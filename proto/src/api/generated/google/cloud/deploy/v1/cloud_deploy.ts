// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/deploy/v1/cloud_deploy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../type/dayofweek.js";
import { TimeOfDay } from "../../../type/timeofday.js";

export const protobufPackage = "google.cloud.deploy.v1";

/** The support state of a specific Skaffold version. */
export enum SkaffoldSupportState {
  /** SKAFFOLD_SUPPORT_STATE_UNSPECIFIED - Default value. This value is unused. */
  SKAFFOLD_SUPPORT_STATE_UNSPECIFIED = 0,
  /** SKAFFOLD_SUPPORT_STATE_SUPPORTED - This Skaffold version is currently supported. */
  SKAFFOLD_SUPPORT_STATE_SUPPORTED = 1,
  /** SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE - This Skaffold version is in maintenance mode. */
  SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE = 2,
  /** SKAFFOLD_SUPPORT_STATE_UNSUPPORTED - This Skaffold version is no longer supported. */
  SKAFFOLD_SUPPORT_STATE_UNSUPPORTED = 3,
  UNRECOGNIZED = -1,
}

export function skaffoldSupportStateFromJSON(object: any): SkaffoldSupportState {
  switch (object) {
    case 0:
    case "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED":
      return SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_UNSPECIFIED;
    case 1:
    case "SKAFFOLD_SUPPORT_STATE_SUPPORTED":
      return SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_SUPPORTED;
    case 2:
    case "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE":
      return SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE;
    case 3:
    case "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED":
      return SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_UNSUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SkaffoldSupportState.UNRECOGNIZED;
  }
}

export function skaffoldSupportStateToJSON(object: SkaffoldSupportState): string {
  switch (object) {
    case SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_UNSPECIFIED:
      return "SKAFFOLD_SUPPORT_STATE_UNSPECIFIED";
    case SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_SUPPORTED:
      return "SKAFFOLD_SUPPORT_STATE_SUPPORTED";
    case SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE:
      return "SKAFFOLD_SUPPORT_STATE_MAINTENANCE_MODE";
    case SkaffoldSupportState.SKAFFOLD_SUPPORT_STATE_UNSUPPORTED:
      return "SKAFFOLD_SUPPORT_STATE_UNSUPPORTED";
    case SkaffoldSupportState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The pattern of how wait time is increased. */
export enum BackoffMode {
  /** BACKOFF_MODE_UNSPECIFIED - No WaitMode is specified. */
  BACKOFF_MODE_UNSPECIFIED = 0,
  /** BACKOFF_MODE_LINEAR - Increases the wait time linearly. */
  BACKOFF_MODE_LINEAR = 1,
  /** BACKOFF_MODE_EXPONENTIAL - Increases the wait time exponentially. */
  BACKOFF_MODE_EXPONENTIAL = 2,
  UNRECOGNIZED = -1,
}

export function backoffModeFromJSON(object: any): BackoffMode {
  switch (object) {
    case 0:
    case "BACKOFF_MODE_UNSPECIFIED":
      return BackoffMode.BACKOFF_MODE_UNSPECIFIED;
    case 1:
    case "BACKOFF_MODE_LINEAR":
      return BackoffMode.BACKOFF_MODE_LINEAR;
    case 2:
    case "BACKOFF_MODE_EXPONENTIAL":
      return BackoffMode.BACKOFF_MODE_EXPONENTIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackoffMode.UNRECOGNIZED;
  }
}

export function backoffModeToJSON(object: BackoffMode): string {
  switch (object) {
    case BackoffMode.BACKOFF_MODE_UNSPECIFIED:
      return "BACKOFF_MODE_UNSPECIFIED";
    case BackoffMode.BACKOFF_MODE_LINEAR:
      return "BACKOFF_MODE_LINEAR";
    case BackoffMode.BACKOFF_MODE_EXPONENTIAL:
      return "BACKOFF_MODE_EXPONENTIAL";
    case BackoffMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid state of a repair attempt. */
export enum RepairState {
  /** REPAIR_STATE_UNSPECIFIED - The `repair` has an unspecified state. */
  REPAIR_STATE_UNSPECIFIED = 0,
  /** REPAIR_STATE_SUCCEEDED - The `repair` action has succeeded. */
  REPAIR_STATE_SUCCEEDED = 1,
  /** REPAIR_STATE_CANCELLED - The `repair` action was cancelled. */
  REPAIR_STATE_CANCELLED = 2,
  /** REPAIR_STATE_FAILED - The `repair` action has failed. */
  REPAIR_STATE_FAILED = 3,
  /** REPAIR_STATE_IN_PROGRESS - The `repair` action is in progress. */
  REPAIR_STATE_IN_PROGRESS = 4,
  /** REPAIR_STATE_PENDING - The `repair` action is pending. */
  REPAIR_STATE_PENDING = 5,
  /** REPAIR_STATE_ABORTED - The `repair` action was aborted. */
  REPAIR_STATE_ABORTED = 7,
  UNRECOGNIZED = -1,
}

export function repairStateFromJSON(object: any): RepairState {
  switch (object) {
    case 0:
    case "REPAIR_STATE_UNSPECIFIED":
      return RepairState.REPAIR_STATE_UNSPECIFIED;
    case 1:
    case "REPAIR_STATE_SUCCEEDED":
      return RepairState.REPAIR_STATE_SUCCEEDED;
    case 2:
    case "REPAIR_STATE_CANCELLED":
      return RepairState.REPAIR_STATE_CANCELLED;
    case 3:
    case "REPAIR_STATE_FAILED":
      return RepairState.REPAIR_STATE_FAILED;
    case 4:
    case "REPAIR_STATE_IN_PROGRESS":
      return RepairState.REPAIR_STATE_IN_PROGRESS;
    case 5:
    case "REPAIR_STATE_PENDING":
      return RepairState.REPAIR_STATE_PENDING;
    case 7:
    case "REPAIR_STATE_ABORTED":
      return RepairState.REPAIR_STATE_ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RepairState.UNRECOGNIZED;
  }
}

export function repairStateToJSON(object: RepairState): string {
  switch (object) {
    case RepairState.REPAIR_STATE_UNSPECIFIED:
      return "REPAIR_STATE_UNSPECIFIED";
    case RepairState.REPAIR_STATE_SUCCEEDED:
      return "REPAIR_STATE_SUCCEEDED";
    case RepairState.REPAIR_STATE_CANCELLED:
      return "REPAIR_STATE_CANCELLED";
    case RepairState.REPAIR_STATE_FAILED:
      return "REPAIR_STATE_FAILED";
    case RepairState.REPAIR_STATE_IN_PROGRESS:
      return "REPAIR_STATE_IN_PROGRESS";
    case RepairState.REPAIR_STATE_PENDING:
      return "REPAIR_STATE_PENDING";
    case RepairState.REPAIR_STATE_ABORTED:
      return "REPAIR_STATE_ABORTED";
    case RepairState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A `DeliveryPipeline` resource in the Cloud Deploy API.
 *
 * A `DeliveryPipeline` defines a pipeline through which a Skaffold
 * configuration can progress.
 */
export interface DeliveryPipeline {
  /**
   * Optional. Name of the `DeliveryPipeline`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}`.
   * The `deliveryPipeline` component must match
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Unique identifier of the `DeliveryPipeline`. */
  uid: string;
  /** Description of the `DeliveryPipeline`. Max length is 255 characters. */
  description: string;
  /**
   * User annotations. These attributes can only be set and used by the
   * user, and not by Cloud Deploy.
   */
  annotations: { [key: string]: string };
  /**
   * Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Output only. Time at which the pipeline was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Most recent time at which the pipeline was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * SerialPipeline defines a sequential set of stages for a
   * `DeliveryPipeline`.
   */
  serialPipeline?:
    | SerialPipeline
    | undefined;
  /** Output only. Information around the state of the Delivery Pipeline. */
  condition:
    | PipelineCondition
    | undefined;
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * When suspended, no new releases or rollouts can be created,
   * but in-progress ones will complete.
   */
  suspended: boolean;
}

export interface DeliveryPipeline_AnnotationsEntry {
  key: string;
  value: string;
}

export interface DeliveryPipeline_LabelsEntry {
  key: string;
  value: string;
}

/** SerialPipeline defines a sequential set of stages for a `DeliveryPipeline`. */
export interface SerialPipeline {
  /**
   * Each stage specifies configuration for a `Target`. The ordering
   * of this list defines the promotion flow.
   */
  stages: Stage[];
}

/** Stage specifies a location to which to deploy. */
export interface Stage {
  /**
   * The target_id to which this stage points. This field refers exclusively to
   * the last segment of a target name. For example, this field would just be
   * `my-target` (rather than
   * `projects/project/locations/location/targets/my-target`). The location of
   * the `Target` is inferred to be the same as the location of the
   * `DeliveryPipeline` that contains this `Stage`.
   */
  targetId: string;
  /**
   * Skaffold profiles to use when rendering the manifest for this stage's
   * `Target`.
   */
  profiles: string[];
  /** Optional. The strategy to use for a `Rollout` to this stage. */
  strategy:
    | Strategy
    | undefined;
  /** Optional. The deploy parameters to use for the target in this stage. */
  deployParameters: DeployParameters[];
}

/** DeployParameters contains deploy parameters information. */
export interface DeployParameters {
  /** Required. Values are deploy parameters in key-value pairs. */
  values: { [key: string]: string };
  /**
   * Optional. Deploy parameters are applied to targets with match labels.
   * If unspecified, deploy parameters are applied to all targets (including
   * child targets of a multi-target).
   */
  matchTargetLabels: { [key: string]: string };
}

export interface DeployParameters_ValuesEntry {
  key: string;
  value: string;
}

export interface DeployParameters_MatchTargetLabelsEntry {
  key: string;
  value: string;
}

/** Strategy contains deployment strategy information. */
export interface Strategy {
  /**
   * Standard deployment strategy executes a single deploy and allows
   * verifying the deployment.
   */
  standard?:
    | Standard
    | undefined;
  /**
   * Canary deployment strategy provides progressive percentage based
   * deployments to a Target.
   */
  canary?: Canary | undefined;
}

/** Predeploy contains the predeploy job configuration information. */
export interface Predeploy {
  /**
   * Optional. A sequence of Skaffold custom actions to invoke during execution
   * of the predeploy job.
   */
  actions: string[];
}

/** Postdeploy contains the postdeploy job configuration information. */
export interface Postdeploy {
  /**
   * Optional. A sequence of Skaffold custom actions to invoke during execution
   * of the postdeploy job.
   */
  actions: string[];
}

/** Standard represents the standard deployment strategy. */
export interface Standard {
  /** Whether to verify a deployment. */
  verify: boolean;
  /**
   * Optional. Configuration for the predeploy job. If this is not configured,
   * predeploy job will not be present.
   */
  predeploy:
    | Predeploy
    | undefined;
  /**
   * Optional. Configuration for the postdeploy job. If this is not configured,
   * postdeploy job will not be present.
   */
  postdeploy: Postdeploy | undefined;
}

/** Canary represents the canary deployment strategy. */
export interface Canary {
  /**
   * Optional. Runtime specific configurations for the deployment strategy. The
   * runtime configuration is used to determine how Cloud Deploy will split
   * traffic to enable a progressive deployment.
   */
  runtimeConfig:
    | RuntimeConfig
    | undefined;
  /** Configures the progressive based deployment for a Target. */
  canaryDeployment?:
    | CanaryDeployment
    | undefined;
  /**
   * Configures the progressive based deployment for a Target, but allows
   * customizing at the phase level where a phase represents each of the
   * percentage deployments.
   */
  customCanaryDeployment?: CustomCanaryDeployment | undefined;
}

/** CanaryDeployment represents the canary deployment configuration */
export interface CanaryDeployment {
  /**
   * Required. The percentage based deployments that will occur as a part of a
   * `Rollout`. List is expected in ascending order and each integer n is
   * 0 <= n < 100.
   * If the GatewayServiceMesh is configured for Kubernetes, then the range for
   * n is 0 <= n <= 100.
   */
  percentages: number[];
  /** Whether to run verify tests after each percentage deployment. */
  verify: boolean;
  /**
   * Optional. Configuration for the predeploy job of the first phase. If this
   * is not configured, there will be no predeploy job for this phase.
   */
  predeploy:
    | Predeploy
    | undefined;
  /**
   * Optional. Configuration for the postdeploy job of the last phase. If this
   * is not configured, there will be no postdeploy job for this phase.
   */
  postdeploy: Postdeploy | undefined;
}

/**
 * CustomCanaryDeployment represents the custom canary deployment
 * configuration.
 */
export interface CustomCanaryDeployment {
  /**
   * Required. Configuration for each phase in the canary deployment in the
   * order executed.
   */
  phaseConfigs: CustomCanaryDeployment_PhaseConfig[];
}

/**
 * PhaseConfig represents the configuration for a phase in the custom
 * canary deployment.
 */
export interface CustomCanaryDeployment_PhaseConfig {
  /**
   * Required. The ID to assign to the `Rollout` phase.
   * This value must consist of lower-case letters, numbers, and hyphens,
   * start with a letter and end with a letter or a number, and have a max
   * length of 63 characters. In other words, it must match the following
   * regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
   */
  phaseId: string;
  /** Required. Percentage deployment for the phase. */
  percentage: number;
  /**
   * Skaffold profiles to use when rendering the manifest for this phase.
   * These are in addition to the profiles list specified in the
   * `DeliveryPipeline` stage.
   */
  profiles: string[];
  /** Whether to run verify tests after the deployment. */
  verify: boolean;
  /**
   * Optional. Configuration for the predeploy job of this phase. If this is
   * not configured, there will be no predeploy job for this phase.
   */
  predeploy:
    | Predeploy
    | undefined;
  /**
   * Optional. Configuration for the postdeploy job of this phase. If this is
   * not configured, there will be no postdeploy job for this phase.
   */
  postdeploy: Postdeploy | undefined;
}

/** KubernetesConfig contains the Kubernetes runtime configuration. */
export interface KubernetesConfig {
  /** Kubernetes Gateway API service mesh configuration. */
  gatewayServiceMesh?:
    | KubernetesConfig_GatewayServiceMesh
    | undefined;
  /** Kubernetes Service networking configuration. */
  serviceNetworking?: KubernetesConfig_ServiceNetworking | undefined;
}

/** Information about the Kubernetes Gateway API service mesh configuration. */
export interface KubernetesConfig_GatewayServiceMesh {
  /** Required. Name of the Gateway API HTTPRoute. */
  httpRoute: string;
  /** Required. Name of the Kubernetes Service. */
  service: string;
  /**
   * Required. Name of the Kubernetes Deployment whose traffic is managed by
   * the specified HTTPRoute and Service.
   */
  deployment: string;
  /**
   * Optional. The time to wait for route updates to propagate. The maximum
   * configurable time is 3 hours, in seconds format. If unspecified, there is
   * no wait time.
   */
  routeUpdateWaitTime:
    | Duration
    | undefined;
  /**
   * Optional. The amount of time to migrate traffic back from the canary
   * Service to the original Service during the stable phase deployment. If
   * specified, must be between 15s and 3600s. If unspecified, there is no
   * cutback time.
   */
  stableCutbackDuration:
    | Duration
    | undefined;
  /**
   * Optional. The label to use when selecting Pods for the Deployment and
   * Service resources. This label must already be present in both resources.
   */
  podSelectorLabel: string;
}

/** Information about the Kubernetes Service networking configuration. */
export interface KubernetesConfig_ServiceNetworking {
  /** Required. Name of the Kubernetes Service. */
  service: string;
  /**
   * Required. Name of the Kubernetes Deployment whose traffic is managed by
   * the specified Service.
   */
  deployment: string;
  /**
   * Optional. Whether to disable Pod overprovisioning. If Pod
   * overprovisioning is disabled then Cloud Deploy will limit the number of
   * total Pods used for the deployment strategy to the number of Pods the
   * Deployment has on the cluster.
   */
  disablePodOverprovisioning: boolean;
  /**
   * Optional. The label to use when selecting Pods for the Deployment
   * resource. This label must already be present in the Deployment.
   */
  podSelectorLabel: string;
}

/** CloudRunConfig contains the Cloud Run runtime configuration. */
export interface CloudRunConfig {
  /**
   * Whether Cloud Deploy should update the traffic stanza in a Cloud Run
   * Service on the user's behalf to facilitate traffic splitting. This is
   * required to be true for CanaryDeployments, but optional for
   * CustomCanaryDeployments.
   */
  automaticTrafficControl: boolean;
  /**
   * Optional. A list of tags that are added to the canary revision while the
   * canary phase is in progress.
   */
  canaryRevisionTags: string[];
  /**
   * Optional. A list of tags that are added to the prior revision while the
   * canary phase is in progress.
   */
  priorRevisionTags: string[];
  /**
   * Optional. A list of tags that are added to the final stable revision when
   * the stable phase is applied.
   */
  stableRevisionTags: string[];
}

/**
 * RuntimeConfig contains the runtime specific configurations for a deployment
 * strategy.
 */
export interface RuntimeConfig {
  /** Kubernetes runtime configuration. */
  kubernetes?:
    | KubernetesConfig
    | undefined;
  /** Cloud Run runtime configuration. */
  cloudRun?: CloudRunConfig | undefined;
}

/**
 * PipelineReadyCondition contains information around the status of the
 * Pipeline.
 */
export interface PipelineReadyCondition {
  /**
   * True if the Pipeline is in a valid state. Otherwise at least one condition
   * in `PipelineCondition` is in an invalid state. Iterate over those
   * conditions and see which condition(s) has status = false to find out what
   * is wrong with the Pipeline.
   */
  status: boolean;
  /** Last time the condition was updated. */
  updateTime: Date | undefined;
}

/**
 * `TargetsPresentCondition` contains information on any Targets referenced in
 * the Delivery Pipeline that do not actually exist.
 */
export interface TargetsPresentCondition {
  /** True if there aren't any missing Targets. */
  status: boolean;
  /**
   * The list of Target names that do not exist. For example,
   * `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
   */
  missingTargets: string[];
  /** Last time the condition was updated. */
  updateTime: Date | undefined;
}

/**
 * TargetsTypeCondition contains information on whether the Targets defined in
 * the Delivery Pipeline are of the same type.
 */
export interface TargetsTypeCondition {
  /**
   * True if the targets are all a comparable type. For example this is true if
   * all targets are GKE clusters. This is false if some targets are Cloud Run
   * targets and others are GKE clusters.
   */
  status: boolean;
  /** Human readable error message. */
  errorDetails: string;
}

/** PipelineCondition contains all conditions relevant to a Delivery Pipeline. */
export interface PipelineCondition {
  /** Details around the Pipeline's overall status. */
  pipelineReadyCondition:
    | PipelineReadyCondition
    | undefined;
  /** Details around targets enumerated in the pipeline. */
  targetsPresentCondition:
    | TargetsPresentCondition
    | undefined;
  /**
   * Details on the whether the targets enumerated in the pipeline are of the
   * same type.
   */
  targetsTypeCondition: TargetsTypeCondition | undefined;
}

/** The request object for `ListDeliveryPipelines`. */
export interface ListDeliveryPipelinesRequest {
  /**
   * Required. The parent, which owns this collection of pipelines. Format must
   * be `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /**
   * The maximum number of pipelines to return. The service may return
   * fewer than this value. If unspecified, at most 50 pipelines will
   * be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDeliveryPipelines` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Filter pipelines to be returned. See https://google.aip.dev/160 for more
   * details.
   */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** The response object from `ListDeliveryPipelines`. */
export interface ListDeliveryPipelinesResponse {
  /** The `DeliveryPipeline` objects. */
  deliveryPipelines: DeliveryPipeline[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetDeliveryPipeline` */
export interface GetDeliveryPipelineRequest {
  /**
   * Required. Name of the `DeliveryPipeline`. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  name: string;
}

/** The request object for `CreateDeliveryPipeline`. */
export interface CreateDeliveryPipelineRequest {
  /**
   * Required. The parent collection in which the `DeliveryPipeline` must be
   * created. The format is `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /** Required. ID of the `DeliveryPipeline`. */
  deliveryPipelineId: string;
  /** Required. The `DeliveryPipeline` to create. */
  deliveryPipeline:
    | DeliveryPipeline
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `UpdateDeliveryPipeline`. */
export interface UpdateDeliveryPipelineRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten by the
   * update in the `DeliveryPipeline` resource. The fields specified in the
   * update_mask are relative to the resource, not the full request. A field
   * will be overwritten if it's in the mask. If the user doesn't provide a mask
   * then all fields are overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The `DeliveryPipeline` to update. */
  deliveryPipeline:
    | DeliveryPipeline
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, updating a `DeliveryPipeline` that does not exist
   * will result in the creation of a new `DeliveryPipeline`.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `DeleteDeliveryPipeline`. */
export interface DeleteDeliveryPipelineRequest {
  /**
   * Required. The name of the `DeliveryPipeline` to delete. The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, then deleting an already deleted or non-existing
   * `DeliveryPipeline` will succeed.
   */
  allowMissing: boolean;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually post it.
   */
  validateOnly: boolean;
  /**
   * Optional. If set to true, all child resources under this pipeline will also
   * be deleted. Otherwise, the request will only work if the pipeline has no
   * child resources.
   */
  force: boolean;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/** Configs for the Rollback rollout. */
export interface RollbackTargetConfig {
  /** Optional. The rollback `Rollout` to create. */
  rollout:
    | Rollout
    | undefined;
  /**
   * Optional. The starting phase ID for the `Rollout`. If unspecified, the
   * `Rollout` will start in the stable phase.
   */
  startingPhaseId: string;
}

/** The request object for `RollbackTarget`. */
export interface RollbackTargetRequest {
  /**
   * Required. The `DeliveryPipeline` for which the rollback `Rollout` must be
   * created. The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  name: string;
  /** Required. ID of the `Target` that is being rolled back. */
  targetId: string;
  /** Required. ID of the rollback `Rollout` to create. */
  rolloutId: string;
  /**
   * Optional. ID of the `Release` to roll back to. If this isn't specified, the
   * previous successful `Rollout` to the specified target will be used to
   * determine the `Release`.
   */
  releaseId: string;
  /**
   * Optional. If provided, this must be the latest `Rollout` that is on the
   * `Target`.
   */
  rolloutToRollBack: string;
  /** Optional. Configs for the rollback `Rollout`. */
  rollbackConfig:
    | RollbackTargetConfig
    | undefined;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with a `RollbackTargetResponse`.
   */
  validateOnly: boolean;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deploy_policy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `RollbackTarget`. */
export interface RollbackTargetResponse {
  /** The config of the rollback `Rollout` created or will be created. */
  rollbackConfig: RollbackTargetConfig | undefined;
}

/**
 * A `Target` resource in the Cloud Deploy API.
 *
 * A `Target` defines a location to which a Skaffold configuration
 * can be deployed.
 */
export interface Target {
  /**
   * Optional. Name of the `Target`. Format is
   * `projects/{project}/locations/{location}/targets/{target}`.
   * The `target` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Resource id of the `Target`. */
  targetId: string;
  /** Output only. Unique identifier of the `Target`. */
  uid: string;
  /** Optional. Description of the `Target`. Max length is 255 characters. */
  description: string;
  /**
   * Optional. User annotations. These attributes can only be set and used by
   * the user, and not by Cloud Deploy. See
   * https://google.aip.dev/128#annotations for more details such as format and
   * size limitations.
   */
  annotations: { [key: string]: string };
  /**
   * Optional. Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Optional. Whether or not the `Target` requires approval. */
  requireApproval: boolean;
  /** Output only. Time at which the `Target` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Most recent time at which the `Target` was updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Information specifying a GKE Cluster. */
  gke?:
    | GkeCluster
    | undefined;
  /** Optional. Information specifying an Anthos Cluster. */
  anthosCluster?:
    | AnthosCluster
    | undefined;
  /** Optional. Information specifying a Cloud Run deployment target. */
  run?:
    | CloudRunLocation
    | undefined;
  /** Optional. Information specifying a multiTarget. */
  multiTarget?:
    | MultiTarget
    | undefined;
  /** Optional. Information specifying a Custom Target. */
  customTarget?:
    | CustomTarget
    | undefined;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Configurations for all execution that relates to this `Target`.
   * Each `ExecutionEnvironmentUsage` value may only be used in a single
   * configuration; using the same value multiple times is an error.
   * When one or more configurations are specified, they must include the
   * `RENDER` and `DEPLOY` `ExecutionEnvironmentUsage` values.
   * When no configurations are specified, execution will use the default
   * specified in `DefaultPool`.
   */
  executionConfigs: ExecutionConfig[];
  /** Optional. The deploy parameters to use for this target. */
  deployParameters: { [key: string]: string };
}

export interface Target_AnnotationsEntry {
  key: string;
  value: string;
}

export interface Target_LabelsEntry {
  key: string;
  value: string;
}

export interface Target_DeployParametersEntry {
  key: string;
  value: string;
}

/** Configuration of the environment to use when calling Skaffold. */
export interface ExecutionConfig {
  /** Required. Usages when this configuration should be applied. */
  usages: ExecutionConfig_ExecutionEnvironmentUsage[];
  /** Optional. Use default Cloud Build pool. */
  defaultPool?:
    | DefaultPool
    | undefined;
  /** Optional. Use private Cloud Build pool. */
  privatePool?:
    | PrivatePool
    | undefined;
  /**
   * Optional. The resource name of the `WorkerPool`, with the format
   * `projects/{project}/locations/{location}/workerPools/{worker_pool}`.
   * If this optional field is unspecified, the default Cloud Build pool will be
   * used.
   */
  workerPool: string;
  /**
   * Optional. Google service account to use for execution. If unspecified,
   * the project execution service account
   * (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) is used.
   */
  serviceAccount: string;
  /**
   * Optional. Cloud Storage location in which to store execution outputs. This
   * can either be a bucket ("gs://my-bucket") or a path within a bucket
   * ("gs://my-bucket/my-dir").
   * If unspecified, a default bucket located in the same region will be used.
   */
  artifactStorage: string;
  /**
   * Optional. Execution timeout for a Cloud Build Execution. This must be
   * between 10m and 24h in seconds format. If unspecified, a default timeout of
   * 1h is used.
   */
  executionTimeout:
    | Duration
    | undefined;
  /**
   * Optional. If true, additional logging will be enabled when running builds
   * in this execution environment.
   */
  verbose: boolean;
}

/** Possible usages of this configuration. */
export enum ExecutionConfig_ExecutionEnvironmentUsage {
  /** EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED - Default value. This value is unused. */
  EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED = 0,
  /** RENDER - Use for rendering. */
  RENDER = 1,
  /** DEPLOY - Use for deploying and deployment hooks. */
  DEPLOY = 2,
  /** VERIFY - Use for deployment verification. */
  VERIFY = 3,
  /** PREDEPLOY - Use for predeploy job execution. */
  PREDEPLOY = 4,
  /** POSTDEPLOY - Use for postdeploy job execution. */
  POSTDEPLOY = 5,
  UNRECOGNIZED = -1,
}

export function executionConfig_ExecutionEnvironmentUsageFromJSON(
  object: any,
): ExecutionConfig_ExecutionEnvironmentUsage {
  switch (object) {
    case 0:
    case "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED":
      return ExecutionConfig_ExecutionEnvironmentUsage.EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED;
    case 1:
    case "RENDER":
      return ExecutionConfig_ExecutionEnvironmentUsage.RENDER;
    case 2:
    case "DEPLOY":
      return ExecutionConfig_ExecutionEnvironmentUsage.DEPLOY;
    case 3:
    case "VERIFY":
      return ExecutionConfig_ExecutionEnvironmentUsage.VERIFY;
    case 4:
    case "PREDEPLOY":
      return ExecutionConfig_ExecutionEnvironmentUsage.PREDEPLOY;
    case 5:
    case "POSTDEPLOY":
      return ExecutionConfig_ExecutionEnvironmentUsage.POSTDEPLOY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionConfig_ExecutionEnvironmentUsage.UNRECOGNIZED;
  }
}

export function executionConfig_ExecutionEnvironmentUsageToJSON(
  object: ExecutionConfig_ExecutionEnvironmentUsage,
): string {
  switch (object) {
    case ExecutionConfig_ExecutionEnvironmentUsage.EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED:
      return "EXECUTION_ENVIRONMENT_USAGE_UNSPECIFIED";
    case ExecutionConfig_ExecutionEnvironmentUsage.RENDER:
      return "RENDER";
    case ExecutionConfig_ExecutionEnvironmentUsage.DEPLOY:
      return "DEPLOY";
    case ExecutionConfig_ExecutionEnvironmentUsage.VERIFY:
      return "VERIFY";
    case ExecutionConfig_ExecutionEnvironmentUsage.PREDEPLOY:
      return "PREDEPLOY";
    case ExecutionConfig_ExecutionEnvironmentUsage.POSTDEPLOY:
      return "POSTDEPLOY";
    case ExecutionConfig_ExecutionEnvironmentUsage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Execution using the default Cloud Build pool. */
export interface DefaultPool {
  /**
   * Optional. Google service account to use for execution. If unspecified,
   * the project execution service account
   * (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
   */
  serviceAccount: string;
  /**
   * Optional. Cloud Storage location where execution outputs should be stored.
   * This can either be a bucket ("gs://my-bucket") or a path within a bucket
   * ("gs://my-bucket/my-dir").
   * If unspecified, a default bucket located in the same region will be used.
   */
  artifactStorage: string;
}

/** Execution using a private Cloud Build pool. */
export interface PrivatePool {
  /**
   * Required. Resource name of the Cloud Build worker pool to use. The format
   * is `projects/{project}/locations/{location}/workerPools/{pool}`.
   */
  workerPool: string;
  /**
   * Optional. Google service account to use for execution. If unspecified,
   * the project execution service account
   * (<PROJECT_NUMBER>-compute@developer.gserviceaccount.com) will be used.
   */
  serviceAccount: string;
  /**
   * Optional. Cloud Storage location where execution outputs should be stored.
   * This can either be a bucket ("gs://my-bucket") or a path within a bucket
   * ("gs://my-bucket/my-dir").
   * If unspecified, a default bucket located in the same region will be used.
   */
  artifactStorage: string;
}

/** Information specifying a GKE Cluster. */
export interface GkeCluster {
  /**
   * Optional. Information specifying a GKE Cluster. Format is
   * `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`.
   */
  cluster: string;
  /**
   * Optional. If true, `cluster` is accessed using the private IP address of
   * the control plane endpoint. Otherwise, the default IP address of the
   * control plane endpoint is used. The default IP address is the private IP
   * address for clusters with private control-plane endpoints and the public IP
   * address otherwise.
   *
   * Only specify this option when `cluster` is a [private GKE
   * cluster](https://cloud.google.com/kubernetes-engine/docs/concepts/private-cluster-concept).
   */
  internalIp: boolean;
  /**
   * Optional. If set, used to configure a
   * [proxy](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#proxy)
   * to the Kubernetes server.
   */
  proxyUrl: string;
}

/** Information specifying an Anthos Cluster. */
export interface AnthosCluster {
  /**
   * Optional. Membership of the GKE Hub-registered cluster to which to apply
   * the Skaffold configuration. Format is
   * `projects/{project}/locations/{location}/memberships/{membership_name}`.
   */
  membership: string;
}

/** Information specifying where to deploy a Cloud Run Service. */
export interface CloudRunLocation {
  /**
   * Required. The location for the Cloud Run Service. Format must be
   * `projects/{project}/locations/{location}`.
   */
  location: string;
}

/** Information specifying a multiTarget. */
export interface MultiTarget {
  /** Required. The target_ids of this multiTarget. */
  targetIds: string[];
}

/** Information specifying a Custom Target. */
export interface CustomTarget {
  /**
   * Required. The name of the CustomTargetType. Format must be
   * `projects/{project}/locations/{location}/customTargetTypes/{custom_target_type}`.
   */
  customTargetType: string;
}

/** The request object for `ListTargets`. */
export interface ListTargetsRequest {
  /**
   * Required. The parent, which owns this collection of targets. Format must be
   * `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of `Target` objects to return. The service may
   * return fewer than this value. If unspecified, at most 50 `Target` objects
   * will be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListTargets` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter targets to be returned. See https://google.aip.dev/160 for
   * more details.
   */
  filter: string;
  /**
   * Optional. Field to sort by. See https://google.aip.dev/132#ordering for
   * more details.
   */
  orderBy: string;
}

/** The response object from `ListTargets`. */
export interface ListTargetsResponse {
  /** The `Target` objects. */
  targets: Target[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetTarget`. */
export interface GetTargetRequest {
  /**
   * Required. Name of the `Target`. Format must be
   * `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
   */
  name: string;
}

/** The request object for `CreateTarget`. */
export interface CreateTargetRequest {
  /**
   * Required. The parent collection in which the `Target` must be created.
   * The format is
   * `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /** Required. ID of the `Target`. */
  targetId: string;
  /** Required. The `Target` to create. */
  target:
    | Target
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `UpdateTarget`. */
export interface UpdateTargetRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten by the
   * update in the `Target` resource. The fields specified in the update_mask
   * are relative to the resource, not the full request. A field will be
   * overwritten if it's in the mask. If the user doesn't provide a mask then
   * all fields are overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The `Target` to update. */
  target:
    | Target
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, updating a `Target` that does not exist will
   * result in the creation of a new `Target`.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `DeleteTarget`. */
export interface DeleteTargetRequest {
  /**
   * Required. The name of the `Target` to delete. The format is
   * `projects/{project_id}/locations/{location_name}/targets/{target_name}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, then deleting an already deleted or non-existing
   * `Target` will succeed.
   */
  allowMissing: boolean;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually post it.
   */
  validateOnly: boolean;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/**
 * A `CustomTargetType` resource in the Cloud Deploy API.
 *
 * A `CustomTargetType` defines a type of custom target that can be referenced
 * in a `Target` in order to facilitate deploying to other systems besides the
 * supported runtimes.
 */
export interface CustomTargetType {
  /**
   * Optional. Name of the `CustomTargetType`. Format is
   * `projects/{project}/locations/{location}/customTargetTypes/{customTargetType}`.
   * The `customTargetType` component must match
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Resource id of the `CustomTargetType`. */
  customTargetTypeId: string;
  /** Output only. Unique identifier of the `CustomTargetType`. */
  uid: string;
  /**
   * Optional. Description of the `CustomTargetType`. Max length is 255
   * characters.
   */
  description: string;
  /**
   * Optional. User annotations. These attributes can only be set and used by
   * the user, and not by Cloud Deploy. See
   * https://google.aip.dev/128#annotations for more details such as format and
   * size limitations.
   */
  annotations: { [key: string]: string };
  /**
   * Optional. Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Output only. Time at which the `CustomTargetType` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Most recent time at which the `CustomTargetType` was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Configures render and deploy for the `CustomTargetType` using Skaffold
   * custom actions.
   */
  customActions?: CustomTargetSkaffoldActions | undefined;
}

export interface CustomTargetType_AnnotationsEntry {
  key: string;
  value: string;
}

export interface CustomTargetType_LabelsEntry {
  key: string;
  value: string;
}

/**
 * CustomTargetSkaffoldActions represents the `CustomTargetType` configuration
 * using Skaffold custom actions.
 */
export interface CustomTargetSkaffoldActions {
  /**
   * Optional. The Skaffold custom action responsible for render operations. If
   * not provided then Cloud Deploy will perform the render operations via
   * `skaffold render`.
   */
  renderAction: string;
  /** Required. The Skaffold custom action responsible for deploy operations. */
  deployAction: string;
  /**
   * Optional. List of Skaffold modules Cloud Deploy will include in the
   * Skaffold Config as required before performing diagnose.
   */
  includeSkaffoldModules: SkaffoldModules[];
}

/** Skaffold Config modules and their remote source. */
export interface SkaffoldModules {
  /** Optional. The Skaffold Config modules to use from the specified source. */
  configs: string[];
  /** Remote git repository containing the Skaffold Config modules. */
  git?:
    | SkaffoldModules_SkaffoldGitSource
    | undefined;
  /** Cloud Storage bucket containing the Skaffold Config modules. */
  googleCloudStorage?:
    | SkaffoldModules_SkaffoldGCSSource
    | undefined;
  /** Cloud Build V2 repository containing the Skaffold Config modules. */
  googleCloudBuildRepo?: SkaffoldModules_SkaffoldGCBRepoSource | undefined;
}

/** Git repository containing Skaffold Config modules. */
export interface SkaffoldModules_SkaffoldGitSource {
  /** Required. Git repository the package should be cloned from. */
  repo: string;
  /** Optional. Relative path from the repository root to the Skaffold file. */
  path: string;
  /** Optional. Git branch or tag to use when cloning the repository. */
  ref: string;
}

/** Cloud Storage bucket containing Skaffold Config modules. */
export interface SkaffoldModules_SkaffoldGCSSource {
  /**
   * Required. Cloud Storage source paths to copy recursively. For example,
   * providing "gs://my-bucket/dir/configs/*" will result in Skaffold copying
   * all files within the "dir/configs" directory in the bucket "my-bucket".
   */
  source: string;
  /** Optional. Relative path from the source to the Skaffold file. */
  path: string;
}

/** Cloud Build V2 Repository containing Skaffold Configs. */
export interface SkaffoldModules_SkaffoldGCBRepoSource {
  /**
   * Required. Name of the Cloud Build V2 Repository.
   * Format is
   * projects/{project}/locations/{location}/connections/{connection}/repositories/{repository}.
   */
  repository: string;
  /**
   * Optional. Relative path from the repository root to the Skaffold Config
   * file.
   */
  path: string;
  /** Optional. Branch or tag to use when cloning the repository. */
  ref: string;
}

/** The request object for `ListCustomTargetTypes`. */
export interface ListCustomTargetTypesRequest {
  /**
   * Required. The parent that owns this collection of custom target types.
   * Format must be `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of `CustomTargetType` objects to return. The
   * service may return fewer than this value. If unspecified, at most 50
   * `CustomTargetType` objects will be returned. The maximum value is 1000;
   * values above 1000 will be set to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListCustomTargetTypes`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter custom target types to be returned. See
   * https://google.aip.dev/160 for more details.
   */
  filter: string;
  /**
   * Optional. Field to sort by. See https://google.aip.dev/132#ordering for
   * more details.
   */
  orderBy: string;
}

/** The response object from `ListCustomTargetTypes.` */
export interface ListCustomTargetTypesResponse {
  /** The `CustomTargetType` objects. */
  customTargetTypes: CustomTargetType[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetCustomTargetType`. */
export interface GetCustomTargetTypeRequest {
  /**
   * Required. Name of the `CustomTargetType`. Format must be
   * `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
   */
  name: string;
}

/** The request object for `CreateCustomTargetType`. */
export interface CreateCustomTargetTypeRequest {
  /**
   * Required. The parent collection in which the `CustomTargetType` must be
   * created. The format is `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /** Required. ID of the `CustomTargetType`. */
  customTargetTypeId: string;
  /** Required. The `CustomTargetType` to create. */
  customTargetType:
    | CustomTargetType
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `UpdateCustomTargetType`. */
export interface UpdateCustomTargetTypeRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten by the
   * update in the `CustomTargetType` resource. The fields specified in the
   * update_mask are relative to the resource, not the full request. A field
   * will be overwritten if it's in the mask. If the user doesn't provide a mask
   * then all fields are overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The `CustomTargetType` to update. */
  customTargetType:
    | CustomTargetType
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, updating a `CustomTargetType` that does not exist
   * will result in the creation of a new `CustomTargetType`.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `DeleteCustomTargetType`. */
export interface DeleteCustomTargetTypeRequest {
  /**
   * Required. The name of the `CustomTargetType` to delete. Format must be
   * `projects/{project_id}/locations/{location_name}/customTargetTypes/{custom_target_type}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, then deleting an already deleted or non-existing
   * `CustomTargetType` will succeed.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated but no actual change is
   * made.
   */
  validateOnly: boolean;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/**
 * A `DeployPolicy` resource in the Cloud Deploy API.
 *
 * A `DeployPolicy` inhibits manual or automation-driven actions within a
 * Delivery Pipeline or Target.
 */
export interface DeployPolicy {
  /**
   * Output only. Name of the `DeployPolicy`. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   * The `deployPolicy` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Unique identifier of the `DeployPolicy`. */
  uid: string;
  /** Description of the `DeployPolicy`. Max length is 255 characters. */
  description: string;
  /**
   * User annotations. These attributes can only be set and used by the
   * user, and not by Cloud Deploy. Annotations must meet the following
   * constraints:
   *
   * * Annotations are key/value pairs.
   * * Valid annotation keys have two segments: an optional prefix and name,
   * separated by a slash (`/`).
   * * The name segment is required and must be 63 characters or less,
   * beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
   * dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
   * * The prefix is optional. If specified, the prefix must be a DNS subdomain:
   * a series of DNS labels separated by dots(`.`), not longer than 253
   * characters in total, followed by a slash (`/`).
   *
   * See
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
   * for more details.
   */
  annotations: { [key: string]: string };
  /**
   * Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Output only. Time at which the deploy policy was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Most recent time at which the deploy policy was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * When suspended, the policy will not prevent actions from occurring, even
   * if the action violates the policy.
   */
  suspended: boolean;
  /**
   * Required. Selected resources to which the policy will be applied. At least
   * one selector is required. If one selector matches the resource the policy
   * applies. For example, if there are two selectors and the action being
   * attempted matches one of them, the policy will apply to that action.
   */
  selectors: DeployPolicyResourceSelector[];
  /** Required. Rules to apply. At least one rule must be present. */
  rules: PolicyRule[];
  /**
   * The weak etag of the `Automation` resource.
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/**
 * What invoked the action. Filters enforcing the policy depending on what
 * invoked the action.
 */
export enum DeployPolicy_Invoker {
  /** INVOKER_UNSPECIFIED - Unspecified. */
  INVOKER_UNSPECIFIED = 0,
  /**
   * USER - The action is user-driven. For example, creating a rollout manually via a
   * gcloud create command.
   */
  USER = 1,
  /** DEPLOY_AUTOMATION - Automated action by Cloud Deploy. */
  DEPLOY_AUTOMATION = 2,
  UNRECOGNIZED = -1,
}

export function deployPolicy_InvokerFromJSON(object: any): DeployPolicy_Invoker {
  switch (object) {
    case 0:
    case "INVOKER_UNSPECIFIED":
      return DeployPolicy_Invoker.INVOKER_UNSPECIFIED;
    case 1:
    case "USER":
      return DeployPolicy_Invoker.USER;
    case 2:
    case "DEPLOY_AUTOMATION":
      return DeployPolicy_Invoker.DEPLOY_AUTOMATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeployPolicy_Invoker.UNRECOGNIZED;
  }
}

export function deployPolicy_InvokerToJSON(object: DeployPolicy_Invoker): string {
  switch (object) {
    case DeployPolicy_Invoker.INVOKER_UNSPECIFIED:
      return "INVOKER_UNSPECIFIED";
    case DeployPolicy_Invoker.USER:
      return "USER";
    case DeployPolicy_Invoker.DEPLOY_AUTOMATION:
      return "DEPLOY_AUTOMATION";
    case DeployPolicy_Invoker.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DeployPolicy_AnnotationsEntry {
  key: string;
  value: string;
}

export interface DeployPolicy_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Contains information on the resources to select for a deploy policy.
 * Attributes provided must all match the resource in order for policy
 * restrictions to apply. For example, if delivery pipelines attributes given
 * are an id "prod" and labels "foo: bar", a delivery pipeline resource must
 * match both that id and have that label in order to be subject to the policy.
 */
export interface DeployPolicyResourceSelector {
  /** Optional. Contains attributes about a delivery pipeline. */
  deliveryPipeline:
    | DeliveryPipelineAttribute
    | undefined;
  /** Optional. Contains attributes about a target. */
  target: TargetAttribute | undefined;
}

/** Contains criteria for selecting DeliveryPipelines. */
export interface DeliveryPipelineAttribute {
  /**
   * ID of the `DeliveryPipeline`. The value of this field could be one of the
   * following:
   *
   * * The last segment of a pipeline name
   * * "*", all delivery pipelines in a location
   */
  id: string;
  /** DeliveryPipeline labels. */
  labels: { [key: string]: string };
}

export interface DeliveryPipelineAttribute_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Contains criteria for selecting Targets. This could be used to select targets
 * for a Deploy Policy or for an Automation.
 */
export interface TargetAttribute {
  /**
   * ID of the `Target`. The value of this field could be one of the
   * following:
   *
   * * The last segment of a target name
   * * "*", all targets in a location
   */
  id: string;
  /** Target labels. */
  labels: { [key: string]: string };
}

export interface TargetAttribute_LabelsEntry {
  key: string;
  value: string;
}

/** Deploy Policy rule. */
export interface PolicyRule {
  /** Rollout restrictions. */
  rolloutRestriction?: RolloutRestriction | undefined;
}

/** Rollout restrictions. */
export interface RolloutRestriction {
  /**
   * Required. Restriction rule ID. Required and must be unique within a
   * DeployPolicy. The format is `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  id: string;
  /**
   * Optional. What invoked the action. If left empty, all invoker types will be
   * restricted.
   */
  invokers: DeployPolicy_Invoker[];
  /**
   * Optional. Rollout actions to be restricted as part of the policy. If left
   * empty, all actions will be restricted.
   */
  actions: RolloutRestriction_RolloutActions[];
  /** Required. Time window within which actions are restricted. */
  timeWindows: TimeWindows | undefined;
}

/** Rollout actions to be restricted as part of the policy. */
export enum RolloutRestriction_RolloutActions {
  /** ROLLOUT_ACTIONS_UNSPECIFIED - Unspecified. */
  ROLLOUT_ACTIONS_UNSPECIFIED = 0,
  /** ADVANCE - Advance the rollout to the next phase. */
  ADVANCE = 1,
  /** APPROVE - Approve the rollout. */
  APPROVE = 2,
  /** CANCEL - Cancel the rollout. */
  CANCEL = 3,
  /** CREATE - Create a rollout. */
  CREATE = 4,
  /** IGNORE_JOB - Ignore a job result on the rollout. */
  IGNORE_JOB = 5,
  /** RETRY_JOB - Retry a job for a rollout. */
  RETRY_JOB = 6,
  /** ROLLBACK - Rollback a rollout. */
  ROLLBACK = 7,
  /** TERMINATE_JOBRUN - Terminate a jobrun. */
  TERMINATE_JOBRUN = 8,
  UNRECOGNIZED = -1,
}

export function rolloutRestriction_RolloutActionsFromJSON(object: any): RolloutRestriction_RolloutActions {
  switch (object) {
    case 0:
    case "ROLLOUT_ACTIONS_UNSPECIFIED":
      return RolloutRestriction_RolloutActions.ROLLOUT_ACTIONS_UNSPECIFIED;
    case 1:
    case "ADVANCE":
      return RolloutRestriction_RolloutActions.ADVANCE;
    case 2:
    case "APPROVE":
      return RolloutRestriction_RolloutActions.APPROVE;
    case 3:
    case "CANCEL":
      return RolloutRestriction_RolloutActions.CANCEL;
    case 4:
    case "CREATE":
      return RolloutRestriction_RolloutActions.CREATE;
    case 5:
    case "IGNORE_JOB":
      return RolloutRestriction_RolloutActions.IGNORE_JOB;
    case 6:
    case "RETRY_JOB":
      return RolloutRestriction_RolloutActions.RETRY_JOB;
    case 7:
    case "ROLLBACK":
      return RolloutRestriction_RolloutActions.ROLLBACK;
    case 8:
    case "TERMINATE_JOBRUN":
      return RolloutRestriction_RolloutActions.TERMINATE_JOBRUN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RolloutRestriction_RolloutActions.UNRECOGNIZED;
  }
}

export function rolloutRestriction_RolloutActionsToJSON(object: RolloutRestriction_RolloutActions): string {
  switch (object) {
    case RolloutRestriction_RolloutActions.ROLLOUT_ACTIONS_UNSPECIFIED:
      return "ROLLOUT_ACTIONS_UNSPECIFIED";
    case RolloutRestriction_RolloutActions.ADVANCE:
      return "ADVANCE";
    case RolloutRestriction_RolloutActions.APPROVE:
      return "APPROVE";
    case RolloutRestriction_RolloutActions.CANCEL:
      return "CANCEL";
    case RolloutRestriction_RolloutActions.CREATE:
      return "CREATE";
    case RolloutRestriction_RolloutActions.IGNORE_JOB:
      return "IGNORE_JOB";
    case RolloutRestriction_RolloutActions.RETRY_JOB:
      return "RETRY_JOB";
    case RolloutRestriction_RolloutActions.ROLLBACK:
      return "ROLLBACK";
    case RolloutRestriction_RolloutActions.TERMINATE_JOBRUN:
      return "TERMINATE_JOBRUN";
    case RolloutRestriction_RolloutActions.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Time windows within which actions are restricted. See the
 * [documentation](https://cloud.google.com/deploy/docs/deploy-policy#dates_times)
 * for more information on how to configure dates/times.
 */
export interface TimeWindows {
  /**
   * Required. The time zone in IANA format [IANA Time Zone
   * Database](https://www.iana.org/time-zones) (e.g. America/New_York).
   */
  timeZone: string;
  /** Optional. One-time windows within which actions are restricted. */
  oneTimeWindows: OneTimeWindow[];
  /** Optional. Recurring weekly windows within which actions are restricted. */
  weeklyWindows: WeeklyWindow[];
}

/**
 * One-time window within which actions are restricted. For example, blocking
 * actions over New Year's Eve from December 31st at 5pm to January 1st at 9am.
 */
export interface OneTimeWindow {
  /** Required. Start date. */
  startDate:
    | DateMessage
    | undefined;
  /** Required. Start time (inclusive). Use 00:00 for the beginning of the day. */
  startTime:
    | TimeOfDay
    | undefined;
  /** Required. End date. */
  endDate:
    | DateMessage
    | undefined;
  /** Required. End time (exclusive). You may use 24:00 for the end of the day. */
  endTime: TimeOfDay | undefined;
}

/**
 * Weekly windows. For example, blocking actions every Saturday and Sunday.
 * Another example would be blocking actions every weekday from 5pm to midnight.
 */
export interface WeeklyWindow {
  /**
   * Optional. Days of week. If left empty, all days of the week will be
   * included.
   */
  daysOfWeek: DayOfWeek[];
  /**
   * Optional. Start time (inclusive). Use 00:00 for the beginning of the day.
   * If you specify start_time you must also specify end_time. If left empty,
   * this will block for the entire day for the days specified in days_of_week.
   */
  startTime:
    | TimeOfDay
    | undefined;
  /**
   * Optional. End time (exclusive). Use 24:00 to indicate midnight. If you
   * specify end_time you must also specify start_time. If left empty, this will
   * block for the entire day for the days specified in days_of_week.
   */
  endTime: TimeOfDay | undefined;
}

/**
 * Returned from an action if one or more policies were
 * violated, and therefore the action was prevented. Contains information about
 * what policies were violated and why.
 */
export interface PolicyViolation {
  /** Policy violation details. */
  policyViolationDetails: PolicyViolationDetails[];
}

/** Policy violation details. */
export interface PolicyViolationDetails {
  /**
   * Name of the policy that was violated.
   * Policy resource will be in the format of
   * `projects/{project}/locations/{location}/policies/{policy}`.
   */
  policy: string;
  /** Id of the rule that triggered the policy violation. */
  ruleId: string;
  /**
   * User readable message about why the request violated a policy. This is not
   * intended for machine parsing.
   */
  failureMessage: string;
}

/**
 * A `Release` resource in the Cloud Deploy API.
 *
 * A `Release` defines a specific Skaffold configuration instance
 * that can be deployed.
 */
export interface Release {
  /**
   * Optional. Name of the `Release`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
   * The `release` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Unique identifier of the `Release`. */
  uid: string;
  /** Description of the `Release`. Max length is 255 characters. */
  description: string;
  /**
   * User annotations. These attributes can only be set and used by the
   * user, and not by Cloud Deploy. See https://google.aip.dev/128#annotations
   * for more details such as format and size limitations.
   */
  annotations: { [key: string]: string };
  /**
   * Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Output only. Indicates whether this is an abandoned release. */
  abandoned: boolean;
  /** Output only. Time at which the `Release` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time at which the render began. */
  renderStartTime:
    | Date
    | undefined;
  /** Output only. Time at which the render completed. */
  renderEndTime:
    | Date
    | undefined;
  /** Cloud Storage URI of tar.gz archive containing Skaffold configuration. */
  skaffoldConfigUri: string;
  /** Filepath of the Skaffold config inside of the config URI. */
  skaffoldConfigPath: string;
  /** List of artifacts to pass through to Skaffold command. */
  buildArtifacts: BuildArtifact[];
  /**
   * Output only. Snapshot of the parent pipeline taken at release creation
   * time.
   */
  deliveryPipelineSnapshot:
    | DeliveryPipeline
    | undefined;
  /** Output only. Snapshot of the targets taken at release creation time. */
  targetSnapshots: Target[];
  /**
   * Output only. Snapshot of the custom target types referenced by the targets
   * taken at release creation time.
   */
  customTargetTypeSnapshots: CustomTargetType[];
  /** Output only. Current state of the render operation. */
  renderState: Release_RenderState;
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * The Skaffold version to use when operating on this release, such as
   * "1.20.0". Not all versions are valid; Cloud Deploy supports a specific set
   * of versions.
   *
   * If unset, the most recent supported Skaffold version will be used.
   */
  skaffoldVersion: string;
  /**
   * Output only. Map from target ID to the target artifacts created
   * during the render operation.
   */
  targetArtifacts: { [key: string]: TargetArtifact };
  /**
   * Output only. Map from target ID to details of the render operation for that
   * target.
   */
  targetRenders: { [key: string]: Release_TargetRender };
  /** Output only. Information around the state of the Release. */
  condition:
    | Release_ReleaseCondition
    | undefined;
  /** Optional. The deploy parameters to use for all targets in this release. */
  deployParameters: { [key: string]: string };
}

/** Valid states of the render operation. */
export enum Release_RenderState {
  /** RENDER_STATE_UNSPECIFIED - The render state is unspecified. */
  RENDER_STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - All rendering operations have completed successfully. */
  SUCCEEDED = 1,
  /** FAILED - All rendering operations have completed, and one or more have failed. */
  FAILED = 2,
  /** IN_PROGRESS - Rendering has started and is not complete. */
  IN_PROGRESS = 3,
  UNRECOGNIZED = -1,
}

export function release_RenderStateFromJSON(object: any): Release_RenderState {
  switch (object) {
    case 0:
    case "RENDER_STATE_UNSPECIFIED":
      return Release_RenderState.RENDER_STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return Release_RenderState.SUCCEEDED;
    case 2:
    case "FAILED":
      return Release_RenderState.FAILED;
    case 3:
    case "IN_PROGRESS":
      return Release_RenderState.IN_PROGRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Release_RenderState.UNRECOGNIZED;
  }
}

export function release_RenderStateToJSON(object: Release_RenderState): string {
  switch (object) {
    case Release_RenderState.RENDER_STATE_UNSPECIFIED:
      return "RENDER_STATE_UNSPECIFIED";
    case Release_RenderState.SUCCEEDED:
      return "SUCCEEDED";
    case Release_RenderState.FAILED:
      return "FAILED";
    case Release_RenderState.IN_PROGRESS:
      return "IN_PROGRESS";
    case Release_RenderState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of rendering for a single target. */
export interface Release_TargetRender {
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to render the manifest for this target. Format is
   * `projects/{project}/locations/{location}/builds/{build}`.
   */
  renderingBuild: string;
  /** Output only. Current state of the render operation for this Target. */
  renderingState: Release_TargetRender_TargetRenderState;
  /** Output only. Metadata related to the `Release` render for this Target. */
  metadata:
    | RenderMetadata
    | undefined;
  /**
   * Output only. Reason this render failed. This will always be unspecified
   * while the render in progress.
   */
  failureCause: Release_TargetRender_FailureCause;
  /**
   * Output only. Additional information about the render failure, if
   * available.
   */
  failureMessage: string;
}

/** Valid states of the render operation. */
export enum Release_TargetRender_TargetRenderState {
  /** TARGET_RENDER_STATE_UNSPECIFIED - The render operation state is unspecified. */
  TARGET_RENDER_STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The render operation has completed successfully. */
  SUCCEEDED = 1,
  /** FAILED - The render operation has failed. */
  FAILED = 2,
  /** IN_PROGRESS - The render operation is in progress. */
  IN_PROGRESS = 3,
  UNRECOGNIZED = -1,
}

export function release_TargetRender_TargetRenderStateFromJSON(object: any): Release_TargetRender_TargetRenderState {
  switch (object) {
    case 0:
    case "TARGET_RENDER_STATE_UNSPECIFIED":
      return Release_TargetRender_TargetRenderState.TARGET_RENDER_STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return Release_TargetRender_TargetRenderState.SUCCEEDED;
    case 2:
    case "FAILED":
      return Release_TargetRender_TargetRenderState.FAILED;
    case 3:
    case "IN_PROGRESS":
      return Release_TargetRender_TargetRenderState.IN_PROGRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Release_TargetRender_TargetRenderState.UNRECOGNIZED;
  }
}

export function release_TargetRender_TargetRenderStateToJSON(object: Release_TargetRender_TargetRenderState): string {
  switch (object) {
    case Release_TargetRender_TargetRenderState.TARGET_RENDER_STATE_UNSPECIFIED:
      return "TARGET_RENDER_STATE_UNSPECIFIED";
    case Release_TargetRender_TargetRenderState.SUCCEEDED:
      return "SUCCEEDED";
    case Release_TargetRender_TargetRenderState.FAILED:
      return "FAILED";
    case Release_TargetRender_TargetRenderState.IN_PROGRESS:
      return "IN_PROGRESS";
    case Release_TargetRender_TargetRenderState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Well-known rendering failures. */
export enum Release_TargetRender_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or
   * because Cloud Deploy has insufficient permissions. See [required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The render operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See
   * failure_message for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 3,
  /**
   * VERIFICATION_CONFIG_NOT_FOUND - The render operation did not complete successfully because the
   * verification stanza required for verify was not found on the Skaffold
   * configuration.
   */
  VERIFICATION_CONFIG_NOT_FOUND = 4,
  /**
   * CUSTOM_ACTION_NOT_FOUND - The render operation did not complete successfully because the custom
   * action required for predeploy or postdeploy was not found in the
   * Skaffold configuration. See failure_message for additional details.
   */
  CUSTOM_ACTION_NOT_FOUND = 5,
  /**
   * DEPLOYMENT_STRATEGY_NOT_SUPPORTED - Release failed during rendering because the release configuration is
   * not supported with the specified deployment strategy.
   */
  DEPLOYMENT_STRATEGY_NOT_SUPPORTED = 6,
  /** RENDER_FEATURE_NOT_SUPPORTED - The render operation had a feature configured that is not supported. */
  RENDER_FEATURE_NOT_SUPPORTED = 7,
  UNRECOGNIZED = -1,
}

export function release_TargetRender_FailureCauseFromJSON(object: any): Release_TargetRender_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return Release_TargetRender_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return Release_TargetRender_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return Release_TargetRender_FailureCause.EXECUTION_FAILED;
    case 3:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return Release_TargetRender_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case 4:
    case "VERIFICATION_CONFIG_NOT_FOUND":
      return Release_TargetRender_FailureCause.VERIFICATION_CONFIG_NOT_FOUND;
    case 5:
    case "CUSTOM_ACTION_NOT_FOUND":
      return Release_TargetRender_FailureCause.CUSTOM_ACTION_NOT_FOUND;
    case 6:
    case "DEPLOYMENT_STRATEGY_NOT_SUPPORTED":
      return Release_TargetRender_FailureCause.DEPLOYMENT_STRATEGY_NOT_SUPPORTED;
    case 7:
    case "RENDER_FEATURE_NOT_SUPPORTED":
      return Release_TargetRender_FailureCause.RENDER_FEATURE_NOT_SUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Release_TargetRender_FailureCause.UNRECOGNIZED;
  }
}

export function release_TargetRender_FailureCauseToJSON(object: Release_TargetRender_FailureCause): string {
  switch (object) {
    case Release_TargetRender_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case Release_TargetRender_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case Release_TargetRender_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case Release_TargetRender_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case Release_TargetRender_FailureCause.VERIFICATION_CONFIG_NOT_FOUND:
      return "VERIFICATION_CONFIG_NOT_FOUND";
    case Release_TargetRender_FailureCause.CUSTOM_ACTION_NOT_FOUND:
      return "CUSTOM_ACTION_NOT_FOUND";
    case Release_TargetRender_FailureCause.DEPLOYMENT_STRATEGY_NOT_SUPPORTED:
      return "DEPLOYMENT_STRATEGY_NOT_SUPPORTED";
    case Release_TargetRender_FailureCause.RENDER_FEATURE_NOT_SUPPORTED:
      return "RENDER_FEATURE_NOT_SUPPORTED";
    case Release_TargetRender_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ReleaseReadyCondition contains information around the status of the
 * Release. If a release is not ready, you cannot create a rollout with the
 * release.
 */
export interface Release_ReleaseReadyCondition {
  /**
   * True if the Release is in a valid state. Otherwise at least one condition
   * in `ReleaseCondition` is in an invalid state. Iterate over those
   * conditions and see which condition(s) has status = false to find out what
   * is wrong with the Release.
   */
  status: boolean;
}

/**
 * SkaffoldSupportedCondition contains information about when support for the
 * release's version of Skaffold ends.
 */
export interface Release_SkaffoldSupportedCondition {
  /** True if the version of Skaffold used by this release is supported. */
  status: boolean;
  /** The Skaffold support state for this release's version of Skaffold. */
  skaffoldSupportState: SkaffoldSupportState;
  /**
   * The time at which this release's version of Skaffold will enter
   * maintenance mode.
   */
  maintenanceModeTime:
    | Date
    | undefined;
  /**
   * The time at which this release's version of Skaffold will no longer be
   * supported.
   */
  supportExpirationTime: Date | undefined;
}

/** ReleaseCondition contains all conditions relevant to a Release. */
export interface Release_ReleaseCondition {
  /** Details around the Releases's overall status. */
  releaseReadyCondition:
    | Release_ReleaseReadyCondition
    | undefined;
  /**
   * Details around the support state of the release's Skaffold
   * version.
   */
  skaffoldSupportedCondition: Release_SkaffoldSupportedCondition | undefined;
}

export interface Release_AnnotationsEntry {
  key: string;
  value: string;
}

export interface Release_LabelsEntry {
  key: string;
  value: string;
}

export interface Release_TargetArtifactsEntry {
  key: string;
  value: TargetArtifact | undefined;
}

export interface Release_TargetRendersEntry {
  key: string;
  value: Release_TargetRender | undefined;
}

export interface Release_DeployParametersEntry {
  key: string;
  value: string;
}

/** The request object for `CreateDeployPolicy`. */
export interface CreateDeployPolicyRequest {
  /**
   * Required. The parent collection in which the `DeployPolicy` must be
   * created. The format is `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /** Required. ID of the `DeployPolicy`. */
  deployPolicyId: string;
  /** Required. The `DeployPolicy` to create. */
  deployPolicy:
    | DeployPolicy
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `UpdateDeployPolicy`. */
export interface UpdateDeployPolicyRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten by the
   * update in the `DeployPolicy` resource. The fields specified in the
   * update_mask are relative to the resource, not the full request. A field
   * will be overwritten if it's in the mask. If the user doesn't provide a mask
   * then all fields are overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The `DeployPolicy` to update. */
  deployPolicy:
    | DeployPolicy
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, updating a `DeployPolicy` that does not exist
   * will result in the creation of a new `DeployPolicy`.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `DeleteDeployPolicy`. */
export interface DeleteDeployPolicyRequest {
  /**
   * Required. The name of the `DeployPolicy` to delete. The format is
   * `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, then deleting an already deleted or non-existing
   * `DeployPolicy` will succeed.
   */
  allowMissing: boolean;
  /**
   * Optional. If set, validate the request and preview the review, but do not
   * actually post it.
   */
  validateOnly: boolean;
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/** The request object for `ListDeployPolicies`. */
export interface ListDeployPoliciesRequest {
  /**
   * Required. The parent, which owns this collection of deploy policies. Format
   * must be `projects/{project_id}/locations/{location_name}`.
   */
  parent: string;
  /**
   * The maximum number of deploy policies to return. The service may return
   * fewer than this value. If unspecified, at most 50 deploy policies will
   * be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListDeployPolicies` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Filter deploy policies to be returned. See https://google.aip.dev/160 for
   * more details. All fields can be used in the filter.
   */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** The response object from `ListDeployPolicies`. */
export interface ListDeployPoliciesResponse {
  /** The `DeployPolicy` objects. */
  deployPolicies: DeployPolicy[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetDeployPolicy` */
export interface GetDeployPolicyRequest {
  /**
   * Required. Name of the `DeployPolicy`. Format must be
   * `projects/{project_id}/locations/{location_name}/deployPolicies/{deploy_policy_name}`.
   */
  name: string;
}

/** Description of an a image to use during Skaffold rendering. */
export interface BuildArtifact {
  /** Image name in Skaffold configuration. */
  image: string;
  /**
   * Image tag to use. This will generally be the full path to an image, such
   * as "gcr.io/my-project/busybox:1.2.3" or
   * "gcr.io/my-project/busybox@sha256:abc123".
   */
  tag: string;
}

/** The artifacts produced by a target render operation. */
export interface TargetArtifact {
  /**
   * Output only. URI of a directory containing the artifacts. This contains
   * deployment configuration used by Skaffold during a rollout, and all
   * paths are relative to this location.
   */
  artifactUri?:
    | string
    | undefined;
  /**
   * Output only. File path of the resolved Skaffold configuration relative to
   * the URI.
   */
  skaffoldConfigPath: string;
  /** Output only. File path of the rendered manifest relative to the URI. */
  manifestPath: string;
  /** Output only. Map from the phase ID to the phase artifacts for the `Target`. */
  phaseArtifacts: { [key: string]: TargetArtifact_PhaseArtifact };
}

/** Contains the paths to the artifacts, relative to the URI, for a phase. */
export interface TargetArtifact_PhaseArtifact {
  /**
   * Output only. File path of the resolved Skaffold configuration relative to
   * the URI.
   */
  skaffoldConfigPath: string;
  /** Output only. File path of the rendered manifest relative to the URI. */
  manifestPath: string;
  /**
   * Output only. File path of the directory of rendered job manifests
   * relative to the URI. This is only set if it is applicable.
   */
  jobManifestsPath: string;
}

export interface TargetArtifact_PhaseArtifactsEntry {
  key: string;
  value: TargetArtifact_PhaseArtifact | undefined;
}

/** The artifacts produced by a deploy operation. */
export interface DeployArtifact {
  /**
   * Output only. URI of a directory containing the artifacts. All paths are
   * relative to this location.
   */
  artifactUri: string;
  /**
   * Output only. File paths of the manifests applied during the deploy
   * operation relative to the URI.
   */
  manifestPaths: string[];
}

/**
 * CloudRunRenderMetadata contains Cloud Run information associated with a
 * `Release` render.
 */
export interface CloudRunRenderMetadata {
  /**
   * Output only. The name of the Cloud Run Service in the rendered manifest.
   * Format is `projects/{project}/locations/{location}/services/{service}`.
   */
  service: string;
}

/** RenderMetadata includes information associated with a `Release` render. */
export interface RenderMetadata {
  /** Output only. Metadata associated with rendering for Cloud Run. */
  cloudRun:
    | CloudRunRenderMetadata
    | undefined;
  /** Output only. Custom metadata provided by user-defined render operation. */
  custom: CustomMetadata | undefined;
}

/** The request object for `ListReleases`. */
export interface ListReleasesRequest {
  /**
   * Required. The `DeliveryPipeline` which owns this collection of `Release`
   * objects.
   */
  parent: string;
  /**
   * Optional. The maximum number of `Release` objects to return. The service
   * may return fewer than this value. If unspecified, at most 50 `Release`
   * objects will be returned. The maximum value is 1000; values above 1000 will
   * be set to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListReleases` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter releases to be returned. See https://google.aip.dev/160
   * for more details.
   */
  filter: string;
  /**
   * Optional. Field to sort by. See https://google.aip.dev/132#ordering for
   * more details.
   */
  orderBy: string;
}

/** The response object from `ListReleases`. */
export interface ListReleasesResponse {
  /** The `Release` objects. */
  releases: Release[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetRelease`. */
export interface GetReleaseRequest {
  /**
   * Required. Name of the `Release`. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
   */
  name: string;
}

/** The request object for `CreateRelease`, */
export interface CreateReleaseRequest {
  /**
   * Required. The parent collection in which the `Release` is created.
   * The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  parent: string;
  /** Required. ID of the `Release`. */
  releaseId: string;
  /** Required. The `Release` to create. */
  release:
    | Release
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/**
 * A `Rollout` resource in the Cloud Deploy API.
 *
 * A `Rollout` contains information around a specific deployment to a `Target`.
 */
export interface Rollout {
  /**
   * Optional. Name of the `Rollout`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   * The `rollout` component must match `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`
   */
  name: string;
  /** Output only. Unique identifier of the `Rollout`. */
  uid: string;
  /**
   * Description of the `Rollout` for user purposes. Max length is 255
   * characters.
   */
  description: string;
  /**
   * User annotations. These attributes can only be set and used by the
   * user, and not by Cloud Deploy. See https://google.aip.dev/128#annotations
   * for more details such as format and size limitations.
   */
  annotations: { [key: string]: string };
  /**
   * Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 128 bytes.
   */
  labels: { [key: string]: string };
  /** Output only. Time at which the `Rollout` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time at which the `Rollout` was approved. */
  approveTime:
    | Date
    | undefined;
  /** Output only. Time at which the `Rollout` was enqueued. */
  enqueueTime:
    | Date
    | undefined;
  /** Output only. Time at which the `Rollout` started deploying. */
  deployStartTime:
    | Date
    | undefined;
  /** Output only. Time at which the `Rollout` finished deploying. */
  deployEndTime:
    | Date
    | undefined;
  /** Required. The ID of Target to which this `Rollout` is deploying. */
  targetId: string;
  /** Output only. Approval state of the `Rollout`. */
  approvalState: Rollout_ApprovalState;
  /** Output only. Current state of the `Rollout`. */
  state: Rollout_State;
  /**
   * Output only. Additional information about the rollout failure, if
   * available.
   */
  failureReason: string;
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to deploy the Rollout. Format is
   * `projects/{project}/locations/{location}/builds/{build}`.
   */
  deployingBuild: string;
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Output only. The reason this rollout failed. This will always be
   * unspecified while the rollout is in progress.
   */
  deployFailureCause: Rollout_FailureCause;
  /** Output only. The phases that represent the workflows of this `Rollout`. */
  phases: Phase[];
  /** Output only. Metadata contains information about the rollout. */
  metadata:
    | Metadata
    | undefined;
  /**
   * Output only. Name of the `ControllerRollout`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  controllerRollout: string;
  /**
   * Output only. Name of the `Rollout` that is rolled back by this `Rollout`.
   * Empty if this `Rollout` wasn't created as a rollback.
   */
  rollbackOfRollout: string;
  /** Output only. Names of `Rollouts` that rolled back this `Rollout`. */
  rolledBackByRollouts: string[];
}

/** Valid approval states of a `Rollout`. */
export enum Rollout_ApprovalState {
  /** APPROVAL_STATE_UNSPECIFIED - The `Rollout` has an unspecified approval state. */
  APPROVAL_STATE_UNSPECIFIED = 0,
  /** NEEDS_APPROVAL - The `Rollout` requires approval. */
  NEEDS_APPROVAL = 1,
  /** DOES_NOT_NEED_APPROVAL - The `Rollout` does not require approval. */
  DOES_NOT_NEED_APPROVAL = 2,
  /** APPROVED - The `Rollout` has been approved. */
  APPROVED = 3,
  /** REJECTED - The `Rollout` has been rejected. */
  REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function rollout_ApprovalStateFromJSON(object: any): Rollout_ApprovalState {
  switch (object) {
    case 0:
    case "APPROVAL_STATE_UNSPECIFIED":
      return Rollout_ApprovalState.APPROVAL_STATE_UNSPECIFIED;
    case 1:
    case "NEEDS_APPROVAL":
      return Rollout_ApprovalState.NEEDS_APPROVAL;
    case 2:
    case "DOES_NOT_NEED_APPROVAL":
      return Rollout_ApprovalState.DOES_NOT_NEED_APPROVAL;
    case 3:
    case "APPROVED":
      return Rollout_ApprovalState.APPROVED;
    case 4:
    case "REJECTED":
      return Rollout_ApprovalState.REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rollout_ApprovalState.UNRECOGNIZED;
  }
}

export function rollout_ApprovalStateToJSON(object: Rollout_ApprovalState): string {
  switch (object) {
    case Rollout_ApprovalState.APPROVAL_STATE_UNSPECIFIED:
      return "APPROVAL_STATE_UNSPECIFIED";
    case Rollout_ApprovalState.NEEDS_APPROVAL:
      return "NEEDS_APPROVAL";
    case Rollout_ApprovalState.DOES_NOT_NEED_APPROVAL:
      return "DOES_NOT_NEED_APPROVAL";
    case Rollout_ApprovalState.APPROVED:
      return "APPROVED";
    case Rollout_ApprovalState.REJECTED:
      return "REJECTED";
    case Rollout_ApprovalState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid states of a `Rollout`. */
export enum Rollout_State {
  /** STATE_UNSPECIFIED - The `Rollout` has an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The `Rollout` has completed successfully. */
  SUCCEEDED = 1,
  /** FAILED - The `Rollout` has failed. */
  FAILED = 2,
  /** IN_PROGRESS - The `Rollout` is being deployed. */
  IN_PROGRESS = 3,
  /** PENDING_APPROVAL - The `Rollout` needs approval. */
  PENDING_APPROVAL = 4,
  /** APPROVAL_REJECTED - An approver rejected the `Rollout`. */
  APPROVAL_REJECTED = 5,
  /**
   * PENDING - The `Rollout` is waiting for an earlier Rollout(s) to complete on this
   * `Target`.
   */
  PENDING = 6,
  /** PENDING_RELEASE - The `Rollout` is waiting for the `Release` to be fully rendered. */
  PENDING_RELEASE = 7,
  /** CANCELLING - The `Rollout` is in the process of being cancelled. */
  CANCELLING = 8,
  /** CANCELLED - The `Rollout` has been cancelled. */
  CANCELLED = 9,
  /** HALTED - The `Rollout` is halted. */
  HALTED = 10,
  UNRECOGNIZED = -1,
}

export function rollout_StateFromJSON(object: any): Rollout_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Rollout_State.STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return Rollout_State.SUCCEEDED;
    case 2:
    case "FAILED":
      return Rollout_State.FAILED;
    case 3:
    case "IN_PROGRESS":
      return Rollout_State.IN_PROGRESS;
    case 4:
    case "PENDING_APPROVAL":
      return Rollout_State.PENDING_APPROVAL;
    case 5:
    case "APPROVAL_REJECTED":
      return Rollout_State.APPROVAL_REJECTED;
    case 6:
    case "PENDING":
      return Rollout_State.PENDING;
    case 7:
    case "PENDING_RELEASE":
      return Rollout_State.PENDING_RELEASE;
    case 8:
    case "CANCELLING":
      return Rollout_State.CANCELLING;
    case 9:
    case "CANCELLED":
      return Rollout_State.CANCELLED;
    case 10:
    case "HALTED":
      return Rollout_State.HALTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rollout_State.UNRECOGNIZED;
  }
}

export function rollout_StateToJSON(object: Rollout_State): string {
  switch (object) {
    case Rollout_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Rollout_State.SUCCEEDED:
      return "SUCCEEDED";
    case Rollout_State.FAILED:
      return "FAILED";
    case Rollout_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Rollout_State.PENDING_APPROVAL:
      return "PENDING_APPROVAL";
    case Rollout_State.APPROVAL_REJECTED:
      return "APPROVAL_REJECTED";
    case Rollout_State.PENDING:
      return "PENDING";
    case Rollout_State.PENDING_RELEASE:
      return "PENDING_RELEASE";
    case Rollout_State.CANCELLING:
      return "CANCELLING";
    case Rollout_State.CANCELLED:
      return "CANCELLED";
    case Rollout_State.HALTED:
      return "HALTED";
    case Rollout_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Well-known rollout failures. */
export enum Rollout_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or because
   * Cloud Deploy has insufficient permissions. See [required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The deploy operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /** DEADLINE_EXCEEDED - Deployment did not complete within the alloted time. */
  DEADLINE_EXCEEDED = 3,
  /** RELEASE_FAILED - Release is in a failed state. */
  RELEASE_FAILED = 4,
  /** RELEASE_ABANDONED - Release is abandoned. */
  RELEASE_ABANDONED = 5,
  /** VERIFICATION_CONFIG_NOT_FOUND - No Skaffold verify configuration was found. */
  VERIFICATION_CONFIG_NOT_FOUND = 6,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
   * for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 7,
  /** OPERATION_FEATURE_NOT_SUPPORTED - A Rollout operation had a feature configured that is not supported. */
  OPERATION_FEATURE_NOT_SUPPORTED = 8,
  UNRECOGNIZED = -1,
}

export function rollout_FailureCauseFromJSON(object: any): Rollout_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return Rollout_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return Rollout_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return Rollout_FailureCause.EXECUTION_FAILED;
    case 3:
    case "DEADLINE_EXCEEDED":
      return Rollout_FailureCause.DEADLINE_EXCEEDED;
    case 4:
    case "RELEASE_FAILED":
      return Rollout_FailureCause.RELEASE_FAILED;
    case 5:
    case "RELEASE_ABANDONED":
      return Rollout_FailureCause.RELEASE_ABANDONED;
    case 6:
    case "VERIFICATION_CONFIG_NOT_FOUND":
      return Rollout_FailureCause.VERIFICATION_CONFIG_NOT_FOUND;
    case 7:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return Rollout_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case 8:
    case "OPERATION_FEATURE_NOT_SUPPORTED":
      return Rollout_FailureCause.OPERATION_FEATURE_NOT_SUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rollout_FailureCause.UNRECOGNIZED;
  }
}

export function rollout_FailureCauseToJSON(object: Rollout_FailureCause): string {
  switch (object) {
    case Rollout_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case Rollout_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case Rollout_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case Rollout_FailureCause.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case Rollout_FailureCause.RELEASE_FAILED:
      return "RELEASE_FAILED";
    case Rollout_FailureCause.RELEASE_ABANDONED:
      return "RELEASE_ABANDONED";
    case Rollout_FailureCause.VERIFICATION_CONFIG_NOT_FOUND:
      return "VERIFICATION_CONFIG_NOT_FOUND";
    case Rollout_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case Rollout_FailureCause.OPERATION_FEATURE_NOT_SUPPORTED:
      return "OPERATION_FEATURE_NOT_SUPPORTED";
    case Rollout_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Rollout_AnnotationsEntry {
  key: string;
  value: string;
}

export interface Rollout_LabelsEntry {
  key: string;
  value: string;
}

/** Metadata includes information associated with a `Rollout`. */
export interface Metadata {
  /**
   * Output only. The name of the Cloud Run Service that is associated with a
   * `Rollout`.
   */
  cloudRun:
    | CloudRunMetadata
    | undefined;
  /**
   * Output only. AutomationRolloutMetadata contains the information about the
   * interactions between Automation service and this rollout.
   */
  automation:
    | AutomationRolloutMetadata
    | undefined;
  /** Output only. Custom metadata provided by user-defined `Rollout` operations. */
  custom: CustomMetadata | undefined;
}

/**
 * DeployJobRunMetadata surfaces information associated with a `DeployJobRun` to
 * the user.
 */
export interface DeployJobRunMetadata {
  /**
   * Output only. The name of the Cloud Run Service that is associated with a
   * `DeployJobRun`.
   */
  cloudRun:
    | CloudRunMetadata
    | undefined;
  /** Output only. Custom Target metadata associated with a `DeployJobRun`. */
  customTarget:
    | CustomTargetDeployMetadata
    | undefined;
  /** Output only. Custom metadata provided by user-defined deploy operation. */
  custom: CustomMetadata | undefined;
}

/** CloudRunMetadata contains information from a Cloud Run deployment. */
export interface CloudRunMetadata {
  /**
   * Output only. The name of the Cloud Run Service that is associated with a
   * `Rollout`. Format is
   * `projects/{project}/locations/{location}/services/{service}`.
   */
  service: string;
  /**
   * Output only. The Cloud Run Service urls that are associated with a
   * `Rollout`.
   */
  serviceUrls: string[];
  /** Output only. The Cloud Run Revision id associated with a `Rollout`. */
  revision: string;
  /**
   * Output only. The name of the Cloud Run job that is associated with a
   * `Rollout`. Format is
   * `projects/{project}/locations/{location}/jobs/{job_name}`.
   */
  job: string;
}

/**
 * CustomTargetDeployMetadata contains information from a Custom Target
 * deploy operation.
 */
export interface CustomTargetDeployMetadata {
  /**
   * Output only. Skip message provided in the results of a custom deploy
   * operation.
   */
  skipMessage: string;
}

/**
 * AutomationRolloutMetadata contains Automation-related actions that
 * were performed on a rollout.
 */
export interface AutomationRolloutMetadata {
  /**
   * Output only. The name of the AutomationRun initiated by a promote release
   * rule.
   */
  promoteAutomationRun: string;
  /**
   * Output only. The names of the AutomationRuns initiated by an advance
   * rollout rule.
   */
  advanceAutomationRuns: string[];
  /**
   * Output only. The names of the AutomationRuns initiated by a repair rollout
   * rule.
   */
  repairAutomationRuns: string[];
}

/** CustomMetadata contains information from a user-defined operation. */
export interface CustomMetadata {
  /** Output only. Key-value pairs provided by the user-defined operation. */
  values: { [key: string]: string };
}

export interface CustomMetadata_ValuesEntry {
  key: string;
  value: string;
}

/**
 * Phase represents a collection of jobs that are logically grouped together
 * for a `Rollout`.
 */
export interface Phase {
  /** Output only. The ID of the Phase. */
  id: string;
  /** Output only. Current state of the Phase. */
  state: Phase_State;
  /**
   * Output only. Additional information on why the Phase was skipped, if
   * available.
   */
  skipMessage: string;
  /** Output only. Deployment job composition. */
  deploymentJobs?:
    | DeploymentJobs
    | undefined;
  /** Output only. ChildRollout job composition. */
  childRolloutJobs?: ChildRolloutJobs | undefined;
}

/** Valid states of a Phase. */
export enum Phase_State {
  /** STATE_UNSPECIFIED - The Phase has an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The Phase is waiting for an earlier Phase(s) to complete. */
  PENDING = 1,
  /** IN_PROGRESS - The Phase is in progress. */
  IN_PROGRESS = 2,
  /** SUCCEEDED - The Phase has succeeded. */
  SUCCEEDED = 3,
  /** FAILED - The Phase has failed. */
  FAILED = 4,
  /** ABORTED - The Phase was aborted. */
  ABORTED = 5,
  /** SKIPPED - The Phase was skipped. */
  SKIPPED = 6,
  UNRECOGNIZED = -1,
}

export function phase_StateFromJSON(object: any): Phase_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Phase_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Phase_State.PENDING;
    case 2:
    case "IN_PROGRESS":
      return Phase_State.IN_PROGRESS;
    case 3:
    case "SUCCEEDED":
      return Phase_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Phase_State.FAILED;
    case 5:
    case "ABORTED":
      return Phase_State.ABORTED;
    case 6:
    case "SKIPPED":
      return Phase_State.SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Phase_State.UNRECOGNIZED;
  }
}

export function phase_StateToJSON(object: Phase_State): string {
  switch (object) {
    case Phase_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Phase_State.PENDING:
      return "PENDING";
    case Phase_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Phase_State.SUCCEEDED:
      return "SUCCEEDED";
    case Phase_State.FAILED:
      return "FAILED";
    case Phase_State.ABORTED:
      return "ABORTED";
    case Phase_State.SKIPPED:
      return "SKIPPED";
    case Phase_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Deployment job composition. */
export interface DeploymentJobs {
  /** Output only. The deploy Job. This is the deploy job in the phase. */
  deployJob:
    | Job
    | undefined;
  /** Output only. The verify Job. Runs after a deploy if the deploy succeeds. */
  verifyJob:
    | Job
    | undefined;
  /** Output only. The predeploy Job, which is the first job on the phase. */
  predeployJob:
    | Job
    | undefined;
  /** Output only. The postdeploy Job, which is the last job on the phase. */
  postdeployJob: Job | undefined;
}

/** ChildRollouts job composition */
export interface ChildRolloutJobs {
  /** Output only. List of CreateChildRolloutJobs */
  createRolloutJobs: Job[];
  /** Output only. List of AdvanceChildRolloutJobs */
  advanceRolloutJobs: Job[];
}

/** Job represents an operation for a `Rollout`. */
export interface Job {
  /** Output only. The ID of the Job. */
  id: string;
  /** Output only. The current state of the Job. */
  state: Job_State;
  /**
   * Output only. Additional information on why the Job was skipped, if
   * available.
   */
  skipMessage: string;
  /**
   * Output only. The name of the `JobRun` responsible for the most recent
   * invocation of this Job.
   */
  jobRun: string;
  /** Output only. A deploy Job. */
  deployJob?:
    | DeployJob
    | undefined;
  /** Output only. A verify Job. */
  verifyJob?:
    | VerifyJob
    | undefined;
  /** Output only. A predeploy Job. */
  predeployJob?:
    | PredeployJob
    | undefined;
  /** Output only. A postdeploy Job. */
  postdeployJob?:
    | PostdeployJob
    | undefined;
  /** Output only. A createChildRollout Job. */
  createChildRolloutJob?:
    | CreateChildRolloutJob
    | undefined;
  /** Output only. An advanceChildRollout Job. */
  advanceChildRolloutJob?: AdvanceChildRolloutJob | undefined;
}

/** Valid states of a Job. */
export enum Job_State {
  /** STATE_UNSPECIFIED - The Job has an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The Job is waiting for an earlier Phase(s) or Job(s) to complete. */
  PENDING = 1,
  /** DISABLED - The Job is disabled. */
  DISABLED = 2,
  /** IN_PROGRESS - The Job is in progress. */
  IN_PROGRESS = 3,
  /** SUCCEEDED - The Job succeeded. */
  SUCCEEDED = 4,
  /** FAILED - The Job failed. */
  FAILED = 5,
  /** ABORTED - The Job was aborted. */
  ABORTED = 6,
  /** SKIPPED - The Job was skipped. */
  SKIPPED = 7,
  /** IGNORED - The Job was ignored. */
  IGNORED = 8,
  UNRECOGNIZED = -1,
}

export function job_StateFromJSON(object: any): Job_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Job_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Job_State.PENDING;
    case 2:
    case "DISABLED":
      return Job_State.DISABLED;
    case 3:
    case "IN_PROGRESS":
      return Job_State.IN_PROGRESS;
    case 4:
    case "SUCCEEDED":
      return Job_State.SUCCEEDED;
    case 5:
    case "FAILED":
      return Job_State.FAILED;
    case 6:
    case "ABORTED":
      return Job_State.ABORTED;
    case 7:
    case "SKIPPED":
      return Job_State.SKIPPED;
    case 8:
    case "IGNORED":
      return Job_State.IGNORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_State.UNRECOGNIZED;
  }
}

export function job_StateToJSON(object: Job_State): string {
  switch (object) {
    case Job_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Job_State.PENDING:
      return "PENDING";
    case Job_State.DISABLED:
      return "DISABLED";
    case Job_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Job_State.SUCCEEDED:
      return "SUCCEEDED";
    case Job_State.FAILED:
      return "FAILED";
    case Job_State.ABORTED:
      return "ABORTED";
    case Job_State.SKIPPED:
      return "SKIPPED";
    case Job_State.IGNORED:
      return "IGNORED";
    case Job_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A deploy Job. */
export interface DeployJob {
}

/** A verify Job. */
export interface VerifyJob {
}

/** A predeploy Job. */
export interface PredeployJob {
  /** Output only. The custom actions that the predeploy Job executes. */
  actions: string[];
}

/** A postdeploy Job. */
export interface PostdeployJob {
  /** Output only. The custom actions that the postdeploy Job executes. */
  actions: string[];
}

/** A createChildRollout Job. */
export interface CreateChildRolloutJob {
}

/** An advanceChildRollout Job. */
export interface AdvanceChildRolloutJob {
}

/** ListRolloutsRequest is the request object used by `ListRollouts`. */
export interface ListRolloutsRequest {
  /** Required. The `Release` which owns this collection of `Rollout` objects. */
  parent: string;
  /**
   * Optional. The maximum number of `Rollout` objects to return. The service
   * may return fewer than this value. If unspecified, at most 50 `Rollout`
   * objects will be returned. The maximum value is 1000; values above 1000 will
   * be set to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListRollouts` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter rollouts to be returned. See https://google.aip.dev/160
   * for more details.
   */
  filter: string;
  /**
   * Optional. Field to sort by. See https://google.aip.dev/132#ordering for
   * more details.
   */
  orderBy: string;
}

/** ListRolloutsResponse is the response object reutrned by `ListRollouts`. */
export interface ListRolloutsResponse {
  /** The `Rollout` objects. */
  rollouts: Rollout[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** GetRolloutRequest is the request object used by `GetRollout`. */
export interface GetRolloutRequest {
  /**
   * Required. Name of the `Rollout`. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}`.
   */
  name: string;
}

/** CreateRolloutRequest is the request object used by `CreateRollout`. */
export interface CreateRolloutRequest {
  /**
   * Required. The parent collection in which the `Rollout` must be created.
   * The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}`.
   */
  parent: string;
  /** Required. ID of the `Rollout`. */
  rolloutId: string;
  /** Required. The `Rollout` to create. */
  rollout:
    | Rollout
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
  /**
   * Optional. The starting phase ID for the `Rollout`. If empty the `Rollout`
   * will start at the first phase.
   */
  startingPhaseId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** The request object used by `ApproveRollout`. */
export interface ApproveRolloutRequest {
  /**
   * Required. Name of the Rollout. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  name: string;
  /** Required. True = approve; false = reject */
  approved: boolean;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `ApproveRollout`. */
export interface ApproveRolloutResponse {
}

/** The request object used by `AdvanceRollout`. */
export interface AdvanceRolloutRequest {
  /**
   * Required. Name of the Rollout. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  name: string;
  /** Required. The phase ID to advance the `Rollout` to. */
  phaseId: string;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `AdvanceRollout`. */
export interface AdvanceRolloutResponse {
}

/** The request object used by `CancelRollout`. */
export interface CancelRolloutRequest {
  /**
   * Required. Name of the Rollout. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  name: string;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `CancelRollout`. */
export interface CancelRolloutResponse {
}

/** The request object used by `IgnoreJob`. */
export interface IgnoreJobRequest {
  /**
   * Required. Name of the Rollout. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  rollout: string;
  /** Required. The phase ID the Job to ignore belongs to. */
  phaseId: string;
  /** Required. The job ID for the Job to ignore. */
  jobId: string;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `IgnoreJob`. */
export interface IgnoreJobResponse {
}

/** RetryJobRequest is the request object used by `RetryJob`. */
export interface RetryJobRequest {
  /**
   * Required. Name of the Rollout. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  rollout: string;
  /** Required. The phase ID the Job to retry belongs to. */
  phaseId: string;
  /** Required. The job ID for the Job to retry. */
  jobId: string;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from 'RetryJob'. */
export interface RetryJobResponse {
}

/** The request object used by `AbandonRelease`. */
export interface AbandonReleaseRequest {
  /**
   * Required. Name of the Release. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}`.
   */
  name: string;
}

/** The response object for `AbandonRelease`. */
export interface AbandonReleaseResponse {
}

/**
 * A `JobRun` resource in the Cloud Deploy API.
 *
 * A `JobRun` contains information of a single `Rollout` job evaluation.
 */
export interface JobRun {
  /**
   * Optional. Name of the `JobRun`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{releases}/rollouts/{rollouts}/jobRuns/{uuid}`.
   */
  name: string;
  /** Output only. Unique identifier of the `JobRun`. */
  uid: string;
  /** Output only. ID of the `Rollout` phase this `JobRun` belongs in. */
  phaseId: string;
  /** Output only. ID of the `Rollout` job this `JobRun` corresponds to. */
  jobId: string;
  /** Output only. Time at which the `JobRun` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time at which the `JobRun` was started. */
  startTime:
    | Date
    | undefined;
  /** Output only. Time at which the `JobRun` ended. */
  endTime:
    | Date
    | undefined;
  /** Output only. The current state of the `JobRun`. */
  state: JobRun_State;
  /** Output only. Information specific to a deploy `JobRun`. */
  deployJobRun?:
    | DeployJobRun
    | undefined;
  /** Output only. Information specific to a verify `JobRun`. */
  verifyJobRun?:
    | VerifyJobRun
    | undefined;
  /** Output only. Information specific to a predeploy `JobRun`. */
  predeployJobRun?:
    | PredeployJobRun
    | undefined;
  /** Output only. Information specific to a postdeploy `JobRun`. */
  postdeployJobRun?:
    | PostdeployJobRun
    | undefined;
  /** Output only. Information specific to a createChildRollout `JobRun`. */
  createChildRolloutJobRun?:
    | CreateChildRolloutJobRun
    | undefined;
  /** Output only. Information specific to an advanceChildRollout `JobRun` */
  advanceChildRolloutJobRun?:
    | AdvanceChildRolloutJobRun
    | undefined;
  /**
   * Output only. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/** Valid states of a `JobRun`. */
export enum JobRun_State {
  /** STATE_UNSPECIFIED - The `JobRun` has an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - The `JobRun` is in progress. */
  IN_PROGRESS = 1,
  /** SUCCEEDED - The `JobRun` has succeeded. */
  SUCCEEDED = 2,
  /** FAILED - The `JobRun` has failed. */
  FAILED = 3,
  /** TERMINATING - The `JobRun` is terminating. */
  TERMINATING = 4,
  /** TERMINATED - The `JobRun` was terminated. */
  TERMINATED = 5,
  UNRECOGNIZED = -1,
}

export function jobRun_StateFromJSON(object: any): JobRun_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return JobRun_State.STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return JobRun_State.IN_PROGRESS;
    case 2:
    case "SUCCEEDED":
      return JobRun_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return JobRun_State.FAILED;
    case 4:
    case "TERMINATING":
      return JobRun_State.TERMINATING;
    case 5:
    case "TERMINATED":
      return JobRun_State.TERMINATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobRun_State.UNRECOGNIZED;
  }
}

export function jobRun_StateToJSON(object: JobRun_State): string {
  switch (object) {
    case JobRun_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case JobRun_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case JobRun_State.SUCCEEDED:
      return "SUCCEEDED";
    case JobRun_State.FAILED:
      return "FAILED";
    case JobRun_State.TERMINATING:
      return "TERMINATING";
    case JobRun_State.TERMINATED:
      return "TERMINATED";
    case JobRun_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DeployJobRun contains information specific to a deploy `JobRun`. */
export interface DeployJobRun {
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to deploy. Format is
   * `projects/{project}/locations/{location}/builds/{build}`.
   */
  build: string;
  /**
   * Output only. The reason the deploy failed. This will always be unspecified
   * while the deploy is in progress or if it succeeded.
   */
  failureCause: DeployJobRun_FailureCause;
  /** Output only. Additional information about the deploy failure, if available. */
  failureMessage: string;
  /** Output only. Metadata containing information about the deploy job run. */
  metadata:
    | DeployJobRunMetadata
    | undefined;
  /** Output only. The artifact of a deploy job run, if available. */
  artifact: DeployArtifact | undefined;
}

/** Well-known deploy failures. */
export enum DeployJobRun_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or because
   * Cloud Deploy has insufficient permissions. See [Required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The deploy operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /** DEADLINE_EXCEEDED - The deploy job run did not complete within the alloted time. */
  DEADLINE_EXCEEDED = 3,
  /**
   * MISSING_RESOURCES_FOR_CANARY - There were missing resources in the runtime environment required for a
   * canary deployment. Check the Cloud Build logs for more information.
   */
  MISSING_RESOURCES_FOR_CANARY = 4,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
   * for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 5,
  /** DEPLOY_FEATURE_NOT_SUPPORTED - The deploy operation had a feature configured that is not supported. */
  DEPLOY_FEATURE_NOT_SUPPORTED = 6,
  UNRECOGNIZED = -1,
}

export function deployJobRun_FailureCauseFromJSON(object: any): DeployJobRun_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return DeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return DeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return DeployJobRun_FailureCause.EXECUTION_FAILED;
    case 3:
    case "DEADLINE_EXCEEDED":
      return DeployJobRun_FailureCause.DEADLINE_EXCEEDED;
    case 4:
    case "MISSING_RESOURCES_FOR_CANARY":
      return DeployJobRun_FailureCause.MISSING_RESOURCES_FOR_CANARY;
    case 5:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return DeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case 6:
    case "DEPLOY_FEATURE_NOT_SUPPORTED":
      return DeployJobRun_FailureCause.DEPLOY_FEATURE_NOT_SUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeployJobRun_FailureCause.UNRECOGNIZED;
  }
}

export function deployJobRun_FailureCauseToJSON(object: DeployJobRun_FailureCause): string {
  switch (object) {
    case DeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case DeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case DeployJobRun_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case DeployJobRun_FailureCause.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case DeployJobRun_FailureCause.MISSING_RESOURCES_FOR_CANARY:
      return "MISSING_RESOURCES_FOR_CANARY";
    case DeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case DeployJobRun_FailureCause.DEPLOY_FEATURE_NOT_SUPPORTED:
      return "DEPLOY_FEATURE_NOT_SUPPORTED";
    case DeployJobRun_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VerifyJobRun contains information specific to a verify `JobRun`. */
export interface VerifyJobRun {
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to verify. Format is
   * `projects/{project}/locations/{location}/builds/{build}`.
   */
  build: string;
  /**
   * Output only. URI of a directory containing the verify artifacts. This
   * contains the Skaffold event log.
   */
  artifactUri: string;
  /**
   * Output only. File path of the Skaffold event log relative to the artifact
   * URI.
   */
  eventLogPath: string;
  /**
   * Output only. The reason the verify failed. This will always be unspecified
   * while the verify is in progress or if it succeeded.
   */
  failureCause: VerifyJobRun_FailureCause;
  /** Output only. Additional information about the verify failure, if available. */
  failureMessage: string;
}

/** Well-known verify failures. */
export enum VerifyJobRun_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or because
   * Cloud Deploy has insufficient permissions. See [required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The verify operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /** DEADLINE_EXCEEDED - The verify job run did not complete within the alloted time. */
  DEADLINE_EXCEEDED = 3,
  /** VERIFICATION_CONFIG_NOT_FOUND - No Skaffold verify configuration was found. */
  VERIFICATION_CONFIG_NOT_FOUND = 4,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
   * for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 5,
  UNRECOGNIZED = -1,
}

export function verifyJobRun_FailureCauseFromJSON(object: any): VerifyJobRun_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return VerifyJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return VerifyJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return VerifyJobRun_FailureCause.EXECUTION_FAILED;
    case 3:
    case "DEADLINE_EXCEEDED":
      return VerifyJobRun_FailureCause.DEADLINE_EXCEEDED;
    case 4:
    case "VERIFICATION_CONFIG_NOT_FOUND":
      return VerifyJobRun_FailureCause.VERIFICATION_CONFIG_NOT_FOUND;
    case 5:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return VerifyJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerifyJobRun_FailureCause.UNRECOGNIZED;
  }
}

export function verifyJobRun_FailureCauseToJSON(object: VerifyJobRun_FailureCause): string {
  switch (object) {
    case VerifyJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case VerifyJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case VerifyJobRun_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case VerifyJobRun_FailureCause.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case VerifyJobRun_FailureCause.VERIFICATION_CONFIG_NOT_FOUND:
      return "VERIFICATION_CONFIG_NOT_FOUND";
    case VerifyJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case VerifyJobRun_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PredeployJobRun contains information specific to a predeploy `JobRun`. */
export interface PredeployJobRun {
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to execute the custom actions associated with the predeploy Job.
   * Format is `projects/{project}/locations/{location}/builds/{build}`.
   */
  build: string;
  /**
   * Output only. The reason the predeploy failed. This will always be
   * unspecified while the predeploy is in progress or if it succeeded.
   */
  failureCause: PredeployJobRun_FailureCause;
  /**
   * Output only. Additional information about the predeploy failure, if
   * available.
   */
  failureMessage: string;
}

/** Well-known predeploy failures. */
export enum PredeployJobRun_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or because
   * Cloud Deploy has insufficient permissions. See [required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The predeploy operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /** DEADLINE_EXCEEDED - The predeploy job run did not complete within the alloted time. */
  DEADLINE_EXCEEDED = 3,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
   * for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function predeployJobRun_FailureCauseFromJSON(object: any): PredeployJobRun_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return PredeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return PredeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return PredeployJobRun_FailureCause.EXECUTION_FAILED;
    case 3:
    case "DEADLINE_EXCEEDED":
      return PredeployJobRun_FailureCause.DEADLINE_EXCEEDED;
    case 4:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return PredeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PredeployJobRun_FailureCause.UNRECOGNIZED;
  }
}

export function predeployJobRun_FailureCauseToJSON(object: PredeployJobRun_FailureCause): string {
  switch (object) {
    case PredeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case PredeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case PredeployJobRun_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case PredeployJobRun_FailureCause.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case PredeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case PredeployJobRun_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PostdeployJobRun contains information specific to a postdeploy `JobRun`. */
export interface PostdeployJobRun {
  /**
   * Output only. The resource name of the Cloud Build `Build` object that is
   * used to execute the custom actions associated with the postdeploy Job.
   * Format is `projects/{project}/locations/{location}/builds/{build}`.
   */
  build: string;
  /**
   * Output only. The reason the postdeploy failed. This will always be
   * unspecified while the postdeploy is in progress or if it succeeded.
   */
  failureCause: PostdeployJobRun_FailureCause;
  /**
   * Output only. Additional information about the postdeploy failure, if
   * available.
   */
  failureMessage: string;
}

/** Well-known postdeploy failures. */
export enum PostdeployJobRun_FailureCause {
  /** FAILURE_CAUSE_UNSPECIFIED - No reason for failure is specified. */
  FAILURE_CAUSE_UNSPECIFIED = 0,
  /**
   * CLOUD_BUILD_UNAVAILABLE - Cloud Build is not available, either because it is not enabled or because
   * Cloud Deploy has insufficient permissions. See [required
   * permission](https://cloud.google.com/deploy/docs/cloud-deploy-service-account#required_permissions).
   */
  CLOUD_BUILD_UNAVAILABLE = 1,
  /**
   * EXECUTION_FAILED - The postdeploy operation did not complete successfully; check Cloud Build
   * logs.
   */
  EXECUTION_FAILED = 2,
  /** DEADLINE_EXCEEDED - The postdeploy job run did not complete within the alloted time. */
  DEADLINE_EXCEEDED = 3,
  /**
   * CLOUD_BUILD_REQUEST_FAILED - Cloud Build failed to fulfill Cloud Deploy's request. See failure_message
   * for additional details.
   */
  CLOUD_BUILD_REQUEST_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function postdeployJobRun_FailureCauseFromJSON(object: any): PostdeployJobRun_FailureCause {
  switch (object) {
    case 0:
    case "FAILURE_CAUSE_UNSPECIFIED":
      return PostdeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED;
    case 1:
    case "CLOUD_BUILD_UNAVAILABLE":
      return PostdeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE;
    case 2:
    case "EXECUTION_FAILED":
      return PostdeployJobRun_FailureCause.EXECUTION_FAILED;
    case 3:
    case "DEADLINE_EXCEEDED":
      return PostdeployJobRun_FailureCause.DEADLINE_EXCEEDED;
    case 4:
    case "CLOUD_BUILD_REQUEST_FAILED":
      return PostdeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostdeployJobRun_FailureCause.UNRECOGNIZED;
  }
}

export function postdeployJobRun_FailureCauseToJSON(object: PostdeployJobRun_FailureCause): string {
  switch (object) {
    case PostdeployJobRun_FailureCause.FAILURE_CAUSE_UNSPECIFIED:
      return "FAILURE_CAUSE_UNSPECIFIED";
    case PostdeployJobRun_FailureCause.CLOUD_BUILD_UNAVAILABLE:
      return "CLOUD_BUILD_UNAVAILABLE";
    case PostdeployJobRun_FailureCause.EXECUTION_FAILED:
      return "EXECUTION_FAILED";
    case PostdeployJobRun_FailureCause.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case PostdeployJobRun_FailureCause.CLOUD_BUILD_REQUEST_FAILED:
      return "CLOUD_BUILD_REQUEST_FAILED";
    case PostdeployJobRun_FailureCause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * CreateChildRolloutJobRun contains information specific to a
 * createChildRollout `JobRun`.
 */
export interface CreateChildRolloutJobRun {
  /**
   * Output only. Name of the `ChildRollout`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  rollout: string;
  /** Output only. The ID of the childRollout Phase initiated by this JobRun. */
  rolloutPhaseId: string;
}

/**
 * AdvanceChildRolloutJobRun contains information specific to a
 * advanceChildRollout `JobRun`.
 */
export interface AdvanceChildRolloutJobRun {
  /**
   * Output only. Name of the `ChildRollout`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}`.
   */
  rollout: string;
  /** Output only. the ID of the ChildRollout's Phase. */
  rolloutPhaseId: string;
}

/** ListJobRunsRequest is the request object used by `ListJobRuns`. */
export interface ListJobRunsRequest {
  /** Required. The `Rollout` which owns this collection of `JobRun` objects. */
  parent: string;
  /**
   * Optional. The maximum number of `JobRun` objects to return. The service may
   * return fewer than this value. If unspecified, at most 50 `JobRun` objects
   * will be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListJobRuns` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match the call that provided
   * the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter results to be returned. See https://google.aip.dev/160 for
   * more details.
   */
  filter: string;
  /**
   * Optional. Field to sort by. See https://google.aip.dev/132#ordering for
   * more details.
   */
  orderBy: string;
}

/** ListJobRunsResponse is the response object returned by `ListJobRuns`. */
export interface ListJobRunsResponse {
  /** The `JobRun` objects. */
  jobRuns: JobRun[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page. If
   * this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached */
  unreachable: string[];
}

/** GetJobRunRequest is the request object used by `GetJobRun`. */
export interface GetJobRunRequest {
  /**
   * Required. Name of the `JobRun`. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/releases/{release_name}/rollouts/{rollout_name}/jobRuns/{job_run_name}`.
   */
  name: string;
}

/** The request object used by `TerminateJobRun`. */
export interface TerminateJobRunRequest {
  /**
   * Required. Name of the `JobRun`. Format must be
   * `projects/{project}/locations/{location}/deliveryPipelines/{deliveryPipeline}/releases/{release}/rollouts/{rollout}/jobRuns/{jobRun}`.
   */
  name: string;
  /**
   * Optional. Deploy policies to override. Format is
   * `projects/{project}/locations/{location}/deployPolicies/{deployPolicy}`.
   */
  overrideDeployPolicy: string[];
}

/** The response object from `TerminateJobRun`. */
export interface TerminateJobRunResponse {
}

/** Service-wide configuration. */
export interface Config {
  /** Name of the configuration. */
  name: string;
  /** All supported versions of Skaffold. */
  supportedVersions: SkaffoldVersion[];
  /**
   * Default Skaffold version that is assigned when a Release is created without
   * specifying a Skaffold version.
   */
  defaultSkaffoldVersion: string;
}

/** Details of a supported Skaffold version. */
export interface SkaffoldVersion {
  /** Release version number. For example, "1.20.3". */
  version: string;
  /** The time at which this version of Skaffold will enter maintenance mode. */
  maintenanceModeTime:
    | Date
    | undefined;
  /** The time at which this version of Skaffold will no longer be supported. */
  supportExpirationTime:
    | Date
    | undefined;
  /** Date when this version is expected to no longer be supported. */
  supportEndDate: DateMessage | undefined;
}

/** Request to get a configuration. */
export interface GetConfigRequest {
  /** Required. Name of requested configuration. */
  name: string;
}

/**
 * An `Automation` resource in the Cloud Deploy API.
 *
 * An `Automation` enables the automation of manually driven actions for
 * a Delivery Pipeline, which includes Release promotion among Targets,
 * Rollout repair and Rollout deployment strategy advancement. The intention
 * of Automation is to reduce manual intervention in the continuous delivery
 * process.
 */
export interface Automation {
  /**
   * Output only. Name of the `Automation`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automations/{automation}`.
   */
  name: string;
  /** Output only. Unique identifier of the `Automation`. */
  uid: string;
  /** Optional. Description of the `Automation`. Max length is 255 characters. */
  description: string;
  /** Output only. Time at which the automation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time at which the automation was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. User annotations. These attributes can only be set and used by
   * the user, and not by Cloud Deploy. Annotations must meet the following
   * constraints:
   *
   * * Annotations are key/value pairs.
   * * Valid annotation keys have two segments: an optional prefix and name,
   * separated by a slash (`/`).
   * * The name segment is required and must be 63 characters or less,
   * beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with
   * dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
   * * The prefix is optional. If specified, the prefix must be a DNS subdomain:
   * a series of DNS labels separated by dots(`.`), not longer than 253
   * characters in total, followed by a slash (`/`).
   *
   * See
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
   * for more details.
   */
  annotations: { [key: string]: string };
  /**
   * Optional. Labels are attributes that can be set and used by both the
   * user and by Cloud Deploy. Labels must meet the following constraints:
   *
   * * Keys and values can contain only lowercase letters, numeric characters,
   * underscores, and dashes.
   * * All characters must use UTF-8 encoding, and international characters are
   * allowed.
   * * Keys must start with a lowercase letter or international character.
   * * Each resource is limited to a maximum of 64 labels.
   *
   * Both keys and values are additionally constrained to be <= 63 characters.
   */
  labels: { [key: string]: string };
  /**
   * Optional. The weak etag of the `Automation` resource.
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /** Optional. When Suspended, automation is deactivated from execution. */
  suspended: boolean;
  /**
   * Required. Email address of the user-managed IAM service account that
   * creates Cloud Deploy release and rollout resources.
   */
  serviceAccount: string;
  /** Required. Selected resources to which the automation will be applied. */
  selector:
    | AutomationResourceSelector
    | undefined;
  /**
   * Required. List of Automation rules associated with the Automation resource.
   * Must have at least one rule and limited to 250 rules per Delivery Pipeline.
   * Note: the order of the rules here is not the same as the order of
   * execution.
   */
  rules: AutomationRule[];
}

export interface Automation_AnnotationsEntry {
  key: string;
  value: string;
}

export interface Automation_LabelsEntry {
  key: string;
  value: string;
}

/**
 * AutomationResourceSelector contains the information to select the resources
 * to which an Automation is going to be applied.
 */
export interface AutomationResourceSelector {
  /** Contains attributes about a target. */
  targets: TargetAttribute[];
}

/** `AutomationRule` defines the automation activities. */
export interface AutomationRule {
  /**
   * Optional. `PromoteReleaseRule` will automatically promote a release from
   * the current target to a specified target.
   */
  promoteReleaseRule?:
    | PromoteReleaseRule
    | undefined;
  /**
   * Optional. The `AdvanceRolloutRule` will automatically advance a
   * successful Rollout.
   */
  advanceRolloutRule?:
    | AdvanceRolloutRule
    | undefined;
  /**
   * Optional. The `RepairRolloutRule` will automatically repair a failed
   * rollout.
   */
  repairRolloutRule?: RepairRolloutRule | undefined;
}

/**
 * The `PromoteRelease` rule will automatically promote a release from the
 * current target to a specified target.
 */
export interface PromoteReleaseRule {
  /**
   * Required. ID of the rule. This id must be unique in the `Automation`
   * resource to which this rule belongs. The format is
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  id: string;
  /**
   * Optional. How long the release need to be paused until being promoted to
   * the next target.
   */
  wait:
    | Duration
    | undefined;
  /**
   * Optional. The ID of the stage in the pipeline to which this `Release` is
   * deploying. If unspecified, default it to the next stage in the promotion
   * flow. The value of this field could be one of the following:
   *
   * * The last segment of a target name
   * * "@next", the next target in the promotion sequence
   */
  destinationTargetId: string;
  /** Output only. Information around the state of the Automation rule. */
  condition:
    | AutomationRuleCondition
    | undefined;
  /**
   * Optional. The starting phase of the rollout created by this operation.
   * Default to the first phase.
   */
  destinationPhase: string;
}

/**
 * The `AdvanceRollout` automation rule will automatically advance a successful
 * Rollout to the next phase.
 */
export interface AdvanceRolloutRule {
  /**
   * Required. ID of the rule. This id must be unique in the `Automation`
   * resource to which this rule belongs. The format is
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  id: string;
  /**
   * Optional. Proceeds only after phase name matched any one in the list.
   * This value must consist of lower-case letters, numbers, and hyphens,
   * start with a letter and end with a letter or a number, and have a max
   * length of 63 characters. In other words, it must match the following
   * regex: `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
   */
  sourcePhases: string[];
  /** Optional. How long to wait after a rollout is finished. */
  wait:
    | Duration
    | undefined;
  /** Output only. Information around the state of the Automation rule. */
  condition: AutomationRuleCondition | undefined;
}

/**
 * The `RepairRolloutRule` automation rule will automatically repair a failed
 * `Rollout`.
 */
export interface RepairRolloutRule {
  /**
   * Required. ID of the rule. This id must be unique in the `Automation`
   * resource to which this rule belongs. The format is
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  id: string;
  /**
   * Optional. Jobs to repair. Proceeds only after job name matched any one in
   * the list, or for all jobs if unspecified or empty. The phase that includes
   * the job must match the phase ID specified in `source_phase`. This value
   * must consist of lower-case letters, numbers, and hyphens, start with a
   * letter and end with a letter or a number, and have a max length of 63
   * characters. In other words, it must match the following regex:
   * `^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$`.
   */
  jobs: string[];
  /** Output only. Information around the state of the 'Automation' rule. */
  condition: AutomationRuleCondition | undefined;
}

/**
 * `AutomationRuleCondition` contains conditions relevant to an
 * `Automation` rule.
 */
export interface AutomationRuleCondition {
  /** Optional. Details around targets enumerated in the rule. */
  targetsPresentCondition: TargetsPresentCondition | undefined;
}

/** The request object for `CreateAutomation`. */
export interface CreateAutomationRequest {
  /**
   * Required. The parent collection in which the `Automation` must be created.
   * The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  parent: string;
  /** Required. ID of the `Automation`. */
  automationId: string;
  /** Required. The `Automation` to create. */
  automation:
    | Automation
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `UpdateAutomation`. */
export interface UpdateAutomationRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten by the
   * update in the `Automation` resource. The fields specified in the
   * update_mask are relative to the resource, not the full request. A field
   * will be overwritten if it's in the mask. If the user doesn't provide a mask
   * then all fields are overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The `Automation` to update. */
  automation:
    | Automation
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, updating a `Automation` that does not exist will
   * result in the creation of a new `Automation`.
   */
  allowMissing: boolean;
  /**
   * Optional. If set to true, the request is validated and the user is provided
   * with an expected result, but no actual change is made.
   */
  validateOnly: boolean;
}

/** The request object for `DeleteAutomation`. */
export interface DeleteAutomationRequest {
  /**
   * Required. The name of the `Automation` to delete. The format is
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server knows to ignore the
   * request if it has already been completed. The server guarantees that for
   * at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, then deleting an already deleted or non-existing
   * `Automation` will succeed.
   */
  allowMissing: boolean;
  /**
   * Optional. If set, validate the request and verify whether the resource
   * exists, but do not actually post it.
   */
  validateOnly: boolean;
  /**
   * Optional. The weak etag of the request.
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/** The request object for `ListAutomations`. */
export interface ListAutomationsRequest {
  /**
   * Required. The parent `Delivery Pipeline`, which owns this collection of
   * automations. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}`.
   */
  parent: string;
  /**
   * The maximum number of automations to return. The service may return
   * fewer than this value. If unspecified, at most 50 automations will
   * be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAutomations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Filter automations to be returned. All fields can be used in the
   * filter.
   */
  filter: string;
  /** Field to sort by. */
  orderBy: string;
}

/** The response object from `ListAutomations`. */
export interface ListAutomationsResponse {
  /** The `Automation` objects. */
  automations: Automation[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetAutomation` */
export interface GetAutomationRequest {
  /**
   * Required. Name of the `Automation`. Format must be
   * `projects/{project_id}/locations/{location_name}/deliveryPipelines/{pipeline_name}/automations/{automation_name}`.
   */
  name: string;
}

/**
 * An `AutomationRun` resource in the Cloud Deploy API.
 *
 * An `AutomationRun` represents an execution instance of an
 * automation rule.
 */
export interface AutomationRun {
  /**
   * Output only. Name of the `AutomationRun`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
   */
  name: string;
  /** Output only. Time at which the `AutomationRun` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time at which the automationRun was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The weak etag of the `AutomationRun` resource.
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Output only. Email address of the user-managed IAM service account that
   * performs the operations against Cloud Deploy resources.
   */
  serviceAccount: string;
  /**
   * Output only. Snapshot of the Automation taken at AutomationRun creation
   * time.
   */
  automationSnapshot:
    | Automation
    | undefined;
  /**
   * Output only. The ID of the target that represents the promotion stage that
   * initiates the `AutomationRun`. The value of this field is the last segment
   * of a target name.
   */
  targetId: string;
  /** Output only. Current state of the `AutomationRun`. */
  state: AutomationRun_State;
  /**
   * Output only. Explains the current state of the `AutomationRun`. Present
   * only when an explanation is needed.
   */
  stateDescription: string;
  /**
   * Output only. Contains information about what policies prevented the
   * `AutomationRun` from proceeding.
   */
  policyViolation:
    | PolicyViolation
    | undefined;
  /**
   * Output only. Time the `AutomationRun` expires. An `AutomationRun` expires
   * after 14 days from its creation date.
   */
  expireTime:
    | Date
    | undefined;
  /** Output only. The ID of the automation rule that initiated the operation. */
  ruleId: string;
  /** Output only. The ID of the automation that initiated the operation. */
  automationId: string;
  /** Output only. Promotes a release to a specified 'Target'. */
  promoteReleaseOperation?:
    | PromoteReleaseOperation
    | undefined;
  /** Output only. Advances a rollout to the next phase. */
  advanceRolloutOperation?:
    | AdvanceRolloutOperation
    | undefined;
  /** Output only. Repairs a failed 'Rollout'. */
  repairRolloutOperation?:
    | RepairRolloutOperation
    | undefined;
  /**
   * Output only. Earliest time the `AutomationRun` will attempt to resume.
   * Wait-time is configured by `wait` in automation rule.
   */
  waitUntilTime: Date | undefined;
}

/** Valid state of an `AutomationRun`. */
export enum AutomationRun_State {
  /** STATE_UNSPECIFIED - The `AutomationRun` has an unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The `AutomationRun` has succeeded. */
  SUCCEEDED = 1,
  /** CANCELLED - The `AutomationRun` was cancelled. */
  CANCELLED = 2,
  /** FAILED - The `AutomationRun` has failed. */
  FAILED = 3,
  /** IN_PROGRESS - The `AutomationRun` is in progress. */
  IN_PROGRESS = 4,
  /** PENDING - The `AutomationRun` is pending. */
  PENDING = 5,
  /** ABORTED - The `AutomationRun` was aborted. */
  ABORTED = 6,
  UNRECOGNIZED = -1,
}

export function automationRun_StateFromJSON(object: any): AutomationRun_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AutomationRun_State.STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return AutomationRun_State.SUCCEEDED;
    case 2:
    case "CANCELLED":
      return AutomationRun_State.CANCELLED;
    case 3:
    case "FAILED":
      return AutomationRun_State.FAILED;
    case 4:
    case "IN_PROGRESS":
      return AutomationRun_State.IN_PROGRESS;
    case 5:
    case "PENDING":
      return AutomationRun_State.PENDING;
    case 6:
    case "ABORTED":
      return AutomationRun_State.ABORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationRun_State.UNRECOGNIZED;
  }
}

export function automationRun_StateToJSON(object: AutomationRun_State): string {
  switch (object) {
    case AutomationRun_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AutomationRun_State.SUCCEEDED:
      return "SUCCEEDED";
    case AutomationRun_State.CANCELLED:
      return "CANCELLED";
    case AutomationRun_State.FAILED:
      return "FAILED";
    case AutomationRun_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case AutomationRun_State.PENDING:
      return "PENDING";
    case AutomationRun_State.ABORTED:
      return "ABORTED";
    case AutomationRun_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains the information of an automated promote-release operation. */
export interface PromoteReleaseOperation {
  /**
   * Output only. The ID of the target that represents the promotion stage to
   * which the release will be promoted. The value of this field is the last
   * segment of a target name.
   */
  targetId: string;
  /** Output only. How long the operation will be paused. */
  wait:
    | Duration
    | undefined;
  /** Output only. The name of the rollout that initiates the `AutomationRun`. */
  rollout: string;
  /** Output only. The starting phase of the rollout created by this operation. */
  phase: string;
}

/** Contains the information of an automated advance-rollout operation. */
export interface AdvanceRolloutOperation {
  /** Output only. The phase of a deployment that initiated the operation. */
  sourcePhase: string;
  /** Output only. How long the operation will be paused. */
  wait:
    | Duration
    | undefined;
  /** Output only. The name of the rollout that initiates the `AutomationRun`. */
  rollout: string;
  /** Output only. The phase the rollout will be advanced to. */
  destinationPhase: string;
}

/** Contains the information for an automated `repair rollout` operation. */
export interface RepairRolloutOperation {
  /** Output only. The name of the rollout that initiates the `AutomationRun`. */
  rollout: string;
  /**
   * Output only. Records of the repair attempts. Each repair phase may have
   * multiple retry attempts or single rollback attempt.
   */
  repairPhases: RepairPhase[];
  /**
   * Output only. The phase ID of the phase that includes the job being
   * repaired.
   */
  phaseId: string;
  /** Output only. The job ID for the Job to repair. */
  jobId: string;
}

/**
 * RepairPhase tracks the repair attempts that have been made for
 * each `RepairPhaseConfig` specified in the `Automation` resource.
 */
export interface RepairPhase {
  /** Output only. Records of the retry attempts for retry repair mode. */
  retry?:
    | RetryPhase
    | undefined;
  /** Output only. Rollback attempt for rollback repair mode . */
  rollback?: RollbackAttempt | undefined;
}

/**
 * RetryPhase contains the retry attempts and the metadata for initiating a
 * new attempt.
 */
export interface RetryPhase {
  /** Output only. The number of attempts that have been made. */
  totalAttempts: Long;
  /**
   * Output only. The pattern of how the wait time of the retry attempt is
   * calculated.
   */
  backoffMode: BackoffMode;
  /** Output only. Detail of a retry action. */
  attempts: RetryAttempt[];
}

/** RetryAttempt represents an action of retrying the failed Cloud Deploy job. */
export interface RetryAttempt {
  /** Output only. The index of this retry attempt. */
  attempt: Long;
  /** Output only. How long the operation will be paused. */
  wait:
    | Duration
    | undefined;
  /** Output only. Valid state of this retry action. */
  state: RepairState;
  /** Output only. Description of the state of the Retry. */
  stateDesc: string;
}

/** RollbackAttempt represents an action of rolling back a Cloud Deploy 'Target'. */
export interface RollbackAttempt {
  /** Output only. The phase to which the rollout will be rolled back to. */
  destinationPhase: string;
  /** Output only. ID of the rollback `Rollout` to create. */
  rolloutId: string;
  /** Output only. Valid state of this rollback action. */
  state: RepairState;
  /** Output only. Description of the state of the Rollback. */
  stateDesc: string;
}

/** The request object for `ListAutomationRuns`. */
export interface ListAutomationRunsRequest {
  /**
   * Required. The parent `Delivery Pipeline`, which owns this collection of
   * automationRuns. Format must be
   * `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}`.
   */
  parent: string;
  /**
   * The maximum number of automationRuns to return. The service may return
   * fewer than this value. If unspecified, at most 50 automationRuns will
   * be returned. The maximum value is 1000; values above 1000 will be set
   * to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListAutomationRuns` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other provided parameters match
   * the call that provided the page token.
   */
  pageToken: string;
  /**
   * Filter automationRuns to be returned. All fields can be used in the
   * filter.
   */
  filter: string;
  /** Field to sort by. */
  orderBy: string;
}

/** The response object from `ListAutomationRuns`. */
export interface ListAutomationRunsResponse {
  /** The `AutomationRuns` objects. */
  automationRuns: AutomationRun[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** The request object for `GetAutomationRun` */
export interface GetAutomationRunRequest {
  /**
   * Required. Name of the `AutomationRun`. Format must be
   * `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
   */
  name: string;
}

/** The request object used by `CancelAutomationRun`. */
export interface CancelAutomationRunRequest {
  /**
   * Required. Name of the `AutomationRun`. Format is
   * `projects/{project}/locations/{location}/deliveryPipelines/{delivery_pipeline}/automationRuns/{automation_run}`.
   */
  name: string;
}

/** The response object from `CancelAutomationRun`. */
export interface CancelAutomationRunResponse {
}

function createBaseDeliveryPipeline(): DeliveryPipeline {
  return {
    name: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    serialPipeline: undefined,
    condition: undefined,
    etag: "",
    suspended: false,
  };
}

export const DeliveryPipeline: MessageFns<DeliveryPipeline> = {
  encode(message: DeliveryPipeline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      DeliveryPipeline_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      DeliveryPipeline_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.serialPipeline !== undefined) {
      SerialPipeline.encode(message.serialPipeline, writer.uint32(66).fork()).join();
    }
    if (message.condition !== undefined) {
      PipelineCondition.encode(message.condition, writer.uint32(90).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(82).string(message.etag);
    }
    if (message.suspended !== false) {
      writer.uint32(96).bool(message.suspended);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryPipeline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryPipeline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = DeliveryPipeline_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.annotations[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = DeliveryPipeline_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serialPipeline = SerialPipeline.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.condition = PipelineCondition.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.suspended = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryPipeline {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      serialPipeline: isSet(object.serialPipeline) ? SerialPipeline.fromJSON(object.serialPipeline) : undefined,
      condition: isSet(object.condition) ? PipelineCondition.fromJSON(object.condition) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      suspended: isSet(object.suspended) ? globalThis.Boolean(object.suspended) : false,
    };
  },

  toJSON(message: DeliveryPipeline): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.serialPipeline !== undefined) {
      obj.serialPipeline = SerialPipeline.toJSON(message.serialPipeline);
    }
    if (message.condition !== undefined) {
      obj.condition = PipelineCondition.toJSON(message.condition);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.suspended !== false) {
      obj.suspended = message.suspended;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryPipeline>): DeliveryPipeline {
    return DeliveryPipeline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryPipeline>): DeliveryPipeline {
    const message = createBaseDeliveryPipeline();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.serialPipeline = (object.serialPipeline !== undefined && object.serialPipeline !== null)
      ? SerialPipeline.fromPartial(object.serialPipeline)
      : undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? PipelineCondition.fromPartial(object.condition)
      : undefined;
    message.etag = object.etag ?? "";
    message.suspended = object.suspended ?? false;
    return message;
  },
};

function createBaseDeliveryPipeline_AnnotationsEntry(): DeliveryPipeline_AnnotationsEntry {
  return { key: "", value: "" };
}

export const DeliveryPipeline_AnnotationsEntry: MessageFns<DeliveryPipeline_AnnotationsEntry> = {
  encode(message: DeliveryPipeline_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryPipeline_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryPipeline_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryPipeline_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeliveryPipeline_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryPipeline_AnnotationsEntry>): DeliveryPipeline_AnnotationsEntry {
    return DeliveryPipeline_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryPipeline_AnnotationsEntry>): DeliveryPipeline_AnnotationsEntry {
    const message = createBaseDeliveryPipeline_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeliveryPipeline_LabelsEntry(): DeliveryPipeline_LabelsEntry {
  return { key: "", value: "" };
}

export const DeliveryPipeline_LabelsEntry: MessageFns<DeliveryPipeline_LabelsEntry> = {
  encode(message: DeliveryPipeline_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryPipeline_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryPipeline_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryPipeline_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeliveryPipeline_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryPipeline_LabelsEntry>): DeliveryPipeline_LabelsEntry {
    return DeliveryPipeline_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryPipeline_LabelsEntry>): DeliveryPipeline_LabelsEntry {
    const message = createBaseDeliveryPipeline_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSerialPipeline(): SerialPipeline {
  return { stages: [] };
}

export const SerialPipeline: MessageFns<SerialPipeline> = {
  encode(message: SerialPipeline, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stages) {
      Stage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SerialPipeline {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSerialPipeline();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stages.push(Stage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SerialPipeline {
    return { stages: globalThis.Array.isArray(object?.stages) ? object.stages.map((e: any) => Stage.fromJSON(e)) : [] };
  },

  toJSON(message: SerialPipeline): unknown {
    const obj: any = {};
    if (message.stages?.length) {
      obj.stages = message.stages.map((e) => Stage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SerialPipeline>): SerialPipeline {
    return SerialPipeline.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SerialPipeline>): SerialPipeline {
    const message = createBaseSerialPipeline();
    message.stages = object.stages?.map((e) => Stage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStage(): Stage {
  return { targetId: "", profiles: [], strategy: undefined, deployParameters: [] };
}

export const Stage: MessageFns<Stage> = {
  encode(message: Stage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetId !== "") {
      writer.uint32(10).string(message.targetId);
    }
    for (const v of message.profiles) {
      writer.uint32(18).string(v!);
    }
    if (message.strategy !== undefined) {
      Strategy.encode(message.strategy, writer.uint32(42).fork()).join();
    }
    for (const v of message.deployParameters) {
      DeployParameters.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.profiles.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.strategy = Strategy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deployParameters.push(DeployParameters.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stage {
    return {
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => globalThis.String(e)) : [],
      strategy: isSet(object.strategy) ? Strategy.fromJSON(object.strategy) : undefined,
      deployParameters: globalThis.Array.isArray(object?.deployParameters)
        ? object.deployParameters.map((e: any) => DeployParameters.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Stage): unknown {
    const obj: any = {};
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.profiles?.length) {
      obj.profiles = message.profiles;
    }
    if (message.strategy !== undefined) {
      obj.strategy = Strategy.toJSON(message.strategy);
    }
    if (message.deployParameters?.length) {
      obj.deployParameters = message.deployParameters.map((e) => DeployParameters.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Stage>): Stage {
    return Stage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stage>): Stage {
    const message = createBaseStage();
    message.targetId = object.targetId ?? "";
    message.profiles = object.profiles?.map((e) => e) || [];
    message.strategy = (object.strategy !== undefined && object.strategy !== null)
      ? Strategy.fromPartial(object.strategy)
      : undefined;
    message.deployParameters = object.deployParameters?.map((e) => DeployParameters.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeployParameters(): DeployParameters {
  return { values: {}, matchTargetLabels: {} };
}

export const DeployParameters: MessageFns<DeployParameters> = {
  encode(message: DeployParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.values).forEach(([key, value]) => {
      DeployParameters_ValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.matchTargetLabels).forEach(([key, value]) => {
      DeployParameters_MatchTargetLabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = DeployParameters_ValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = DeployParameters_MatchTargetLabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.matchTargetLabels[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployParameters {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      matchTargetLabels: isObject(object.matchTargetLabels)
        ? Object.entries(object.matchTargetLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeployParameters): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    if (message.matchTargetLabels) {
      const entries = Object.entries(message.matchTargetLabels);
      if (entries.length > 0) {
        obj.matchTargetLabels = {};
        entries.forEach(([k, v]) => {
          obj.matchTargetLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DeployParameters>): DeployParameters {
    return DeployParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployParameters>): DeployParameters {
    const message = createBaseDeployParameters();
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.matchTargetLabels = Object.entries(object.matchTargetLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDeployParameters_ValuesEntry(): DeployParameters_ValuesEntry {
  return { key: "", value: "" };
}

export const DeployParameters_ValuesEntry: MessageFns<DeployParameters_ValuesEntry> = {
  encode(message: DeployParameters_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployParameters_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployParameters_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployParameters_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeployParameters_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployParameters_ValuesEntry>): DeployParameters_ValuesEntry {
    return DeployParameters_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployParameters_ValuesEntry>): DeployParameters_ValuesEntry {
    const message = createBaseDeployParameters_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeployParameters_MatchTargetLabelsEntry(): DeployParameters_MatchTargetLabelsEntry {
  return { key: "", value: "" };
}

export const DeployParameters_MatchTargetLabelsEntry: MessageFns<DeployParameters_MatchTargetLabelsEntry> = {
  encode(message: DeployParameters_MatchTargetLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployParameters_MatchTargetLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployParameters_MatchTargetLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployParameters_MatchTargetLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeployParameters_MatchTargetLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployParameters_MatchTargetLabelsEntry>): DeployParameters_MatchTargetLabelsEntry {
    return DeployParameters_MatchTargetLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployParameters_MatchTargetLabelsEntry>): DeployParameters_MatchTargetLabelsEntry {
    const message = createBaseDeployParameters_MatchTargetLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStrategy(): Strategy {
  return { standard: undefined, canary: undefined };
}

export const Strategy: MessageFns<Strategy> = {
  encode(message: Strategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.standard !== undefined) {
      Standard.encode(message.standard, writer.uint32(10).fork()).join();
    }
    if (message.canary !== undefined) {
      Canary.encode(message.canary, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Strategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.standard = Standard.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.canary = Canary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Strategy {
    return {
      standard: isSet(object.standard) ? Standard.fromJSON(object.standard) : undefined,
      canary: isSet(object.canary) ? Canary.fromJSON(object.canary) : undefined,
    };
  },

  toJSON(message: Strategy): unknown {
    const obj: any = {};
    if (message.standard !== undefined) {
      obj.standard = Standard.toJSON(message.standard);
    }
    if (message.canary !== undefined) {
      obj.canary = Canary.toJSON(message.canary);
    }
    return obj;
  },

  create(base?: DeepPartial<Strategy>): Strategy {
    return Strategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Strategy>): Strategy {
    const message = createBaseStrategy();
    message.standard = (object.standard !== undefined && object.standard !== null)
      ? Standard.fromPartial(object.standard)
      : undefined;
    message.canary = (object.canary !== undefined && object.canary !== null)
      ? Canary.fromPartial(object.canary)
      : undefined;
    return message;
  },
};

function createBasePredeploy(): Predeploy {
  return { actions: [] };
}

export const Predeploy: MessageFns<Predeploy> = {
  encode(message: Predeploy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Predeploy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredeploy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Predeploy {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Predeploy): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },

  create(base?: DeepPartial<Predeploy>): Predeploy {
    return Predeploy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Predeploy>): Predeploy {
    const message = createBasePredeploy();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBasePostdeploy(): Postdeploy {
  return { actions: [] };
}

export const Postdeploy: MessageFns<Postdeploy> = {
  encode(message: Postdeploy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Postdeploy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostdeploy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Postdeploy {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Postdeploy): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },

  create(base?: DeepPartial<Postdeploy>): Postdeploy {
    return Postdeploy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Postdeploy>): Postdeploy {
    const message = createBasePostdeploy();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBaseStandard(): Standard {
  return { verify: false, predeploy: undefined, postdeploy: undefined };
}

export const Standard: MessageFns<Standard> = {
  encode(message: Standard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.verify !== false) {
      writer.uint32(8).bool(message.verify);
    }
    if (message.predeploy !== undefined) {
      Predeploy.encode(message.predeploy, writer.uint32(18).fork()).join();
    }
    if (message.postdeploy !== undefined) {
      Postdeploy.encode(message.postdeploy, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Standard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.verify = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predeploy = Predeploy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postdeploy = Postdeploy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Standard {
    return {
      verify: isSet(object.verify) ? globalThis.Boolean(object.verify) : false,
      predeploy: isSet(object.predeploy) ? Predeploy.fromJSON(object.predeploy) : undefined,
      postdeploy: isSet(object.postdeploy) ? Postdeploy.fromJSON(object.postdeploy) : undefined,
    };
  },

  toJSON(message: Standard): unknown {
    const obj: any = {};
    if (message.verify !== false) {
      obj.verify = message.verify;
    }
    if (message.predeploy !== undefined) {
      obj.predeploy = Predeploy.toJSON(message.predeploy);
    }
    if (message.postdeploy !== undefined) {
      obj.postdeploy = Postdeploy.toJSON(message.postdeploy);
    }
    return obj;
  },

  create(base?: DeepPartial<Standard>): Standard {
    return Standard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Standard>): Standard {
    const message = createBaseStandard();
    message.verify = object.verify ?? false;
    message.predeploy = (object.predeploy !== undefined && object.predeploy !== null)
      ? Predeploy.fromPartial(object.predeploy)
      : undefined;
    message.postdeploy = (object.postdeploy !== undefined && object.postdeploy !== null)
      ? Postdeploy.fromPartial(object.postdeploy)
      : undefined;
    return message;
  },
};

function createBaseCanary(): Canary {
  return { runtimeConfig: undefined, canaryDeployment: undefined, customCanaryDeployment: undefined };
}

export const Canary: MessageFns<Canary> = {
  encode(message: Canary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runtimeConfig !== undefined) {
      RuntimeConfig.encode(message.runtimeConfig, writer.uint32(10).fork()).join();
    }
    if (message.canaryDeployment !== undefined) {
      CanaryDeployment.encode(message.canaryDeployment, writer.uint32(18).fork()).join();
    }
    if (message.customCanaryDeployment !== undefined) {
      CustomCanaryDeployment.encode(message.customCanaryDeployment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Canary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runtimeConfig = RuntimeConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.canaryDeployment = CanaryDeployment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customCanaryDeployment = CustomCanaryDeployment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Canary {
    return {
      runtimeConfig: isSet(object.runtimeConfig) ? RuntimeConfig.fromJSON(object.runtimeConfig) : undefined,
      canaryDeployment: isSet(object.canaryDeployment) ? CanaryDeployment.fromJSON(object.canaryDeployment) : undefined,
      customCanaryDeployment: isSet(object.customCanaryDeployment)
        ? CustomCanaryDeployment.fromJSON(object.customCanaryDeployment)
        : undefined,
    };
  },

  toJSON(message: Canary): unknown {
    const obj: any = {};
    if (message.runtimeConfig !== undefined) {
      obj.runtimeConfig = RuntimeConfig.toJSON(message.runtimeConfig);
    }
    if (message.canaryDeployment !== undefined) {
      obj.canaryDeployment = CanaryDeployment.toJSON(message.canaryDeployment);
    }
    if (message.customCanaryDeployment !== undefined) {
      obj.customCanaryDeployment = CustomCanaryDeployment.toJSON(message.customCanaryDeployment);
    }
    return obj;
  },

  create(base?: DeepPartial<Canary>): Canary {
    return Canary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Canary>): Canary {
    const message = createBaseCanary();
    message.runtimeConfig = (object.runtimeConfig !== undefined && object.runtimeConfig !== null)
      ? RuntimeConfig.fromPartial(object.runtimeConfig)
      : undefined;
    message.canaryDeployment = (object.canaryDeployment !== undefined && object.canaryDeployment !== null)
      ? CanaryDeployment.fromPartial(object.canaryDeployment)
      : undefined;
    message.customCanaryDeployment =
      (object.customCanaryDeployment !== undefined && object.customCanaryDeployment !== null)
        ? CustomCanaryDeployment.fromPartial(object.customCanaryDeployment)
        : undefined;
    return message;
  },
};

function createBaseCanaryDeployment(): CanaryDeployment {
  return { percentages: [], verify: false, predeploy: undefined, postdeploy: undefined };
}

export const CanaryDeployment: MessageFns<CanaryDeployment> = {
  encode(message: CanaryDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.percentages) {
      writer.int32(v);
    }
    writer.join();
    if (message.verify !== false) {
      writer.uint32(16).bool(message.verify);
    }
    if (message.predeploy !== undefined) {
      Predeploy.encode(message.predeploy, writer.uint32(26).fork()).join();
    }
    if (message.postdeploy !== undefined) {
      Postdeploy.encode(message.postdeploy, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CanaryDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCanaryDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.percentages.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.percentages.push(reader.int32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.verify = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.predeploy = Predeploy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postdeploy = Postdeploy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CanaryDeployment {
    return {
      percentages: globalThis.Array.isArray(object?.percentages)
        ? object.percentages.map((e: any) => globalThis.Number(e))
        : [],
      verify: isSet(object.verify) ? globalThis.Boolean(object.verify) : false,
      predeploy: isSet(object.predeploy) ? Predeploy.fromJSON(object.predeploy) : undefined,
      postdeploy: isSet(object.postdeploy) ? Postdeploy.fromJSON(object.postdeploy) : undefined,
    };
  },

  toJSON(message: CanaryDeployment): unknown {
    const obj: any = {};
    if (message.percentages?.length) {
      obj.percentages = message.percentages.map((e) => Math.round(e));
    }
    if (message.verify !== false) {
      obj.verify = message.verify;
    }
    if (message.predeploy !== undefined) {
      obj.predeploy = Predeploy.toJSON(message.predeploy);
    }
    if (message.postdeploy !== undefined) {
      obj.postdeploy = Postdeploy.toJSON(message.postdeploy);
    }
    return obj;
  },

  create(base?: DeepPartial<CanaryDeployment>): CanaryDeployment {
    return CanaryDeployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CanaryDeployment>): CanaryDeployment {
    const message = createBaseCanaryDeployment();
    message.percentages = object.percentages?.map((e) => e) || [];
    message.verify = object.verify ?? false;
    message.predeploy = (object.predeploy !== undefined && object.predeploy !== null)
      ? Predeploy.fromPartial(object.predeploy)
      : undefined;
    message.postdeploy = (object.postdeploy !== undefined && object.postdeploy !== null)
      ? Postdeploy.fromPartial(object.postdeploy)
      : undefined;
    return message;
  },
};

function createBaseCustomCanaryDeployment(): CustomCanaryDeployment {
  return { phaseConfigs: [] };
}

export const CustomCanaryDeployment: MessageFns<CustomCanaryDeployment> = {
  encode(message: CustomCanaryDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.phaseConfigs) {
      CustomCanaryDeployment_PhaseConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomCanaryDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomCanaryDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phaseConfigs.push(CustomCanaryDeployment_PhaseConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomCanaryDeployment {
    return {
      phaseConfigs: globalThis.Array.isArray(object?.phaseConfigs)
        ? object.phaseConfigs.map((e: any) => CustomCanaryDeployment_PhaseConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomCanaryDeployment): unknown {
    const obj: any = {};
    if (message.phaseConfigs?.length) {
      obj.phaseConfigs = message.phaseConfigs.map((e) => CustomCanaryDeployment_PhaseConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomCanaryDeployment>): CustomCanaryDeployment {
    return CustomCanaryDeployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomCanaryDeployment>): CustomCanaryDeployment {
    const message = createBaseCustomCanaryDeployment();
    message.phaseConfigs = object.phaseConfigs?.map((e) => CustomCanaryDeployment_PhaseConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCustomCanaryDeployment_PhaseConfig(): CustomCanaryDeployment_PhaseConfig {
  return { phaseId: "", percentage: 0, profiles: [], verify: false, predeploy: undefined, postdeploy: undefined };
}

export const CustomCanaryDeployment_PhaseConfig: MessageFns<CustomCanaryDeployment_PhaseConfig> = {
  encode(message: CustomCanaryDeployment_PhaseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phaseId !== "") {
      writer.uint32(10).string(message.phaseId);
    }
    if (message.percentage !== 0) {
      writer.uint32(16).int32(message.percentage);
    }
    for (const v of message.profiles) {
      writer.uint32(26).string(v!);
    }
    if (message.verify !== false) {
      writer.uint32(32).bool(message.verify);
    }
    if (message.predeploy !== undefined) {
      Predeploy.encode(message.predeploy, writer.uint32(42).fork()).join();
    }
    if (message.postdeploy !== undefined) {
      Postdeploy.encode(message.postdeploy, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomCanaryDeployment_PhaseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomCanaryDeployment_PhaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.profiles.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.verify = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.predeploy = Predeploy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postdeploy = Postdeploy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomCanaryDeployment_PhaseConfig {
    return {
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => globalThis.String(e)) : [],
      verify: isSet(object.verify) ? globalThis.Boolean(object.verify) : false,
      predeploy: isSet(object.predeploy) ? Predeploy.fromJSON(object.predeploy) : undefined,
      postdeploy: isSet(object.postdeploy) ? Postdeploy.fromJSON(object.postdeploy) : undefined,
    };
  },

  toJSON(message: CustomCanaryDeployment_PhaseConfig): unknown {
    const obj: any = {};
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.percentage !== 0) {
      obj.percentage = Math.round(message.percentage);
    }
    if (message.profiles?.length) {
      obj.profiles = message.profiles;
    }
    if (message.verify !== false) {
      obj.verify = message.verify;
    }
    if (message.predeploy !== undefined) {
      obj.predeploy = Predeploy.toJSON(message.predeploy);
    }
    if (message.postdeploy !== undefined) {
      obj.postdeploy = Postdeploy.toJSON(message.postdeploy);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomCanaryDeployment_PhaseConfig>): CustomCanaryDeployment_PhaseConfig {
    return CustomCanaryDeployment_PhaseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomCanaryDeployment_PhaseConfig>): CustomCanaryDeployment_PhaseConfig {
    const message = createBaseCustomCanaryDeployment_PhaseConfig();
    message.phaseId = object.phaseId ?? "";
    message.percentage = object.percentage ?? 0;
    message.profiles = object.profiles?.map((e) => e) || [];
    message.verify = object.verify ?? false;
    message.predeploy = (object.predeploy !== undefined && object.predeploy !== null)
      ? Predeploy.fromPartial(object.predeploy)
      : undefined;
    message.postdeploy = (object.postdeploy !== undefined && object.postdeploy !== null)
      ? Postdeploy.fromPartial(object.postdeploy)
      : undefined;
    return message;
  },
};

function createBaseKubernetesConfig(): KubernetesConfig {
  return { gatewayServiceMesh: undefined, serviceNetworking: undefined };
}

export const KubernetesConfig: MessageFns<KubernetesConfig> = {
  encode(message: KubernetesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gatewayServiceMesh !== undefined) {
      KubernetesConfig_GatewayServiceMesh.encode(message.gatewayServiceMesh, writer.uint32(10).fork()).join();
    }
    if (message.serviceNetworking !== undefined) {
      KubernetesConfig_ServiceNetworking.encode(message.serviceNetworking, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gatewayServiceMesh = KubernetesConfig_GatewayServiceMesh.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceNetworking = KubernetesConfig_ServiceNetworking.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesConfig {
    return {
      gatewayServiceMesh: isSet(object.gatewayServiceMesh)
        ? KubernetesConfig_GatewayServiceMesh.fromJSON(object.gatewayServiceMesh)
        : undefined,
      serviceNetworking: isSet(object.serviceNetworking)
        ? KubernetesConfig_ServiceNetworking.fromJSON(object.serviceNetworking)
        : undefined,
    };
  },

  toJSON(message: KubernetesConfig): unknown {
    const obj: any = {};
    if (message.gatewayServiceMesh !== undefined) {
      obj.gatewayServiceMesh = KubernetesConfig_GatewayServiceMesh.toJSON(message.gatewayServiceMesh);
    }
    if (message.serviceNetworking !== undefined) {
      obj.serviceNetworking = KubernetesConfig_ServiceNetworking.toJSON(message.serviceNetworking);
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesConfig>): KubernetesConfig {
    return KubernetesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesConfig>): KubernetesConfig {
    const message = createBaseKubernetesConfig();
    message.gatewayServiceMesh = (object.gatewayServiceMesh !== undefined && object.gatewayServiceMesh !== null)
      ? KubernetesConfig_GatewayServiceMesh.fromPartial(object.gatewayServiceMesh)
      : undefined;
    message.serviceNetworking = (object.serviceNetworking !== undefined && object.serviceNetworking !== null)
      ? KubernetesConfig_ServiceNetworking.fromPartial(object.serviceNetworking)
      : undefined;
    return message;
  },
};

function createBaseKubernetesConfig_GatewayServiceMesh(): KubernetesConfig_GatewayServiceMesh {
  return {
    httpRoute: "",
    service: "",
    deployment: "",
    routeUpdateWaitTime: undefined,
    stableCutbackDuration: undefined,
    podSelectorLabel: "",
  };
}

export const KubernetesConfig_GatewayServiceMesh: MessageFns<KubernetesConfig_GatewayServiceMesh> = {
  encode(message: KubernetesConfig_GatewayServiceMesh, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpRoute !== "") {
      writer.uint32(10).string(message.httpRoute);
    }
    if (message.service !== "") {
      writer.uint32(18).string(message.service);
    }
    if (message.deployment !== "") {
      writer.uint32(26).string(message.deployment);
    }
    if (message.routeUpdateWaitTime !== undefined) {
      Duration.encode(message.routeUpdateWaitTime, writer.uint32(34).fork()).join();
    }
    if (message.stableCutbackDuration !== undefined) {
      Duration.encode(message.stableCutbackDuration, writer.uint32(42).fork()).join();
    }
    if (message.podSelectorLabel !== "") {
      writer.uint32(50).string(message.podSelectorLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesConfig_GatewayServiceMesh {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesConfig_GatewayServiceMesh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpRoute = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.service = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deployment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.routeUpdateWaitTime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stableCutbackDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.podSelectorLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesConfig_GatewayServiceMesh {
    return {
      httpRoute: isSet(object.httpRoute) ? globalThis.String(object.httpRoute) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      deployment: isSet(object.deployment) ? globalThis.String(object.deployment) : "",
      routeUpdateWaitTime: isSet(object.routeUpdateWaitTime)
        ? Duration.fromJSON(object.routeUpdateWaitTime)
        : undefined,
      stableCutbackDuration: isSet(object.stableCutbackDuration)
        ? Duration.fromJSON(object.stableCutbackDuration)
        : undefined,
      podSelectorLabel: isSet(object.podSelectorLabel) ? globalThis.String(object.podSelectorLabel) : "",
    };
  },

  toJSON(message: KubernetesConfig_GatewayServiceMesh): unknown {
    const obj: any = {};
    if (message.httpRoute !== "") {
      obj.httpRoute = message.httpRoute;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.deployment !== "") {
      obj.deployment = message.deployment;
    }
    if (message.routeUpdateWaitTime !== undefined) {
      obj.routeUpdateWaitTime = Duration.toJSON(message.routeUpdateWaitTime);
    }
    if (message.stableCutbackDuration !== undefined) {
      obj.stableCutbackDuration = Duration.toJSON(message.stableCutbackDuration);
    }
    if (message.podSelectorLabel !== "") {
      obj.podSelectorLabel = message.podSelectorLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesConfig_GatewayServiceMesh>): KubernetesConfig_GatewayServiceMesh {
    return KubernetesConfig_GatewayServiceMesh.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesConfig_GatewayServiceMesh>): KubernetesConfig_GatewayServiceMesh {
    const message = createBaseKubernetesConfig_GatewayServiceMesh();
    message.httpRoute = object.httpRoute ?? "";
    message.service = object.service ?? "";
    message.deployment = object.deployment ?? "";
    message.routeUpdateWaitTime = (object.routeUpdateWaitTime !== undefined && object.routeUpdateWaitTime !== null)
      ? Duration.fromPartial(object.routeUpdateWaitTime)
      : undefined;
    message.stableCutbackDuration =
      (object.stableCutbackDuration !== undefined && object.stableCutbackDuration !== null)
        ? Duration.fromPartial(object.stableCutbackDuration)
        : undefined;
    message.podSelectorLabel = object.podSelectorLabel ?? "";
    return message;
  },
};

function createBaseKubernetesConfig_ServiceNetworking(): KubernetesConfig_ServiceNetworking {
  return { service: "", deployment: "", disablePodOverprovisioning: false, podSelectorLabel: "" };
}

export const KubernetesConfig_ServiceNetworking: MessageFns<KubernetesConfig_ServiceNetworking> = {
  encode(message: KubernetesConfig_ServiceNetworking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.deployment !== "") {
      writer.uint32(18).string(message.deployment);
    }
    if (message.disablePodOverprovisioning !== false) {
      writer.uint32(24).bool(message.disablePodOverprovisioning);
    }
    if (message.podSelectorLabel !== "") {
      writer.uint32(34).string(message.podSelectorLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesConfig_ServiceNetworking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesConfig_ServiceNetworking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployment = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.disablePodOverprovisioning = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.podSelectorLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesConfig_ServiceNetworking {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      deployment: isSet(object.deployment) ? globalThis.String(object.deployment) : "",
      disablePodOverprovisioning: isSet(object.disablePodOverprovisioning)
        ? globalThis.Boolean(object.disablePodOverprovisioning)
        : false,
      podSelectorLabel: isSet(object.podSelectorLabel) ? globalThis.String(object.podSelectorLabel) : "",
    };
  },

  toJSON(message: KubernetesConfig_ServiceNetworking): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.deployment !== "") {
      obj.deployment = message.deployment;
    }
    if (message.disablePodOverprovisioning !== false) {
      obj.disablePodOverprovisioning = message.disablePodOverprovisioning;
    }
    if (message.podSelectorLabel !== "") {
      obj.podSelectorLabel = message.podSelectorLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesConfig_ServiceNetworking>): KubernetesConfig_ServiceNetworking {
    return KubernetesConfig_ServiceNetworking.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesConfig_ServiceNetworking>): KubernetesConfig_ServiceNetworking {
    const message = createBaseKubernetesConfig_ServiceNetworking();
    message.service = object.service ?? "";
    message.deployment = object.deployment ?? "";
    message.disablePodOverprovisioning = object.disablePodOverprovisioning ?? false;
    message.podSelectorLabel = object.podSelectorLabel ?? "";
    return message;
  },
};

function createBaseCloudRunConfig(): CloudRunConfig {
  return { automaticTrafficControl: false, canaryRevisionTags: [], priorRevisionTags: [], stableRevisionTags: [] };
}

export const CloudRunConfig: MessageFns<CloudRunConfig> = {
  encode(message: CloudRunConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.automaticTrafficControl !== false) {
      writer.uint32(8).bool(message.automaticTrafficControl);
    }
    for (const v of message.canaryRevisionTags) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.priorRevisionTags) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.stableRevisionTags) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.automaticTrafficControl = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.canaryRevisionTags.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.priorRevisionTags.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stableRevisionTags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunConfig {
    return {
      automaticTrafficControl: isSet(object.automaticTrafficControl)
        ? globalThis.Boolean(object.automaticTrafficControl)
        : false,
      canaryRevisionTags: globalThis.Array.isArray(object?.canaryRevisionTags)
        ? object.canaryRevisionTags.map((e: any) => globalThis.String(e))
        : [],
      priorRevisionTags: globalThis.Array.isArray(object?.priorRevisionTags)
        ? object.priorRevisionTags.map((e: any) => globalThis.String(e))
        : [],
      stableRevisionTags: globalThis.Array.isArray(object?.stableRevisionTags)
        ? object.stableRevisionTags.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CloudRunConfig): unknown {
    const obj: any = {};
    if (message.automaticTrafficControl !== false) {
      obj.automaticTrafficControl = message.automaticTrafficControl;
    }
    if (message.canaryRevisionTags?.length) {
      obj.canaryRevisionTags = message.canaryRevisionTags;
    }
    if (message.priorRevisionTags?.length) {
      obj.priorRevisionTags = message.priorRevisionTags;
    }
    if (message.stableRevisionTags?.length) {
      obj.stableRevisionTags = message.stableRevisionTags;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunConfig>): CloudRunConfig {
    return CloudRunConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunConfig>): CloudRunConfig {
    const message = createBaseCloudRunConfig();
    message.automaticTrafficControl = object.automaticTrafficControl ?? false;
    message.canaryRevisionTags = object.canaryRevisionTags?.map((e) => e) || [];
    message.priorRevisionTags = object.priorRevisionTags?.map((e) => e) || [];
    message.stableRevisionTags = object.stableRevisionTags?.map((e) => e) || [];
    return message;
  },
};

function createBaseRuntimeConfig(): RuntimeConfig {
  return { kubernetes: undefined, cloudRun: undefined };
}

export const RuntimeConfig: MessageFns<RuntimeConfig> = {
  encode(message: RuntimeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kubernetes !== undefined) {
      KubernetesConfig.encode(message.kubernetes, writer.uint32(10).fork()).join();
    }
    if (message.cloudRun !== undefined) {
      CloudRunConfig.encode(message.cloudRun, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kubernetes = KubernetesConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudRun = CloudRunConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeConfig {
    return {
      kubernetes: isSet(object.kubernetes) ? KubernetesConfig.fromJSON(object.kubernetes) : undefined,
      cloudRun: isSet(object.cloudRun) ? CloudRunConfig.fromJSON(object.cloudRun) : undefined,
    };
  },

  toJSON(message: RuntimeConfig): unknown {
    const obj: any = {};
    if (message.kubernetes !== undefined) {
      obj.kubernetes = KubernetesConfig.toJSON(message.kubernetes);
    }
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRunConfig.toJSON(message.cloudRun);
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeConfig>): RuntimeConfig {
    return RuntimeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeConfig>): RuntimeConfig {
    const message = createBaseRuntimeConfig();
    message.kubernetes = (object.kubernetes !== undefined && object.kubernetes !== null)
      ? KubernetesConfig.fromPartial(object.kubernetes)
      : undefined;
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRunConfig.fromPartial(object.cloudRun)
      : undefined;
    return message;
  },
};

function createBasePipelineReadyCondition(): PipelineReadyCondition {
  return { status: false, updateTime: undefined };
}

export const PipelineReadyCondition: MessageFns<PipelineReadyCondition> = {
  encode(message: PipelineReadyCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== false) {
      writer.uint32(24).bool(message.status);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineReadyCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineReadyCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineReadyCondition {
    return {
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: PipelineReadyCondition): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PipelineReadyCondition>): PipelineReadyCondition {
    return PipelineReadyCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PipelineReadyCondition>): PipelineReadyCondition {
    const message = createBasePipelineReadyCondition();
    message.status = object.status ?? false;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseTargetsPresentCondition(): TargetsPresentCondition {
  return { status: false, missingTargets: [], updateTime: undefined };
}

export const TargetsPresentCondition: MessageFns<TargetsPresentCondition> = {
  encode(message: TargetsPresentCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    for (const v of message.missingTargets) {
      writer.uint32(18).string(v!);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetsPresentCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetsPresentCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingTargets.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetsPresentCondition {
    return {
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      missingTargets: globalThis.Array.isArray(object?.missingTargets)
        ? object.missingTargets.map((e: any) => globalThis.String(e))
        : [],
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: TargetsPresentCondition): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.missingTargets?.length) {
      obj.missingTargets = message.missingTargets;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TargetsPresentCondition>): TargetsPresentCondition {
    return TargetsPresentCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetsPresentCondition>): TargetsPresentCondition {
    const message = createBaseTargetsPresentCondition();
    message.status = object.status ?? false;
    message.missingTargets = object.missingTargets?.map((e) => e) || [];
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseTargetsTypeCondition(): TargetsTypeCondition {
  return { status: false, errorDetails: "" };
}

export const TargetsTypeCondition: MessageFns<TargetsTypeCondition> = {
  encode(message: TargetsTypeCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    if (message.errorDetails !== "") {
      writer.uint32(18).string(message.errorDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetsTypeCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetsTypeCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorDetails = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetsTypeCondition {
    return {
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      errorDetails: isSet(object.errorDetails) ? globalThis.String(object.errorDetails) : "",
    };
  },

  toJSON(message: TargetsTypeCondition): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.errorDetails !== "") {
      obj.errorDetails = message.errorDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<TargetsTypeCondition>): TargetsTypeCondition {
    return TargetsTypeCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetsTypeCondition>): TargetsTypeCondition {
    const message = createBaseTargetsTypeCondition();
    message.status = object.status ?? false;
    message.errorDetails = object.errorDetails ?? "";
    return message;
  },
};

function createBasePipelineCondition(): PipelineCondition {
  return { pipelineReadyCondition: undefined, targetsPresentCondition: undefined, targetsTypeCondition: undefined };
}

export const PipelineCondition: MessageFns<PipelineCondition> = {
  encode(message: PipelineCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pipelineReadyCondition !== undefined) {
      PipelineReadyCondition.encode(message.pipelineReadyCondition, writer.uint32(10).fork()).join();
    }
    if (message.targetsPresentCondition !== undefined) {
      TargetsPresentCondition.encode(message.targetsPresentCondition, writer.uint32(26).fork()).join();
    }
    if (message.targetsTypeCondition !== undefined) {
      TargetsTypeCondition.encode(message.targetsTypeCondition, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PipelineCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePipelineCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pipelineReadyCondition = PipelineReadyCondition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetsPresentCondition = TargetsPresentCondition.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetsTypeCondition = TargetsTypeCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PipelineCondition {
    return {
      pipelineReadyCondition: isSet(object.pipelineReadyCondition)
        ? PipelineReadyCondition.fromJSON(object.pipelineReadyCondition)
        : undefined,
      targetsPresentCondition: isSet(object.targetsPresentCondition)
        ? TargetsPresentCondition.fromJSON(object.targetsPresentCondition)
        : undefined,
      targetsTypeCondition: isSet(object.targetsTypeCondition)
        ? TargetsTypeCondition.fromJSON(object.targetsTypeCondition)
        : undefined,
    };
  },

  toJSON(message: PipelineCondition): unknown {
    const obj: any = {};
    if (message.pipelineReadyCondition !== undefined) {
      obj.pipelineReadyCondition = PipelineReadyCondition.toJSON(message.pipelineReadyCondition);
    }
    if (message.targetsPresentCondition !== undefined) {
      obj.targetsPresentCondition = TargetsPresentCondition.toJSON(message.targetsPresentCondition);
    }
    if (message.targetsTypeCondition !== undefined) {
      obj.targetsTypeCondition = TargetsTypeCondition.toJSON(message.targetsTypeCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<PipelineCondition>): PipelineCondition {
    return PipelineCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PipelineCondition>): PipelineCondition {
    const message = createBasePipelineCondition();
    message.pipelineReadyCondition =
      (object.pipelineReadyCondition !== undefined && object.pipelineReadyCondition !== null)
        ? PipelineReadyCondition.fromPartial(object.pipelineReadyCondition)
        : undefined;
    message.targetsPresentCondition =
      (object.targetsPresentCondition !== undefined && object.targetsPresentCondition !== null)
        ? TargetsPresentCondition.fromPartial(object.targetsPresentCondition)
        : undefined;
    message.targetsTypeCondition = (object.targetsTypeCondition !== undefined && object.targetsTypeCondition !== null)
      ? TargetsTypeCondition.fromPartial(object.targetsTypeCondition)
      : undefined;
    return message;
  },
};

function createBaseListDeliveryPipelinesRequest(): ListDeliveryPipelinesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDeliveryPipelinesRequest: MessageFns<ListDeliveryPipelinesRequest> = {
  encode(message: ListDeliveryPipelinesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeliveryPipelinesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeliveryPipelinesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeliveryPipelinesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDeliveryPipelinesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeliveryPipelinesRequest>): ListDeliveryPipelinesRequest {
    return ListDeliveryPipelinesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeliveryPipelinesRequest>): ListDeliveryPipelinesRequest {
    const message = createBaseListDeliveryPipelinesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListDeliveryPipelinesResponse(): ListDeliveryPipelinesResponse {
  return { deliveryPipelines: [], nextPageToken: "", unreachable: [] };
}

export const ListDeliveryPipelinesResponse: MessageFns<ListDeliveryPipelinesResponse> = {
  encode(message: ListDeliveryPipelinesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deliveryPipelines) {
      DeliveryPipeline.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeliveryPipelinesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeliveryPipelinesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deliveryPipelines.push(DeliveryPipeline.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeliveryPipelinesResponse {
    return {
      deliveryPipelines: globalThis.Array.isArray(object?.deliveryPipelines)
        ? object.deliveryPipelines.map((e: any) => DeliveryPipeline.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDeliveryPipelinesResponse): unknown {
    const obj: any = {};
    if (message.deliveryPipelines?.length) {
      obj.deliveryPipelines = message.deliveryPipelines.map((e) => DeliveryPipeline.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeliveryPipelinesResponse>): ListDeliveryPipelinesResponse {
    return ListDeliveryPipelinesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeliveryPipelinesResponse>): ListDeliveryPipelinesResponse {
    const message = createBaseListDeliveryPipelinesResponse();
    message.deliveryPipelines = object.deliveryPipelines?.map((e) => DeliveryPipeline.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDeliveryPipelineRequest(): GetDeliveryPipelineRequest {
  return { name: "" };
}

export const GetDeliveryPipelineRequest: MessageFns<GetDeliveryPipelineRequest> = {
  encode(message: GetDeliveryPipelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeliveryPipelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeliveryPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeliveryPipelineRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDeliveryPipelineRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeliveryPipelineRequest>): GetDeliveryPipelineRequest {
    return GetDeliveryPipelineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeliveryPipelineRequest>): GetDeliveryPipelineRequest {
    const message = createBaseGetDeliveryPipelineRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDeliveryPipelineRequest(): CreateDeliveryPipelineRequest {
  return { parent: "", deliveryPipelineId: "", deliveryPipeline: undefined, requestId: "", validateOnly: false };
}

export const CreateDeliveryPipelineRequest: MessageFns<CreateDeliveryPipelineRequest> = {
  encode(message: CreateDeliveryPipelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.deliveryPipelineId !== "") {
      writer.uint32(18).string(message.deliveryPipelineId);
    }
    if (message.deliveryPipeline !== undefined) {
      DeliveryPipeline.encode(message.deliveryPipeline, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDeliveryPipelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeliveryPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deliveryPipelineId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deliveryPipeline = DeliveryPipeline.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDeliveryPipelineRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      deliveryPipelineId: isSet(object.deliveryPipelineId) ? globalThis.String(object.deliveryPipelineId) : "",
      deliveryPipeline: isSet(object.deliveryPipeline) ? DeliveryPipeline.fromJSON(object.deliveryPipeline) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateDeliveryPipelineRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.deliveryPipelineId !== "") {
      obj.deliveryPipelineId = message.deliveryPipelineId;
    }
    if (message.deliveryPipeline !== undefined) {
      obj.deliveryPipeline = DeliveryPipeline.toJSON(message.deliveryPipeline);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDeliveryPipelineRequest>): CreateDeliveryPipelineRequest {
    return CreateDeliveryPipelineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDeliveryPipelineRequest>): CreateDeliveryPipelineRequest {
    const message = createBaseCreateDeliveryPipelineRequest();
    message.parent = object.parent ?? "";
    message.deliveryPipelineId = object.deliveryPipelineId ?? "";
    message.deliveryPipeline = (object.deliveryPipeline !== undefined && object.deliveryPipeline !== null)
      ? DeliveryPipeline.fromPartial(object.deliveryPipeline)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateDeliveryPipelineRequest(): UpdateDeliveryPipelineRequest {
  return {
    updateMask: undefined,
    deliveryPipeline: undefined,
    requestId: "",
    allowMissing: false,
    validateOnly: false,
  };
}

export const UpdateDeliveryPipelineRequest: MessageFns<UpdateDeliveryPipelineRequest> = {
  encode(message: UpdateDeliveryPipelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.deliveryPipeline !== undefined) {
      DeliveryPipeline.encode(message.deliveryPipeline, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeliveryPipelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeliveryPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deliveryPipeline = DeliveryPipeline.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeliveryPipelineRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      deliveryPipeline: isSet(object.deliveryPipeline) ? DeliveryPipeline.fromJSON(object.deliveryPipeline) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateDeliveryPipelineRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.deliveryPipeline !== undefined) {
      obj.deliveryPipeline = DeliveryPipeline.toJSON(message.deliveryPipeline);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDeliveryPipelineRequest>): UpdateDeliveryPipelineRequest {
    return UpdateDeliveryPipelineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDeliveryPipelineRequest>): UpdateDeliveryPipelineRequest {
    const message = createBaseUpdateDeliveryPipelineRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.deliveryPipeline = (object.deliveryPipeline !== undefined && object.deliveryPipeline !== null)
      ? DeliveryPipeline.fromPartial(object.deliveryPipeline)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteDeliveryPipelineRequest(): DeleteDeliveryPipelineRequest {
  return { name: "", requestId: "", allowMissing: false, validateOnly: false, force: false, etag: "" };
}

export const DeleteDeliveryPipelineRequest: MessageFns<DeleteDeliveryPipelineRequest> = {
  encode(message: DeleteDeliveryPipelineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.force !== false) {
      writer.uint32(48).bool(message.force);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDeliveryPipelineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDeliveryPipelineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.force = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDeliveryPipelineRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteDeliveryPipelineRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDeliveryPipelineRequest>): DeleteDeliveryPipelineRequest {
    return DeleteDeliveryPipelineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDeliveryPipelineRequest>): DeleteDeliveryPipelineRequest {
    const message = createBaseDeleteDeliveryPipelineRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.force = object.force ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseRollbackTargetConfig(): RollbackTargetConfig {
  return { rollout: undefined, startingPhaseId: "" };
}

export const RollbackTargetConfig: MessageFns<RollbackTargetConfig> = {
  encode(message: RollbackTargetConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== undefined) {
      Rollout.encode(message.rollout, writer.uint32(10).fork()).join();
    }
    if (message.startingPhaseId !== "") {
      writer.uint32(18).string(message.startingPhaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackTargetConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackTargetConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = Rollout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startingPhaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackTargetConfig {
    return {
      rollout: isSet(object.rollout) ? Rollout.fromJSON(object.rollout) : undefined,
      startingPhaseId: isSet(object.startingPhaseId) ? globalThis.String(object.startingPhaseId) : "",
    };
  },

  toJSON(message: RollbackTargetConfig): unknown {
    const obj: any = {};
    if (message.rollout !== undefined) {
      obj.rollout = Rollout.toJSON(message.rollout);
    }
    if (message.startingPhaseId !== "") {
      obj.startingPhaseId = message.startingPhaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackTargetConfig>): RollbackTargetConfig {
    return RollbackTargetConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackTargetConfig>): RollbackTargetConfig {
    const message = createBaseRollbackTargetConfig();
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? Rollout.fromPartial(object.rollout)
      : undefined;
    message.startingPhaseId = object.startingPhaseId ?? "";
    return message;
  },
};

function createBaseRollbackTargetRequest(): RollbackTargetRequest {
  return {
    name: "",
    targetId: "",
    rolloutId: "",
    releaseId: "",
    rolloutToRollBack: "",
    rollbackConfig: undefined,
    validateOnly: false,
    overrideDeployPolicy: [],
  };
}

export const RollbackTargetRequest: MessageFns<RollbackTargetRequest> = {
  encode(message: RollbackTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    if (message.rolloutId !== "") {
      writer.uint32(26).string(message.rolloutId);
    }
    if (message.releaseId !== "") {
      writer.uint32(34).string(message.releaseId);
    }
    if (message.rolloutToRollBack !== "") {
      writer.uint32(42).string(message.rolloutToRollBack);
    }
    if (message.rollbackConfig !== undefined) {
      RollbackTargetConfig.encode(message.rollbackConfig, writer.uint32(50).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(56).bool(message.validateOnly);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rolloutId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.releaseId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolloutToRollBack = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rollbackConfig = RollbackTargetConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackTargetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      rolloutId: isSet(object.rolloutId) ? globalThis.String(object.rolloutId) : "",
      releaseId: isSet(object.releaseId) ? globalThis.String(object.releaseId) : "",
      rolloutToRollBack: isSet(object.rolloutToRollBack) ? globalThis.String(object.rolloutToRollBack) : "",
      rollbackConfig: isSet(object.rollbackConfig) ? RollbackTargetConfig.fromJSON(object.rollbackConfig) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RollbackTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.rolloutId !== "") {
      obj.rolloutId = message.rolloutId;
    }
    if (message.releaseId !== "") {
      obj.releaseId = message.releaseId;
    }
    if (message.rolloutToRollBack !== "") {
      obj.rolloutToRollBack = message.rolloutToRollBack;
    }
    if (message.rollbackConfig !== undefined) {
      obj.rollbackConfig = RollbackTargetConfig.toJSON(message.rollbackConfig);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackTargetRequest>): RollbackTargetRequest {
    return RollbackTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackTargetRequest>): RollbackTargetRequest {
    const message = createBaseRollbackTargetRequest();
    message.name = object.name ?? "";
    message.targetId = object.targetId ?? "";
    message.rolloutId = object.rolloutId ?? "";
    message.releaseId = object.releaseId ?? "";
    message.rolloutToRollBack = object.rolloutToRollBack ?? "";
    message.rollbackConfig = (object.rollbackConfig !== undefined && object.rollbackConfig !== null)
      ? RollbackTargetConfig.fromPartial(object.rollbackConfig)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseRollbackTargetResponse(): RollbackTargetResponse {
  return { rollbackConfig: undefined };
}

export const RollbackTargetResponse: MessageFns<RollbackTargetResponse> = {
  encode(message: RollbackTargetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollbackConfig !== undefined) {
      RollbackTargetConfig.encode(message.rollbackConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackTargetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackTargetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollbackConfig = RollbackTargetConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackTargetResponse {
    return {
      rollbackConfig: isSet(object.rollbackConfig) ? RollbackTargetConfig.fromJSON(object.rollbackConfig) : undefined,
    };
  },

  toJSON(message: RollbackTargetResponse): unknown {
    const obj: any = {};
    if (message.rollbackConfig !== undefined) {
      obj.rollbackConfig = RollbackTargetConfig.toJSON(message.rollbackConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackTargetResponse>): RollbackTargetResponse {
    return RollbackTargetResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackTargetResponse>): RollbackTargetResponse {
    const message = createBaseRollbackTargetResponse();
    message.rollbackConfig = (object.rollbackConfig !== undefined && object.rollbackConfig !== null)
      ? RollbackTargetConfig.fromPartial(object.rollbackConfig)
      : undefined;
    return message;
  },
};

function createBaseTarget(): Target {
  return {
    name: "",
    targetId: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    requireApproval: false,
    createTime: undefined,
    updateTime: undefined,
    gke: undefined,
    anthosCluster: undefined,
    run: undefined,
    multiTarget: undefined,
    customTarget: undefined,
    etag: "",
    executionConfigs: [],
    deployParameters: {},
  };
}

export const Target: MessageFns<Target> = {
  encode(message: Target, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Target_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      Target_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.requireApproval !== false) {
      writer.uint32(104).bool(message.requireApproval);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.gke !== undefined) {
      GkeCluster.encode(message.gke, writer.uint32(122).fork()).join();
    }
    if (message.anthosCluster !== undefined) {
      AnthosCluster.encode(message.anthosCluster, writer.uint32(138).fork()).join();
    }
    if (message.run !== undefined) {
      CloudRunLocation.encode(message.run, writer.uint32(146).fork()).join();
    }
    if (message.multiTarget !== undefined) {
      MultiTarget.encode(message.multiTarget, writer.uint32(154).fork()).join();
    }
    if (message.customTarget !== undefined) {
      CustomTarget.encode(message.customTarget, writer.uint32(170).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(98).string(message.etag);
    }
    for (const v of message.executionConfigs) {
      ExecutionConfig.encode(v!, writer.uint32(130).fork()).join();
    }
    Object.entries(message.deployParameters).forEach(([key, value]) => {
      Target_DeployParametersEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Target {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Target_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Target_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.requireApproval = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.gke = GkeCluster.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.anthosCluster = AnthosCluster.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.run = CloudRunLocation.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.multiTarget = MultiTarget.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.customTarget = CustomTarget.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.executionConfigs.push(ExecutionConfig.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = Target_DeployParametersEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.deployParameters[entry20.key] = entry20.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Target {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      requireApproval: isSet(object.requireApproval) ? globalThis.Boolean(object.requireApproval) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      gke: isSet(object.gke) ? GkeCluster.fromJSON(object.gke) : undefined,
      anthosCluster: isSet(object.anthosCluster) ? AnthosCluster.fromJSON(object.anthosCluster) : undefined,
      run: isSet(object.run) ? CloudRunLocation.fromJSON(object.run) : undefined,
      multiTarget: isSet(object.multiTarget) ? MultiTarget.fromJSON(object.multiTarget) : undefined,
      customTarget: isSet(object.customTarget) ? CustomTarget.fromJSON(object.customTarget) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      executionConfigs: globalThis.Array.isArray(object?.executionConfigs)
        ? object.executionConfigs.map((e: any) => ExecutionConfig.fromJSON(e))
        : [],
      deployParameters: isObject(object.deployParameters)
        ? Object.entries(object.deployParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Target): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.requireApproval !== false) {
      obj.requireApproval = message.requireApproval;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.gke !== undefined) {
      obj.gke = GkeCluster.toJSON(message.gke);
    }
    if (message.anthosCluster !== undefined) {
      obj.anthosCluster = AnthosCluster.toJSON(message.anthosCluster);
    }
    if (message.run !== undefined) {
      obj.run = CloudRunLocation.toJSON(message.run);
    }
    if (message.multiTarget !== undefined) {
      obj.multiTarget = MultiTarget.toJSON(message.multiTarget);
    }
    if (message.customTarget !== undefined) {
      obj.customTarget = CustomTarget.toJSON(message.customTarget);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.executionConfigs?.length) {
      obj.executionConfigs = message.executionConfigs.map((e) => ExecutionConfig.toJSON(e));
    }
    if (message.deployParameters) {
      const entries = Object.entries(message.deployParameters);
      if (entries.length > 0) {
        obj.deployParameters = {};
        entries.forEach(([k, v]) => {
          obj.deployParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Target>): Target {
    return Target.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Target>): Target {
    const message = createBaseTarget();
    message.name = object.name ?? "";
    message.targetId = object.targetId ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.requireApproval = object.requireApproval ?? false;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.gke = (object.gke !== undefined && object.gke !== null) ? GkeCluster.fromPartial(object.gke) : undefined;
    message.anthosCluster = (object.anthosCluster !== undefined && object.anthosCluster !== null)
      ? AnthosCluster.fromPartial(object.anthosCluster)
      : undefined;
    message.run = (object.run !== undefined && object.run !== null)
      ? CloudRunLocation.fromPartial(object.run)
      : undefined;
    message.multiTarget = (object.multiTarget !== undefined && object.multiTarget !== null)
      ? MultiTarget.fromPartial(object.multiTarget)
      : undefined;
    message.customTarget = (object.customTarget !== undefined && object.customTarget !== null)
      ? CustomTarget.fromPartial(object.customTarget)
      : undefined;
    message.etag = object.etag ?? "";
    message.executionConfigs = object.executionConfigs?.map((e) => ExecutionConfig.fromPartial(e)) || [];
    message.deployParameters = Object.entries(object.deployParameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTarget_AnnotationsEntry(): Target_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Target_AnnotationsEntry: MessageFns<Target_AnnotationsEntry> = {
  encode(message: Target_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Target_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTarget_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Target_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Target_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Target_AnnotationsEntry>): Target_AnnotationsEntry {
    return Target_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Target_AnnotationsEntry>): Target_AnnotationsEntry {
    const message = createBaseTarget_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTarget_LabelsEntry(): Target_LabelsEntry {
  return { key: "", value: "" };
}

export const Target_LabelsEntry: MessageFns<Target_LabelsEntry> = {
  encode(message: Target_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Target_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTarget_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Target_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Target_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Target_LabelsEntry>): Target_LabelsEntry {
    return Target_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Target_LabelsEntry>): Target_LabelsEntry {
    const message = createBaseTarget_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTarget_DeployParametersEntry(): Target_DeployParametersEntry {
  return { key: "", value: "" };
}

export const Target_DeployParametersEntry: MessageFns<Target_DeployParametersEntry> = {
  encode(message: Target_DeployParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Target_DeployParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTarget_DeployParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Target_DeployParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Target_DeployParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Target_DeployParametersEntry>): Target_DeployParametersEntry {
    return Target_DeployParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Target_DeployParametersEntry>): Target_DeployParametersEntry {
    const message = createBaseTarget_DeployParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecutionConfig(): ExecutionConfig {
  return {
    usages: [],
    defaultPool: undefined,
    privatePool: undefined,
    workerPool: "",
    serviceAccount: "",
    artifactStorage: "",
    executionTimeout: undefined,
    verbose: false,
  };
}

export const ExecutionConfig: MessageFns<ExecutionConfig> = {
  encode(message: ExecutionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.usages) {
      writer.int32(v);
    }
    writer.join();
    if (message.defaultPool !== undefined) {
      DefaultPool.encode(message.defaultPool, writer.uint32(18).fork()).join();
    }
    if (message.privatePool !== undefined) {
      PrivatePool.encode(message.privatePool, writer.uint32(26).fork()).join();
    }
    if (message.workerPool !== "") {
      writer.uint32(34).string(message.workerPool);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(42).string(message.serviceAccount);
    }
    if (message.artifactStorage !== "") {
      writer.uint32(50).string(message.artifactStorage);
    }
    if (message.executionTimeout !== undefined) {
      Duration.encode(message.executionTimeout, writer.uint32(58).fork()).join();
    }
    if (message.verbose !== false) {
      writer.uint32(64).bool(message.verbose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.usages.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.usages.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultPool = DefaultPool.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privatePool = PrivatePool.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerPool = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.artifactStorage = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.executionTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.verbose = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionConfig {
    return {
      usages: globalThis.Array.isArray(object?.usages)
        ? object.usages.map((e: any) => executionConfig_ExecutionEnvironmentUsageFromJSON(e))
        : [],
      defaultPool: isSet(object.defaultPool) ? DefaultPool.fromJSON(object.defaultPool) : undefined,
      privatePool: isSet(object.privatePool) ? PrivatePool.fromJSON(object.privatePool) : undefined,
      workerPool: isSet(object.workerPool) ? globalThis.String(object.workerPool) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      artifactStorage: isSet(object.artifactStorage) ? globalThis.String(object.artifactStorage) : "",
      executionTimeout: isSet(object.executionTimeout) ? Duration.fromJSON(object.executionTimeout) : undefined,
      verbose: isSet(object.verbose) ? globalThis.Boolean(object.verbose) : false,
    };
  },

  toJSON(message: ExecutionConfig): unknown {
    const obj: any = {};
    if (message.usages?.length) {
      obj.usages = message.usages.map((e) => executionConfig_ExecutionEnvironmentUsageToJSON(e));
    }
    if (message.defaultPool !== undefined) {
      obj.defaultPool = DefaultPool.toJSON(message.defaultPool);
    }
    if (message.privatePool !== undefined) {
      obj.privatePool = PrivatePool.toJSON(message.privatePool);
    }
    if (message.workerPool !== "") {
      obj.workerPool = message.workerPool;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.artifactStorage !== "") {
      obj.artifactStorage = message.artifactStorage;
    }
    if (message.executionTimeout !== undefined) {
      obj.executionTimeout = Duration.toJSON(message.executionTimeout);
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionConfig>): ExecutionConfig {
    return ExecutionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionConfig>): ExecutionConfig {
    const message = createBaseExecutionConfig();
    message.usages = object.usages?.map((e) => e) || [];
    message.defaultPool = (object.defaultPool !== undefined && object.defaultPool !== null)
      ? DefaultPool.fromPartial(object.defaultPool)
      : undefined;
    message.privatePool = (object.privatePool !== undefined && object.privatePool !== null)
      ? PrivatePool.fromPartial(object.privatePool)
      : undefined;
    message.workerPool = object.workerPool ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.artifactStorage = object.artifactStorage ?? "";
    message.executionTimeout = (object.executionTimeout !== undefined && object.executionTimeout !== null)
      ? Duration.fromPartial(object.executionTimeout)
      : undefined;
    message.verbose = object.verbose ?? false;
    return message;
  },
};

function createBaseDefaultPool(): DefaultPool {
  return { serviceAccount: "", artifactStorage: "" };
}

export const DefaultPool: MessageFns<DefaultPool> = {
  encode(message: DefaultPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccount !== "") {
      writer.uint32(10).string(message.serviceAccount);
    }
    if (message.artifactStorage !== "") {
      writer.uint32(18).string(message.artifactStorage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifactStorage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultPool {
    return {
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      artifactStorage: isSet(object.artifactStorage) ? globalThis.String(object.artifactStorage) : "",
    };
  },

  toJSON(message: DefaultPool): unknown {
    const obj: any = {};
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.artifactStorage !== "") {
      obj.artifactStorage = message.artifactStorage;
    }
    return obj;
  },

  create(base?: DeepPartial<DefaultPool>): DefaultPool {
    return DefaultPool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DefaultPool>): DefaultPool {
    const message = createBaseDefaultPool();
    message.serviceAccount = object.serviceAccount ?? "";
    message.artifactStorage = object.artifactStorage ?? "";
    return message;
  },
};

function createBasePrivatePool(): PrivatePool {
  return { workerPool: "", serviceAccount: "", artifactStorage: "" };
}

export const PrivatePool: MessageFns<PrivatePool> = {
  encode(message: PrivatePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerPool !== "") {
      writer.uint32(10).string(message.workerPool);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    if (message.artifactStorage !== "") {
      writer.uint32(26).string(message.artifactStorage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivatePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivatePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerPool = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.artifactStorage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivatePool {
    return {
      workerPool: isSet(object.workerPool) ? globalThis.String(object.workerPool) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      artifactStorage: isSet(object.artifactStorage) ? globalThis.String(object.artifactStorage) : "",
    };
  },

  toJSON(message: PrivatePool): unknown {
    const obj: any = {};
    if (message.workerPool !== "") {
      obj.workerPool = message.workerPool;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.artifactStorage !== "") {
      obj.artifactStorage = message.artifactStorage;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivatePool>): PrivatePool {
    return PrivatePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivatePool>): PrivatePool {
    const message = createBasePrivatePool();
    message.workerPool = object.workerPool ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.artifactStorage = object.artifactStorage ?? "";
    return message;
  },
};

function createBaseGkeCluster(): GkeCluster {
  return { cluster: "", internalIp: false, proxyUrl: "" };
}

export const GkeCluster: MessageFns<GkeCluster> = {
  encode(message: GkeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.internalIp !== false) {
      writer.uint32(16).bool(message.internalIp);
    }
    if (message.proxyUrl !== "") {
      writer.uint32(26).string(message.proxyUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GkeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGkeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.internalIp = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proxyUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GkeCluster {
    return {
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      internalIp: isSet(object.internalIp) ? globalThis.Boolean(object.internalIp) : false,
      proxyUrl: isSet(object.proxyUrl) ? globalThis.String(object.proxyUrl) : "",
    };
  },

  toJSON(message: GkeCluster): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.internalIp !== false) {
      obj.internalIp = message.internalIp;
    }
    if (message.proxyUrl !== "") {
      obj.proxyUrl = message.proxyUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<GkeCluster>): GkeCluster {
    return GkeCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GkeCluster>): GkeCluster {
    const message = createBaseGkeCluster();
    message.cluster = object.cluster ?? "";
    message.internalIp = object.internalIp ?? false;
    message.proxyUrl = object.proxyUrl ?? "";
    return message;
  },
};

function createBaseAnthosCluster(): AnthosCluster {
  return { membership: "" };
}

export const AnthosCluster: MessageFns<AnthosCluster> = {
  encode(message: AnthosCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membership !== "") {
      writer.uint32(10).string(message.membership);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnthosCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnthosCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membership = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnthosCluster {
    return { membership: isSet(object.membership) ? globalThis.String(object.membership) : "" };
  },

  toJSON(message: AnthosCluster): unknown {
    const obj: any = {};
    if (message.membership !== "") {
      obj.membership = message.membership;
    }
    return obj;
  },

  create(base?: DeepPartial<AnthosCluster>): AnthosCluster {
    return AnthosCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnthosCluster>): AnthosCluster {
    const message = createBaseAnthosCluster();
    message.membership = object.membership ?? "";
    return message;
  },
};

function createBaseCloudRunLocation(): CloudRunLocation {
  return { location: "" };
}

export const CloudRunLocation: MessageFns<CloudRunLocation> = {
  encode(message: CloudRunLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunLocation {
    return { location: isSet(object.location) ? globalThis.String(object.location) : "" };
  },

  toJSON(message: CloudRunLocation): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunLocation>): CloudRunLocation {
    return CloudRunLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunLocation>): CloudRunLocation {
    const message = createBaseCloudRunLocation();
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseMultiTarget(): MultiTarget {
  return { targetIds: [] };
}

export const MultiTarget: MessageFns<MultiTarget> = {
  encode(message: MultiTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.targetIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiTarget {
    return {
      targetIds: globalThis.Array.isArray(object?.targetIds)
        ? object.targetIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MultiTarget): unknown {
    const obj: any = {};
    if (message.targetIds?.length) {
      obj.targetIds = message.targetIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MultiTarget>): MultiTarget {
    return MultiTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MultiTarget>): MultiTarget {
    const message = createBaseMultiTarget();
    message.targetIds = object.targetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomTarget(): CustomTarget {
  return { customTargetType: "" };
}

export const CustomTarget: MessageFns<CustomTarget> = {
  encode(message: CustomTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customTargetType !== "") {
      writer.uint32(10).string(message.customTargetType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customTargetType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTarget {
    return { customTargetType: isSet(object.customTargetType) ? globalThis.String(object.customTargetType) : "" };
  },

  toJSON(message: CustomTarget): unknown {
    const obj: any = {};
    if (message.customTargetType !== "") {
      obj.customTargetType = message.customTargetType;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTarget>): CustomTarget {
    return CustomTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTarget>): CustomTarget {
    const message = createBaseCustomTarget();
    message.customTargetType = object.customTargetType ?? "";
    return message;
  },
};

function createBaseListTargetsRequest(): ListTargetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListTargetsRequest: MessageFns<ListTargetsRequest> = {
  encode(message: ListTargetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListTargetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetsRequest>): ListTargetsRequest {
    return ListTargetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetsRequest>): ListTargetsRequest {
    const message = createBaseListTargetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListTargetsResponse(): ListTargetsResponse {
  return { targets: [], nextPageToken: "", unreachable: [] };
}

export const ListTargetsResponse: MessageFns<ListTargetsResponse> = {
  encode(message: ListTargetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.targets) {
      Target.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTargetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTargetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targets.push(Target.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTargetsResponse {
    return {
      targets: globalThis.Array.isArray(object?.targets) ? object.targets.map((e: any) => Target.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListTargetsResponse): unknown {
    const obj: any = {};
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => Target.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTargetsResponse>): ListTargetsResponse {
    return ListTargetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTargetsResponse>): ListTargetsResponse {
    const message = createBaseListTargetsResponse();
    message.targets = object.targets?.map((e) => Target.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTargetRequest(): GetTargetRequest {
  return { name: "" };
}

export const GetTargetRequest: MessageFns<GetTargetRequest> = {
  encode(message: GetTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTargetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTargetRequest>): GetTargetRequest {
    return GetTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTargetRequest>): GetTargetRequest {
    const message = createBaseGetTargetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateTargetRequest(): CreateTargetRequest {
  return { parent: "", targetId: "", target: undefined, requestId: "", validateOnly: false };
}

export const CreateTargetRequest: MessageFns<CreateTargetRequest> = {
  encode(message: CreateTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.targetId !== "") {
      writer.uint32(18).string(message.targetId);
    }
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTargetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateTargetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTargetRequest>): CreateTargetRequest {
    return CreateTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTargetRequest>): CreateTargetRequest {
    const message = createBaseCreateTargetRequest();
    message.parent = object.parent ?? "";
    message.targetId = object.targetId ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateTargetRequest(): UpdateTargetRequest {
  return { updateMask: undefined, target: undefined, requestId: "", allowMissing: false, validateOnly: false };
}

export const UpdateTargetRequest: MessageFns<UpdateTargetRequest> = {
  encode(message: UpdateTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.target !== undefined) {
      Target.encode(message.target, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = Target.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTargetRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      target: isSet(object.target) ? Target.fromJSON(object.target) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateTargetRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.target !== undefined) {
      obj.target = Target.toJSON(message.target);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTargetRequest>): UpdateTargetRequest {
    return UpdateTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTargetRequest>): UpdateTargetRequest {
    const message = createBaseUpdateTargetRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? Target.fromPartial(object.target)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteTargetRequest(): DeleteTargetRequest {
  return { name: "", requestId: "", allowMissing: false, validateOnly: false, etag: "" };
}

export const DeleteTargetRequest: MessageFns<DeleteTargetRequest> = {
  encode(message: DeleteTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTargetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteTargetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTargetRequest>): DeleteTargetRequest {
    return DeleteTargetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTargetRequest>): DeleteTargetRequest {
    const message = createBaseDeleteTargetRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseCustomTargetType(): CustomTargetType {
  return {
    name: "",
    customTargetTypeId: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    etag: "",
    customActions: undefined,
  };
}

export const CustomTargetType: MessageFns<CustomTargetType> = {
  encode(message: CustomTargetType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.customTargetTypeId !== "") {
      writer.uint32(18).string(message.customTargetTypeId);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      CustomTargetType_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      CustomTargetType_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    if (message.customActions !== undefined) {
      CustomTargetSkaffoldActions.encode(message.customActions, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTargetType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTargetType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customTargetTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = CustomTargetType_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = CustomTargetType_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.customActions = CustomTargetSkaffoldActions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTargetType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      customTargetTypeId: isSet(object.customTargetTypeId) ? globalThis.String(object.customTargetTypeId) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      customActions: isSet(object.customActions)
        ? CustomTargetSkaffoldActions.fromJSON(object.customActions)
        : undefined,
    };
  },

  toJSON(message: CustomTargetType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.customTargetTypeId !== "") {
      obj.customTargetTypeId = message.customTargetTypeId;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.customActions !== undefined) {
      obj.customActions = CustomTargetSkaffoldActions.toJSON(message.customActions);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTargetType>): CustomTargetType {
    return CustomTargetType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTargetType>): CustomTargetType {
    const message = createBaseCustomTargetType();
    message.name = object.name ?? "";
    message.customTargetTypeId = object.customTargetTypeId ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    message.customActions = (object.customActions !== undefined && object.customActions !== null)
      ? CustomTargetSkaffoldActions.fromPartial(object.customActions)
      : undefined;
    return message;
  },
};

function createBaseCustomTargetType_AnnotationsEntry(): CustomTargetType_AnnotationsEntry {
  return { key: "", value: "" };
}

export const CustomTargetType_AnnotationsEntry: MessageFns<CustomTargetType_AnnotationsEntry> = {
  encode(message: CustomTargetType_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTargetType_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTargetType_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTargetType_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CustomTargetType_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTargetType_AnnotationsEntry>): CustomTargetType_AnnotationsEntry {
    return CustomTargetType_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTargetType_AnnotationsEntry>): CustomTargetType_AnnotationsEntry {
    const message = createBaseCustomTargetType_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomTargetType_LabelsEntry(): CustomTargetType_LabelsEntry {
  return { key: "", value: "" };
}

export const CustomTargetType_LabelsEntry: MessageFns<CustomTargetType_LabelsEntry> = {
  encode(message: CustomTargetType_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTargetType_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTargetType_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTargetType_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CustomTargetType_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTargetType_LabelsEntry>): CustomTargetType_LabelsEntry {
    return CustomTargetType_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTargetType_LabelsEntry>): CustomTargetType_LabelsEntry {
    const message = createBaseCustomTargetType_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCustomTargetSkaffoldActions(): CustomTargetSkaffoldActions {
  return { renderAction: "", deployAction: "", includeSkaffoldModules: [] };
}

export const CustomTargetSkaffoldActions: MessageFns<CustomTargetSkaffoldActions> = {
  encode(message: CustomTargetSkaffoldActions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.renderAction !== "") {
      writer.uint32(10).string(message.renderAction);
    }
    if (message.deployAction !== "") {
      writer.uint32(18).string(message.deployAction);
    }
    for (const v of message.includeSkaffoldModules) {
      SkaffoldModules.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTargetSkaffoldActions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTargetSkaffoldActions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.renderAction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployAction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.includeSkaffoldModules.push(SkaffoldModules.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTargetSkaffoldActions {
    return {
      renderAction: isSet(object.renderAction) ? globalThis.String(object.renderAction) : "",
      deployAction: isSet(object.deployAction) ? globalThis.String(object.deployAction) : "",
      includeSkaffoldModules: globalThis.Array.isArray(object?.includeSkaffoldModules)
        ? object.includeSkaffoldModules.map((e: any) => SkaffoldModules.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomTargetSkaffoldActions): unknown {
    const obj: any = {};
    if (message.renderAction !== "") {
      obj.renderAction = message.renderAction;
    }
    if (message.deployAction !== "") {
      obj.deployAction = message.deployAction;
    }
    if (message.includeSkaffoldModules?.length) {
      obj.includeSkaffoldModules = message.includeSkaffoldModules.map((e) => SkaffoldModules.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTargetSkaffoldActions>): CustomTargetSkaffoldActions {
    return CustomTargetSkaffoldActions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTargetSkaffoldActions>): CustomTargetSkaffoldActions {
    const message = createBaseCustomTargetSkaffoldActions();
    message.renderAction = object.renderAction ?? "";
    message.deployAction = object.deployAction ?? "";
    message.includeSkaffoldModules = object.includeSkaffoldModules?.map((e) => SkaffoldModules.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkaffoldModules(): SkaffoldModules {
  return { configs: [], git: undefined, googleCloudStorage: undefined, googleCloudBuildRepo: undefined };
}

export const SkaffoldModules: MessageFns<SkaffoldModules> = {
  encode(message: SkaffoldModules, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.configs) {
      writer.uint32(10).string(v!);
    }
    if (message.git !== undefined) {
      SkaffoldModules_SkaffoldGitSource.encode(message.git, writer.uint32(18).fork()).join();
    }
    if (message.googleCloudStorage !== undefined) {
      SkaffoldModules_SkaffoldGCSSource.encode(message.googleCloudStorage, writer.uint32(26).fork()).join();
    }
    if (message.googleCloudBuildRepo !== undefined) {
      SkaffoldModules_SkaffoldGCBRepoSource.encode(message.googleCloudBuildRepo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkaffoldModules {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkaffoldModules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configs.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.git = SkaffoldModules_SkaffoldGitSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.googleCloudStorage = SkaffoldModules_SkaffoldGCSSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.googleCloudBuildRepo = SkaffoldModules_SkaffoldGCBRepoSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkaffoldModules {
    return {
      configs: globalThis.Array.isArray(object?.configs) ? object.configs.map((e: any) => globalThis.String(e)) : [],
      git: isSet(object.git) ? SkaffoldModules_SkaffoldGitSource.fromJSON(object.git) : undefined,
      googleCloudStorage: isSet(object.googleCloudStorage)
        ? SkaffoldModules_SkaffoldGCSSource.fromJSON(object.googleCloudStorage)
        : undefined,
      googleCloudBuildRepo: isSet(object.googleCloudBuildRepo)
        ? SkaffoldModules_SkaffoldGCBRepoSource.fromJSON(object.googleCloudBuildRepo)
        : undefined,
    };
  },

  toJSON(message: SkaffoldModules): unknown {
    const obj: any = {};
    if (message.configs?.length) {
      obj.configs = message.configs;
    }
    if (message.git !== undefined) {
      obj.git = SkaffoldModules_SkaffoldGitSource.toJSON(message.git);
    }
    if (message.googleCloudStorage !== undefined) {
      obj.googleCloudStorage = SkaffoldModules_SkaffoldGCSSource.toJSON(message.googleCloudStorage);
    }
    if (message.googleCloudBuildRepo !== undefined) {
      obj.googleCloudBuildRepo = SkaffoldModules_SkaffoldGCBRepoSource.toJSON(message.googleCloudBuildRepo);
    }
    return obj;
  },

  create(base?: DeepPartial<SkaffoldModules>): SkaffoldModules {
    return SkaffoldModules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkaffoldModules>): SkaffoldModules {
    const message = createBaseSkaffoldModules();
    message.configs = object.configs?.map((e) => e) || [];
    message.git = (object.git !== undefined && object.git !== null)
      ? SkaffoldModules_SkaffoldGitSource.fromPartial(object.git)
      : undefined;
    message.googleCloudStorage = (object.googleCloudStorage !== undefined && object.googleCloudStorage !== null)
      ? SkaffoldModules_SkaffoldGCSSource.fromPartial(object.googleCloudStorage)
      : undefined;
    message.googleCloudBuildRepo = (object.googleCloudBuildRepo !== undefined && object.googleCloudBuildRepo !== null)
      ? SkaffoldModules_SkaffoldGCBRepoSource.fromPartial(object.googleCloudBuildRepo)
      : undefined;
    return message;
  },
};

function createBaseSkaffoldModules_SkaffoldGitSource(): SkaffoldModules_SkaffoldGitSource {
  return { repo: "", path: "", ref: "" };
}

export const SkaffoldModules_SkaffoldGitSource: MessageFns<SkaffoldModules_SkaffoldGitSource> = {
  encode(message: SkaffoldModules_SkaffoldGitSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repo !== "") {
      writer.uint32(10).string(message.repo);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkaffoldModules_SkaffoldGitSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkaffoldModules_SkaffoldGitSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repo = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkaffoldModules_SkaffoldGitSource {
    return {
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: SkaffoldModules_SkaffoldGitSource): unknown {
    const obj: any = {};
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<SkaffoldModules_SkaffoldGitSource>): SkaffoldModules_SkaffoldGitSource {
    return SkaffoldModules_SkaffoldGitSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkaffoldModules_SkaffoldGitSource>): SkaffoldModules_SkaffoldGitSource {
    const message = createBaseSkaffoldModules_SkaffoldGitSource();
    message.repo = object.repo ?? "";
    message.path = object.path ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

function createBaseSkaffoldModules_SkaffoldGCSSource(): SkaffoldModules_SkaffoldGCSSource {
  return { source: "", path: "" };
}

export const SkaffoldModules_SkaffoldGCSSource: MessageFns<SkaffoldModules_SkaffoldGCSSource> = {
  encode(message: SkaffoldModules_SkaffoldGCSSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkaffoldModules_SkaffoldGCSSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkaffoldModules_SkaffoldGCSSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkaffoldModules_SkaffoldGCSSource {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: SkaffoldModules_SkaffoldGCSSource): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SkaffoldModules_SkaffoldGCSSource>): SkaffoldModules_SkaffoldGCSSource {
    return SkaffoldModules_SkaffoldGCSSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkaffoldModules_SkaffoldGCSSource>): SkaffoldModules_SkaffoldGCSSource {
    const message = createBaseSkaffoldModules_SkaffoldGCSSource();
    message.source = object.source ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSkaffoldModules_SkaffoldGCBRepoSource(): SkaffoldModules_SkaffoldGCBRepoSource {
  return { repository: "", path: "", ref: "" };
}

export const SkaffoldModules_SkaffoldGCBRepoSource: MessageFns<SkaffoldModules_SkaffoldGCBRepoSource> = {
  encode(message: SkaffoldModules_SkaffoldGCBRepoSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.ref !== "") {
      writer.uint32(26).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkaffoldModules_SkaffoldGCBRepoSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkaffoldModules_SkaffoldGCBRepoSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ref = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkaffoldModules_SkaffoldGCBRepoSource {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
    };
  },

  toJSON(message: SkaffoldModules_SkaffoldGCBRepoSource): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    return obj;
  },

  create(base?: DeepPartial<SkaffoldModules_SkaffoldGCBRepoSource>): SkaffoldModules_SkaffoldGCBRepoSource {
    return SkaffoldModules_SkaffoldGCBRepoSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkaffoldModules_SkaffoldGCBRepoSource>): SkaffoldModules_SkaffoldGCBRepoSource {
    const message = createBaseSkaffoldModules_SkaffoldGCBRepoSource();
    message.repository = object.repository ?? "";
    message.path = object.path ?? "";
    message.ref = object.ref ?? "";
    return message;
  },
};

function createBaseListCustomTargetTypesRequest(): ListCustomTargetTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCustomTargetTypesRequest: MessageFns<ListCustomTargetTypesRequest> = {
  encode(message: ListCustomTargetTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomTargetTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomTargetTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomTargetTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCustomTargetTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomTargetTypesRequest>): ListCustomTargetTypesRequest {
    return ListCustomTargetTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomTargetTypesRequest>): ListCustomTargetTypesRequest {
    const message = createBaseListCustomTargetTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCustomTargetTypesResponse(): ListCustomTargetTypesResponse {
  return { customTargetTypes: [], nextPageToken: "", unreachable: [] };
}

export const ListCustomTargetTypesResponse: MessageFns<ListCustomTargetTypesResponse> = {
  encode(message: ListCustomTargetTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.customTargetTypes) {
      CustomTargetType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCustomTargetTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCustomTargetTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customTargetTypes.push(CustomTargetType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCustomTargetTypesResponse {
    return {
      customTargetTypes: globalThis.Array.isArray(object?.customTargetTypes)
        ? object.customTargetTypes.map((e: any) => CustomTargetType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCustomTargetTypesResponse): unknown {
    const obj: any = {};
    if (message.customTargetTypes?.length) {
      obj.customTargetTypes = message.customTargetTypes.map((e) => CustomTargetType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCustomTargetTypesResponse>): ListCustomTargetTypesResponse {
    return ListCustomTargetTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCustomTargetTypesResponse>): ListCustomTargetTypesResponse {
    const message = createBaseListCustomTargetTypesResponse();
    message.customTargetTypes = object.customTargetTypes?.map((e) => CustomTargetType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCustomTargetTypeRequest(): GetCustomTargetTypeRequest {
  return { name: "" };
}

export const GetCustomTargetTypeRequest: MessageFns<GetCustomTargetTypeRequest> = {
  encode(message: GetCustomTargetTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCustomTargetTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCustomTargetTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCustomTargetTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCustomTargetTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCustomTargetTypeRequest>): GetCustomTargetTypeRequest {
    return GetCustomTargetTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCustomTargetTypeRequest>): GetCustomTargetTypeRequest {
    const message = createBaseGetCustomTargetTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateCustomTargetTypeRequest(): CreateCustomTargetTypeRequest {
  return { parent: "", customTargetTypeId: "", customTargetType: undefined, requestId: "", validateOnly: false };
}

export const CreateCustomTargetTypeRequest: MessageFns<CreateCustomTargetTypeRequest> = {
  encode(message: CreateCustomTargetTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.customTargetTypeId !== "") {
      writer.uint32(18).string(message.customTargetTypeId);
    }
    if (message.customTargetType !== undefined) {
      CustomTargetType.encode(message.customTargetType, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCustomTargetTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCustomTargetTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customTargetTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customTargetType = CustomTargetType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCustomTargetTypeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      customTargetTypeId: isSet(object.customTargetTypeId) ? globalThis.String(object.customTargetTypeId) : "",
      customTargetType: isSet(object.customTargetType) ? CustomTargetType.fromJSON(object.customTargetType) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateCustomTargetTypeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.customTargetTypeId !== "") {
      obj.customTargetTypeId = message.customTargetTypeId;
    }
    if (message.customTargetType !== undefined) {
      obj.customTargetType = CustomTargetType.toJSON(message.customTargetType);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCustomTargetTypeRequest>): CreateCustomTargetTypeRequest {
    return CreateCustomTargetTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCustomTargetTypeRequest>): CreateCustomTargetTypeRequest {
    const message = createBaseCreateCustomTargetTypeRequest();
    message.parent = object.parent ?? "";
    message.customTargetTypeId = object.customTargetTypeId ?? "";
    message.customTargetType = (object.customTargetType !== undefined && object.customTargetType !== null)
      ? CustomTargetType.fromPartial(object.customTargetType)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateCustomTargetTypeRequest(): UpdateCustomTargetTypeRequest {
  return {
    updateMask: undefined,
    customTargetType: undefined,
    requestId: "",
    allowMissing: false,
    validateOnly: false,
  };
}

export const UpdateCustomTargetTypeRequest: MessageFns<UpdateCustomTargetTypeRequest> = {
  encode(message: UpdateCustomTargetTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.customTargetType !== undefined) {
      CustomTargetType.encode(message.customTargetType, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCustomTargetTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCustomTargetTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customTargetType = CustomTargetType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCustomTargetTypeRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      customTargetType: isSet(object.customTargetType) ? CustomTargetType.fromJSON(object.customTargetType) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateCustomTargetTypeRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.customTargetType !== undefined) {
      obj.customTargetType = CustomTargetType.toJSON(message.customTargetType);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCustomTargetTypeRequest>): UpdateCustomTargetTypeRequest {
    return UpdateCustomTargetTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCustomTargetTypeRequest>): UpdateCustomTargetTypeRequest {
    const message = createBaseUpdateCustomTargetTypeRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.customTargetType = (object.customTargetType !== undefined && object.customTargetType !== null)
      ? CustomTargetType.fromPartial(object.customTargetType)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteCustomTargetTypeRequest(): DeleteCustomTargetTypeRequest {
  return { name: "", requestId: "", allowMissing: false, validateOnly: false, etag: "" };
}

export const DeleteCustomTargetTypeRequest: MessageFns<DeleteCustomTargetTypeRequest> = {
  encode(message: DeleteCustomTargetTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCustomTargetTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCustomTargetTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCustomTargetTypeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteCustomTargetTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCustomTargetTypeRequest>): DeleteCustomTargetTypeRequest {
    return DeleteCustomTargetTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCustomTargetTypeRequest>): DeleteCustomTargetTypeRequest {
    const message = createBaseDeleteCustomTargetTypeRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseDeployPolicy(): DeployPolicy {
  return {
    name: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    suspended: false,
    selectors: [],
    rules: [],
    etag: "",
  };
}

export const DeployPolicy: MessageFns<DeployPolicy> = {
  encode(message: DeployPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      DeployPolicy_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      DeployPolicy_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.suspended !== false) {
      writer.uint32(64).bool(message.suspended);
    }
    for (const v of message.selectors) {
      DeployPolicyResourceSelector.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.rules) {
      PolicyRule.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(90).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = DeployPolicy_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.annotations[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = DeployPolicy_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.suspended = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.selectors.push(DeployPolicyResourceSelector.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.rules.push(PolicyRule.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      suspended: isSet(object.suspended) ? globalThis.Boolean(object.suspended) : false,
      selectors: globalThis.Array.isArray(object?.selectors)
        ? object.selectors.map((e: any) => DeployPolicyResourceSelector.fromJSON(e))
        : [],
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => PolicyRule.fromJSON(e)) : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeployPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.suspended !== false) {
      obj.suspended = message.suspended;
    }
    if (message.selectors?.length) {
      obj.selectors = message.selectors.map((e) => DeployPolicyResourceSelector.toJSON(e));
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => PolicyRule.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployPolicy>): DeployPolicy {
    return DeployPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployPolicy>): DeployPolicy {
    const message = createBaseDeployPolicy();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.suspended = object.suspended ?? false;
    message.selectors = object.selectors?.map((e) => DeployPolicyResourceSelector.fromPartial(e)) || [];
    message.rules = object.rules?.map((e) => PolicyRule.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseDeployPolicy_AnnotationsEntry(): DeployPolicy_AnnotationsEntry {
  return { key: "", value: "" };
}

export const DeployPolicy_AnnotationsEntry: MessageFns<DeployPolicy_AnnotationsEntry> = {
  encode(message: DeployPolicy_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployPolicy_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployPolicy_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployPolicy_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeployPolicy_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployPolicy_AnnotationsEntry>): DeployPolicy_AnnotationsEntry {
    return DeployPolicy_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployPolicy_AnnotationsEntry>): DeployPolicy_AnnotationsEntry {
    const message = createBaseDeployPolicy_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeployPolicy_LabelsEntry(): DeployPolicy_LabelsEntry {
  return { key: "", value: "" };
}

export const DeployPolicy_LabelsEntry: MessageFns<DeployPolicy_LabelsEntry> = {
  encode(message: DeployPolicy_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployPolicy_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployPolicy_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployPolicy_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeployPolicy_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployPolicy_LabelsEntry>): DeployPolicy_LabelsEntry {
    return DeployPolicy_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployPolicy_LabelsEntry>): DeployPolicy_LabelsEntry {
    const message = createBaseDeployPolicy_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeployPolicyResourceSelector(): DeployPolicyResourceSelector {
  return { deliveryPipeline: undefined, target: undefined };
}

export const DeployPolicyResourceSelector: MessageFns<DeployPolicyResourceSelector> = {
  encode(message: DeployPolicyResourceSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deliveryPipeline !== undefined) {
      DeliveryPipelineAttribute.encode(message.deliveryPipeline, writer.uint32(10).fork()).join();
    }
    if (message.target !== undefined) {
      TargetAttribute.encode(message.target, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployPolicyResourceSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployPolicyResourceSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deliveryPipeline = DeliveryPipelineAttribute.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = TargetAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployPolicyResourceSelector {
    return {
      deliveryPipeline: isSet(object.deliveryPipeline)
        ? DeliveryPipelineAttribute.fromJSON(object.deliveryPipeline)
        : undefined,
      target: isSet(object.target) ? TargetAttribute.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: DeployPolicyResourceSelector): unknown {
    const obj: any = {};
    if (message.deliveryPipeline !== undefined) {
      obj.deliveryPipeline = DeliveryPipelineAttribute.toJSON(message.deliveryPipeline);
    }
    if (message.target !== undefined) {
      obj.target = TargetAttribute.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployPolicyResourceSelector>): DeployPolicyResourceSelector {
    return DeployPolicyResourceSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployPolicyResourceSelector>): DeployPolicyResourceSelector {
    const message = createBaseDeployPolicyResourceSelector();
    message.deliveryPipeline = (object.deliveryPipeline !== undefined && object.deliveryPipeline !== null)
      ? DeliveryPipelineAttribute.fromPartial(object.deliveryPipeline)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? TargetAttribute.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseDeliveryPipelineAttribute(): DeliveryPipelineAttribute {
  return { id: "", labels: {} };
}

export const DeliveryPipelineAttribute: MessageFns<DeliveryPipelineAttribute> = {
  encode(message: DeliveryPipelineAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DeliveryPipelineAttribute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryPipelineAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryPipelineAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = DeliveryPipelineAttribute_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryPipelineAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeliveryPipelineAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryPipelineAttribute>): DeliveryPipelineAttribute {
    return DeliveryPipelineAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryPipelineAttribute>): DeliveryPipelineAttribute {
    const message = createBaseDeliveryPipelineAttribute();
    message.id = object.id ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDeliveryPipelineAttribute_LabelsEntry(): DeliveryPipelineAttribute_LabelsEntry {
  return { key: "", value: "" };
}

export const DeliveryPipelineAttribute_LabelsEntry: MessageFns<DeliveryPipelineAttribute_LabelsEntry> = {
  encode(message: DeliveryPipelineAttribute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryPipelineAttribute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryPipelineAttribute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryPipelineAttribute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeliveryPipelineAttribute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryPipelineAttribute_LabelsEntry>): DeliveryPipelineAttribute_LabelsEntry {
    return DeliveryPipelineAttribute_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryPipelineAttribute_LabelsEntry>): DeliveryPipelineAttribute_LabelsEntry {
    const message = createBaseDeliveryPipelineAttribute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTargetAttribute(): TargetAttribute {
  return { id: "", labels: {} };
}

export const TargetAttribute: MessageFns<TargetAttribute> = {
  encode(message: TargetAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TargetAttribute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = TargetAttribute_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TargetAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TargetAttribute>): TargetAttribute {
    return TargetAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetAttribute>): TargetAttribute {
    const message = createBaseTargetAttribute();
    message.id = object.id ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTargetAttribute_LabelsEntry(): TargetAttribute_LabelsEntry {
  return { key: "", value: "" };
}

export const TargetAttribute_LabelsEntry: MessageFns<TargetAttribute_LabelsEntry> = {
  encode(message: TargetAttribute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetAttribute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetAttribute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetAttribute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TargetAttribute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TargetAttribute_LabelsEntry>): TargetAttribute_LabelsEntry {
    return TargetAttribute_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetAttribute_LabelsEntry>): TargetAttribute_LabelsEntry {
    const message = createBaseTargetAttribute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePolicyRule(): PolicyRule {
  return { rolloutRestriction: undefined };
}

export const PolicyRule: MessageFns<PolicyRule> = {
  encode(message: PolicyRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rolloutRestriction !== undefined) {
      RolloutRestriction.encode(message.rolloutRestriction, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rolloutRestriction = RolloutRestriction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyRule {
    return {
      rolloutRestriction: isSet(object.rolloutRestriction)
        ? RolloutRestriction.fromJSON(object.rolloutRestriction)
        : undefined,
    };
  },

  toJSON(message: PolicyRule): unknown {
    const obj: any = {};
    if (message.rolloutRestriction !== undefined) {
      obj.rolloutRestriction = RolloutRestriction.toJSON(message.rolloutRestriction);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyRule>): PolicyRule {
    return PolicyRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyRule>): PolicyRule {
    const message = createBasePolicyRule();
    message.rolloutRestriction = (object.rolloutRestriction !== undefined && object.rolloutRestriction !== null)
      ? RolloutRestriction.fromPartial(object.rolloutRestriction)
      : undefined;
    return message;
  },
};

function createBaseRolloutRestriction(): RolloutRestriction {
  return { id: "", invokers: [], actions: [], timeWindows: undefined };
}

export const RolloutRestriction: MessageFns<RolloutRestriction> = {
  encode(message: RolloutRestriction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.invokers) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.actions) {
      writer.int32(v);
    }
    writer.join();
    if (message.timeWindows !== undefined) {
      TimeWindows.encode(message.timeWindows, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RolloutRestriction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRolloutRestriction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.invokers.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.invokers.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.actions.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.actions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeWindows = TimeWindows.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RolloutRestriction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      invokers: globalThis.Array.isArray(object?.invokers)
        ? object.invokers.map((e: any) => deployPolicy_InvokerFromJSON(e))
        : [],
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => rolloutRestriction_RolloutActionsFromJSON(e))
        : [],
      timeWindows: isSet(object.timeWindows) ? TimeWindows.fromJSON(object.timeWindows) : undefined,
    };
  },

  toJSON(message: RolloutRestriction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.invokers?.length) {
      obj.invokers = message.invokers.map((e) => deployPolicy_InvokerToJSON(e));
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => rolloutRestriction_RolloutActionsToJSON(e));
    }
    if (message.timeWindows !== undefined) {
      obj.timeWindows = TimeWindows.toJSON(message.timeWindows);
    }
    return obj;
  },

  create(base?: DeepPartial<RolloutRestriction>): RolloutRestriction {
    return RolloutRestriction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RolloutRestriction>): RolloutRestriction {
    const message = createBaseRolloutRestriction();
    message.id = object.id ?? "";
    message.invokers = object.invokers?.map((e) => e) || [];
    message.actions = object.actions?.map((e) => e) || [];
    message.timeWindows = (object.timeWindows !== undefined && object.timeWindows !== null)
      ? TimeWindows.fromPartial(object.timeWindows)
      : undefined;
    return message;
  },
};

function createBaseTimeWindows(): TimeWindows {
  return { timeZone: "", oneTimeWindows: [], weeklyWindows: [] };
}

export const TimeWindows: MessageFns<TimeWindows> = {
  encode(message: TimeWindows, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeZone !== "") {
      writer.uint32(10).string(message.timeZone);
    }
    for (const v of message.oneTimeWindows) {
      OneTimeWindow.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.weeklyWindows) {
      WeeklyWindow.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindows {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindows();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oneTimeWindows.push(OneTimeWindow.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.weeklyWindows.push(WeeklyWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindows {
    return {
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      oneTimeWindows: globalThis.Array.isArray(object?.oneTimeWindows)
        ? object.oneTimeWindows.map((e: any) => OneTimeWindow.fromJSON(e))
        : [],
      weeklyWindows: globalThis.Array.isArray(object?.weeklyWindows)
        ? object.weeklyWindows.map((e: any) => WeeklyWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TimeWindows): unknown {
    const obj: any = {};
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.oneTimeWindows?.length) {
      obj.oneTimeWindows = message.oneTimeWindows.map((e) => OneTimeWindow.toJSON(e));
    }
    if (message.weeklyWindows?.length) {
      obj.weeklyWindows = message.weeklyWindows.map((e) => WeeklyWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindows>): TimeWindows {
    return TimeWindows.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindows>): TimeWindows {
    const message = createBaseTimeWindows();
    message.timeZone = object.timeZone ?? "";
    message.oneTimeWindows = object.oneTimeWindows?.map((e) => OneTimeWindow.fromPartial(e)) || [];
    message.weeklyWindows = object.weeklyWindows?.map((e) => WeeklyWindow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOneTimeWindow(): OneTimeWindow {
  return { startDate: undefined, startTime: undefined, endDate: undefined, endTime: undefined };
}

export const OneTimeWindow: MessageFns<OneTimeWindow> = {
  encode(message: OneTimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== undefined) {
      DateMessage.encode(message.startDate, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      TimeOfDay.encode(message.startTime, writer.uint32(18).fork()).join();
    }
    if (message.endDate !== undefined) {
      DateMessage.encode(message.endDate, writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      TimeOfDay.encode(message.endTime, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneTimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneTimeWindow {
    return {
      startDate: isSet(object.startDate) ? DateMessage.fromJSON(object.startDate) : undefined,
      startTime: isSet(object.startTime) ? TimeOfDay.fromJSON(object.startTime) : undefined,
      endDate: isSet(object.endDate) ? DateMessage.fromJSON(object.endDate) : undefined,
      endTime: isSet(object.endTime) ? TimeOfDay.fromJSON(object.endTime) : undefined,
    };
  },

  toJSON(message: OneTimeWindow): unknown {
    const obj: any = {};
    if (message.startDate !== undefined) {
      obj.startDate = DateMessage.toJSON(message.startDate);
    }
    if (message.startTime !== undefined) {
      obj.startTime = TimeOfDay.toJSON(message.startTime);
    }
    if (message.endDate !== undefined) {
      obj.endDate = DateMessage.toJSON(message.endDate);
    }
    if (message.endTime !== undefined) {
      obj.endTime = TimeOfDay.toJSON(message.endTime);
    }
    return obj;
  },

  create(base?: DeepPartial<OneTimeWindow>): OneTimeWindow {
    return OneTimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OneTimeWindow>): OneTimeWindow {
    const message = createBaseOneTimeWindow();
    message.startDate = (object.startDate !== undefined && object.startDate !== null)
      ? DateMessage.fromPartial(object.startDate)
      : undefined;
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? TimeOfDay.fromPartial(object.startTime)
      : undefined;
    message.endDate = (object.endDate !== undefined && object.endDate !== null)
      ? DateMessage.fromPartial(object.endDate)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? TimeOfDay.fromPartial(object.endTime)
      : undefined;
    return message;
  },
};

function createBaseWeeklyWindow(): WeeklyWindow {
  return { daysOfWeek: [], startTime: undefined, endTime: undefined };
}

export const WeeklyWindow: MessageFns<WeeklyWindow> = {
  encode(message: WeeklyWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.daysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    if (message.startTime !== undefined) {
      TimeOfDay.encode(message.startTime, writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      TimeOfDay.encode(message.endTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklyWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklyWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.daysOfWeek.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.daysOfWeek.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklyWindow {
    return {
      daysOfWeek: globalThis.Array.isArray(object?.daysOfWeek)
        ? object.daysOfWeek.map((e: any) => dayOfWeekFromJSON(e))
        : [],
      startTime: isSet(object.startTime) ? TimeOfDay.fromJSON(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? TimeOfDay.fromJSON(object.endTime) : undefined,
    };
  },

  toJSON(message: WeeklyWindow): unknown {
    const obj: any = {};
    if (message.daysOfWeek?.length) {
      obj.daysOfWeek = message.daysOfWeek.map((e) => dayOfWeekToJSON(e));
    }
    if (message.startTime !== undefined) {
      obj.startTime = TimeOfDay.toJSON(message.startTime);
    }
    if (message.endTime !== undefined) {
      obj.endTime = TimeOfDay.toJSON(message.endTime);
    }
    return obj;
  },

  create(base?: DeepPartial<WeeklyWindow>): WeeklyWindow {
    return WeeklyWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeeklyWindow>): WeeklyWindow {
    const message = createBaseWeeklyWindow();
    message.daysOfWeek = object.daysOfWeek?.map((e) => e) || [];
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? TimeOfDay.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? TimeOfDay.fromPartial(object.endTime)
      : undefined;
    return message;
  },
};

function createBasePolicyViolation(): PolicyViolation {
  return { policyViolationDetails: [] };
}

export const PolicyViolation: MessageFns<PolicyViolation> = {
  encode(message: PolicyViolation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policyViolationDetails) {
      PolicyViolationDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyViolation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyViolation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyViolationDetails.push(PolicyViolationDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyViolation {
    return {
      policyViolationDetails: globalThis.Array.isArray(object?.policyViolationDetails)
        ? object.policyViolationDetails.map((e: any) => PolicyViolationDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolicyViolation): unknown {
    const obj: any = {};
    if (message.policyViolationDetails?.length) {
      obj.policyViolationDetails = message.policyViolationDetails.map((e) => PolicyViolationDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyViolation>): PolicyViolation {
    return PolicyViolation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyViolation>): PolicyViolation {
    const message = createBasePolicyViolation();
    message.policyViolationDetails = object.policyViolationDetails?.map((e) => PolicyViolationDetails.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBasePolicyViolationDetails(): PolicyViolationDetails {
  return { policy: "", ruleId: "", failureMessage: "" };
}

export const PolicyViolationDetails: MessageFns<PolicyViolationDetails> = {
  encode(message: PolicyViolationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.policy !== "") {
      writer.uint32(10).string(message.policy);
    }
    if (message.ruleId !== "") {
      writer.uint32(18).string(message.ruleId);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyViolationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyViolationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyViolationDetails {
    return {
      policy: isSet(object.policy) ? globalThis.String(object.policy) : "",
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: PolicyViolationDetails): unknown {
    const obj: any = {};
    if (message.policy !== "") {
      obj.policy = message.policy;
    }
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyViolationDetails>): PolicyViolationDetails {
    return PolicyViolationDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyViolationDetails>): PolicyViolationDetails {
    const message = createBasePolicyViolationDetails();
    message.policy = object.policy ?? "";
    message.ruleId = object.ruleId ?? "";
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseRelease(): Release {
  return {
    name: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    abandoned: false,
    createTime: undefined,
    renderStartTime: undefined,
    renderEndTime: undefined,
    skaffoldConfigUri: "",
    skaffoldConfigPath: "",
    buildArtifacts: [],
    deliveryPipelineSnapshot: undefined,
    targetSnapshots: [],
    customTargetTypeSnapshots: [],
    renderState: 0,
    etag: "",
    skaffoldVersion: "",
    targetArtifacts: {},
    targetRenders: {},
    condition: undefined,
    deployParameters: {},
  };
}

export const Release: MessageFns<Release> = {
  encode(message: Release, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Release_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      Release_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.abandoned !== false) {
      writer.uint32(184).bool(message.abandoned);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.renderStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.renderStartTime), writer.uint32(58).fork()).join();
    }
    if (message.renderEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.renderEndTime), writer.uint32(66).fork()).join();
    }
    if (message.skaffoldConfigUri !== "") {
      writer.uint32(138).string(message.skaffoldConfigUri);
    }
    if (message.skaffoldConfigPath !== "") {
      writer.uint32(74).string(message.skaffoldConfigPath);
    }
    for (const v of message.buildArtifacts) {
      BuildArtifact.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.deliveryPipelineSnapshot !== undefined) {
      DeliveryPipeline.encode(message.deliveryPipelineSnapshot, writer.uint32(90).fork()).join();
    }
    for (const v of message.targetSnapshots) {
      Target.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.customTargetTypeSnapshots) {
      CustomTargetType.encode(v!, writer.uint32(218).fork()).join();
    }
    if (message.renderState !== 0) {
      writer.uint32(104).int32(message.renderState);
    }
    if (message.etag !== "") {
      writer.uint32(130).string(message.etag);
    }
    if (message.skaffoldVersion !== "") {
      writer.uint32(154).string(message.skaffoldVersion);
    }
    Object.entries(message.targetArtifacts).forEach(([key, value]) => {
      Release_TargetArtifactsEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).join();
    });
    Object.entries(message.targetRenders).forEach(([key, value]) => {
      Release_TargetRendersEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.condition !== undefined) {
      Release_ReleaseCondition.encode(message.condition, writer.uint32(194).fork()).join();
    }
    Object.entries(message.deployParameters).forEach(([key, value]) => {
      Release_DeployParametersEntry.encode({ key: key as any, value }, writer.uint32(202).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Release_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.annotations[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Release_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.abandoned = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.renderStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.renderEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.skaffoldConfigUri = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.skaffoldConfigPath = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.buildArtifacts.push(BuildArtifact.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.deliveryPipelineSnapshot = DeliveryPipeline.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.targetSnapshots.push(Target.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.customTargetTypeSnapshots.push(CustomTargetType.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.renderState = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.skaffoldVersion = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          const entry20 = Release_TargetArtifactsEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.targetArtifacts[entry20.key] = entry20.value;
          }
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = Release_TargetRendersEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.targetRenders[entry22.key] = entry22.value;
          }
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.condition = Release_ReleaseCondition.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          const entry25 = Release_DeployParametersEntry.decode(reader, reader.uint32());
          if (entry25.value !== undefined) {
            message.deployParameters[entry25.key] = entry25.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      abandoned: isSet(object.abandoned) ? globalThis.Boolean(object.abandoned) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      renderStartTime: isSet(object.renderStartTime) ? fromJsonTimestamp(object.renderStartTime) : undefined,
      renderEndTime: isSet(object.renderEndTime) ? fromJsonTimestamp(object.renderEndTime) : undefined,
      skaffoldConfigUri: isSet(object.skaffoldConfigUri) ? globalThis.String(object.skaffoldConfigUri) : "",
      skaffoldConfigPath: isSet(object.skaffoldConfigPath) ? globalThis.String(object.skaffoldConfigPath) : "",
      buildArtifacts: globalThis.Array.isArray(object?.buildArtifacts)
        ? object.buildArtifacts.map((e: any) => BuildArtifact.fromJSON(e))
        : [],
      deliveryPipelineSnapshot: isSet(object.deliveryPipelineSnapshot)
        ? DeliveryPipeline.fromJSON(object.deliveryPipelineSnapshot)
        : undefined,
      targetSnapshots: globalThis.Array.isArray(object?.targetSnapshots)
        ? object.targetSnapshots.map((e: any) => Target.fromJSON(e))
        : [],
      customTargetTypeSnapshots: globalThis.Array.isArray(object?.customTargetTypeSnapshots)
        ? object.customTargetTypeSnapshots.map((e: any) => CustomTargetType.fromJSON(e))
        : [],
      renderState: isSet(object.renderState) ? release_RenderStateFromJSON(object.renderState) : 0,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      skaffoldVersion: isSet(object.skaffoldVersion) ? globalThis.String(object.skaffoldVersion) : "",
      targetArtifacts: isObject(object.targetArtifacts)
        ? Object.entries(object.targetArtifacts).reduce<{ [key: string]: TargetArtifact }>((acc, [key, value]) => {
          acc[key] = TargetArtifact.fromJSON(value);
          return acc;
        }, {})
        : {},
      targetRenders: isObject(object.targetRenders)
        ? Object.entries(object.targetRenders).reduce<{ [key: string]: Release_TargetRender }>((acc, [key, value]) => {
          acc[key] = Release_TargetRender.fromJSON(value);
          return acc;
        }, {})
        : {},
      condition: isSet(object.condition) ? Release_ReleaseCondition.fromJSON(object.condition) : undefined,
      deployParameters: isObject(object.deployParameters)
        ? Object.entries(object.deployParameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Release): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.abandoned !== false) {
      obj.abandoned = message.abandoned;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.renderStartTime !== undefined) {
      obj.renderStartTime = message.renderStartTime.toISOString();
    }
    if (message.renderEndTime !== undefined) {
      obj.renderEndTime = message.renderEndTime.toISOString();
    }
    if (message.skaffoldConfigUri !== "") {
      obj.skaffoldConfigUri = message.skaffoldConfigUri;
    }
    if (message.skaffoldConfigPath !== "") {
      obj.skaffoldConfigPath = message.skaffoldConfigPath;
    }
    if (message.buildArtifacts?.length) {
      obj.buildArtifacts = message.buildArtifacts.map((e) => BuildArtifact.toJSON(e));
    }
    if (message.deliveryPipelineSnapshot !== undefined) {
      obj.deliveryPipelineSnapshot = DeliveryPipeline.toJSON(message.deliveryPipelineSnapshot);
    }
    if (message.targetSnapshots?.length) {
      obj.targetSnapshots = message.targetSnapshots.map((e) => Target.toJSON(e));
    }
    if (message.customTargetTypeSnapshots?.length) {
      obj.customTargetTypeSnapshots = message.customTargetTypeSnapshots.map((e) => CustomTargetType.toJSON(e));
    }
    if (message.renderState !== 0) {
      obj.renderState = release_RenderStateToJSON(message.renderState);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.skaffoldVersion !== "") {
      obj.skaffoldVersion = message.skaffoldVersion;
    }
    if (message.targetArtifacts) {
      const entries = Object.entries(message.targetArtifacts);
      if (entries.length > 0) {
        obj.targetArtifacts = {};
        entries.forEach(([k, v]) => {
          obj.targetArtifacts[k] = TargetArtifact.toJSON(v);
        });
      }
    }
    if (message.targetRenders) {
      const entries = Object.entries(message.targetRenders);
      if (entries.length > 0) {
        obj.targetRenders = {};
        entries.forEach(([k, v]) => {
          obj.targetRenders[k] = Release_TargetRender.toJSON(v);
        });
      }
    }
    if (message.condition !== undefined) {
      obj.condition = Release_ReleaseCondition.toJSON(message.condition);
    }
    if (message.deployParameters) {
      const entries = Object.entries(message.deployParameters);
      if (entries.length > 0) {
        obj.deployParameters = {};
        entries.forEach(([k, v]) => {
          obj.deployParameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Release>): Release {
    return Release.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release>): Release {
    const message = createBaseRelease();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.abandoned = object.abandoned ?? false;
    message.createTime = object.createTime ?? undefined;
    message.renderStartTime = object.renderStartTime ?? undefined;
    message.renderEndTime = object.renderEndTime ?? undefined;
    message.skaffoldConfigUri = object.skaffoldConfigUri ?? "";
    message.skaffoldConfigPath = object.skaffoldConfigPath ?? "";
    message.buildArtifacts = object.buildArtifacts?.map((e) => BuildArtifact.fromPartial(e)) || [];
    message.deliveryPipelineSnapshot =
      (object.deliveryPipelineSnapshot !== undefined && object.deliveryPipelineSnapshot !== null)
        ? DeliveryPipeline.fromPartial(object.deliveryPipelineSnapshot)
        : undefined;
    message.targetSnapshots = object.targetSnapshots?.map((e) => Target.fromPartial(e)) || [];
    message.customTargetTypeSnapshots = object.customTargetTypeSnapshots?.map((e) => CustomTargetType.fromPartial(e)) ||
      [];
    message.renderState = object.renderState ?? 0;
    message.etag = object.etag ?? "";
    message.skaffoldVersion = object.skaffoldVersion ?? "";
    message.targetArtifacts = Object.entries(object.targetArtifacts ?? {}).reduce<{ [key: string]: TargetArtifact }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TargetArtifact.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.targetRenders = Object.entries(object.targetRenders ?? {}).reduce<{ [key: string]: Release_TargetRender }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Release_TargetRender.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Release_ReleaseCondition.fromPartial(object.condition)
      : undefined;
    message.deployParameters = Object.entries(object.deployParameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRelease_TargetRender(): Release_TargetRender {
  return { renderingBuild: "", renderingState: 0, metadata: undefined, failureCause: 0, failureMessage: "" };
}

export const Release_TargetRender: MessageFns<Release_TargetRender> = {
  encode(message: Release_TargetRender, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.renderingBuild !== "") {
      writer.uint32(10).string(message.renderingBuild);
    }
    if (message.renderingState !== 0) {
      writer.uint32(16).int32(message.renderingState);
    }
    if (message.metadata !== undefined) {
      RenderMetadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.failureCause !== 0) {
      writer.uint32(32).int32(message.failureCause);
    }
    if (message.failureMessage !== "") {
      writer.uint32(42).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_TargetRender {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_TargetRender();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.renderingBuild = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.renderingState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = RenderMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureCause = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_TargetRender {
    return {
      renderingBuild: isSet(object.renderingBuild) ? globalThis.String(object.renderingBuild) : "",
      renderingState: isSet(object.renderingState)
        ? release_TargetRender_TargetRenderStateFromJSON(object.renderingState)
        : 0,
      metadata: isSet(object.metadata) ? RenderMetadata.fromJSON(object.metadata) : undefined,
      failureCause: isSet(object.failureCause) ? release_TargetRender_FailureCauseFromJSON(object.failureCause) : 0,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: Release_TargetRender): unknown {
    const obj: any = {};
    if (message.renderingBuild !== "") {
      obj.renderingBuild = message.renderingBuild;
    }
    if (message.renderingState !== 0) {
      obj.renderingState = release_TargetRender_TargetRenderStateToJSON(message.renderingState);
    }
    if (message.metadata !== undefined) {
      obj.metadata = RenderMetadata.toJSON(message.metadata);
    }
    if (message.failureCause !== 0) {
      obj.failureCause = release_TargetRender_FailureCauseToJSON(message.failureCause);
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<Release_TargetRender>): Release_TargetRender {
    return Release_TargetRender.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_TargetRender>): Release_TargetRender {
    const message = createBaseRelease_TargetRender();
    message.renderingBuild = object.renderingBuild ?? "";
    message.renderingState = object.renderingState ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RenderMetadata.fromPartial(object.metadata)
      : undefined;
    message.failureCause = object.failureCause ?? 0;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseRelease_ReleaseReadyCondition(): Release_ReleaseReadyCondition {
  return { status: false };
}

export const Release_ReleaseReadyCondition: MessageFns<Release_ReleaseReadyCondition> = {
  encode(message: Release_ReleaseReadyCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_ReleaseReadyCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_ReleaseReadyCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_ReleaseReadyCondition {
    return { status: isSet(object.status) ? globalThis.Boolean(object.status) : false };
  },

  toJSON(message: Release_ReleaseReadyCondition): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<Release_ReleaseReadyCondition>): Release_ReleaseReadyCondition {
    return Release_ReleaseReadyCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_ReleaseReadyCondition>): Release_ReleaseReadyCondition {
    const message = createBaseRelease_ReleaseReadyCondition();
    message.status = object.status ?? false;
    return message;
  },
};

function createBaseRelease_SkaffoldSupportedCondition(): Release_SkaffoldSupportedCondition {
  return { status: false, skaffoldSupportState: 0, maintenanceModeTime: undefined, supportExpirationTime: undefined };
}

export const Release_SkaffoldSupportedCondition: MessageFns<Release_SkaffoldSupportedCondition> = {
  encode(message: Release_SkaffoldSupportedCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== false) {
      writer.uint32(8).bool(message.status);
    }
    if (message.skaffoldSupportState !== 0) {
      writer.uint32(16).int32(message.skaffoldSupportState);
    }
    if (message.maintenanceModeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.maintenanceModeTime), writer.uint32(26).fork()).join();
    }
    if (message.supportExpirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.supportExpirationTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_SkaffoldSupportedCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_SkaffoldSupportedCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skaffoldSupportState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maintenanceModeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supportExpirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_SkaffoldSupportedCondition {
    return {
      status: isSet(object.status) ? globalThis.Boolean(object.status) : false,
      skaffoldSupportState: isSet(object.skaffoldSupportState)
        ? skaffoldSupportStateFromJSON(object.skaffoldSupportState)
        : 0,
      maintenanceModeTime: isSet(object.maintenanceModeTime)
        ? fromJsonTimestamp(object.maintenanceModeTime)
        : undefined,
      supportExpirationTime: isSet(object.supportExpirationTime)
        ? fromJsonTimestamp(object.supportExpirationTime)
        : undefined,
    };
  },

  toJSON(message: Release_SkaffoldSupportedCondition): unknown {
    const obj: any = {};
    if (message.status !== false) {
      obj.status = message.status;
    }
    if (message.skaffoldSupportState !== 0) {
      obj.skaffoldSupportState = skaffoldSupportStateToJSON(message.skaffoldSupportState);
    }
    if (message.maintenanceModeTime !== undefined) {
      obj.maintenanceModeTime = message.maintenanceModeTime.toISOString();
    }
    if (message.supportExpirationTime !== undefined) {
      obj.supportExpirationTime = message.supportExpirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Release_SkaffoldSupportedCondition>): Release_SkaffoldSupportedCondition {
    return Release_SkaffoldSupportedCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_SkaffoldSupportedCondition>): Release_SkaffoldSupportedCondition {
    const message = createBaseRelease_SkaffoldSupportedCondition();
    message.status = object.status ?? false;
    message.skaffoldSupportState = object.skaffoldSupportState ?? 0;
    message.maintenanceModeTime = object.maintenanceModeTime ?? undefined;
    message.supportExpirationTime = object.supportExpirationTime ?? undefined;
    return message;
  },
};

function createBaseRelease_ReleaseCondition(): Release_ReleaseCondition {
  return { releaseReadyCondition: undefined, skaffoldSupportedCondition: undefined };
}

export const Release_ReleaseCondition: MessageFns<Release_ReleaseCondition> = {
  encode(message: Release_ReleaseCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.releaseReadyCondition !== undefined) {
      Release_ReleaseReadyCondition.encode(message.releaseReadyCondition, writer.uint32(10).fork()).join();
    }
    if (message.skaffoldSupportedCondition !== undefined) {
      Release_SkaffoldSupportedCondition.encode(message.skaffoldSupportedCondition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_ReleaseCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_ReleaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.releaseReadyCondition = Release_ReleaseReadyCondition.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skaffoldSupportedCondition = Release_SkaffoldSupportedCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_ReleaseCondition {
    return {
      releaseReadyCondition: isSet(object.releaseReadyCondition)
        ? Release_ReleaseReadyCondition.fromJSON(object.releaseReadyCondition)
        : undefined,
      skaffoldSupportedCondition: isSet(object.skaffoldSupportedCondition)
        ? Release_SkaffoldSupportedCondition.fromJSON(object.skaffoldSupportedCondition)
        : undefined,
    };
  },

  toJSON(message: Release_ReleaseCondition): unknown {
    const obj: any = {};
    if (message.releaseReadyCondition !== undefined) {
      obj.releaseReadyCondition = Release_ReleaseReadyCondition.toJSON(message.releaseReadyCondition);
    }
    if (message.skaffoldSupportedCondition !== undefined) {
      obj.skaffoldSupportedCondition = Release_SkaffoldSupportedCondition.toJSON(message.skaffoldSupportedCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<Release_ReleaseCondition>): Release_ReleaseCondition {
    return Release_ReleaseCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_ReleaseCondition>): Release_ReleaseCondition {
    const message = createBaseRelease_ReleaseCondition();
    message.releaseReadyCondition =
      (object.releaseReadyCondition !== undefined && object.releaseReadyCondition !== null)
        ? Release_ReleaseReadyCondition.fromPartial(object.releaseReadyCondition)
        : undefined;
    message.skaffoldSupportedCondition =
      (object.skaffoldSupportedCondition !== undefined && object.skaffoldSupportedCondition !== null)
        ? Release_SkaffoldSupportedCondition.fromPartial(object.skaffoldSupportedCondition)
        : undefined;
    return message;
  },
};

function createBaseRelease_AnnotationsEntry(): Release_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Release_AnnotationsEntry: MessageFns<Release_AnnotationsEntry> = {
  encode(message: Release_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Release_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Release_AnnotationsEntry>): Release_AnnotationsEntry {
    return Release_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_AnnotationsEntry>): Release_AnnotationsEntry {
    const message = createBaseRelease_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRelease_LabelsEntry(): Release_LabelsEntry {
  return { key: "", value: "" };
}

export const Release_LabelsEntry: MessageFns<Release_LabelsEntry> = {
  encode(message: Release_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Release_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Release_LabelsEntry>): Release_LabelsEntry {
    return Release_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_LabelsEntry>): Release_LabelsEntry {
    const message = createBaseRelease_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRelease_TargetArtifactsEntry(): Release_TargetArtifactsEntry {
  return { key: "", value: undefined };
}

export const Release_TargetArtifactsEntry: MessageFns<Release_TargetArtifactsEntry> = {
  encode(message: Release_TargetArtifactsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TargetArtifact.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_TargetArtifactsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_TargetArtifactsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TargetArtifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_TargetArtifactsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TargetArtifact.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Release_TargetArtifactsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TargetArtifact.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Release_TargetArtifactsEntry>): Release_TargetArtifactsEntry {
    return Release_TargetArtifactsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_TargetArtifactsEntry>): Release_TargetArtifactsEntry {
    const message = createBaseRelease_TargetArtifactsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TargetArtifact.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRelease_TargetRendersEntry(): Release_TargetRendersEntry {
  return { key: "", value: undefined };
}

export const Release_TargetRendersEntry: MessageFns<Release_TargetRendersEntry> = {
  encode(message: Release_TargetRendersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Release_TargetRender.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_TargetRendersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_TargetRendersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Release_TargetRender.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_TargetRendersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Release_TargetRender.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Release_TargetRendersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Release_TargetRender.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Release_TargetRendersEntry>): Release_TargetRendersEntry {
    return Release_TargetRendersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_TargetRendersEntry>): Release_TargetRendersEntry {
    const message = createBaseRelease_TargetRendersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Release_TargetRender.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseRelease_DeployParametersEntry(): Release_DeployParametersEntry {
  return { key: "", value: "" };
}

export const Release_DeployParametersEntry: MessageFns<Release_DeployParametersEntry> = {
  encode(message: Release_DeployParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Release_DeployParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelease_DeployParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Release_DeployParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Release_DeployParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Release_DeployParametersEntry>): Release_DeployParametersEntry {
    return Release_DeployParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Release_DeployParametersEntry>): Release_DeployParametersEntry {
    const message = createBaseRelease_DeployParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateDeployPolicyRequest(): CreateDeployPolicyRequest {
  return { parent: "", deployPolicyId: "", deployPolicy: undefined, requestId: "", validateOnly: false };
}

export const CreateDeployPolicyRequest: MessageFns<CreateDeployPolicyRequest> = {
  encode(message: CreateDeployPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.deployPolicyId !== "") {
      writer.uint32(18).string(message.deployPolicyId);
    }
    if (message.deployPolicy !== undefined) {
      DeployPolicy.encode(message.deployPolicy, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDeployPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeployPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployPolicyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deployPolicy = DeployPolicy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDeployPolicyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      deployPolicyId: isSet(object.deployPolicyId) ? globalThis.String(object.deployPolicyId) : "",
      deployPolicy: isSet(object.deployPolicy) ? DeployPolicy.fromJSON(object.deployPolicy) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateDeployPolicyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.deployPolicyId !== "") {
      obj.deployPolicyId = message.deployPolicyId;
    }
    if (message.deployPolicy !== undefined) {
      obj.deployPolicy = DeployPolicy.toJSON(message.deployPolicy);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDeployPolicyRequest>): CreateDeployPolicyRequest {
    return CreateDeployPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDeployPolicyRequest>): CreateDeployPolicyRequest {
    const message = createBaseCreateDeployPolicyRequest();
    message.parent = object.parent ?? "";
    message.deployPolicyId = object.deployPolicyId ?? "";
    message.deployPolicy = (object.deployPolicy !== undefined && object.deployPolicy !== null)
      ? DeployPolicy.fromPartial(object.deployPolicy)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateDeployPolicyRequest(): UpdateDeployPolicyRequest {
  return { updateMask: undefined, deployPolicy: undefined, requestId: "", allowMissing: false, validateOnly: false };
}

export const UpdateDeployPolicyRequest: MessageFns<UpdateDeployPolicyRequest> = {
  encode(message: UpdateDeployPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.deployPolicy !== undefined) {
      DeployPolicy.encode(message.deployPolicy, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeployPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeployPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deployPolicy = DeployPolicy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeployPolicyRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      deployPolicy: isSet(object.deployPolicy) ? DeployPolicy.fromJSON(object.deployPolicy) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateDeployPolicyRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.deployPolicy !== undefined) {
      obj.deployPolicy = DeployPolicy.toJSON(message.deployPolicy);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDeployPolicyRequest>): UpdateDeployPolicyRequest {
    return UpdateDeployPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDeployPolicyRequest>): UpdateDeployPolicyRequest {
    const message = createBaseUpdateDeployPolicyRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.deployPolicy = (object.deployPolicy !== undefined && object.deployPolicy !== null)
      ? DeployPolicy.fromPartial(object.deployPolicy)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteDeployPolicyRequest(): DeleteDeployPolicyRequest {
  return { name: "", requestId: "", allowMissing: false, validateOnly: false, etag: "" };
}

export const DeleteDeployPolicyRequest: MessageFns<DeleteDeployPolicyRequest> = {
  encode(message: DeleteDeployPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDeployPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDeployPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDeployPolicyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteDeployPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDeployPolicyRequest>): DeleteDeployPolicyRequest {
    return DeleteDeployPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDeployPolicyRequest>): DeleteDeployPolicyRequest {
    const message = createBaseDeleteDeployPolicyRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseListDeployPoliciesRequest(): ListDeployPoliciesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDeployPoliciesRequest: MessageFns<ListDeployPoliciesRequest> = {
  encode(message: ListDeployPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeployPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeployPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeployPoliciesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDeployPoliciesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeployPoliciesRequest>): ListDeployPoliciesRequest {
    return ListDeployPoliciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeployPoliciesRequest>): ListDeployPoliciesRequest {
    const message = createBaseListDeployPoliciesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListDeployPoliciesResponse(): ListDeployPoliciesResponse {
  return { deployPolicies: [], nextPageToken: "", unreachable: [] };
}

export const ListDeployPoliciesResponse: MessageFns<ListDeployPoliciesResponse> = {
  encode(message: ListDeployPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployPolicies) {
      DeployPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeployPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeployPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployPolicies.push(DeployPolicy.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeployPoliciesResponse {
    return {
      deployPolicies: globalThis.Array.isArray(object?.deployPolicies)
        ? object.deployPolicies.map((e: any) => DeployPolicy.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDeployPoliciesResponse): unknown {
    const obj: any = {};
    if (message.deployPolicies?.length) {
      obj.deployPolicies = message.deployPolicies.map((e) => DeployPolicy.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeployPoliciesResponse>): ListDeployPoliciesResponse {
    return ListDeployPoliciesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeployPoliciesResponse>): ListDeployPoliciesResponse {
    const message = createBaseListDeployPoliciesResponse();
    message.deployPolicies = object.deployPolicies?.map((e) => DeployPolicy.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDeployPolicyRequest(): GetDeployPolicyRequest {
  return { name: "" };
}

export const GetDeployPolicyRequest: MessageFns<GetDeployPolicyRequest> = {
  encode(message: GetDeployPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeployPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeployPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeployPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDeployPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeployPolicyRequest>): GetDeployPolicyRequest {
    return GetDeployPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeployPolicyRequest>): GetDeployPolicyRequest {
    const message = createBaseGetDeployPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBuildArtifact(): BuildArtifact {
  return { image: "", tag: "" };
}

export const BuildArtifact: MessageFns<BuildArtifact> = {
  encode(message: BuildArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildArtifact {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: BuildArtifact): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(base?: DeepPartial<BuildArtifact>): BuildArtifact {
    return BuildArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BuildArtifact>): BuildArtifact {
    const message = createBaseBuildArtifact();
    message.image = object.image ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseTargetArtifact(): TargetArtifact {
  return { artifactUri: undefined, skaffoldConfigPath: "", manifestPath: "", phaseArtifacts: {} };
}

export const TargetArtifact: MessageFns<TargetArtifact> = {
  encode(message: TargetArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactUri !== undefined) {
      writer.uint32(34).string(message.artifactUri);
    }
    if (message.skaffoldConfigPath !== "") {
      writer.uint32(18).string(message.skaffoldConfigPath);
    }
    if (message.manifestPath !== "") {
      writer.uint32(26).string(message.manifestPath);
    }
    Object.entries(message.phaseArtifacts).forEach(([key, value]) => {
      TargetArtifact_PhaseArtifactsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.artifactUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skaffoldConfigPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.manifestPath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = TargetArtifact_PhaseArtifactsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.phaseArtifacts[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetArtifact {
    return {
      artifactUri: isSet(object.artifactUri) ? globalThis.String(object.artifactUri) : undefined,
      skaffoldConfigPath: isSet(object.skaffoldConfigPath) ? globalThis.String(object.skaffoldConfigPath) : "",
      manifestPath: isSet(object.manifestPath) ? globalThis.String(object.manifestPath) : "",
      phaseArtifacts: isObject(object.phaseArtifacts)
        ? Object.entries(object.phaseArtifacts).reduce<{ [key: string]: TargetArtifact_PhaseArtifact }>(
          (acc, [key, value]) => {
            acc[key] = TargetArtifact_PhaseArtifact.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: TargetArtifact): unknown {
    const obj: any = {};
    if (message.artifactUri !== undefined) {
      obj.artifactUri = message.artifactUri;
    }
    if (message.skaffoldConfigPath !== "") {
      obj.skaffoldConfigPath = message.skaffoldConfigPath;
    }
    if (message.manifestPath !== "") {
      obj.manifestPath = message.manifestPath;
    }
    if (message.phaseArtifacts) {
      const entries = Object.entries(message.phaseArtifacts);
      if (entries.length > 0) {
        obj.phaseArtifacts = {};
        entries.forEach(([k, v]) => {
          obj.phaseArtifacts[k] = TargetArtifact_PhaseArtifact.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TargetArtifact>): TargetArtifact {
    return TargetArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetArtifact>): TargetArtifact {
    const message = createBaseTargetArtifact();
    message.artifactUri = object.artifactUri ?? undefined;
    message.skaffoldConfigPath = object.skaffoldConfigPath ?? "";
    message.manifestPath = object.manifestPath ?? "";
    message.phaseArtifacts = Object.entries(object.phaseArtifacts ?? {}).reduce<
      { [key: string]: TargetArtifact_PhaseArtifact }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TargetArtifact_PhaseArtifact.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTargetArtifact_PhaseArtifact(): TargetArtifact_PhaseArtifact {
  return { skaffoldConfigPath: "", manifestPath: "", jobManifestsPath: "" };
}

export const TargetArtifact_PhaseArtifact: MessageFns<TargetArtifact_PhaseArtifact> = {
  encode(message: TargetArtifact_PhaseArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skaffoldConfigPath !== "") {
      writer.uint32(10).string(message.skaffoldConfigPath);
    }
    if (message.manifestPath !== "") {
      writer.uint32(26).string(message.manifestPath);
    }
    if (message.jobManifestsPath !== "") {
      writer.uint32(34).string(message.jobManifestsPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetArtifact_PhaseArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetArtifact_PhaseArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skaffoldConfigPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.manifestPath = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jobManifestsPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetArtifact_PhaseArtifact {
    return {
      skaffoldConfigPath: isSet(object.skaffoldConfigPath) ? globalThis.String(object.skaffoldConfigPath) : "",
      manifestPath: isSet(object.manifestPath) ? globalThis.String(object.manifestPath) : "",
      jobManifestsPath: isSet(object.jobManifestsPath) ? globalThis.String(object.jobManifestsPath) : "",
    };
  },

  toJSON(message: TargetArtifact_PhaseArtifact): unknown {
    const obj: any = {};
    if (message.skaffoldConfigPath !== "") {
      obj.skaffoldConfigPath = message.skaffoldConfigPath;
    }
    if (message.manifestPath !== "") {
      obj.manifestPath = message.manifestPath;
    }
    if (message.jobManifestsPath !== "") {
      obj.jobManifestsPath = message.jobManifestsPath;
    }
    return obj;
  },

  create(base?: DeepPartial<TargetArtifact_PhaseArtifact>): TargetArtifact_PhaseArtifact {
    return TargetArtifact_PhaseArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetArtifact_PhaseArtifact>): TargetArtifact_PhaseArtifact {
    const message = createBaseTargetArtifact_PhaseArtifact();
    message.skaffoldConfigPath = object.skaffoldConfigPath ?? "";
    message.manifestPath = object.manifestPath ?? "";
    message.jobManifestsPath = object.jobManifestsPath ?? "";
    return message;
  },
};

function createBaseTargetArtifact_PhaseArtifactsEntry(): TargetArtifact_PhaseArtifactsEntry {
  return { key: "", value: undefined };
}

export const TargetArtifact_PhaseArtifactsEntry: MessageFns<TargetArtifact_PhaseArtifactsEntry> = {
  encode(message: TargetArtifact_PhaseArtifactsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TargetArtifact_PhaseArtifact.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetArtifact_PhaseArtifactsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetArtifact_PhaseArtifactsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TargetArtifact_PhaseArtifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetArtifact_PhaseArtifactsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TargetArtifact_PhaseArtifact.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TargetArtifact_PhaseArtifactsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TargetArtifact_PhaseArtifact.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetArtifact_PhaseArtifactsEntry>): TargetArtifact_PhaseArtifactsEntry {
    return TargetArtifact_PhaseArtifactsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetArtifact_PhaseArtifactsEntry>): TargetArtifact_PhaseArtifactsEntry {
    const message = createBaseTargetArtifact_PhaseArtifactsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TargetArtifact_PhaseArtifact.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDeployArtifact(): DeployArtifact {
  return { artifactUri: "", manifestPaths: [] };
}

export const DeployArtifact: MessageFns<DeployArtifact> = {
  encode(message: DeployArtifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactUri !== "") {
      writer.uint32(10).string(message.artifactUri);
    }
    for (const v of message.manifestPaths) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployArtifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployArtifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.manifestPaths.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployArtifact {
    return {
      artifactUri: isSet(object.artifactUri) ? globalThis.String(object.artifactUri) : "",
      manifestPaths: globalThis.Array.isArray(object?.manifestPaths)
        ? object.manifestPaths.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeployArtifact): unknown {
    const obj: any = {};
    if (message.artifactUri !== "") {
      obj.artifactUri = message.artifactUri;
    }
    if (message.manifestPaths?.length) {
      obj.manifestPaths = message.manifestPaths;
    }
    return obj;
  },

  create(base?: DeepPartial<DeployArtifact>): DeployArtifact {
    return DeployArtifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployArtifact>): DeployArtifact {
    const message = createBaseDeployArtifact();
    message.artifactUri = object.artifactUri ?? "";
    message.manifestPaths = object.manifestPaths?.map((e) => e) || [];
    return message;
  },
};

function createBaseCloudRunRenderMetadata(): CloudRunRenderMetadata {
  return { service: "" };
}

export const CloudRunRenderMetadata: MessageFns<CloudRunRenderMetadata> = {
  encode(message: CloudRunRenderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunRenderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunRenderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunRenderMetadata {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: CloudRunRenderMetadata): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunRenderMetadata>): CloudRunRenderMetadata {
    return CloudRunRenderMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunRenderMetadata>): CloudRunRenderMetadata {
    const message = createBaseCloudRunRenderMetadata();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseRenderMetadata(): RenderMetadata {
  return { cloudRun: undefined, custom: undefined };
}

export const RenderMetadata: MessageFns<RenderMetadata> = {
  encode(message: RenderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudRun !== undefined) {
      CloudRunRenderMetadata.encode(message.cloudRun, writer.uint32(10).fork()).join();
    }
    if (message.custom !== undefined) {
      CustomMetadata.encode(message.custom, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudRun = CloudRunRenderMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.custom = CustomMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderMetadata {
    return {
      cloudRun: isSet(object.cloudRun) ? CloudRunRenderMetadata.fromJSON(object.cloudRun) : undefined,
      custom: isSet(object.custom) ? CustomMetadata.fromJSON(object.custom) : undefined,
    };
  },

  toJSON(message: RenderMetadata): unknown {
    const obj: any = {};
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRunRenderMetadata.toJSON(message.cloudRun);
    }
    if (message.custom !== undefined) {
      obj.custom = CustomMetadata.toJSON(message.custom);
    }
    return obj;
  },

  create(base?: DeepPartial<RenderMetadata>): RenderMetadata {
    return RenderMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenderMetadata>): RenderMetadata {
    const message = createBaseRenderMetadata();
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRunRenderMetadata.fromPartial(object.cloudRun)
      : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? CustomMetadata.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseListReleasesRequest(): ListReleasesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListReleasesRequest: MessageFns<ListReleasesRequest> = {
  encode(message: ListReleasesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReleasesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReleasesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReleasesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListReleasesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReleasesRequest>): ListReleasesRequest {
    return ListReleasesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReleasesRequest>): ListReleasesRequest {
    const message = createBaseListReleasesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListReleasesResponse(): ListReleasesResponse {
  return { releases: [], nextPageToken: "", unreachable: [] };
}

export const ListReleasesResponse: MessageFns<ListReleasesResponse> = {
  encode(message: ListReleasesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.releases) {
      Release.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReleasesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReleasesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.releases.push(Release.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReleasesResponse {
    return {
      releases: globalThis.Array.isArray(object?.releases) ? object.releases.map((e: any) => Release.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListReleasesResponse): unknown {
    const obj: any = {};
    if (message.releases?.length) {
      obj.releases = message.releases.map((e) => Release.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReleasesResponse>): ListReleasesResponse {
    return ListReleasesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReleasesResponse>): ListReleasesResponse {
    const message = createBaseListReleasesResponse();
    message.releases = object.releases?.map((e) => Release.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetReleaseRequest(): GetReleaseRequest {
  return { name: "" };
}

export const GetReleaseRequest: MessageFns<GetReleaseRequest> = {
  encode(message: GetReleaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReleaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReleaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReleaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReleaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReleaseRequest>): GetReleaseRequest {
    return GetReleaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReleaseRequest>): GetReleaseRequest {
    const message = createBaseGetReleaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateReleaseRequest(): CreateReleaseRequest {
  return {
    parent: "",
    releaseId: "",
    release: undefined,
    requestId: "",
    validateOnly: false,
    overrideDeployPolicy: [],
  };
}

export const CreateReleaseRequest: MessageFns<CreateReleaseRequest> = {
  encode(message: CreateReleaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.releaseId !== "") {
      writer.uint32(18).string(message.releaseId);
    }
    if (message.release !== undefined) {
      Release.encode(message.release, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReleaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReleaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.releaseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.release = Release.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReleaseRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      releaseId: isSet(object.releaseId) ? globalThis.String(object.releaseId) : "",
      release: isSet(object.release) ? Release.fromJSON(object.release) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CreateReleaseRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.releaseId !== "") {
      obj.releaseId = message.releaseId;
    }
    if (message.release !== undefined) {
      obj.release = Release.toJSON(message.release);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReleaseRequest>): CreateReleaseRequest {
    return CreateReleaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReleaseRequest>): CreateReleaseRequest {
    const message = createBaseCreateReleaseRequest();
    message.parent = object.parent ?? "";
    message.releaseId = object.releaseId ?? "";
    message.release = (object.release !== undefined && object.release !== null)
      ? Release.fromPartial(object.release)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseRollout(): Rollout {
  return {
    name: "",
    uid: "",
    description: "",
    annotations: {},
    labels: {},
    createTime: undefined,
    approveTime: undefined,
    enqueueTime: undefined,
    deployStartTime: undefined,
    deployEndTime: undefined,
    targetId: "",
    approvalState: 0,
    state: 0,
    failureReason: "",
    deployingBuild: "",
    etag: "",
    deployFailureCause: 0,
    phases: [],
    metadata: undefined,
    controllerRollout: "",
    rollbackOfRollout: "",
    rolledBackByRollouts: [],
  };
}

export const Rollout: MessageFns<Rollout> = {
  encode(message: Rollout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Rollout_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      Rollout_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.approveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.approveTime), writer.uint32(58).fork()).join();
    }
    if (message.enqueueTime !== undefined) {
      Timestamp.encode(toTimestamp(message.enqueueTime), writer.uint32(66).fork()).join();
    }
    if (message.deployStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deployStartTime), writer.uint32(74).fork()).join();
    }
    if (message.deployEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deployEndTime), writer.uint32(82).fork()).join();
    }
    if (message.targetId !== "") {
      writer.uint32(146).string(message.targetId);
    }
    if (message.approvalState !== 0) {
      writer.uint32(96).int32(message.approvalState);
    }
    if (message.state !== 0) {
      writer.uint32(104).int32(message.state);
    }
    if (message.failureReason !== "") {
      writer.uint32(114).string(message.failureReason);
    }
    if (message.deployingBuild !== "") {
      writer.uint32(138).string(message.deployingBuild);
    }
    if (message.etag !== "") {
      writer.uint32(130).string(message.etag);
    }
    if (message.deployFailureCause !== 0) {
      writer.uint32(152).int32(message.deployFailureCause);
    }
    for (const v of message.phases) {
      Phase.encode(v!, writer.uint32(186).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(194).fork()).join();
    }
    if (message.controllerRollout !== "") {
      writer.uint32(202).string(message.controllerRollout);
    }
    if (message.rollbackOfRollout !== "") {
      writer.uint32(210).string(message.rollbackOfRollout);
    }
    for (const v of message.rolledBackByRollouts) {
      writer.uint32(218).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rollout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Rollout_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.annotations[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Rollout_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.approveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.enqueueTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.deployStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.deployEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.approvalState = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.deployingBuild = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.deployFailureCause = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.phases.push(Phase.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.controllerRollout = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.rollbackOfRollout = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.rolledBackByRollouts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rollout {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      approveTime: isSet(object.approveTime) ? fromJsonTimestamp(object.approveTime) : undefined,
      enqueueTime: isSet(object.enqueueTime) ? fromJsonTimestamp(object.enqueueTime) : undefined,
      deployStartTime: isSet(object.deployStartTime) ? fromJsonTimestamp(object.deployStartTime) : undefined,
      deployEndTime: isSet(object.deployEndTime) ? fromJsonTimestamp(object.deployEndTime) : undefined,
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      approvalState: isSet(object.approvalState) ? rollout_ApprovalStateFromJSON(object.approvalState) : 0,
      state: isSet(object.state) ? rollout_StateFromJSON(object.state) : 0,
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : "",
      deployingBuild: isSet(object.deployingBuild) ? globalThis.String(object.deployingBuild) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      deployFailureCause: isSet(object.deployFailureCause)
        ? rollout_FailureCauseFromJSON(object.deployFailureCause)
        : 0,
      phases: globalThis.Array.isArray(object?.phases) ? object.phases.map((e: any) => Phase.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      controllerRollout: isSet(object.controllerRollout) ? globalThis.String(object.controllerRollout) : "",
      rollbackOfRollout: isSet(object.rollbackOfRollout) ? globalThis.String(object.rollbackOfRollout) : "",
      rolledBackByRollouts: globalThis.Array.isArray(object?.rolledBackByRollouts)
        ? object.rolledBackByRollouts.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Rollout): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.approveTime !== undefined) {
      obj.approveTime = message.approveTime.toISOString();
    }
    if (message.enqueueTime !== undefined) {
      obj.enqueueTime = message.enqueueTime.toISOString();
    }
    if (message.deployStartTime !== undefined) {
      obj.deployStartTime = message.deployStartTime.toISOString();
    }
    if (message.deployEndTime !== undefined) {
      obj.deployEndTime = message.deployEndTime.toISOString();
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.approvalState !== 0) {
      obj.approvalState = rollout_ApprovalStateToJSON(message.approvalState);
    }
    if (message.state !== 0) {
      obj.state = rollout_StateToJSON(message.state);
    }
    if (message.failureReason !== "") {
      obj.failureReason = message.failureReason;
    }
    if (message.deployingBuild !== "") {
      obj.deployingBuild = message.deployingBuild;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.deployFailureCause !== 0) {
      obj.deployFailureCause = rollout_FailureCauseToJSON(message.deployFailureCause);
    }
    if (message.phases?.length) {
      obj.phases = message.phases.map((e) => Phase.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.controllerRollout !== "") {
      obj.controllerRollout = message.controllerRollout;
    }
    if (message.rollbackOfRollout !== "") {
      obj.rollbackOfRollout = message.rollbackOfRollout;
    }
    if (message.rolledBackByRollouts?.length) {
      obj.rolledBackByRollouts = message.rolledBackByRollouts;
    }
    return obj;
  },

  create(base?: DeepPartial<Rollout>): Rollout {
    return Rollout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rollout>): Rollout {
    const message = createBaseRollout();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.approveTime = object.approveTime ?? undefined;
    message.enqueueTime = object.enqueueTime ?? undefined;
    message.deployStartTime = object.deployStartTime ?? undefined;
    message.deployEndTime = object.deployEndTime ?? undefined;
    message.targetId = object.targetId ?? "";
    message.approvalState = object.approvalState ?? 0;
    message.state = object.state ?? 0;
    message.failureReason = object.failureReason ?? "";
    message.deployingBuild = object.deployingBuild ?? "";
    message.etag = object.etag ?? "";
    message.deployFailureCause = object.deployFailureCause ?? 0;
    message.phases = object.phases?.map((e) => Phase.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.controllerRollout = object.controllerRollout ?? "";
    message.rollbackOfRollout = object.rollbackOfRollout ?? "";
    message.rolledBackByRollouts = object.rolledBackByRollouts?.map((e) => e) || [];
    return message;
  },
};

function createBaseRollout_AnnotationsEntry(): Rollout_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Rollout_AnnotationsEntry: MessageFns<Rollout_AnnotationsEntry> = {
  encode(message: Rollout_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rollout_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rollout_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Rollout_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Rollout_AnnotationsEntry>): Rollout_AnnotationsEntry {
    return Rollout_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rollout_AnnotationsEntry>): Rollout_AnnotationsEntry {
    const message = createBaseRollout_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRollout_LabelsEntry(): Rollout_LabelsEntry {
  return { key: "", value: "" };
}

export const Rollout_LabelsEntry: MessageFns<Rollout_LabelsEntry> = {
  encode(message: Rollout_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rollout_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollout_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rollout_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Rollout_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Rollout_LabelsEntry>): Rollout_LabelsEntry {
    return Rollout_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rollout_LabelsEntry>): Rollout_LabelsEntry {
    const message = createBaseRollout_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { cloudRun: undefined, automation: undefined, custom: undefined };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudRun !== undefined) {
      CloudRunMetadata.encode(message.cloudRun, writer.uint32(10).fork()).join();
    }
    if (message.automation !== undefined) {
      AutomationRolloutMetadata.encode(message.automation, writer.uint32(18).fork()).join();
    }
    if (message.custom !== undefined) {
      CustomMetadata.encode(message.custom, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudRun = CloudRunMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.automation = AutomationRolloutMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custom = CustomMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      cloudRun: isSet(object.cloudRun) ? CloudRunMetadata.fromJSON(object.cloudRun) : undefined,
      automation: isSet(object.automation) ? AutomationRolloutMetadata.fromJSON(object.automation) : undefined,
      custom: isSet(object.custom) ? CustomMetadata.fromJSON(object.custom) : undefined,
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRunMetadata.toJSON(message.cloudRun);
    }
    if (message.automation !== undefined) {
      obj.automation = AutomationRolloutMetadata.toJSON(message.automation);
    }
    if (message.custom !== undefined) {
      obj.custom = CustomMetadata.toJSON(message.custom);
    }
    return obj;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRunMetadata.fromPartial(object.cloudRun)
      : undefined;
    message.automation = (object.automation !== undefined && object.automation !== null)
      ? AutomationRolloutMetadata.fromPartial(object.automation)
      : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? CustomMetadata.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseDeployJobRunMetadata(): DeployJobRunMetadata {
  return { cloudRun: undefined, customTarget: undefined, custom: undefined };
}

export const DeployJobRunMetadata: MessageFns<DeployJobRunMetadata> = {
  encode(message: DeployJobRunMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudRun !== undefined) {
      CloudRunMetadata.encode(message.cloudRun, writer.uint32(10).fork()).join();
    }
    if (message.customTarget !== undefined) {
      CustomTargetDeployMetadata.encode(message.customTarget, writer.uint32(18).fork()).join();
    }
    if (message.custom !== undefined) {
      CustomMetadata.encode(message.custom, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployJobRunMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployJobRunMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudRun = CloudRunMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customTarget = CustomTargetDeployMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.custom = CustomMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployJobRunMetadata {
    return {
      cloudRun: isSet(object.cloudRun) ? CloudRunMetadata.fromJSON(object.cloudRun) : undefined,
      customTarget: isSet(object.customTarget) ? CustomTargetDeployMetadata.fromJSON(object.customTarget) : undefined,
      custom: isSet(object.custom) ? CustomMetadata.fromJSON(object.custom) : undefined,
    };
  },

  toJSON(message: DeployJobRunMetadata): unknown {
    const obj: any = {};
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRunMetadata.toJSON(message.cloudRun);
    }
    if (message.customTarget !== undefined) {
      obj.customTarget = CustomTargetDeployMetadata.toJSON(message.customTarget);
    }
    if (message.custom !== undefined) {
      obj.custom = CustomMetadata.toJSON(message.custom);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployJobRunMetadata>): DeployJobRunMetadata {
    return DeployJobRunMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployJobRunMetadata>): DeployJobRunMetadata {
    const message = createBaseDeployJobRunMetadata();
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRunMetadata.fromPartial(object.cloudRun)
      : undefined;
    message.customTarget = (object.customTarget !== undefined && object.customTarget !== null)
      ? CustomTargetDeployMetadata.fromPartial(object.customTarget)
      : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? CustomMetadata.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseCloudRunMetadata(): CloudRunMetadata {
  return { service: "", serviceUrls: [], revision: "", job: "" };
}

export const CloudRunMetadata: MessageFns<CloudRunMetadata> = {
  encode(message: CloudRunMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    for (const v of message.serviceUrls) {
      writer.uint32(18).string(v!);
    }
    if (message.revision !== "") {
      writer.uint32(26).string(message.revision);
    }
    if (message.job !== "") {
      writer.uint32(34).string(message.job);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceUrls.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.revision = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.job = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunMetadata {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      serviceUrls: globalThis.Array.isArray(object?.serviceUrls)
        ? object.serviceUrls.map((e: any) => globalThis.String(e))
        : [],
      revision: isSet(object.revision) ? globalThis.String(object.revision) : "",
      job: isSet(object.job) ? globalThis.String(object.job) : "",
    };
  },

  toJSON(message: CloudRunMetadata): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.serviceUrls?.length) {
      obj.serviceUrls = message.serviceUrls;
    }
    if (message.revision !== "") {
      obj.revision = message.revision;
    }
    if (message.job !== "") {
      obj.job = message.job;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunMetadata>): CloudRunMetadata {
    return CloudRunMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunMetadata>): CloudRunMetadata {
    const message = createBaseCloudRunMetadata();
    message.service = object.service ?? "";
    message.serviceUrls = object.serviceUrls?.map((e) => e) || [];
    message.revision = object.revision ?? "";
    message.job = object.job ?? "";
    return message;
  },
};

function createBaseCustomTargetDeployMetadata(): CustomTargetDeployMetadata {
  return { skipMessage: "" };
}

export const CustomTargetDeployMetadata: MessageFns<CustomTargetDeployMetadata> = {
  encode(message: CustomTargetDeployMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skipMessage !== "") {
      writer.uint32(10).string(message.skipMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomTargetDeployMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomTargetDeployMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skipMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomTargetDeployMetadata {
    return { skipMessage: isSet(object.skipMessage) ? globalThis.String(object.skipMessage) : "" };
  },

  toJSON(message: CustomTargetDeployMetadata): unknown {
    const obj: any = {};
    if (message.skipMessage !== "") {
      obj.skipMessage = message.skipMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomTargetDeployMetadata>): CustomTargetDeployMetadata {
    return CustomTargetDeployMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomTargetDeployMetadata>): CustomTargetDeployMetadata {
    const message = createBaseCustomTargetDeployMetadata();
    message.skipMessage = object.skipMessage ?? "";
    return message;
  },
};

function createBaseAutomationRolloutMetadata(): AutomationRolloutMetadata {
  return { promoteAutomationRun: "", advanceAutomationRuns: [], repairAutomationRuns: [] };
}

export const AutomationRolloutMetadata: MessageFns<AutomationRolloutMetadata> = {
  encode(message: AutomationRolloutMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.promoteAutomationRun !== "") {
      writer.uint32(10).string(message.promoteAutomationRun);
    }
    for (const v of message.advanceAutomationRuns) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.repairAutomationRuns) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomationRolloutMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomationRolloutMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.promoteAutomationRun = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.advanceAutomationRuns.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repairAutomationRuns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomationRolloutMetadata {
    return {
      promoteAutomationRun: isSet(object.promoteAutomationRun) ? globalThis.String(object.promoteAutomationRun) : "",
      advanceAutomationRuns: globalThis.Array.isArray(object?.advanceAutomationRuns)
        ? object.advanceAutomationRuns.map((e: any) => globalThis.String(e))
        : [],
      repairAutomationRuns: globalThis.Array.isArray(object?.repairAutomationRuns)
        ? object.repairAutomationRuns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AutomationRolloutMetadata): unknown {
    const obj: any = {};
    if (message.promoteAutomationRun !== "") {
      obj.promoteAutomationRun = message.promoteAutomationRun;
    }
    if (message.advanceAutomationRuns?.length) {
      obj.advanceAutomationRuns = message.advanceAutomationRuns;
    }
    if (message.repairAutomationRuns?.length) {
      obj.repairAutomationRuns = message.repairAutomationRuns;
    }
    return obj;
  },

  create(base?: DeepPartial<AutomationRolloutMetadata>): AutomationRolloutMetadata {
    return AutomationRolloutMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomationRolloutMetadata>): AutomationRolloutMetadata {
    const message = createBaseAutomationRolloutMetadata();
    message.promoteAutomationRun = object.promoteAutomationRun ?? "";
    message.advanceAutomationRuns = object.advanceAutomationRuns?.map((e) => e) || [];
    message.repairAutomationRuns = object.repairAutomationRuns?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomMetadata(): CustomMetadata {
  return { values: {} };
}

export const CustomMetadata: MessageFns<CustomMetadata> = {
  encode(message: CustomMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.values).forEach(([key, value]) => {
      CustomMetadata_ValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = CustomMetadata_ValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomMetadata {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CustomMetadata): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CustomMetadata>): CustomMetadata {
    return CustomMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomMetadata>): CustomMetadata {
    const message = createBaseCustomMetadata();
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCustomMetadata_ValuesEntry(): CustomMetadata_ValuesEntry {
  return { key: "", value: "" };
}

export const CustomMetadata_ValuesEntry: MessageFns<CustomMetadata_ValuesEntry> = {
  encode(message: CustomMetadata_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomMetadata_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomMetadata_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomMetadata_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CustomMetadata_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomMetadata_ValuesEntry>): CustomMetadata_ValuesEntry {
    return CustomMetadata_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomMetadata_ValuesEntry>): CustomMetadata_ValuesEntry {
    const message = createBaseCustomMetadata_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePhase(): Phase {
  return { id: "", state: 0, skipMessage: "", deploymentJobs: undefined, childRolloutJobs: undefined };
}

export const Phase: MessageFns<Phase> = {
  encode(message: Phase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.skipMessage !== "") {
      writer.uint32(50).string(message.skipMessage);
    }
    if (message.deploymentJobs !== undefined) {
      DeploymentJobs.encode(message.deploymentJobs, writer.uint32(34).fork()).join();
    }
    if (message.childRolloutJobs !== undefined) {
      ChildRolloutJobs.encode(message.childRolloutJobs, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Phase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skipMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deploymentJobs = DeploymentJobs.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.childRolloutJobs = ChildRolloutJobs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Phase {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      state: isSet(object.state) ? phase_StateFromJSON(object.state) : 0,
      skipMessage: isSet(object.skipMessage) ? globalThis.String(object.skipMessage) : "",
      deploymentJobs: isSet(object.deploymentJobs) ? DeploymentJobs.fromJSON(object.deploymentJobs) : undefined,
      childRolloutJobs: isSet(object.childRolloutJobs) ? ChildRolloutJobs.fromJSON(object.childRolloutJobs) : undefined,
    };
  },

  toJSON(message: Phase): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== 0) {
      obj.state = phase_StateToJSON(message.state);
    }
    if (message.skipMessage !== "") {
      obj.skipMessage = message.skipMessage;
    }
    if (message.deploymentJobs !== undefined) {
      obj.deploymentJobs = DeploymentJobs.toJSON(message.deploymentJobs);
    }
    if (message.childRolloutJobs !== undefined) {
      obj.childRolloutJobs = ChildRolloutJobs.toJSON(message.childRolloutJobs);
    }
    return obj;
  },

  create(base?: DeepPartial<Phase>): Phase {
    return Phase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Phase>): Phase {
    const message = createBasePhase();
    message.id = object.id ?? "";
    message.state = object.state ?? 0;
    message.skipMessage = object.skipMessage ?? "";
    message.deploymentJobs = (object.deploymentJobs !== undefined && object.deploymentJobs !== null)
      ? DeploymentJobs.fromPartial(object.deploymentJobs)
      : undefined;
    message.childRolloutJobs = (object.childRolloutJobs !== undefined && object.childRolloutJobs !== null)
      ? ChildRolloutJobs.fromPartial(object.childRolloutJobs)
      : undefined;
    return message;
  },
};

function createBaseDeploymentJobs(): DeploymentJobs {
  return { deployJob: undefined, verifyJob: undefined, predeployJob: undefined, postdeployJob: undefined };
}

export const DeploymentJobs: MessageFns<DeploymentJobs> = {
  encode(message: DeploymentJobs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployJob !== undefined) {
      Job.encode(message.deployJob, writer.uint32(10).fork()).join();
    }
    if (message.verifyJob !== undefined) {
      Job.encode(message.verifyJob, writer.uint32(18).fork()).join();
    }
    if (message.predeployJob !== undefined) {
      Job.encode(message.predeployJob, writer.uint32(26).fork()).join();
    }
    if (message.postdeployJob !== undefined) {
      Job.encode(message.postdeployJob, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeploymentJobs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeploymentJobs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployJob = Job.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verifyJob = Job.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.predeployJob = Job.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postdeployJob = Job.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeploymentJobs {
    return {
      deployJob: isSet(object.deployJob) ? Job.fromJSON(object.deployJob) : undefined,
      verifyJob: isSet(object.verifyJob) ? Job.fromJSON(object.verifyJob) : undefined,
      predeployJob: isSet(object.predeployJob) ? Job.fromJSON(object.predeployJob) : undefined,
      postdeployJob: isSet(object.postdeployJob) ? Job.fromJSON(object.postdeployJob) : undefined,
    };
  },

  toJSON(message: DeploymentJobs): unknown {
    const obj: any = {};
    if (message.deployJob !== undefined) {
      obj.deployJob = Job.toJSON(message.deployJob);
    }
    if (message.verifyJob !== undefined) {
      obj.verifyJob = Job.toJSON(message.verifyJob);
    }
    if (message.predeployJob !== undefined) {
      obj.predeployJob = Job.toJSON(message.predeployJob);
    }
    if (message.postdeployJob !== undefined) {
      obj.postdeployJob = Job.toJSON(message.postdeployJob);
    }
    return obj;
  },

  create(base?: DeepPartial<DeploymentJobs>): DeploymentJobs {
    return DeploymentJobs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeploymentJobs>): DeploymentJobs {
    const message = createBaseDeploymentJobs();
    message.deployJob = (object.deployJob !== undefined && object.deployJob !== null)
      ? Job.fromPartial(object.deployJob)
      : undefined;
    message.verifyJob = (object.verifyJob !== undefined && object.verifyJob !== null)
      ? Job.fromPartial(object.verifyJob)
      : undefined;
    message.predeployJob = (object.predeployJob !== undefined && object.predeployJob !== null)
      ? Job.fromPartial(object.predeployJob)
      : undefined;
    message.postdeployJob = (object.postdeployJob !== undefined && object.postdeployJob !== null)
      ? Job.fromPartial(object.postdeployJob)
      : undefined;
    return message;
  },
};

function createBaseChildRolloutJobs(): ChildRolloutJobs {
  return { createRolloutJobs: [], advanceRolloutJobs: [] };
}

export const ChildRolloutJobs: MessageFns<ChildRolloutJobs> = {
  encode(message: ChildRolloutJobs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.createRolloutJobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.advanceRolloutJobs) {
      Job.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChildRolloutJobs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChildRolloutJobs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createRolloutJobs.push(Job.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.advanceRolloutJobs.push(Job.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChildRolloutJobs {
    return {
      createRolloutJobs: globalThis.Array.isArray(object?.createRolloutJobs)
        ? object.createRolloutJobs.map((e: any) => Job.fromJSON(e))
        : [],
      advanceRolloutJobs: globalThis.Array.isArray(object?.advanceRolloutJobs)
        ? object.advanceRolloutJobs.map((e: any) => Job.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ChildRolloutJobs): unknown {
    const obj: any = {};
    if (message.createRolloutJobs?.length) {
      obj.createRolloutJobs = message.createRolloutJobs.map((e) => Job.toJSON(e));
    }
    if (message.advanceRolloutJobs?.length) {
      obj.advanceRolloutJobs = message.advanceRolloutJobs.map((e) => Job.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChildRolloutJobs>): ChildRolloutJobs {
    return ChildRolloutJobs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChildRolloutJobs>): ChildRolloutJobs {
    const message = createBaseChildRolloutJobs();
    message.createRolloutJobs = object.createRolloutJobs?.map((e) => Job.fromPartial(e)) || [];
    message.advanceRolloutJobs = object.advanceRolloutJobs?.map((e) => Job.fromPartial(e)) || [];
    return message;
  },
};

function createBaseJob(): Job {
  return {
    id: "",
    state: 0,
    skipMessage: "",
    jobRun: "",
    deployJob: undefined,
    verifyJob: undefined,
    predeployJob: undefined,
    postdeployJob: undefined,
    createChildRolloutJob: undefined,
    advanceChildRolloutJob: undefined,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.skipMessage !== "") {
      writer.uint32(66).string(message.skipMessage);
    }
    if (message.jobRun !== "") {
      writer.uint32(26).string(message.jobRun);
    }
    if (message.deployJob !== undefined) {
      DeployJob.encode(message.deployJob, writer.uint32(34).fork()).join();
    }
    if (message.verifyJob !== undefined) {
      VerifyJob.encode(message.verifyJob, writer.uint32(42).fork()).join();
    }
    if (message.predeployJob !== undefined) {
      PredeployJob.encode(message.predeployJob, writer.uint32(74).fork()).join();
    }
    if (message.postdeployJob !== undefined) {
      PostdeployJob.encode(message.postdeployJob, writer.uint32(82).fork()).join();
    }
    if (message.createChildRolloutJob !== undefined) {
      CreateChildRolloutJob.encode(message.createChildRolloutJob, writer.uint32(50).fork()).join();
    }
    if (message.advanceChildRolloutJob !== undefined) {
      AdvanceChildRolloutJob.encode(message.advanceChildRolloutJob, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.skipMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jobRun = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deployJob = DeployJob.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.verifyJob = VerifyJob.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.predeployJob = PredeployJob.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.postdeployJob = PostdeployJob.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createChildRolloutJob = CreateChildRolloutJob.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.advanceChildRolloutJob = AdvanceChildRolloutJob.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      state: isSet(object.state) ? job_StateFromJSON(object.state) : 0,
      skipMessage: isSet(object.skipMessage) ? globalThis.String(object.skipMessage) : "",
      jobRun: isSet(object.jobRun) ? globalThis.String(object.jobRun) : "",
      deployJob: isSet(object.deployJob) ? DeployJob.fromJSON(object.deployJob) : undefined,
      verifyJob: isSet(object.verifyJob) ? VerifyJob.fromJSON(object.verifyJob) : undefined,
      predeployJob: isSet(object.predeployJob) ? PredeployJob.fromJSON(object.predeployJob) : undefined,
      postdeployJob: isSet(object.postdeployJob) ? PostdeployJob.fromJSON(object.postdeployJob) : undefined,
      createChildRolloutJob: isSet(object.createChildRolloutJob)
        ? CreateChildRolloutJob.fromJSON(object.createChildRolloutJob)
        : undefined,
      advanceChildRolloutJob: isSet(object.advanceChildRolloutJob)
        ? AdvanceChildRolloutJob.fromJSON(object.advanceChildRolloutJob)
        : undefined,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.state !== 0) {
      obj.state = job_StateToJSON(message.state);
    }
    if (message.skipMessage !== "") {
      obj.skipMessage = message.skipMessage;
    }
    if (message.jobRun !== "") {
      obj.jobRun = message.jobRun;
    }
    if (message.deployJob !== undefined) {
      obj.deployJob = DeployJob.toJSON(message.deployJob);
    }
    if (message.verifyJob !== undefined) {
      obj.verifyJob = VerifyJob.toJSON(message.verifyJob);
    }
    if (message.predeployJob !== undefined) {
      obj.predeployJob = PredeployJob.toJSON(message.predeployJob);
    }
    if (message.postdeployJob !== undefined) {
      obj.postdeployJob = PostdeployJob.toJSON(message.postdeployJob);
    }
    if (message.createChildRolloutJob !== undefined) {
      obj.createChildRolloutJob = CreateChildRolloutJob.toJSON(message.createChildRolloutJob);
    }
    if (message.advanceChildRolloutJob !== undefined) {
      obj.advanceChildRolloutJob = AdvanceChildRolloutJob.toJSON(message.advanceChildRolloutJob);
    }
    return obj;
  },

  create(base?: DeepPartial<Job>): Job {
    return Job.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job>): Job {
    const message = createBaseJob();
    message.id = object.id ?? "";
    message.state = object.state ?? 0;
    message.skipMessage = object.skipMessage ?? "";
    message.jobRun = object.jobRun ?? "";
    message.deployJob = (object.deployJob !== undefined && object.deployJob !== null)
      ? DeployJob.fromPartial(object.deployJob)
      : undefined;
    message.verifyJob = (object.verifyJob !== undefined && object.verifyJob !== null)
      ? VerifyJob.fromPartial(object.verifyJob)
      : undefined;
    message.predeployJob = (object.predeployJob !== undefined && object.predeployJob !== null)
      ? PredeployJob.fromPartial(object.predeployJob)
      : undefined;
    message.postdeployJob = (object.postdeployJob !== undefined && object.postdeployJob !== null)
      ? PostdeployJob.fromPartial(object.postdeployJob)
      : undefined;
    message.createChildRolloutJob =
      (object.createChildRolloutJob !== undefined && object.createChildRolloutJob !== null)
        ? CreateChildRolloutJob.fromPartial(object.createChildRolloutJob)
        : undefined;
    message.advanceChildRolloutJob =
      (object.advanceChildRolloutJob !== undefined && object.advanceChildRolloutJob !== null)
        ? AdvanceChildRolloutJob.fromPartial(object.advanceChildRolloutJob)
        : undefined;
    return message;
  },
};

function createBaseDeployJob(): DeployJob {
  return {};
}

export const DeployJob: MessageFns<DeployJob> = {
  encode(_: DeployJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeployJob {
    return {};
  },

  toJSON(_: DeployJob): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeployJob>): DeployJob {
    return DeployJob.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeployJob>): DeployJob {
    const message = createBaseDeployJob();
    return message;
  },
};

function createBaseVerifyJob(): VerifyJob {
  return {};
}

export const VerifyJob: MessageFns<VerifyJob> = {
  encode(_: VerifyJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VerifyJob {
    return {};
  },

  toJSON(_: VerifyJob): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<VerifyJob>): VerifyJob {
    return VerifyJob.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<VerifyJob>): VerifyJob {
    const message = createBaseVerifyJob();
    return message;
  },
};

function createBasePredeployJob(): PredeployJob {
  return { actions: [] };
}

export const PredeployJob: MessageFns<PredeployJob> = {
  encode(message: PredeployJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredeployJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredeployJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredeployJob {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PredeployJob): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },

  create(base?: DeepPartial<PredeployJob>): PredeployJob {
    return PredeployJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PredeployJob>): PredeployJob {
    const message = createBasePredeployJob();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBasePostdeployJob(): PostdeployJob {
  return { actions: [] };
}

export const PostdeployJob: MessageFns<PostdeployJob> = {
  encode(message: PostdeployJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostdeployJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostdeployJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostdeployJob {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PostdeployJob): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },

  create(base?: DeepPartial<PostdeployJob>): PostdeployJob {
    return PostdeployJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostdeployJob>): PostdeployJob {
    const message = createBasePostdeployJob();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateChildRolloutJob(): CreateChildRolloutJob {
  return {};
}

export const CreateChildRolloutJob: MessageFns<CreateChildRolloutJob> = {
  encode(_: CreateChildRolloutJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChildRolloutJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChildRolloutJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateChildRolloutJob {
    return {};
  },

  toJSON(_: CreateChildRolloutJob): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateChildRolloutJob>): CreateChildRolloutJob {
    return CreateChildRolloutJob.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateChildRolloutJob>): CreateChildRolloutJob {
    const message = createBaseCreateChildRolloutJob();
    return message;
  },
};

function createBaseAdvanceChildRolloutJob(): AdvanceChildRolloutJob {
  return {};
}

export const AdvanceChildRolloutJob: MessageFns<AdvanceChildRolloutJob> = {
  encode(_: AdvanceChildRolloutJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceChildRolloutJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceChildRolloutJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AdvanceChildRolloutJob {
    return {};
  },

  toJSON(_: AdvanceChildRolloutJob): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AdvanceChildRolloutJob>): AdvanceChildRolloutJob {
    return AdvanceChildRolloutJob.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AdvanceChildRolloutJob>): AdvanceChildRolloutJob {
    const message = createBaseAdvanceChildRolloutJob();
    return message;
  },
};

function createBaseListRolloutsRequest(): ListRolloutsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListRolloutsRequest: MessageFns<ListRolloutsRequest> = {
  encode(message: ListRolloutsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolloutsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolloutsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolloutsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListRolloutsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolloutsRequest>): ListRolloutsRequest {
    return ListRolloutsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolloutsRequest>): ListRolloutsRequest {
    const message = createBaseListRolloutsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListRolloutsResponse(): ListRolloutsResponse {
  return { rollouts: [], nextPageToken: "", unreachable: [] };
}

export const ListRolloutsResponse: MessageFns<ListRolloutsResponse> = {
  encode(message: ListRolloutsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rollouts) {
      Rollout.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolloutsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolloutsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollouts.push(Rollout.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolloutsResponse {
    return {
      rollouts: globalThis.Array.isArray(object?.rollouts) ? object.rollouts.map((e: any) => Rollout.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRolloutsResponse): unknown {
    const obj: any = {};
    if (message.rollouts?.length) {
      obj.rollouts = message.rollouts.map((e) => Rollout.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRolloutsResponse>): ListRolloutsResponse {
    return ListRolloutsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRolloutsResponse>): ListRolloutsResponse {
    const message = createBaseListRolloutsResponse();
    message.rollouts = object.rollouts?.map((e) => Rollout.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRolloutRequest(): GetRolloutRequest {
  return { name: "" };
}

export const GetRolloutRequest: MessageFns<GetRolloutRequest> = {
  encode(message: GetRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRolloutRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRolloutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRolloutRequest>): GetRolloutRequest {
    return GetRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRolloutRequest>): GetRolloutRequest {
    const message = createBaseGetRolloutRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateRolloutRequest(): CreateRolloutRequest {
  return {
    parent: "",
    rolloutId: "",
    rollout: undefined,
    requestId: "",
    validateOnly: false,
    overrideDeployPolicy: [],
    startingPhaseId: "",
  };
}

export const CreateRolloutRequest: MessageFns<CreateRolloutRequest> = {
  encode(message: CreateRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.rolloutId !== "") {
      writer.uint32(18).string(message.rolloutId);
    }
    if (message.rollout !== undefined) {
      Rollout.encode(message.rollout, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(50).string(v!);
    }
    if (message.startingPhaseId !== "") {
      writer.uint32(58).string(message.startingPhaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rolloutId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rollout = Rollout.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startingPhaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRolloutRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      rolloutId: isSet(object.rolloutId) ? globalThis.String(object.rolloutId) : "",
      rollout: isSet(object.rollout) ? Rollout.fromJSON(object.rollout) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
      startingPhaseId: isSet(object.startingPhaseId) ? globalThis.String(object.startingPhaseId) : "",
    };
  },

  toJSON(message: CreateRolloutRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.rolloutId !== "") {
      obj.rolloutId = message.rolloutId;
    }
    if (message.rollout !== undefined) {
      obj.rollout = Rollout.toJSON(message.rollout);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    if (message.startingPhaseId !== "") {
      obj.startingPhaseId = message.startingPhaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRolloutRequest>): CreateRolloutRequest {
    return CreateRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRolloutRequest>): CreateRolloutRequest {
    const message = createBaseCreateRolloutRequest();
    message.parent = object.parent ?? "";
    message.rolloutId = object.rolloutId ?? "";
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? Rollout.fromPartial(object.rollout)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    message.startingPhaseId = object.startingPhaseId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseApproveRolloutRequest(): ApproveRolloutRequest {
  return { name: "", approved: false, overrideDeployPolicy: [] };
}

export const ApproveRolloutRequest: MessageFns<ApproveRolloutRequest> = {
  encode(message: ApproveRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.approved !== false) {
      writer.uint32(16).bool(message.approved);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApproveRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.approved = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveRolloutRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      approved: isSet(object.approved) ? globalThis.Boolean(object.approved) : false,
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ApproveRolloutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.approved !== false) {
      obj.approved = message.approved;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveRolloutRequest>): ApproveRolloutRequest {
    return ApproveRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveRolloutRequest>): ApproveRolloutRequest {
    const message = createBaseApproveRolloutRequest();
    message.name = object.name ?? "";
    message.approved = object.approved ?? false;
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseApproveRolloutResponse(): ApproveRolloutResponse {
  return {};
}

export const ApproveRolloutResponse: MessageFns<ApproveRolloutResponse> = {
  encode(_: ApproveRolloutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApproveRolloutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveRolloutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ApproveRolloutResponse {
    return {};
  },

  toJSON(_: ApproveRolloutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ApproveRolloutResponse>): ApproveRolloutResponse {
    return ApproveRolloutResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ApproveRolloutResponse>): ApproveRolloutResponse {
    const message = createBaseApproveRolloutResponse();
    return message;
  },
};

function createBaseAdvanceRolloutRequest(): AdvanceRolloutRequest {
  return { name: "", phaseId: "", overrideDeployPolicy: [] };
}

export const AdvanceRolloutRequest: MessageFns<AdvanceRolloutRequest> = {
  encode(message: AdvanceRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.phaseId !== "") {
      writer.uint32(18).string(message.phaseId);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceRolloutRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AdvanceRolloutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvanceRolloutRequest>): AdvanceRolloutRequest {
    return AdvanceRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvanceRolloutRequest>): AdvanceRolloutRequest {
    const message = createBaseAdvanceRolloutRequest();
    message.name = object.name ?? "";
    message.phaseId = object.phaseId ?? "";
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseAdvanceRolloutResponse(): AdvanceRolloutResponse {
  return {};
}

export const AdvanceRolloutResponse: MessageFns<AdvanceRolloutResponse> = {
  encode(_: AdvanceRolloutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceRolloutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceRolloutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AdvanceRolloutResponse {
    return {};
  },

  toJSON(_: AdvanceRolloutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AdvanceRolloutResponse>): AdvanceRolloutResponse {
    return AdvanceRolloutResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AdvanceRolloutResponse>): AdvanceRolloutResponse {
    const message = createBaseAdvanceRolloutResponse();
    return message;
  },
};

function createBaseCancelRolloutRequest(): CancelRolloutRequest {
  return { name: "", overrideDeployPolicy: [] };
}

export const CancelRolloutRequest: MessageFns<CancelRolloutRequest> = {
  encode(message: CancelRolloutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRolloutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRolloutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelRolloutRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CancelRolloutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelRolloutRequest>): CancelRolloutRequest {
    return CancelRolloutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelRolloutRequest>): CancelRolloutRequest {
    const message = createBaseCancelRolloutRequest();
    message.name = object.name ?? "";
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseCancelRolloutResponse(): CancelRolloutResponse {
  return {};
}

export const CancelRolloutResponse: MessageFns<CancelRolloutResponse> = {
  encode(_: CancelRolloutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelRolloutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelRolloutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelRolloutResponse {
    return {};
  },

  toJSON(_: CancelRolloutResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelRolloutResponse>): CancelRolloutResponse {
    return CancelRolloutResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelRolloutResponse>): CancelRolloutResponse {
    const message = createBaseCancelRolloutResponse();
    return message;
  },
};

function createBaseIgnoreJobRequest(): IgnoreJobRequest {
  return { rollout: "", phaseId: "", jobId: "", overrideDeployPolicy: [] };
}

export const IgnoreJobRequest: MessageFns<IgnoreJobRequest> = {
  encode(message: IgnoreJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== "") {
      writer.uint32(10).string(message.rollout);
    }
    if (message.phaseId !== "") {
      writer.uint32(18).string(message.phaseId);
    }
    if (message.jobId !== "") {
      writer.uint32(26).string(message.jobId);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IgnoreJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIgnoreJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jobId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IgnoreJobRequest {
    return {
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: IgnoreJobRequest): unknown {
    const obj: any = {};
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<IgnoreJobRequest>): IgnoreJobRequest {
    return IgnoreJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IgnoreJobRequest>): IgnoreJobRequest {
    const message = createBaseIgnoreJobRequest();
    message.rollout = object.rollout ?? "";
    message.phaseId = object.phaseId ?? "";
    message.jobId = object.jobId ?? "";
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseIgnoreJobResponse(): IgnoreJobResponse {
  return {};
}

export const IgnoreJobResponse: MessageFns<IgnoreJobResponse> = {
  encode(_: IgnoreJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IgnoreJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIgnoreJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IgnoreJobResponse {
    return {};
  },

  toJSON(_: IgnoreJobResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<IgnoreJobResponse>): IgnoreJobResponse {
    return IgnoreJobResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<IgnoreJobResponse>): IgnoreJobResponse {
    const message = createBaseIgnoreJobResponse();
    return message;
  },
};

function createBaseRetryJobRequest(): RetryJobRequest {
  return { rollout: "", phaseId: "", jobId: "", overrideDeployPolicy: [] };
}

export const RetryJobRequest: MessageFns<RetryJobRequest> = {
  encode(message: RetryJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== "") {
      writer.uint32(10).string(message.rollout);
    }
    if (message.phaseId !== "") {
      writer.uint32(18).string(message.phaseId);
    }
    if (message.jobId !== "") {
      writer.uint32(26).string(message.jobId);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jobId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryJobRequest {
    return {
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RetryJobRequest): unknown {
    const obj: any = {};
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<RetryJobRequest>): RetryJobRequest {
    return RetryJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryJobRequest>): RetryJobRequest {
    const message = createBaseRetryJobRequest();
    message.rollout = object.rollout ?? "";
    message.phaseId = object.phaseId ?? "";
    message.jobId = object.jobId ?? "";
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseRetryJobResponse(): RetryJobResponse {
  return {};
}

export const RetryJobResponse: MessageFns<RetryJobResponse> = {
  encode(_: RetryJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RetryJobResponse {
    return {};
  },

  toJSON(_: RetryJobResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RetryJobResponse>): RetryJobResponse {
    return RetryJobResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RetryJobResponse>): RetryJobResponse {
    const message = createBaseRetryJobResponse();
    return message;
  },
};

function createBaseAbandonReleaseRequest(): AbandonReleaseRequest {
  return { name: "" };
}

export const AbandonReleaseRequest: MessageFns<AbandonReleaseRequest> = {
  encode(message: AbandonReleaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbandonReleaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbandonReleaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbandonReleaseRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: AbandonReleaseRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<AbandonReleaseRequest>): AbandonReleaseRequest {
    return AbandonReleaseRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AbandonReleaseRequest>): AbandonReleaseRequest {
    const message = createBaseAbandonReleaseRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAbandonReleaseResponse(): AbandonReleaseResponse {
  return {};
}

export const AbandonReleaseResponse: MessageFns<AbandonReleaseResponse> = {
  encode(_: AbandonReleaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbandonReleaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbandonReleaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AbandonReleaseResponse {
    return {};
  },

  toJSON(_: AbandonReleaseResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AbandonReleaseResponse>): AbandonReleaseResponse {
    return AbandonReleaseResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AbandonReleaseResponse>): AbandonReleaseResponse {
    const message = createBaseAbandonReleaseResponse();
    return message;
  },
};

function createBaseJobRun(): JobRun {
  return {
    name: "",
    uid: "",
    phaseId: "",
    jobId: "",
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    state: 0,
    deployJobRun: undefined,
    verifyJobRun: undefined,
    predeployJobRun: undefined,
    postdeployJobRun: undefined,
    createChildRolloutJobRun: undefined,
    advanceChildRolloutJobRun: undefined,
    etag: "",
  };
}

export const JobRun: MessageFns<JobRun> = {
  encode(message: JobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.phaseId !== "") {
      writer.uint32(26).string(message.phaseId);
    }
    if (message.jobId !== "") {
      writer.uint32(34).string(message.jobId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.deployJobRun !== undefined) {
      DeployJobRun.encode(message.deployJobRun, writer.uint32(74).fork()).join();
    }
    if (message.verifyJobRun !== undefined) {
      VerifyJobRun.encode(message.verifyJobRun, writer.uint32(82).fork()).join();
    }
    if (message.predeployJobRun !== undefined) {
      PredeployJobRun.encode(message.predeployJobRun, writer.uint32(114).fork()).join();
    }
    if (message.postdeployJobRun !== undefined) {
      PostdeployJobRun.encode(message.postdeployJobRun, writer.uint32(122).fork()).join();
    }
    if (message.createChildRolloutJobRun !== undefined) {
      CreateChildRolloutJobRun.encode(message.createChildRolloutJobRun, writer.uint32(98).fork()).join();
    }
    if (message.advanceChildRolloutJobRun !== undefined) {
      AdvanceChildRolloutJobRun.encode(message.advanceChildRolloutJobRun, writer.uint32(106).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(90).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jobId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.deployJobRun = DeployJobRun.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.verifyJobRun = VerifyJobRun.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.predeployJobRun = PredeployJobRun.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.postdeployJobRun = PostdeployJobRun.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createChildRolloutJobRun = CreateChildRolloutJobRun.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.advanceChildRolloutJobRun = AdvanceChildRolloutJobRun.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobRun {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      state: isSet(object.state) ? jobRun_StateFromJSON(object.state) : 0,
      deployJobRun: isSet(object.deployJobRun) ? DeployJobRun.fromJSON(object.deployJobRun) : undefined,
      verifyJobRun: isSet(object.verifyJobRun) ? VerifyJobRun.fromJSON(object.verifyJobRun) : undefined,
      predeployJobRun: isSet(object.predeployJobRun) ? PredeployJobRun.fromJSON(object.predeployJobRun) : undefined,
      postdeployJobRun: isSet(object.postdeployJobRun) ? PostdeployJobRun.fromJSON(object.postdeployJobRun) : undefined,
      createChildRolloutJobRun: isSet(object.createChildRolloutJobRun)
        ? CreateChildRolloutJobRun.fromJSON(object.createChildRolloutJobRun)
        : undefined,
      advanceChildRolloutJobRun: isSet(object.advanceChildRolloutJobRun)
        ? AdvanceChildRolloutJobRun.fromJSON(object.advanceChildRolloutJobRun)
        : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: JobRun): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = jobRun_StateToJSON(message.state);
    }
    if (message.deployJobRun !== undefined) {
      obj.deployJobRun = DeployJobRun.toJSON(message.deployJobRun);
    }
    if (message.verifyJobRun !== undefined) {
      obj.verifyJobRun = VerifyJobRun.toJSON(message.verifyJobRun);
    }
    if (message.predeployJobRun !== undefined) {
      obj.predeployJobRun = PredeployJobRun.toJSON(message.predeployJobRun);
    }
    if (message.postdeployJobRun !== undefined) {
      obj.postdeployJobRun = PostdeployJobRun.toJSON(message.postdeployJobRun);
    }
    if (message.createChildRolloutJobRun !== undefined) {
      obj.createChildRolloutJobRun = CreateChildRolloutJobRun.toJSON(message.createChildRolloutJobRun);
    }
    if (message.advanceChildRolloutJobRun !== undefined) {
      obj.advanceChildRolloutJobRun = AdvanceChildRolloutJobRun.toJSON(message.advanceChildRolloutJobRun);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<JobRun>): JobRun {
    return JobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobRun>): JobRun {
    const message = createBaseJobRun();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.phaseId = object.phaseId ?? "";
    message.jobId = object.jobId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.state = object.state ?? 0;
    message.deployJobRun = (object.deployJobRun !== undefined && object.deployJobRun !== null)
      ? DeployJobRun.fromPartial(object.deployJobRun)
      : undefined;
    message.verifyJobRun = (object.verifyJobRun !== undefined && object.verifyJobRun !== null)
      ? VerifyJobRun.fromPartial(object.verifyJobRun)
      : undefined;
    message.predeployJobRun = (object.predeployJobRun !== undefined && object.predeployJobRun !== null)
      ? PredeployJobRun.fromPartial(object.predeployJobRun)
      : undefined;
    message.postdeployJobRun = (object.postdeployJobRun !== undefined && object.postdeployJobRun !== null)
      ? PostdeployJobRun.fromPartial(object.postdeployJobRun)
      : undefined;
    message.createChildRolloutJobRun =
      (object.createChildRolloutJobRun !== undefined && object.createChildRolloutJobRun !== null)
        ? CreateChildRolloutJobRun.fromPartial(object.createChildRolloutJobRun)
        : undefined;
    message.advanceChildRolloutJobRun =
      (object.advanceChildRolloutJobRun !== undefined && object.advanceChildRolloutJobRun !== null)
        ? AdvanceChildRolloutJobRun.fromPartial(object.advanceChildRolloutJobRun)
        : undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseDeployJobRun(): DeployJobRun {
  return { build: "", failureCause: 0, failureMessage: "", metadata: undefined, artifact: undefined };
}

export const DeployJobRun: MessageFns<DeployJobRun> = {
  encode(message: DeployJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.build !== "") {
      writer.uint32(10).string(message.build);
    }
    if (message.failureCause !== 0) {
      writer.uint32(16).int32(message.failureCause);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    if (message.metadata !== undefined) {
      DeployJobRunMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.artifact !== undefined) {
      DeployArtifact.encode(message.artifact, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeployJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.build = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failureCause = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = DeployJobRunMetadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.artifact = DeployArtifact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeployJobRun {
    return {
      build: isSet(object.build) ? globalThis.String(object.build) : "",
      failureCause: isSet(object.failureCause) ? deployJobRun_FailureCauseFromJSON(object.failureCause) : 0,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
      metadata: isSet(object.metadata) ? DeployJobRunMetadata.fromJSON(object.metadata) : undefined,
      artifact: isSet(object.artifact) ? DeployArtifact.fromJSON(object.artifact) : undefined,
    };
  },

  toJSON(message: DeployJobRun): unknown {
    const obj: any = {};
    if (message.build !== "") {
      obj.build = message.build;
    }
    if (message.failureCause !== 0) {
      obj.failureCause = deployJobRun_FailureCauseToJSON(message.failureCause);
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    if (message.metadata !== undefined) {
      obj.metadata = DeployJobRunMetadata.toJSON(message.metadata);
    }
    if (message.artifact !== undefined) {
      obj.artifact = DeployArtifact.toJSON(message.artifact);
    }
    return obj;
  },

  create(base?: DeepPartial<DeployJobRun>): DeployJobRun {
    return DeployJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeployJobRun>): DeployJobRun {
    const message = createBaseDeployJobRun();
    message.build = object.build ?? "";
    message.failureCause = object.failureCause ?? 0;
    message.failureMessage = object.failureMessage ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? DeployJobRunMetadata.fromPartial(object.metadata)
      : undefined;
    message.artifact = (object.artifact !== undefined && object.artifact !== null)
      ? DeployArtifact.fromPartial(object.artifact)
      : undefined;
    return message;
  },
};

function createBaseVerifyJobRun(): VerifyJobRun {
  return { build: "", artifactUri: "", eventLogPath: "", failureCause: 0, failureMessage: "" };
}

export const VerifyJobRun: MessageFns<VerifyJobRun> = {
  encode(message: VerifyJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.build !== "") {
      writer.uint32(10).string(message.build);
    }
    if (message.artifactUri !== "") {
      writer.uint32(18).string(message.artifactUri);
    }
    if (message.eventLogPath !== "") {
      writer.uint32(26).string(message.eventLogPath);
    }
    if (message.failureCause !== 0) {
      writer.uint32(32).int32(message.failureCause);
    }
    if (message.failureMessage !== "") {
      writer.uint32(42).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.build = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.artifactUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventLogPath = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureCause = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyJobRun {
    return {
      build: isSet(object.build) ? globalThis.String(object.build) : "",
      artifactUri: isSet(object.artifactUri) ? globalThis.String(object.artifactUri) : "",
      eventLogPath: isSet(object.eventLogPath) ? globalThis.String(object.eventLogPath) : "",
      failureCause: isSet(object.failureCause) ? verifyJobRun_FailureCauseFromJSON(object.failureCause) : 0,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: VerifyJobRun): unknown {
    const obj: any = {};
    if (message.build !== "") {
      obj.build = message.build;
    }
    if (message.artifactUri !== "") {
      obj.artifactUri = message.artifactUri;
    }
    if (message.eventLogPath !== "") {
      obj.eventLogPath = message.eventLogPath;
    }
    if (message.failureCause !== 0) {
      obj.failureCause = verifyJobRun_FailureCauseToJSON(message.failureCause);
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<VerifyJobRun>): VerifyJobRun {
    return VerifyJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerifyJobRun>): VerifyJobRun {
    const message = createBaseVerifyJobRun();
    message.build = object.build ?? "";
    message.artifactUri = object.artifactUri ?? "";
    message.eventLogPath = object.eventLogPath ?? "";
    message.failureCause = object.failureCause ?? 0;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBasePredeployJobRun(): PredeployJobRun {
  return { build: "", failureCause: 0, failureMessage: "" };
}

export const PredeployJobRun: MessageFns<PredeployJobRun> = {
  encode(message: PredeployJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.build !== "") {
      writer.uint32(10).string(message.build);
    }
    if (message.failureCause !== 0) {
      writer.uint32(16).int32(message.failureCause);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredeployJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredeployJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.build = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failureCause = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredeployJobRun {
    return {
      build: isSet(object.build) ? globalThis.String(object.build) : "",
      failureCause: isSet(object.failureCause) ? predeployJobRun_FailureCauseFromJSON(object.failureCause) : 0,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: PredeployJobRun): unknown {
    const obj: any = {};
    if (message.build !== "") {
      obj.build = message.build;
    }
    if (message.failureCause !== 0) {
      obj.failureCause = predeployJobRun_FailureCauseToJSON(message.failureCause);
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<PredeployJobRun>): PredeployJobRun {
    return PredeployJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PredeployJobRun>): PredeployJobRun {
    const message = createBasePredeployJobRun();
    message.build = object.build ?? "";
    message.failureCause = object.failureCause ?? 0;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBasePostdeployJobRun(): PostdeployJobRun {
  return { build: "", failureCause: 0, failureMessage: "" };
}

export const PostdeployJobRun: MessageFns<PostdeployJobRun> = {
  encode(message: PostdeployJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.build !== "") {
      writer.uint32(10).string(message.build);
    }
    if (message.failureCause !== 0) {
      writer.uint32(16).int32(message.failureCause);
    }
    if (message.failureMessage !== "") {
      writer.uint32(26).string(message.failureMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostdeployJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostdeployJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.build = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failureCause = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failureMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostdeployJobRun {
    return {
      build: isSet(object.build) ? globalThis.String(object.build) : "",
      failureCause: isSet(object.failureCause) ? postdeployJobRun_FailureCauseFromJSON(object.failureCause) : 0,
      failureMessage: isSet(object.failureMessage) ? globalThis.String(object.failureMessage) : "",
    };
  },

  toJSON(message: PostdeployJobRun): unknown {
    const obj: any = {};
    if (message.build !== "") {
      obj.build = message.build;
    }
    if (message.failureCause !== 0) {
      obj.failureCause = postdeployJobRun_FailureCauseToJSON(message.failureCause);
    }
    if (message.failureMessage !== "") {
      obj.failureMessage = message.failureMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<PostdeployJobRun>): PostdeployJobRun {
    return PostdeployJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostdeployJobRun>): PostdeployJobRun {
    const message = createBasePostdeployJobRun();
    message.build = object.build ?? "";
    message.failureCause = object.failureCause ?? 0;
    message.failureMessage = object.failureMessage ?? "";
    return message;
  },
};

function createBaseCreateChildRolloutJobRun(): CreateChildRolloutJobRun {
  return { rollout: "", rolloutPhaseId: "" };
}

export const CreateChildRolloutJobRun: MessageFns<CreateChildRolloutJobRun> = {
  encode(message: CreateChildRolloutJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== "") {
      writer.uint32(10).string(message.rollout);
    }
    if (message.rolloutPhaseId !== "") {
      writer.uint32(18).string(message.rolloutPhaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChildRolloutJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChildRolloutJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rolloutPhaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChildRolloutJobRun {
    return {
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      rolloutPhaseId: isSet(object.rolloutPhaseId) ? globalThis.String(object.rolloutPhaseId) : "",
    };
  },

  toJSON(message: CreateChildRolloutJobRun): unknown {
    const obj: any = {};
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.rolloutPhaseId !== "") {
      obj.rolloutPhaseId = message.rolloutPhaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateChildRolloutJobRun>): CreateChildRolloutJobRun {
    return CreateChildRolloutJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateChildRolloutJobRun>): CreateChildRolloutJobRun {
    const message = createBaseCreateChildRolloutJobRun();
    message.rollout = object.rollout ?? "";
    message.rolloutPhaseId = object.rolloutPhaseId ?? "";
    return message;
  },
};

function createBaseAdvanceChildRolloutJobRun(): AdvanceChildRolloutJobRun {
  return { rollout: "", rolloutPhaseId: "" };
}

export const AdvanceChildRolloutJobRun: MessageFns<AdvanceChildRolloutJobRun> = {
  encode(message: AdvanceChildRolloutJobRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== "") {
      writer.uint32(10).string(message.rollout);
    }
    if (message.rolloutPhaseId !== "") {
      writer.uint32(18).string(message.rolloutPhaseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceChildRolloutJobRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceChildRolloutJobRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rolloutPhaseId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceChildRolloutJobRun {
    return {
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      rolloutPhaseId: isSet(object.rolloutPhaseId) ? globalThis.String(object.rolloutPhaseId) : "",
    };
  },

  toJSON(message: AdvanceChildRolloutJobRun): unknown {
    const obj: any = {};
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.rolloutPhaseId !== "") {
      obj.rolloutPhaseId = message.rolloutPhaseId;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvanceChildRolloutJobRun>): AdvanceChildRolloutJobRun {
    return AdvanceChildRolloutJobRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvanceChildRolloutJobRun>): AdvanceChildRolloutJobRun {
    const message = createBaseAdvanceChildRolloutJobRun();
    message.rollout = object.rollout ?? "";
    message.rolloutPhaseId = object.rolloutPhaseId ?? "";
    return message;
  },
};

function createBaseListJobRunsRequest(): ListJobRunsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListJobRunsRequest: MessageFns<ListJobRunsRequest> = {
  encode(message: ListJobRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobRunsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListJobRunsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobRunsRequest>): ListJobRunsRequest {
    return ListJobRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobRunsRequest>): ListJobRunsRequest {
    const message = createBaseListJobRunsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListJobRunsResponse(): ListJobRunsResponse {
  return { jobRuns: [], nextPageToken: "", unreachable: [] };
}

export const ListJobRunsResponse: MessageFns<ListJobRunsResponse> = {
  encode(message: ListJobRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobRuns) {
      JobRun.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobRuns.push(JobRun.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobRunsResponse {
    return {
      jobRuns: globalThis.Array.isArray(object?.jobRuns) ? object.jobRuns.map((e: any) => JobRun.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListJobRunsResponse): unknown {
    const obj: any = {};
    if (message.jobRuns?.length) {
      obj.jobRuns = message.jobRuns.map((e) => JobRun.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobRunsResponse>): ListJobRunsResponse {
    return ListJobRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobRunsResponse>): ListJobRunsResponse {
    const message = createBaseListJobRunsResponse();
    message.jobRuns = object.jobRuns?.map((e) => JobRun.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetJobRunRequest(): GetJobRunRequest {
  return { name: "" };
}

export const GetJobRunRequest: MessageFns<GetJobRunRequest> = {
  encode(message: GetJobRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRunRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetJobRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJobRunRequest>): GetJobRunRequest {
    return GetJobRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJobRunRequest>): GetJobRunRequest {
    const message = createBaseGetJobRunRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTerminateJobRunRequest(): TerminateJobRunRequest {
  return { name: "", overrideDeployPolicy: [] };
}

export const TerminateJobRunRequest: MessageFns<TerminateJobRunRequest> = {
  encode(message: TerminateJobRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.overrideDeployPolicy) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateJobRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateJobRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overrideDeployPolicy.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminateJobRunRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      overrideDeployPolicy: globalThis.Array.isArray(object?.overrideDeployPolicy)
        ? object.overrideDeployPolicy.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: TerminateJobRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.overrideDeployPolicy?.length) {
      obj.overrideDeployPolicy = message.overrideDeployPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<TerminateJobRunRequest>): TerminateJobRunRequest {
    return TerminateJobRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminateJobRunRequest>): TerminateJobRunRequest {
    const message = createBaseTerminateJobRunRequest();
    message.name = object.name ?? "";
    message.overrideDeployPolicy = object.overrideDeployPolicy?.map((e) => e) || [];
    return message;
  },
};

function createBaseTerminateJobRunResponse(): TerminateJobRunResponse {
  return {};
}

export const TerminateJobRunResponse: MessageFns<TerminateJobRunResponse> = {
  encode(_: TerminateJobRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateJobRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateJobRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): TerminateJobRunResponse {
    return {};
  },

  toJSON(_: TerminateJobRunResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<TerminateJobRunResponse>): TerminateJobRunResponse {
    return TerminateJobRunResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<TerminateJobRunResponse>): TerminateJobRunResponse {
    const message = createBaseTerminateJobRunResponse();
    return message;
  },
};

function createBaseConfig(): Config {
  return { name: "", supportedVersions: [], defaultSkaffoldVersion: "" };
}

export const Config: MessageFns<Config> = {
  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.supportedVersions) {
      SkaffoldVersion.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.defaultSkaffoldVersion !== "") {
      writer.uint32(26).string(message.defaultSkaffoldVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.supportedVersions.push(SkaffoldVersion.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultSkaffoldVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      supportedVersions: globalThis.Array.isArray(object?.supportedVersions)
        ? object.supportedVersions.map((e: any) => SkaffoldVersion.fromJSON(e))
        : [],
      defaultSkaffoldVersion: isSet(object.defaultSkaffoldVersion)
        ? globalThis.String(object.defaultSkaffoldVersion)
        : "",
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.supportedVersions?.length) {
      obj.supportedVersions = message.supportedVersions.map((e) => SkaffoldVersion.toJSON(e));
    }
    if (message.defaultSkaffoldVersion !== "") {
      obj.defaultSkaffoldVersion = message.defaultSkaffoldVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Config>): Config {
    return Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Config>): Config {
    const message = createBaseConfig();
    message.name = object.name ?? "";
    message.supportedVersions = object.supportedVersions?.map((e) => SkaffoldVersion.fromPartial(e)) || [];
    message.defaultSkaffoldVersion = object.defaultSkaffoldVersion ?? "";
    return message;
  },
};

function createBaseSkaffoldVersion(): SkaffoldVersion {
  return { version: "", maintenanceModeTime: undefined, supportExpirationTime: undefined, supportEndDate: undefined };
}

export const SkaffoldVersion: MessageFns<SkaffoldVersion> = {
  encode(message: SkaffoldVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.maintenanceModeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.maintenanceModeTime), writer.uint32(26).fork()).join();
    }
    if (message.supportExpirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.supportExpirationTime), writer.uint32(34).fork()).join();
    }
    if (message.supportEndDate !== undefined) {
      DateMessage.encode(message.supportEndDate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkaffoldVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkaffoldVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maintenanceModeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.supportExpirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.supportEndDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkaffoldVersion {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      maintenanceModeTime: isSet(object.maintenanceModeTime)
        ? fromJsonTimestamp(object.maintenanceModeTime)
        : undefined,
      supportExpirationTime: isSet(object.supportExpirationTime)
        ? fromJsonTimestamp(object.supportExpirationTime)
        : undefined,
      supportEndDate: isSet(object.supportEndDate) ? DateMessage.fromJSON(object.supportEndDate) : undefined,
    };
  },

  toJSON(message: SkaffoldVersion): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.maintenanceModeTime !== undefined) {
      obj.maintenanceModeTime = message.maintenanceModeTime.toISOString();
    }
    if (message.supportExpirationTime !== undefined) {
      obj.supportExpirationTime = message.supportExpirationTime.toISOString();
    }
    if (message.supportEndDate !== undefined) {
      obj.supportEndDate = DateMessage.toJSON(message.supportEndDate);
    }
    return obj;
  },

  create(base?: DeepPartial<SkaffoldVersion>): SkaffoldVersion {
    return SkaffoldVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkaffoldVersion>): SkaffoldVersion {
    const message = createBaseSkaffoldVersion();
    message.version = object.version ?? "";
    message.maintenanceModeTime = object.maintenanceModeTime ?? undefined;
    message.supportExpirationTime = object.supportExpirationTime ?? undefined;
    message.supportEndDate = (object.supportEndDate !== undefined && object.supportEndDate !== null)
      ? DateMessage.fromPartial(object.supportEndDate)
      : undefined;
    return message;
  },
};

function createBaseGetConfigRequest(): GetConfigRequest {
  return { name: "" };
}

export const GetConfigRequest: MessageFns<GetConfigRequest> = {
  encode(message: GetConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigRequest>): GetConfigRequest {
    return GetConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigRequest>): GetConfigRequest {
    const message = createBaseGetConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAutomation(): Automation {
  return {
    name: "",
    uid: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    annotations: {},
    labels: {},
    etag: "",
    suspended: false,
    serviceAccount: "",
    selector: undefined,
    rules: [],
  };
}

export const Automation: MessageFns<Automation> = {
  encode(message: Automation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Automation_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      Automation_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    if (message.suspended !== false) {
      writer.uint32(72).bool(message.suspended);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(82).string(message.serviceAccount);
    }
    if (message.selector !== undefined) {
      AutomationResourceSelector.encode(message.selector, writer.uint32(90).fork()).join();
    }
    for (const v of message.rules) {
      AutomationRule.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Automation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Automation_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.annotations[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Automation_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.suspended = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.selector = AutomationResourceSelector.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.rules.push(AutomationRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Automation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      suspended: isSet(object.suspended) ? globalThis.Boolean(object.suspended) : false,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      selector: isSet(object.selector) ? AutomationResourceSelector.fromJSON(object.selector) : undefined,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => AutomationRule.fromJSON(e)) : [],
    };
  },

  toJSON(message: Automation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.suspended !== false) {
      obj.suspended = message.suspended;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.selector !== undefined) {
      obj.selector = AutomationResourceSelector.toJSON(message.selector);
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => AutomationRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Automation>): Automation {
    return Automation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Automation>): Automation {
    const message = createBaseAutomation();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.suspended = object.suspended ?? false;
    message.serviceAccount = object.serviceAccount ?? "";
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? AutomationResourceSelector.fromPartial(object.selector)
      : undefined;
    message.rules = object.rules?.map((e) => AutomationRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAutomation_AnnotationsEntry(): Automation_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Automation_AnnotationsEntry: MessageFns<Automation_AnnotationsEntry> = {
  encode(message: Automation_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Automation_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomation_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Automation_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Automation_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Automation_AnnotationsEntry>): Automation_AnnotationsEntry {
    return Automation_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Automation_AnnotationsEntry>): Automation_AnnotationsEntry {
    const message = createBaseAutomation_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAutomation_LabelsEntry(): Automation_LabelsEntry {
  return { key: "", value: "" };
}

export const Automation_LabelsEntry: MessageFns<Automation_LabelsEntry> = {
  encode(message: Automation_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Automation_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomation_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Automation_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Automation_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Automation_LabelsEntry>): Automation_LabelsEntry {
    return Automation_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Automation_LabelsEntry>): Automation_LabelsEntry {
    const message = createBaseAutomation_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAutomationResourceSelector(): AutomationResourceSelector {
  return { targets: [] };
}

export const AutomationResourceSelector: MessageFns<AutomationResourceSelector> = {
  encode(message: AutomationResourceSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.targets) {
      TargetAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomationResourceSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomationResourceSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targets.push(TargetAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomationResourceSelector {
    return {
      targets: globalThis.Array.isArray(object?.targets)
        ? object.targets.map((e: any) => TargetAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AutomationResourceSelector): unknown {
    const obj: any = {};
    if (message.targets?.length) {
      obj.targets = message.targets.map((e) => TargetAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AutomationResourceSelector>): AutomationResourceSelector {
    return AutomationResourceSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomationResourceSelector>): AutomationResourceSelector {
    const message = createBaseAutomationResourceSelector();
    message.targets = object.targets?.map((e) => TargetAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAutomationRule(): AutomationRule {
  return { promoteReleaseRule: undefined, advanceRolloutRule: undefined, repairRolloutRule: undefined };
}

export const AutomationRule: MessageFns<AutomationRule> = {
  encode(message: AutomationRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.promoteReleaseRule !== undefined) {
      PromoteReleaseRule.encode(message.promoteReleaseRule, writer.uint32(10).fork()).join();
    }
    if (message.advanceRolloutRule !== undefined) {
      AdvanceRolloutRule.encode(message.advanceRolloutRule, writer.uint32(18).fork()).join();
    }
    if (message.repairRolloutRule !== undefined) {
      RepairRolloutRule.encode(message.repairRolloutRule, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomationRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomationRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.promoteReleaseRule = PromoteReleaseRule.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.advanceRolloutRule = AdvanceRolloutRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repairRolloutRule = RepairRolloutRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomationRule {
    return {
      promoteReleaseRule: isSet(object.promoteReleaseRule)
        ? PromoteReleaseRule.fromJSON(object.promoteReleaseRule)
        : undefined,
      advanceRolloutRule: isSet(object.advanceRolloutRule)
        ? AdvanceRolloutRule.fromJSON(object.advanceRolloutRule)
        : undefined,
      repairRolloutRule: isSet(object.repairRolloutRule)
        ? RepairRolloutRule.fromJSON(object.repairRolloutRule)
        : undefined,
    };
  },

  toJSON(message: AutomationRule): unknown {
    const obj: any = {};
    if (message.promoteReleaseRule !== undefined) {
      obj.promoteReleaseRule = PromoteReleaseRule.toJSON(message.promoteReleaseRule);
    }
    if (message.advanceRolloutRule !== undefined) {
      obj.advanceRolloutRule = AdvanceRolloutRule.toJSON(message.advanceRolloutRule);
    }
    if (message.repairRolloutRule !== undefined) {
      obj.repairRolloutRule = RepairRolloutRule.toJSON(message.repairRolloutRule);
    }
    return obj;
  },

  create(base?: DeepPartial<AutomationRule>): AutomationRule {
    return AutomationRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomationRule>): AutomationRule {
    const message = createBaseAutomationRule();
    message.promoteReleaseRule = (object.promoteReleaseRule !== undefined && object.promoteReleaseRule !== null)
      ? PromoteReleaseRule.fromPartial(object.promoteReleaseRule)
      : undefined;
    message.advanceRolloutRule = (object.advanceRolloutRule !== undefined && object.advanceRolloutRule !== null)
      ? AdvanceRolloutRule.fromPartial(object.advanceRolloutRule)
      : undefined;
    message.repairRolloutRule = (object.repairRolloutRule !== undefined && object.repairRolloutRule !== null)
      ? RepairRolloutRule.fromPartial(object.repairRolloutRule)
      : undefined;
    return message;
  },
};

function createBasePromoteReleaseRule(): PromoteReleaseRule {
  return { id: "", wait: undefined, destinationTargetId: "", condition: undefined, destinationPhase: "" };
}

export const PromoteReleaseRule: MessageFns<PromoteReleaseRule> = {
  encode(message: PromoteReleaseRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.wait !== undefined) {
      Duration.encode(message.wait, writer.uint32(18).fork()).join();
    }
    if (message.destinationTargetId !== "") {
      writer.uint32(58).string(message.destinationTargetId);
    }
    if (message.condition !== undefined) {
      AutomationRuleCondition.encode(message.condition, writer.uint32(42).fork()).join();
    }
    if (message.destinationPhase !== "") {
      writer.uint32(66).string(message.destinationPhase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromoteReleaseRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteReleaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wait = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.destinationTargetId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.condition = AutomationRuleCondition.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.destinationPhase = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromoteReleaseRule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      wait: isSet(object.wait) ? Duration.fromJSON(object.wait) : undefined,
      destinationTargetId: isSet(object.destinationTargetId) ? globalThis.String(object.destinationTargetId) : "",
      condition: isSet(object.condition) ? AutomationRuleCondition.fromJSON(object.condition) : undefined,
      destinationPhase: isSet(object.destinationPhase) ? globalThis.String(object.destinationPhase) : "",
    };
  },

  toJSON(message: PromoteReleaseRule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.wait !== undefined) {
      obj.wait = Duration.toJSON(message.wait);
    }
    if (message.destinationTargetId !== "") {
      obj.destinationTargetId = message.destinationTargetId;
    }
    if (message.condition !== undefined) {
      obj.condition = AutomationRuleCondition.toJSON(message.condition);
    }
    if (message.destinationPhase !== "") {
      obj.destinationPhase = message.destinationPhase;
    }
    return obj;
  },

  create(base?: DeepPartial<PromoteReleaseRule>): PromoteReleaseRule {
    return PromoteReleaseRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromoteReleaseRule>): PromoteReleaseRule {
    const message = createBasePromoteReleaseRule();
    message.id = object.id ?? "";
    message.wait = (object.wait !== undefined && object.wait !== null) ? Duration.fromPartial(object.wait) : undefined;
    message.destinationTargetId = object.destinationTargetId ?? "";
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? AutomationRuleCondition.fromPartial(object.condition)
      : undefined;
    message.destinationPhase = object.destinationPhase ?? "";
    return message;
  },
};

function createBaseAdvanceRolloutRule(): AdvanceRolloutRule {
  return { id: "", sourcePhases: [], wait: undefined, condition: undefined };
}

export const AdvanceRolloutRule: MessageFns<AdvanceRolloutRule> = {
  encode(message: AdvanceRolloutRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.sourcePhases) {
      writer.uint32(50).string(v!);
    }
    if (message.wait !== undefined) {
      Duration.encode(message.wait, writer.uint32(26).fork()).join();
    }
    if (message.condition !== undefined) {
      AutomationRuleCondition.encode(message.condition, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceRolloutRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceRolloutRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourcePhases.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.wait = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.condition = AutomationRuleCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceRolloutRule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sourcePhases: globalThis.Array.isArray(object?.sourcePhases)
        ? object.sourcePhases.map((e: any) => globalThis.String(e))
        : [],
      wait: isSet(object.wait) ? Duration.fromJSON(object.wait) : undefined,
      condition: isSet(object.condition) ? AutomationRuleCondition.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: AdvanceRolloutRule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sourcePhases?.length) {
      obj.sourcePhases = message.sourcePhases;
    }
    if (message.wait !== undefined) {
      obj.wait = Duration.toJSON(message.wait);
    }
    if (message.condition !== undefined) {
      obj.condition = AutomationRuleCondition.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<AdvanceRolloutRule>): AdvanceRolloutRule {
    return AdvanceRolloutRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvanceRolloutRule>): AdvanceRolloutRule {
    const message = createBaseAdvanceRolloutRule();
    message.id = object.id ?? "";
    message.sourcePhases = object.sourcePhases?.map((e) => e) || [];
    message.wait = (object.wait !== undefined && object.wait !== null) ? Duration.fromPartial(object.wait) : undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? AutomationRuleCondition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseRepairRolloutRule(): RepairRolloutRule {
  return { id: "", jobs: [], condition: undefined };
}

export const RepairRolloutRule: MessageFns<RepairRolloutRule> = {
  encode(message: RepairRolloutRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.jobs) {
      writer.uint32(26).string(v!);
    }
    if (message.condition !== undefined) {
      AutomationRuleCondition.encode(message.condition, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairRolloutRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairRolloutRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.jobs.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.condition = AutomationRuleCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairRolloutRule {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => globalThis.String(e)) : [],
      condition: isSet(object.condition) ? AutomationRuleCondition.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: RepairRolloutRule): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.jobs?.length) {
      obj.jobs = message.jobs;
    }
    if (message.condition !== undefined) {
      obj.condition = AutomationRuleCondition.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<RepairRolloutRule>): RepairRolloutRule {
    return RepairRolloutRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairRolloutRule>): RepairRolloutRule {
    const message = createBaseRepairRolloutRule();
    message.id = object.id ?? "";
    message.jobs = object.jobs?.map((e) => e) || [];
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? AutomationRuleCondition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseAutomationRuleCondition(): AutomationRuleCondition {
  return { targetsPresentCondition: undefined };
}

export const AutomationRuleCondition: MessageFns<AutomationRuleCondition> = {
  encode(message: AutomationRuleCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetsPresentCondition !== undefined) {
      TargetsPresentCondition.encode(message.targetsPresentCondition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomationRuleCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomationRuleCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetsPresentCondition = TargetsPresentCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomationRuleCondition {
    return {
      targetsPresentCondition: isSet(object.targetsPresentCondition)
        ? TargetsPresentCondition.fromJSON(object.targetsPresentCondition)
        : undefined,
    };
  },

  toJSON(message: AutomationRuleCondition): unknown {
    const obj: any = {};
    if (message.targetsPresentCondition !== undefined) {
      obj.targetsPresentCondition = TargetsPresentCondition.toJSON(message.targetsPresentCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<AutomationRuleCondition>): AutomationRuleCondition {
    return AutomationRuleCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomationRuleCondition>): AutomationRuleCondition {
    const message = createBaseAutomationRuleCondition();
    message.targetsPresentCondition =
      (object.targetsPresentCondition !== undefined && object.targetsPresentCondition !== null)
        ? TargetsPresentCondition.fromPartial(object.targetsPresentCondition)
        : undefined;
    return message;
  },
};

function createBaseCreateAutomationRequest(): CreateAutomationRequest {
  return { parent: "", automationId: "", automation: undefined, requestId: "", validateOnly: false };
}

export const CreateAutomationRequest: MessageFns<CreateAutomationRequest> = {
  encode(message: CreateAutomationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.automationId !== "") {
      writer.uint32(18).string(message.automationId);
    }
    if (message.automation !== undefined) {
      Automation.encode(message.automation, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAutomationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.automationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.automation = Automation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAutomationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      automationId: isSet(object.automationId) ? globalThis.String(object.automationId) : "",
      automation: isSet(object.automation) ? Automation.fromJSON(object.automation) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateAutomationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.automationId !== "") {
      obj.automationId = message.automationId;
    }
    if (message.automation !== undefined) {
      obj.automation = Automation.toJSON(message.automation);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAutomationRequest>): CreateAutomationRequest {
    return CreateAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAutomationRequest>): CreateAutomationRequest {
    const message = createBaseCreateAutomationRequest();
    message.parent = object.parent ?? "";
    message.automationId = object.automationId ?? "";
    message.automation = (object.automation !== undefined && object.automation !== null)
      ? Automation.fromPartial(object.automation)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateAutomationRequest(): UpdateAutomationRequest {
  return { updateMask: undefined, automation: undefined, requestId: "", allowMissing: false, validateOnly: false };
}

export const UpdateAutomationRequest: MessageFns<UpdateAutomationRequest> = {
  encode(message: UpdateAutomationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.automation !== undefined) {
      Automation.encode(message.automation, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAutomationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.automation = Automation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAutomationRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      automation: isSet(object.automation) ? Automation.fromJSON(object.automation) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateAutomationRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.automation !== undefined) {
      obj.automation = Automation.toJSON(message.automation);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAutomationRequest>): UpdateAutomationRequest {
    return UpdateAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAutomationRequest>): UpdateAutomationRequest {
    const message = createBaseUpdateAutomationRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.automation = (object.automation !== undefined && object.automation !== null)
      ? Automation.fromPartial(object.automation)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteAutomationRequest(): DeleteAutomationRequest {
  return { name: "", requestId: "", allowMissing: false, validateOnly: false, etag: "" };
}

export const DeleteAutomationRequest: MessageFns<DeleteAutomationRequest> = {
  encode(message: DeleteAutomationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.etag !== "") {
      writer.uint32(42).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAutomationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAutomationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteAutomationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAutomationRequest>): DeleteAutomationRequest {
    return DeleteAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAutomationRequest>): DeleteAutomationRequest {
    const message = createBaseDeleteAutomationRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    message.validateOnly = object.validateOnly ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseListAutomationsRequest(): ListAutomationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAutomationsRequest: MessageFns<ListAutomationsRequest> = {
  encode(message: ListAutomationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAutomationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAutomationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAutomationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAutomationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAutomationsRequest>): ListAutomationsRequest {
    return ListAutomationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAutomationsRequest>): ListAutomationsRequest {
    const message = createBaseListAutomationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAutomationsResponse(): ListAutomationsResponse {
  return { automations: [], nextPageToken: "", unreachable: [] };
}

export const ListAutomationsResponse: MessageFns<ListAutomationsResponse> = {
  encode(message: ListAutomationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.automations) {
      Automation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAutomationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAutomationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.automations.push(Automation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAutomationsResponse {
    return {
      automations: globalThis.Array.isArray(object?.automations)
        ? object.automations.map((e: any) => Automation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAutomationsResponse): unknown {
    const obj: any = {};
    if (message.automations?.length) {
      obj.automations = message.automations.map((e) => Automation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAutomationsResponse>): ListAutomationsResponse {
    return ListAutomationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAutomationsResponse>): ListAutomationsResponse {
    const message = createBaseListAutomationsResponse();
    message.automations = object.automations?.map((e) => Automation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAutomationRequest(): GetAutomationRequest {
  return { name: "" };
}

export const GetAutomationRequest: MessageFns<GetAutomationRequest> = {
  encode(message: GetAutomationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutomationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutomationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutomationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAutomationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutomationRequest>): GetAutomationRequest {
    return GetAutomationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutomationRequest>): GetAutomationRequest {
    const message = createBaseGetAutomationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAutomationRun(): AutomationRun {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    etag: "",
    serviceAccount: "",
    automationSnapshot: undefined,
    targetId: "",
    state: 0,
    stateDescription: "",
    policyViolation: undefined,
    expireTime: undefined,
    ruleId: "",
    automationId: "",
    promoteReleaseOperation: undefined,
    advanceRolloutOperation: undefined,
    repairRolloutOperation: undefined,
    waitUntilTime: undefined,
  };
}

export const AutomationRun: MessageFns<AutomationRun> = {
  encode(message: AutomationRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(42).string(message.serviceAccount);
    }
    if (message.automationSnapshot !== undefined) {
      Automation.encode(message.automationSnapshot, writer.uint32(50).fork()).join();
    }
    if (message.targetId !== "") {
      writer.uint32(58).string(message.targetId);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.stateDescription !== "") {
      writer.uint32(74).string(message.stateDescription);
    }
    if (message.policyViolation !== undefined) {
      PolicyViolation.encode(message.policyViolation, writer.uint32(82).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(90).fork()).join();
    }
    if (message.ruleId !== "") {
      writer.uint32(98).string(message.ruleId);
    }
    if (message.automationId !== "") {
      writer.uint32(122).string(message.automationId);
    }
    if (message.promoteReleaseOperation !== undefined) {
      PromoteReleaseOperation.encode(message.promoteReleaseOperation, writer.uint32(106).fork()).join();
    }
    if (message.advanceRolloutOperation !== undefined) {
      AdvanceRolloutOperation.encode(message.advanceRolloutOperation, writer.uint32(114).fork()).join();
    }
    if (message.repairRolloutOperation !== undefined) {
      RepairRolloutOperation.encode(message.repairRolloutOperation, writer.uint32(138).fork()).join();
    }
    if (message.waitUntilTime !== undefined) {
      Timestamp.encode(toTimestamp(message.waitUntilTime), writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomationRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomationRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.automationSnapshot = Automation.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stateDescription = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.policyViolation = PolicyViolation.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.automationId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.promoteReleaseOperation = PromoteReleaseOperation.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.advanceRolloutOperation = AdvanceRolloutOperation.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.repairRolloutOperation = RepairRolloutOperation.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.waitUntilTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomationRun {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      automationSnapshot: isSet(object.automationSnapshot) ? Automation.fromJSON(object.automationSnapshot) : undefined,
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      state: isSet(object.state) ? automationRun_StateFromJSON(object.state) : 0,
      stateDescription: isSet(object.stateDescription) ? globalThis.String(object.stateDescription) : "",
      policyViolation: isSet(object.policyViolation) ? PolicyViolation.fromJSON(object.policyViolation) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      automationId: isSet(object.automationId) ? globalThis.String(object.automationId) : "",
      promoteReleaseOperation: isSet(object.promoteReleaseOperation)
        ? PromoteReleaseOperation.fromJSON(object.promoteReleaseOperation)
        : undefined,
      advanceRolloutOperation: isSet(object.advanceRolloutOperation)
        ? AdvanceRolloutOperation.fromJSON(object.advanceRolloutOperation)
        : undefined,
      repairRolloutOperation: isSet(object.repairRolloutOperation)
        ? RepairRolloutOperation.fromJSON(object.repairRolloutOperation)
        : undefined,
      waitUntilTime: isSet(object.waitUntilTime) ? fromJsonTimestamp(object.waitUntilTime) : undefined,
    };
  },

  toJSON(message: AutomationRun): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.automationSnapshot !== undefined) {
      obj.automationSnapshot = Automation.toJSON(message.automationSnapshot);
    }
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.state !== 0) {
      obj.state = automationRun_StateToJSON(message.state);
    }
    if (message.stateDescription !== "") {
      obj.stateDescription = message.stateDescription;
    }
    if (message.policyViolation !== undefined) {
      obj.policyViolation = PolicyViolation.toJSON(message.policyViolation);
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.automationId !== "") {
      obj.automationId = message.automationId;
    }
    if (message.promoteReleaseOperation !== undefined) {
      obj.promoteReleaseOperation = PromoteReleaseOperation.toJSON(message.promoteReleaseOperation);
    }
    if (message.advanceRolloutOperation !== undefined) {
      obj.advanceRolloutOperation = AdvanceRolloutOperation.toJSON(message.advanceRolloutOperation);
    }
    if (message.repairRolloutOperation !== undefined) {
      obj.repairRolloutOperation = RepairRolloutOperation.toJSON(message.repairRolloutOperation);
    }
    if (message.waitUntilTime !== undefined) {
      obj.waitUntilTime = message.waitUntilTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AutomationRun>): AutomationRun {
    return AutomationRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomationRun>): AutomationRun {
    const message = createBaseAutomationRun();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.automationSnapshot = (object.automationSnapshot !== undefined && object.automationSnapshot !== null)
      ? Automation.fromPartial(object.automationSnapshot)
      : undefined;
    message.targetId = object.targetId ?? "";
    message.state = object.state ?? 0;
    message.stateDescription = object.stateDescription ?? "";
    message.policyViolation = (object.policyViolation !== undefined && object.policyViolation !== null)
      ? PolicyViolation.fromPartial(object.policyViolation)
      : undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.ruleId = object.ruleId ?? "";
    message.automationId = object.automationId ?? "";
    message.promoteReleaseOperation =
      (object.promoteReleaseOperation !== undefined && object.promoteReleaseOperation !== null)
        ? PromoteReleaseOperation.fromPartial(object.promoteReleaseOperation)
        : undefined;
    message.advanceRolloutOperation =
      (object.advanceRolloutOperation !== undefined && object.advanceRolloutOperation !== null)
        ? AdvanceRolloutOperation.fromPartial(object.advanceRolloutOperation)
        : undefined;
    message.repairRolloutOperation =
      (object.repairRolloutOperation !== undefined && object.repairRolloutOperation !== null)
        ? RepairRolloutOperation.fromPartial(object.repairRolloutOperation)
        : undefined;
    message.waitUntilTime = object.waitUntilTime ?? undefined;
    return message;
  },
};

function createBasePromoteReleaseOperation(): PromoteReleaseOperation {
  return { targetId: "", wait: undefined, rollout: "", phase: "" };
}

export const PromoteReleaseOperation: MessageFns<PromoteReleaseOperation> = {
  encode(message: PromoteReleaseOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetId !== "") {
      writer.uint32(10).string(message.targetId);
    }
    if (message.wait !== undefined) {
      Duration.encode(message.wait, writer.uint32(18).fork()).join();
    }
    if (message.rollout !== "") {
      writer.uint32(26).string(message.rollout);
    }
    if (message.phase !== "") {
      writer.uint32(34).string(message.phase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PromoteReleaseOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePromoteReleaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wait = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phase = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PromoteReleaseOperation {
    return {
      targetId: isSet(object.targetId) ? globalThis.String(object.targetId) : "",
      wait: isSet(object.wait) ? Duration.fromJSON(object.wait) : undefined,
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      phase: isSet(object.phase) ? globalThis.String(object.phase) : "",
    };
  },

  toJSON(message: PromoteReleaseOperation): unknown {
    const obj: any = {};
    if (message.targetId !== "") {
      obj.targetId = message.targetId;
    }
    if (message.wait !== undefined) {
      obj.wait = Duration.toJSON(message.wait);
    }
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.phase !== "") {
      obj.phase = message.phase;
    }
    return obj;
  },

  create(base?: DeepPartial<PromoteReleaseOperation>): PromoteReleaseOperation {
    return PromoteReleaseOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PromoteReleaseOperation>): PromoteReleaseOperation {
    const message = createBasePromoteReleaseOperation();
    message.targetId = object.targetId ?? "";
    message.wait = (object.wait !== undefined && object.wait !== null) ? Duration.fromPartial(object.wait) : undefined;
    message.rollout = object.rollout ?? "";
    message.phase = object.phase ?? "";
    return message;
  },
};

function createBaseAdvanceRolloutOperation(): AdvanceRolloutOperation {
  return { sourcePhase: "", wait: undefined, rollout: "", destinationPhase: "" };
}

export const AdvanceRolloutOperation: MessageFns<AdvanceRolloutOperation> = {
  encode(message: AdvanceRolloutOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcePhase !== "") {
      writer.uint32(42).string(message.sourcePhase);
    }
    if (message.wait !== undefined) {
      Duration.encode(message.wait, writer.uint32(18).fork()).join();
    }
    if (message.rollout !== "") {
      writer.uint32(26).string(message.rollout);
    }
    if (message.destinationPhase !== "") {
      writer.uint32(34).string(message.destinationPhase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvanceRolloutOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvanceRolloutOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourcePhase = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wait = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationPhase = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvanceRolloutOperation {
    return {
      sourcePhase: isSet(object.sourcePhase) ? globalThis.String(object.sourcePhase) : "",
      wait: isSet(object.wait) ? Duration.fromJSON(object.wait) : undefined,
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      destinationPhase: isSet(object.destinationPhase) ? globalThis.String(object.destinationPhase) : "",
    };
  },

  toJSON(message: AdvanceRolloutOperation): unknown {
    const obj: any = {};
    if (message.sourcePhase !== "") {
      obj.sourcePhase = message.sourcePhase;
    }
    if (message.wait !== undefined) {
      obj.wait = Duration.toJSON(message.wait);
    }
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.destinationPhase !== "") {
      obj.destinationPhase = message.destinationPhase;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvanceRolloutOperation>): AdvanceRolloutOperation {
    return AdvanceRolloutOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvanceRolloutOperation>): AdvanceRolloutOperation {
    const message = createBaseAdvanceRolloutOperation();
    message.sourcePhase = object.sourcePhase ?? "";
    message.wait = (object.wait !== undefined && object.wait !== null) ? Duration.fromPartial(object.wait) : undefined;
    message.rollout = object.rollout ?? "";
    message.destinationPhase = object.destinationPhase ?? "";
    return message;
  },
};

function createBaseRepairRolloutOperation(): RepairRolloutOperation {
  return { rollout: "", repairPhases: [], phaseId: "", jobId: "" };
}

export const RepairRolloutOperation: MessageFns<RepairRolloutOperation> = {
  encode(message: RepairRolloutOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rollout !== "") {
      writer.uint32(10).string(message.rollout);
    }
    for (const v of message.repairPhases) {
      RepairPhase.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.phaseId !== "") {
      writer.uint32(34).string(message.phaseId);
    }
    if (message.jobId !== "") {
      writer.uint32(42).string(message.jobId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairRolloutOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairRolloutOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rollout = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repairPhases.push(RepairPhase.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phaseId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.jobId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairRolloutOperation {
    return {
      rollout: isSet(object.rollout) ? globalThis.String(object.rollout) : "",
      repairPhases: globalThis.Array.isArray(object?.repairPhases)
        ? object.repairPhases.map((e: any) => RepairPhase.fromJSON(e))
        : [],
      phaseId: isSet(object.phaseId) ? globalThis.String(object.phaseId) : "",
      jobId: isSet(object.jobId) ? globalThis.String(object.jobId) : "",
    };
  },

  toJSON(message: RepairRolloutOperation): unknown {
    const obj: any = {};
    if (message.rollout !== "") {
      obj.rollout = message.rollout;
    }
    if (message.repairPhases?.length) {
      obj.repairPhases = message.repairPhases.map((e) => RepairPhase.toJSON(e));
    }
    if (message.phaseId !== "") {
      obj.phaseId = message.phaseId;
    }
    if (message.jobId !== "") {
      obj.jobId = message.jobId;
    }
    return obj;
  },

  create(base?: DeepPartial<RepairRolloutOperation>): RepairRolloutOperation {
    return RepairRolloutOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairRolloutOperation>): RepairRolloutOperation {
    const message = createBaseRepairRolloutOperation();
    message.rollout = object.rollout ?? "";
    message.repairPhases = object.repairPhases?.map((e) => RepairPhase.fromPartial(e)) || [];
    message.phaseId = object.phaseId ?? "";
    message.jobId = object.jobId ?? "";
    return message;
  },
};

function createBaseRepairPhase(): RepairPhase {
  return { retry: undefined, rollback: undefined };
}

export const RepairPhase: MessageFns<RepairPhase> = {
  encode(message: RepairPhase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retry !== undefined) {
      RetryPhase.encode(message.retry, writer.uint32(10).fork()).join();
    }
    if (message.rollback !== undefined) {
      RollbackAttempt.encode(message.rollback, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairPhase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairPhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retry = RetryPhase.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rollback = RollbackAttempt.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairPhase {
    return {
      retry: isSet(object.retry) ? RetryPhase.fromJSON(object.retry) : undefined,
      rollback: isSet(object.rollback) ? RollbackAttempt.fromJSON(object.rollback) : undefined,
    };
  },

  toJSON(message: RepairPhase): unknown {
    const obj: any = {};
    if (message.retry !== undefined) {
      obj.retry = RetryPhase.toJSON(message.retry);
    }
    if (message.rollback !== undefined) {
      obj.rollback = RollbackAttempt.toJSON(message.rollback);
    }
    return obj;
  },

  create(base?: DeepPartial<RepairPhase>): RepairPhase {
    return RepairPhase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairPhase>): RepairPhase {
    const message = createBaseRepairPhase();
    message.retry = (object.retry !== undefined && object.retry !== null)
      ? RetryPhase.fromPartial(object.retry)
      : undefined;
    message.rollback = (object.rollback !== undefined && object.rollback !== null)
      ? RollbackAttempt.fromPartial(object.rollback)
      : undefined;
    return message;
  },
};

function createBaseRetryPhase(): RetryPhase {
  return { totalAttempts: Long.ZERO, backoffMode: 0, attempts: [] };
}

export const RetryPhase: MessageFns<RetryPhase> = {
  encode(message: RetryPhase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalAttempts.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalAttempts.toString());
    }
    if (message.backoffMode !== 0) {
      writer.uint32(16).int32(message.backoffMode);
    }
    for (const v of message.attempts) {
      RetryAttempt.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryPhase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryPhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalAttempts = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.backoffMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attempts.push(RetryAttempt.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryPhase {
    return {
      totalAttempts: isSet(object.totalAttempts) ? Long.fromValue(object.totalAttempts) : Long.ZERO,
      backoffMode: isSet(object.backoffMode) ? backoffModeFromJSON(object.backoffMode) : 0,
      attempts: globalThis.Array.isArray(object?.attempts)
        ? object.attempts.map((e: any) => RetryAttempt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RetryPhase): unknown {
    const obj: any = {};
    if (!message.totalAttempts.equals(Long.ZERO)) {
      obj.totalAttempts = (message.totalAttempts || Long.ZERO).toString();
    }
    if (message.backoffMode !== 0) {
      obj.backoffMode = backoffModeToJSON(message.backoffMode);
    }
    if (message.attempts?.length) {
      obj.attempts = message.attempts.map((e) => RetryAttempt.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RetryPhase>): RetryPhase {
    return RetryPhase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryPhase>): RetryPhase {
    const message = createBaseRetryPhase();
    message.totalAttempts = (object.totalAttempts !== undefined && object.totalAttempts !== null)
      ? Long.fromValue(object.totalAttempts)
      : Long.ZERO;
    message.backoffMode = object.backoffMode ?? 0;
    message.attempts = object.attempts?.map((e) => RetryAttempt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRetryAttempt(): RetryAttempt {
  return { attempt: Long.ZERO, wait: undefined, state: 0, stateDesc: "" };
}

export const RetryAttempt: MessageFns<RetryAttempt> = {
  encode(message: RetryAttempt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.attempt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.attempt.toString());
    }
    if (message.wait !== undefined) {
      Duration.encode(message.wait, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.stateDesc !== "") {
      writer.uint32(50).string(message.stateDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryAttempt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryAttempt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.attempt = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wait = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stateDesc = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryAttempt {
    return {
      attempt: isSet(object.attempt) ? Long.fromValue(object.attempt) : Long.ZERO,
      wait: isSet(object.wait) ? Duration.fromJSON(object.wait) : undefined,
      state: isSet(object.state) ? repairStateFromJSON(object.state) : 0,
      stateDesc: isSet(object.stateDesc) ? globalThis.String(object.stateDesc) : "",
    };
  },

  toJSON(message: RetryAttempt): unknown {
    const obj: any = {};
    if (!message.attempt.equals(Long.ZERO)) {
      obj.attempt = (message.attempt || Long.ZERO).toString();
    }
    if (message.wait !== undefined) {
      obj.wait = Duration.toJSON(message.wait);
    }
    if (message.state !== 0) {
      obj.state = repairStateToJSON(message.state);
    }
    if (message.stateDesc !== "") {
      obj.stateDesc = message.stateDesc;
    }
    return obj;
  },

  create(base?: DeepPartial<RetryAttempt>): RetryAttempt {
    return RetryAttempt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryAttempt>): RetryAttempt {
    const message = createBaseRetryAttempt();
    message.attempt = (object.attempt !== undefined && object.attempt !== null)
      ? Long.fromValue(object.attempt)
      : Long.ZERO;
    message.wait = (object.wait !== undefined && object.wait !== null) ? Duration.fromPartial(object.wait) : undefined;
    message.state = object.state ?? 0;
    message.stateDesc = object.stateDesc ?? "";
    return message;
  },
};

function createBaseRollbackAttempt(): RollbackAttempt {
  return { destinationPhase: "", rolloutId: "", state: 0, stateDesc: "" };
}

export const RollbackAttempt: MessageFns<RollbackAttempt> = {
  encode(message: RollbackAttempt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destinationPhase !== "") {
      writer.uint32(10).string(message.destinationPhase);
    }
    if (message.rolloutId !== "") {
      writer.uint32(18).string(message.rolloutId);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.stateDesc !== "") {
      writer.uint32(34).string(message.stateDesc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackAttempt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackAttempt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destinationPhase = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rolloutId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stateDesc = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackAttempt {
    return {
      destinationPhase: isSet(object.destinationPhase) ? globalThis.String(object.destinationPhase) : "",
      rolloutId: isSet(object.rolloutId) ? globalThis.String(object.rolloutId) : "",
      state: isSet(object.state) ? repairStateFromJSON(object.state) : 0,
      stateDesc: isSet(object.stateDesc) ? globalThis.String(object.stateDesc) : "",
    };
  },

  toJSON(message: RollbackAttempt): unknown {
    const obj: any = {};
    if (message.destinationPhase !== "") {
      obj.destinationPhase = message.destinationPhase;
    }
    if (message.rolloutId !== "") {
      obj.rolloutId = message.rolloutId;
    }
    if (message.state !== 0) {
      obj.state = repairStateToJSON(message.state);
    }
    if (message.stateDesc !== "") {
      obj.stateDesc = message.stateDesc;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackAttempt>): RollbackAttempt {
    return RollbackAttempt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackAttempt>): RollbackAttempt {
    const message = createBaseRollbackAttempt();
    message.destinationPhase = object.destinationPhase ?? "";
    message.rolloutId = object.rolloutId ?? "";
    message.state = object.state ?? 0;
    message.stateDesc = object.stateDesc ?? "";
    return message;
  },
};

function createBaseListAutomationRunsRequest(): ListAutomationRunsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAutomationRunsRequest: MessageFns<ListAutomationRunsRequest> = {
  encode(message: ListAutomationRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAutomationRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAutomationRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAutomationRunsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAutomationRunsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAutomationRunsRequest>): ListAutomationRunsRequest {
    return ListAutomationRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAutomationRunsRequest>): ListAutomationRunsRequest {
    const message = createBaseListAutomationRunsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAutomationRunsResponse(): ListAutomationRunsResponse {
  return { automationRuns: [], nextPageToken: "", unreachable: [] };
}

export const ListAutomationRunsResponse: MessageFns<ListAutomationRunsResponse> = {
  encode(message: ListAutomationRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.automationRuns) {
      AutomationRun.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAutomationRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAutomationRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.automationRuns.push(AutomationRun.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAutomationRunsResponse {
    return {
      automationRuns: globalThis.Array.isArray(object?.automationRuns)
        ? object.automationRuns.map((e: any) => AutomationRun.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAutomationRunsResponse): unknown {
    const obj: any = {};
    if (message.automationRuns?.length) {
      obj.automationRuns = message.automationRuns.map((e) => AutomationRun.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAutomationRunsResponse>): ListAutomationRunsResponse {
    return ListAutomationRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAutomationRunsResponse>): ListAutomationRunsResponse {
    const message = createBaseListAutomationRunsResponse();
    message.automationRuns = object.automationRuns?.map((e) => AutomationRun.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAutomationRunRequest(): GetAutomationRunRequest {
  return { name: "" };
}

export const GetAutomationRunRequest: MessageFns<GetAutomationRunRequest> = {
  encode(message: GetAutomationRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAutomationRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutomationRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutomationRunRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAutomationRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutomationRunRequest>): GetAutomationRunRequest {
    return GetAutomationRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutomationRunRequest>): GetAutomationRunRequest {
    const message = createBaseGetAutomationRunRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCancelAutomationRunRequest(): CancelAutomationRunRequest {
  return { name: "" };
}

export const CancelAutomationRunRequest: MessageFns<CancelAutomationRunRequest> = {
  encode(message: CancelAutomationRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelAutomationRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelAutomationRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelAutomationRunRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelAutomationRunRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelAutomationRunRequest>): CancelAutomationRunRequest {
    return CancelAutomationRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelAutomationRunRequest>): CancelAutomationRunRequest {
    const message = createBaseCancelAutomationRunRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCancelAutomationRunResponse(): CancelAutomationRunResponse {
  return {};
}

export const CancelAutomationRunResponse: MessageFns<CancelAutomationRunResponse> = {
  encode(_: CancelAutomationRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelAutomationRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelAutomationRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelAutomationRunResponse {
    return {};
  },

  toJSON(_: CancelAutomationRunResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelAutomationRunResponse>): CancelAutomationRunResponse {
    return CancelAutomationRunResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelAutomationRunResponse>): CancelAutomationRunResponse {
    const message = createBaseCancelAutomationRunResponse();
    return message;
  },
};

/**
 * CloudDeploy service creates and manages Continuous Delivery operations
 * on Google Cloud Platform via Skaffold (https://skaffold.dev).
 */
export type CloudDeployDefinition = typeof CloudDeployDefinition;
export const CloudDeployDefinition = {
  name: "CloudDeploy",
  fullName: "google.cloud.deploy.v1.CloudDeploy",
  methods: {
    /** Lists DeliveryPipelines in a given project and location. */
    listDeliveryPipelines: {
      name: "ListDeliveryPipelines",
      requestType: ListDeliveryPipelinesRequest,
      requestStream: false,
      responseType: ListDeliveryPipelinesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single DeliveryPipeline. */
    getDeliveryPipeline: {
      name: "GetDeliveryPipeline",
      requestType: GetDeliveryPipelineRequest,
      requestStream: false,
      responseType: DeliveryPipeline,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new DeliveryPipeline in a given project and location. */
    createDeliveryPipeline: {
      name: "CreateDeliveryPipeline",
      requestType: CreateDeliveryPipelineRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              68,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              45,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              44,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              17,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single DeliveryPipeline. */
    updateDeliveryPipeline: {
      name: "UpdateDeliveryPipeline",
      requestType: UpdateDeliveryPipelineRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              68,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              92,
              58,
              17,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              50,
              71,
              47,
              118,
              49,
              47,
              123,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              95,
              112,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single DeliveryPipeline. */
    deleteDeliveryPipeline: {
      name: "DeleteDeliveryPipeline",
      requestType: DeleteDeliveryPipelineRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Targets in a given project and location. */
    listTargets: {
      name: "ListTargets",
      requestType: ListTargetsRequest,
      requestStream: false,
      responseType: ListTargetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a `Rollout` to roll back the specified target. */
    rollbackTarget: {
      name: "RollbackTarget",
      requestType: RollbackTargetRequest,
      requestStream: false,
      responseType: RollbackTargetResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              110,
              97,
              109,
              101,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              105,
              100,
              44,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              73,
              58,
              1,
              42,
              34,
              68,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
              84,
              97,
              114,
              103,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Target. */
    getTarget: {
      name: "GetTarget",
      requestType: GetTargetRequest,
      requestStream: false,
      responseType: Target,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Target in a given project and location. */
    createTarget: {
      name: "CreateTarget",
      requestType: CreateTargetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              84,
              97,
              114,
              103,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              6,
              116,
              97,
              114,
              103,
              101,
              116,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Target. */
    updateTarget: {
      name: "UpdateTarget",
      requestType: UpdateTargetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              84,
              97,
              114,
              103,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 116, 97, 114, 103, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              6,
              116,
              97,
              114,
              103,
              101,
              116,
              50,
              50,
              47,
              118,
              49,
              47,
              123,
              116,
              97,
              114,
              103,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Target. */
    deleteTarget: {
      name: "DeleteTarget",
      requestType: DeleteTargetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              97,
              114,
              103,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists CustomTargetTypes in a given project and location. */
    listCustomTargetTypes: {
      name: "ListCustomTargetTypes",
      requestType: ListCustomTargetTypesRequest,
      requestStream: false,
      responseType: ListCustomTargetTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CustomTargetType. */
    getCustomTargetType: {
      name: "GetCustomTargetType",
      requestType: GetCustomTargetTypeRequest,
      requestStream: false,
      responseType: CustomTargetType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new CustomTargetType in a given project and location. */
    createCustomTargetType: {
      name: "CreateCustomTargetType",
      requestType: CreateCustomTargetTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              67,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              44,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              18,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a single CustomTargetType. */
    updateCustomTargetType: {
      name: "UpdateCustomTargetType",
      requestType: UpdateCustomTargetTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              67,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              30,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              94,
              58,
              18,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              50,
              72,
              47,
              118,
              49,
              47,
              123,
              99,
              117,
              115,
              116,
              111,
              109,
              95,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              116,
              121,
              112,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single CustomTargetType. */
    deleteCustomTargetType: {
      name: "DeleteCustomTargetType",
      requestType: DeleteCustomTargetTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              117,
              115,
              116,
              111,
              109,
              84,
              97,
              114,
              103,
              101,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Releases in a given project and location. */
    listReleases: {
      name: "ListReleases",
      requestType: ListReleasesRequest,
      requestStream: false,
      responseType: ListReleasesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Release. */
    getRelease: {
      name: "GetRelease",
      requestType: GetReleaseRequest,
      requestStream: false,
      responseType: Release,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Release in a given project and location. */
    createRelease: {
      name: "CreateRelease",
      requestType: CreateReleaseRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              82,
              101,
              108,
              101,
              97,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              44,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              7,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Abandons a Release in the Delivery Pipeline. */
    abandonRelease: {
      name: "AbandonRelease",
      requestType: AbandonReleaseRequest,
      requestStream: false,
      responseType: AbandonReleaseResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              97,
              98,
              97,
              110,
              100,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Creates a new DeployPolicy in a given project and location. */
    createDeployPolicy: {
      name: "CreateDeployPolicy",
      requestType: CreateDeployPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              68,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              37,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              44,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              67,
              58,
              13,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single DeployPolicy. */
    updateDeployPolicy: {
      name: "UpdateDeployPolicy",
      requestType: UpdateDeployPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              68,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              13,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              50,
              64,
              47,
              118,
              49,
              47,
              123,
              100,
              101,
              112,
              108,
              111,
              121,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single DeployPolicy. */
    deleteDeployPolicy: {
      name: "DeleteDeployPolicy",
      requestType: DeleteDeployPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists DeployPolicies in a given project and location. */
    listDeployPolicies: {
      name: "ListDeployPolicies",
      requestType: ListDeployPoliciesRequest,
      requestStream: false,
      responseType: ListDeployPoliciesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single DeployPolicy. */
    getDeployPolicy: {
      name: "GetDeployPolicy",
      requestType: GetDeployPolicyRequest,
      requestStream: false,
      responseType: DeployPolicy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Approves a Rollout. */
    approveRollout: {
      name: "ApproveRollout",
      requestType: ApproveRolloutRequest,
      requestStream: false,
      responseType: ApproveRolloutResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              88,
              58,
              1,
              42,
              34,
              83,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              114,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /** Advances a Rollout in a given project and location. */
    advanceRollout: {
      name: "AdvanceRollout",
      requestType: AdvanceRolloutRequest,
      requestStream: false,
      responseType: AdvanceRolloutResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 110, 97, 109, 101, 44, 112, 104, 97, 115, 101, 95, 105, 100])],
          578365826: [
            Buffer.from([
              88,
              58,
              1,
              42,
              34,
              83,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              118,
              97,
              110,
              99,
              101,
            ]),
          ],
        },
      },
    },
    /** Cancels a Rollout in a given project and location. */
    cancelRollout: {
      name: "CancelRollout",
      requestType: CancelRolloutRequest,
      requestStream: false,
      responseType: CancelRolloutResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              87,
              58,
              1,
              42,
              34,
              82,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /** Lists Rollouts in a given project and location. */
    listRollouts: {
      name: "ListRollouts",
      requestType: ListRolloutsRequest,
      requestStream: false,
      responseType: ListRolloutsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              77,
              18,
              75,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Rollout. */
    getRollout: {
      name: "GetRollout",
      requestType: GetRolloutRequest,
      requestStream: false,
      responseType: Rollout,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              77,
              18,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Rollout in a given project and location. */
    createRollout: {
      name: "CreateRollout",
      requestType: CreateRolloutRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              82,
              111,
              108,
              108,
              111,
              117,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              44,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              7,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Ignores the specified Job in a Rollout. */
    ignoreJob: {
      name: "IgnoreJob",
      requestType: IgnoreJobRequest,
      requestStream: false,
      responseType: IgnoreJobResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              44,
              112,
              104,
              97,
              115,
              101,
              95,
              105,
              100,
              44,
              106,
              111,
              98,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              93,
              58,
              1,
              42,
              34,
              88,
              47,
              118,
              49,
              47,
              123,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              58,
              105,
              103,
              110,
              111,
              114,
              101,
              74,
              111,
              98,
            ]),
          ],
        },
      },
    },
    /** Retries the specified Job in a Rollout. */
    retryJob: {
      name: "RetryJob",
      requestType: RetryJobRequest,
      requestStream: false,
      responseType: RetryJobResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              44,
              112,
              104,
              97,
              115,
              101,
              95,
              105,
              100,
              44,
              106,
              111,
              98,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              92,
              58,
              1,
              42,
              34,
              87,
              47,
              118,
              49,
              47,
              123,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              116,
              114,
              121,
              74,
              111,
              98,
            ]),
          ],
        },
      },
    },
    /** Lists JobRuns in a given project and location. */
    listJobRuns: {
      name: "ListJobRuns",
      requestType: ListJobRunsRequest,
      requestStream: false,
      responseType: ListJobRunsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              87,
              18,
              85,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              82,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single JobRun. */
    getJobRun: {
      name: "GetJobRun",
      requestType: GetJobRunRequest,
      requestStream: false,
      responseType: JobRun,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              87,
              18,
              85,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Terminates a Job Run in a given project and location. */
    terminateJobRun: {
      name: "TerminateJobRun",
      requestType: TerminateJobRunRequest,
      requestStream: false,
      responseType: TerminateJobRunResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              100,
              58,
              1,
              42,
              34,
              95,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              108,
              101,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              108,
              108,
              111,
              117,
              116,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              114,
              109,
              105,
              110,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Gets the configuration for a location. */
    getConfig: {
      name: "GetConfig",
      requestType: GetConfigRequest,
      requestStream: false,
      responseType: Config,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Automation in a given project and location. */
    createAutomation: {
      name: "CreateAutomation",
      requestType: CreateAutomationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              65,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              44,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              10,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              34,
              67,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Automation resource. */
    updateAutomation: {
      name: "UpdateAutomation",
      requestType: UpdateAutomationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              65,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              22,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              92,
              58,
              10,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              50,
              78,
              47,
              118,
              49,
              47,
              123,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Automation resource. */
    deleteAutomation: {
      name: "DeleteAutomation",
      requestType: DeleteAutomationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              42,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Automation. */
    getAutomation: {
      name: "GetAutomation",
      requestType: GetAutomationRequest,
      requestStream: false,
      responseType: Automation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Automations in a given project and location. */
    listAutomations: {
      name: "ListAutomations",
      requestType: ListAutomationsRequest,
      requestStream: false,
      responseType: ListAutomationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single AutomationRun. */
    getAutomationRun: {
      name: "GetAutomationRun",
      requestType: GetAutomationRunRequest,
      requestStream: false,
      responseType: AutomationRun,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists AutomationRuns in a given project and location. */
    listAutomationRuns: {
      name: "ListAutomationRuns",
      requestType: ListAutomationRunsRequest,
      requestStream: false,
      responseType: ListAutomationRunsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              82,
              117,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Cancels an AutomationRun. The `state` of the `AutomationRun` after
     * cancelling is `CANCELLED`. `CancelAutomationRun` can be called on
     * AutomationRun in the state `IN_PROGRESS` and `PENDING`; AutomationRun
     * in a different state returns an `FAILED_PRECONDITION` error.
     */
    cancelAutomationRun: {
      name: "CancelAutomationRun",
      requestType: CancelAutomationRunRequest,
      requestStream: false,
      responseType: CancelAutomationRunResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              101,
              108,
              105,
              118,
              101,
              114,
              121,
              80,
              105,
              112,
              101,
              108,
              105,
              110,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              116,
              111,
              109,
              97,
              116,
              105,
              111,
              110,
              82,
              117,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudDeployServiceImplementation<CallContextExt = {}> {
  /** Lists DeliveryPipelines in a given project and location. */
  listDeliveryPipelines(
    request: ListDeliveryPipelinesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDeliveryPipelinesResponse>>;
  /** Gets details of a single DeliveryPipeline. */
  getDeliveryPipeline(
    request: GetDeliveryPipelineRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeliveryPipeline>>;
  /** Creates a new DeliveryPipeline in a given project and location. */
  createDeliveryPipeline(
    request: CreateDeliveryPipelineRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single DeliveryPipeline. */
  updateDeliveryPipeline(
    request: UpdateDeliveryPipelineRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single DeliveryPipeline. */
  deleteDeliveryPipeline(
    request: DeleteDeliveryPipelineRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Targets in a given project and location. */
  listTargets(
    request: ListTargetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTargetsResponse>>;
  /** Creates a `Rollout` to roll back the specified target. */
  rollbackTarget(
    request: RollbackTargetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RollbackTargetResponse>>;
  /** Gets details of a single Target. */
  getTarget(request: GetTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Target>>;
  /** Creates a new Target in a given project and location. */
  createTarget(request: CreateTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Target. */
  updateTarget(request: UpdateTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Target. */
  deleteTarget(request: DeleteTargetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists CustomTargetTypes in a given project and location. */
  listCustomTargetTypes(
    request: ListCustomTargetTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCustomTargetTypesResponse>>;
  /** Gets details of a single CustomTargetType. */
  getCustomTargetType(
    request: GetCustomTargetTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CustomTargetType>>;
  /** Creates a new CustomTargetType in a given project and location. */
  createCustomTargetType(
    request: CreateCustomTargetTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a single CustomTargetType. */
  updateCustomTargetType(
    request: UpdateCustomTargetTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single CustomTargetType. */
  deleteCustomTargetType(
    request: DeleteCustomTargetTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Releases in a given project and location. */
  listReleases(
    request: ListReleasesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReleasesResponse>>;
  /** Gets details of a single Release. */
  getRelease(request: GetReleaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Release>>;
  /** Creates a new Release in a given project and location. */
  createRelease(request: CreateReleaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Abandons a Release in the Delivery Pipeline. */
  abandonRelease(
    request: AbandonReleaseRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AbandonReleaseResponse>>;
  /** Creates a new DeployPolicy in a given project and location. */
  createDeployPolicy(
    request: CreateDeployPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single DeployPolicy. */
  updateDeployPolicy(
    request: UpdateDeployPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single DeployPolicy. */
  deleteDeployPolicy(
    request: DeleteDeployPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists DeployPolicies in a given project and location. */
  listDeployPolicies(
    request: ListDeployPoliciesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDeployPoliciesResponse>>;
  /** Gets details of a single DeployPolicy. */
  getDeployPolicy(
    request: GetDeployPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DeployPolicy>>;
  /** Approves a Rollout. */
  approveRollout(
    request: ApproveRolloutRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ApproveRolloutResponse>>;
  /** Advances a Rollout in a given project and location. */
  advanceRollout(
    request: AdvanceRolloutRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AdvanceRolloutResponse>>;
  /** Cancels a Rollout in a given project and location. */
  cancelRollout(
    request: CancelRolloutRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelRolloutResponse>>;
  /** Lists Rollouts in a given project and location. */
  listRollouts(
    request: ListRolloutsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRolloutsResponse>>;
  /** Gets details of a single Rollout. */
  getRollout(request: GetRolloutRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Rollout>>;
  /** Creates a new Rollout in a given project and location. */
  createRollout(request: CreateRolloutRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Ignores the specified Job in a Rollout. */
  ignoreJob(request: IgnoreJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<IgnoreJobResponse>>;
  /** Retries the specified Job in a Rollout. */
  retryJob(request: RetryJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RetryJobResponse>>;
  /** Lists JobRuns in a given project and location. */
  listJobRuns(
    request: ListJobRunsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListJobRunsResponse>>;
  /** Gets details of a single JobRun. */
  getJobRun(request: GetJobRunRequest, context: CallContext & CallContextExt): Promise<DeepPartial<JobRun>>;
  /** Terminates a Job Run in a given project and location. */
  terminateJobRun(
    request: TerminateJobRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TerminateJobRunResponse>>;
  /** Gets the configuration for a location. */
  getConfig(request: GetConfigRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Config>>;
  /** Creates a new Automation in a given project and location. */
  createAutomation(
    request: CreateAutomationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Automation resource. */
  updateAutomation(
    request: UpdateAutomationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single Automation resource. */
  deleteAutomation(
    request: DeleteAutomationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets details of a single Automation. */
  getAutomation(request: GetAutomationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Automation>>;
  /** Lists Automations in a given project and location. */
  listAutomations(
    request: ListAutomationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAutomationsResponse>>;
  /** Gets details of a single AutomationRun. */
  getAutomationRun(
    request: GetAutomationRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AutomationRun>>;
  /** Lists AutomationRuns in a given project and location. */
  listAutomationRuns(
    request: ListAutomationRunsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAutomationRunsResponse>>;
  /**
   * Cancels an AutomationRun. The `state` of the `AutomationRun` after
   * cancelling is `CANCELLED`. `CancelAutomationRun` can be called on
   * AutomationRun in the state `IN_PROGRESS` and `PENDING`; AutomationRun
   * in a different state returns an `FAILED_PRECONDITION` error.
   */
  cancelAutomationRun(
    request: CancelAutomationRunRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelAutomationRunResponse>>;
}

export interface CloudDeployClient<CallOptionsExt = {}> {
  /** Lists DeliveryPipelines in a given project and location. */
  listDeliveryPipelines(
    request: DeepPartial<ListDeliveryPipelinesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDeliveryPipelinesResponse>;
  /** Gets details of a single DeliveryPipeline. */
  getDeliveryPipeline(
    request: DeepPartial<GetDeliveryPipelineRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeliveryPipeline>;
  /** Creates a new DeliveryPipeline in a given project and location. */
  createDeliveryPipeline(
    request: DeepPartial<CreateDeliveryPipelineRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single DeliveryPipeline. */
  updateDeliveryPipeline(
    request: DeepPartial<UpdateDeliveryPipelineRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single DeliveryPipeline. */
  deleteDeliveryPipeline(
    request: DeepPartial<DeleteDeliveryPipelineRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Targets in a given project and location. */
  listTargets(
    request: DeepPartial<ListTargetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTargetsResponse>;
  /** Creates a `Rollout` to roll back the specified target. */
  rollbackTarget(
    request: DeepPartial<RollbackTargetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RollbackTargetResponse>;
  /** Gets details of a single Target. */
  getTarget(request: DeepPartial<GetTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Target>;
  /** Creates a new Target in a given project and location. */
  createTarget(request: DeepPartial<CreateTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Target. */
  updateTarget(request: DeepPartial<UpdateTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Target. */
  deleteTarget(request: DeepPartial<DeleteTargetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists CustomTargetTypes in a given project and location. */
  listCustomTargetTypes(
    request: DeepPartial<ListCustomTargetTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCustomTargetTypesResponse>;
  /** Gets details of a single CustomTargetType. */
  getCustomTargetType(
    request: DeepPartial<GetCustomTargetTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CustomTargetType>;
  /** Creates a new CustomTargetType in a given project and location. */
  createCustomTargetType(
    request: DeepPartial<CreateCustomTargetTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a single CustomTargetType. */
  updateCustomTargetType(
    request: DeepPartial<UpdateCustomTargetTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single CustomTargetType. */
  deleteCustomTargetType(
    request: DeepPartial<DeleteCustomTargetTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Releases in a given project and location. */
  listReleases(
    request: DeepPartial<ListReleasesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReleasesResponse>;
  /** Gets details of a single Release. */
  getRelease(request: DeepPartial<GetReleaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Release>;
  /** Creates a new Release in a given project and location. */
  createRelease(request: DeepPartial<CreateReleaseRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Abandons a Release in the Delivery Pipeline. */
  abandonRelease(
    request: DeepPartial<AbandonReleaseRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AbandonReleaseResponse>;
  /** Creates a new DeployPolicy in a given project and location. */
  createDeployPolicy(
    request: DeepPartial<CreateDeployPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single DeployPolicy. */
  updateDeployPolicy(
    request: DeepPartial<UpdateDeployPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single DeployPolicy. */
  deleteDeployPolicy(
    request: DeepPartial<DeleteDeployPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists DeployPolicies in a given project and location. */
  listDeployPolicies(
    request: DeepPartial<ListDeployPoliciesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDeployPoliciesResponse>;
  /** Gets details of a single DeployPolicy. */
  getDeployPolicy(
    request: DeepPartial<GetDeployPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DeployPolicy>;
  /** Approves a Rollout. */
  approveRollout(
    request: DeepPartial<ApproveRolloutRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ApproveRolloutResponse>;
  /** Advances a Rollout in a given project and location. */
  advanceRollout(
    request: DeepPartial<AdvanceRolloutRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AdvanceRolloutResponse>;
  /** Cancels a Rollout in a given project and location. */
  cancelRollout(
    request: DeepPartial<CancelRolloutRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelRolloutResponse>;
  /** Lists Rollouts in a given project and location. */
  listRollouts(
    request: DeepPartial<ListRolloutsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRolloutsResponse>;
  /** Gets details of a single Rollout. */
  getRollout(request: DeepPartial<GetRolloutRequest>, options?: CallOptions & CallOptionsExt): Promise<Rollout>;
  /** Creates a new Rollout in a given project and location. */
  createRollout(request: DeepPartial<CreateRolloutRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Ignores the specified Job in a Rollout. */
  ignoreJob(request: DeepPartial<IgnoreJobRequest>, options?: CallOptions & CallOptionsExt): Promise<IgnoreJobResponse>;
  /** Retries the specified Job in a Rollout. */
  retryJob(request: DeepPartial<RetryJobRequest>, options?: CallOptions & CallOptionsExt): Promise<RetryJobResponse>;
  /** Lists JobRuns in a given project and location. */
  listJobRuns(
    request: DeepPartial<ListJobRunsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListJobRunsResponse>;
  /** Gets details of a single JobRun. */
  getJobRun(request: DeepPartial<GetJobRunRequest>, options?: CallOptions & CallOptionsExt): Promise<JobRun>;
  /** Terminates a Job Run in a given project and location. */
  terminateJobRun(
    request: DeepPartial<TerminateJobRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TerminateJobRunResponse>;
  /** Gets the configuration for a location. */
  getConfig(request: DeepPartial<GetConfigRequest>, options?: CallOptions & CallOptionsExt): Promise<Config>;
  /** Creates a new Automation in a given project and location. */
  createAutomation(
    request: DeepPartial<CreateAutomationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single Automation resource. */
  updateAutomation(
    request: DeepPartial<UpdateAutomationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single Automation resource. */
  deleteAutomation(
    request: DeepPartial<DeleteAutomationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets details of a single Automation. */
  getAutomation(
    request: DeepPartial<GetAutomationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Automation>;
  /** Lists Automations in a given project and location. */
  listAutomations(
    request: DeepPartial<ListAutomationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAutomationsResponse>;
  /** Gets details of a single AutomationRun. */
  getAutomationRun(
    request: DeepPartial<GetAutomationRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AutomationRun>;
  /** Lists AutomationRuns in a given project and location. */
  listAutomationRuns(
    request: DeepPartial<ListAutomationRunsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAutomationRunsResponse>;
  /**
   * Cancels an AutomationRun. The `state` of the `AutomationRun` after
   * cancelling is `CANCELLED`. `CancelAutomationRun` can be called on
   * AutomationRun in the state `IN_PROGRESS` and `PENDING`; AutomationRun
   * in a different state returns an `FAILED_PRECONDITION` error.
   */
  cancelAutomationRun(
    request: DeepPartial<CancelAutomationRunRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelAutomationRunResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
