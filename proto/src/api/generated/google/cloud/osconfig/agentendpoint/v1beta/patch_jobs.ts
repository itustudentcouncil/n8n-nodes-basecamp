// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/agentendpoint/v1beta/patch_jobs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.osconfig.agentendpoint.v1beta";

/**
 * Patch configuration specifications. Contains details on how to
 * apply patches to a VM instance.
 */
export interface PatchConfig {
  /** Post-patch reboot settings. */
  rebootConfig: PatchConfig_RebootConfig;
  /**
   * Retry strategy can be defined to have the agent retry patching
   * during the window if patching fails. If omitted, the agent will use its
   * default retry strategy.
   */
  retryStrategy:
    | RetryStrategy
    | undefined;
  /** Apt update settings. Use this override the default apt patch rules. */
  apt:
    | AptSettings
    | undefined;
  /** Yum update settings. Use this override the default yum patch rules. */
  yum:
    | YumSettings
    | undefined;
  /** Goo update settings. Use this override the default goo patch rules. */
  goo:
    | GooSettings
    | undefined;
  /** Zypper update settings. Use this override the default zypper patch rules. */
  zypper:
    | ZypperSettings
    | undefined;
  /** Windows update settings. Use this override the default windows patch rules. */
  windowsUpdate:
    | WindowsUpdateSettings
    | undefined;
  /** The ExecStep to run before the patch update. */
  preStep:
    | ExecStep
    | undefined;
  /** The ExecStep to run after the patch update. */
  postStep:
    | ExecStep
    | undefined;
  /** Allows the patch job to run on Managed instance groups (MIGs). */
  migInstancesAllowed: boolean;
}

/** Post-patch reboot settings. */
export enum PatchConfig_RebootConfig {
  /** REBOOT_CONFIG_UNSPECIFIED - The default behavior is DEFAULT. */
  REBOOT_CONFIG_UNSPECIFIED = 0,
  /**
   * DEFAULT - The agent decides if a reboot is necessary by checking
   * signals such as registry keys on Windows or `/var/run/reboot-required` on
   * APT based systems. On RPM based systems, a set of core system package
   * install times are compared with system boot time.
   */
  DEFAULT = 1,
  /** ALWAYS - Always reboot the machine after the update completes. */
  ALWAYS = 2,
  /** NEVER - Never reboot the machine after the update completes. */
  NEVER = 3,
  UNRECOGNIZED = -1,
}

export function patchConfig_RebootConfigFromJSON(object: any): PatchConfig_RebootConfig {
  switch (object) {
    case 0:
    case "REBOOT_CONFIG_UNSPECIFIED":
      return PatchConfig_RebootConfig.REBOOT_CONFIG_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return PatchConfig_RebootConfig.DEFAULT;
    case 2:
    case "ALWAYS":
      return PatchConfig_RebootConfig.ALWAYS;
    case 3:
    case "NEVER":
      return PatchConfig_RebootConfig.NEVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchConfig_RebootConfig.UNRECOGNIZED;
  }
}

export function patchConfig_RebootConfigToJSON(object: PatchConfig_RebootConfig): string {
  switch (object) {
    case PatchConfig_RebootConfig.REBOOT_CONFIG_UNSPECIFIED:
      return "REBOOT_CONFIG_UNSPECIFIED";
    case PatchConfig_RebootConfig.DEFAULT:
      return "DEFAULT";
    case PatchConfig_RebootConfig.ALWAYS:
      return "ALWAYS";
    case PatchConfig_RebootConfig.NEVER:
      return "NEVER";
    case PatchConfig_RebootConfig.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Apt patching will be performed by executing `apt-get update && apt-get
 * upgrade`. Additional options can be set to control how this is executed.
 */
export interface AptSettings {
  /**
   * By changing the type to DIST, the patching will be performed
   * using `apt-get dist-upgrade` instead.
   */
  type: AptSettings_Type;
  /** List of packages to exclude from update. */
  excludes: string[];
  /**
   * An exclusive list of packages to be updated. These are the only packages
   * that will be updated. If these packages are not installed, they will be
   * ignored. This field cannot be specified with any other patch configuration
   * fields.
   */
  exclusivePackages: string[];
}

/** Apt patch type. */
export enum AptSettings_Type {
  /** TYPE_UNSPECIFIED - By default, upgrade will be performed. */
  TYPE_UNSPECIFIED = 0,
  /** DIST - Runs `apt-get dist-upgrade`. */
  DIST = 1,
  /** UPGRADE - Runs `apt-get upgrade`. */
  UPGRADE = 2,
  UNRECOGNIZED = -1,
}

export function aptSettings_TypeFromJSON(object: any): AptSettings_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AptSettings_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DIST":
      return AptSettings_Type.DIST;
    case 2:
    case "UPGRADE":
      return AptSettings_Type.UPGRADE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AptSettings_Type.UNRECOGNIZED;
  }
}

export function aptSettings_TypeToJSON(object: AptSettings_Type): string {
  switch (object) {
    case AptSettings_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AptSettings_Type.DIST:
      return "DIST";
    case AptSettings_Type.UPGRADE:
      return "UPGRADE";
    case AptSettings_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Yum patching will be performed by executing `yum update`. Additional options
 * can be set to control how this is executed.
 *
 * Note that not all settings are supported on all platforms.
 */
export interface YumSettings {
  /**
   * Adds the `--security` flag to `yum update`. Not supported on
   * all platforms.
   */
  security: boolean;
  /** Will cause patch to run `yum update-minimal` instead. */
  minimal: boolean;
  /**
   * List of packages to exclude from update. These packages will be excluded by
   * using the yum `--exclude` flag.
   */
  excludes: string[];
  /**
   * An exclusive list of packages to be updated. These are the only packages
   * that will be updated. If these packages are not installed, they will be
   * ignored. This field must not be specified with any other patch
   * configuration fields.
   */
  exclusivePackages: string[];
}

/** Googet patching is performed by running `googet update`. */
export interface GooSettings {
}

/**
 * Zypper patching is performed by running `zypper patch`.
 * See also https://en.opensuse.org/SDB:Zypper_manual.
 */
export interface ZypperSettings {
  /** Adds the `--with-optional` flag to `zypper patch`. */
  withOptional: boolean;
  /** Adds the `--with-update` flag, to `zypper patch`. */
  withUpdate: boolean;
  /**
   * Install only patches with these categories.
   * Common categories include security, recommended, and feature.
   */
  categories: string[];
  /**
   * Install only patches with these severities.
   * Common severities include critical, important, moderate, and low.
   */
  severities: string[];
  /** List of patches to exclude from update. */
  excludes: string[];
  /**
   * An exclusive list of patches to be updated. These are the only patches
   * that will be installed using 'zypper patch patch:<patch_name>' command.
   * This field must not be used with any other patch configuration fields.
   */
  exclusivePatches: string[];
}

/** Windows patching is performed using the Windows Update Agent. */
export interface WindowsUpdateSettings {
  /**
   * Only apply updates of these windows update classifications. If empty, all
   * updates will be applied.
   */
  classifications: WindowsUpdateSettings_Classification[];
  /** List of KBs to exclude from update. */
  excludes: string[];
  /**
   * An exclusive list of kbs to be updated. These are the only patches
   * that will be updated. This field must not be used with other
   * patch configurations.
   */
  exclusivePatches: string[];
}

/**
 * Microsoft Windows update classifications as defined in
 * [1]
 * https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro
 */
export enum WindowsUpdateSettings_Classification {
  /** CLASSIFICATION_UNSPECIFIED - Invalid. If classifications are included, they must be specified. */
  CLASSIFICATION_UNSPECIFIED = 0,
  /**
   * CRITICAL - "A widely released fix for a specific problem that addresses a critical,
   * non-security-related bug." [1]
   */
  CRITICAL = 1,
  /**
   * SECURITY - "A widely released fix for a product-specific, security-related
   * vulnerability. Security vulnerabilities are rated by their severity. The
   * severity rating is indicated in the Microsoft security bulletin as
   * critical, important, moderate, or low." [1]
   */
  SECURITY = 2,
  /**
   * DEFINITION - "A widely released and frequent software update that contains additions
   * to a productâ€™s definition database. Definition databases are often used
   * to detect objects that have specific attributes, such as malicious code,
   * phishing websites, or junk mail." [1]
   */
  DEFINITION = 3,
  /** DRIVER - "Software that controls the input and output of a device." [1] */
  DRIVER = 4,
  /**
   * FEATURE_PACK - "New product functionality that is first distributed outside the context
   * of a product release and that is typically included in the next full
   * product release." [1]
   */
  FEATURE_PACK = 5,
  /**
   * SERVICE_PACK - "A tested, cumulative set of all hotfixes, security updates, critical
   * updates, and updates. Additionally, service packs may contain additional
   * fixes for problems that are found internally since the release of the
   * product. Service packs my also contain a limited number of
   * customer-requested design changes or features." [1]
   */
  SERVICE_PACK = 6,
  /** TOOL - "A utility or feature that helps complete a task or set of tasks." [1] */
  TOOL = 7,
  /**
   * UPDATE_ROLLUP - "A tested, cumulative set of hotfixes, security updates, critical
   * updates, and updates that are packaged together for easy deployment. A
   * rollup generally targets a specific area, such as security, or a
   * component of a product, such as Internet Information Services (IIS)." [1]
   */
  UPDATE_ROLLUP = 8,
  /**
   * UPDATE - "A widely released fix for a specific problem. An update addresses a
   * noncritical, non-security-related bug." [1]
   */
  UPDATE = 9,
  UNRECOGNIZED = -1,
}

export function windowsUpdateSettings_ClassificationFromJSON(object: any): WindowsUpdateSettings_Classification {
  switch (object) {
    case 0:
    case "CLASSIFICATION_UNSPECIFIED":
      return WindowsUpdateSettings_Classification.CLASSIFICATION_UNSPECIFIED;
    case 1:
    case "CRITICAL":
      return WindowsUpdateSettings_Classification.CRITICAL;
    case 2:
    case "SECURITY":
      return WindowsUpdateSettings_Classification.SECURITY;
    case 3:
    case "DEFINITION":
      return WindowsUpdateSettings_Classification.DEFINITION;
    case 4:
    case "DRIVER":
      return WindowsUpdateSettings_Classification.DRIVER;
    case 5:
    case "FEATURE_PACK":
      return WindowsUpdateSettings_Classification.FEATURE_PACK;
    case 6:
    case "SERVICE_PACK":
      return WindowsUpdateSettings_Classification.SERVICE_PACK;
    case 7:
    case "TOOL":
      return WindowsUpdateSettings_Classification.TOOL;
    case 8:
    case "UPDATE_ROLLUP":
      return WindowsUpdateSettings_Classification.UPDATE_ROLLUP;
    case 9:
    case "UPDATE":
      return WindowsUpdateSettings_Classification.UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowsUpdateSettings_Classification.UNRECOGNIZED;
  }
}

export function windowsUpdateSettings_ClassificationToJSON(object: WindowsUpdateSettings_Classification): string {
  switch (object) {
    case WindowsUpdateSettings_Classification.CLASSIFICATION_UNSPECIFIED:
      return "CLASSIFICATION_UNSPECIFIED";
    case WindowsUpdateSettings_Classification.CRITICAL:
      return "CRITICAL";
    case WindowsUpdateSettings_Classification.SECURITY:
      return "SECURITY";
    case WindowsUpdateSettings_Classification.DEFINITION:
      return "DEFINITION";
    case WindowsUpdateSettings_Classification.DRIVER:
      return "DRIVER";
    case WindowsUpdateSettings_Classification.FEATURE_PACK:
      return "FEATURE_PACK";
    case WindowsUpdateSettings_Classification.SERVICE_PACK:
      return "SERVICE_PACK";
    case WindowsUpdateSettings_Classification.TOOL:
      return "TOOL";
    case WindowsUpdateSettings_Classification.UPDATE_ROLLUP:
      return "UPDATE_ROLLUP";
    case WindowsUpdateSettings_Classification.UPDATE:
      return "UPDATE";
    case WindowsUpdateSettings_Classification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The strategy for retrying failed patches during the patch window. */
export interface RetryStrategy {
  /**
   * If true, the agent will continue to try and patch until the window has
   * ended.
   */
  enabled: boolean;
}

/** A step that runs an executable for a PatchJob. */
export interface ExecStep {
  /** The ExecStepConfig for all Linux VMs targeted by the PatchJob. */
  linuxExecStepConfig:
    | ExecStepConfig
    | undefined;
  /** The ExecStepConfig for all Windows VMs targeted by the PatchJob. */
  windowsExecStepConfig: ExecStepConfig | undefined;
}

/** Common configurations for an ExecStep. */
export interface ExecStepConfig {
  /** An absolute path to the executable on the VM. */
  localPath?:
    | string
    | undefined;
  /** A GCS object containing the executable. */
  gcsObject?:
    | GcsObject
    | undefined;
  /**
   * Defaults to [0]. A list of possible return values that the
   * execution can return to indicate a success.
   */
  allowedSuccessCodes: number[];
  /**
   * The script interpreter to use to run the script. If no interpreter is
   * specified the script will be executed directly, which will likely
   * only succeed for scripts with shebang lines.
   * [Wikipedia shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).
   */
  interpreter: ExecStepConfig_Interpreter;
}

/** The interpreter used to execute the a file. */
export enum ExecStepConfig_Interpreter {
  /** INTERPRETER_UNSPECIFIED - Deprecated, defaults to NONE for compatibility reasons. */
  INTERPRETER_UNSPECIFIED = 0,
  /**
   * NONE - Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
   * interpreter will be parsed from the shebang line of the script if
   * unspecified.
   */
  NONE = 3,
  /**
   * SHELL - Indicates that the script will be run with /bin/sh on Linux and cmd
   * on windows.
   */
  SHELL = 1,
  /** POWERSHELL - Indicates that the file will be run with PowerShell. */
  POWERSHELL = 2,
  UNRECOGNIZED = -1,
}

export function execStepConfig_InterpreterFromJSON(object: any): ExecStepConfig_Interpreter {
  switch (object) {
    case 0:
    case "INTERPRETER_UNSPECIFIED":
      return ExecStepConfig_Interpreter.INTERPRETER_UNSPECIFIED;
    case 3:
    case "NONE":
      return ExecStepConfig_Interpreter.NONE;
    case 1:
    case "SHELL":
      return ExecStepConfig_Interpreter.SHELL;
    case 2:
    case "POWERSHELL":
      return ExecStepConfig_Interpreter.POWERSHELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecStepConfig_Interpreter.UNRECOGNIZED;
  }
}

export function execStepConfig_InterpreterToJSON(object: ExecStepConfig_Interpreter): string {
  switch (object) {
    case ExecStepConfig_Interpreter.INTERPRETER_UNSPECIFIED:
      return "INTERPRETER_UNSPECIFIED";
    case ExecStepConfig_Interpreter.NONE:
      return "NONE";
    case ExecStepConfig_Interpreter.SHELL:
      return "SHELL";
    case ExecStepConfig_Interpreter.POWERSHELL:
      return "POWERSHELL";
    case ExecStepConfig_Interpreter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GCS object representation. */
export interface GcsObject {
  /** Bucket of the GCS object. */
  bucket: string;
  /** Name of the GCS object. */
  object: string;
  /**
   * Generation number of the GCS object. This is used to ensure that the
   * ExecStep specified by this PatchJob does not change.
   */
  generationNumber: Long;
}

function createBasePatchConfig(): PatchConfig {
  return {
    rebootConfig: 0,
    retryStrategy: undefined,
    apt: undefined,
    yum: undefined,
    goo: undefined,
    zypper: undefined,
    windowsUpdate: undefined,
    preStep: undefined,
    postStep: undefined,
    migInstancesAllowed: false,
  };
}

export const PatchConfig: MessageFns<PatchConfig> = {
  encode(message: PatchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rebootConfig !== 0) {
      writer.uint32(8).int32(message.rebootConfig);
    }
    if (message.retryStrategy !== undefined) {
      RetryStrategy.encode(message.retryStrategy, writer.uint32(18).fork()).join();
    }
    if (message.apt !== undefined) {
      AptSettings.encode(message.apt, writer.uint32(26).fork()).join();
    }
    if (message.yum !== undefined) {
      YumSettings.encode(message.yum, writer.uint32(34).fork()).join();
    }
    if (message.goo !== undefined) {
      GooSettings.encode(message.goo, writer.uint32(42).fork()).join();
    }
    if (message.zypper !== undefined) {
      ZypperSettings.encode(message.zypper, writer.uint32(50).fork()).join();
    }
    if (message.windowsUpdate !== undefined) {
      WindowsUpdateSettings.encode(message.windowsUpdate, writer.uint32(58).fork()).join();
    }
    if (message.preStep !== undefined) {
      ExecStep.encode(message.preStep, writer.uint32(66).fork()).join();
    }
    if (message.postStep !== undefined) {
      ExecStep.encode(message.postStep, writer.uint32(74).fork()).join();
    }
    if (message.migInstancesAllowed !== false) {
      writer.uint32(80).bool(message.migInstancesAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rebootConfig = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.retryStrategy = RetryStrategy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.apt = AptSettings.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.yum = YumSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.goo = GooSettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.zypper = ZypperSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.windowsUpdate = WindowsUpdateSettings.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.preStep = ExecStep.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.postStep = ExecStep.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.migInstancesAllowed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchConfig {
    return {
      rebootConfig: isSet(object.rebootConfig) ? patchConfig_RebootConfigFromJSON(object.rebootConfig) : 0,
      retryStrategy: isSet(object.retryStrategy) ? RetryStrategy.fromJSON(object.retryStrategy) : undefined,
      apt: isSet(object.apt) ? AptSettings.fromJSON(object.apt) : undefined,
      yum: isSet(object.yum) ? YumSettings.fromJSON(object.yum) : undefined,
      goo: isSet(object.goo) ? GooSettings.fromJSON(object.goo) : undefined,
      zypper: isSet(object.zypper) ? ZypperSettings.fromJSON(object.zypper) : undefined,
      windowsUpdate: isSet(object.windowsUpdate) ? WindowsUpdateSettings.fromJSON(object.windowsUpdate) : undefined,
      preStep: isSet(object.preStep) ? ExecStep.fromJSON(object.preStep) : undefined,
      postStep: isSet(object.postStep) ? ExecStep.fromJSON(object.postStep) : undefined,
      migInstancesAllowed: isSet(object.migInstancesAllowed) ? globalThis.Boolean(object.migInstancesAllowed) : false,
    };
  },

  toJSON(message: PatchConfig): unknown {
    const obj: any = {};
    if (message.rebootConfig !== 0) {
      obj.rebootConfig = patchConfig_RebootConfigToJSON(message.rebootConfig);
    }
    if (message.retryStrategy !== undefined) {
      obj.retryStrategy = RetryStrategy.toJSON(message.retryStrategy);
    }
    if (message.apt !== undefined) {
      obj.apt = AptSettings.toJSON(message.apt);
    }
    if (message.yum !== undefined) {
      obj.yum = YumSettings.toJSON(message.yum);
    }
    if (message.goo !== undefined) {
      obj.goo = GooSettings.toJSON(message.goo);
    }
    if (message.zypper !== undefined) {
      obj.zypper = ZypperSettings.toJSON(message.zypper);
    }
    if (message.windowsUpdate !== undefined) {
      obj.windowsUpdate = WindowsUpdateSettings.toJSON(message.windowsUpdate);
    }
    if (message.preStep !== undefined) {
      obj.preStep = ExecStep.toJSON(message.preStep);
    }
    if (message.postStep !== undefined) {
      obj.postStep = ExecStep.toJSON(message.postStep);
    }
    if (message.migInstancesAllowed !== false) {
      obj.migInstancesAllowed = message.migInstancesAllowed;
    }
    return obj;
  },

  create(base?: DeepPartial<PatchConfig>): PatchConfig {
    return PatchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchConfig>): PatchConfig {
    const message = createBasePatchConfig();
    message.rebootConfig = object.rebootConfig ?? 0;
    message.retryStrategy = (object.retryStrategy !== undefined && object.retryStrategy !== null)
      ? RetryStrategy.fromPartial(object.retryStrategy)
      : undefined;
    message.apt = (object.apt !== undefined && object.apt !== null) ? AptSettings.fromPartial(object.apt) : undefined;
    message.yum = (object.yum !== undefined && object.yum !== null) ? YumSettings.fromPartial(object.yum) : undefined;
    message.goo = (object.goo !== undefined && object.goo !== null) ? GooSettings.fromPartial(object.goo) : undefined;
    message.zypper = (object.zypper !== undefined && object.zypper !== null)
      ? ZypperSettings.fromPartial(object.zypper)
      : undefined;
    message.windowsUpdate = (object.windowsUpdate !== undefined && object.windowsUpdate !== null)
      ? WindowsUpdateSettings.fromPartial(object.windowsUpdate)
      : undefined;
    message.preStep = (object.preStep !== undefined && object.preStep !== null)
      ? ExecStep.fromPartial(object.preStep)
      : undefined;
    message.postStep = (object.postStep !== undefined && object.postStep !== null)
      ? ExecStep.fromPartial(object.postStep)
      : undefined;
    message.migInstancesAllowed = object.migInstancesAllowed ?? false;
    return message;
  },
};

function createBaseAptSettings(): AptSettings {
  return { type: 0, excludes: [], exclusivePackages: [] };
}

export const AptSettings: MessageFns<AptSettings> = {
  encode(message: AptSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.excludes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.exclusivePackages) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AptSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAptSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusivePackages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AptSettings {
    return {
      type: isSet(object.type) ? aptSettings_TypeFromJSON(object.type) : 0,
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePackages: globalThis.Array.isArray(object?.exclusivePackages)
        ? object.exclusivePackages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AptSettings): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = aptSettings_TypeToJSON(message.type);
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePackages?.length) {
      obj.exclusivePackages = message.exclusivePackages;
    }
    return obj;
  },

  create(base?: DeepPartial<AptSettings>): AptSettings {
    return AptSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AptSettings>): AptSettings {
    const message = createBaseAptSettings();
    message.type = object.type ?? 0;
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePackages = object.exclusivePackages?.map((e) => e) || [];
    return message;
  },
};

function createBaseYumSettings(): YumSettings {
  return { security: false, minimal: false, excludes: [], exclusivePackages: [] };
}

export const YumSettings: MessageFns<YumSettings> = {
  encode(message: YumSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.security !== false) {
      writer.uint32(8).bool(message.security);
    }
    if (message.minimal !== false) {
      writer.uint32(16).bool(message.minimal);
    }
    for (const v of message.excludes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.exclusivePackages) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YumSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYumSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.security = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minimal = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exclusivePackages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YumSettings {
    return {
      security: isSet(object.security) ? globalThis.Boolean(object.security) : false,
      minimal: isSet(object.minimal) ? globalThis.Boolean(object.minimal) : false,
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePackages: globalThis.Array.isArray(object?.exclusivePackages)
        ? object.exclusivePackages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: YumSettings): unknown {
    const obj: any = {};
    if (message.security !== false) {
      obj.security = message.security;
    }
    if (message.minimal !== false) {
      obj.minimal = message.minimal;
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePackages?.length) {
      obj.exclusivePackages = message.exclusivePackages;
    }
    return obj;
  },

  create(base?: DeepPartial<YumSettings>): YumSettings {
    return YumSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YumSettings>): YumSettings {
    const message = createBaseYumSettings();
    message.security = object.security ?? false;
    message.minimal = object.minimal ?? false;
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePackages = object.exclusivePackages?.map((e) => e) || [];
    return message;
  },
};

function createBaseGooSettings(): GooSettings {
  return {};
}

export const GooSettings: MessageFns<GooSettings> = {
  encode(_: GooSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GooSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGooSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GooSettings {
    return {};
  },

  toJSON(_: GooSettings): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GooSettings>): GooSettings {
    return GooSettings.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GooSettings>): GooSettings {
    const message = createBaseGooSettings();
    return message;
  },
};

function createBaseZypperSettings(): ZypperSettings {
  return { withOptional: false, withUpdate: false, categories: [], severities: [], excludes: [], exclusivePatches: [] };
}

export const ZypperSettings: MessageFns<ZypperSettings> = {
  encode(message: ZypperSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withOptional !== false) {
      writer.uint32(8).bool(message.withOptional);
    }
    if (message.withUpdate !== false) {
      writer.uint32(16).bool(message.withUpdate);
    }
    for (const v of message.categories) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.severities) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.excludes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.exclusivePatches) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZypperSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZypperSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.withOptional = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.withUpdate = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.severities.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.exclusivePatches.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZypperSettings {
    return {
      withOptional: isSet(object.withOptional) ? globalThis.Boolean(object.withOptional) : false,
      withUpdate: isSet(object.withUpdate) ? globalThis.Boolean(object.withUpdate) : false,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      severities: globalThis.Array.isArray(object?.severities)
        ? object.severities.map((e: any) => globalThis.String(e))
        : [],
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePatches: globalThis.Array.isArray(object?.exclusivePatches)
        ? object.exclusivePatches.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ZypperSettings): unknown {
    const obj: any = {};
    if (message.withOptional !== false) {
      obj.withOptional = message.withOptional;
    }
    if (message.withUpdate !== false) {
      obj.withUpdate = message.withUpdate;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.severities?.length) {
      obj.severities = message.severities;
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePatches?.length) {
      obj.exclusivePatches = message.exclusivePatches;
    }
    return obj;
  },

  create(base?: DeepPartial<ZypperSettings>): ZypperSettings {
    return ZypperSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZypperSettings>): ZypperSettings {
    const message = createBaseZypperSettings();
    message.withOptional = object.withOptional ?? false;
    message.withUpdate = object.withUpdate ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.severities = object.severities?.map((e) => e) || [];
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePatches = object.exclusivePatches?.map((e) => e) || [];
    return message;
  },
};

function createBaseWindowsUpdateSettings(): WindowsUpdateSettings {
  return { classifications: [], excludes: [], exclusivePatches: [] };
}

export const WindowsUpdateSettings: MessageFns<WindowsUpdateSettings> = {
  encode(message: WindowsUpdateSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.classifications) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.excludes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.exclusivePatches) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsUpdateSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsUpdateSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.classifications.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.classifications.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusivePatches.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsUpdateSettings {
    return {
      classifications: globalThis.Array.isArray(object?.classifications)
        ? object.classifications.map((e: any) => windowsUpdateSettings_ClassificationFromJSON(e))
        : [],
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePatches: globalThis.Array.isArray(object?.exclusivePatches)
        ? object.exclusivePatches.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WindowsUpdateSettings): unknown {
    const obj: any = {};
    if (message.classifications?.length) {
      obj.classifications = message.classifications.map((e) => windowsUpdateSettings_ClassificationToJSON(e));
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePatches?.length) {
      obj.exclusivePatches = message.exclusivePatches;
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsUpdateSettings>): WindowsUpdateSettings {
    return WindowsUpdateSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsUpdateSettings>): WindowsUpdateSettings {
    const message = createBaseWindowsUpdateSettings();
    message.classifications = object.classifications?.map((e) => e) || [];
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePatches = object.exclusivePatches?.map((e) => e) || [];
    return message;
  },
};

function createBaseRetryStrategy(): RetryStrategy {
  return { enabled: false };
}

export const RetryStrategy: MessageFns<RetryStrategy> = {
  encode(message: RetryStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryStrategy {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: RetryStrategy): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<RetryStrategy>): RetryStrategy {
    return RetryStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryStrategy>): RetryStrategy {
    const message = createBaseRetryStrategy();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseExecStep(): ExecStep {
  return { linuxExecStepConfig: undefined, windowsExecStepConfig: undefined };
}

export const ExecStep: MessageFns<ExecStep> = {
  encode(message: ExecStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linuxExecStepConfig !== undefined) {
      ExecStepConfig.encode(message.linuxExecStepConfig, writer.uint32(10).fork()).join();
    }
    if (message.windowsExecStepConfig !== undefined) {
      ExecStepConfig.encode(message.windowsExecStepConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.linuxExecStepConfig = ExecStepConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowsExecStepConfig = ExecStepConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecStep {
    return {
      linuxExecStepConfig: isSet(object.linuxExecStepConfig)
        ? ExecStepConfig.fromJSON(object.linuxExecStepConfig)
        : undefined,
      windowsExecStepConfig: isSet(object.windowsExecStepConfig)
        ? ExecStepConfig.fromJSON(object.windowsExecStepConfig)
        : undefined,
    };
  },

  toJSON(message: ExecStep): unknown {
    const obj: any = {};
    if (message.linuxExecStepConfig !== undefined) {
      obj.linuxExecStepConfig = ExecStepConfig.toJSON(message.linuxExecStepConfig);
    }
    if (message.windowsExecStepConfig !== undefined) {
      obj.windowsExecStepConfig = ExecStepConfig.toJSON(message.windowsExecStepConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecStep>): ExecStep {
    return ExecStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecStep>): ExecStep {
    const message = createBaseExecStep();
    message.linuxExecStepConfig = (object.linuxExecStepConfig !== undefined && object.linuxExecStepConfig !== null)
      ? ExecStepConfig.fromPartial(object.linuxExecStepConfig)
      : undefined;
    message.windowsExecStepConfig =
      (object.windowsExecStepConfig !== undefined && object.windowsExecStepConfig !== null)
        ? ExecStepConfig.fromPartial(object.windowsExecStepConfig)
        : undefined;
    return message;
  },
};

function createBaseExecStepConfig(): ExecStepConfig {
  return { localPath: undefined, gcsObject: undefined, allowedSuccessCodes: [], interpreter: 0 };
}

export const ExecStepConfig: MessageFns<ExecStepConfig> = {
  encode(message: ExecStepConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localPath !== undefined) {
      writer.uint32(10).string(message.localPath);
    }
    if (message.gcsObject !== undefined) {
      GcsObject.encode(message.gcsObject, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.allowedSuccessCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.interpreter !== 0) {
      writer.uint32(32).int32(message.interpreter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecStepConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecStepConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsObject = GcsObject.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.allowedSuccessCodes.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedSuccessCodes.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.interpreter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecStepConfig {
    return {
      localPath: isSet(object.localPath) ? globalThis.String(object.localPath) : undefined,
      gcsObject: isSet(object.gcsObject) ? GcsObject.fromJSON(object.gcsObject) : undefined,
      allowedSuccessCodes: globalThis.Array.isArray(object?.allowedSuccessCodes)
        ? object.allowedSuccessCodes.map((e: any) => globalThis.Number(e))
        : [],
      interpreter: isSet(object.interpreter) ? execStepConfig_InterpreterFromJSON(object.interpreter) : 0,
    };
  },

  toJSON(message: ExecStepConfig): unknown {
    const obj: any = {};
    if (message.localPath !== undefined) {
      obj.localPath = message.localPath;
    }
    if (message.gcsObject !== undefined) {
      obj.gcsObject = GcsObject.toJSON(message.gcsObject);
    }
    if (message.allowedSuccessCodes?.length) {
      obj.allowedSuccessCodes = message.allowedSuccessCodes.map((e) => Math.round(e));
    }
    if (message.interpreter !== 0) {
      obj.interpreter = execStepConfig_InterpreterToJSON(message.interpreter);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecStepConfig>): ExecStepConfig {
    return ExecStepConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecStepConfig>): ExecStepConfig {
    const message = createBaseExecStepConfig();
    message.localPath = object.localPath ?? undefined;
    message.gcsObject = (object.gcsObject !== undefined && object.gcsObject !== null)
      ? GcsObject.fromPartial(object.gcsObject)
      : undefined;
    message.allowedSuccessCodes = object.allowedSuccessCodes?.map((e) => e) || [];
    message.interpreter = object.interpreter ?? 0;
    return message;
  },
};

function createBaseGcsObject(): GcsObject {
  return { bucket: "", object: "", generationNumber: Long.ZERO };
}

export const GcsObject: MessageFns<GcsObject> = {
  encode(message: GcsObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    if (!message.generationNumber.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.generationNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.generationNumber = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsObject {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      generationNumber: isSet(object.generationNumber) ? Long.fromValue(object.generationNumber) : Long.ZERO,
    };
  },

  toJSON(message: GcsObject): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (!message.generationNumber.equals(Long.ZERO)) {
      obj.generationNumber = (message.generationNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GcsObject>): GcsObject {
    return GcsObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsObject>): GcsObject {
    const message = createBaseGcsObject();
    message.bucket = object.bucket ?? "";
    message.object = object.object ?? "";
    message.generationNumber = (object.generationNumber !== undefined && object.generationNumber !== null)
      ? Long.fromValue(object.generationNumber)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
