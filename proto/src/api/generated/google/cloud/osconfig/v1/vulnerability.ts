// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/v1/vulnerability.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.osconfig.v1";

/**
 * This API resource represents the vulnerability report for a specified
 * Compute Engine virtual machine (VM) instance at a given point in time.
 *
 * For more information, see [Vulnerability
 * reports](https://cloud.google.com/compute/docs/instances/os-inventory-management#vulnerability-reports).
 */
export interface VulnerabilityReport {
  /**
   * Output only. The `vulnerabilityReport` API resource name.
   *
   * Format:
   * `projects/{project_number}/locations/{location}/instances/{instance_id}/vulnerabilityReport`
   */
  name: string;
  /** Output only. List of vulnerabilities affecting the VM. */
  vulnerabilities: VulnerabilityReport_Vulnerability[];
  /**
   * Output only. The timestamp for when the last vulnerability report was generated for the
   * VM.
   */
  updateTime: Date | undefined;
}

/** A vulnerability affecting the VM instance. */
export interface VulnerabilityReport_Vulnerability {
  /**
   * Contains metadata as per the upstream feed of the operating system and
   * NVD.
   */
  details:
    | VulnerabilityReport_Vulnerability_Details
    | undefined;
  /**
   * Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
   * This field displays the inventory items affected by this vulnerability.
   * If the vulnerability report was not updated after the VM inventory
   * update, these values might not display in VM inventory. For some distros,
   * this field may be empty.
   *
   * @deprecated
   */
  installedInventoryItemIds: string[];
  /**
   * Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
   * If the vulnerability report was not updated after the VM inventory
   * update, these values might not display in VM inventory. If there is no
   * available fix, the field is empty. The `inventory_item` value specifies
   * the latest `SoftwarePackage` available to the VM that fixes the
   * vulnerability.
   *
   * @deprecated
   */
  availableInventoryItemIds: string[];
  /** The timestamp for when the vulnerability was first detected. */
  createTime:
    | Date
    | undefined;
  /** The timestamp for when the vulnerability was last modified. */
  updateTime:
    | Date
    | undefined;
  /** List of items affected by the vulnerability. */
  items: VulnerabilityReport_Vulnerability_Item[];
}

/**
 * Contains metadata information for the vulnerability. This information is
 * collected from the upstream feed of the operating system.
 */
export interface VulnerabilityReport_Vulnerability_Details {
  /**
   * The CVE of the vulnerability. CVE cannot be
   * empty and the combination of <cve, classification> should be unique
   * across vulnerabilities for a VM.
   */
  cve: string;
  /**
   * The CVSS V2 score of this vulnerability. CVSS V2 score is on a scale of
   * 0 - 10 where 0 indicates low severity and 10 indicates high severity.
   */
  cvssV2Score: number;
  /** The full description of the CVSSv3 for this vulnerability from NVD. */
  cvssV3:
    | CVSSv3
    | undefined;
  /** Assigned severity/impact ranking from the distro. */
  severity: string;
  /** The note or description describing the vulnerability from the distro. */
  description: string;
  /** Corresponds to the references attached to the `VulnerabilityDetails`. */
  references: VulnerabilityReport_Vulnerability_Details_Reference[];
}

/** A reference for this vulnerability. */
export interface VulnerabilityReport_Vulnerability_Details_Reference {
  /** The url of the reference. */
  url: string;
  /** The source of the reference e.g. NVD. */
  source: string;
}

/**
 * OS inventory item that is affected by a vulnerability or fixed as a
 * result of a vulnerability.
 */
export interface VulnerabilityReport_Vulnerability_Item {
  /**
   * Corresponds to the `INSTALLED_PACKAGE` inventory item on the VM.
   * This field displays the inventory items affected by this vulnerability.
   * If the vulnerability report was not updated after the VM inventory
   * update, these values might not display in VM inventory. For some
   * operating systems, this field might be empty.
   */
  installedInventoryItemId: string;
  /**
   * Corresponds to the `AVAILABLE_PACKAGE` inventory item on the VM.
   * If the vulnerability report was not updated after the VM inventory
   * update, these values might not display in VM inventory. If there is no
   * available fix, the field is empty. The `inventory_item` value specifies
   * the latest `SoftwarePackage` available to the VM that fixes the
   * vulnerability.
   */
  availableInventoryItemId: string;
  /**
   * The recommended [CPE URI](https://cpe.mitre.org/specification/) update
   * that contains a fix for this vulnerability.
   */
  fixedCpeUri: string;
  /** The upstream OS patch, packages or KB that fixes the vulnerability. */
  upstreamFix: string;
}

/** A request message for getting the vulnerability report for the specified VM. */
export interface GetVulnerabilityReportRequest {
  /**
   * Required. API resource name for vulnerability resource.
   *
   * Format:
   * `projects/{project}/locations/{location}/instances/{instance}/vulnerabilityReport`
   *
   * For `{project}`, either `project-number` or `project-id` can be provided.
   * For `{instance}`, either Compute Engine `instance-id` or `instance-name`
   * can be provided.
   */
  name: string;
}

/**
 * A request message for listing vulnerability reports for all VM instances in
 * the specified location.
 */
export interface ListVulnerabilityReportsRequest {
  /**
   * Required. The parent resource name.
   *
   * Format: `projects/{project}/locations/{location}/instances/-`
   *
   * For `{project}`, either `project-number` or `project-id` can be provided.
   */
  parent: string;
  /** The maximum number of results to return. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call to
   * `ListVulnerabilityReports` that indicates where this listing
   * should continue from.
   */
  pageToken: string;
  /**
   * If provided, this field specifies the criteria that must be met by a
   * `vulnerabilityReport` API resource to be included in the response.
   */
  filter: string;
}

/**
 * A response message for listing vulnerability reports for all VM instances in
 * the specified location.
 */
export interface ListVulnerabilityReportsResponse {
  /** List of vulnerabilityReport objects. */
  vulnerabilityReports: VulnerabilityReport[];
  /**
   * The pagination token to retrieve the next page of vulnerabilityReports
   * object.
   */
  nextPageToken: string;
}

/**
 * Common Vulnerability Scoring System version 3.
 * For details, see https://www.first.org/cvss/specification-document
 */
export interface CVSSv3 {
  /**
   * The base score is a function of the base metric scores.
   * https://www.first.org/cvss/specification-document#Base-Metrics
   */
  baseScore: number;
  /**
   * The Exploitability sub-score equation is derived from the Base
   * Exploitability metrics.
   * https://www.first.org/cvss/specification-document#2-1-Exploitability-Metrics
   */
  exploitabilityScore: number;
  /** The Impact sub-score equation is derived from the Base Impact metrics. */
  impactScore: number;
  /**
   * This metric reflects the context by which vulnerability exploitation is
   * possible.
   */
  attackVector: CVSSv3_AttackVector;
  /**
   * This metric describes the conditions beyond the attacker's control that
   * must exist in order to exploit the vulnerability.
   */
  attackComplexity: CVSSv3_AttackComplexity;
  /**
   * This metric describes the level of privileges an attacker must possess
   * before successfully exploiting the vulnerability.
   */
  privilegesRequired: CVSSv3_PrivilegesRequired;
  /**
   * This metric captures the requirement for a human user, other than the
   * attacker, to participate in the successful compromise of the vulnerable
   * component.
   */
  userInteraction: CVSSv3_UserInteraction;
  /**
   * The Scope metric captures whether a vulnerability in one vulnerable
   * component impacts resources in components beyond its security scope.
   */
  scope: CVSSv3_Scope;
  /**
   * This metric measures the impact to the confidentiality of the information
   * resources managed by a software component due to a successfully exploited
   * vulnerability.
   */
  confidentialityImpact: CVSSv3_Impact;
  /**
   * This metric measures the impact to integrity of a successfully exploited
   * vulnerability.
   */
  integrityImpact: CVSSv3_Impact;
  /**
   * This metric measures the impact to the availability of the impacted
   * component resulting from a successfully exploited vulnerability.
   */
  availabilityImpact: CVSSv3_Impact;
}

/**
 * This metric reflects the context by which vulnerability exploitation is
 * possible.
 */
export enum CVSSv3_AttackVector {
  /** ATTACK_VECTOR_UNSPECIFIED - Invalid value. */
  ATTACK_VECTOR_UNSPECIFIED = 0,
  /**
   * ATTACK_VECTOR_NETWORK - The vulnerable component is bound to the network stack and the set of
   * possible attackers extends beyond the other options listed below, up to
   * and including the entire Internet.
   */
  ATTACK_VECTOR_NETWORK = 1,
  /**
   * ATTACK_VECTOR_ADJACENT - The vulnerable component is bound to the network stack, but the attack is
   * limited at the protocol level to a logically adjacent topology.
   */
  ATTACK_VECTOR_ADJACENT = 2,
  /**
   * ATTACK_VECTOR_LOCAL - The vulnerable component is not bound to the network stack and the
   * attacker's path is via read/write/execute capabilities.
   */
  ATTACK_VECTOR_LOCAL = 3,
  /**
   * ATTACK_VECTOR_PHYSICAL - The attack requires the attacker to physically touch or manipulate the
   * vulnerable component.
   */
  ATTACK_VECTOR_PHYSICAL = 4,
  UNRECOGNIZED = -1,
}

export function cVSSv3_AttackVectorFromJSON(object: any): CVSSv3_AttackVector {
  switch (object) {
    case 0:
    case "ATTACK_VECTOR_UNSPECIFIED":
      return CVSSv3_AttackVector.ATTACK_VECTOR_UNSPECIFIED;
    case 1:
    case "ATTACK_VECTOR_NETWORK":
      return CVSSv3_AttackVector.ATTACK_VECTOR_NETWORK;
    case 2:
    case "ATTACK_VECTOR_ADJACENT":
      return CVSSv3_AttackVector.ATTACK_VECTOR_ADJACENT;
    case 3:
    case "ATTACK_VECTOR_LOCAL":
      return CVSSv3_AttackVector.ATTACK_VECTOR_LOCAL;
    case 4:
    case "ATTACK_VECTOR_PHYSICAL":
      return CVSSv3_AttackVector.ATTACK_VECTOR_PHYSICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_AttackVector.UNRECOGNIZED;
  }
}

export function cVSSv3_AttackVectorToJSON(object: CVSSv3_AttackVector): string {
  switch (object) {
    case CVSSv3_AttackVector.ATTACK_VECTOR_UNSPECIFIED:
      return "ATTACK_VECTOR_UNSPECIFIED";
    case CVSSv3_AttackVector.ATTACK_VECTOR_NETWORK:
      return "ATTACK_VECTOR_NETWORK";
    case CVSSv3_AttackVector.ATTACK_VECTOR_ADJACENT:
      return "ATTACK_VECTOR_ADJACENT";
    case CVSSv3_AttackVector.ATTACK_VECTOR_LOCAL:
      return "ATTACK_VECTOR_LOCAL";
    case CVSSv3_AttackVector.ATTACK_VECTOR_PHYSICAL:
      return "ATTACK_VECTOR_PHYSICAL";
    case CVSSv3_AttackVector.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric describes the conditions beyond the attacker's control that
 * must exist in order to exploit the vulnerability.
 */
export enum CVSSv3_AttackComplexity {
  /** ATTACK_COMPLEXITY_UNSPECIFIED - Invalid value. */
  ATTACK_COMPLEXITY_UNSPECIFIED = 0,
  /**
   * ATTACK_COMPLEXITY_LOW - Specialized access conditions or extenuating circumstances do not exist.
   * An attacker can expect repeatable success when attacking the vulnerable
   * component.
   */
  ATTACK_COMPLEXITY_LOW = 1,
  /**
   * ATTACK_COMPLEXITY_HIGH - A successful attack depends on conditions beyond the attacker's control.
   * That is, a successful attack cannot be accomplished at will, but requires
   * the attacker to invest in some measurable amount of effort in preparation
   * or execution against the vulnerable component before a successful attack
   * can be expected.
   */
  ATTACK_COMPLEXITY_HIGH = 2,
  UNRECOGNIZED = -1,
}

export function cVSSv3_AttackComplexityFromJSON(object: any): CVSSv3_AttackComplexity {
  switch (object) {
    case 0:
    case "ATTACK_COMPLEXITY_UNSPECIFIED":
      return CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_UNSPECIFIED;
    case 1:
    case "ATTACK_COMPLEXITY_LOW":
      return CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_LOW;
    case 2:
    case "ATTACK_COMPLEXITY_HIGH":
      return CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_AttackComplexity.UNRECOGNIZED;
  }
}

export function cVSSv3_AttackComplexityToJSON(object: CVSSv3_AttackComplexity): string {
  switch (object) {
    case CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_UNSPECIFIED:
      return "ATTACK_COMPLEXITY_UNSPECIFIED";
    case CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_LOW:
      return "ATTACK_COMPLEXITY_LOW";
    case CVSSv3_AttackComplexity.ATTACK_COMPLEXITY_HIGH:
      return "ATTACK_COMPLEXITY_HIGH";
    case CVSSv3_AttackComplexity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric describes the level of privileges an attacker must possess
 * before successfully exploiting the vulnerability.
 */
export enum CVSSv3_PrivilegesRequired {
  /** PRIVILEGES_REQUIRED_UNSPECIFIED - Invalid value. */
  PRIVILEGES_REQUIRED_UNSPECIFIED = 0,
  /**
   * PRIVILEGES_REQUIRED_NONE - The attacker is unauthorized prior to attack, and therefore does not
   * require any access to settings or files of the vulnerable system to
   * carry out an attack.
   */
  PRIVILEGES_REQUIRED_NONE = 1,
  /**
   * PRIVILEGES_REQUIRED_LOW - The attacker requires privileges that provide basic user capabilities
   * that could normally affect only settings and files owned by a user.
   * Alternatively, an attacker with Low privileges has the ability to access
   * only non-sensitive resources.
   */
  PRIVILEGES_REQUIRED_LOW = 2,
  /**
   * PRIVILEGES_REQUIRED_HIGH - The attacker requires privileges that provide significant (e.g.,
   * administrative) control over the vulnerable component allowing access to
   * component-wide settings and files.
   */
  PRIVILEGES_REQUIRED_HIGH = 3,
  UNRECOGNIZED = -1,
}

export function cVSSv3_PrivilegesRequiredFromJSON(object: any): CVSSv3_PrivilegesRequired {
  switch (object) {
    case 0:
    case "PRIVILEGES_REQUIRED_UNSPECIFIED":
      return CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_UNSPECIFIED;
    case 1:
    case "PRIVILEGES_REQUIRED_NONE":
      return CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_NONE;
    case 2:
    case "PRIVILEGES_REQUIRED_LOW":
      return CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_LOW;
    case 3:
    case "PRIVILEGES_REQUIRED_HIGH":
      return CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_PrivilegesRequired.UNRECOGNIZED;
  }
}

export function cVSSv3_PrivilegesRequiredToJSON(object: CVSSv3_PrivilegesRequired): string {
  switch (object) {
    case CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_UNSPECIFIED:
      return "PRIVILEGES_REQUIRED_UNSPECIFIED";
    case CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_NONE:
      return "PRIVILEGES_REQUIRED_NONE";
    case CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_LOW:
      return "PRIVILEGES_REQUIRED_LOW";
    case CVSSv3_PrivilegesRequired.PRIVILEGES_REQUIRED_HIGH:
      return "PRIVILEGES_REQUIRED_HIGH";
    case CVSSv3_PrivilegesRequired.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This metric captures the requirement for a human user, other than the
 * attacker, to participate in the successful compromise of the vulnerable
 * component.
 */
export enum CVSSv3_UserInteraction {
  /** USER_INTERACTION_UNSPECIFIED - Invalid value. */
  USER_INTERACTION_UNSPECIFIED = 0,
  /** USER_INTERACTION_NONE - The vulnerable system can be exploited without interaction from any user. */
  USER_INTERACTION_NONE = 1,
  /**
   * USER_INTERACTION_REQUIRED - Successful exploitation of this vulnerability requires a user to take
   * some action before the vulnerability can be exploited.
   */
  USER_INTERACTION_REQUIRED = 2,
  UNRECOGNIZED = -1,
}

export function cVSSv3_UserInteractionFromJSON(object: any): CVSSv3_UserInteraction {
  switch (object) {
    case 0:
    case "USER_INTERACTION_UNSPECIFIED":
      return CVSSv3_UserInteraction.USER_INTERACTION_UNSPECIFIED;
    case 1:
    case "USER_INTERACTION_NONE":
      return CVSSv3_UserInteraction.USER_INTERACTION_NONE;
    case 2:
    case "USER_INTERACTION_REQUIRED":
      return CVSSv3_UserInteraction.USER_INTERACTION_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_UserInteraction.UNRECOGNIZED;
  }
}

export function cVSSv3_UserInteractionToJSON(object: CVSSv3_UserInteraction): string {
  switch (object) {
    case CVSSv3_UserInteraction.USER_INTERACTION_UNSPECIFIED:
      return "USER_INTERACTION_UNSPECIFIED";
    case CVSSv3_UserInteraction.USER_INTERACTION_NONE:
      return "USER_INTERACTION_NONE";
    case CVSSv3_UserInteraction.USER_INTERACTION_REQUIRED:
      return "USER_INTERACTION_REQUIRED";
    case CVSSv3_UserInteraction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The Scope metric captures whether a vulnerability in one vulnerable
 * component impacts resources in components beyond its security scope.
 */
export enum CVSSv3_Scope {
  /** SCOPE_UNSPECIFIED - Invalid value. */
  SCOPE_UNSPECIFIED = 0,
  /**
   * SCOPE_UNCHANGED - An exploited vulnerability can only affect resources managed by the same
   * security authority.
   */
  SCOPE_UNCHANGED = 1,
  /**
   * SCOPE_CHANGED - An exploited vulnerability can affect resources beyond the security scope
   * managed by the security authority of the vulnerable component.
   */
  SCOPE_CHANGED = 2,
  UNRECOGNIZED = -1,
}

export function cVSSv3_ScopeFromJSON(object: any): CVSSv3_Scope {
  switch (object) {
    case 0:
    case "SCOPE_UNSPECIFIED":
      return CVSSv3_Scope.SCOPE_UNSPECIFIED;
    case 1:
    case "SCOPE_UNCHANGED":
      return CVSSv3_Scope.SCOPE_UNCHANGED;
    case 2:
    case "SCOPE_CHANGED":
      return CVSSv3_Scope.SCOPE_CHANGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_Scope.UNRECOGNIZED;
  }
}

export function cVSSv3_ScopeToJSON(object: CVSSv3_Scope): string {
  switch (object) {
    case CVSSv3_Scope.SCOPE_UNSPECIFIED:
      return "SCOPE_UNSPECIFIED";
    case CVSSv3_Scope.SCOPE_UNCHANGED:
      return "SCOPE_UNCHANGED";
    case CVSSv3_Scope.SCOPE_CHANGED:
      return "SCOPE_CHANGED";
    case CVSSv3_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The Impact metrics capture the effects of a successfully exploited
 * vulnerability on the component that suffers the worst outcome that is most
 * directly and predictably associated with the attack.
 */
export enum CVSSv3_Impact {
  /** IMPACT_UNSPECIFIED - Invalid value. */
  IMPACT_UNSPECIFIED = 0,
  /** IMPACT_HIGH - High impact. */
  IMPACT_HIGH = 1,
  /** IMPACT_LOW - Low impact. */
  IMPACT_LOW = 2,
  /** IMPACT_NONE - No impact. */
  IMPACT_NONE = 3,
  UNRECOGNIZED = -1,
}

export function cVSSv3_ImpactFromJSON(object: any): CVSSv3_Impact {
  switch (object) {
    case 0:
    case "IMPACT_UNSPECIFIED":
      return CVSSv3_Impact.IMPACT_UNSPECIFIED;
    case 1:
    case "IMPACT_HIGH":
      return CVSSv3_Impact.IMPACT_HIGH;
    case 2:
    case "IMPACT_LOW":
      return CVSSv3_Impact.IMPACT_LOW;
    case 3:
    case "IMPACT_NONE":
      return CVSSv3_Impact.IMPACT_NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CVSSv3_Impact.UNRECOGNIZED;
  }
}

export function cVSSv3_ImpactToJSON(object: CVSSv3_Impact): string {
  switch (object) {
    case CVSSv3_Impact.IMPACT_UNSPECIFIED:
      return "IMPACT_UNSPECIFIED";
    case CVSSv3_Impact.IMPACT_HIGH:
      return "IMPACT_HIGH";
    case CVSSv3_Impact.IMPACT_LOW:
      return "IMPACT_LOW";
    case CVSSv3_Impact.IMPACT_NONE:
      return "IMPACT_NONE";
    case CVSSv3_Impact.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseVulnerabilityReport(): VulnerabilityReport {
  return { name: "", vulnerabilities: [], updateTime: undefined };
}

export const VulnerabilityReport: MessageFns<VulnerabilityReport> = {
  encode(message: VulnerabilityReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.vulnerabilities) {
      VulnerabilityReport_Vulnerability.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vulnerabilities.push(VulnerabilityReport_Vulnerability.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReport {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vulnerabilities: globalThis.Array.isArray(object?.vulnerabilities)
        ? object.vulnerabilities.map((e: any) => VulnerabilityReport_Vulnerability.fromJSON(e))
        : [],
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: VulnerabilityReport): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vulnerabilities?.length) {
      obj.vulnerabilities = message.vulnerabilities.map((e) => VulnerabilityReport_Vulnerability.toJSON(e));
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityReport>): VulnerabilityReport {
    return VulnerabilityReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityReport>): VulnerabilityReport {
    const message = createBaseVulnerabilityReport();
    message.name = object.name ?? "";
    message.vulnerabilities = object.vulnerabilities?.map((e) => VulnerabilityReport_Vulnerability.fromPartial(e)) ||
      [];
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseVulnerabilityReport_Vulnerability(): VulnerabilityReport_Vulnerability {
  return {
    details: undefined,
    installedInventoryItemIds: [],
    availableInventoryItemIds: [],
    createTime: undefined,
    updateTime: undefined,
    items: [],
  };
}

export const VulnerabilityReport_Vulnerability: MessageFns<VulnerabilityReport_Vulnerability> = {
  encode(message: VulnerabilityReport_Vulnerability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.details !== undefined) {
      VulnerabilityReport_Vulnerability_Details.encode(message.details, writer.uint32(10).fork()).join();
    }
    for (const v of message.installedInventoryItemIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.availableInventoryItemIds) {
      writer.uint32(26).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    for (const v of message.items) {
      VulnerabilityReport_Vulnerability_Item.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReport_Vulnerability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReport_Vulnerability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = VulnerabilityReport_Vulnerability_Details.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.installedInventoryItemIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.availableInventoryItemIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.items.push(VulnerabilityReport_Vulnerability_Item.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReport_Vulnerability {
    return {
      details: isSet(object.details) ? VulnerabilityReport_Vulnerability_Details.fromJSON(object.details) : undefined,
      installedInventoryItemIds: globalThis.Array.isArray(object?.installedInventoryItemIds)
        ? object.installedInventoryItemIds.map((e: any) => globalThis.String(e))
        : [],
      availableInventoryItemIds: globalThis.Array.isArray(object?.availableInventoryItemIds)
        ? object.availableInventoryItemIds.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => VulnerabilityReport_Vulnerability_Item.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityReport_Vulnerability): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = VulnerabilityReport_Vulnerability_Details.toJSON(message.details);
    }
    if (message.installedInventoryItemIds?.length) {
      obj.installedInventoryItemIds = message.installedInventoryItemIds;
    }
    if (message.availableInventoryItemIds?.length) {
      obj.availableInventoryItemIds = message.availableInventoryItemIds;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => VulnerabilityReport_Vulnerability_Item.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityReport_Vulnerability>): VulnerabilityReport_Vulnerability {
    return VulnerabilityReport_Vulnerability.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityReport_Vulnerability>): VulnerabilityReport_Vulnerability {
    const message = createBaseVulnerabilityReport_Vulnerability();
    message.details = (object.details !== undefined && object.details !== null)
      ? VulnerabilityReport_Vulnerability_Details.fromPartial(object.details)
      : undefined;
    message.installedInventoryItemIds = object.installedInventoryItemIds?.map((e) => e) || [];
    message.availableInventoryItemIds = object.availableInventoryItemIds?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.items = object.items?.map((e) => VulnerabilityReport_Vulnerability_Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityReport_Vulnerability_Details(): VulnerabilityReport_Vulnerability_Details {
  return { cve: "", cvssV2Score: 0, cvssV3: undefined, severity: "", description: "", references: [] };
}

export const VulnerabilityReport_Vulnerability_Details: MessageFns<VulnerabilityReport_Vulnerability_Details> = {
  encode(message: VulnerabilityReport_Vulnerability_Details, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cve !== "") {
      writer.uint32(10).string(message.cve);
    }
    if (message.cvssV2Score !== 0) {
      writer.uint32(21).float(message.cvssV2Score);
    }
    if (message.cvssV3 !== undefined) {
      CVSSv3.encode(message.cvssV3, writer.uint32(26).fork()).join();
    }
    if (message.severity !== "") {
      writer.uint32(34).string(message.severity);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.references) {
      VulnerabilityReport_Vulnerability_Details_Reference.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReport_Vulnerability_Details {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReport_Vulnerability_Details();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cve = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.cvssV2Score = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cvssV3 = CVSSv3.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.severity = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.references.push(VulnerabilityReport_Vulnerability_Details_Reference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReport_Vulnerability_Details {
    return {
      cve: isSet(object.cve) ? globalThis.String(object.cve) : "",
      cvssV2Score: isSet(object.cvssV2Score) ? globalThis.Number(object.cvssV2Score) : 0,
      cvssV3: isSet(object.cvssV3) ? CVSSv3.fromJSON(object.cvssV3) : undefined,
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => VulnerabilityReport_Vulnerability_Details_Reference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityReport_Vulnerability_Details): unknown {
    const obj: any = {};
    if (message.cve !== "") {
      obj.cve = message.cve;
    }
    if (message.cvssV2Score !== 0) {
      obj.cvssV2Score = message.cvssV2Score;
    }
    if (message.cvssV3 !== undefined) {
      obj.cvssV3 = CVSSv3.toJSON(message.cvssV3);
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => VulnerabilityReport_Vulnerability_Details_Reference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityReport_Vulnerability_Details>): VulnerabilityReport_Vulnerability_Details {
    return VulnerabilityReport_Vulnerability_Details.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VulnerabilityReport_Vulnerability_Details>,
  ): VulnerabilityReport_Vulnerability_Details {
    const message = createBaseVulnerabilityReport_Vulnerability_Details();
    message.cve = object.cve ?? "";
    message.cvssV2Score = object.cvssV2Score ?? 0;
    message.cvssV3 = (object.cvssV3 !== undefined && object.cvssV3 !== null)
      ? CVSSv3.fromPartial(object.cvssV3)
      : undefined;
    message.severity = object.severity ?? "";
    message.description = object.description ?? "";
    message.references =
      object.references?.map((e) => VulnerabilityReport_Vulnerability_Details_Reference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityReport_Vulnerability_Details_Reference(): VulnerabilityReport_Vulnerability_Details_Reference {
  return { url: "", source: "" };
}

export const VulnerabilityReport_Vulnerability_Details_Reference: MessageFns<
  VulnerabilityReport_Vulnerability_Details_Reference
> = {
  encode(
    message: VulnerabilityReport_Vulnerability_Details_Reference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReport_Vulnerability_Details_Reference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReport_Vulnerability_Details_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReport_Vulnerability_Details_Reference {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: VulnerabilityReport_Vulnerability_Details_Reference): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(
    base?: DeepPartial<VulnerabilityReport_Vulnerability_Details_Reference>,
  ): VulnerabilityReport_Vulnerability_Details_Reference {
    return VulnerabilityReport_Vulnerability_Details_Reference.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<VulnerabilityReport_Vulnerability_Details_Reference>,
  ): VulnerabilityReport_Vulnerability_Details_Reference {
    const message = createBaseVulnerabilityReport_Vulnerability_Details_Reference();
    message.url = object.url ?? "";
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseVulnerabilityReport_Vulnerability_Item(): VulnerabilityReport_Vulnerability_Item {
  return { installedInventoryItemId: "", availableInventoryItemId: "", fixedCpeUri: "", upstreamFix: "" };
}

export const VulnerabilityReport_Vulnerability_Item: MessageFns<VulnerabilityReport_Vulnerability_Item> = {
  encode(message: VulnerabilityReport_Vulnerability_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.installedInventoryItemId !== "") {
      writer.uint32(10).string(message.installedInventoryItemId);
    }
    if (message.availableInventoryItemId !== "") {
      writer.uint32(18).string(message.availableInventoryItemId);
    }
    if (message.fixedCpeUri !== "") {
      writer.uint32(26).string(message.fixedCpeUri);
    }
    if (message.upstreamFix !== "") {
      writer.uint32(34).string(message.upstreamFix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReport_Vulnerability_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReport_Vulnerability_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.installedInventoryItemId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.availableInventoryItemId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fixedCpeUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.upstreamFix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReport_Vulnerability_Item {
    return {
      installedInventoryItemId: isSet(object.installedInventoryItemId)
        ? globalThis.String(object.installedInventoryItemId)
        : "",
      availableInventoryItemId: isSet(object.availableInventoryItemId)
        ? globalThis.String(object.availableInventoryItemId)
        : "",
      fixedCpeUri: isSet(object.fixedCpeUri) ? globalThis.String(object.fixedCpeUri) : "",
      upstreamFix: isSet(object.upstreamFix) ? globalThis.String(object.upstreamFix) : "",
    };
  },

  toJSON(message: VulnerabilityReport_Vulnerability_Item): unknown {
    const obj: any = {};
    if (message.installedInventoryItemId !== "") {
      obj.installedInventoryItemId = message.installedInventoryItemId;
    }
    if (message.availableInventoryItemId !== "") {
      obj.availableInventoryItemId = message.availableInventoryItemId;
    }
    if (message.fixedCpeUri !== "") {
      obj.fixedCpeUri = message.fixedCpeUri;
    }
    if (message.upstreamFix !== "") {
      obj.upstreamFix = message.upstreamFix;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerabilityReport_Vulnerability_Item>): VulnerabilityReport_Vulnerability_Item {
    return VulnerabilityReport_Vulnerability_Item.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerabilityReport_Vulnerability_Item>): VulnerabilityReport_Vulnerability_Item {
    const message = createBaseVulnerabilityReport_Vulnerability_Item();
    message.installedInventoryItemId = object.installedInventoryItemId ?? "";
    message.availableInventoryItemId = object.availableInventoryItemId ?? "";
    message.fixedCpeUri = object.fixedCpeUri ?? "";
    message.upstreamFix = object.upstreamFix ?? "";
    return message;
  },
};

function createBaseGetVulnerabilityReportRequest(): GetVulnerabilityReportRequest {
  return { name: "" };
}

export const GetVulnerabilityReportRequest: MessageFns<GetVulnerabilityReportRequest> = {
  encode(message: GetVulnerabilityReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVulnerabilityReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVulnerabilityReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVulnerabilityReportRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetVulnerabilityReportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVulnerabilityReportRequest>): GetVulnerabilityReportRequest {
    return GetVulnerabilityReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVulnerabilityReportRequest>): GetVulnerabilityReportRequest {
    const message = createBaseGetVulnerabilityReportRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListVulnerabilityReportsRequest(): ListVulnerabilityReportsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListVulnerabilityReportsRequest: MessageFns<ListVulnerabilityReportsRequest> = {
  encode(message: ListVulnerabilityReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVulnerabilityReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVulnerabilityReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVulnerabilityReportsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListVulnerabilityReportsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVulnerabilityReportsRequest>): ListVulnerabilityReportsRequest {
    return ListVulnerabilityReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVulnerabilityReportsRequest>): ListVulnerabilityReportsRequest {
    const message = createBaseListVulnerabilityReportsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListVulnerabilityReportsResponse(): ListVulnerabilityReportsResponse {
  return { vulnerabilityReports: [], nextPageToken: "" };
}

export const ListVulnerabilityReportsResponse: MessageFns<ListVulnerabilityReportsResponse> = {
  encode(message: ListVulnerabilityReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vulnerabilityReports) {
      VulnerabilityReport.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVulnerabilityReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVulnerabilityReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vulnerabilityReports.push(VulnerabilityReport.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVulnerabilityReportsResponse {
    return {
      vulnerabilityReports: globalThis.Array.isArray(object?.vulnerabilityReports)
        ? object.vulnerabilityReports.map((e: any) => VulnerabilityReport.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListVulnerabilityReportsResponse): unknown {
    const obj: any = {};
    if (message.vulnerabilityReports?.length) {
      obj.vulnerabilityReports = message.vulnerabilityReports.map((e) => VulnerabilityReport.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVulnerabilityReportsResponse>): ListVulnerabilityReportsResponse {
    return ListVulnerabilityReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVulnerabilityReportsResponse>): ListVulnerabilityReportsResponse {
    const message = createBaseListVulnerabilityReportsResponse();
    message.vulnerabilityReports = object.vulnerabilityReports?.map((e) => VulnerabilityReport.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCVSSv3(): CVSSv3 {
  return {
    baseScore: 0,
    exploitabilityScore: 0,
    impactScore: 0,
    attackVector: 0,
    attackComplexity: 0,
    privilegesRequired: 0,
    userInteraction: 0,
    scope: 0,
    confidentialityImpact: 0,
    integrityImpact: 0,
    availabilityImpact: 0,
  };
}

export const CVSSv3: MessageFns<CVSSv3> = {
  encode(message: CVSSv3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseScore !== 0) {
      writer.uint32(13).float(message.baseScore);
    }
    if (message.exploitabilityScore !== 0) {
      writer.uint32(21).float(message.exploitabilityScore);
    }
    if (message.impactScore !== 0) {
      writer.uint32(29).float(message.impactScore);
    }
    if (message.attackVector !== 0) {
      writer.uint32(40).int32(message.attackVector);
    }
    if (message.attackComplexity !== 0) {
      writer.uint32(48).int32(message.attackComplexity);
    }
    if (message.privilegesRequired !== 0) {
      writer.uint32(56).int32(message.privilegesRequired);
    }
    if (message.userInteraction !== 0) {
      writer.uint32(64).int32(message.userInteraction);
    }
    if (message.scope !== 0) {
      writer.uint32(72).int32(message.scope);
    }
    if (message.confidentialityImpact !== 0) {
      writer.uint32(80).int32(message.confidentialityImpact);
    }
    if (message.integrityImpact !== 0) {
      writer.uint32(88).int32(message.integrityImpact);
    }
    if (message.availabilityImpact !== 0) {
      writer.uint32(96).int32(message.availabilityImpact);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CVSSv3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCVSSv3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.baseScore = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.exploitabilityScore = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.impactScore = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.attackVector = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.attackComplexity = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.privilegesRequired = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.userInteraction = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.confidentialityImpact = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.integrityImpact = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.availabilityImpact = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CVSSv3 {
    return {
      baseScore: isSet(object.baseScore) ? globalThis.Number(object.baseScore) : 0,
      exploitabilityScore: isSet(object.exploitabilityScore) ? globalThis.Number(object.exploitabilityScore) : 0,
      impactScore: isSet(object.impactScore) ? globalThis.Number(object.impactScore) : 0,
      attackVector: isSet(object.attackVector) ? cVSSv3_AttackVectorFromJSON(object.attackVector) : 0,
      attackComplexity: isSet(object.attackComplexity) ? cVSSv3_AttackComplexityFromJSON(object.attackComplexity) : 0,
      privilegesRequired: isSet(object.privilegesRequired)
        ? cVSSv3_PrivilegesRequiredFromJSON(object.privilegesRequired)
        : 0,
      userInteraction: isSet(object.userInteraction) ? cVSSv3_UserInteractionFromJSON(object.userInteraction) : 0,
      scope: isSet(object.scope) ? cVSSv3_ScopeFromJSON(object.scope) : 0,
      confidentialityImpact: isSet(object.confidentialityImpact)
        ? cVSSv3_ImpactFromJSON(object.confidentialityImpact)
        : 0,
      integrityImpact: isSet(object.integrityImpact) ? cVSSv3_ImpactFromJSON(object.integrityImpact) : 0,
      availabilityImpact: isSet(object.availabilityImpact) ? cVSSv3_ImpactFromJSON(object.availabilityImpact) : 0,
    };
  },

  toJSON(message: CVSSv3): unknown {
    const obj: any = {};
    if (message.baseScore !== 0) {
      obj.baseScore = message.baseScore;
    }
    if (message.exploitabilityScore !== 0) {
      obj.exploitabilityScore = message.exploitabilityScore;
    }
    if (message.impactScore !== 0) {
      obj.impactScore = message.impactScore;
    }
    if (message.attackVector !== 0) {
      obj.attackVector = cVSSv3_AttackVectorToJSON(message.attackVector);
    }
    if (message.attackComplexity !== 0) {
      obj.attackComplexity = cVSSv3_AttackComplexityToJSON(message.attackComplexity);
    }
    if (message.privilegesRequired !== 0) {
      obj.privilegesRequired = cVSSv3_PrivilegesRequiredToJSON(message.privilegesRequired);
    }
    if (message.userInteraction !== 0) {
      obj.userInteraction = cVSSv3_UserInteractionToJSON(message.userInteraction);
    }
    if (message.scope !== 0) {
      obj.scope = cVSSv3_ScopeToJSON(message.scope);
    }
    if (message.confidentialityImpact !== 0) {
      obj.confidentialityImpact = cVSSv3_ImpactToJSON(message.confidentialityImpact);
    }
    if (message.integrityImpact !== 0) {
      obj.integrityImpact = cVSSv3_ImpactToJSON(message.integrityImpact);
    }
    if (message.availabilityImpact !== 0) {
      obj.availabilityImpact = cVSSv3_ImpactToJSON(message.availabilityImpact);
    }
    return obj;
  },

  create(base?: DeepPartial<CVSSv3>): CVSSv3 {
    return CVSSv3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CVSSv3>): CVSSv3 {
    const message = createBaseCVSSv3();
    message.baseScore = object.baseScore ?? 0;
    message.exploitabilityScore = object.exploitabilityScore ?? 0;
    message.impactScore = object.impactScore ?? 0;
    message.attackVector = object.attackVector ?? 0;
    message.attackComplexity = object.attackComplexity ?? 0;
    message.privilegesRequired = object.privilegesRequired ?? 0;
    message.userInteraction = object.userInteraction ?? 0;
    message.scope = object.scope ?? 0;
    message.confidentialityImpact = object.confidentialityImpact ?? 0;
    message.integrityImpact = object.integrityImpact ?? 0;
    message.availabilityImpact = object.availabilityImpact ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
