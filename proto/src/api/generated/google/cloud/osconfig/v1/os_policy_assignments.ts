// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/v1/os_policy_assignments.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { OSPolicy } from "./os_policy.js";
import { FixedOrPercent } from "./osconfig_common.js";

export const protobufPackage = "google.cloud.osconfig.v1";

/**
 * OS policy assignment is an API resource that is used to
 * apply a set of OS policies to a dynamically targeted group of Compute Engine
 * VM instances.
 *
 * An OS policy is used to define the desired state configuration for a
 * Compute Engine VM instance through a set of configuration resources that
 * provide capabilities such as installing or removing software packages, or
 * executing a script.
 *
 * For more information, see [OS policy and OS policy
 * assignment](https://cloud.google.com/compute/docs/os-configuration-management/working-with-os-policies).
 */
export interface OSPolicyAssignment {
  /**
   * Resource name.
   *
   * Format:
   * `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id}`
   *
   * This field is ignored when you create an OS policy assignment.
   */
  name: string;
  /**
   * OS policy assignment description.
   * Length of the description is limited to 1024 characters.
   */
  description: string;
  /** Required. List of OS policies to be applied to the VMs. */
  osPolicies: OSPolicy[];
  /** Required. Filter to select VMs. */
  instanceFilter:
    | OSPolicyAssignment_InstanceFilter
    | undefined;
  /**
   * Required. Rollout to deploy the OS policy assignment.
   * A rollout is triggered in the following situations:
   * 1) OSPolicyAssignment is created.
   * 2) OSPolicyAssignment is updated and the update contains changes to one of
   * the following fields:
   *    - instance_filter
   *    - os_policies
   * 3) OSPolicyAssignment is deleted.
   */
  rollout:
    | OSPolicyAssignment_Rollout
    | undefined;
  /**
   * Output only. The assignment revision ID
   * A new revision is committed whenever a rollout is triggered for a OS policy
   * assignment
   */
  revisionId: string;
  /** Output only. The timestamp that the revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /**
   * The etag for this OS policy assignment.
   * If this is provided on update, it must match the server's etag.
   */
  etag: string;
  /** Output only. OS policy assignment rollout state */
  rolloutState: OSPolicyAssignment_RolloutState;
  /**
   * Output only. Indicates that this revision has been successfully rolled out
   * in this zone and new VMs will be assigned OS policies from this revision.
   *
   * For a given OS policy assignment, there is only one revision with a value
   * of `true` for this field.
   */
  baseline: boolean;
  /** Output only. Indicates that this revision deletes the OS policy assignment. */
  deleted: boolean;
  /**
   * Output only. Indicates that reconciliation is in progress for the revision.
   * This value is `true` when the `rollout_state` is one of:
   * * IN_PROGRESS
   * * CANCELLING
   */
  reconciling: boolean;
  /**
   * Output only. Server generated unique id for the OS policy assignment
   * resource.
   */
  uid: string;
}

/** OS policy assignment rollout state */
export enum OSPolicyAssignment_RolloutState {
  /** ROLLOUT_STATE_UNSPECIFIED - Invalid value */
  ROLLOUT_STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - The rollout is in progress. */
  IN_PROGRESS = 1,
  /** CANCELLING - The rollout is being cancelled. */
  CANCELLING = 2,
  /** CANCELLED - The rollout is cancelled. */
  CANCELLED = 3,
  /** SUCCEEDED - The rollout has completed successfully. */
  SUCCEEDED = 4,
  UNRECOGNIZED = -1,
}

export function oSPolicyAssignment_RolloutStateFromJSON(object: any): OSPolicyAssignment_RolloutState {
  switch (object) {
    case 0:
    case "ROLLOUT_STATE_UNSPECIFIED":
      return OSPolicyAssignment_RolloutState.ROLLOUT_STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return OSPolicyAssignment_RolloutState.IN_PROGRESS;
    case 2:
    case "CANCELLING":
      return OSPolicyAssignment_RolloutState.CANCELLING;
    case 3:
    case "CANCELLED":
      return OSPolicyAssignment_RolloutState.CANCELLED;
    case 4:
    case "SUCCEEDED":
      return OSPolicyAssignment_RolloutState.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OSPolicyAssignment_RolloutState.UNRECOGNIZED;
  }
}

export function oSPolicyAssignment_RolloutStateToJSON(object: OSPolicyAssignment_RolloutState): string {
  switch (object) {
    case OSPolicyAssignment_RolloutState.ROLLOUT_STATE_UNSPECIFIED:
      return "ROLLOUT_STATE_UNSPECIFIED";
    case OSPolicyAssignment_RolloutState.IN_PROGRESS:
      return "IN_PROGRESS";
    case OSPolicyAssignment_RolloutState.CANCELLING:
      return "CANCELLING";
    case OSPolicyAssignment_RolloutState.CANCELLED:
      return "CANCELLED";
    case OSPolicyAssignment_RolloutState.SUCCEEDED:
      return "SUCCEEDED";
    case OSPolicyAssignment_RolloutState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Message representing label set.
 * * A label is a key value pair set for a VM.
 * * A LabelSet is a set of labels.
 * * Labels within a LabelSet are ANDed. In other words, a LabelSet is
 *   applicable for a VM only if it matches all the labels in the
 *   LabelSet.
 * * Example: A LabelSet with 2 labels: `env=prod` and `type=webserver` will
 *            only be applicable for those VMs with both labels
 *            present.
 */
export interface OSPolicyAssignment_LabelSet {
  /**
   * Labels are identified by key/value pairs in this map.
   * A VM should contain all the key/value pairs specified in this
   * map to be selected.
   */
  labels: { [key: string]: string };
}

export interface OSPolicyAssignment_LabelSet_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Filters to select target VMs for an assignment.
 *
 * If more than one filter criteria is specified below, a VM will be selected
 * if and only if it satisfies all of them.
 */
export interface OSPolicyAssignment_InstanceFilter {
  /**
   * Target all VMs in the project. If true, no other criteria is
   * permitted.
   */
  all: boolean;
  /**
   * List of label sets used for VM inclusion.
   *
   * If the list has more than one `LabelSet`, the VM is included if any
   * of the label sets are applicable for the VM.
   */
  inclusionLabels: OSPolicyAssignment_LabelSet[];
  /**
   * List of label sets used for VM exclusion.
   *
   * If the list has more than one label set, the VM is excluded if any
   * of the label sets are applicable for the VM.
   */
  exclusionLabels: OSPolicyAssignment_LabelSet[];
  /**
   * List of inventories to select VMs.
   *
   * A VM is selected if its inventory data matches at least one of the
   * following inventories.
   */
  inventories: OSPolicyAssignment_InstanceFilter_Inventory[];
}

/** VM inventory details. */
export interface OSPolicyAssignment_InstanceFilter_Inventory {
  /** Required. The OS short name */
  osShortName: string;
  /**
   * The OS version
   *
   * Prefix matches are supported if asterisk(*) is provided as the
   * last character. For example, to match all versions with a major
   * version of `7`, specify the following value for this field `7.*`
   *
   * An empty string matches all OS versions.
   */
  osVersion: string;
}

/**
 * Message to configure the rollout at the zonal level for the OS policy
 * assignment.
 */
export interface OSPolicyAssignment_Rollout {
  /**
   * Required. The maximum number (or percentage) of VMs per zone to disrupt
   * at any given moment.
   */
  disruptionBudget:
    | FixedOrPercent
    | undefined;
  /**
   * Required. This determines the minimum duration of time to wait after the
   * configuration changes are applied through the current rollout. A
   * VM continues to count towards the `disruption_budget` at least
   * until this duration of time has passed after configuration changes are
   * applied.
   */
  minWaitDuration: Duration | undefined;
}

/**
 * OS policy assignment operation metadata provided by OS policy assignment API
 * methods that return long running operations.
 */
export interface OSPolicyAssignmentOperationMetadata {
  /**
   * Reference to the `OSPolicyAssignment` API resource.
   *
   * Format:
   * `projects/{project_number}/locations/{location}/osPolicyAssignments/{os_policy_assignment_id@revision_id}`
   */
  osPolicyAssignment: string;
  /** The OS policy assignment API method. */
  apiMethod: OSPolicyAssignmentOperationMetadata_APIMethod;
  /** State of the rollout */
  rolloutState: OSPolicyAssignmentOperationMetadata_RolloutState;
  /** Rollout start time */
  rolloutStartTime:
    | Date
    | undefined;
  /** Rollout update time */
  rolloutUpdateTime: Date | undefined;
}

/** The OS policy assignment API method. */
export enum OSPolicyAssignmentOperationMetadata_APIMethod {
  /** API_METHOD_UNSPECIFIED - Invalid value */
  API_METHOD_UNSPECIFIED = 0,
  /** CREATE - Create OS policy assignment API method */
  CREATE = 1,
  /** UPDATE - Update OS policy assignment API method */
  UPDATE = 2,
  /** DELETE - Delete OS policy assignment API method */
  DELETE = 3,
  UNRECOGNIZED = -1,
}

export function oSPolicyAssignmentOperationMetadata_APIMethodFromJSON(
  object: any,
): OSPolicyAssignmentOperationMetadata_APIMethod {
  switch (object) {
    case 0:
    case "API_METHOD_UNSPECIFIED":
      return OSPolicyAssignmentOperationMetadata_APIMethod.API_METHOD_UNSPECIFIED;
    case 1:
    case "CREATE":
      return OSPolicyAssignmentOperationMetadata_APIMethod.CREATE;
    case 2:
    case "UPDATE":
      return OSPolicyAssignmentOperationMetadata_APIMethod.UPDATE;
    case 3:
    case "DELETE":
      return OSPolicyAssignmentOperationMetadata_APIMethod.DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OSPolicyAssignmentOperationMetadata_APIMethod.UNRECOGNIZED;
  }
}

export function oSPolicyAssignmentOperationMetadata_APIMethodToJSON(
  object: OSPolicyAssignmentOperationMetadata_APIMethod,
): string {
  switch (object) {
    case OSPolicyAssignmentOperationMetadata_APIMethod.API_METHOD_UNSPECIFIED:
      return "API_METHOD_UNSPECIFIED";
    case OSPolicyAssignmentOperationMetadata_APIMethod.CREATE:
      return "CREATE";
    case OSPolicyAssignmentOperationMetadata_APIMethod.UPDATE:
      return "UPDATE";
    case OSPolicyAssignmentOperationMetadata_APIMethod.DELETE:
      return "DELETE";
    case OSPolicyAssignmentOperationMetadata_APIMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** State of the rollout */
export enum OSPolicyAssignmentOperationMetadata_RolloutState {
  /** ROLLOUT_STATE_UNSPECIFIED - Invalid value */
  ROLLOUT_STATE_UNSPECIFIED = 0,
  /** IN_PROGRESS - The rollout is in progress. */
  IN_PROGRESS = 1,
  /** CANCELLING - The rollout is being cancelled. */
  CANCELLING = 2,
  /** CANCELLED - The rollout is cancelled. */
  CANCELLED = 3,
  /** SUCCEEDED - The rollout has completed successfully. */
  SUCCEEDED = 4,
  UNRECOGNIZED = -1,
}

export function oSPolicyAssignmentOperationMetadata_RolloutStateFromJSON(
  object: any,
): OSPolicyAssignmentOperationMetadata_RolloutState {
  switch (object) {
    case 0:
    case "ROLLOUT_STATE_UNSPECIFIED":
      return OSPolicyAssignmentOperationMetadata_RolloutState.ROLLOUT_STATE_UNSPECIFIED;
    case 1:
    case "IN_PROGRESS":
      return OSPolicyAssignmentOperationMetadata_RolloutState.IN_PROGRESS;
    case 2:
    case "CANCELLING":
      return OSPolicyAssignmentOperationMetadata_RolloutState.CANCELLING;
    case 3:
    case "CANCELLED":
      return OSPolicyAssignmentOperationMetadata_RolloutState.CANCELLED;
    case 4:
    case "SUCCEEDED":
      return OSPolicyAssignmentOperationMetadata_RolloutState.SUCCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OSPolicyAssignmentOperationMetadata_RolloutState.UNRECOGNIZED;
  }
}

export function oSPolicyAssignmentOperationMetadata_RolloutStateToJSON(
  object: OSPolicyAssignmentOperationMetadata_RolloutState,
): string {
  switch (object) {
    case OSPolicyAssignmentOperationMetadata_RolloutState.ROLLOUT_STATE_UNSPECIFIED:
      return "ROLLOUT_STATE_UNSPECIFIED";
    case OSPolicyAssignmentOperationMetadata_RolloutState.IN_PROGRESS:
      return "IN_PROGRESS";
    case OSPolicyAssignmentOperationMetadata_RolloutState.CANCELLING:
      return "CANCELLING";
    case OSPolicyAssignmentOperationMetadata_RolloutState.CANCELLED:
      return "CANCELLED";
    case OSPolicyAssignmentOperationMetadata_RolloutState.SUCCEEDED:
      return "SUCCEEDED";
    case OSPolicyAssignmentOperationMetadata_RolloutState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request message to create an OS policy assignment */
export interface CreateOSPolicyAssignmentRequest {
  /**
   * Required. The parent resource name in the form:
   * projects/{project}/locations/{location}
   */
  parent: string;
  /** Required. The OS policy assignment to be created. */
  osPolicyAssignment:
    | OSPolicyAssignment
    | undefined;
  /**
   * Required. The logical name of the OS policy assignment in the project
   * with the following restrictions:
   *
   * * Must contain only lowercase letters, numbers, and hyphens.
   * * Must start with a letter.
   * * Must be between 1-63 characters.
   * * Must end with a number or a letter.
   * * Must be unique within the project.
   */
  osPolicyAssignmentId: string;
}

/** A request message to update an OS policy assignment */
export interface UpdateOSPolicyAssignmentRequest {
  /** Required. The updated OS policy assignment. */
  osPolicyAssignment:
    | OSPolicyAssignment
    | undefined;
  /**
   * Optional. Field mask that controls which fields of the assignment should be
   * updated.
   */
  updateMask: string[] | undefined;
}

/** A request message to get an OS policy assignment */
export interface GetOSPolicyAssignmentRequest {
  /**
   * Required. The resource name of OS policy assignment.
   *
   * Format:
   * `projects/{project}/locations/{location}/osPolicyAssignments/{os_policy_assignment}@{revisionId}`
   */
  name: string;
}

/** A request message to list OS policy assignments for a parent resource */
export interface ListOSPolicyAssignmentsRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of assignments to return. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call to
   * `ListOSPolicyAssignments` that indicates where this listing should continue
   * from.
   */
  pageToken: string;
}

/** A response message for listing all assignments under given parent. */
export interface ListOSPolicyAssignmentsResponse {
  /** The list of assignments */
  osPolicyAssignments: OSPolicyAssignment[];
  /** The pagination token to retrieve the next page of OS policy assignments. */
  nextPageToken: string;
}

/** A request message to list revisions for a OS policy assignment */
export interface ListOSPolicyAssignmentRevisionsRequest {
  /** Required. The name of the OS policy assignment to list revisions for. */
  name: string;
  /** The maximum number of revisions to return. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call to
   * `ListOSPolicyAssignmentRevisions` that indicates where this listing should
   * continue from.
   */
  pageToken: string;
}

/** A response message for listing all revisions for a OS policy assignment. */
export interface ListOSPolicyAssignmentRevisionsResponse {
  /** The OS policy assignment revisions */
  osPolicyAssignments: OSPolicyAssignment[];
  /**
   * The pagination token to retrieve the next page of OS policy assignment
   * revisions.
   */
  nextPageToken: string;
}

/** A request message for deleting a OS policy assignment. */
export interface DeleteOSPolicyAssignmentRequest {
  /** Required. The name of the OS policy assignment to be deleted */
  name: string;
}

function createBaseOSPolicyAssignment(): OSPolicyAssignment {
  return {
    name: "",
    description: "",
    osPolicies: [],
    instanceFilter: undefined,
    rollout: undefined,
    revisionId: "",
    revisionCreateTime: undefined,
    etag: "",
    rolloutState: 0,
    baseline: false,
    deleted: false,
    reconciling: false,
    uid: "",
  };
}

export const OSPolicyAssignment: MessageFns<OSPolicyAssignment> = {
  encode(message: OSPolicyAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.osPolicies) {
      OSPolicy.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.instanceFilter !== undefined) {
      OSPolicyAssignment_InstanceFilter.encode(message.instanceFilter, writer.uint32(34).fork()).join();
    }
    if (message.rollout !== undefined) {
      OSPolicyAssignment_Rollout.encode(message.rollout, writer.uint32(42).fork()).join();
    }
    if (message.revisionId !== "") {
      writer.uint32(50).string(message.revisionId);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(58).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    if (message.rolloutState !== 0) {
      writer.uint32(72).int32(message.rolloutState);
    }
    if (message.baseline !== false) {
      writer.uint32(80).bool(message.baseline);
    }
    if (message.deleted !== false) {
      writer.uint32(88).bool(message.deleted);
    }
    if (message.reconciling !== false) {
      writer.uint32(96).bool(message.reconciling);
    }
    if (message.uid !== "") {
      writer.uint32(106).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osPolicies.push(OSPolicy.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instanceFilter = OSPolicyAssignment_InstanceFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rollout = OSPolicyAssignment_Rollout.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.rolloutState = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.baseline = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.reconciling = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      osPolicies: globalThis.Array.isArray(object?.osPolicies)
        ? object.osPolicies.map((e: any) => OSPolicy.fromJSON(e))
        : [],
      instanceFilter: isSet(object.instanceFilter)
        ? OSPolicyAssignment_InstanceFilter.fromJSON(object.instanceFilter)
        : undefined,
      rollout: isSet(object.rollout) ? OSPolicyAssignment_Rollout.fromJSON(object.rollout) : undefined,
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      rolloutState: isSet(object.rolloutState) ? oSPolicyAssignment_RolloutStateFromJSON(object.rolloutState) : 0,
      baseline: isSet(object.baseline) ? globalThis.Boolean(object.baseline) : false,
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      reconciling: isSet(object.reconciling) ? globalThis.Boolean(object.reconciling) : false,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
    };
  },

  toJSON(message: OSPolicyAssignment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.osPolicies?.length) {
      obj.osPolicies = message.osPolicies.map((e) => OSPolicy.toJSON(e));
    }
    if (message.instanceFilter !== undefined) {
      obj.instanceFilter = OSPolicyAssignment_InstanceFilter.toJSON(message.instanceFilter);
    }
    if (message.rollout !== undefined) {
      obj.rollout = OSPolicyAssignment_Rollout.toJSON(message.rollout);
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.rolloutState !== 0) {
      obj.rolloutState = oSPolicyAssignment_RolloutStateToJSON(message.rolloutState);
    }
    if (message.baseline !== false) {
      obj.baseline = message.baseline;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.reconciling !== false) {
      obj.reconciling = message.reconciling;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment>): OSPolicyAssignment {
    return OSPolicyAssignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignment>): OSPolicyAssignment {
    const message = createBaseOSPolicyAssignment();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.osPolicies = object.osPolicies?.map((e) => OSPolicy.fromPartial(e)) || [];
    message.instanceFilter = (object.instanceFilter !== undefined && object.instanceFilter !== null)
      ? OSPolicyAssignment_InstanceFilter.fromPartial(object.instanceFilter)
      : undefined;
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? OSPolicyAssignment_Rollout.fromPartial(object.rollout)
      : undefined;
    message.revisionId = object.revisionId ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.etag = object.etag ?? "";
    message.rolloutState = object.rolloutState ?? 0;
    message.baseline = object.baseline ?? false;
    message.deleted = object.deleted ?? false;
    message.reconciling = object.reconciling ?? false;
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseOSPolicyAssignment_LabelSet(): OSPolicyAssignment_LabelSet {
  return { labels: {} };
}

export const OSPolicyAssignment_LabelSet: MessageFns<OSPolicyAssignment_LabelSet> = {
  encode(message: OSPolicyAssignment_LabelSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      OSPolicyAssignment_LabelSet_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment_LabelSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment_LabelSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = OSPolicyAssignment_LabelSet_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment_LabelSet {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: OSPolicyAssignment_LabelSet): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment_LabelSet>): OSPolicyAssignment_LabelSet {
    return OSPolicyAssignment_LabelSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignment_LabelSet>): OSPolicyAssignment_LabelSet {
    const message = createBaseOSPolicyAssignment_LabelSet();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseOSPolicyAssignment_LabelSet_LabelsEntry(): OSPolicyAssignment_LabelSet_LabelsEntry {
  return { key: "", value: "" };
}

export const OSPolicyAssignment_LabelSet_LabelsEntry: MessageFns<OSPolicyAssignment_LabelSet_LabelsEntry> = {
  encode(message: OSPolicyAssignment_LabelSet_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment_LabelSet_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment_LabelSet_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment_LabelSet_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OSPolicyAssignment_LabelSet_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment_LabelSet_LabelsEntry>): OSPolicyAssignment_LabelSet_LabelsEntry {
    return OSPolicyAssignment_LabelSet_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignment_LabelSet_LabelsEntry>): OSPolicyAssignment_LabelSet_LabelsEntry {
    const message = createBaseOSPolicyAssignment_LabelSet_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOSPolicyAssignment_InstanceFilter(): OSPolicyAssignment_InstanceFilter {
  return { all: false, inclusionLabels: [], exclusionLabels: [], inventories: [] };
}

export const OSPolicyAssignment_InstanceFilter: MessageFns<OSPolicyAssignment_InstanceFilter> = {
  encode(message: OSPolicyAssignment_InstanceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== false) {
      writer.uint32(8).bool(message.all);
    }
    for (const v of message.inclusionLabels) {
      OSPolicyAssignment_LabelSet.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.exclusionLabels) {
      OSPolicyAssignment_LabelSet.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.inventories) {
      OSPolicyAssignment_InstanceFilter_Inventory.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment_InstanceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment_InstanceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.all = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inclusionLabels.push(OSPolicyAssignment_LabelSet.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusionLabels.push(OSPolicyAssignment_LabelSet.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inventories.push(OSPolicyAssignment_InstanceFilter_Inventory.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment_InstanceFilter {
    return {
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
      inclusionLabels: globalThis.Array.isArray(object?.inclusionLabels)
        ? object.inclusionLabels.map((e: any) => OSPolicyAssignment_LabelSet.fromJSON(e))
        : [],
      exclusionLabels: globalThis.Array.isArray(object?.exclusionLabels)
        ? object.exclusionLabels.map((e: any) => OSPolicyAssignment_LabelSet.fromJSON(e))
        : [],
      inventories: globalThis.Array.isArray(object?.inventories)
        ? object.inventories.map((e: any) => OSPolicyAssignment_InstanceFilter_Inventory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OSPolicyAssignment_InstanceFilter): unknown {
    const obj: any = {};
    if (message.all !== false) {
      obj.all = message.all;
    }
    if (message.inclusionLabels?.length) {
      obj.inclusionLabels = message.inclusionLabels.map((e) => OSPolicyAssignment_LabelSet.toJSON(e));
    }
    if (message.exclusionLabels?.length) {
      obj.exclusionLabels = message.exclusionLabels.map((e) => OSPolicyAssignment_LabelSet.toJSON(e));
    }
    if (message.inventories?.length) {
      obj.inventories = message.inventories.map((e) => OSPolicyAssignment_InstanceFilter_Inventory.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment_InstanceFilter>): OSPolicyAssignment_InstanceFilter {
    return OSPolicyAssignment_InstanceFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignment_InstanceFilter>): OSPolicyAssignment_InstanceFilter {
    const message = createBaseOSPolicyAssignment_InstanceFilter();
    message.all = object.all ?? false;
    message.inclusionLabels = object.inclusionLabels?.map((e) => OSPolicyAssignment_LabelSet.fromPartial(e)) || [];
    message.exclusionLabels = object.exclusionLabels?.map((e) => OSPolicyAssignment_LabelSet.fromPartial(e)) || [];
    message.inventories = object.inventories?.map((e) => OSPolicyAssignment_InstanceFilter_Inventory.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseOSPolicyAssignment_InstanceFilter_Inventory(): OSPolicyAssignment_InstanceFilter_Inventory {
  return { osShortName: "", osVersion: "" };
}

export const OSPolicyAssignment_InstanceFilter_Inventory: MessageFns<OSPolicyAssignment_InstanceFilter_Inventory> = {
  encode(
    message: OSPolicyAssignment_InstanceFilter_Inventory,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.osShortName !== "") {
      writer.uint32(10).string(message.osShortName);
    }
    if (message.osVersion !== "") {
      writer.uint32(18).string(message.osVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment_InstanceFilter_Inventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment_InstanceFilter_Inventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osShortName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment_InstanceFilter_Inventory {
    return {
      osShortName: isSet(object.osShortName) ? globalThis.String(object.osShortName) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
    };
  },

  toJSON(message: OSPolicyAssignment_InstanceFilter_Inventory): unknown {
    const obj: any = {};
    if (message.osShortName !== "") {
      obj.osShortName = message.osShortName;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment_InstanceFilter_Inventory>): OSPolicyAssignment_InstanceFilter_Inventory {
    return OSPolicyAssignment_InstanceFilter_Inventory.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<OSPolicyAssignment_InstanceFilter_Inventory>,
  ): OSPolicyAssignment_InstanceFilter_Inventory {
    const message = createBaseOSPolicyAssignment_InstanceFilter_Inventory();
    message.osShortName = object.osShortName ?? "";
    message.osVersion = object.osVersion ?? "";
    return message;
  },
};

function createBaseOSPolicyAssignment_Rollout(): OSPolicyAssignment_Rollout {
  return { disruptionBudget: undefined, minWaitDuration: undefined };
}

export const OSPolicyAssignment_Rollout: MessageFns<OSPolicyAssignment_Rollout> = {
  encode(message: OSPolicyAssignment_Rollout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disruptionBudget !== undefined) {
      FixedOrPercent.encode(message.disruptionBudget, writer.uint32(10).fork()).join();
    }
    if (message.minWaitDuration !== undefined) {
      Duration.encode(message.minWaitDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignment_Rollout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignment_Rollout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.disruptionBudget = FixedOrPercent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minWaitDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignment_Rollout {
    return {
      disruptionBudget: isSet(object.disruptionBudget) ? FixedOrPercent.fromJSON(object.disruptionBudget) : undefined,
      minWaitDuration: isSet(object.minWaitDuration) ? Duration.fromJSON(object.minWaitDuration) : undefined,
    };
  },

  toJSON(message: OSPolicyAssignment_Rollout): unknown {
    const obj: any = {};
    if (message.disruptionBudget !== undefined) {
      obj.disruptionBudget = FixedOrPercent.toJSON(message.disruptionBudget);
    }
    if (message.minWaitDuration !== undefined) {
      obj.minWaitDuration = Duration.toJSON(message.minWaitDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignment_Rollout>): OSPolicyAssignment_Rollout {
    return OSPolicyAssignment_Rollout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignment_Rollout>): OSPolicyAssignment_Rollout {
    const message = createBaseOSPolicyAssignment_Rollout();
    message.disruptionBudget = (object.disruptionBudget !== undefined && object.disruptionBudget !== null)
      ? FixedOrPercent.fromPartial(object.disruptionBudget)
      : undefined;
    message.minWaitDuration = (object.minWaitDuration !== undefined && object.minWaitDuration !== null)
      ? Duration.fromPartial(object.minWaitDuration)
      : undefined;
    return message;
  },
};

function createBaseOSPolicyAssignmentOperationMetadata(): OSPolicyAssignmentOperationMetadata {
  return {
    osPolicyAssignment: "",
    apiMethod: 0,
    rolloutState: 0,
    rolloutStartTime: undefined,
    rolloutUpdateTime: undefined,
  };
}

export const OSPolicyAssignmentOperationMetadata: MessageFns<OSPolicyAssignmentOperationMetadata> = {
  encode(message: OSPolicyAssignmentOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.osPolicyAssignment !== "") {
      writer.uint32(10).string(message.osPolicyAssignment);
    }
    if (message.apiMethod !== 0) {
      writer.uint32(16).int32(message.apiMethod);
    }
    if (message.rolloutState !== 0) {
      writer.uint32(24).int32(message.rolloutState);
    }
    if (message.rolloutStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rolloutStartTime), writer.uint32(34).fork()).join();
    }
    if (message.rolloutUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.rolloutUpdateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OSPolicyAssignmentOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOSPolicyAssignmentOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osPolicyAssignment = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.apiMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rolloutState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rolloutStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolloutUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OSPolicyAssignmentOperationMetadata {
    return {
      osPolicyAssignment: isSet(object.osPolicyAssignment) ? globalThis.String(object.osPolicyAssignment) : "",
      apiMethod: isSet(object.apiMethod) ? oSPolicyAssignmentOperationMetadata_APIMethodFromJSON(object.apiMethod) : 0,
      rolloutState: isSet(object.rolloutState)
        ? oSPolicyAssignmentOperationMetadata_RolloutStateFromJSON(object.rolloutState)
        : 0,
      rolloutStartTime: isSet(object.rolloutStartTime) ? fromJsonTimestamp(object.rolloutStartTime) : undefined,
      rolloutUpdateTime: isSet(object.rolloutUpdateTime) ? fromJsonTimestamp(object.rolloutUpdateTime) : undefined,
    };
  },

  toJSON(message: OSPolicyAssignmentOperationMetadata): unknown {
    const obj: any = {};
    if (message.osPolicyAssignment !== "") {
      obj.osPolicyAssignment = message.osPolicyAssignment;
    }
    if (message.apiMethod !== 0) {
      obj.apiMethod = oSPolicyAssignmentOperationMetadata_APIMethodToJSON(message.apiMethod);
    }
    if (message.rolloutState !== 0) {
      obj.rolloutState = oSPolicyAssignmentOperationMetadata_RolloutStateToJSON(message.rolloutState);
    }
    if (message.rolloutStartTime !== undefined) {
      obj.rolloutStartTime = message.rolloutStartTime.toISOString();
    }
    if (message.rolloutUpdateTime !== undefined) {
      obj.rolloutUpdateTime = message.rolloutUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OSPolicyAssignmentOperationMetadata>): OSPolicyAssignmentOperationMetadata {
    return OSPolicyAssignmentOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OSPolicyAssignmentOperationMetadata>): OSPolicyAssignmentOperationMetadata {
    const message = createBaseOSPolicyAssignmentOperationMetadata();
    message.osPolicyAssignment = object.osPolicyAssignment ?? "";
    message.apiMethod = object.apiMethod ?? 0;
    message.rolloutState = object.rolloutState ?? 0;
    message.rolloutStartTime = object.rolloutStartTime ?? undefined;
    message.rolloutUpdateTime = object.rolloutUpdateTime ?? undefined;
    return message;
  },
};

function createBaseCreateOSPolicyAssignmentRequest(): CreateOSPolicyAssignmentRequest {
  return { parent: "", osPolicyAssignment: undefined, osPolicyAssignmentId: "" };
}

export const CreateOSPolicyAssignmentRequest: MessageFns<CreateOSPolicyAssignmentRequest> = {
  encode(message: CreateOSPolicyAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.osPolicyAssignment !== undefined) {
      OSPolicyAssignment.encode(message.osPolicyAssignment, writer.uint32(18).fork()).join();
    }
    if (message.osPolicyAssignmentId !== "") {
      writer.uint32(26).string(message.osPolicyAssignmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOSPolicyAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOSPolicyAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osPolicyAssignment = OSPolicyAssignment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osPolicyAssignmentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOSPolicyAssignmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      osPolicyAssignment: isSet(object.osPolicyAssignment)
        ? OSPolicyAssignment.fromJSON(object.osPolicyAssignment)
        : undefined,
      osPolicyAssignmentId: isSet(object.osPolicyAssignmentId) ? globalThis.String(object.osPolicyAssignmentId) : "",
    };
  },

  toJSON(message: CreateOSPolicyAssignmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.osPolicyAssignment !== undefined) {
      obj.osPolicyAssignment = OSPolicyAssignment.toJSON(message.osPolicyAssignment);
    }
    if (message.osPolicyAssignmentId !== "") {
      obj.osPolicyAssignmentId = message.osPolicyAssignmentId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOSPolicyAssignmentRequest>): CreateOSPolicyAssignmentRequest {
    return CreateOSPolicyAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOSPolicyAssignmentRequest>): CreateOSPolicyAssignmentRequest {
    const message = createBaseCreateOSPolicyAssignmentRequest();
    message.parent = object.parent ?? "";
    message.osPolicyAssignment = (object.osPolicyAssignment !== undefined && object.osPolicyAssignment !== null)
      ? OSPolicyAssignment.fromPartial(object.osPolicyAssignment)
      : undefined;
    message.osPolicyAssignmentId = object.osPolicyAssignmentId ?? "";
    return message;
  },
};

function createBaseUpdateOSPolicyAssignmentRequest(): UpdateOSPolicyAssignmentRequest {
  return { osPolicyAssignment: undefined, updateMask: undefined };
}

export const UpdateOSPolicyAssignmentRequest: MessageFns<UpdateOSPolicyAssignmentRequest> = {
  encode(message: UpdateOSPolicyAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.osPolicyAssignment !== undefined) {
      OSPolicyAssignment.encode(message.osPolicyAssignment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOSPolicyAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOSPolicyAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osPolicyAssignment = OSPolicyAssignment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOSPolicyAssignmentRequest {
    return {
      osPolicyAssignment: isSet(object.osPolicyAssignment)
        ? OSPolicyAssignment.fromJSON(object.osPolicyAssignment)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateOSPolicyAssignmentRequest): unknown {
    const obj: any = {};
    if (message.osPolicyAssignment !== undefined) {
      obj.osPolicyAssignment = OSPolicyAssignment.toJSON(message.osPolicyAssignment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateOSPolicyAssignmentRequest>): UpdateOSPolicyAssignmentRequest {
    return UpdateOSPolicyAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateOSPolicyAssignmentRequest>): UpdateOSPolicyAssignmentRequest {
    const message = createBaseUpdateOSPolicyAssignmentRequest();
    message.osPolicyAssignment = (object.osPolicyAssignment !== undefined && object.osPolicyAssignment !== null)
      ? OSPolicyAssignment.fromPartial(object.osPolicyAssignment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetOSPolicyAssignmentRequest(): GetOSPolicyAssignmentRequest {
  return { name: "" };
}

export const GetOSPolicyAssignmentRequest: MessageFns<GetOSPolicyAssignmentRequest> = {
  encode(message: GetOSPolicyAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOSPolicyAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOSPolicyAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOSPolicyAssignmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOSPolicyAssignmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOSPolicyAssignmentRequest>): GetOSPolicyAssignmentRequest {
    return GetOSPolicyAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOSPolicyAssignmentRequest>): GetOSPolicyAssignmentRequest {
    const message = createBaseGetOSPolicyAssignmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOSPolicyAssignmentsRequest(): ListOSPolicyAssignmentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListOSPolicyAssignmentsRequest: MessageFns<ListOSPolicyAssignmentsRequest> = {
  encode(message: ListOSPolicyAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOSPolicyAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOSPolicyAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOSPolicyAssignmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListOSPolicyAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOSPolicyAssignmentsRequest>): ListOSPolicyAssignmentsRequest {
    return ListOSPolicyAssignmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOSPolicyAssignmentsRequest>): ListOSPolicyAssignmentsRequest {
    const message = createBaseListOSPolicyAssignmentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListOSPolicyAssignmentsResponse(): ListOSPolicyAssignmentsResponse {
  return { osPolicyAssignments: [], nextPageToken: "" };
}

export const ListOSPolicyAssignmentsResponse: MessageFns<ListOSPolicyAssignmentsResponse> = {
  encode(message: ListOSPolicyAssignmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.osPolicyAssignments) {
      OSPolicyAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOSPolicyAssignmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOSPolicyAssignmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osPolicyAssignments.push(OSPolicyAssignment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOSPolicyAssignmentsResponse {
    return {
      osPolicyAssignments: globalThis.Array.isArray(object?.osPolicyAssignments)
        ? object.osPolicyAssignments.map((e: any) => OSPolicyAssignment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListOSPolicyAssignmentsResponse): unknown {
    const obj: any = {};
    if (message.osPolicyAssignments?.length) {
      obj.osPolicyAssignments = message.osPolicyAssignments.map((e) => OSPolicyAssignment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOSPolicyAssignmentsResponse>): ListOSPolicyAssignmentsResponse {
    return ListOSPolicyAssignmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOSPolicyAssignmentsResponse>): ListOSPolicyAssignmentsResponse {
    const message = createBaseListOSPolicyAssignmentsResponse();
    message.osPolicyAssignments = object.osPolicyAssignments?.map((e) => OSPolicyAssignment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListOSPolicyAssignmentRevisionsRequest(): ListOSPolicyAssignmentRevisionsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListOSPolicyAssignmentRevisionsRequest: MessageFns<ListOSPolicyAssignmentRevisionsRequest> = {
  encode(message: ListOSPolicyAssignmentRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOSPolicyAssignmentRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOSPolicyAssignmentRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOSPolicyAssignmentRevisionsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListOSPolicyAssignmentRevisionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOSPolicyAssignmentRevisionsRequest>): ListOSPolicyAssignmentRevisionsRequest {
    return ListOSPolicyAssignmentRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOSPolicyAssignmentRevisionsRequest>): ListOSPolicyAssignmentRevisionsRequest {
    const message = createBaseListOSPolicyAssignmentRevisionsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListOSPolicyAssignmentRevisionsResponse(): ListOSPolicyAssignmentRevisionsResponse {
  return { osPolicyAssignments: [], nextPageToken: "" };
}

export const ListOSPolicyAssignmentRevisionsResponse: MessageFns<ListOSPolicyAssignmentRevisionsResponse> = {
  encode(message: ListOSPolicyAssignmentRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.osPolicyAssignments) {
      OSPolicyAssignment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOSPolicyAssignmentRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOSPolicyAssignmentRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osPolicyAssignments.push(OSPolicyAssignment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOSPolicyAssignmentRevisionsResponse {
    return {
      osPolicyAssignments: globalThis.Array.isArray(object?.osPolicyAssignments)
        ? object.osPolicyAssignments.map((e: any) => OSPolicyAssignment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListOSPolicyAssignmentRevisionsResponse): unknown {
    const obj: any = {};
    if (message.osPolicyAssignments?.length) {
      obj.osPolicyAssignments = message.osPolicyAssignments.map((e) => OSPolicyAssignment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOSPolicyAssignmentRevisionsResponse>): ListOSPolicyAssignmentRevisionsResponse {
    return ListOSPolicyAssignmentRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOSPolicyAssignmentRevisionsResponse>): ListOSPolicyAssignmentRevisionsResponse {
    const message = createBaseListOSPolicyAssignmentRevisionsResponse();
    message.osPolicyAssignments = object.osPolicyAssignments?.map((e) => OSPolicyAssignment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteOSPolicyAssignmentRequest(): DeleteOSPolicyAssignmentRequest {
  return { name: "" };
}

export const DeleteOSPolicyAssignmentRequest: MessageFns<DeleteOSPolicyAssignmentRequest> = {
  encode(message: DeleteOSPolicyAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOSPolicyAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOSPolicyAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOSPolicyAssignmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteOSPolicyAssignmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteOSPolicyAssignmentRequest>): DeleteOSPolicyAssignmentRequest {
    return DeleteOSPolicyAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteOSPolicyAssignmentRequest>): DeleteOSPolicyAssignmentRequest {
    const message = createBaseDeleteOSPolicyAssignmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
