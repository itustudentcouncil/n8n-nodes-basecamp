// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkconnectivity/v1/policy_based_routing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.networkconnectivity.v1";

/**
 * Policy Based Routes (PBR) are more powerful routes that allows GCP customers
 * to route their L4 network traffic based on not just destination IP, but also
 * source IP, protocol and more. A PBR always take precedence when it conflicts
 * with other types of routes.
 * Next id: 22
 */
export interface PolicyBasedRoute {
  /** Optional. VM instances to which this policy based route applies to. */
  virtualMachine?:
    | PolicyBasedRoute_VirtualMachine
    | undefined;
  /** Optional. The interconnect attachments to which this route applies to. */
  interconnectAttachment?:
    | PolicyBasedRoute_InterconnectAttachment
    | undefined;
  /**
   * Optional. The IP of a global access enabled L4 ILB that should be the
   * next hop to handle matching packets. For this version, only
   * next_hop_ilb_ip is supported.
   */
  nextHopIlbIp?:
    | string
    | undefined;
  /**
   * Optional. Other routes that will be referenced to determine the next hop
   * of the packet.
   */
  nextHopOtherRoutes?:
    | PolicyBasedRoute_OtherRoutes
    | undefined;
  /**
   * Immutable. A unique name of the resource in the form of
   * `projects/{project_number}/locations/global/PolicyBasedRoutes/{policy_based_route_id}`
   */
  name: string;
  /** Output only. Time when the PolicyBasedRoute was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when the PolicyBasedRoute was updated. */
  updateTime:
    | Date
    | undefined;
  /** User-defined labels. */
  labels: { [key: string]: string };
  /**
   * Optional. An optional description of this resource. Provide this field when
   * you create the resource.
   */
  description: string;
  /**
   * Required. Fully-qualified URL of the network that this route applies to.
   * e.g. projects/my-project/global/networks/my-network.
   */
  network: string;
  /** Required. The filter to match L4 traffic. */
  filter:
    | PolicyBasedRoute_Filter
    | undefined;
  /**
   * Optional. The priority of this policy based route. Priority is used to
   * break ties in cases where there are more than one matching policy based
   * routes found. In cases where multiple policy based routes are matched, the
   * one with the lowest-numbered priority value wins. The default value is
   * 1000. The priority value must be from 1 to 65535, inclusive.
   */
  priority: number;
  /**
   * Output only. If potential misconfigurations are detected for this route,
   * this field will be populated with warning messages.
   */
  warnings: PolicyBasedRoute_Warnings[];
  /** Output only. Server-defined fully-qualified URL for this resource. */
  selfLink: string;
  /**
   * Output only. Type of this resource. Always
   * networkconnectivity#policyBasedRoute for Policy Based Route resources.
   */
  kind: string;
}

/** The other routing cases. */
export enum PolicyBasedRoute_OtherRoutes {
  /** OTHER_ROUTES_UNSPECIFIED - Default value. */
  OTHER_ROUTES_UNSPECIFIED = 0,
  /**
   * DEFAULT_ROUTING - Use the routes from the default routing tables (system-generated routes,
   * custom routes, peering route) to determine the next hop. This will
   * effectively exclude matching packets being applied on other PBRs with a
   * lower priority.
   */
  DEFAULT_ROUTING = 1,
  UNRECOGNIZED = -1,
}

export function policyBasedRoute_OtherRoutesFromJSON(object: any): PolicyBasedRoute_OtherRoutes {
  switch (object) {
    case 0:
    case "OTHER_ROUTES_UNSPECIFIED":
      return PolicyBasedRoute_OtherRoutes.OTHER_ROUTES_UNSPECIFIED;
    case 1:
    case "DEFAULT_ROUTING":
      return PolicyBasedRoute_OtherRoutes.DEFAULT_ROUTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyBasedRoute_OtherRoutes.UNRECOGNIZED;
  }
}

export function policyBasedRoute_OtherRoutesToJSON(object: PolicyBasedRoute_OtherRoutes): string {
  switch (object) {
    case PolicyBasedRoute_OtherRoutes.OTHER_ROUTES_UNSPECIFIED:
      return "OTHER_ROUTES_UNSPECIFIED";
    case PolicyBasedRoute_OtherRoutes.DEFAULT_ROUTING:
      return "DEFAULT_ROUTING";
    case PolicyBasedRoute_OtherRoutes.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VM instances to which this policy based route applies to. */
export interface PolicyBasedRoute_VirtualMachine {
  /**
   * Optional. A list of VM instance tags to which this policy based route
   * applies to. VM instances that have ANY of tags specified here will
   * install this PBR.
   */
  tags: string[];
}

/** InterconnectAttachment to which this route applies to. */
export interface PolicyBasedRoute_InterconnectAttachment {
  /**
   * Optional. Cloud region to install this policy based route on interconnect
   * attachment. Use `all` to install it on all interconnect attachments.
   */
  region: string;
}

/** Filter matches L4 traffic. */
export interface PolicyBasedRoute_Filter {
  /**
   * Optional. The IP protocol that this policy based route applies to. Valid
   * values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
   */
  ipProtocol: string;
  /**
   * Optional. The source IP range of outgoing packets that this policy based
   * route applies to. Default is "0.0.0.0/0" if protocol version is IPv4.
   */
  srcRange: string;
  /**
   * Optional. The destination IP range of outgoing packets that this policy
   * based route applies to. Default is "0.0.0.0/0" if protocol version is
   * IPv4.
   */
  destRange: string;
  /**
   * Required. Internet protocol versions this policy based route applies to.
   * For this version, only IPV4 is supported.
   */
  protocolVersion: PolicyBasedRoute_Filter_ProtocolVersion;
}

/** The internet protocol version. */
export enum PolicyBasedRoute_Filter_ProtocolVersion {
  /** PROTOCOL_VERSION_UNSPECIFIED - Default value. */
  PROTOCOL_VERSION_UNSPECIFIED = 0,
  /** IPV4 - The PBR is for IPv4 internet protocol traffic. */
  IPV4 = 1,
  UNRECOGNIZED = -1,
}

export function policyBasedRoute_Filter_ProtocolVersionFromJSON(object: any): PolicyBasedRoute_Filter_ProtocolVersion {
  switch (object) {
    case 0:
    case "PROTOCOL_VERSION_UNSPECIFIED":
      return PolicyBasedRoute_Filter_ProtocolVersion.PROTOCOL_VERSION_UNSPECIFIED;
    case 1:
    case "IPV4":
      return PolicyBasedRoute_Filter_ProtocolVersion.IPV4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyBasedRoute_Filter_ProtocolVersion.UNRECOGNIZED;
  }
}

export function policyBasedRoute_Filter_ProtocolVersionToJSON(object: PolicyBasedRoute_Filter_ProtocolVersion): string {
  switch (object) {
    case PolicyBasedRoute_Filter_ProtocolVersion.PROTOCOL_VERSION_UNSPECIFIED:
      return "PROTOCOL_VERSION_UNSPECIFIED";
    case PolicyBasedRoute_Filter_ProtocolVersion.IPV4:
      return "IPV4";
    case PolicyBasedRoute_Filter_ProtocolVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Informational warning message. */
export interface PolicyBasedRoute_Warnings {
  /** Output only. A warning code, if applicable. */
  code: PolicyBasedRoute_Warnings_Code;
  /**
   * Output only. Metadata about this warning in key: value format. The key
   * should provides more detail on the warning being returned. For example,
   * for warnings where there are no results in a list request for a
   * particular zone, this key might be scope and the key value might be the
   * zone name. Other examples might be a key indicating a deprecated resource
   * and a suggested replacement.
   */
  data: { [key: string]: string };
  /** Output only. A human-readable description of the warning code. */
  warningMessage: string;
}

/**
 * Warning code for Policy Based Routing. Expect to add values in the
 * future.
 */
export enum PolicyBasedRoute_Warnings_Code {
  /** WARNING_UNSPECIFIED - Default value. */
  WARNING_UNSPECIFIED = 0,
  /**
   * RESOURCE_NOT_ACTIVE - The policy based route is not active and functioning. Common causes are
   * the dependent network was deleted or the resource project was turned
   * off.
   */
  RESOURCE_NOT_ACTIVE = 1,
  /**
   * RESOURCE_BEING_MODIFIED - The policy based route is being modified (e.g. created/deleted) at this
   * time.
   */
  RESOURCE_BEING_MODIFIED = 2,
  UNRECOGNIZED = -1,
}

export function policyBasedRoute_Warnings_CodeFromJSON(object: any): PolicyBasedRoute_Warnings_Code {
  switch (object) {
    case 0:
    case "WARNING_UNSPECIFIED":
      return PolicyBasedRoute_Warnings_Code.WARNING_UNSPECIFIED;
    case 1:
    case "RESOURCE_NOT_ACTIVE":
      return PolicyBasedRoute_Warnings_Code.RESOURCE_NOT_ACTIVE;
    case 2:
    case "RESOURCE_BEING_MODIFIED":
      return PolicyBasedRoute_Warnings_Code.RESOURCE_BEING_MODIFIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyBasedRoute_Warnings_Code.UNRECOGNIZED;
  }
}

export function policyBasedRoute_Warnings_CodeToJSON(object: PolicyBasedRoute_Warnings_Code): string {
  switch (object) {
    case PolicyBasedRoute_Warnings_Code.WARNING_UNSPECIFIED:
      return "WARNING_UNSPECIFIED";
    case PolicyBasedRoute_Warnings_Code.RESOURCE_NOT_ACTIVE:
      return "RESOURCE_NOT_ACTIVE";
    case PolicyBasedRoute_Warnings_Code.RESOURCE_BEING_MODIFIED:
      return "RESOURCE_BEING_MODIFIED";
    case PolicyBasedRoute_Warnings_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PolicyBasedRoute_Warnings_DataEntry {
  key: string;
  value: string;
}

export interface PolicyBasedRoute_LabelsEntry {
  key: string;
  value: string;
}

/** Request for [PolicyBasedRouting.ListPolicyBasedRoutes][] method. */
export interface ListPolicyBasedRoutesRequest {
  /** Required. The parent resource's name. */
  parent: string;
  /** The maximum number of results per page that should be returned. */
  pageSize: number;
  /** The page token. */
  pageToken: string;
  /** A filter expression that filters the results listed in the response. */
  filter: string;
  /** Sort the results by a certain order. */
  orderBy: string;
}

/** Response for [PolicyBasedRouting.ListPolicyBasedRoutes][] method. */
export interface ListPolicyBasedRoutesResponse {
  /** Policy based routes to be returned. */
  policyBasedRoutes: PolicyBasedRoute[];
  /**
   * The next pagination token in the List response. It should be used as
   * page_token for the following request. An empty value means no more result.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for [PolicyBasedRouting.GetPolicyBasedRoute][] method. */
export interface GetPolicyBasedRouteRequest {
  /** Required. Name of the PolicyBasedRoute resource to get. */
  name: string;
}

/** Request for [PolicyBasedRouting.CreatePolicyBasedRoute][] method. */
export interface CreatePolicyBasedRouteRequest {
  /** Required. The parent resource's name of the PolicyBasedRoute. */
  parent: string;
  /** Required. Unique id for the Policy Based Route to create. */
  policyBasedRouteId: string;
  /** Required. Initial values for a new Policy Based Route. */
  policyBasedRoute:
    | PolicyBasedRoute
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request for [PolicyBasedRouting.DeletePolicyBasedRoute][] method. */
export interface DeletePolicyBasedRouteRequest {
  /** Required. Name of the PolicyBasedRoute resource to delete. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

function createBasePolicyBasedRoute(): PolicyBasedRoute {
  return {
    virtualMachine: undefined,
    interconnectAttachment: undefined,
    nextHopIlbIp: undefined,
    nextHopOtherRoutes: undefined,
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    network: "",
    filter: undefined,
    priority: 0,
    warnings: [],
    selfLink: "",
    kind: "",
  };
}

export const PolicyBasedRoute: MessageFns<PolicyBasedRoute> = {
  encode(message: PolicyBasedRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.virtualMachine !== undefined) {
      PolicyBasedRoute_VirtualMachine.encode(message.virtualMachine, writer.uint32(146).fork()).join();
    }
    if (message.interconnectAttachment !== undefined) {
      PolicyBasedRoute_InterconnectAttachment.encode(message.interconnectAttachment, writer.uint32(74).fork()).join();
    }
    if (message.nextHopIlbIp !== undefined) {
      writer.uint32(98).string(message.nextHopIlbIp);
    }
    if (message.nextHopOtherRoutes !== undefined) {
      writer.uint32(168).int32(message.nextHopOtherRoutes);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      PolicyBasedRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    if (message.filter !== undefined) {
      PolicyBasedRoute_Filter.encode(message.filter, writer.uint32(82).fork()).join();
    }
    if (message.priority !== 0) {
      writer.uint32(88).int32(message.priority);
    }
    for (const v of message.warnings) {
      PolicyBasedRoute_Warnings.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.selfLink !== "") {
      writer.uint32(122).string(message.selfLink);
    }
    if (message.kind !== "") {
      writer.uint32(130).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 18:
          if (tag !== 146) {
            break;
          }

          message.virtualMachine = PolicyBasedRoute_VirtualMachine.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.interconnectAttachment = PolicyBasedRoute_InterconnectAttachment.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.nextHopIlbIp = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.nextHopOtherRoutes = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = PolicyBasedRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.filter = PolicyBasedRoute_Filter.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.warnings.push(PolicyBasedRoute_Warnings.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute {
    return {
      virtualMachine: isSet(object.virtualMachine)
        ? PolicyBasedRoute_VirtualMachine.fromJSON(object.virtualMachine)
        : undefined,
      interconnectAttachment: isSet(object.interconnectAttachment)
        ? PolicyBasedRoute_InterconnectAttachment.fromJSON(object.interconnectAttachment)
        : undefined,
      nextHopIlbIp: isSet(object.nextHopIlbIp) ? globalThis.String(object.nextHopIlbIp) : undefined,
      nextHopOtherRoutes: isSet(object.nextHopOtherRoutes)
        ? policyBasedRoute_OtherRoutesFromJSON(object.nextHopOtherRoutes)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      filter: isSet(object.filter) ? PolicyBasedRoute_Filter.fromJSON(object.filter) : undefined,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => PolicyBasedRoute_Warnings.fromJSON(e))
        : [],
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: PolicyBasedRoute): unknown {
    const obj: any = {};
    if (message.virtualMachine !== undefined) {
      obj.virtualMachine = PolicyBasedRoute_VirtualMachine.toJSON(message.virtualMachine);
    }
    if (message.interconnectAttachment !== undefined) {
      obj.interconnectAttachment = PolicyBasedRoute_InterconnectAttachment.toJSON(message.interconnectAttachment);
    }
    if (message.nextHopIlbIp !== undefined) {
      obj.nextHopIlbIp = message.nextHopIlbIp;
    }
    if (message.nextHopOtherRoutes !== undefined) {
      obj.nextHopOtherRoutes = policyBasedRoute_OtherRoutesToJSON(message.nextHopOtherRoutes);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.filter !== undefined) {
      obj.filter = PolicyBasedRoute_Filter.toJSON(message.filter);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => PolicyBasedRoute_Warnings.toJSON(e));
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute>): PolicyBasedRoute {
    return PolicyBasedRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute>): PolicyBasedRoute {
    const message = createBasePolicyBasedRoute();
    message.virtualMachine = (object.virtualMachine !== undefined && object.virtualMachine !== null)
      ? PolicyBasedRoute_VirtualMachine.fromPartial(object.virtualMachine)
      : undefined;
    message.interconnectAttachment =
      (object.interconnectAttachment !== undefined && object.interconnectAttachment !== null)
        ? PolicyBasedRoute_InterconnectAttachment.fromPartial(object.interconnectAttachment)
        : undefined;
    message.nextHopIlbIp = object.nextHopIlbIp ?? undefined;
    message.nextHopOtherRoutes = object.nextHopOtherRoutes ?? undefined;
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.network = object.network ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? PolicyBasedRoute_Filter.fromPartial(object.filter)
      : undefined;
    message.priority = object.priority ?? 0;
    message.warnings = object.warnings?.map((e) => PolicyBasedRoute_Warnings.fromPartial(e)) || [];
    message.selfLink = object.selfLink ?? "";
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBasePolicyBasedRoute_VirtualMachine(): PolicyBasedRoute_VirtualMachine {
  return { tags: [] };
}

export const PolicyBasedRoute_VirtualMachine: MessageFns<PolicyBasedRoute_VirtualMachine> = {
  encode(message: PolicyBasedRoute_VirtualMachine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_VirtualMachine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_VirtualMachine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_VirtualMachine {
    return { tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: PolicyBasedRoute_VirtualMachine): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_VirtualMachine>): PolicyBasedRoute_VirtualMachine {
    return PolicyBasedRoute_VirtualMachine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_VirtualMachine>): PolicyBasedRoute_VirtualMachine {
    const message = createBasePolicyBasedRoute_VirtualMachine();
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBasePolicyBasedRoute_InterconnectAttachment(): PolicyBasedRoute_InterconnectAttachment {
  return { region: "" };
}

export const PolicyBasedRoute_InterconnectAttachment: MessageFns<PolicyBasedRoute_InterconnectAttachment> = {
  encode(message: PolicyBasedRoute_InterconnectAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== "") {
      writer.uint32(10).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_InterconnectAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_InterconnectAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_InterconnectAttachment {
    return { region: isSet(object.region) ? globalThis.String(object.region) : "" };
  },

  toJSON(message: PolicyBasedRoute_InterconnectAttachment): unknown {
    const obj: any = {};
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_InterconnectAttachment>): PolicyBasedRoute_InterconnectAttachment {
    return PolicyBasedRoute_InterconnectAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_InterconnectAttachment>): PolicyBasedRoute_InterconnectAttachment {
    const message = createBasePolicyBasedRoute_InterconnectAttachment();
    message.region = object.region ?? "";
    return message;
  },
};

function createBasePolicyBasedRoute_Filter(): PolicyBasedRoute_Filter {
  return { ipProtocol: "", srcRange: "", destRange: "", protocolVersion: 0 };
}

export const PolicyBasedRoute_Filter: MessageFns<PolicyBasedRoute_Filter> = {
  encode(message: PolicyBasedRoute_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipProtocol !== "") {
      writer.uint32(10).string(message.ipProtocol);
    }
    if (message.srcRange !== "") {
      writer.uint32(18).string(message.srcRange);
    }
    if (message.destRange !== "") {
      writer.uint32(26).string(message.destRange);
    }
    if (message.protocolVersion !== 0) {
      writer.uint32(48).int32(message.protocolVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipProtocol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.srcRange = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destRange = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.protocolVersion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_Filter {
    return {
      ipProtocol: isSet(object.ipProtocol) ? globalThis.String(object.ipProtocol) : "",
      srcRange: isSet(object.srcRange) ? globalThis.String(object.srcRange) : "",
      destRange: isSet(object.destRange) ? globalThis.String(object.destRange) : "",
      protocolVersion: isSet(object.protocolVersion)
        ? policyBasedRoute_Filter_ProtocolVersionFromJSON(object.protocolVersion)
        : 0,
    };
  },

  toJSON(message: PolicyBasedRoute_Filter): unknown {
    const obj: any = {};
    if (message.ipProtocol !== "") {
      obj.ipProtocol = message.ipProtocol;
    }
    if (message.srcRange !== "") {
      obj.srcRange = message.srcRange;
    }
    if (message.destRange !== "") {
      obj.destRange = message.destRange;
    }
    if (message.protocolVersion !== 0) {
      obj.protocolVersion = policyBasedRoute_Filter_ProtocolVersionToJSON(message.protocolVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_Filter>): PolicyBasedRoute_Filter {
    return PolicyBasedRoute_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_Filter>): PolicyBasedRoute_Filter {
    const message = createBasePolicyBasedRoute_Filter();
    message.ipProtocol = object.ipProtocol ?? "";
    message.srcRange = object.srcRange ?? "";
    message.destRange = object.destRange ?? "";
    message.protocolVersion = object.protocolVersion ?? 0;
    return message;
  },
};

function createBasePolicyBasedRoute_Warnings(): PolicyBasedRoute_Warnings {
  return { code: 0, data: {}, warningMessage: "" };
}

export const PolicyBasedRoute_Warnings: MessageFns<PolicyBasedRoute_Warnings> = {
  encode(message: PolicyBasedRoute_Warnings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    Object.entries(message.data).forEach(([key, value]) => {
      PolicyBasedRoute_Warnings_DataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.warningMessage !== "") {
      writer.uint32(26).string(message.warningMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_Warnings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_Warnings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = PolicyBasedRoute_Warnings_DataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.data[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.warningMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_Warnings {
    return {
      code: isSet(object.code) ? policyBasedRoute_Warnings_CodeFromJSON(object.code) : 0,
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      warningMessage: isSet(object.warningMessage) ? globalThis.String(object.warningMessage) : "",
    };
  },

  toJSON(message: PolicyBasedRoute_Warnings): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = policyBasedRoute_Warnings_CodeToJSON(message.code);
    }
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    if (message.warningMessage !== "") {
      obj.warningMessage = message.warningMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_Warnings>): PolicyBasedRoute_Warnings {
    return PolicyBasedRoute_Warnings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_Warnings>): PolicyBasedRoute_Warnings {
    const message = createBasePolicyBasedRoute_Warnings();
    message.code = object.code ?? 0;
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.warningMessage = object.warningMessage ?? "";
    return message;
  },
};

function createBasePolicyBasedRoute_Warnings_DataEntry(): PolicyBasedRoute_Warnings_DataEntry {
  return { key: "", value: "" };
}

export const PolicyBasedRoute_Warnings_DataEntry: MessageFns<PolicyBasedRoute_Warnings_DataEntry> = {
  encode(message: PolicyBasedRoute_Warnings_DataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_Warnings_DataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_Warnings_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_Warnings_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PolicyBasedRoute_Warnings_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_Warnings_DataEntry>): PolicyBasedRoute_Warnings_DataEntry {
    return PolicyBasedRoute_Warnings_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_Warnings_DataEntry>): PolicyBasedRoute_Warnings_DataEntry {
    const message = createBasePolicyBasedRoute_Warnings_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePolicyBasedRoute_LabelsEntry(): PolicyBasedRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const PolicyBasedRoute_LabelsEntry: MessageFns<PolicyBasedRoute_LabelsEntry> = {
  encode(message: PolicyBasedRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyBasedRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyBasedRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyBasedRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PolicyBasedRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyBasedRoute_LabelsEntry>): PolicyBasedRoute_LabelsEntry {
    return PolicyBasedRoute_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyBasedRoute_LabelsEntry>): PolicyBasedRoute_LabelsEntry {
    const message = createBasePolicyBasedRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListPolicyBasedRoutesRequest(): ListPolicyBasedRoutesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListPolicyBasedRoutesRequest: MessageFns<ListPolicyBasedRoutesRequest> = {
  encode(message: ListPolicyBasedRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPolicyBasedRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPolicyBasedRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPolicyBasedRoutesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPolicyBasedRoutesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPolicyBasedRoutesRequest>): ListPolicyBasedRoutesRequest {
    return ListPolicyBasedRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPolicyBasedRoutesRequest>): ListPolicyBasedRoutesRequest {
    const message = createBaseListPolicyBasedRoutesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPolicyBasedRoutesResponse(): ListPolicyBasedRoutesResponse {
  return { policyBasedRoutes: [], nextPageToken: "", unreachable: [] };
}

export const ListPolicyBasedRoutesResponse: MessageFns<ListPolicyBasedRoutesResponse> = {
  encode(message: ListPolicyBasedRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.policyBasedRoutes) {
      PolicyBasedRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPolicyBasedRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPolicyBasedRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyBasedRoutes.push(PolicyBasedRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPolicyBasedRoutesResponse {
    return {
      policyBasedRoutes: globalThis.Array.isArray(object?.policyBasedRoutes)
        ? object.policyBasedRoutes.map((e: any) => PolicyBasedRoute.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListPolicyBasedRoutesResponse): unknown {
    const obj: any = {};
    if (message.policyBasedRoutes?.length) {
      obj.policyBasedRoutes = message.policyBasedRoutes.map((e) => PolicyBasedRoute.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPolicyBasedRoutesResponse>): ListPolicyBasedRoutesResponse {
    return ListPolicyBasedRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPolicyBasedRoutesResponse>): ListPolicyBasedRoutesResponse {
    const message = createBaseListPolicyBasedRoutesResponse();
    message.policyBasedRoutes = object.policyBasedRoutes?.map((e) => PolicyBasedRoute.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPolicyBasedRouteRequest(): GetPolicyBasedRouteRequest {
  return { name: "" };
}

export const GetPolicyBasedRouteRequest: MessageFns<GetPolicyBasedRouteRequest> = {
  encode(message: GetPolicyBasedRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyBasedRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyBasedRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPolicyBasedRouteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPolicyBasedRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPolicyBasedRouteRequest>): GetPolicyBasedRouteRequest {
    return GetPolicyBasedRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPolicyBasedRouteRequest>): GetPolicyBasedRouteRequest {
    const message = createBaseGetPolicyBasedRouteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreatePolicyBasedRouteRequest(): CreatePolicyBasedRouteRequest {
  return { parent: "", policyBasedRouteId: "", policyBasedRoute: undefined, requestId: "" };
}

export const CreatePolicyBasedRouteRequest: MessageFns<CreatePolicyBasedRouteRequest> = {
  encode(message: CreatePolicyBasedRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.policyBasedRouteId !== "") {
      writer.uint32(18).string(message.policyBasedRouteId);
    }
    if (message.policyBasedRoute !== undefined) {
      PolicyBasedRoute.encode(message.policyBasedRoute, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePolicyBasedRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePolicyBasedRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policyBasedRouteId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyBasedRoute = PolicyBasedRoute.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePolicyBasedRouteRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      policyBasedRouteId: isSet(object.policyBasedRouteId) ? globalThis.String(object.policyBasedRouteId) : "",
      policyBasedRoute: isSet(object.policyBasedRoute) ? PolicyBasedRoute.fromJSON(object.policyBasedRoute) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreatePolicyBasedRouteRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.policyBasedRouteId !== "") {
      obj.policyBasedRouteId = message.policyBasedRouteId;
    }
    if (message.policyBasedRoute !== undefined) {
      obj.policyBasedRoute = PolicyBasedRoute.toJSON(message.policyBasedRoute);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePolicyBasedRouteRequest>): CreatePolicyBasedRouteRequest {
    return CreatePolicyBasedRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePolicyBasedRouteRequest>): CreatePolicyBasedRouteRequest {
    const message = createBaseCreatePolicyBasedRouteRequest();
    message.parent = object.parent ?? "";
    message.policyBasedRouteId = object.policyBasedRouteId ?? "";
    message.policyBasedRoute = (object.policyBasedRoute !== undefined && object.policyBasedRoute !== null)
      ? PolicyBasedRoute.fromPartial(object.policyBasedRoute)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeletePolicyBasedRouteRequest(): DeletePolicyBasedRouteRequest {
  return { name: "", requestId: "" };
}

export const DeletePolicyBasedRouteRequest: MessageFns<DeletePolicyBasedRouteRequest> = {
  encode(message: DeletePolicyBasedRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePolicyBasedRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePolicyBasedRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePolicyBasedRouteRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeletePolicyBasedRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePolicyBasedRouteRequest>): DeletePolicyBasedRouteRequest {
    return DeletePolicyBasedRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePolicyBasedRouteRequest>): DeletePolicyBasedRouteRequest {
    const message = createBaseDeletePolicyBasedRouteRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

/**
 * Policy-Based Routing allows GCP customers to specify flexibile routing
 * policies for Layer 4 traffic traversing through the connected service.
 */
export type PolicyBasedRoutingServiceDefinition = typeof PolicyBasedRoutingServiceDefinition;
export const PolicyBasedRoutingServiceDefinition = {
  name: "PolicyBasedRoutingService",
  fullName: "google.cloud.networkconnectivity.v1.PolicyBasedRoutingService",
  methods: {
    /** Lists PolicyBasedRoutes in a given project and location. */
    listPolicyBasedRoutes: {
      name: "ListPolicyBasedRoutes",
      requestType: ListPolicyBasedRoutesRequest,
      requestStream: false,
      responseType: ListPolicyBasedRoutesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              103,
              108,
              111,
              98,
              97,
              108,
              125,
              47,
              112,
              111,
              108,
              105,
              99,
              121,
              66,
              97,
              115,
              101,
              100,
              82,
              111,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single PolicyBasedRoute. */
    getPolicyBasedRoute: {
      name: "GetPolicyBasedRoute",
      requestType: GetPolicyBasedRouteRequest,
      requestStream: false,
      responseType: PolicyBasedRoute,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              103,
              108,
              111,
              98,
              97,
              108,
              47,
              112,
              111,
              108,
              105,
              99,
              121,
              66,
              97,
              115,
              101,
              100,
              82,
              111,
              117,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new PolicyBasedRoute in a given project and location. */
    createPolicyBasedRoute: {
      name: "CreatePolicyBasedRoute",
      requestType: CreatePolicyBasedRouteRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              80,
              111,
              108,
              105,
              99,
              121,
              66,
              97,
              115,
              101,
              100,
              82,
              111,
              117,
              116,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              111,
              108,
              105,
              99,
              121,
              95,
              98,
              97,
              115,
              101,
              100,
              95,
              114,
              111,
              117,
              116,
              101,
              44,
              112,
              111,
              108,
              105,
              99,
              121,
              95,
              98,
              97,
              115,
              101,
              100,
              95,
              114,
              111,
              117,
              116,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              18,
              112,
              111,
              108,
              105,
              99,
              121,
              95,
              98,
              97,
              115,
              101,
              100,
              95,
              114,
              111,
              117,
              116,
              101,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              103,
              108,
              111,
              98,
              97,
              108,
              125,
              47,
              112,
              111,
              108,
              105,
              99,
              121,
              66,
              97,
              115,
              101,
              100,
              82,
              111,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single PolicyBasedRoute. */
    deletePolicyBasedRoute: {
      name: "DeletePolicyBasedRoute",
      requestType: DeletePolicyBasedRouteRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              103,
              108,
              111,
              98,
              97,
              108,
              47,
              112,
              111,
              108,
              105,
              99,
              121,
              66,
              97,
              115,
              101,
              100,
              82,
              111,
              117,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PolicyBasedRoutingServiceImplementation<CallContextExt = {}> {
  /** Lists PolicyBasedRoutes in a given project and location. */
  listPolicyBasedRoutes(
    request: ListPolicyBasedRoutesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPolicyBasedRoutesResponse>>;
  /** Gets details of a single PolicyBasedRoute. */
  getPolicyBasedRoute(
    request: GetPolicyBasedRouteRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PolicyBasedRoute>>;
  /** Creates a new PolicyBasedRoute in a given project and location. */
  createPolicyBasedRoute(
    request: CreatePolicyBasedRouteRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single PolicyBasedRoute. */
  deletePolicyBasedRoute(
    request: DeletePolicyBasedRouteRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface PolicyBasedRoutingServiceClient<CallOptionsExt = {}> {
  /** Lists PolicyBasedRoutes in a given project and location. */
  listPolicyBasedRoutes(
    request: DeepPartial<ListPolicyBasedRoutesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPolicyBasedRoutesResponse>;
  /** Gets details of a single PolicyBasedRoute. */
  getPolicyBasedRoute(
    request: DeepPartial<GetPolicyBasedRouteRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PolicyBasedRoute>;
  /** Creates a new PolicyBasedRoute in a given project and location. */
  createPolicyBasedRoute(
    request: DeepPartial<CreatePolicyBasedRouteRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single PolicyBasedRoute. */
  deletePolicyBasedRoute(
    request: DeepPartial<DeletePolicyBasedRouteRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
