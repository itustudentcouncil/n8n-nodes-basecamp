// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/orgpolicy/v1/orgpolicy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.orgpolicy.v1";

/**
 * Defines a Cloud Organization `Policy` which is used to specify `Constraints`
 * for configurations of Cloud Platform resources.
 */
export interface Policy {
  /** Version of the `Policy`. Default version is 0; */
  version: number;
  /**
   * The name of the `Constraint` the `Policy` is configuring, for example,
   * `constraints/serviceuser.services`.
   *
   * Immutable after creation.
   */
  constraint: string;
  /**
   * An opaque tag indicating the current version of the `Policy`, used for
   * concurrency control.
   *
   * When the `Policy` is returned from either a `GetPolicy` or a
   * `ListOrgPolicy` request, this `etag` indicates the version of the current
   * `Policy` to use when executing a read-modify-write loop.
   *
   * When the `Policy` is returned from a `GetEffectivePolicy` request, the
   * `etag` will be unset.
   *
   * When the `Policy` is used in a `SetOrgPolicy` method, use the `etag` value
   * that was returned from a `GetOrgPolicy` request as part of a
   * read-modify-write loop for concurrency control. Not setting the `etag`in a
   * `SetOrgPolicy` request will result in an unconditional write of the
   * `Policy`.
   */
  etag: Buffer;
  /**
   * The time stamp the `Policy` was previously updated. This is set by the
   * server, not specified by the caller, and represents the last time a call to
   * `SetOrgPolicy` was made for that `Policy`. Any value set by the client will
   * be ignored.
   */
  updateTime:
    | Date
    | undefined;
  /** List of values either allowed or disallowed. */
  listPolicy?:
    | Policy_ListPolicy
    | undefined;
  /** For boolean `Constraints`, whether to enforce the `Constraint` or not. */
  booleanPolicy?:
    | Policy_BooleanPolicy
    | undefined;
  /**
   * Restores the default behavior of the constraint; independent of
   * `Constraint` type.
   */
  restoreDefault?: Policy_RestoreDefault | undefined;
}

/**
 * Used in `policy_type` to specify how `list_policy` behaves at this
 * resource.
 *
 * `ListPolicy` can define specific values and subtrees of Cloud Resource
 * Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
 * are allowed or denied by setting the `allowed_values` and `denied_values`
 * fields. This is achieved by using the `under:` and optional `is:` prefixes.
 * The `under:` prefix is used to denote resource subtree values.
 * The `is:` prefix is used to denote specific values, and is required only
 * if the value contains a ":". Values prefixed with "is:" are treated the
 * same as values with no prefix.
 * Ancestry subtrees must be in one of the following formats:
 *     - "projects/<project-id>", e.g. "projects/tokyo-rain-123"
 *     - "folders/<folder-id>", e.g. "folders/1234"
 *     - "organizations/<organization-id>", e.g. "organizations/1234"
 * The `supports_under` field of the associated `Constraint`  defines whether
 * ancestry prefixes can be used. You can set `allowed_values` and
 * `denied_values` in the same `Policy` if `all_values` is
 * `ALL_VALUES_UNSPECIFIED`. `ALLOW` or `DENY` are used to allow or deny all
 * values. If `all_values` is set to either `ALLOW` or `DENY`,
 * `allowed_values` and `denied_values` must be unset.
 */
export interface Policy_ListPolicy {
  /**
   * List of values allowed  at this resource. Can only be set if `all_values`
   * is set to `ALL_VALUES_UNSPECIFIED`.
   */
  allowedValues: string[];
  /**
   * List of values denied at this resource. Can only be set if `all_values`
   * is set to `ALL_VALUES_UNSPECIFIED`.
   */
  deniedValues: string[];
  /** The policy all_values state. */
  allValues: Policy_ListPolicy_AllValues;
  /**
   * Optional. The Google Cloud Console will try to default to a configuration
   * that matches the value specified in this `Policy`. If `suggested_value`
   * is not set, it will inherit the value specified higher in the hierarchy,
   * unless `inherit_from_parent` is `false`.
   */
  suggestedValue: string;
  /**
   * Determines the inheritance behavior for this `Policy`.
   *
   * By default, a `ListPolicy` set at a resource supercedes any `Policy` set
   * anywhere up the resource hierarchy. However, if `inherit_from_parent` is
   * set to `true`, then the values from the effective `Policy` of the parent
   * resource are inherited, meaning the values set in this `Policy` are
   * added to the values inherited up the hierarchy.
   *
   * Setting `Policy` hierarchies that inherit both allowed values and denied
   * values isn't recommended in most circumstances to keep the configuration
   * simple and understandable. However, it is possible to set a `Policy` with
   * `allowed_values` set that inherits a `Policy` with `denied_values` set.
   * In this case, the values that are allowed must be in `allowed_values` and
   * not present in `denied_values`.
   *
   * For example, suppose you have a `Constraint`
   * `constraints/serviceuser.services`, which has a `constraint_type` of
   * `list_constraint`, and with `constraint_default` set to `ALLOW`.
   * Suppose that at the Organization level, a `Policy` is applied that
   * restricts the allowed API activations to {`E1`, `E2`}. Then, if a
   * `Policy` is applied to a project below the Organization that has
   * `inherit_from_parent` set to `false` and field all_values set to DENY,
   * then an attempt to activate any API will be denied.
   *
   * The following examples demonstrate different possible layerings for
   * `projects/bar` parented by `organizations/foo`:
   *
   * Example 1 (no inherited values):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values:"E2"}
   *   `projects/bar` has `inherit_from_parent` `false` and values:
   *     {allowed_values: "E3" allowed_values: "E4"}
   * The accepted values at `organizations/foo` are `E1`, `E2`.
   * The accepted values at `projects/bar` are `E3`, and `E4`.
   *
   * Example 2 (inherited values):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values:"E2"}
   *   `projects/bar` has a `Policy` with values:
   *     {value: "E3" value: "E4" inherit_from_parent: true}
   * The accepted values at `organizations/foo` are `E1`, `E2`.
   * The accepted values at `projects/bar` are `E1`, `E2`, `E3`, and `E4`.
   *
   * Example 3 (inheriting both allowed and denied values):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values: "E2"}
   *   `projects/bar` has a `Policy` with:
   *     {denied_values: "E1"}
   * The accepted values at `organizations/foo` are `E1`, `E2`.
   * The value accepted at `projects/bar` is `E2`.
   *
   * Example 4 (RestoreDefault):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values:"E2"}
   *   `projects/bar` has a `Policy` with values:
   *     {RestoreDefault: {}}
   * The accepted values at `organizations/foo` are `E1`, `E2`.
   * The accepted values at `projects/bar` are either all or none depending on
   * the value of `constraint_default` (if `ALLOW`, all; if
   * `DENY`, none).
   *
   * Example 5 (no policy inherits parent policy):
   *   `organizations/foo` has no `Policy` set.
   *   `projects/bar` has no `Policy` set.
   * The accepted values at both levels are either all or none depending on
   * the value of `constraint_default` (if `ALLOW`, all; if
   * `DENY`, none).
   *
   * Example 6 (ListConstraint allowing all):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values: "E2"}
   *   `projects/bar` has a `Policy` with:
   *     {all: ALLOW}
   * The accepted values at `organizations/foo` are `E1`, E2`.
   * Any value is accepted at `projects/bar`.
   *
   * Example 7 (ListConstraint allowing none):
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "E1" allowed_values: "E2"}
   *   `projects/bar` has a `Policy` with:
   *     {all: DENY}
   * The accepted values at `organizations/foo` are `E1`, E2`.
   * No value is accepted at `projects/bar`.
   *
   * Example 10 (allowed and denied subtrees of Resource Manager hierarchy):
   * Given the following resource hierarchy
   *   O1->{F1, F2}; F1->{P1}; F2->{P2, P3},
   *   `organizations/foo` has a `Policy` with values:
   *     {allowed_values: "under:organizations/O1"}
   *   `projects/bar` has a `Policy` with:
   *     {allowed_values: "under:projects/P3"}
   *     {denied_values: "under:folders/F2"}
   * The accepted values at `organizations/foo` are `organizations/O1`,
   *   `folders/F1`, `folders/F2`, `projects/P1`, `projects/P2`,
   *   `projects/P3`.
   * The accepted values at `projects/bar` are `organizations/O1`,
   *   `folders/F1`, `projects/P1`.
   */
  inheritFromParent: boolean;
}

/**
 * This enum can be used to set `Policies` that apply to all possible
 * configuration values rather than specific values in `allowed_values` or
 * `denied_values`.
 *
 * Settting this to `ALLOW` will mean this `Policy` allows all values.
 * Similarly, setting it to `DENY` will mean no values are allowed. If
 * set to either `ALLOW` or `DENY,  `allowed_values` and `denied_values`
 * must be unset. Setting this to `ALL_VALUES_UNSPECIFIED` allows for
 * setting `allowed_values` and `denied_values`.
 */
export enum Policy_ListPolicy_AllValues {
  /** ALL_VALUES_UNSPECIFIED - Indicates that allowed_values or denied_values must be set. */
  ALL_VALUES_UNSPECIFIED = 0,
  /** ALLOW - A policy with this set allows all values. */
  ALLOW = 1,
  /** DENY - A policy with this set denies all values. */
  DENY = 2,
  UNRECOGNIZED = -1,
}

export function policy_ListPolicy_AllValuesFromJSON(object: any): Policy_ListPolicy_AllValues {
  switch (object) {
    case 0:
    case "ALL_VALUES_UNSPECIFIED":
      return Policy_ListPolicy_AllValues.ALL_VALUES_UNSPECIFIED;
    case 1:
    case "ALLOW":
      return Policy_ListPolicy_AllValues.ALLOW;
    case 2:
    case "DENY":
      return Policy_ListPolicy_AllValues.DENY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Policy_ListPolicy_AllValues.UNRECOGNIZED;
  }
}

export function policy_ListPolicy_AllValuesToJSON(object: Policy_ListPolicy_AllValues): string {
  switch (object) {
    case Policy_ListPolicy_AllValues.ALL_VALUES_UNSPECIFIED:
      return "ALL_VALUES_UNSPECIFIED";
    case Policy_ListPolicy_AllValues.ALLOW:
      return "ALLOW";
    case Policy_ListPolicy_AllValues.DENY:
      return "DENY";
    case Policy_ListPolicy_AllValues.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Used in `policy_type` to specify how `boolean_policy` will behave at this
 * resource.
 */
export interface Policy_BooleanPolicy {
  /**
   * If `true`, then the `Policy` is enforced. If `false`, then any
   * configuration is acceptable.
   *
   * Suppose you have a `Constraint`
   * `constraints/compute.disableSerialPortAccess` with `constraint_default`
   * set to `ALLOW`. A `Policy` for that `Constraint` exhibits the following
   * behavior:
   *   - If the `Policy` at this resource has enforced set to `false`, serial
   *     port connection attempts will be allowed.
   *   - If the `Policy` at this resource has enforced set to `true`, serial
   *     port connection attempts will be refused.
   *   - If the `Policy` at this resource is `RestoreDefault`, serial port
   *     connection attempts will be allowed.
   *   - If no `Policy` is set at this resource or anywhere higher in the
   *     resource hierarchy, serial port connection attempts will be allowed.
   *   - If no `Policy` is set at this resource, but one exists higher in the
   *     resource hierarchy, the behavior is as if the`Policy` were set at
   *     this resource.
   *
   * The following examples demonstrate the different possible layerings:
   *
   * Example 1 (nearest `Constraint` wins):
   *   `organizations/foo` has a `Policy` with:
   *     {enforced: false}
   *   `projects/bar` has no `Policy` set.
   * The constraint at `projects/bar` and `organizations/foo` will not be
   * enforced.
   *
   * Example 2 (enforcement gets replaced):
   *   `organizations/foo` has a `Policy` with:
   *     {enforced: false}
   *   `projects/bar` has a `Policy` with:
   *     {enforced: true}
   * The constraint at `organizations/foo` is not enforced.
   * The constraint at `projects/bar` is enforced.
   *
   * Example 3 (RestoreDefault):
   *   `organizations/foo` has a `Policy` with:
   *     {enforced: true}
   *   `projects/bar` has a `Policy` with:
   *     {RestoreDefault: {}}
   * The constraint at `organizations/foo` is enforced.
   * The constraint at `projects/bar` is not enforced, because
   * `constraint_default` for the `Constraint` is `ALLOW`.
   */
  enforced: boolean;
}

/**
 * Ignores policies set above this resource and restores the
 * `constraint_default` enforcement behavior of the specific `Constraint` at
 * this resource.
 *
 * Suppose that `constraint_default` is set to `ALLOW` for the
 * `Constraint` `constraints/serviceuser.services`. Suppose that organization
 * foo.com sets a `Policy` at their Organization resource node that restricts
 * the allowed service activations to deny all service activations. They
 * could then set a `Policy` with the `policy_type` `restore_default` on
 * several experimental projects, restoring the `constraint_default`
 * enforcement of the `Constraint` for only those projects, allowing those
 * projects to have all services activated.
 */
export interface Policy_RestoreDefault {
}

function createBasePolicy(): Policy {
  return {
    version: 0,
    constraint: "",
    etag: Buffer.alloc(0),
    updateTime: undefined,
    listPolicy: undefined,
    booleanPolicy: undefined,
    restoreDefault: undefined,
  };
}

export const Policy: MessageFns<Policy> = {
  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.constraint !== "") {
      writer.uint32(18).string(message.constraint);
    }
    if (message.etag.length !== 0) {
      writer.uint32(26).bytes(message.etag);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.listPolicy !== undefined) {
      Policy_ListPolicy.encode(message.listPolicy, writer.uint32(42).fork()).join();
    }
    if (message.booleanPolicy !== undefined) {
      Policy_BooleanPolicy.encode(message.booleanPolicy, writer.uint32(50).fork()).join();
    }
    if (message.restoreDefault !== undefined) {
      Policy_RestoreDefault.encode(message.restoreDefault, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constraint = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.listPolicy = Policy_ListPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.booleanPolicy = Policy_BooleanPolicy.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.restoreDefault = Policy_RestoreDefault.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      constraint: isSet(object.constraint) ? globalThis.String(object.constraint) : "",
      etag: isSet(object.etag) ? Buffer.from(bytesFromBase64(object.etag)) : Buffer.alloc(0),
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      listPolicy: isSet(object.listPolicy) ? Policy_ListPolicy.fromJSON(object.listPolicy) : undefined,
      booleanPolicy: isSet(object.booleanPolicy) ? Policy_BooleanPolicy.fromJSON(object.booleanPolicy) : undefined,
      restoreDefault: isSet(object.restoreDefault) ? Policy_RestoreDefault.fromJSON(object.restoreDefault) : undefined,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.constraint !== "") {
      obj.constraint = message.constraint;
    }
    if (message.etag.length !== 0) {
      obj.etag = base64FromBytes(message.etag);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.listPolicy !== undefined) {
      obj.listPolicy = Policy_ListPolicy.toJSON(message.listPolicy);
    }
    if (message.booleanPolicy !== undefined) {
      obj.booleanPolicy = Policy_BooleanPolicy.toJSON(message.booleanPolicy);
    }
    if (message.restoreDefault !== undefined) {
      obj.restoreDefault = Policy_RestoreDefault.toJSON(message.restoreDefault);
    }
    return obj;
  },

  create(base?: DeepPartial<Policy>): Policy {
    return Policy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Policy>): Policy {
    const message = createBasePolicy();
    message.version = object.version ?? 0;
    message.constraint = object.constraint ?? "";
    message.etag = object.etag ?? Buffer.alloc(0);
    message.updateTime = object.updateTime ?? undefined;
    message.listPolicy = (object.listPolicy !== undefined && object.listPolicy !== null)
      ? Policy_ListPolicy.fromPartial(object.listPolicy)
      : undefined;
    message.booleanPolicy = (object.booleanPolicy !== undefined && object.booleanPolicy !== null)
      ? Policy_BooleanPolicy.fromPartial(object.booleanPolicy)
      : undefined;
    message.restoreDefault = (object.restoreDefault !== undefined && object.restoreDefault !== null)
      ? Policy_RestoreDefault.fromPartial(object.restoreDefault)
      : undefined;
    return message;
  },
};

function createBasePolicy_ListPolicy(): Policy_ListPolicy {
  return { allowedValues: [], deniedValues: [], allValues: 0, suggestedValue: "", inheritFromParent: false };
}

export const Policy_ListPolicy: MessageFns<Policy_ListPolicy> = {
  encode(message: Policy_ListPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedValues) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.deniedValues) {
      writer.uint32(18).string(v!);
    }
    if (message.allValues !== 0) {
      writer.uint32(24).int32(message.allValues);
    }
    if (message.suggestedValue !== "") {
      writer.uint32(34).string(message.suggestedValue);
    }
    if (message.inheritFromParent !== false) {
      writer.uint32(40).bool(message.inheritFromParent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_ListPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_ListPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedValues.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deniedValues.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allValues = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.suggestedValue = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.inheritFromParent = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_ListPolicy {
    return {
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => globalThis.String(e))
        : [],
      deniedValues: globalThis.Array.isArray(object?.deniedValues)
        ? object.deniedValues.map((e: any) => globalThis.String(e))
        : [],
      allValues: isSet(object.allValues) ? policy_ListPolicy_AllValuesFromJSON(object.allValues) : 0,
      suggestedValue: isSet(object.suggestedValue) ? globalThis.String(object.suggestedValue) : "",
      inheritFromParent: isSet(object.inheritFromParent) ? globalThis.Boolean(object.inheritFromParent) : false,
    };
  },

  toJSON(message: Policy_ListPolicy): unknown {
    const obj: any = {};
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues;
    }
    if (message.deniedValues?.length) {
      obj.deniedValues = message.deniedValues;
    }
    if (message.allValues !== 0) {
      obj.allValues = policy_ListPolicy_AllValuesToJSON(message.allValues);
    }
    if (message.suggestedValue !== "") {
      obj.suggestedValue = message.suggestedValue;
    }
    if (message.inheritFromParent !== false) {
      obj.inheritFromParent = message.inheritFromParent;
    }
    return obj;
  },

  create(base?: DeepPartial<Policy_ListPolicy>): Policy_ListPolicy {
    return Policy_ListPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Policy_ListPolicy>): Policy_ListPolicy {
    const message = createBasePolicy_ListPolicy();
    message.allowedValues = object.allowedValues?.map((e) => e) || [];
    message.deniedValues = object.deniedValues?.map((e) => e) || [];
    message.allValues = object.allValues ?? 0;
    message.suggestedValue = object.suggestedValue ?? "";
    message.inheritFromParent = object.inheritFromParent ?? false;
    return message;
  },
};

function createBasePolicy_BooleanPolicy(): Policy_BooleanPolicy {
  return { enforced: false };
}

export const Policy_BooleanPolicy: MessageFns<Policy_BooleanPolicy> = {
  encode(message: Policy_BooleanPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enforced !== false) {
      writer.uint32(8).bool(message.enforced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_BooleanPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_BooleanPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enforced = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_BooleanPolicy {
    return { enforced: isSet(object.enforced) ? globalThis.Boolean(object.enforced) : false };
  },

  toJSON(message: Policy_BooleanPolicy): unknown {
    const obj: any = {};
    if (message.enforced !== false) {
      obj.enforced = message.enforced;
    }
    return obj;
  },

  create(base?: DeepPartial<Policy_BooleanPolicy>): Policy_BooleanPolicy {
    return Policy_BooleanPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Policy_BooleanPolicy>): Policy_BooleanPolicy {
    const message = createBasePolicy_BooleanPolicy();
    message.enforced = object.enforced ?? false;
    return message;
  },
};

function createBasePolicy_RestoreDefault(): Policy_RestoreDefault {
  return {};
}

export const Policy_RestoreDefault: MessageFns<Policy_RestoreDefault> = {
  encode(_: Policy_RestoreDefault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_RestoreDefault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_RestoreDefault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Policy_RestoreDefault {
    return {};
  },

  toJSON(_: Policy_RestoreDefault): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Policy_RestoreDefault>): Policy_RestoreDefault {
    return Policy_RestoreDefault.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Policy_RestoreDefault>): Policy_RestoreDefault {
    const message = createBasePolicy_RestoreDefault();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
