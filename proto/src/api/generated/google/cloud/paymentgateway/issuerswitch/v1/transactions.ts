// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/paymentgateway/issuerswitch/v1/transactions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { DateMessage } from "../../../../type/date.js";
import { Money } from "../../../../type/money.js";
import {
  ApiType,
  apiTypeFromJSON,
  apiTypeToJSON,
  Participant,
  SettlementParticipant,
  TransactionType,
  transactionTypeFromJSON,
  transactionTypeToJSON,
} from "./common_fields.js";
import { Complaint, Dispute } from "./resolutions.js";

export const protobufPackage = "google.cloud.paymentgateway.issuerswitch.v1";

/**
 * Information about a transaction processed by the issuer switch.
 * The fields in this type are common across both financial and metadata
 * transactions.
 */
export interface TransactionInfo {
  /**
   * Output only. An identifier that is mandatorily present in every transaction
   * processed via UPI. This maps to UPI's transaction ID.
   */
  id: string;
  /** Output only. The API type of the transaction. */
  apiType: ApiType;
  /** Output only. The transaction type. */
  transactionType: TransactionType;
  /** Output only. The transaction subtype. */
  transactionSubType: TransactionInfo_TransactionSubType;
  /** Output only. The transaction's state. */
  state: TransactionInfo_State;
  /** Metadata about the API transaction. */
  metadata:
    | TransactionInfo_TransactionMetadata
    | undefined;
  /**
   * Output only. Any error details for the current API transaction, if the
   * state is `FAILED`.
   */
  errorDetails:
    | TransactionInfo_TransactionErrorDetails
    | undefined;
  /**
   * Output only. Information about the adapter invocation from the issuer
   * switch for processing this API transaction.
   */
  adapterInfo:
    | TransactionInfo_AdapterInfo
    | undefined;
  /** Risk information as provided by the payments orchestrator. */
  riskInfo: TransactionInfo_TransactionRiskInfo[];
}

/** Specifies the current state of the transaction. */
export enum TransactionInfo_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The transaction has successfully completed. */
  SUCCEEDED = 1,
  /** FAILED - The transaction has failed. */
  FAILED = 2,
  /** TIMED_OUT - The transaction has timed out. */
  TIMED_OUT = 3,
  UNRECOGNIZED = -1,
}

export function transactionInfo_StateFromJSON(object: any): TransactionInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return TransactionInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return TransactionInfo_State.SUCCEEDED;
    case 2:
    case "FAILED":
      return TransactionInfo_State.FAILED;
    case 3:
    case "TIMED_OUT":
      return TransactionInfo_State.TIMED_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionInfo_State.UNRECOGNIZED;
  }
}

export function transactionInfo_StateToJSON(object: TransactionInfo_State): string {
  switch (object) {
    case TransactionInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case TransactionInfo_State.SUCCEEDED:
      return "SUCCEEDED";
    case TransactionInfo_State.FAILED:
      return "FAILED";
    case TransactionInfo_State.TIMED_OUT:
      return "TIMED_OUT";
    case TransactionInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The subtype of a transaction. This value is used only for certain API type
 * and transaction type combinations.
 */
export enum TransactionInfo_TransactionSubType {
  /** TRANSACTION_SUB_TYPE_UNSPECIFIED - Unspecified transaction subtype. */
  TRANSACTION_SUB_TYPE_UNSPECIFIED = 0,
  /**
   * COLLECT - Collect subtype. This is used in a `SETTLE_PAYMENT` API type
   * transaction, with the transaction type as either
   * `TRANSACTION_TYPE_CREDIT` or `TRANSACTION_TYPE_DEBIT` when the payment
   * was initiated by a collect request.
   */
  COLLECT = 1,
  /**
   * DEBIT - Debit subtype. This is used in a `SETTLE_PAYMENT` API type transaction,
   * with the transaction type as `TRANSACTION_TYPE_REVERSAL` when the
   * original payment was a debit request.
   */
  DEBIT = 2,
  /**
   * PAY - Pay subtype. This is used in a `SETTLE_PAYMENT` API type transaction,
   * with the transaction type as either `TRANSACTION_TYPE_CREDIT` or
   * `TRANSACTION_TYPE_DEBIT` when the payment was initiated by a pay request.
   */
  PAY = 3,
  /**
   * BENEFICIARY - Beneficiary subtype. This is used in a `COMPLAINT` API type transaction,
   * when the complaint / dispute request is initiated / received by the
   * beneficiary bank.
   */
  BENEFICIARY = 4,
  /**
   * REMITTER - Remitter subtype. This is used in a `COMPLAINT` API type transaction,
   * when the complaint / dispute request is initiated / received by the
   * remitter bank.
   */
  REMITTER = 5,
  /**
   * REFUND - Refund subtype. This is used in a `SETTLE_PAYMENT` API type transaction,
   * with the transaction type as `TRANSACTION_TYPE_CREDIT` when the payment
   * was initiated in response to a refund.
   */
  REFUND = 6,
  /**
   * CREDIT - Credit subtype. This is used in a `SETTLE_PAYMENT` API type transaction,
   * with the transaction type as `TRANSACTION_TYPE_REVERSAL` when the
   * original payment was a credit request.
   */
  CREDIT = 7,
  UNRECOGNIZED = -1,
}

export function transactionInfo_TransactionSubTypeFromJSON(object: any): TransactionInfo_TransactionSubType {
  switch (object) {
    case 0:
    case "TRANSACTION_SUB_TYPE_UNSPECIFIED":
      return TransactionInfo_TransactionSubType.TRANSACTION_SUB_TYPE_UNSPECIFIED;
    case 1:
    case "COLLECT":
      return TransactionInfo_TransactionSubType.COLLECT;
    case 2:
    case "DEBIT":
      return TransactionInfo_TransactionSubType.DEBIT;
    case 3:
    case "PAY":
      return TransactionInfo_TransactionSubType.PAY;
    case 4:
    case "BENEFICIARY":
      return TransactionInfo_TransactionSubType.BENEFICIARY;
    case 5:
    case "REMITTER":
      return TransactionInfo_TransactionSubType.REMITTER;
    case 6:
    case "REFUND":
      return TransactionInfo_TransactionSubType.REFUND;
    case 7:
    case "CREDIT":
      return TransactionInfo_TransactionSubType.CREDIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionInfo_TransactionSubType.UNRECOGNIZED;
  }
}

export function transactionInfo_TransactionSubTypeToJSON(object: TransactionInfo_TransactionSubType): string {
  switch (object) {
    case TransactionInfo_TransactionSubType.TRANSACTION_SUB_TYPE_UNSPECIFIED:
      return "TRANSACTION_SUB_TYPE_UNSPECIFIED";
    case TransactionInfo_TransactionSubType.COLLECT:
      return "COLLECT";
    case TransactionInfo_TransactionSubType.DEBIT:
      return "DEBIT";
    case TransactionInfo_TransactionSubType.PAY:
      return "PAY";
    case TransactionInfo_TransactionSubType.BENEFICIARY:
      return "BENEFICIARY";
    case TransactionInfo_TransactionSubType.REMITTER:
      return "REMITTER";
    case TransactionInfo_TransactionSubType.REFUND:
      return "REFUND";
    case TransactionInfo_TransactionSubType.CREDIT:
      return "CREDIT";
    case TransactionInfo_TransactionSubType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Common metadata about an API transaction. */
export interface TransactionInfo_TransactionMetadata {
  /**
   * Output only. The time at which the transaction resource was created by
   * the issuer switch.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the transaction resource was last updated
   * by the issuer switch.
   */
  updateTime:
    | Date
    | undefined;
  /** Output only. A reference id for the API transaction. */
  referenceId: string;
  /** Output only. A reference URI to this API transaction. */
  referenceUri: string;
  /** Output only. A descriptive note about this API transaction. */
  description: string;
  /**
   * Output only. The initiation mode of this API transaction. In UPI, the
   * values are as defined by the UPI API specification.
   */
  initiationMode: string;
  /**
   * Output only. The purpose code of this API transaction. In UPI, the values
   * are as defined by the UPI API specification.
   */
  purposeCode: string;
  /** Output only. The reference category of this API transaction. */
  referenceCategory: string;
}

/** All details about any error in the processing of an API transaction. */
export interface TransactionInfo_TransactionErrorDetails {
  /** Output only. Error code of the failed transaction. */
  errorCode: string;
  /** Output only. Error description for the failed transaction. */
  errorMessage: string;
  /**
   * Output only. Error code as per the UPI specification. The issuer switch
   * maps the ErrorCode to an appropriate error code that complies with the
   * UPI specification.
   */
  upiErrorCode: string;
}

/**
 * Information about an adapter invocation triggered as part of the
 * processing of an API transaction.
 */
export interface TransactionInfo_AdapterInfo {
  /**
   * Output only. List of adapter request IDs (colon separated) used when
   * invoking the Adapter APIs for fulfilling a transaction request.
   */
  requestIds: string;
  /**
   * Output only. Response metadata included by the adapter in its response to
   * an API invocation from the issuer switch.
   */
  responseMetadata: TransactionInfo_AdapterInfo_ResponseMetadata | undefined;
}

/**
 * Metadata about a response that the adapter includes in its response
 * to the issuer switch.
 */
export interface TransactionInfo_AdapterInfo_ResponseMetadata {
  /** A map of name-value pairs. */
  values: { [key: string]: string };
}

export interface TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
  key: string;
  value: string;
}

/**
 * Information about the transaction's risk evaluation as provided by the
 * payments orchestrator.
 */
export interface TransactionInfo_TransactionRiskInfo {
  /**
   * Entity providing the risk score. This could either be the payment service
   * provider or the payment orchestrator (UPI, etc).
   */
  provider: string;
  /** Type of risk. Examples include `TXNRISK`. */
  type: string;
  /**
   * Numeric value of risk evaluation ranging from 0 (No Risk) to 100 (Maximum
   * Risk).
   */
  value: string;
}

/**
 * A metadata API transaction processed by the issuer switch. This
 * includes UPI APIs such as List Accounts, Balance Enquiry, etc.
 */
export interface MetadataTransaction {
  /**
   * The name of the metadata transaction. This uniquely identifies the
   * transaction. Format of name is
   * projects/{project_id}/metadataTransaction/{metadata_transaction_id}.
   */
  name: string;
  /** Information about the transaction. */
  info:
    | TransactionInfo
    | undefined;
  /** Output only. The initiator of the metadata transaction. */
  initiator: Participant | undefined;
}

/**
 * A financial API transaction processed by the issuer switch. In UPI, this maps
 * to the Pay API.
 */
export interface FinancialTransaction {
  /**
   * The name of the financial transaction. This uniquely identifies the
   * transaction. Format of name is
   * projects/{project_id}/financialTransactions/{financial_transaction_id}.
   */
  name: string;
  /** Information about the transaction. */
  info:
    | TransactionInfo
    | undefined;
  /**
   * Output only. A 12 digit numeric code associated with the request. It could
   * contain leading 0s. In UPI, this is also known as as the customer reference
   * or the UPI transaction ID.
   */
  retrievalReferenceNumber: string;
  /** Output only. The payer in the transaction. */
  payer:
    | SettlementParticipant
    | undefined;
  /** Output only. The payee in the transaction. */
  payee:
    | SettlementParticipant
    | undefined;
  /** Output only. The amount for payment settlement in the transaction. */
  amount:
    | Money
    | undefined;
  /**
   * A list of rules specified by the payments orchestrator for this API
   * transaction.
   */
  paymentRules: FinancialTransaction_PaymentRule[];
}

/** A payment rule as provided by the payments orchestrator. */
export interface FinancialTransaction_PaymentRule {
  /** The rule's name. */
  paymentRule: FinancialTransaction_PaymentRule_PaymentRuleName;
  /** The rule's value. */
  value: string;
}

/** An enum of the possible rule names. */
export enum FinancialTransaction_PaymentRule_PaymentRuleName {
  /** PAYMENT_RULE_NAME_UNSPECIFIED - Rule name unspecified. */
  PAYMENT_RULE_NAME_UNSPECIFIED = 0,
  /** EXPIRE_AFTER - The `expire after` rule. */
  EXPIRE_AFTER = 1,
  /** MIN_AMOUNT - The `min amount` rule. */
  MIN_AMOUNT = 2,
  UNRECOGNIZED = -1,
}

export function financialTransaction_PaymentRule_PaymentRuleNameFromJSON(
  object: any,
): FinancialTransaction_PaymentRule_PaymentRuleName {
  switch (object) {
    case 0:
    case "PAYMENT_RULE_NAME_UNSPECIFIED":
      return FinancialTransaction_PaymentRule_PaymentRuleName.PAYMENT_RULE_NAME_UNSPECIFIED;
    case 1:
    case "EXPIRE_AFTER":
      return FinancialTransaction_PaymentRule_PaymentRuleName.EXPIRE_AFTER;
    case 2:
    case "MIN_AMOUNT":
      return FinancialTransaction_PaymentRule_PaymentRuleName.MIN_AMOUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FinancialTransaction_PaymentRule_PaymentRuleName.UNRECOGNIZED;
  }
}

export function financialTransaction_PaymentRule_PaymentRuleNameToJSON(
  object: FinancialTransaction_PaymentRule_PaymentRuleName,
): string {
  switch (object) {
    case FinancialTransaction_PaymentRule_PaymentRuleName.PAYMENT_RULE_NAME_UNSPECIFIED:
      return "PAYMENT_RULE_NAME_UNSPECIFIED";
    case FinancialTransaction_PaymentRule_PaymentRuleName.EXPIRE_AFTER:
      return "EXPIRE_AFTER";
    case FinancialTransaction_PaymentRule_PaymentRuleName.MIN_AMOUNT:
      return "MIN_AMOUNT";
    case FinancialTransaction_PaymentRule_PaymentRuleName.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A mandate processed by the issuer switch. In UPI, this maps to the Mandate
 * API.
 */
export interface MandateTransaction {
  /**
   * The name of the mandate transaction. This uniquely identifies the
   * transaction. Format of name is
   * projects/{project_id}/mandateTransactions/{mandate_transaction_id}.
   */
  name: string;
  /** Information about the transaction. */
  transactionInfo:
    | TransactionInfo
    | undefined;
  /** Output only. This maps to Unique Mandate Number (UMN) in UPI specification. */
  uniqueMandateNumber: string;
  /** Output only. The payer in the transaction. */
  payer:
    | SettlementParticipant
    | undefined;
  /** Output only. The payee in the transaction. */
  payee:
    | SettlementParticipant
    | undefined;
  /** Output only. The type of recurrence pattern of the mandate. */
  recurrencePattern: MandateTransaction_RecurrencePatternType;
  /** Output only. The type of recurrence rule of the mandate. */
  recurrenceRuleType: MandateTransaction_RecurrenceRuleType;
  /**
   * Output only. The recurrence rule value of the mandate. This is a value from
   * 1 to 31.
   */
  recurrenceRuleValue: number;
  /** Output only. The start date of the mandate. */
  startDate:
    | DateMessage
    | undefined;
  /** Output only. The end date of the mandate. */
  endDate:
    | DateMessage
    | undefined;
  /** Output only. If true, this specifies mandate can be revoked. */
  revokable: boolean;
  /** Output only. The amount of the mandate. */
  amount: number;
  /** Output only. The amount rule type of the mandate. */
  amountRule: MandateTransaction_AmountRuleType;
  /**
   * Output only. The Block funds reference generated by the bank, this will be
   * available only when Recurrence is ONETIME.
   */
  approvalReference: string;
  /**
   * Output only. If true, this specifies the mandate transaction requested
   * funds to be blocked.
   */
  blockFunds: boolean;
  /** Output only. The mandate's name. */
  mandateName: string;
}

/** RecurrencePatternType specifies the recurrence pattern type of the mandate. */
export enum MandateTransaction_RecurrencePatternType {
  /** RECURRENCE_PATTERN_TYPE_UNSPECIFIED - Unspecified recurrence pattern. */
  RECURRENCE_PATTERN_TYPE_UNSPECIFIED = 0,
  /** AS_PRESENTED - As presented recurrence pattern. */
  AS_PRESENTED = 1,
  /** BIMONTHLY - Bi monthly recurrence pattern. */
  BIMONTHLY = 2,
  /** DAILY - Daily recurrence pattern. */
  DAILY = 3,
  /** FORTNIGHTLY - Bi weekly recurrence pattern. */
  FORTNIGHTLY = 4,
  /** HALF_YEARLY - Half yearly recurrence pattern. */
  HALF_YEARLY = 5,
  /** MONTHLY - Monthly recurrence pattern. */
  MONTHLY = 6,
  /** ONE_TIME - One time recurrence pattern. */
  ONE_TIME = 7,
  /** QUARTERLY - Quarterly recurrence pattern. */
  QUARTERLY = 8,
  /** WEEKLY - Weekly recurrence pattern. */
  WEEKLY = 9,
  /** YEARLY - Yearly recurrence pattern. */
  YEARLY = 10,
  UNRECOGNIZED = -1,
}

export function mandateTransaction_RecurrencePatternTypeFromJSON(
  object: any,
): MandateTransaction_RecurrencePatternType {
  switch (object) {
    case 0:
    case "RECURRENCE_PATTERN_TYPE_UNSPECIFIED":
      return MandateTransaction_RecurrencePatternType.RECURRENCE_PATTERN_TYPE_UNSPECIFIED;
    case 1:
    case "AS_PRESENTED":
      return MandateTransaction_RecurrencePatternType.AS_PRESENTED;
    case 2:
    case "BIMONTHLY":
      return MandateTransaction_RecurrencePatternType.BIMONTHLY;
    case 3:
    case "DAILY":
      return MandateTransaction_RecurrencePatternType.DAILY;
    case 4:
    case "FORTNIGHTLY":
      return MandateTransaction_RecurrencePatternType.FORTNIGHTLY;
    case 5:
    case "HALF_YEARLY":
      return MandateTransaction_RecurrencePatternType.HALF_YEARLY;
    case 6:
    case "MONTHLY":
      return MandateTransaction_RecurrencePatternType.MONTHLY;
    case 7:
    case "ONE_TIME":
      return MandateTransaction_RecurrencePatternType.ONE_TIME;
    case 8:
    case "QUARTERLY":
      return MandateTransaction_RecurrencePatternType.QUARTERLY;
    case 9:
    case "WEEKLY":
      return MandateTransaction_RecurrencePatternType.WEEKLY;
    case 10:
    case "YEARLY":
      return MandateTransaction_RecurrencePatternType.YEARLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MandateTransaction_RecurrencePatternType.UNRECOGNIZED;
  }
}

export function mandateTransaction_RecurrencePatternTypeToJSON(
  object: MandateTransaction_RecurrencePatternType,
): string {
  switch (object) {
    case MandateTransaction_RecurrencePatternType.RECURRENCE_PATTERN_TYPE_UNSPECIFIED:
      return "RECURRENCE_PATTERN_TYPE_UNSPECIFIED";
    case MandateTransaction_RecurrencePatternType.AS_PRESENTED:
      return "AS_PRESENTED";
    case MandateTransaction_RecurrencePatternType.BIMONTHLY:
      return "BIMONTHLY";
    case MandateTransaction_RecurrencePatternType.DAILY:
      return "DAILY";
    case MandateTransaction_RecurrencePatternType.FORTNIGHTLY:
      return "FORTNIGHTLY";
    case MandateTransaction_RecurrencePatternType.HALF_YEARLY:
      return "HALF_YEARLY";
    case MandateTransaction_RecurrencePatternType.MONTHLY:
      return "MONTHLY";
    case MandateTransaction_RecurrencePatternType.ONE_TIME:
      return "ONE_TIME";
    case MandateTransaction_RecurrencePatternType.QUARTERLY:
      return "QUARTERLY";
    case MandateTransaction_RecurrencePatternType.WEEKLY:
      return "WEEKLY";
    case MandateTransaction_RecurrencePatternType.YEARLY:
      return "YEARLY";
    case MandateTransaction_RecurrencePatternType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RecurrenceRuleType specifies the recurrence rule type of mandate. */
export enum MandateTransaction_RecurrenceRuleType {
  /** RECURRENCE_RULE_TYPE_UNSPECIFIED - Unspecified recurrence rule type. */
  RECURRENCE_RULE_TYPE_UNSPECIFIED = 0,
  /** AFTER - After recurrence rule type. */
  AFTER = 1,
  /** BEFORE - Before recurrence rule type. */
  BEFORE = 2,
  /** ON - On recurrence rule type. */
  ON = 3,
  UNRECOGNIZED = -1,
}

export function mandateTransaction_RecurrenceRuleTypeFromJSON(object: any): MandateTransaction_RecurrenceRuleType {
  switch (object) {
    case 0:
    case "RECURRENCE_RULE_TYPE_UNSPECIFIED":
      return MandateTransaction_RecurrenceRuleType.RECURRENCE_RULE_TYPE_UNSPECIFIED;
    case 1:
    case "AFTER":
      return MandateTransaction_RecurrenceRuleType.AFTER;
    case 2:
    case "BEFORE":
      return MandateTransaction_RecurrenceRuleType.BEFORE;
    case 3:
    case "ON":
      return MandateTransaction_RecurrenceRuleType.ON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MandateTransaction_RecurrenceRuleType.UNRECOGNIZED;
  }
}

export function mandateTransaction_RecurrenceRuleTypeToJSON(object: MandateTransaction_RecurrenceRuleType): string {
  switch (object) {
    case MandateTransaction_RecurrenceRuleType.RECURRENCE_RULE_TYPE_UNSPECIFIED:
      return "RECURRENCE_RULE_TYPE_UNSPECIFIED";
    case MandateTransaction_RecurrenceRuleType.AFTER:
      return "AFTER";
    case MandateTransaction_RecurrenceRuleType.BEFORE:
      return "BEFORE";
    case MandateTransaction_RecurrenceRuleType.ON:
      return "ON";
    case MandateTransaction_RecurrenceRuleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AmountRuleType specifies the type of rule associated with the mandate
 * amount.
 */
export enum MandateTransaction_AmountRuleType {
  /** AMOUNT_RULE_TYPE_UNSPECIFIED - Unspecified amount rule. */
  AMOUNT_RULE_TYPE_UNSPECIFIED = 0,
  /**
   * EXACT - Exact amount rule. Amount specified is the exact amount for which
   * mandate could be granted.
   */
  EXACT = 1,
  /**
   * MAX - Max amount rule. Amount specified is the maximum amount for which
   * mandate could be granted.
   */
  MAX = 2,
  UNRECOGNIZED = -1,
}

export function mandateTransaction_AmountRuleTypeFromJSON(object: any): MandateTransaction_AmountRuleType {
  switch (object) {
    case 0:
    case "AMOUNT_RULE_TYPE_UNSPECIFIED":
      return MandateTransaction_AmountRuleType.AMOUNT_RULE_TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return MandateTransaction_AmountRuleType.EXACT;
    case 2:
    case "MAX":
      return MandateTransaction_AmountRuleType.MAX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MandateTransaction_AmountRuleType.UNRECOGNIZED;
  }
}

export function mandateTransaction_AmountRuleTypeToJSON(object: MandateTransaction_AmountRuleType): string {
  switch (object) {
    case MandateTransaction_AmountRuleType.AMOUNT_RULE_TYPE_UNSPECIFIED:
      return "AMOUNT_RULE_TYPE_UNSPECIFIED";
    case MandateTransaction_AmountRuleType.EXACT:
      return "EXACT";
    case MandateTransaction_AmountRuleType.MAX:
      return "MAX";
    case MandateTransaction_AmountRuleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A complaint API transaction processed by the issuer switch. In
 * UPI, this maps to the Complaint API.
 */
export interface ComplaintTransaction {
  /**
   * The name of the complaint transaction. This uniquely identifies the
   * transaction. Format of name is
   * projects/{project_id}/complaintTransactions/{complaint_transaction_id}.
   */
  name: string;
  /** Information about the transaction. */
  info:
    | TransactionInfo
    | undefined;
  /**
   * Output only. Information about the complaint transaction when it is of
   * type complaint.
   */
  complaint?:
    | Complaint
    | undefined;
  /**
   * Output only. Information about the complaint transaction when it is of
   * type dispute.
   */
  dispute?: Dispute | undefined;
}

/**
 * Request for the `ListMetadataTransactions` method. Callers can request for
 * transactions to be filtered by the given filter criteria and specified
 * pagination parameters.
 */
export interface ListMetadataTransactionsRequest {
  /** Required. The parent resource. The format is `projects/{project}`. */
  parent: string;
  /**
   * The maximum number of transactions to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 1,
   * at most 50 transactions will be returned. The maximum value is 1000; values
   * above 1000 will be coerced to 1000. While paginating, you can specify a new
   * page size parameter for each page of transactions to be listed.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListMetadataTransactions` call.
   * Specify this parameter to retrieve the next page of transactions.
   *
   * When paginating, you must specify only the `page_token` parameter. The
   * filter that was specified in the initial call to the
   * `ListMetadataTransactions` method that returned the page token will be
   * reused for all further calls where the page token parameter is specified.
   */
  pageToken: string;
  /**
   * An expression that filters the list of metadata transactions.
   *
   * A filter expression consists of a field name, a comparison
   * operator, and a value for filtering. The value must be a string, a
   * number, or a boolean. The comparison operator must be one of: `<`, `>` or
   * `=`. Filters are not case sensitive.
   *
   * The following fields in the `MetadataTransaction` are eligible for
   * filtering:
   *
   *   * `apiType` - The API type of the metadata transaction. Must be one of
   *   [ApiType][google.cloud.paymentgateway.issuerswitch.v1.ApiType] values.
   *   Allowed comparison operators: `=`.
   *   * `transactionType` - The transaction type of the metadata transaction.
   *   Must be one of
   *   [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
   *   values. Allowed comparison operators: `=`.
   *   * `transactionID` - The UPI transaction ID of the metadata transaction.
   *   Allowed comparison operators: `=`.
   *   * `createTime` - The time at which the transaction was created
   *   (received) by the issuer switch. The value should be in
   *   the format `YYYY-MM-DDTHH:MM:SSZ`. Allowed comparison operators: `>`,
   *   `<`.
   *
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. Expressions are combined with AND logic. No other logical
   * operators are supported.
   *
   * Here are a few examples:
   *
   *   * `apiType = LIST_ACCOUNTS` -  - The API type is _LIST_ACCOUNTS_.
   *   * `state = SUCCEEDED` - The transaction's state is _SUCCEEDED_.
   *   * `(apiType = LIST_ACCOUNTS) AND (create_time <
   *   \"2021-08-15T14:50:00Z\")` - The API type is _LIST_ACCOUNTS_ and
   *   the transaction was received before _2021-08-15 14:50:00 UTC_.
   */
  filter: string;
}

/**
 * Request for the `ListFinancialTransactions` method. Callers can request for
 * transactions to be filtered by the given filter criteria and specified
 * pagination parameters.
 */
export interface ListFinancialTransactionsRequest {
  /** Required. The parent resource. The format is `projects/{project}`. */
  parent: string;
  /**
   * The maximum number of transactions to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 1,
   * at most 50 transactions will be returned. The maximum value is 1000; values
   * above 1000 will be coerced to 1000. While paginating, you can specify a new
   * page size parameter for each page of transactions to be listed.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListFinancialTransactions` call.
   * Specify this parameter to retrieve the next page of transactions.
   *
   * When paginating, you must specify only the `page_token` parameter. The
   * filter that was specified in the initial call to the
   * `ListFinancialTransactions` method that returned the page token will be
   * reused for all further calls where the page token parameter is specified.
   */
  pageToken: string;
  /**
   * An expression that filters the list of financial transactions.
   *
   * A filter expression consists of a field name, a comparison operator, and
   * a value for filtering. The value must be a string, a number, or a
   * boolean. The comparison operator must be one of: `<`, `>`, or `=`.
   * Filters are not case sensitive.
   *
   * The following fields in the `FinancialTransaction` are eligible for
   * filtering:
   *
   *   * `transactionID` - The UPI transaction ID of the financial
   *   transaction. Allowed comparison operators: `=`.
   *   * `RRN` - The retrieval reference number of the transaction. Allowed
   *   comparison operators: `=`.
   *   * `payerVPA` - The VPA of the payer in a financial transaction. Allowed
   *   comparison operators: `=`.
   *   * `payeeVPA` - The VPA of the payee in a financial transaction. Allowed
   *   comparison operators: `=`.
   *   * `payerMobileNumber` - The mobile number of the payer in a financial
   *      transaction. Allowed comparison operators: `=`.
   *   * `payeeMobileNumber` - The mobile number of the payee in a financial
   *      transaction. Allowed comparison operators: `=`.
   *   * `createTime` - The time at which the transaction was created
   *   (received) by the issuer switch. The value should be in
   *   the format `YYYY-MM-DDTHH:MM:SSZ`. Allowed comparison operators: `>`,
   *   `<`.
   *
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. Expressions are combined with AND logic. No other logical
   * operators are supported.
   *
   * Here are a few examples:
   *
   *   * `rrn = 123456789123` - The RRN is _123456789123_.
   *   * `payerVpa = example@goog` - The VPA of the payer is the string
   *   _example@goog_.
   *   * `(payeeVpa = example@goog) AND (createTime < "2021-08-15T14:50:00Z")`
   *   - The VPA of the payee is _example@goog_ and the transaction was received
   *   before _2021-08-15 14:50:00 UTC_.
   *   * `createTime > "2021-08-15T14:50:00Z" AND createTime <
   *   "2021-08-16T14:50:00Z"` - The transaction was received between
   *   _2021-08-15 14:50:00 UTC_ and _2021-08-16 14:50:00 UTC_.
   */
  filter: string;
}

/**
 * Request for the `ListMandateTransactions` method. Callers can request for
 * transactions to be filtered by the given filter criteria and specified
 * pagination parameters.
 */
export interface ListMandateTransactionsRequest {
  /** Required. The parent resource. The format is `projects/{project}`. */
  parent: string;
  /**
   * The maximum number of transactions to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 1,
   * at most 50 transactions will be returned. The maximum value is 1000; values
   * above 1000 will be coerced to 1000. While paginating, you can specify a new
   * page size parameter for each page of transactions to be listed.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListMandateTransactions` call.
   * Specify this parameter to retrieve the next page of transactions.
   *
   * When paginating, you must specify only the `page_token` parameter. The
   * filter that was specified in the initial call to the
   * `ListMandateTransactions` method that returned the page token will be
   * reused for all further calls where the page token parameter is specified.
   */
  pageToken: string;
  /**
   * An expression that filters the list of mandate transactions.
   *
   * A filter expression consists of a field name, a comparison operator, and
   * a value for filtering. The value must be a string, a number, or a
   * boolean. The comparison operator must be one of: `<`, `>`, or `=`.
   * Filters are not case sensitive.
   *
   * The following fields in the `Mandate` are eligible for
   * filtering:
   *
   *   * `uniqueMandateNumber` - UPI Unique Mandate Number (UMN). Allowed
   *   comparison operators: `=`.
   *   * `transactionID` - The transaction ID of the mandate transaction.
   *   Allowed comparison operators: `=`.
   *   * `transactionType` - The transaction type of the mandate
   *   transaction. Must be one of
   *   [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
   *   values. For mandate transactions, only valid transaction types are
   *   `TRANSACTION_TYPE_CREATE`, `TRANSACTION_TYPE_REVOKE` and
   *   `TRANSACTION_TYPE_UPDATE`. Allowed comparison operators: `=`.
   *   * `createTime` - The time at which the transaction was created
   *   (received) by the issuer switch. The value should be in
   *   the format `YYYY-MM-DDTHH:MM:SSZ`. Allowed comparison
   *   operators: `>`, `<`.
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. Expressions are combined with AND logic. No other logical
   * operators are supported.
   *
   * Here are a few examples:
   *   * `recurrencePattern = MONTHLY` - The recurrence pattern type is
   *   monthly.
   *   * `state = SUCCEEDED` - The transaction's state is _SUCCEEDED_.
   *   * `payerVPA = example@okbank` - The VPA of the payer is the string
   *   _example@okbank_.
   *   * `(payerVPA = example@okbank) AND (createTime <
   *   "2021-08-15T14:50:00Z")`
   *   - The payer VPA example@okbank and the transaction was received
   *   before _2021-08-15 14:50:00 UTC_.
   *   * `createTime > "2021-08-15T14:50:00Z" AND createTime <
   *   "2021-08-16T14:50:00Z"` - The transaction was received between
   *   _2021-08-15 14:50:00 UTC_ and _2021-08-16 14:50:00 UTC_.
   *   * `startDate > "2021-08-15" AND startDate < "2021-08-17"` - The start
   *   date for mandate is between _2021-08-15_ and _2021-08-17_.
   */
  filter: string;
}

/**
 * Request for the `ListComplaintTransactions` method. Callers can request for
 * transactions to be filtered by the given filter criteria and specified
 * pagination parameters.
 */
export interface ListComplaintTransactionsRequest {
  /** Required. The parent resource. The format is `projects/{project}`. */
  parent: string;
  /**
   * The maximum number of transactions to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 1,
   * at most 50 transactions will be returned. The maximum value is 1000; values
   * above 1000 will be coerced to 1000. While paginating, you can specify a new
   * page size parameter for each page of transactions to be listed.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListComplaintTransactions` call.
   * Specify this parameter to retrieve the next page of transactions.
   *
   * When paginating, you must specify only the `page_token` parameter. The
   * filter that was specified in the initial call to the
   * `ListComplaintTransactions` method that returned the page token will be
   * reused for all further calls where the page token parameter is specified.
   */
  pageToken: string;
  /**
   * An expression that filters the list of complaint transactions.
   *
   * A filter expression consists of a field name, a comparison operator, and
   * a value for filtering. The value must be a string, a number, or a
   * boolean. The comparison operator must be one of: `<`, `>`, or `=`.
   * Filters are not case sensitive.
   *
   * The following fields in the `Complaint` are eligible for
   * filtering:
   *
   *   * `transactionID` - The transaction ID of the complaint transaction.
   *   Allowed comparison operators: `=`.
   *   * `transactionType` - The transaction type of the complaint
   *   transaction. Must be one of
   *   [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
   *   values. For complaint transactions, only valid transaction types are
   *  `TRANSACTION_TYPE_CHECK_STATUS`, `TRANSACTION_TYPE_COMPLAINT`,
   *  `TRANSACTION_TYPE_REVERSAL`, `TRANSACTION_TYPE_DISPUTE`,
   *  `TRANSACTION_TYPE_REFUND` or `TRANSACTION_TYPE_STATUS_UPDATE`. Allowed
   *   comparison operators: `=`.
   *   * `originalRRN` - The retrieval reference number of the original
   *   transaction for which complaint / dispute was raised / resolved. Allowed
   *   comparison operators: `=`.
   *   * `createTime` - The time at which the transaction was created
   *   (received) by the issuer switch. The value should be in
   *   the format `YYYY-MM-DDTHH:MM:SSZ`. Allowed comparison
   *   operators: `>`, `<`.
   *   * `state` - The state of the transaction. Must be one of
   *   [TransactionInfo.State][google.cloud.paymentgateway.issuerswitch.v1.TransactionInfo.State]
   *   values. Allowed comparison operators: `=`.
   *   * `errorCode` - Use this filter to list complaint transactions which
   *   have failed a particular error code. Allowed comparison
   *   operators: `=`.
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. Expressions are combined with AND logic. No other logical
   * operators are supported.
   *
   * Here are a few examples:
   *
   *   * `state = SUCCEEDED` - The transaction's state is _SUCCEEDED_.
   *   * (createTime < "2021-08-15T14:50:00Z")`
   *   - The transaction was received before _2021-08-15 14:50:00 UTC_.
   *   * `createTime > "2021-08-15T14:50:00Z" AND createTime <
   *   "2021-08-16T14:50:00Z"` - The transaction was received between
   *   _2021-08-15 14:50:00 UTC_ and _2021-08-16 14:50:00 UTC_.
   */
  filter: string;
}

/** Response for the `ListMetadataTransactions` method. */
export interface ListMetadataTransactionsResponse {
  /**
   * List of non financial metadata transactions satisfying the filtered
   * request.
   */
  metadataTransactions: MetadataTransaction[];
  /**
   * Pass this token in the ListMetadataTransactionsRequest to continue to list
   * results. If all results have been returned, this field is an empty string
   * or not present in the response.
   */
  nextPageToken: string;
}

/** Response for the `ListFinancialTransactions` method. */
export interface ListFinancialTransactionsResponse {
  /** List of financial transactions satisfying the filtered request. */
  financialTransactions: FinancialTransaction[];
  /**
   * Pass this token in the ListFinancialTransactionsRequest to continue to list
   * results. If all results have been returned, this field is an empty string
   * or not present in the response.
   */
  nextPageToken: string;
}

/** Response for the `ListMandateTransactionsResponse` method. */
export interface ListMandateTransactionsResponse {
  /** List of mandate transactions satisfying the filtered request. */
  mandateTransactions: MandateTransaction[];
  /**
   * Pass this token in the ListMandateTransactionsRequest to continue to list
   * results. If all results have been returned, this field is an empty string
   * or not present in the response.
   */
  nextPageToken: string;
}

/** Response for the `ListComplaintTransactionsResponse` method. */
export interface ListComplaintTransactionsResponse {
  /** List of complaint transactions satisfying the filtered request. */
  complaintTransactions: ComplaintTransaction[];
  /**
   * Pass this token in the ListComplaintTransactionsRequest to continue to list
   * results. If all results have been returned, this field is an empty string
   * or not present in the response.
   */
  nextPageToken: string;
}

/** Request for the `ExportFinancialTransactions` method. */
export interface ExportFinancialTransactionsRequest {
  /**
   * Required. The parent resource for the transactions. The format is
   * `projects/{project}`.
   */
  parent: string;
  /**
   * Transaction type for the financial transaction API. The possible values for
   * transaction type are
   *
   * * TRANSACTION_TYPE_CREDIT
   * * TRANSACTION_TYPE_DEBIT
   * * TRANSACTION_TYPE_REVERSAL
   *
   * If no transaction type is specified, records of all the above transaction
   * types will be exported.
   */
  transactionType: TransactionType;
  /** The start time for the query. */
  startTime:
    | Date
    | undefined;
  /** The end time for the query. */
  endTime: Date | undefined;
}

/** Request for the `ExportMetadataTransactions` method. */
export interface ExportMetadataTransactionsRequest {
  /**
   * Required. The parent resource for the transactions. The format is
   * `projects/{project}`.
   */
  parent: string;
  /**
   * API type of the metadata transaction API. The possible values for API type
   * are
   *
   * * BALANCE
   * * CHECK_STATUS
   * * HEART_BEAT
   * * INITIATE_REGISTRATION
   * * LIST_ACCOUNTS
   * * UPDATE_CREDENTIALS
   * * VALIDATE_REGISTRATION
   *
   * If no API type is specified, records of all the above API types will be
   * exported.
   */
  apiType: ApiType;
  /** The start time for the query. */
  startTime:
    | Date
    | undefined;
  /** The end time for the query. */
  endTime: Date | undefined;
}

/** Request for the `ExportMandateTransactions` method. */
export interface ExportMandateTransactionsRequest {
  /**
   * Required. The parent resource for the transactions. The format is
   * `projects/{project}`.
   */
  parent: string;
  /**
   * Transaction type for the mandate transaction API.  The possible values for
   * transaction type are
   *
   * * TRANSACTION_TYPE_CREATE
   * * TRANSACTION_TYPE_REVOKE
   * * TRANSACTION_TYPE_UPDATE
   *
   * If no transaction type is specified, records of all the above transaction
   * types will be exported.
   */
  transactionType: TransactionType;
  /** The start time for the query. */
  startTime:
    | Date
    | undefined;
  /** The end time for the query. */
  endTime: Date | undefined;
}

/** Request for the `ExportComplaintTransactions` method. */
export interface ExportComplaintTransactionsRequest {
  /**
   * Required. The parent resource for the transactions. The format is
   * `projects/{project}`.
   */
  parent: string;
  /**
   * Transaction type for the complaint transaction API. The possible values for
   * transaction type are
   *
   * * TRANSACTION_TYPE_CHECK_STATUS
   * * TRANSACTION_TYPE_COMPLAINT
   * * TRANSACTION_TYPE_DISPUTE
   * * TRANSACTION_TYPE_REFUND
   * * TRANSACTION_TYPE_REVERSAL
   * * TRANSACTION_TYPE_STATUS_UPDATE
   *
   * If no transaction type is specified, records of all the above transaction
   * types will be exported.
   */
  transactionType: TransactionType;
  /** The start time for the query. */
  startTime:
    | Date
    | undefined;
  /** The end time for the query. */
  endTime: Date | undefined;
}

/** Response for the `ExportFinancialTransactions` method. */
export interface ExportFinancialTransactionsResponse {
  /** URI of the exported file. */
  targetUri: string;
}

/** Response for the `ExportMetadataTransactions` method. */
export interface ExportMetadataTransactionsResponse {
  /** URI of the exported file. */
  targetUri: string;
}

/** Response for the `ExportMandateTransactions` method. */
export interface ExportMandateTransactionsResponse {
  /** URI of the exported file. */
  targetUri: string;
}

/** Response for the `ExportComplaintTransactions` method. */
export interface ExportComplaintTransactionsResponse {
  /** URI of the exported file. */
  targetUri: string;
}

/** Metadata for ExportFinancialTransactions. */
export interface ExportFinancialTransactionsMetadata {
  /** Output only. The time at which the operation was created. */
  createTime: Date | undefined;
}

/** Metadata for ExportMandateTransactions. */
export interface ExportMandateTransactionsMetadata {
  /** Output only. The time at which the operation was created. */
  createTime: Date | undefined;
}

/** Metadata for ExportMetadataTransactions. */
export interface ExportMetadataTransactionsMetadata {
  /** Output only. The time at which the operation was created. */
  createTime: Date | undefined;
}

/** Metadata for ExportComplaintTransactions. */
export interface ExportComplaintTransactionsMetadata {
  /** Output only. The time at which the operation was created. */
  createTime: Date | undefined;
}

function createBaseTransactionInfo(): TransactionInfo {
  return {
    id: "",
    apiType: 0,
    transactionType: 0,
    transactionSubType: 0,
    state: 0,
    metadata: undefined,
    errorDetails: undefined,
    adapterInfo: undefined,
    riskInfo: [],
  };
}

export const TransactionInfo: MessageFns<TransactionInfo> = {
  encode(message: TransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.apiType !== 0) {
      writer.uint32(16).int32(message.apiType);
    }
    if (message.transactionType !== 0) {
      writer.uint32(24).int32(message.transactionType);
    }
    if (message.transactionSubType !== 0) {
      writer.uint32(32).int32(message.transactionSubType);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.metadata !== undefined) {
      TransactionInfo_TransactionMetadata.encode(message.metadata, writer.uint32(50).fork()).join();
    }
    if (message.errorDetails !== undefined) {
      TransactionInfo_TransactionErrorDetails.encode(message.errorDetails, writer.uint32(58).fork()).join();
    }
    if (message.adapterInfo !== undefined) {
      TransactionInfo_AdapterInfo.encode(message.adapterInfo, writer.uint32(66).fork()).join();
    }
    for (const v of message.riskInfo) {
      TransactionInfo_TransactionRiskInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.apiType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transactionSubType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = TransactionInfo_TransactionMetadata.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorDetails = TransactionInfo_TransactionErrorDetails.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.adapterInfo = TransactionInfo_AdapterInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.riskInfo.push(TransactionInfo_TransactionRiskInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      apiType: isSet(object.apiType) ? apiTypeFromJSON(object.apiType) : 0,
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      transactionSubType: isSet(object.transactionSubType)
        ? transactionInfo_TransactionSubTypeFromJSON(object.transactionSubType)
        : 0,
      state: isSet(object.state) ? transactionInfo_StateFromJSON(object.state) : 0,
      metadata: isSet(object.metadata) ? TransactionInfo_TransactionMetadata.fromJSON(object.metadata) : undefined,
      errorDetails: isSet(object.errorDetails)
        ? TransactionInfo_TransactionErrorDetails.fromJSON(object.errorDetails)
        : undefined,
      adapterInfo: isSet(object.adapterInfo) ? TransactionInfo_AdapterInfo.fromJSON(object.adapterInfo) : undefined,
      riskInfo: globalThis.Array.isArray(object?.riskInfo)
        ? object.riskInfo.map((e: any) => TransactionInfo_TransactionRiskInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.apiType !== 0) {
      obj.apiType = apiTypeToJSON(message.apiType);
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.transactionSubType !== 0) {
      obj.transactionSubType = transactionInfo_TransactionSubTypeToJSON(message.transactionSubType);
    }
    if (message.state !== 0) {
      obj.state = transactionInfo_StateToJSON(message.state);
    }
    if (message.metadata !== undefined) {
      obj.metadata = TransactionInfo_TransactionMetadata.toJSON(message.metadata);
    }
    if (message.errorDetails !== undefined) {
      obj.errorDetails = TransactionInfo_TransactionErrorDetails.toJSON(message.errorDetails);
    }
    if (message.adapterInfo !== undefined) {
      obj.adapterInfo = TransactionInfo_AdapterInfo.toJSON(message.adapterInfo);
    }
    if (message.riskInfo?.length) {
      obj.riskInfo = message.riskInfo.map((e) => TransactionInfo_TransactionRiskInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo>): TransactionInfo {
    return TransactionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo>): TransactionInfo {
    const message = createBaseTransactionInfo();
    message.id = object.id ?? "";
    message.apiType = object.apiType ?? 0;
    message.transactionType = object.transactionType ?? 0;
    message.transactionSubType = object.transactionSubType ?? 0;
    message.state = object.state ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? TransactionInfo_TransactionMetadata.fromPartial(object.metadata)
      : undefined;
    message.errorDetails = (object.errorDetails !== undefined && object.errorDetails !== null)
      ? TransactionInfo_TransactionErrorDetails.fromPartial(object.errorDetails)
      : undefined;
    message.adapterInfo = (object.adapterInfo !== undefined && object.adapterInfo !== null)
      ? TransactionInfo_AdapterInfo.fromPartial(object.adapterInfo)
      : undefined;
    message.riskInfo = object.riskInfo?.map((e) => TransactionInfo_TransactionRiskInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionInfo_TransactionMetadata(): TransactionInfo_TransactionMetadata {
  return {
    createTime: undefined,
    updateTime: undefined,
    referenceId: "",
    referenceUri: "",
    description: "",
    initiationMode: "",
    purposeCode: "",
    referenceCategory: "",
  };
}

export const TransactionInfo_TransactionMetadata: MessageFns<TransactionInfo_TransactionMetadata> = {
  encode(message: TransactionInfo_TransactionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    if (message.referenceId !== "") {
      writer.uint32(26).string(message.referenceId);
    }
    if (message.referenceUri !== "") {
      writer.uint32(34).string(message.referenceUri);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.initiationMode !== "") {
      writer.uint32(50).string(message.initiationMode);
    }
    if (message.purposeCode !== "") {
      writer.uint32(58).string(message.purposeCode);
    }
    if (message.referenceCategory !== "") {
      writer.uint32(66).string(message.referenceCategory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_TransactionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_TransactionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.referenceUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.initiationMode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.purposeCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.referenceCategory = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_TransactionMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
      referenceUri: isSet(object.referenceUri) ? globalThis.String(object.referenceUri) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      initiationMode: isSet(object.initiationMode) ? globalThis.String(object.initiationMode) : "",
      purposeCode: isSet(object.purposeCode) ? globalThis.String(object.purposeCode) : "",
      referenceCategory: isSet(object.referenceCategory) ? globalThis.String(object.referenceCategory) : "",
    };
  },

  toJSON(message: TransactionInfo_TransactionMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    if (message.referenceUri !== "") {
      obj.referenceUri = message.referenceUri;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.initiationMode !== "") {
      obj.initiationMode = message.initiationMode;
    }
    if (message.purposeCode !== "") {
      obj.purposeCode = message.purposeCode;
    }
    if (message.referenceCategory !== "") {
      obj.referenceCategory = message.referenceCategory;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo_TransactionMetadata>): TransactionInfo_TransactionMetadata {
    return TransactionInfo_TransactionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo_TransactionMetadata>): TransactionInfo_TransactionMetadata {
    const message = createBaseTransactionInfo_TransactionMetadata();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.referenceId = object.referenceId ?? "";
    message.referenceUri = object.referenceUri ?? "";
    message.description = object.description ?? "";
    message.initiationMode = object.initiationMode ?? "";
    message.purposeCode = object.purposeCode ?? "";
    message.referenceCategory = object.referenceCategory ?? "";
    return message;
  },
};

function createBaseTransactionInfo_TransactionErrorDetails(): TransactionInfo_TransactionErrorDetails {
  return { errorCode: "", errorMessage: "", upiErrorCode: "" };
}

export const TransactionInfo_TransactionErrorDetails: MessageFns<TransactionInfo_TransactionErrorDetails> = {
  encode(message: TransactionInfo_TransactionErrorDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.upiErrorCode !== "") {
      writer.uint32(26).string(message.upiErrorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_TransactionErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_TransactionErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.upiErrorCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_TransactionErrorDetails {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      upiErrorCode: isSet(object.upiErrorCode) ? globalThis.String(object.upiErrorCode) : "",
    };
  },

  toJSON(message: TransactionInfo_TransactionErrorDetails): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.upiErrorCode !== "") {
      obj.upiErrorCode = message.upiErrorCode;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo_TransactionErrorDetails>): TransactionInfo_TransactionErrorDetails {
    return TransactionInfo_TransactionErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo_TransactionErrorDetails>): TransactionInfo_TransactionErrorDetails {
    const message = createBaseTransactionInfo_TransactionErrorDetails();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.upiErrorCode = object.upiErrorCode ?? "";
    return message;
  },
};

function createBaseTransactionInfo_AdapterInfo(): TransactionInfo_AdapterInfo {
  return { requestIds: "", responseMetadata: undefined };
}

export const TransactionInfo_AdapterInfo: MessageFns<TransactionInfo_AdapterInfo> = {
  encode(message: TransactionInfo_AdapterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestIds !== "") {
      writer.uint32(10).string(message.requestIds);
    }
    if (message.responseMetadata !== undefined) {
      TransactionInfo_AdapterInfo_ResponseMetadata.encode(message.responseMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_AdapterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_AdapterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestIds = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.responseMetadata = TransactionInfo_AdapterInfo_ResponseMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_AdapterInfo {
    return {
      requestIds: isSet(object.requestIds) ? globalThis.String(object.requestIds) : "",
      responseMetadata: isSet(object.responseMetadata)
        ? TransactionInfo_AdapterInfo_ResponseMetadata.fromJSON(object.responseMetadata)
        : undefined,
    };
  },

  toJSON(message: TransactionInfo_AdapterInfo): unknown {
    const obj: any = {};
    if (message.requestIds !== "") {
      obj.requestIds = message.requestIds;
    }
    if (message.responseMetadata !== undefined) {
      obj.responseMetadata = TransactionInfo_AdapterInfo_ResponseMetadata.toJSON(message.responseMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo_AdapterInfo>): TransactionInfo_AdapterInfo {
    return TransactionInfo_AdapterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo_AdapterInfo>): TransactionInfo_AdapterInfo {
    const message = createBaseTransactionInfo_AdapterInfo();
    message.requestIds = object.requestIds ?? "";
    message.responseMetadata = (object.responseMetadata !== undefined && object.responseMetadata !== null)
      ? TransactionInfo_AdapterInfo_ResponseMetadata.fromPartial(object.responseMetadata)
      : undefined;
    return message;
  },
};

function createBaseTransactionInfo_AdapterInfo_ResponseMetadata(): TransactionInfo_AdapterInfo_ResponseMetadata {
  return { values: {} };
}

export const TransactionInfo_AdapterInfo_ResponseMetadata: MessageFns<TransactionInfo_AdapterInfo_ResponseMetadata> = {
  encode(
    message: TransactionInfo_AdapterInfo_ResponseMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.values).forEach(([key, value]) => {
      TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_AdapterInfo_ResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_AdapterInfo_ResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_AdapterInfo_ResponseMetadata {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionInfo_AdapterInfo_ResponseMetadata): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v;
        });
      }
    }
    return obj;
  },

  create(
    base?: DeepPartial<TransactionInfo_AdapterInfo_ResponseMetadata>,
  ): TransactionInfo_AdapterInfo_ResponseMetadata {
    return TransactionInfo_AdapterInfo_ResponseMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransactionInfo_AdapterInfo_ResponseMetadata>,
  ): TransactionInfo_AdapterInfo_ResponseMetadata {
    const message = createBaseTransactionInfo_AdapterInfo_ResponseMetadata();
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry(): TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
  return { key: "", value: "" };
}

export const TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry: MessageFns<
  TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry
> = {
  encode(
    message: TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry>,
  ): TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
    return TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry>,
  ): TransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry {
    const message = createBaseTransactionInfo_AdapterInfo_ResponseMetadata_ValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTransactionInfo_TransactionRiskInfo(): TransactionInfo_TransactionRiskInfo {
  return { provider: "", type: "", value: "" };
}

export const TransactionInfo_TransactionRiskInfo: MessageFns<TransactionInfo_TransactionRiskInfo> = {
  encode(message: TransactionInfo_TransactionRiskInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransactionInfo_TransactionRiskInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionInfo_TransactionRiskInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionInfo_TransactionRiskInfo {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionInfo_TransactionRiskInfo): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionInfo_TransactionRiskInfo>): TransactionInfo_TransactionRiskInfo {
    return TransactionInfo_TransactionRiskInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionInfo_TransactionRiskInfo>): TransactionInfo_TransactionRiskInfo {
    const message = createBaseTransactionInfo_TransactionRiskInfo();
    message.provider = object.provider ?? "";
    message.type = object.type ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMetadataTransaction(): MetadataTransaction {
  return { name: "", info: undefined, initiator: undefined };
}

export const MetadataTransaction: MessageFns<MetadataTransaction> = {
  encode(message: MetadataTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.info !== undefined) {
      TransactionInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    if (message.initiator !== undefined) {
      Participant.encode(message.initiator, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.info = TransactionInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.initiator = Participant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataTransaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      info: isSet(object.info) ? TransactionInfo.fromJSON(object.info) : undefined,
      initiator: isSet(object.initiator) ? Participant.fromJSON(object.initiator) : undefined,
    };
  },

  toJSON(message: MetadataTransaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.info !== undefined) {
      obj.info = TransactionInfo.toJSON(message.info);
    }
    if (message.initiator !== undefined) {
      obj.initiator = Participant.toJSON(message.initiator);
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataTransaction>): MetadataTransaction {
    return MetadataTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataTransaction>): MetadataTransaction {
    const message = createBaseMetadataTransaction();
    message.name = object.name ?? "";
    message.info = (object.info !== undefined && object.info !== null)
      ? TransactionInfo.fromPartial(object.info)
      : undefined;
    message.initiator = (object.initiator !== undefined && object.initiator !== null)
      ? Participant.fromPartial(object.initiator)
      : undefined;
    return message;
  },
};

function createBaseFinancialTransaction(): FinancialTransaction {
  return {
    name: "",
    info: undefined,
    retrievalReferenceNumber: "",
    payer: undefined,
    payee: undefined,
    amount: undefined,
    paymentRules: [],
  };
}

export const FinancialTransaction: MessageFns<FinancialTransaction> = {
  encode(message: FinancialTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.info !== undefined) {
      TransactionInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    if (message.retrievalReferenceNumber !== "") {
      writer.uint32(26).string(message.retrievalReferenceNumber);
    }
    if (message.payer !== undefined) {
      SettlementParticipant.encode(message.payer, writer.uint32(34).fork()).join();
    }
    if (message.payee !== undefined) {
      SettlementParticipant.encode(message.payee, writer.uint32(42).fork()).join();
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(50).fork()).join();
    }
    for (const v of message.paymentRules) {
      FinancialTransaction_PaymentRule.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinancialTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinancialTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.info = TransactionInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retrievalReferenceNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payer = SettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payee = SettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.paymentRules.push(FinancialTransaction_PaymentRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinancialTransaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      info: isSet(object.info) ? TransactionInfo.fromJSON(object.info) : undefined,
      retrievalReferenceNumber: isSet(object.retrievalReferenceNumber)
        ? globalThis.String(object.retrievalReferenceNumber)
        : "",
      payer: isSet(object.payer) ? SettlementParticipant.fromJSON(object.payer) : undefined,
      payee: isSet(object.payee) ? SettlementParticipant.fromJSON(object.payee) : undefined,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      paymentRules: globalThis.Array.isArray(object?.paymentRules)
        ? object.paymentRules.map((e: any) => FinancialTransaction_PaymentRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinancialTransaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.info !== undefined) {
      obj.info = TransactionInfo.toJSON(message.info);
    }
    if (message.retrievalReferenceNumber !== "") {
      obj.retrievalReferenceNumber = message.retrievalReferenceNumber;
    }
    if (message.payer !== undefined) {
      obj.payer = SettlementParticipant.toJSON(message.payer);
    }
    if (message.payee !== undefined) {
      obj.payee = SettlementParticipant.toJSON(message.payee);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.paymentRules?.length) {
      obj.paymentRules = message.paymentRules.map((e) => FinancialTransaction_PaymentRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinancialTransaction>): FinancialTransaction {
    return FinancialTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinancialTransaction>): FinancialTransaction {
    const message = createBaseFinancialTransaction();
    message.name = object.name ?? "";
    message.info = (object.info !== undefined && object.info !== null)
      ? TransactionInfo.fromPartial(object.info)
      : undefined;
    message.retrievalReferenceNumber = object.retrievalReferenceNumber ?? "";
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? SettlementParticipant.fromPartial(object.payer)
      : undefined;
    message.payee = (object.payee !== undefined && object.payee !== null)
      ? SettlementParticipant.fromPartial(object.payee)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.paymentRules = object.paymentRules?.map((e) => FinancialTransaction_PaymentRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinancialTransaction_PaymentRule(): FinancialTransaction_PaymentRule {
  return { paymentRule: 0, value: "" };
}

export const FinancialTransaction_PaymentRule: MessageFns<FinancialTransaction_PaymentRule> = {
  encode(message: FinancialTransaction_PaymentRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentRule !== 0) {
      writer.uint32(8).int32(message.paymentRule);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinancialTransaction_PaymentRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinancialTransaction_PaymentRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.paymentRule = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinancialTransaction_PaymentRule {
    return {
      paymentRule: isSet(object.paymentRule)
        ? financialTransaction_PaymentRule_PaymentRuleNameFromJSON(object.paymentRule)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FinancialTransaction_PaymentRule): unknown {
    const obj: any = {};
    if (message.paymentRule !== 0) {
      obj.paymentRule = financialTransaction_PaymentRule_PaymentRuleNameToJSON(message.paymentRule);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FinancialTransaction_PaymentRule>): FinancialTransaction_PaymentRule {
    return FinancialTransaction_PaymentRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinancialTransaction_PaymentRule>): FinancialTransaction_PaymentRule {
    const message = createBaseFinancialTransaction_PaymentRule();
    message.paymentRule = object.paymentRule ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMandateTransaction(): MandateTransaction {
  return {
    name: "",
    transactionInfo: undefined,
    uniqueMandateNumber: "",
    payer: undefined,
    payee: undefined,
    recurrencePattern: 0,
    recurrenceRuleType: 0,
    recurrenceRuleValue: 0,
    startDate: undefined,
    endDate: undefined,
    revokable: false,
    amount: 0,
    amountRule: 0,
    approvalReference: "",
    blockFunds: false,
    mandateName: "",
  };
}

export const MandateTransaction: MessageFns<MandateTransaction> = {
  encode(message: MandateTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.transactionInfo !== undefined) {
      TransactionInfo.encode(message.transactionInfo, writer.uint32(18).fork()).join();
    }
    if (message.uniqueMandateNumber !== "") {
      writer.uint32(26).string(message.uniqueMandateNumber);
    }
    if (message.payer !== undefined) {
      SettlementParticipant.encode(message.payer, writer.uint32(34).fork()).join();
    }
    if (message.payee !== undefined) {
      SettlementParticipant.encode(message.payee, writer.uint32(42).fork()).join();
    }
    if (message.recurrencePattern !== 0) {
      writer.uint32(48).int32(message.recurrencePattern);
    }
    if (message.recurrenceRuleType !== 0) {
      writer.uint32(56).int32(message.recurrenceRuleType);
    }
    if (message.recurrenceRuleValue !== 0) {
      writer.uint32(64).int32(message.recurrenceRuleValue);
    }
    if (message.startDate !== undefined) {
      DateMessage.encode(message.startDate, writer.uint32(74).fork()).join();
    }
    if (message.endDate !== undefined) {
      DateMessage.encode(message.endDate, writer.uint32(82).fork()).join();
    }
    if (message.revokable !== false) {
      writer.uint32(88).bool(message.revokable);
    }
    if (message.amount !== 0) {
      writer.uint32(97).double(message.amount);
    }
    if (message.amountRule !== 0) {
      writer.uint32(104).int32(message.amountRule);
    }
    if (message.approvalReference !== "") {
      writer.uint32(114).string(message.approvalReference);
    }
    if (message.blockFunds !== false) {
      writer.uint32(120).bool(message.blockFunds);
    }
    if (message.mandateName !== "") {
      writer.uint32(130).string(message.mandateName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MandateTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMandateTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionInfo = TransactionInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uniqueMandateNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payer = SettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payee = SettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.recurrencePattern = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.recurrenceRuleType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.recurrenceRuleValue = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.startDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.endDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.revokable = reader.bool();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.amount = reader.double();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.amountRule = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.approvalReference = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.blockFunds = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.mandateName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MandateTransaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      transactionInfo: isSet(object.transactionInfo) ? TransactionInfo.fromJSON(object.transactionInfo) : undefined,
      uniqueMandateNumber: isSet(object.uniqueMandateNumber) ? globalThis.String(object.uniqueMandateNumber) : "",
      payer: isSet(object.payer) ? SettlementParticipant.fromJSON(object.payer) : undefined,
      payee: isSet(object.payee) ? SettlementParticipant.fromJSON(object.payee) : undefined,
      recurrencePattern: isSet(object.recurrencePattern)
        ? mandateTransaction_RecurrencePatternTypeFromJSON(object.recurrencePattern)
        : 0,
      recurrenceRuleType: isSet(object.recurrenceRuleType)
        ? mandateTransaction_RecurrenceRuleTypeFromJSON(object.recurrenceRuleType)
        : 0,
      recurrenceRuleValue: isSet(object.recurrenceRuleValue) ? globalThis.Number(object.recurrenceRuleValue) : 0,
      startDate: isSet(object.startDate) ? DateMessage.fromJSON(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? DateMessage.fromJSON(object.endDate) : undefined,
      revokable: isSet(object.revokable) ? globalThis.Boolean(object.revokable) : false,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      amountRule: isSet(object.amountRule) ? mandateTransaction_AmountRuleTypeFromJSON(object.amountRule) : 0,
      approvalReference: isSet(object.approvalReference) ? globalThis.String(object.approvalReference) : "",
      blockFunds: isSet(object.blockFunds) ? globalThis.Boolean(object.blockFunds) : false,
      mandateName: isSet(object.mandateName) ? globalThis.String(object.mandateName) : "",
    };
  },

  toJSON(message: MandateTransaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.transactionInfo !== undefined) {
      obj.transactionInfo = TransactionInfo.toJSON(message.transactionInfo);
    }
    if (message.uniqueMandateNumber !== "") {
      obj.uniqueMandateNumber = message.uniqueMandateNumber;
    }
    if (message.payer !== undefined) {
      obj.payer = SettlementParticipant.toJSON(message.payer);
    }
    if (message.payee !== undefined) {
      obj.payee = SettlementParticipant.toJSON(message.payee);
    }
    if (message.recurrencePattern !== 0) {
      obj.recurrencePattern = mandateTransaction_RecurrencePatternTypeToJSON(message.recurrencePattern);
    }
    if (message.recurrenceRuleType !== 0) {
      obj.recurrenceRuleType = mandateTransaction_RecurrenceRuleTypeToJSON(message.recurrenceRuleType);
    }
    if (message.recurrenceRuleValue !== 0) {
      obj.recurrenceRuleValue = Math.round(message.recurrenceRuleValue);
    }
    if (message.startDate !== undefined) {
      obj.startDate = DateMessage.toJSON(message.startDate);
    }
    if (message.endDate !== undefined) {
      obj.endDate = DateMessage.toJSON(message.endDate);
    }
    if (message.revokable !== false) {
      obj.revokable = message.revokable;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.amountRule !== 0) {
      obj.amountRule = mandateTransaction_AmountRuleTypeToJSON(message.amountRule);
    }
    if (message.approvalReference !== "") {
      obj.approvalReference = message.approvalReference;
    }
    if (message.blockFunds !== false) {
      obj.blockFunds = message.blockFunds;
    }
    if (message.mandateName !== "") {
      obj.mandateName = message.mandateName;
    }
    return obj;
  },

  create(base?: DeepPartial<MandateTransaction>): MandateTransaction {
    return MandateTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MandateTransaction>): MandateTransaction {
    const message = createBaseMandateTransaction();
    message.name = object.name ?? "";
    message.transactionInfo = (object.transactionInfo !== undefined && object.transactionInfo !== null)
      ? TransactionInfo.fromPartial(object.transactionInfo)
      : undefined;
    message.uniqueMandateNumber = object.uniqueMandateNumber ?? "";
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? SettlementParticipant.fromPartial(object.payer)
      : undefined;
    message.payee = (object.payee !== undefined && object.payee !== null)
      ? SettlementParticipant.fromPartial(object.payee)
      : undefined;
    message.recurrencePattern = object.recurrencePattern ?? 0;
    message.recurrenceRuleType = object.recurrenceRuleType ?? 0;
    message.recurrenceRuleValue = object.recurrenceRuleValue ?? 0;
    message.startDate = (object.startDate !== undefined && object.startDate !== null)
      ? DateMessage.fromPartial(object.startDate)
      : undefined;
    message.endDate = (object.endDate !== undefined && object.endDate !== null)
      ? DateMessage.fromPartial(object.endDate)
      : undefined;
    message.revokable = object.revokable ?? false;
    message.amount = object.amount ?? 0;
    message.amountRule = object.amountRule ?? 0;
    message.approvalReference = object.approvalReference ?? "";
    message.blockFunds = object.blockFunds ?? false;
    message.mandateName = object.mandateName ?? "";
    return message;
  },
};

function createBaseComplaintTransaction(): ComplaintTransaction {
  return { name: "", info: undefined, complaint: undefined, dispute: undefined };
}

export const ComplaintTransaction: MessageFns<ComplaintTransaction> = {
  encode(message: ComplaintTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.info !== undefined) {
      TransactionInfo.encode(message.info, writer.uint32(18).fork()).join();
    }
    if (message.complaint !== undefined) {
      Complaint.encode(message.complaint, writer.uint32(26).fork()).join();
    }
    if (message.dispute !== undefined) {
      Dispute.encode(message.dispute, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplaintTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplaintTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.info = TransactionInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.complaint = Complaint.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dispute = Dispute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplaintTransaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      info: isSet(object.info) ? TransactionInfo.fromJSON(object.info) : undefined,
      complaint: isSet(object.complaint) ? Complaint.fromJSON(object.complaint) : undefined,
      dispute: isSet(object.dispute) ? Dispute.fromJSON(object.dispute) : undefined,
    };
  },

  toJSON(message: ComplaintTransaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.info !== undefined) {
      obj.info = TransactionInfo.toJSON(message.info);
    }
    if (message.complaint !== undefined) {
      obj.complaint = Complaint.toJSON(message.complaint);
    }
    if (message.dispute !== undefined) {
      obj.dispute = Dispute.toJSON(message.dispute);
    }
    return obj;
  },

  create(base?: DeepPartial<ComplaintTransaction>): ComplaintTransaction {
    return ComplaintTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComplaintTransaction>): ComplaintTransaction {
    const message = createBaseComplaintTransaction();
    message.name = object.name ?? "";
    message.info = (object.info !== undefined && object.info !== null)
      ? TransactionInfo.fromPartial(object.info)
      : undefined;
    message.complaint = (object.complaint !== undefined && object.complaint !== null)
      ? Complaint.fromPartial(object.complaint)
      : undefined;
    message.dispute = (object.dispute !== undefined && object.dispute !== null)
      ? Dispute.fromPartial(object.dispute)
      : undefined;
    return message;
  },
};

function createBaseListMetadataTransactionsRequest(): ListMetadataTransactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListMetadataTransactionsRequest: MessageFns<ListMetadataTransactionsRequest> = {
  encode(message: ListMetadataTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMetadataTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetadataTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetadataTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListMetadataTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetadataTransactionsRequest>): ListMetadataTransactionsRequest {
    return ListMetadataTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetadataTransactionsRequest>): ListMetadataTransactionsRequest {
    const message = createBaseListMetadataTransactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListFinancialTransactionsRequest(): ListFinancialTransactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListFinancialTransactionsRequest: MessageFns<ListFinancialTransactionsRequest> = {
  encode(message: ListFinancialTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFinancialTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFinancialTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFinancialTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListFinancialTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFinancialTransactionsRequest>): ListFinancialTransactionsRequest {
    return ListFinancialTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFinancialTransactionsRequest>): ListFinancialTransactionsRequest {
    const message = createBaseListFinancialTransactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListMandateTransactionsRequest(): ListMandateTransactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListMandateTransactionsRequest: MessageFns<ListMandateTransactionsRequest> = {
  encode(message: ListMandateTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMandateTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMandateTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMandateTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListMandateTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMandateTransactionsRequest>): ListMandateTransactionsRequest {
    return ListMandateTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMandateTransactionsRequest>): ListMandateTransactionsRequest {
    const message = createBaseListMandateTransactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListComplaintTransactionsRequest(): ListComplaintTransactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListComplaintTransactionsRequest: MessageFns<ListComplaintTransactionsRequest> = {
  encode(message: ListComplaintTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListComplaintTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComplaintTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListComplaintTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListComplaintTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListComplaintTransactionsRequest>): ListComplaintTransactionsRequest {
    return ListComplaintTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListComplaintTransactionsRequest>): ListComplaintTransactionsRequest {
    const message = createBaseListComplaintTransactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListMetadataTransactionsResponse(): ListMetadataTransactionsResponse {
  return { metadataTransactions: [], nextPageToken: "" };
}

export const ListMetadataTransactionsResponse: MessageFns<ListMetadataTransactionsResponse> = {
  encode(message: ListMetadataTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metadataTransactions) {
      MetadataTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMetadataTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetadataTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadataTransactions.push(MetadataTransaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetadataTransactionsResponse {
    return {
      metadataTransactions: globalThis.Array.isArray(object?.metadataTransactions)
        ? object.metadataTransactions.map((e: any) => MetadataTransaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMetadataTransactionsResponse): unknown {
    const obj: any = {};
    if (message.metadataTransactions?.length) {
      obj.metadataTransactions = message.metadataTransactions.map((e) => MetadataTransaction.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetadataTransactionsResponse>): ListMetadataTransactionsResponse {
    return ListMetadataTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetadataTransactionsResponse>): ListMetadataTransactionsResponse {
    const message = createBaseListMetadataTransactionsResponse();
    message.metadataTransactions = object.metadataTransactions?.map((e) => MetadataTransaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListFinancialTransactionsResponse(): ListFinancialTransactionsResponse {
  return { financialTransactions: [], nextPageToken: "" };
}

export const ListFinancialTransactionsResponse: MessageFns<ListFinancialTransactionsResponse> = {
  encode(message: ListFinancialTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.financialTransactions) {
      FinancialTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFinancialTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFinancialTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.financialTransactions.push(FinancialTransaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFinancialTransactionsResponse {
    return {
      financialTransactions: globalThis.Array.isArray(object?.financialTransactions)
        ? object.financialTransactions.map((e: any) => FinancialTransaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFinancialTransactionsResponse): unknown {
    const obj: any = {};
    if (message.financialTransactions?.length) {
      obj.financialTransactions = message.financialTransactions.map((e) => FinancialTransaction.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFinancialTransactionsResponse>): ListFinancialTransactionsResponse {
    return ListFinancialTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFinancialTransactionsResponse>): ListFinancialTransactionsResponse {
    const message = createBaseListFinancialTransactionsResponse();
    message.financialTransactions = object.financialTransactions?.map((e) => FinancialTransaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListMandateTransactionsResponse(): ListMandateTransactionsResponse {
  return { mandateTransactions: [], nextPageToken: "" };
}

export const ListMandateTransactionsResponse: MessageFns<ListMandateTransactionsResponse> = {
  encode(message: ListMandateTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mandateTransactions) {
      MandateTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMandateTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMandateTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mandateTransactions.push(MandateTransaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMandateTransactionsResponse {
    return {
      mandateTransactions: globalThis.Array.isArray(object?.mandateTransactions)
        ? object.mandateTransactions.map((e: any) => MandateTransaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMandateTransactionsResponse): unknown {
    const obj: any = {};
    if (message.mandateTransactions?.length) {
      obj.mandateTransactions = message.mandateTransactions.map((e) => MandateTransaction.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMandateTransactionsResponse>): ListMandateTransactionsResponse {
    return ListMandateTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMandateTransactionsResponse>): ListMandateTransactionsResponse {
    const message = createBaseListMandateTransactionsResponse();
    message.mandateTransactions = object.mandateTransactions?.map((e) => MandateTransaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListComplaintTransactionsResponse(): ListComplaintTransactionsResponse {
  return { complaintTransactions: [], nextPageToken: "" };
}

export const ListComplaintTransactionsResponse: MessageFns<ListComplaintTransactionsResponse> = {
  encode(message: ListComplaintTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.complaintTransactions) {
      ComplaintTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListComplaintTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListComplaintTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.complaintTransactions.push(ComplaintTransaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListComplaintTransactionsResponse {
    return {
      complaintTransactions: globalThis.Array.isArray(object?.complaintTransactions)
        ? object.complaintTransactions.map((e: any) => ComplaintTransaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListComplaintTransactionsResponse): unknown {
    const obj: any = {};
    if (message.complaintTransactions?.length) {
      obj.complaintTransactions = message.complaintTransactions.map((e) => ComplaintTransaction.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListComplaintTransactionsResponse>): ListComplaintTransactionsResponse {
    return ListComplaintTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListComplaintTransactionsResponse>): ListComplaintTransactionsResponse {
    const message = createBaseListComplaintTransactionsResponse();
    message.complaintTransactions = object.complaintTransactions?.map((e) => ComplaintTransaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseExportFinancialTransactionsRequest(): ExportFinancialTransactionsRequest {
  return { parent: "", transactionType: 0, startTime: undefined, endTime: undefined };
}

export const ExportFinancialTransactionsRequest: MessageFns<ExportFinancialTransactionsRequest> = {
  encode(message: ExportFinancialTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.transactionType !== 0) {
      writer.uint32(16).int32(message.transactionType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportFinancialTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportFinancialTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportFinancialTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ExportFinancialTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportFinancialTransactionsRequest>): ExportFinancialTransactionsRequest {
    return ExportFinancialTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportFinancialTransactionsRequest>): ExportFinancialTransactionsRequest {
    const message = createBaseExportFinancialTransactionsRequest();
    message.parent = object.parent ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseExportMetadataTransactionsRequest(): ExportMetadataTransactionsRequest {
  return { parent: "", apiType: 0, startTime: undefined, endTime: undefined };
}

export const ExportMetadataTransactionsRequest: MessageFns<ExportMetadataTransactionsRequest> = {
  encode(message: ExportMetadataTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.apiType !== 0) {
      writer.uint32(16).int32(message.apiType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMetadataTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMetadataTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.apiType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMetadataTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      apiType: isSet(object.apiType) ? apiTypeFromJSON(object.apiType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ExportMetadataTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.apiType !== 0) {
      obj.apiType = apiTypeToJSON(message.apiType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMetadataTransactionsRequest>): ExportMetadataTransactionsRequest {
    return ExportMetadataTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMetadataTransactionsRequest>): ExportMetadataTransactionsRequest {
    const message = createBaseExportMetadataTransactionsRequest();
    message.parent = object.parent ?? "";
    message.apiType = object.apiType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseExportMandateTransactionsRequest(): ExportMandateTransactionsRequest {
  return { parent: "", transactionType: 0, startTime: undefined, endTime: undefined };
}

export const ExportMandateTransactionsRequest: MessageFns<ExportMandateTransactionsRequest> = {
  encode(message: ExportMandateTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.transactionType !== 0) {
      writer.uint32(16).int32(message.transactionType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMandateTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMandateTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMandateTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ExportMandateTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMandateTransactionsRequest>): ExportMandateTransactionsRequest {
    return ExportMandateTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMandateTransactionsRequest>): ExportMandateTransactionsRequest {
    const message = createBaseExportMandateTransactionsRequest();
    message.parent = object.parent ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseExportComplaintTransactionsRequest(): ExportComplaintTransactionsRequest {
  return { parent: "", transactionType: 0, startTime: undefined, endTime: undefined };
}

export const ExportComplaintTransactionsRequest: MessageFns<ExportComplaintTransactionsRequest> = {
  encode(message: ExportComplaintTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.transactionType !== 0) {
      writer.uint32(16).int32(message.transactionType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportComplaintTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportComplaintTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportComplaintTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ExportComplaintTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportComplaintTransactionsRequest>): ExportComplaintTransactionsRequest {
    return ExportComplaintTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportComplaintTransactionsRequest>): ExportComplaintTransactionsRequest {
    const message = createBaseExportComplaintTransactionsRequest();
    message.parent = object.parent ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseExportFinancialTransactionsResponse(): ExportFinancialTransactionsResponse {
  return { targetUri: "" };
}

export const ExportFinancialTransactionsResponse: MessageFns<ExportFinancialTransactionsResponse> = {
  encode(message: ExportFinancialTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUri !== "") {
      writer.uint32(10).string(message.targetUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportFinancialTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportFinancialTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportFinancialTransactionsResponse {
    return { targetUri: isSet(object.targetUri) ? globalThis.String(object.targetUri) : "" };
  },

  toJSON(message: ExportFinancialTransactionsResponse): unknown {
    const obj: any = {};
    if (message.targetUri !== "") {
      obj.targetUri = message.targetUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportFinancialTransactionsResponse>): ExportFinancialTransactionsResponse {
    return ExportFinancialTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportFinancialTransactionsResponse>): ExportFinancialTransactionsResponse {
    const message = createBaseExportFinancialTransactionsResponse();
    message.targetUri = object.targetUri ?? "";
    return message;
  },
};

function createBaseExportMetadataTransactionsResponse(): ExportMetadataTransactionsResponse {
  return { targetUri: "" };
}

export const ExportMetadataTransactionsResponse: MessageFns<ExportMetadataTransactionsResponse> = {
  encode(message: ExportMetadataTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUri !== "") {
      writer.uint32(10).string(message.targetUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMetadataTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMetadataTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMetadataTransactionsResponse {
    return { targetUri: isSet(object.targetUri) ? globalThis.String(object.targetUri) : "" };
  },

  toJSON(message: ExportMetadataTransactionsResponse): unknown {
    const obj: any = {};
    if (message.targetUri !== "") {
      obj.targetUri = message.targetUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMetadataTransactionsResponse>): ExportMetadataTransactionsResponse {
    return ExportMetadataTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMetadataTransactionsResponse>): ExportMetadataTransactionsResponse {
    const message = createBaseExportMetadataTransactionsResponse();
    message.targetUri = object.targetUri ?? "";
    return message;
  },
};

function createBaseExportMandateTransactionsResponse(): ExportMandateTransactionsResponse {
  return { targetUri: "" };
}

export const ExportMandateTransactionsResponse: MessageFns<ExportMandateTransactionsResponse> = {
  encode(message: ExportMandateTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUri !== "") {
      writer.uint32(10).string(message.targetUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMandateTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMandateTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMandateTransactionsResponse {
    return { targetUri: isSet(object.targetUri) ? globalThis.String(object.targetUri) : "" };
  },

  toJSON(message: ExportMandateTransactionsResponse): unknown {
    const obj: any = {};
    if (message.targetUri !== "") {
      obj.targetUri = message.targetUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMandateTransactionsResponse>): ExportMandateTransactionsResponse {
    return ExportMandateTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMandateTransactionsResponse>): ExportMandateTransactionsResponse {
    const message = createBaseExportMandateTransactionsResponse();
    message.targetUri = object.targetUri ?? "";
    return message;
  },
};

function createBaseExportComplaintTransactionsResponse(): ExportComplaintTransactionsResponse {
  return { targetUri: "" };
}

export const ExportComplaintTransactionsResponse: MessageFns<ExportComplaintTransactionsResponse> = {
  encode(message: ExportComplaintTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetUri !== "") {
      writer.uint32(10).string(message.targetUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportComplaintTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportComplaintTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportComplaintTransactionsResponse {
    return { targetUri: isSet(object.targetUri) ? globalThis.String(object.targetUri) : "" };
  },

  toJSON(message: ExportComplaintTransactionsResponse): unknown {
    const obj: any = {};
    if (message.targetUri !== "") {
      obj.targetUri = message.targetUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportComplaintTransactionsResponse>): ExportComplaintTransactionsResponse {
    return ExportComplaintTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportComplaintTransactionsResponse>): ExportComplaintTransactionsResponse {
    const message = createBaseExportComplaintTransactionsResponse();
    message.targetUri = object.targetUri ?? "";
    return message;
  },
};

function createBaseExportFinancialTransactionsMetadata(): ExportFinancialTransactionsMetadata {
  return { createTime: undefined };
}

export const ExportFinancialTransactionsMetadata: MessageFns<ExportFinancialTransactionsMetadata> = {
  encode(message: ExportFinancialTransactionsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportFinancialTransactionsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportFinancialTransactionsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportFinancialTransactionsMetadata {
    return { createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined };
  },

  toJSON(message: ExportFinancialTransactionsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportFinancialTransactionsMetadata>): ExportFinancialTransactionsMetadata {
    return ExportFinancialTransactionsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportFinancialTransactionsMetadata>): ExportFinancialTransactionsMetadata {
    const message = createBaseExportFinancialTransactionsMetadata();
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseExportMandateTransactionsMetadata(): ExportMandateTransactionsMetadata {
  return { createTime: undefined };
}

export const ExportMandateTransactionsMetadata: MessageFns<ExportMandateTransactionsMetadata> = {
  encode(message: ExportMandateTransactionsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMandateTransactionsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMandateTransactionsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMandateTransactionsMetadata {
    return { createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined };
  },

  toJSON(message: ExportMandateTransactionsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMandateTransactionsMetadata>): ExportMandateTransactionsMetadata {
    return ExportMandateTransactionsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMandateTransactionsMetadata>): ExportMandateTransactionsMetadata {
    const message = createBaseExportMandateTransactionsMetadata();
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseExportMetadataTransactionsMetadata(): ExportMetadataTransactionsMetadata {
  return { createTime: undefined };
}

export const ExportMetadataTransactionsMetadata: MessageFns<ExportMetadataTransactionsMetadata> = {
  encode(message: ExportMetadataTransactionsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportMetadataTransactionsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportMetadataTransactionsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportMetadataTransactionsMetadata {
    return { createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined };
  },

  toJSON(message: ExportMetadataTransactionsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportMetadataTransactionsMetadata>): ExportMetadataTransactionsMetadata {
    return ExportMetadataTransactionsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportMetadataTransactionsMetadata>): ExportMetadataTransactionsMetadata {
    const message = createBaseExportMetadataTransactionsMetadata();
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseExportComplaintTransactionsMetadata(): ExportComplaintTransactionsMetadata {
  return { createTime: undefined };
}

export const ExportComplaintTransactionsMetadata: MessageFns<ExportComplaintTransactionsMetadata> = {
  encode(message: ExportComplaintTransactionsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportComplaintTransactionsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportComplaintTransactionsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportComplaintTransactionsMetadata {
    return { createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined };
  },

  toJSON(message: ExportComplaintTransactionsMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportComplaintTransactionsMetadata>): ExportComplaintTransactionsMetadata {
    return ExportComplaintTransactionsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportComplaintTransactionsMetadata>): ExportComplaintTransactionsMetadata {
    const message = createBaseExportComplaintTransactionsMetadata();
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

/**
 * Fetch the issuer switch participant.
 * Lists and exports transactions processed by the issuer switch.
 */
export type IssuerSwitchTransactionsDefinition = typeof IssuerSwitchTransactionsDefinition;
export const IssuerSwitchTransactionsDefinition = {
  name: "IssuerSwitchTransactions",
  fullName: "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
  methods: {
    /** List metadata transactions that satisfy the specified filter criteria. */
    listMetadataTransactions: {
      name: "ListMetadataTransactions",
      requestType: ListMetadataTransactionsRequest,
      requestStream: false,
      responseType: ListMetadataTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** List financial transactions that satisfy specified filter criteria. */
    listFinancialTransactions: {
      name: "ListFinancialTransactions",
      requestType: ListFinancialTransactionsRequest,
      requestStream: false,
      responseType: ListFinancialTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              110,
              97,
              110,
              99,
              105,
              97,
              108,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** List mandate transactions that satisfy specified filter criteria. */
    listMandateTransactions: {
      name: "ListMandateTransactions",
      requestType: ListMandateTransactionsRequest,
      requestStream: false,
      responseType: ListMandateTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              97,
              110,
              100,
              97,
              116,
              101,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** List complaint transactions that satisfy specified filter criteria. */
    listComplaintTransactions: {
      name: "ListComplaintTransactions",
      requestType: ListComplaintTransactionsRequest,
      requestStream: false,
      responseType: ListComplaintTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              109,
              112,
              108,
              97,
              105,
              110,
              116,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Export financial transactions received within the specified time range as a
     * file into a configured target location. The returned `Operation` type has
     * the following method-specific fields:
     *
     * - `metadata`:
     * [ExportFinancialTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsMetadata]
     * - `response`:
     * [ExportFinancialTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsResponse]
     *
     * The exported file will be in the standard CSV format where each row in the
     * file represents a transaction. The file has the following fields in order:
     *
     * 1. `TransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - UPI transaction ID.
     * 1. `TransactionType`
     *     * **Min Length** - 22 characters
     *     * **Max Length** - 25 characters
     *     * **Description** - Type of the transaction. This will be one of
     *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_DEBIT` or
     *     `TRANSACTION_TYPE_REVERSAL`.
     * 1. `TransactionSubType`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 7 characters
     *     * **Description** - Subtype of the transaction. This will be one of
     *     `COLLECT`, or `PAY`.
     * 1. `CreationTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating when the issuer
     *     switch created the transaction resource for processing the transaction.
     *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
     * 1. `State`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - State of the transaction. This will be one of
     *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
     * 1. `RRN`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Retrieval reference number associated with the
     *     transaction.
     * 1. `PayerVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payer.
     * 1. `PayerMobileNumber`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Mobile number of the payer.
     * 1. `PayerIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payer's bank account.
     * 1. `PayerAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payer's bank account number.
     * 1. `PayerAccountType`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 7 characters
     *     * **Description** - Payer's bank account type. This will be one of
     *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
     *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
     * 1. `PayeeVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payee.
     * 1. `PayeeMobileNumber`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Payee's mobile number.
     * 1. `PayeeIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payee's bank account.
     * 1. `PayeeAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payee's bank account number.
     * 1. `PayeeAccountType`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 10 characters
     *     * **Description** - Payee's bank account type. This will be one of
     *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
     *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
     * 1. `PayeeMerchantID`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Payee's merchant ID, only if the payee is a
     *     merchant.
     * 1. `PayeeMerchantName`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Payee's merchant name, only if the payee is a
     *     merchant.
     * 1. `PayeeMCC`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 4 characters
     *     * **Description** - Payee's Merchant Category Code (MCC), only if the
     *     payee is a merchant.
     * 1. `Currency`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Currency of the amount involved in the transaction.
     *     The currency codes are defined in ISO 4217.
     * 1. `Amount`
     *     * **Description** - Amount involved in the transaction.
     * 1. `AdapterRequestIDs`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 2,000 characters
     *     * **Description** - List of adapter request IDs (colon separated) used
     *     when invoking the Adapter APIs for fulfilling a transaction request.
     * 1. `ErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Error code of a failed transaction.
     * 1. `ErrorMessage`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 10,000 characters
     *     * **Description** - Error description for a failed transaction.
     * 1. `UPIErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Error code as per the UPI specification. The issuer
     *     switch maps the ErrorCode to an appropriate error code that complies
     *     with the UPI specification.
     * 1. `PayerDeviceInfoTypeAppName`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Payment application name on the payer's device.
     * 1. `PayerDeviceInfoTypeCapability`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Capability of the payer's device.
     * 1. `PayerDeviceInfoTypeGeoCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 15 characters
     *     * **Description** - Geo code of the payer's device. This will include
     *     floating point values for latitude and longitude (separated by colon).
     * 1. `PayerDeviceInfoTypeID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Device ID of the payer's device.
     * 1. `PayerDeviceInfoTypeIP`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 39 characters
     *     * **Description** - IP address of the payer's device.
     * 1. `PayerDeviceInfoTypeLocation`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 40 characters
     *     * **Description** - Coarse location of the payer's device.
     * 1. `PayerDeviceInfoTypeOS`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Operating system on the payer's device.
     * 1. `PayerDeviceInfoTypeTelecomProvider`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Telecom provider for the payer's device.
     * 1. `PayerDeviceInfoTypeDeviceType`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - Type of the payer's device. This will be one of
     *     'MOB', 'INET', 'USDC/USDB', 'POS'.
     * 1. `PayeeDeviceInfoTypeAppName`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Payment application name on the payee's device.
     * 1. `PayeeDeviceInfoTypeCapability`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Capability of the payee's device.
     * 1. `PayeeDeviceInfoTypeGeoCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 15 characters
     *     * **Description** - Geo code of the payee's device. This will include
     *     floating point values for latitude and longitude (separated by colon).
     * 1. `PayeeDeviceInfoTypeID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Device ID of the payee's device.
     * 1. `PayeeDeviceInfoTypeIP`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 39 characters
     *     * **Description** - IP address of the payee's device.
     * 1. `PayeeDeviceInfoTypeLocation`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 40 characters
     *     * **Description** - Coarse location of the payee's device.
     * 1. `PayeeDeviceInfoTypeOS`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Operating system on the payee's device.
     * 1. `PayeeDeviceInfoTypeTelecomProvider`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Telecom provider for the payee's device.
     * 1. `PayeeDeviceInfoTypeDeviceType`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - Type of the payee's device. This will be one of
     *     'MOB', 'INET', 'USDC/USDB', 'POS'.
     * 1. `ReferenceID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Consumer reference number to identify loan number,
     *     order id etc.
     * 1. `ReferenceURI`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - URL for the  transaction.
     * 1. `ReferenceCategory`
     *     * **Min Length** - 2 characters
     *     * **Max Length** - 2 characters
     *     * **Description** - Reference category.
     */
    exportFinancialTransactions: {
      name: "ExportFinancialTransactions",
      requestType: ExportFinancialTransactionsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              74,
              10,
              35,
              69,
              120,
              112,
              111,
              114,
              116,
              70,
              105,
              110,
              97,
              110,
              99,
              105,
              97,
              108,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              35,
              69,
              120,
              112,
              111,
              114,
              116,
              70,
              105,
              110,
              97,
              110,
              99,
              105,
              97,
              108,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              110,
              97,
              110,
              99,
              105,
              97,
              108,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Export metadata transactions received within the specified time range as a
     * file into a configured target location. The returned `Operation` type has
     * the following method-specific fields:
     *
     * - `metadata`:
     * [ExportMetadataTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsMetadata]
     * - `response`:
     * [ExportMetadataTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsResponse]
     *
     * The exported file will be in the standard CSV format where each row in the
     * file represents a transaction. The file has the following fields in order:
     *
     * 1. `TransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - UPI transaction ID.
     * 1. `APIType`
     *     * **Description** - The transaction's API type. The value will be of
     *     the [ApiType][google.cloud.paymentgateway.issuerswitch.v1.ApiType]
     *     enum.
     * 1. `TransactionType`
     *     * **Description** - Type of the transaction. The value will be of the
     *     [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
     *     enum.
     * 1. `CreationTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating when the issuer
     *     switch created the transaction resource for processing the transaction.
     *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
     * 1. `State`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - State of the transaction. This will be one of
     *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
     * 1. `OriginVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the originator of
     *     the transaction.
     * 1. `AdapterRequestIDs`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 2,000 characters
     *     * **Description** - List of adapter request IDs (colon separated) used
     *     when invoking the Adapter APIs for fulfilling a transaction request.
     * 1. `ErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Error code of the failed transaction.
     * 1. `ErrorMessage`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 10,000 characters
     *     * **Description** - Error description for the failed transaction.
     * 1. `UPIErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Error code as per the UPI specification. The issuer
     *     switch maps the ErrorCode to an appropriate error code that complies
     *     with the UPI specification.
     */
    exportMetadataTransactions: {
      name: "ExportMetadataTransactions",
      requestType: ExportMetadataTransactionsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              72,
              10,
              34,
              69,
              120,
              112,
              111,
              114,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              34,
              69,
              120,
              112,
              111,
              114,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Export mandate transactions received within the specified time range as a
     * file into a configured target location. The returned `Operation` type has
     * the following method-specific fields:
     *
     * - `metadata`:
     * [ExportMandateTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsMetadata]
     * - `response`:
     * [ExportMandateTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsResponse]
     *
     * The exported file will be in the standard CSV format where each row in the
     * file represents a transaction. The file has the following fields in order:
     *
     * 1. `TransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - UPI transaction ID.
     * 1. `UniqueMandateNumber`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 70 characters
     *     * **Description** - UPI Unique Mandate Number.
     * 1. `TransactionType`
     *     * **Min Length** - 23 characters
     *     * **Max Length** - 23 characters
     *     * **Description** - Type of the transaction. This will be one of
     *     `TRANSACTION_TYPE_CREATE`, `TRANSACTION_TYPE_REVOKE`,
     *     `TRANSACTION_TYPE_UPDATE`, `TRANSACTION_TYPE_PAUSE` or
     *     `TRANSACTION_TYPE_UNPAUSE`.
     * 1. `CreationTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating when the issuer
     *     switch created the transaction resource for processing the transaction.
     *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
     * 1. `State`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - State of the transaction. This will be one of
     *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
     * 1. `PayerVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payer.
     * 1. `PayerMobileNumber`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Mobile number of the payer.
     * 1. `PayerIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payer's bank account.
     * 1. `PayerAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payer's bank account number.
     * 1. `PayerAccountType`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 7 characters
     *     * **Description** - Payer's bank account type. This will be one of
     *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
     *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
     * 1. `PayeeVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payee.
     * 1. `PayeeMobileNumber`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Mobile number of the payee.
     * 1. `PayeeIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payee's bank account.
     * 1. `PayeeAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payee's bank account number.
     * 1. `PayeeAccountType`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 10 characters
     *     * **Description** - Payee's bank account type. This will be one of
     *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
     *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
     * 1. `PayeeMerchantID`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payee's merchant ID, only if the payee is a
     *     merchant
     * 1. `PayeeMerchantName`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Payee's merchant name, only if the payee is a
     *     merchant.
     * 1. `PayeeMCC`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 4 characters
     *     * **Description** - Payee's Merchant Category Code (MCC), only if the
     *     payee is a merchant.
     * 1. `Amount`
     *     * **Description** - Amount specified in the mandate.
     * 1. `RecurrencePattern`
     *     * **Description** - Reccurence pattern of the mandate. The value will
     *     be of the
     *     [MandateTransaction.RecurrencePatternType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrencePatternType]
     *     enum.
     * 1. `RecurrenceRuleType`
     *     * **Description** - Reccurrence rule type of the mandate. The value
     *     will be of the
     *     [MandateTransaction.RecurrenceRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrenceRuleType]
     *     enum.
     * 1. `RecurrenceRuleValue`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 2 characters
     *     * **Description** - Recurrence rule value of the mandate. This will be
     *     an integer between 1 and 31.
     * 1. `Revokeable`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 5 characters
     *     * **Description** - Boolean value specifying if the mandate is
     *     revokable.
     * 1. `StartDate`
     *     * **Min Length** - 10 characters
     *     * **Max Length** - 10 characters
     *     * **Description** - The start date of the mandate in `DD-MM-YYYY`
     *     format.
     * 1. `EndDate`
     *     * **Min Length** - 10 characters
     *     * **Max Length** - 10 characters
     *     * **Description** - The end date of the mandate in `DD-MM-YYYY` format.
     * 1. `AmountRuleType`
     *     * **Description** - The amount rule of the mandate. The value will be
     *     of the
     *     [MandateTransaction.AmountRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.AmountRuleType]
     *     enum.
     * 1. `ApprovalReference`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - The block funds reference generated by the bank, if
     *     funds have been blocked for the mandate. This column will have a value
     *     only when the RecurrencePattern is ONETIME.
     * 1. `BlockFunds`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 5 characters
     *     * **Description** - Boolean value specifying if the mandate transaction
     *     requested to block funds.
     * 1. `LastUpdateTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating when was the last
     *     modification made to the mandate. The format will be as per RFC-3339.
     *     Example : 2022-11-22T23:00:05Z
     * 1. `AdapterRequestIDs`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 2,000 characters
     *     * **Description** - List of adapter request IDs (colon separated) used
     *     when invoking the Adapter APIs for fulfilling a transaction request.
     * 1. `ErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Error code of the failed transaction.
     * 1. `ErrorMessage`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 10,000 characters
     *     * **Description** - Error description for the failed transaction.
     * 1. `UPIErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Error code as per the UPI specification. The issuer
     *     switch maps the ErrorCode to an appropriate error code that complies
     *     with the UPI specification.
     * 1. `PayerDeviceInfoTypeAppName`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Payment application name on the payer's device.
     * 1. `PayerDeviceInfoTypeCapability`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Capability of the payer's device.
     * 1. `PayerDeviceInfoTypeGeoCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 15 characters
     *     * **Description** - Geo code of the payer's device. This will include
     *     floating point values for latitude and longitude (separated by colon).
     * 1. `PayerDeviceInfoTypeID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Device ID of the payer's device.
     * 1. `PayerDeviceInfoTypeIP`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 39 characters
     *     * **Description** - IP address of the payer's device.
     * 1. `PayerDeviceInfoTypeLocation`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 40 characters
     *     * **Description** - Coarse location of the payer's device.
     * 1. `PayerDeviceInfoTypeOS`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Operating system on the payer's device.
     * 1. `PayerDeviceInfoTypeTelecomProvider`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Telecom provider for the payer's device.
     * 1. `PayerDeviceInfoTypeDeviceType`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - Type of the payer's device. This will be one of
     *     'MOB', 'INET', 'USDC/USDB', 'POS'.
     * 1. `PayeeDeviceInfoTypeAppName`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Payment application name on the payee's device.
     * 1. `PayeeDeviceInfoTypeCapability`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Capability of the payee's device.
     * 1. `PayeeDeviceInfoTypeGeoCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 15 characters
     *     * **Description** - Geo code of the payee's device. This will include
     *     floating point values for latitude and longitude (separated by colon).
     * 1. `PayeeDeviceInfoTypeID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Device ID of the payee's device.
     * 1. `PayeeDeviceInfoTypeIP`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 39 characters
     *     * **Description** - IP address of the payee's device.
     * 1. `PayeeDeviceInfoTypeLocation`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 40 characters
     *     * **Description** - Coarse location of the payee's device.
     * 1. `PayeeDeviceInfoTypeOS`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Operating system on the payee's device.
     * 1. `PayeeDeviceInfoTypeTelecomProvider`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 99 characters
     *     * **Description** - Telecom provider for the payee's device.
     * 1. `PayeeDeviceInfoTypeDeviceType`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - Type of the payee's device. This will be one of
     *     `MOB`, `INET`, `USDC/USDB`, `POS`.
     * 1. `ReferenceID`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Consumer reference number to identify loan number,
     *     order id etc.
     * 1. `ReferenceURI`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - URL for the  transaction.
     * 1. `ReferenceCategory`
     *     * **Min Length** - 2 characters
     *     * **Max Length** - 2 characters
     *     * **Description** - Reference category.
     * 1. `MandateName`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - The mandate's name.
     */
    exportMandateTransactions: {
      name: "ExportMandateTransactions",
      requestType: ExportMandateTransactionsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              70,
              10,
              33,
              69,
              120,
              112,
              111,
              114,
              116,
              77,
              97,
              110,
              100,
              97,
              116,
              101,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              33,
              69,
              120,
              112,
              111,
              114,
              116,
              77,
              97,
              110,
              100,
              97,
              116,
              101,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              97,
              110,
              100,
              97,
              116,
              101,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Export complaint transactions received within the specified time range as a
     * file into a configured target location. The returned `Operation` type has
     * the following method-specific fields:
     *
     * - `metadata`:
     * [ExportComplaintTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsMetadata]
     * - `response`:
     * [ExportComplaintTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsResponse]
     *
     * The exported file will be in the standard CSV format where each row in the
     * file represents a transaction. The file has the following fields in order:
     *
     * 1. `TransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - UPI transaction ID.
     * 1. `TransactionType`
     *     * **Min Length** - 23 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Type of the transaction. This will be one of
     *     `TRANSACTION_TYPE_CHECK_STATUS`, `TRANSACTION_TYPE_COMPLAINT`,
     *     `TRANSACTION_TYPE_REVERSAL`, `TRANSACTION_TYPE_DISPUTE`,
     *     `TRANSACTION_TYPE_REFUND`, or `TRANSACTION_TYPE_STATUS_UPDATE`.
     * 1. `CreationTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating when the issuer
     *     switch created the transaction resource for processing the transaction.
     *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
     * 1: `State`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 9 characters
     *     * **Description** - State of the transaction. This will be one of
     *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
     * 1. `OriginalRRN`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Retrieval reference number of the original payment
     *     transaction.
     * 1. `BankType`
     *     * **Min Length** - 8 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - The subtype of the transaction based on the bank
     *     involved. This will be one of `BENEFICIARY`, or `REMITTER`.
     * 1. `OriginalTransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Transaction ID of the original unresolved
     *     transaction.
     * 1. `RaiseComplaintAdjFlag`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the type of action to raise the
     *     complaint.
     * 1. `RaiseComplaintAdjCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the reason of action to raise the
     *     complaint.
     * 1. `ResolveComplaintAdjFlag`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the type of action to resolve the
     *     complaint.
     * 1. `ResolveComplaintAdjCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the reason of action to resolve the
     *     complaint.
     * 1. `RaiseDisputeAdjFlag`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the type of action to raise the dispute.
     * 1. `RaiseDisputeAdjCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the reason of action to raise the
     *     dispute.
     * 1. `ResolveDisputeAdjFlag`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the type of action to resolve the
     *     dispute.
     * 1. `ResolveDisputeAdjCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the reason of action to resolve the
     *     dispute.
     * 1. `Amount`
     *     * **Description** - Amount to be resolved.
     * 1. `CurrentCycle`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 5 characters
     *     * **Description** - Boolean value specifying if the complaint / dispute
     *     belongs to current settlement cycle or not.
     * 1. `CRN`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Defines the Complaint Reference number.
     * 1. `AdjTime`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the time when the resolution was done.
     * 1. `RespAdjFlag`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the response category type.
     * 1. `RespAdjCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the response reason used.
     * 1. `AdjRemarks`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Indicates the additional remarks for the complaint
     *     / dispute.
     * 1. `AdapterRequestIDs`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 2,000 characters
     *     * **Description** - List of adapter request IDs (colon separated) used
     *     when invoking the Adapter APIs for fulfilling a transaction request.
     * 1. `ErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Error code of the failed transaction.
     * 1. `ErrorMessage`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 10,000 characters
     *     * **Description** - Error description for the failed transaction.
     * 1. `UPIErrorCode`
     *     * **Min Length** - 0 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Error code as per the UPI specification. The issuer
     *     switch service maps the ErrorCode to an appropriate error code that
     *     complies with the UPI specification.
     */
    exportComplaintTransactions: {
      name: "ExportComplaintTransactions",
      requestType: ExportComplaintTransactionsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              74,
              10,
              35,
              69,
              120,
              112,
              111,
              114,
              116,
              67,
              111,
              109,
              112,
              108,
              97,
              105,
              110,
              116,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              35,
              69,
              120,
              112,
              111,
              114,
              116,
              67,
              111,
              109,
              112,
              108,
              97,
              105,
              110,
              116,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              111,
              109,
              112,
              108,
              97,
              105,
              110,
              116,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IssuerSwitchTransactionsServiceImplementation<CallContextExt = {}> {
  /** List metadata transactions that satisfy the specified filter criteria. */
  listMetadataTransactions(
    request: ListMetadataTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMetadataTransactionsResponse>>;
  /** List financial transactions that satisfy specified filter criteria. */
  listFinancialTransactions(
    request: ListFinancialTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFinancialTransactionsResponse>>;
  /** List mandate transactions that satisfy specified filter criteria. */
  listMandateTransactions(
    request: ListMandateTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMandateTransactionsResponse>>;
  /** List complaint transactions that satisfy specified filter criteria. */
  listComplaintTransactions(
    request: ListComplaintTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListComplaintTransactionsResponse>>;
  /**
   * Export financial transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportFinancialTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsMetadata]
   * - `response`:
   * [ExportFinancialTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 22 characters
   *     * **Max Length** - 25 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_DEBIT` or
   *     `TRANSACTION_TYPE_REVERSAL`.
   * 1. `TransactionSubType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Subtype of the transaction. This will be one of
   *     `COLLECT`, or `PAY`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `RRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number associated with the
   *     transaction.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayerAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Payer's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Payee's mobile number.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - Payee's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant.
   * 1. `PayeeMerchantName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Payee's merchant name, only if the payee is a
   *     merchant.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `Currency`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Currency of the amount involved in the transaction.
   *     The currency codes are defined in ISO 4217.
   * 1. `Amount`
   *     * **Description** - Amount involved in the transaction.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of a failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for a failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   * 1. `PayerDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payer's device.
   * 1. `PayerDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payer's device.
   * 1. `PayerDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payer's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayerDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payer's device.
   * 1. `PayerDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payer's device.
   * 1. `PayerDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payer's device.
   * 1. `PayerDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payer's device.
   * 1. `PayerDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payer's device.
   * 1. `PayerDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payer's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `PayeeDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payee's device.
   * 1. `PayeeDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payee's device.
   * 1. `PayeeDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payee's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayeeDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payee's device.
   * 1. `PayeeDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payee's device.
   * 1. `PayeeDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payee's device.
   * 1. `PayeeDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payee's device.
   * 1. `PayeeDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payee's device.
   * 1. `PayeeDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payee's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `ReferenceID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Consumer reference number to identify loan number,
   *     order id etc.
   * 1. `ReferenceURI`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - URL for the  transaction.
   * 1. `ReferenceCategory`
   *     * **Min Length** - 2 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Reference category.
   */
  exportFinancialTransactions(
    request: ExportFinancialTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Export metadata transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportMetadataTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsMetadata]
   * - `response`:
   * [ExportMetadataTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `APIType`
   *     * **Description** - The transaction's API type. The value will be of
   *     the [ApiType][google.cloud.paymentgateway.issuerswitch.v1.ApiType]
   *     enum.
   * 1. `TransactionType`
   *     * **Description** - Type of the transaction. The value will be of the
   *     [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
   *     enum.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `OriginVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the originator of
   *     the transaction.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   */
  exportMetadataTransactions(
    request: ExportMetadataTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Export mandate transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportMandateTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsMetadata]
   * - `response`:
   * [ExportMandateTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `UniqueMandateNumber`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 70 characters
   *     * **Description** - UPI Unique Mandate Number.
   * 1. `TransactionType`
   *     * **Min Length** - 23 characters
   *     * **Max Length** - 23 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREATE`, `TRANSACTION_TYPE_REVOKE`,
   *     `TRANSACTION_TYPE_UPDATE`, `TRANSACTION_TYPE_PAUSE` or
   *     `TRANSACTION_TYPE_UNPAUSE`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayerAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Payer's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payee.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - Payee's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant
   * 1. `PayeeMerchantName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Payee's merchant name, only if the payee is a
   *     merchant.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `Amount`
   *     * **Description** - Amount specified in the mandate.
   * 1. `RecurrencePattern`
   *     * **Description** - Reccurence pattern of the mandate. The value will
   *     be of the
   *     [MandateTransaction.RecurrencePatternType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrencePatternType]
   *     enum.
   * 1. `RecurrenceRuleType`
   *     * **Description** - Reccurrence rule type of the mandate. The value
   *     will be of the
   *     [MandateTransaction.RecurrenceRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrenceRuleType]
   *     enum.
   * 1. `RecurrenceRuleValue`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Recurrence rule value of the mandate. This will be
   *     an integer between 1 and 31.
   * 1. `Revokeable`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the mandate is
   *     revokable.
   * 1. `StartDate`
   *     * **Min Length** - 10 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - The start date of the mandate in `DD-MM-YYYY`
   *     format.
   * 1. `EndDate`
   *     * **Min Length** - 10 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - The end date of the mandate in `DD-MM-YYYY` format.
   * 1. `AmountRuleType`
   *     * **Description** - The amount rule of the mandate. The value will be
   *     of the
   *     [MandateTransaction.AmountRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.AmountRuleType]
   *     enum.
   * 1. `ApprovalReference`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - The block funds reference generated by the bank, if
   *     funds have been blocked for the mandate. This column will have a value
   *     only when the RecurrencePattern is ONETIME.
   * 1. `BlockFunds`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the mandate transaction
   *     requested to block funds.
   * 1. `LastUpdateTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when was the last
   *     modification made to the mandate. The format will be as per RFC-3339.
   *     Example : 2022-11-22T23:00:05Z
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   * 1. `PayerDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payer's device.
   * 1. `PayerDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payer's device.
   * 1. `PayerDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payer's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayerDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payer's device.
   * 1. `PayerDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payer's device.
   * 1. `PayerDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payer's device.
   * 1. `PayerDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payer's device.
   * 1. `PayerDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payer's device.
   * 1. `PayerDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payer's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `PayeeDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payee's device.
   * 1. `PayeeDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payee's device.
   * 1. `PayeeDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payee's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayeeDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payee's device.
   * 1. `PayeeDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payee's device.
   * 1. `PayeeDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payee's device.
   * 1. `PayeeDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payee's device.
   * 1. `PayeeDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payee's device.
   * 1. `PayeeDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payee's device. This will be one of
   *     `MOB`, `INET`, `USDC/USDB`, `POS`.
   * 1. `ReferenceID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Consumer reference number to identify loan number,
   *     order id etc.
   * 1. `ReferenceURI`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - URL for the  transaction.
   * 1. `ReferenceCategory`
   *     * **Min Length** - 2 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Reference category.
   * 1. `MandateName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - The mandate's name.
   */
  exportMandateTransactions(
    request: ExportMandateTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Export complaint transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportComplaintTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsMetadata]
   * - `response`:
   * [ExportComplaintTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 23 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CHECK_STATUS`, `TRANSACTION_TYPE_COMPLAINT`,
   *     `TRANSACTION_TYPE_REVERSAL`, `TRANSACTION_TYPE_DISPUTE`,
   *     `TRANSACTION_TYPE_REFUND`, or `TRANSACTION_TYPE_STATUS_UPDATE`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1: `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `OriginalRRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number of the original payment
   *     transaction.
   * 1. `BankType`
   *     * **Min Length** - 8 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - The subtype of the transaction based on the bank
   *     involved. This will be one of `BENEFICIARY`, or `REMITTER`.
   * 1. `OriginalTransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Transaction ID of the original unresolved
   *     transaction.
   * 1. `RaiseComplaintAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to raise the
   *     complaint.
   * 1. `RaiseComplaintAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to raise the
   *     complaint.
   * 1. `ResolveComplaintAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to resolve the
   *     complaint.
   * 1. `ResolveComplaintAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to resolve the
   *     complaint.
   * 1. `RaiseDisputeAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to raise the dispute.
   * 1. `RaiseDisputeAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to raise the
   *     dispute.
   * 1. `ResolveDisputeAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to resolve the
   *     dispute.
   * 1. `ResolveDisputeAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to resolve the
   *     dispute.
   * 1. `Amount`
   *     * **Description** - Amount to be resolved.
   * 1. `CurrentCycle`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the complaint / dispute
   *     belongs to current settlement cycle or not.
   * 1. `CRN`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Defines the Complaint Reference number.
   * 1. `AdjTime`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the time when the resolution was done.
   * 1. `RespAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the response category type.
   * 1. `RespAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the response reason used.
   * 1. `AdjRemarks`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the additional remarks for the complaint
   *     / dispute.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch service maps the ErrorCode to an appropriate error code that
   *     complies with the UPI specification.
   */
  exportComplaintTransactions(
    request: ExportComplaintTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface IssuerSwitchTransactionsClient<CallOptionsExt = {}> {
  /** List metadata transactions that satisfy the specified filter criteria. */
  listMetadataTransactions(
    request: DeepPartial<ListMetadataTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMetadataTransactionsResponse>;
  /** List financial transactions that satisfy specified filter criteria. */
  listFinancialTransactions(
    request: DeepPartial<ListFinancialTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFinancialTransactionsResponse>;
  /** List mandate transactions that satisfy specified filter criteria. */
  listMandateTransactions(
    request: DeepPartial<ListMandateTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMandateTransactionsResponse>;
  /** List complaint transactions that satisfy specified filter criteria. */
  listComplaintTransactions(
    request: DeepPartial<ListComplaintTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListComplaintTransactionsResponse>;
  /**
   * Export financial transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportFinancialTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsMetadata]
   * - `response`:
   * [ExportFinancialTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 22 characters
   *     * **Max Length** - 25 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_DEBIT` or
   *     `TRANSACTION_TYPE_REVERSAL`.
   * 1. `TransactionSubType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Subtype of the transaction. This will be one of
   *     `COLLECT`, or `PAY`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `RRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number associated with the
   *     transaction.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayerAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Payer's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Payee's mobile number.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - Payee's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant.
   * 1. `PayeeMerchantName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Payee's merchant name, only if the payee is a
   *     merchant.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `Currency`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Currency of the amount involved in the transaction.
   *     The currency codes are defined in ISO 4217.
   * 1. `Amount`
   *     * **Description** - Amount involved in the transaction.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of a failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for a failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   * 1. `PayerDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payer's device.
   * 1. `PayerDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payer's device.
   * 1. `PayerDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payer's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayerDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payer's device.
   * 1. `PayerDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payer's device.
   * 1. `PayerDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payer's device.
   * 1. `PayerDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payer's device.
   * 1. `PayerDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payer's device.
   * 1. `PayerDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payer's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `PayeeDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payee's device.
   * 1. `PayeeDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payee's device.
   * 1. `PayeeDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payee's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayeeDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payee's device.
   * 1. `PayeeDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payee's device.
   * 1. `PayeeDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payee's device.
   * 1. `PayeeDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payee's device.
   * 1. `PayeeDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payee's device.
   * 1. `PayeeDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payee's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `ReferenceID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Consumer reference number to identify loan number,
   *     order id etc.
   * 1. `ReferenceURI`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - URL for the  transaction.
   * 1. `ReferenceCategory`
   *     * **Min Length** - 2 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Reference category.
   */
  exportFinancialTransactions(
    request: DeepPartial<ExportFinancialTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Export metadata transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportMetadataTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsMetadata]
   * - `response`:
   * [ExportMetadataTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `APIType`
   *     * **Description** - The transaction's API type. The value will be of
   *     the [ApiType][google.cloud.paymentgateway.issuerswitch.v1.ApiType]
   *     enum.
   * 1. `TransactionType`
   *     * **Description** - Type of the transaction. The value will be of the
   *     [TransactionType][google.cloud.paymentgateway.issuerswitch.v1.TransactionType]
   *     enum.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `OriginVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the originator of
   *     the transaction.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   */
  exportMetadataTransactions(
    request: DeepPartial<ExportMetadataTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Export mandate transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportMandateTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsMetadata]
   * - `response`:
   * [ExportMandateTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `UniqueMandateNumber`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 70 characters
   *     * **Description** - UPI Unique Mandate Number.
   * 1. `TransactionType`
   *     * **Min Length** - 23 characters
   *     * **Max Length** - 23 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREATE`, `TRANSACTION_TYPE_REVOKE`,
   *     `TRANSACTION_TYPE_UPDATE`, `TRANSACTION_TYPE_PAUSE` or
   *     `TRANSACTION_TYPE_UNPAUSE`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayerAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 7 characters
   *     * **Description** - Payer's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeMobileNumber`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Mobile number of the payee.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeAccountType`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - Payee's bank account type. This will be one of
   *     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
   *     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant
   * 1. `PayeeMerchantName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Payee's merchant name, only if the payee is a
   *     merchant.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `Amount`
   *     * **Description** - Amount specified in the mandate.
   * 1. `RecurrencePattern`
   *     * **Description** - Reccurence pattern of the mandate. The value will
   *     be of the
   *     [MandateTransaction.RecurrencePatternType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrencePatternType]
   *     enum.
   * 1. `RecurrenceRuleType`
   *     * **Description** - Reccurrence rule type of the mandate. The value
   *     will be of the
   *     [MandateTransaction.RecurrenceRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrenceRuleType]
   *     enum.
   * 1. `RecurrenceRuleValue`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Recurrence rule value of the mandate. This will be
   *     an integer between 1 and 31.
   * 1. `Revokeable`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the mandate is
   *     revokable.
   * 1. `StartDate`
   *     * **Min Length** - 10 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - The start date of the mandate in `DD-MM-YYYY`
   *     format.
   * 1. `EndDate`
   *     * **Min Length** - 10 characters
   *     * **Max Length** - 10 characters
   *     * **Description** - The end date of the mandate in `DD-MM-YYYY` format.
   * 1. `AmountRuleType`
   *     * **Description** - The amount rule of the mandate. The value will be
   *     of the
   *     [MandateTransaction.AmountRuleType][google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.AmountRuleType]
   *     enum.
   * 1. `ApprovalReference`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - The block funds reference generated by the bank, if
   *     funds have been blocked for the mandate. This column will have a value
   *     only when the RecurrencePattern is ONETIME.
   * 1. `BlockFunds`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the mandate transaction
   *     requested to block funds.
   * 1. `LastUpdateTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when was the last
   *     modification made to the mandate. The format will be as per RFC-3339.
   *     Example : 2022-11-22T23:00:05Z
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch maps the ErrorCode to an appropriate error code that complies
   *     with the UPI specification.
   * 1. `PayerDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payer's device.
   * 1. `PayerDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payer's device.
   * 1. `PayerDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payer's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayerDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payer's device.
   * 1. `PayerDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payer's device.
   * 1. `PayerDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payer's device.
   * 1. `PayerDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payer's device.
   * 1. `PayerDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payer's device.
   * 1. `PayerDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payer's device. This will be one of
   *     'MOB', 'INET', 'USDC/USDB', 'POS'.
   * 1. `PayeeDeviceInfoTypeAppName`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Payment application name on the payee's device.
   * 1. `PayeeDeviceInfoTypeCapability`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Capability of the payee's device.
   * 1. `PayeeDeviceInfoTypeGeoCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 15 characters
   *     * **Description** - Geo code of the payee's device. This will include
   *     floating point values for latitude and longitude (separated by colon).
   * 1. `PayeeDeviceInfoTypeID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Device ID of the payee's device.
   * 1. `PayeeDeviceInfoTypeIP`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 39 characters
   *     * **Description** - IP address of the payee's device.
   * 1. `PayeeDeviceInfoTypeLocation`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 40 characters
   *     * **Description** - Coarse location of the payee's device.
   * 1. `PayeeDeviceInfoTypeOS`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Operating system on the payee's device.
   * 1. `PayeeDeviceInfoTypeTelecomProvider`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 99 characters
   *     * **Description** - Telecom provider for the payee's device.
   * 1. `PayeeDeviceInfoTypeDeviceType`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - Type of the payee's device. This will be one of
   *     `MOB`, `INET`, `USDC/USDB`, `POS`.
   * 1. `ReferenceID`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Consumer reference number to identify loan number,
   *     order id etc.
   * 1. `ReferenceURI`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - URL for the  transaction.
   * 1. `ReferenceCategory`
   *     * **Min Length** - 2 characters
   *     * **Max Length** - 2 characters
   *     * **Description** - Reference category.
   * 1. `MandateName`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - The mandate's name.
   */
  exportMandateTransactions(
    request: DeepPartial<ExportMandateTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Export complaint transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportComplaintTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsMetadata]
   * - `response`:
   * [ExportComplaintTransactionsResponse][google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - UPI transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 23 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CHECK_STATUS`, `TRANSACTION_TYPE_COMPLAINT`,
   *     `TRANSACTION_TYPE_REVERSAL`, `TRANSACTION_TYPE_DISPUTE`,
   *     `TRANSACTION_TYPE_REFUND`, or `TRANSACTION_TYPE_STATUS_UPDATE`.
   * 1. `CreationTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating when the issuer
   *     switch created the transaction resource for processing the transaction.
   *     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
   * 1: `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 9 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
   * 1. `OriginalRRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number of the original payment
   *     transaction.
   * 1. `BankType`
   *     * **Min Length** - 8 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - The subtype of the transaction based on the bank
   *     involved. This will be one of `BENEFICIARY`, or `REMITTER`.
   * 1. `OriginalTransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Transaction ID of the original unresolved
   *     transaction.
   * 1. `RaiseComplaintAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to raise the
   *     complaint.
   * 1. `RaiseComplaintAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to raise the
   *     complaint.
   * 1. `ResolveComplaintAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to resolve the
   *     complaint.
   * 1. `ResolveComplaintAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to resolve the
   *     complaint.
   * 1. `RaiseDisputeAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to raise the dispute.
   * 1. `RaiseDisputeAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to raise the
   *     dispute.
   * 1. `ResolveDisputeAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the type of action to resolve the
   *     dispute.
   * 1. `ResolveDisputeAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the reason of action to resolve the
   *     dispute.
   * 1. `Amount`
   *     * **Description** - Amount to be resolved.
   * 1. `CurrentCycle`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 5 characters
   *     * **Description** - Boolean value specifying if the complaint / dispute
   *     belongs to current settlement cycle or not.
   * 1. `CRN`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Defines the Complaint Reference number.
   * 1. `AdjTime`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the time when the resolution was done.
   * 1. `RespAdjFlag`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the response category type.
   * 1. `RespAdjCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the response reason used.
   * 1. `AdjRemarks`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Indicates the additional remarks for the complaint
   *     / dispute.
   * 1. `AdapterRequestIDs`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 2,000 characters
   *     * **Description** - List of adapter request IDs (colon separated) used
   *     when invoking the Adapter APIs for fulfilling a transaction request.
   * 1. `ErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Error code of the failed transaction.
   * 1. `ErrorMessage`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 10,000 characters
   *     * **Description** - Error description for the failed transaction.
   * 1. `UPIErrorCode`
   *     * **Min Length** - 0 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Error code as per the UPI specification. The issuer
   *     switch service maps the ErrorCode to an appropriate error code that
   *     complies with the UPI specification.
   */
  exportComplaintTransactions(
    request: DeepPartial<ExportComplaintTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
