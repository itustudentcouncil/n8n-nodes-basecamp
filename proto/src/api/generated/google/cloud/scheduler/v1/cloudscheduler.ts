// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/scheduler/v1/cloudscheduler.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Job } from "./job.js";

export const protobufPackage = "google.cloud.scheduler.v1";

/**
 * Request message for listing jobs using
 * [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs].
 */
export interface ListJobsRequest {
  /**
   * Required. The location name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID`.
   */
  parent: string;
  /**
   * Requested page size.
   *
   * The maximum page size is 500. If unspecified, the page size will
   * be the maximum. Fewer jobs than requested might be returned,
   * even if more jobs exist; use next_page_token to determine if more
   * jobs exist.
   */
  pageSize: number;
  /**
   * A token identifying a page of results the server will return. To
   * request the first page results, page_token must be empty. To
   * request the next page of results, page_token must be the value of
   * [next_page_token][google.cloud.scheduler.v1.ListJobsResponse.next_page_token]
   * returned from the previous call to
   * [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs]. It is an
   * error to switch the value of
   * [filter][google.cloud.scheduler.v1.ListJobsRequest.filter] or
   * [order_by][google.cloud.scheduler.v1.ListJobsRequest.order_by] while
   * iterating through pages.
   */
  pageToken: string;
}

/**
 * Response message for listing jobs using
 * [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs].
 */
export interface ListJobsResponse {
  /** The list of jobs. */
  jobs: Job[];
  /**
   * A token to retrieve next page of results. Pass this value in the
   * [page_token][google.cloud.scheduler.v1.ListJobsRequest.page_token] field in
   * the subsequent call to
   * [ListJobs][google.cloud.scheduler.v1.CloudScheduler.ListJobs] to retrieve
   * the next page of results. If this is empty it indicates that there are no
   * more results through which to paginate.
   *
   * The page token is valid for only 2 hours.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [GetJob][google.cloud.scheduler.v1.CloudScheduler.GetJob].
 */
export interface GetJobRequest {
  /**
   * Required. The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   */
  name: string;
}

/**
 * Request message for
 * [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob].
 */
export interface CreateJobRequest {
  /**
   * Required. The location name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID`.
   */
  parent: string;
  /**
   * Required. The job to add. The user can optionally specify a name for the
   * job in [name][google.cloud.scheduler.v1.Job.name].
   * [name][google.cloud.scheduler.v1.Job.name] cannot be the same as an
   * existing job. If a name is not specified then the system will
   * generate a random unique name that will be returned
   * ([name][google.cloud.scheduler.v1.Job.name]) in the response.
   */
  job: Job | undefined;
}

/**
 * Request message for
 * [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
 */
export interface UpdateJobRequest {
  /**
   * Required. The new job properties.
   * [name][google.cloud.scheduler.v1.Job.name] must be specified.
   *
   * Output only fields cannot be modified using UpdateJob.
   * Any value specified for an output only field will be ignored.
   */
  job:
    | Job
    | undefined;
  /** A  mask used to specify which fields of the job are being updated. */
  updateMask: string[] | undefined;
}

/**
 * Request message for deleting a job using
 * [DeleteJob][google.cloud.scheduler.v1.CloudScheduler.DeleteJob].
 */
export interface DeleteJobRequest {
  /**
   * Required. The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   */
  name: string;
}

/**
 * Request message for
 * [PauseJob][google.cloud.scheduler.v1.CloudScheduler.PauseJob].
 */
export interface PauseJobRequest {
  /**
   * Required. The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   */
  name: string;
}

/**
 * Request message for
 * [ResumeJob][google.cloud.scheduler.v1.CloudScheduler.ResumeJob].
 */
export interface ResumeJobRequest {
  /**
   * Required. The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   */
  name: string;
}

/**
 * Request message for forcing a job to run now using
 * [RunJob][google.cloud.scheduler.v1.CloudScheduler.RunJob].
 */
export interface RunJobRequest {
  /**
   * Required. The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   */
  name: string;
}

function createBaseListJobsRequest(): ListJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListJobsRequest: MessageFns<ListJobsRequest> = {
  encode(message: ListJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobsRequest>): ListJobsRequest {
    return ListJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobsRequest>): ListJobsRequest {
    const message = createBaseListJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [], nextPageToken: "" };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsResponse {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListJobsResponse>): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListJobsResponse>): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { name: "" };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJobRequest>): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJobRequest>): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateJobRequest(): CreateJobRequest {
  return { parent: "", job: undefined };
}

export const CreateJobRequest: MessageFns<CreateJobRequest> = {
  encode(message: CreateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
    };
  },

  toJSON(message: CreateJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateJobRequest>): CreateJobRequest {
    return CreateJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateJobRequest>): CreateJobRequest {
    const message = createBaseCreateJobRequest();
    message.parent = object.parent ?? "";
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseUpdateJobRequest(): UpdateJobRequest {
  return { job: undefined, updateMask: undefined };
}

export const UpdateJobRequest: MessageFns<UpdateJobRequest> = {
  encode(message: UpdateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateJobRequest {
    return {
      job: isSet(object.job) ? Job.fromJSON(object.job) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateJobRequest): unknown {
    const obj: any = {};
    if (message.job !== undefined) {
      obj.job = Job.toJSON(message.job);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateJobRequest>): UpdateJobRequest {
    return UpdateJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateJobRequest>): UpdateJobRequest {
    const message = createBaseUpdateJobRequest();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteJobRequest(): DeleteJobRequest {
  return { name: "" };
}

export const DeleteJobRequest: MessageFns<DeleteJobRequest> = {
  encode(message: DeleteJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteJobRequest>): DeleteJobRequest {
    return DeleteJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteJobRequest>): DeleteJobRequest {
    const message = createBaseDeleteJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePauseJobRequest(): PauseJobRequest {
  return { name: "" };
}

export const PauseJobRequest: MessageFns<PauseJobRequest> = {
  encode(message: PauseJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PauseJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PauseJobRequest>): PauseJobRequest {
    return PauseJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseJobRequest>): PauseJobRequest {
    const message = createBasePauseJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResumeJobRequest(): ResumeJobRequest {
  return { name: "" };
}

export const ResumeJobRequest: MessageFns<ResumeJobRequest> = {
  encode(message: ResumeJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResumeJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumeJobRequest>): ResumeJobRequest {
    return ResumeJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeJobRequest>): ResumeJobRequest {
    const message = createBaseResumeJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRunJobRequest(): RunJobRequest {
  return { name: "" };
}

export const RunJobRequest: MessageFns<RunJobRequest> = {
  encode(message: RunJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RunJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RunJobRequest>): RunJobRequest {
    return RunJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunJobRequest>): RunJobRequest {
    const message = createBaseRunJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/**
 * The Cloud Scheduler API allows external entities to reliably
 * schedule asynchronous jobs.
 */
export type CloudSchedulerDefinition = typeof CloudSchedulerDefinition;
export const CloudSchedulerDefinition = {
  name: "CloudScheduler",
  fullName: "google.cloud.scheduler.v1.CloudScheduler",
  methods: {
    /** Lists jobs. */
    listJobs: {
      name: "ListJobs",
      requestType: ListJobsRequest,
      requestStream: false,
      responseType: ListJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a job. */
    getJob: {
      name: "GetJob",
      requestType: GetJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a job. */
    createJob: {
      name: "CreateJob",
      requestType: CreateJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 112, 97, 114, 101, 110, 116, 44, 106, 111, 98])],
          578365826: [
            Buffer.from([
              47,
              58,
              3,
              106,
              111,
              98,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              106,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a job.
     *
     * If successful, the updated [Job][google.cloud.scheduler.v1.Job] is
     * returned. If the job does not exist, `NOT_FOUND` is returned.
     *
     * If UpdateJob does not successfully return, it is possible for the
     * job to be in an
     * [Job.State.UPDATE_FAILED][google.cloud.scheduler.v1.Job.State.UPDATE_FAILED]
     * state. A job in this state may not be executed. If this happens, retry the
     * UpdateJob request until a successful response is received.
     */
    updateJob: {
      name: "UpdateJob",
      requestType: UpdateJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 106, 111, 98, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              51,
              58,
              3,
              106,
              111,
              98,
              50,
              44,
              47,
              118,
              49,
              47,
              123,
              106,
              111,
              98,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a job. */
    deleteJob: {
      name: "DeleteJob",
      requestType: DeleteJobRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              42,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Pauses a job.
     *
     * If a job is paused then the system will stop executing the job
     * until it is re-enabled via
     * [ResumeJob][google.cloud.scheduler.v1.CloudScheduler.ResumeJob]. The state
     * of the job is stored in [state][google.cloud.scheduler.v1.Job.state]; if
     * paused it will be set to
     * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. A job must
     * be in [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED] to
     * be paused.
     */
    pauseJob: {
      name: "PauseJob",
      requestType: PauseJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              112,
              97,
              117,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Resume a job.
     *
     * This method reenables a job after it has been
     * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. The state
     * of a job is stored in [Job.state][google.cloud.scheduler.v1.Job.state];
     * after calling this method it will be set to
     * [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED]. A job
     * must be in [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]
     * to be resumed.
     */
    resumeJob: {
      name: "ResumeJob",
      requestType: ResumeJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              117,
              109,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Forces a job to run now.
     *
     * When this method is called, Cloud Scheduler will dispatch the job, even
     * if the job is already running.
     */
    runJob: {
      name: "RunJob",
      requestType: RunJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              58,
              1,
              42,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              106,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudSchedulerServiceImplementation<CallContextExt = {}> {
  /** Lists jobs. */
  listJobs(request: ListJobsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListJobsResponse>>;
  /** Gets a job. */
  getJob(request: GetJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /** Creates a job. */
  createJob(request: CreateJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /**
   * Updates a job.
   *
   * If successful, the updated [Job][google.cloud.scheduler.v1.Job] is
   * returned. If the job does not exist, `NOT_FOUND` is returned.
   *
   * If UpdateJob does not successfully return, it is possible for the
   * job to be in an
   * [Job.State.UPDATE_FAILED][google.cloud.scheduler.v1.Job.State.UPDATE_FAILED]
   * state. A job in this state may not be executed. If this happens, retry the
   * UpdateJob request until a successful response is received.
   */
  updateJob(request: UpdateJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /** Deletes a job. */
  deleteJob(request: DeleteJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Pauses a job.
   *
   * If a job is paused then the system will stop executing the job
   * until it is re-enabled via
   * [ResumeJob][google.cloud.scheduler.v1.CloudScheduler.ResumeJob]. The state
   * of the job is stored in [state][google.cloud.scheduler.v1.Job.state]; if
   * paused it will be set to
   * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. A job must
   * be in [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED] to
   * be paused.
   */
  pauseJob(request: PauseJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /**
   * Resume a job.
   *
   * This method reenables a job after it has been
   * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. The state
   * of a job is stored in [Job.state][google.cloud.scheduler.v1.Job.state];
   * after calling this method it will be set to
   * [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED]. A job
   * must be in [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]
   * to be resumed.
   */
  resumeJob(request: ResumeJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  /**
   * Forces a job to run now.
   *
   * When this method is called, Cloud Scheduler will dispatch the job, even
   * if the job is already running.
   */
  runJob(request: RunJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
}

export interface CloudSchedulerClient<CallOptionsExt = {}> {
  /** Lists jobs. */
  listJobs(request: DeepPartial<ListJobsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListJobsResponse>;
  /** Gets a job. */
  getJob(request: DeepPartial<GetJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /** Creates a job. */
  createJob(request: DeepPartial<CreateJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /**
   * Updates a job.
   *
   * If successful, the updated [Job][google.cloud.scheduler.v1.Job] is
   * returned. If the job does not exist, `NOT_FOUND` is returned.
   *
   * If UpdateJob does not successfully return, it is possible for the
   * job to be in an
   * [Job.State.UPDATE_FAILED][google.cloud.scheduler.v1.Job.State.UPDATE_FAILED]
   * state. A job in this state may not be executed. If this happens, retry the
   * UpdateJob request until a successful response is received.
   */
  updateJob(request: DeepPartial<UpdateJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /** Deletes a job. */
  deleteJob(request: DeepPartial<DeleteJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Pauses a job.
   *
   * If a job is paused then the system will stop executing the job
   * until it is re-enabled via
   * [ResumeJob][google.cloud.scheduler.v1.CloudScheduler.ResumeJob]. The state
   * of the job is stored in [state][google.cloud.scheduler.v1.Job.state]; if
   * paused it will be set to
   * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. A job must
   * be in [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED] to
   * be paused.
   */
  pauseJob(request: DeepPartial<PauseJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /**
   * Resume a job.
   *
   * This method reenables a job after it has been
   * [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]. The state
   * of a job is stored in [Job.state][google.cloud.scheduler.v1.Job.state];
   * after calling this method it will be set to
   * [Job.State.ENABLED][google.cloud.scheduler.v1.Job.State.ENABLED]. A job
   * must be in [Job.State.PAUSED][google.cloud.scheduler.v1.Job.State.PAUSED]
   * to be resumed.
   */
  resumeJob(request: DeepPartial<ResumeJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  /**
   * Forces a job to run now.
   *
   * When this method is called, Cloud Scheduler will dispatch the job, even
   * if the job is already running.
   */
  runJob(request: DeepPartial<RunJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
