// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/scheduler/v1/target.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.scheduler.v1";

/** The HTTP method used to execute the job. */
export enum HttpMethod {
  /** HTTP_METHOD_UNSPECIFIED - HTTP method unspecified. Defaults to POST. */
  HTTP_METHOD_UNSPECIFIED = 0,
  /** POST - HTTP POST */
  POST = 1,
  /** GET - HTTP GET */
  GET = 2,
  /** HEAD - HTTP HEAD */
  HEAD = 3,
  /** PUT - HTTP PUT */
  PUT = 4,
  /** DELETE - HTTP DELETE */
  DELETE = 5,
  /** PATCH - HTTP PATCH */
  PATCH = 6,
  /** OPTIONS - HTTP OPTIONS */
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function httpMethodFromJSON(object: any): HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return HttpMethod.POST;
    case 2:
    case "GET":
      return HttpMethod.GET;
    case 3:
    case "HEAD":
      return HttpMethod.HEAD;
    case 4:
    case "PUT":
      return HttpMethod.PUT;
    case 5:
    case "DELETE":
      return HttpMethod.DELETE;
    case 6:
    case "PATCH":
      return HttpMethod.PATCH;
    case 7:
    case "OPTIONS":
      return HttpMethod.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpMethod.UNRECOGNIZED;
  }
}

export function httpMethodToJSON(object: HttpMethod): string {
  switch (object) {
    case HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case HttpMethod.POST:
      return "POST";
    case HttpMethod.GET:
      return "GET";
    case HttpMethod.HEAD:
      return "HEAD";
    case HttpMethod.PUT:
      return "PUT";
    case HttpMethod.DELETE:
      return "DELETE";
    case HttpMethod.PATCH:
      return "PATCH";
    case HttpMethod.OPTIONS:
      return "OPTIONS";
    case HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Http target. The job will be pushed to the job handler by means of
 * an HTTP request via an
 * [http_method][google.cloud.scheduler.v1.HttpTarget.http_method] such as HTTP
 * POST, HTTP GET, etc. The job is acknowledged by means of an HTTP
 * response code in the range [200 - 299]. A failure to receive a response
 * constitutes a failed execution. For a redirected request, the response
 * returned by the redirected request is considered.
 */
export interface HttpTarget {
  /**
   * Required. The full URI path that the request will be sent to. This string
   * must begin with either "http://" or "https://". Some examples of
   * valid values for [uri][google.cloud.scheduler.v1.HttpTarget.uri] are:
   * `http://acme.com` and `https://acme.com/sales:8080`. Cloud Scheduler will
   * encode some characters for safety and compatibility. The maximum allowed
   * URL length is 2083 characters after encoding.
   */
  uri: string;
  /** Which HTTP method to use for the request. */
  httpMethod: HttpMethod;
  /**
   * The user can specify HTTP request headers to send with the job's
   * HTTP request. This map contains the header field names and
   * values. Repeated headers are not supported, but a header value can
   * contain commas. These headers represent a subset of the headers
   * that will accompany the job's HTTP request. Some HTTP request
   * headers will be ignored or replaced. A partial list of headers that
   * will be ignored or replaced is below:
   * - Host: This will be computed by Cloud Scheduler and derived from
   * [uri][google.cloud.scheduler.v1.HttpTarget.uri].
   * * `Content-Length`: This will be computed by Cloud Scheduler.
   * * `User-Agent`: This will be set to `"Google-Cloud-Scheduler"`.
   * * `X-Google-*`: Google internal use only.
   * * `X-AppEngine-*`: Google internal use only.
   * * `X-CloudScheduler`: This header will be set to true.
   * * `X-CloudScheduler-JobName`: This header will contain the job name.
   * * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
   * the unix-cron format, this header will contain the job schedule as an
   * offset of UTC parsed according to RFC3339.
   *
   * The total size of headers must be less than 80KB.
   */
  headers: { [key: string]: string };
  /**
   * HTTP request body. A request body is allowed only if the HTTP
   * method is POST, PUT, or PATCH. It is an error to set body on a job with an
   * incompatible [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
   */
  body: Buffer;
  /**
   * If specified, an
   * [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
   * will be generated and attached as an `Authorization` header in the HTTP
   * request.
   *
   * This type of authorization should generally only be used when calling
   * Google APIs hosted on *.googleapis.com.
   */
  oauthToken?:
    | OAuthToken
    | undefined;
  /**
   * If specified, an
   * [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
   * token will be generated and attached as an `Authorization` header in the
   * HTTP request.
   *
   * This type of authorization can be used for many scenarios, including
   * calling Cloud Run, or endpoints where you intend to validate the token
   * yourself.
   */
  oidcToken?: OidcToken | undefined;
}

export interface HttpTarget_HeadersEntry {
  key: string;
  value: string;
}

/**
 * App Engine target. The job will be pushed to a job handler by means
 * of an HTTP request via an
 * [http_method][google.cloud.scheduler.v1.AppEngineHttpTarget.http_method] such
 * as HTTP POST, HTTP GET, etc. The job is acknowledged by means of an
 * HTTP response code in the range [200 - 299]. Error 503 is
 * considered an App Engine system error instead of an application
 * error. Requests returning error 503 will be retried regardless of
 * retry configuration and not counted against retry counts. Any other
 * response code, or a failure to receive a response before the
 * deadline, constitutes a failed attempt.
 */
export interface AppEngineHttpTarget {
  /**
   * The HTTP method to use for the request. PATCH and OPTIONS are not
   * permitted.
   */
  httpMethod: HttpMethod;
  /** App Engine Routing setting for the job. */
  appEngineRouting:
    | AppEngineRouting
    | undefined;
  /**
   * The relative URI.
   *
   * The relative URL must begin with "/" and must be a valid HTTP relative URL.
   * It can contain a path, query string arguments, and `#` fragments.
   * If the relative URL is empty, then the root path "/" will be used.
   * No spaces are allowed, and the maximum length allowed is 2083 characters.
   */
  relativeUri: string;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values. Headers can be set
   * when the job is created.
   *
   * Cloud Scheduler sets some headers to default values:
   *
   * * `User-Agent`: By default, this header is
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"`.
   *   This header can be modified, but Cloud Scheduler will append
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"` to the
   *   modified `User-Agent`.
   * * `X-CloudScheduler`: This header will be set to true.
   * * `X-CloudScheduler-JobName`: This header will contain the job name.
   * * `X-CloudScheduler-ScheduleTime`: For Cloud Scheduler jobs specified in
   * the unix-cron format, this header will contain the job schedule as an
   * offset of UTC parsed according to RFC3339.
   *
   * If the job has an
   * [body][google.cloud.scheduler.v1.AppEngineHttpTarget.body], Cloud Scheduler
   * sets the following headers:
   *
   * * `Content-Type`: By default, the `Content-Type` header is set to
   *   `"application/octet-stream"`. The default can be overridden by explictly
   *   setting `Content-Type` to a particular media type when the job is
   *   created.
   *   For example, `Content-Type` can be set to `"application/json"`.
   * * `Content-Length`: This is computed by Cloud Scheduler. This value is
   *   output only. It cannot be changed.
   *
   * The headers below are output only. They cannot be set or overridden:
   *
   * * `X-Google-*`: For Google internal use only.
   * * `X-AppEngine-*`: For Google internal use only.
   *
   * In addition, some App Engine headers, which contain
   * job-specific information, are also be sent to the job handler.
   */
  headers: { [key: string]: string };
  /**
   * Body.
   *
   * HTTP request body. A request body is allowed only if the HTTP method is
   * POST or PUT. It will result in invalid argument error to set a body on a
   * job with an incompatible
   * [HttpMethod][google.cloud.scheduler.v1.HttpMethod].
   */
  body: Buffer;
}

export interface AppEngineHttpTarget_HeadersEntry {
  key: string;
  value: string;
}

/**
 * Pub/Sub target. The job will be delivered by publishing a message to
 * the given Pub/Sub topic.
 */
export interface PubsubTarget {
  /**
   * Required. The name of the Cloud Pub/Sub topic to which messages will
   * be published when a job is delivered. The topic name must be in the
   * same format as required by Pub/Sub's
   * [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest),
   * for example `projects/PROJECT_ID/topics/TOPIC_ID`.
   *
   * The topic must be in the same project as the Cloud Scheduler job.
   */
  topicName: string;
  /**
   * The message payload for PubsubMessage.
   *
   * Pubsub message must contain either non-empty data, or at least one
   * attribute.
   */
  data: Buffer;
  /**
   * Attributes for PubsubMessage.
   *
   * Pubsub message must contain either non-empty data, or at least one
   * attribute.
   */
  attributes: { [key: string]: string };
}

export interface PubsubTarget_AttributesEntry {
  key: string;
  value: string;
}

/**
 * App Engine Routing.
 *
 * For more information about services, versions, and instances see
 * [An Overview of App
 * Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
 * [Microservices Architecture on Google App
 * Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
 * [App Engine Standard request
 * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
 * and [App Engine Flex request
 * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
 */
export interface AppEngineRouting {
  /**
   * App service.
   *
   * By default, the job is sent to the service which is the default
   * service when the job is attempted.
   */
  service: string;
  /**
   * App version.
   *
   * By default, the job is sent to the version which is the default
   * version when the job is attempted.
   */
  version: string;
  /**
   * App instance.
   *
   * By default, the job is sent to an instance which is available when
   * the job is attempted.
   *
   * Requests can only be sent to a specific instance if
   * [manual scaling is used in App Engine
   * Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?#scaling_types_and_instance_classes).
   * App Engine Flex does not support instances. For more information, see
   * [App Engine Standard request
   * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
   * and [App Engine Flex request
   * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
   */
  instance: string;
  /**
   * Output only. The host that the job is sent to.
   *
   * For more information about how App Engine requests are routed, see
   * [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
   *
   * The host is constructed as:
   *
   * * `host = [application_domain_name]`</br>
   *   `| [service] + '.' + [application_domain_name]`</br>
   *   `| [version] + '.' + [application_domain_name]`</br>
   *   `| [version_dot_service]+ '.' + [application_domain_name]`</br>
   *   `| [instance] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_service] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version_dot_service] + '.' + [application_domain_name]`
   *
   * * `application_domain_name` = The domain name of the app, for
   *   example <app-id>.appspot.com, which is associated with the
   *   job's project ID.
   *
   * * `service =` [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `version =` [version][google.cloud.scheduler.v1.AppEngineRouting.version]
   *
   * * `version_dot_service =`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `instance =`
   * [instance][google.cloud.scheduler.v1.AppEngineRouting.instance]
   *
   * * `instance_dot_service =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * * `instance_dot_version =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version]
   *
   * * `instance_dot_version_dot_service =`
   *   [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] `+ '.' +`
   *   [version][google.cloud.scheduler.v1.AppEngineRouting.version] `+ '.' +`
   *   [service][google.cloud.scheduler.v1.AppEngineRouting.service]
   *
   * If [service][google.cloud.scheduler.v1.AppEngineRouting.service] is empty,
   * then the job will be sent to the service which is the default service when
   * the job is attempted.
   *
   * If [version][google.cloud.scheduler.v1.AppEngineRouting.version] is empty,
   * then the job will be sent to the version which is the default version when
   * the job is attempted.
   *
   * If [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is
   * empty, then the job will be sent to an instance which is available when the
   * job is attempted.
   *
   * If [service][google.cloud.scheduler.v1.AppEngineRouting.service],
   * [version][google.cloud.scheduler.v1.AppEngineRouting.version], or
   * [instance][google.cloud.scheduler.v1.AppEngineRouting.instance] is invalid,
   * then the job will be sent to the default version of the default service
   * when the job is attempted.
   */
  host: string;
}

/**
 * Contains information needed for generating an
 * [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
 * This type of authorization should generally only be used when calling Google
 * APIs hosted on *.googleapis.com.
 */
export interface OAuthToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OAuth token.
   * The service account must be within the same project as the job. The caller
   * must have iam.serviceAccounts.actAs permission for the service account.
   */
  serviceAccountEmail: string;
  /**
   * OAuth scope to be used for generating OAuth access token.
   * If not specified, "https://www.googleapis.com/auth/cloud-platform"
   * will be used.
   */
  scope: string;
}

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * This type of authorization can be used for many scenarios, including
 * calling Cloud Run, or endpoints where you intend to validate the token
 * yourself.
 */
export interface OidcToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OIDC token.
   * The service account must be within the same project as the job. The caller
   * must have iam.serviceAccounts.actAs permission for the service account.
   */
  serviceAccountEmail: string;
  /**
   * Audience to be used when generating OIDC token. If not specified, the URI
   * specified in target will be used.
   */
  audience: string;
}

function createBaseHttpTarget(): HttpTarget {
  return { uri: "", httpMethod: 0, headers: {}, body: Buffer.alloc(0), oauthToken: undefined, oidcToken: undefined };
}

export const HttpTarget: MessageFns<HttpTarget> = {
  encode(message: HttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.httpMethod !== 0) {
      writer.uint32(16).int32(message.httpMethod);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpTarget_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      OAuthToken.encode(message.oauthToken, writer.uint32(42).fork()).join();
    }
    if (message.oidcToken !== undefined) {
      OidcToken.encode(message.oidcToken, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = HttpTarget_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oauthToken = OAuthToken.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oidcToken = OidcToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
      oauthToken: isSet(object.oauthToken) ? OAuthToken.fromJSON(object.oauthToken) : undefined,
      oidcToken: isSet(object.oidcToken) ? OidcToken.fromJSON(object.oidcToken) : undefined,
    };
  },

  toJSON(message: HttpTarget): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      obj.oauthToken = OAuthToken.toJSON(message.oauthToken);
    }
    if (message.oidcToken !== undefined) {
      obj.oidcToken = OidcToken.toJSON(message.oidcToken);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpTarget>): HttpTarget {
    return HttpTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpTarget>): HttpTarget {
    const message = createBaseHttpTarget();
    message.uri = object.uri ?? "";
    message.httpMethod = object.httpMethod ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? Buffer.alloc(0);
    message.oauthToken = (object.oauthToken !== undefined && object.oauthToken !== null)
      ? OAuthToken.fromPartial(object.oauthToken)
      : undefined;
    message.oidcToken = (object.oidcToken !== undefined && object.oidcToken !== null)
      ? OidcToken.fromPartial(object.oidcToken)
      : undefined;
    return message;
  },
};

function createBaseHttpTarget_HeadersEntry(): HttpTarget_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpTarget_HeadersEntry: MessageFns<HttpTarget_HeadersEntry> = {
  encode(message: HttpTarget_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpTarget_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpTarget_HeadersEntry>): HttpTarget_HeadersEntry {
    return HttpTarget_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpTarget_HeadersEntry>): HttpTarget_HeadersEntry {
    const message = createBaseHttpTarget_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineHttpTarget(): AppEngineHttpTarget {
  return { httpMethod: 0, appEngineRouting: undefined, relativeUri: "", headers: {}, body: Buffer.alloc(0) };
}

export const AppEngineHttpTarget: MessageFns<AppEngineHttpTarget> = {
  encode(message: AppEngineHttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpMethod !== 0) {
      writer.uint32(8).int32(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      AppEngineRouting.encode(message.appEngineRouting, writer.uint32(18).fork()).join();
    }
    if (message.relativeUri !== "") {
      writer.uint32(26).string(message.relativeUri);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      AppEngineHttpTarget_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(42).bytes(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appEngineRouting = AppEngineRouting.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relativeUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AppEngineHttpTarget_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpTarget {
    return {
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      appEngineRouting: isSet(object.appEngineRouting) ? AppEngineRouting.fromJSON(object.appEngineRouting) : undefined,
      relativeUri: isSet(object.relativeUri) ? globalThis.String(object.relativeUri) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
    };
  },

  toJSON(message: AppEngineHttpTarget): unknown {
    const obj: any = {};
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      obj.appEngineRouting = AppEngineRouting.toJSON(message.appEngineRouting);
    }
    if (message.relativeUri !== "") {
      obj.relativeUri = message.relativeUri;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpTarget>): AppEngineHttpTarget {
    return AppEngineHttpTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpTarget>): AppEngineHttpTarget {
    const message = createBaseAppEngineHttpTarget();
    message.httpMethod = object.httpMethod ?? 0;
    message.appEngineRouting = (object.appEngineRouting !== undefined && object.appEngineRouting !== null)
      ? AppEngineRouting.fromPartial(object.appEngineRouting)
      : undefined;
    message.relativeUri = object.relativeUri ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAppEngineHttpTarget_HeadersEntry(): AppEngineHttpTarget_HeadersEntry {
  return { key: "", value: "" };
}

export const AppEngineHttpTarget_HeadersEntry: MessageFns<AppEngineHttpTarget_HeadersEntry> = {
  encode(message: AppEngineHttpTarget_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpTarget_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpTarget_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpTarget_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AppEngineHttpTarget_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpTarget_HeadersEntry>): AppEngineHttpTarget_HeadersEntry {
    return AppEngineHttpTarget_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpTarget_HeadersEntry>): AppEngineHttpTarget_HeadersEntry {
    const message = createBaseAppEngineHttpTarget_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePubsubTarget(): PubsubTarget {
  return { topicName: "", data: Buffer.alloc(0), attributes: {} };
}

export const PubsubTarget: MessageFns<PubsubTarget> = {
  encode(message: PubsubTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicName !== "") {
      writer.uint32(10).string(message.topicName);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      PubsubTarget_AttributesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topicName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = PubsubTarget_AttributesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.attributes[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubTarget {
    return {
      topicName: isSet(object.topicName) ? globalThis.String(object.topicName) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PubsubTarget): unknown {
    const obj: any = {};
    if (message.topicName !== "") {
      obj.topicName = message.topicName;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubTarget>): PubsubTarget {
    return PubsubTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubTarget>): PubsubTarget {
    const message = createBasePubsubTarget();
    message.topicName = object.topicName ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePubsubTarget_AttributesEntry(): PubsubTarget_AttributesEntry {
  return { key: "", value: "" };
}

export const PubsubTarget_AttributesEntry: MessageFns<PubsubTarget_AttributesEntry> = {
  encode(message: PubsubTarget_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubTarget_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubTarget_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubTarget_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PubsubTarget_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubTarget_AttributesEntry>): PubsubTarget_AttributesEntry {
    return PubsubTarget_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubTarget_AttributesEntry>): PubsubTarget_AttributesEntry {
    const message = createBasePubsubTarget_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineRouting(): AppEngineRouting {
  return { service: "", version: "", instance: "", host: "" };
}

export const AppEngineRouting: MessageFns<AppEngineRouting> = {
  encode(message: AppEngineRouting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineRouting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.host = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineRouting {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: AppEngineRouting): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineRouting>): AppEngineRouting {
    return AppEngineRouting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineRouting>): AppEngineRouting {
    const message = createBaseAppEngineRouting();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.instance = object.instance ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseOAuthToken(): OAuthToken {
  return { serviceAccountEmail: "", scope: "" };
}

export const OAuthToken: MessageFns<OAuthToken> = {
  encode(message: OAuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
    };
  },

  toJSON(message: OAuthToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<OAuthToken>): OAuthToken {
    return OAuthToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OAuthToken>): OAuthToken {
    const message = createBaseOAuthToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.scope = object.scope ?? "";
    return message;
  },
};

function createBaseOidcToken(): OidcToken {
  return { serviceAccountEmail: "", audience: "" };
}

export const OidcToken: MessageFns<OidcToken> = {
  encode(message: OidcToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OidcToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOidcToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OidcToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: OidcToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<OidcToken>): OidcToken {
    return OidcToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OidcToken>): OidcToken {
    const message = createBaseOidcToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
