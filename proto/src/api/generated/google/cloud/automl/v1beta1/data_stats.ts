// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/automl/v1beta1/data_stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.automl.v1beta1";

/** The data statistics of a series of values that share the same DataType. */
export interface DataStats {
  /** The statistics for FLOAT64 DataType. */
  float64Stats?:
    | Float64Stats
    | undefined;
  /** The statistics for STRING DataType. */
  stringStats?:
    | StringStats
    | undefined;
  /** The statistics for TIMESTAMP DataType. */
  timestampStats?:
    | TimestampStats
    | undefined;
  /** The statistics for ARRAY DataType. */
  arrayStats?:
    | ArrayStats
    | undefined;
  /** The statistics for STRUCT DataType. */
  structStats?:
    | StructStats
    | undefined;
  /** The statistics for CATEGORY DataType. */
  categoryStats?:
    | CategoryStats
    | undefined;
  /** The number of distinct values. */
  distinctValueCount: Long;
  /** The number of values that are null. */
  nullValueCount: Long;
  /** The number of values that are valid. */
  validValueCount: Long;
}

/** The data statistics of a series of FLOAT64 values. */
export interface Float64Stats {
  /** The mean of the series. */
  mean: number;
  /** The standard deviation of the series. */
  standardDeviation: number;
  /**
   * Ordered from 0 to k k-quantile values of the data series of n values.
   * The value at index i is, approximately, the i*n/k-th smallest value in the
   * series; for i = 0 and i = k these are, respectively, the min and max
   * values.
   */
  quantiles: number[];
  /**
   * Histogram buckets of the data series. Sorted by the min value of the
   * bucket, ascendingly, and the number of the buckets is dynamically
   * generated. The buckets are non-overlapping and completely cover whole
   * FLOAT64 range with min of first bucket being `"-Infinity"`, and max of
   * the last one being `"Infinity"`.
   */
  histogramBuckets: Float64Stats_HistogramBucket[];
}

/** A bucket of a histogram. */
export interface Float64Stats_HistogramBucket {
  /** The minimum value of the bucket, inclusive. */
  min: number;
  /**
   * The maximum value of the bucket, exclusive unless max = `"Infinity"`, in
   * which case it's inclusive.
   */
  max: number;
  /**
   * The number of data values that are in the bucket, i.e. are between
   * min and max values.
   */
  count: Long;
}

/** The data statistics of a series of STRING values. */
export interface StringStats {
  /**
   * The statistics of the top 20 unigrams, ordered by
   * [count][google.cloud.automl.v1beta1.StringStats.UnigramStats.count].
   */
  topUnigramStats: StringStats_UnigramStats[];
}

/** The statistics of a unigram. */
export interface StringStats_UnigramStats {
  /** The unigram. */
  value: string;
  /** The number of occurrences of this unigram in the series. */
  count: Long;
}

/** The data statistics of a series of TIMESTAMP values. */
export interface TimestampStats {
  /**
   * The string key is the pre-defined granularity. Currently supported:
   * hour_of_day, day_of_week, month_of_year.
   * Granularities finer that the granularity of timestamp data are not
   * populated (e.g. if timestamps are at day granularity, then hour_of_day
   * is not populated).
   */
  granularStats: { [key: string]: TimestampStats_GranularStats };
}

/** Stats split by a defined in context granularity. */
export interface TimestampStats_GranularStats {
  /**
   * A map from granularity key to example count for that key.
   * E.g. for hour_of_day `13` means 1pm, or for month_of_year `5` means May).
   */
  buckets: { [key: number]: Long };
}

export interface TimestampStats_GranularStats_BucketsEntry {
  key: number;
  value: Long;
}

export interface TimestampStats_GranularStatsEntry {
  key: string;
  value: TimestampStats_GranularStats | undefined;
}

/** The data statistics of a series of ARRAY values. */
export interface ArrayStats {
  /**
   * Stats of all the values of all arrays, as if they were a single long
   * series of data. The type depends on the element type of the array.
   */
  memberStats: DataStats | undefined;
}

/** The data statistics of a series of STRUCT values. */
export interface StructStats {
  /**
   * Map from a field name of the struct to data stats aggregated over series
   * of all data in that field across all the structs.
   */
  fieldStats: { [key: string]: DataStats };
}

export interface StructStats_FieldStatsEntry {
  key: string;
  value: DataStats | undefined;
}

/** The data statistics of a series of CATEGORY values. */
export interface CategoryStats {
  /**
   * The statistics of the top 20 CATEGORY values, ordered by
   *
   * [count][google.cloud.automl.v1beta1.CategoryStats.SingleCategoryStats.count].
   */
  topCategoryStats: CategoryStats_SingleCategoryStats[];
}

/** The statistics of a single CATEGORY value. */
export interface CategoryStats_SingleCategoryStats {
  /** The CATEGORY value. */
  value: string;
  /** The number of occurrences of this value in the series. */
  count: Long;
}

/**
 * A correlation statistics between two series of DataType values. The series
 * may have differing DataType-s, but within a single series the DataType must
 * be the same.
 */
export interface CorrelationStats {
  /** The correlation value using the Cramer's V measure. */
  cramersV: number;
}

function createBaseDataStats(): DataStats {
  return {
    float64Stats: undefined,
    stringStats: undefined,
    timestampStats: undefined,
    arrayStats: undefined,
    structStats: undefined,
    categoryStats: undefined,
    distinctValueCount: Long.ZERO,
    nullValueCount: Long.ZERO,
    validValueCount: Long.ZERO,
  };
}

export const DataStats: MessageFns<DataStats> = {
  encode(message: DataStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.float64Stats !== undefined) {
      Float64Stats.encode(message.float64Stats, writer.uint32(26).fork()).join();
    }
    if (message.stringStats !== undefined) {
      StringStats.encode(message.stringStats, writer.uint32(34).fork()).join();
    }
    if (message.timestampStats !== undefined) {
      TimestampStats.encode(message.timestampStats, writer.uint32(42).fork()).join();
    }
    if (message.arrayStats !== undefined) {
      ArrayStats.encode(message.arrayStats, writer.uint32(50).fork()).join();
    }
    if (message.structStats !== undefined) {
      StructStats.encode(message.structStats, writer.uint32(58).fork()).join();
    }
    if (message.categoryStats !== undefined) {
      CategoryStats.encode(message.categoryStats, writer.uint32(66).fork()).join();
    }
    if (!message.distinctValueCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.distinctValueCount.toString());
    }
    if (!message.nullValueCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.nullValueCount.toString());
    }
    if (!message.validValueCount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.validValueCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.float64Stats = Float64Stats.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringStats = StringStats.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timestampStats = TimestampStats.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.arrayStats = ArrayStats.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.structStats = StructStats.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.categoryStats = CategoryStats.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.distinctValueCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nullValueCount = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.validValueCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStats {
    return {
      float64Stats: isSet(object.float64Stats) ? Float64Stats.fromJSON(object.float64Stats) : undefined,
      stringStats: isSet(object.stringStats) ? StringStats.fromJSON(object.stringStats) : undefined,
      timestampStats: isSet(object.timestampStats) ? TimestampStats.fromJSON(object.timestampStats) : undefined,
      arrayStats: isSet(object.arrayStats) ? ArrayStats.fromJSON(object.arrayStats) : undefined,
      structStats: isSet(object.structStats) ? StructStats.fromJSON(object.structStats) : undefined,
      categoryStats: isSet(object.categoryStats) ? CategoryStats.fromJSON(object.categoryStats) : undefined,
      distinctValueCount: isSet(object.distinctValueCount) ? Long.fromValue(object.distinctValueCount) : Long.ZERO,
      nullValueCount: isSet(object.nullValueCount) ? Long.fromValue(object.nullValueCount) : Long.ZERO,
      validValueCount: isSet(object.validValueCount) ? Long.fromValue(object.validValueCount) : Long.ZERO,
    };
  },

  toJSON(message: DataStats): unknown {
    const obj: any = {};
    if (message.float64Stats !== undefined) {
      obj.float64Stats = Float64Stats.toJSON(message.float64Stats);
    }
    if (message.stringStats !== undefined) {
      obj.stringStats = StringStats.toJSON(message.stringStats);
    }
    if (message.timestampStats !== undefined) {
      obj.timestampStats = TimestampStats.toJSON(message.timestampStats);
    }
    if (message.arrayStats !== undefined) {
      obj.arrayStats = ArrayStats.toJSON(message.arrayStats);
    }
    if (message.structStats !== undefined) {
      obj.structStats = StructStats.toJSON(message.structStats);
    }
    if (message.categoryStats !== undefined) {
      obj.categoryStats = CategoryStats.toJSON(message.categoryStats);
    }
    if (!message.distinctValueCount.equals(Long.ZERO)) {
      obj.distinctValueCount = (message.distinctValueCount || Long.ZERO).toString();
    }
    if (!message.nullValueCount.equals(Long.ZERO)) {
      obj.nullValueCount = (message.nullValueCount || Long.ZERO).toString();
    }
    if (!message.validValueCount.equals(Long.ZERO)) {
      obj.validValueCount = (message.validValueCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataStats>): DataStats {
    return DataStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataStats>): DataStats {
    const message = createBaseDataStats();
    message.float64Stats = (object.float64Stats !== undefined && object.float64Stats !== null)
      ? Float64Stats.fromPartial(object.float64Stats)
      : undefined;
    message.stringStats = (object.stringStats !== undefined && object.stringStats !== null)
      ? StringStats.fromPartial(object.stringStats)
      : undefined;
    message.timestampStats = (object.timestampStats !== undefined && object.timestampStats !== null)
      ? TimestampStats.fromPartial(object.timestampStats)
      : undefined;
    message.arrayStats = (object.arrayStats !== undefined && object.arrayStats !== null)
      ? ArrayStats.fromPartial(object.arrayStats)
      : undefined;
    message.structStats = (object.structStats !== undefined && object.structStats !== null)
      ? StructStats.fromPartial(object.structStats)
      : undefined;
    message.categoryStats = (object.categoryStats !== undefined && object.categoryStats !== null)
      ? CategoryStats.fromPartial(object.categoryStats)
      : undefined;
    message.distinctValueCount = (object.distinctValueCount !== undefined && object.distinctValueCount !== null)
      ? Long.fromValue(object.distinctValueCount)
      : Long.ZERO;
    message.nullValueCount = (object.nullValueCount !== undefined && object.nullValueCount !== null)
      ? Long.fromValue(object.nullValueCount)
      : Long.ZERO;
    message.validValueCount = (object.validValueCount !== undefined && object.validValueCount !== null)
      ? Long.fromValue(object.validValueCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseFloat64Stats(): Float64Stats {
  return { mean: 0, standardDeviation: 0, quantiles: [], histogramBuckets: [] };
}

export const Float64Stats: MessageFns<Float64Stats> = {
  encode(message: Float64Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mean !== 0) {
      writer.uint32(9).double(message.mean);
    }
    if (message.standardDeviation !== 0) {
      writer.uint32(17).double(message.standardDeviation);
    }
    writer.uint32(26).fork();
    for (const v of message.quantiles) {
      writer.double(v);
    }
    writer.join();
    for (const v of message.histogramBuckets) {
      Float64Stats_HistogramBucket.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Float64Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloat64Stats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.mean = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.standardDeviation = reader.double();
          continue;
        case 3:
          if (tag === 25) {
            message.quantiles.push(reader.double());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.quantiles.push(reader.double());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.histogramBuckets.push(Float64Stats_HistogramBucket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Float64Stats {
    return {
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : 0,
      standardDeviation: isSet(object.standardDeviation) ? globalThis.Number(object.standardDeviation) : 0,
      quantiles: globalThis.Array.isArray(object?.quantiles)
        ? object.quantiles.map((e: any) => globalThis.Number(e))
        : [],
      histogramBuckets: globalThis.Array.isArray(object?.histogramBuckets)
        ? object.histogramBuckets.map((e: any) => Float64Stats_HistogramBucket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Float64Stats): unknown {
    const obj: any = {};
    if (message.mean !== 0) {
      obj.mean = message.mean;
    }
    if (message.standardDeviation !== 0) {
      obj.standardDeviation = message.standardDeviation;
    }
    if (message.quantiles?.length) {
      obj.quantiles = message.quantiles;
    }
    if (message.histogramBuckets?.length) {
      obj.histogramBuckets = message.histogramBuckets.map((e) => Float64Stats_HistogramBucket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Float64Stats>): Float64Stats {
    return Float64Stats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Float64Stats>): Float64Stats {
    const message = createBaseFloat64Stats();
    message.mean = object.mean ?? 0;
    message.standardDeviation = object.standardDeviation ?? 0;
    message.quantiles = object.quantiles?.map((e) => e) || [];
    message.histogramBuckets = object.histogramBuckets?.map((e) => Float64Stats_HistogramBucket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloat64Stats_HistogramBucket(): Float64Stats_HistogramBucket {
  return { min: 0, max: 0, count: Long.ZERO };
}

export const Float64Stats_HistogramBucket: MessageFns<Float64Stats_HistogramBucket> = {
  encode(message: Float64Stats_HistogramBucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(9).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(17).double(message.max);
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Float64Stats_HistogramBucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloat64Stats_HistogramBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.min = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.max = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Float64Stats_HistogramBucket {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: Float64Stats_HistogramBucket): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Float64Stats_HistogramBucket>): Float64Stats_HistogramBucket {
    return Float64Stats_HistogramBucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Float64Stats_HistogramBucket>): Float64Stats_HistogramBucket {
    const message = createBaseFloat64Stats_HistogramBucket();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseStringStats(): StringStats {
  return { topUnigramStats: [] };
}

export const StringStats: MessageFns<StringStats> = {
  encode(message: StringStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topUnigramStats) {
      StringStats_UnigramStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topUnigramStats.push(StringStats_UnigramStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringStats {
    return {
      topUnigramStats: globalThis.Array.isArray(object?.topUnigramStats)
        ? object.topUnigramStats.map((e: any) => StringStats_UnigramStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StringStats): unknown {
    const obj: any = {};
    if (message.topUnigramStats?.length) {
      obj.topUnigramStats = message.topUnigramStats.map((e) => StringStats_UnigramStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StringStats>): StringStats {
    return StringStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringStats>): StringStats {
    const message = createBaseStringStats();
    message.topUnigramStats = object.topUnigramStats?.map((e) => StringStats_UnigramStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStringStats_UnigramStats(): StringStats_UnigramStats {
  return { value: "", count: Long.ZERO };
}

export const StringStats_UnigramStats: MessageFns<StringStats_UnigramStats> = {
  encode(message: StringStats_UnigramStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringStats_UnigramStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringStats_UnigramStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringStats_UnigramStats {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: StringStats_UnigramStats): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StringStats_UnigramStats>): StringStats_UnigramStats {
    return StringStats_UnigramStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringStats_UnigramStats>): StringStats_UnigramStats {
    const message = createBaseStringStats_UnigramStats();
    message.value = object.value ?? "";
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseTimestampStats(): TimestampStats {
  return { granularStats: {} };
}

export const TimestampStats: MessageFns<TimestampStats> = {
  encode(message: TimestampStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.granularStats).forEach(([key, value]) => {
      TimestampStats_GranularStatsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = TimestampStats_GranularStatsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.granularStats[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampStats {
    return {
      granularStats: isObject(object.granularStats)
        ? Object.entries(object.granularStats).reduce<{ [key: string]: TimestampStats_GranularStats }>(
          (acc, [key, value]) => {
            acc[key] = TimestampStats_GranularStats.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: TimestampStats): unknown {
    const obj: any = {};
    if (message.granularStats) {
      const entries = Object.entries(message.granularStats);
      if (entries.length > 0) {
        obj.granularStats = {};
        entries.forEach(([k, v]) => {
          obj.granularStats[k] = TimestampStats_GranularStats.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampStats>): TimestampStats {
    return TimestampStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampStats>): TimestampStats {
    const message = createBaseTimestampStats();
    message.granularStats = Object.entries(object.granularStats ?? {}).reduce<
      { [key: string]: TimestampStats_GranularStats }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TimestampStats_GranularStats.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTimestampStats_GranularStats(): TimestampStats_GranularStats {
  return { buckets: {} };
}

export const TimestampStats_GranularStats: MessageFns<TimestampStats_GranularStats> = {
  encode(message: TimestampStats_GranularStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.buckets).forEach(([key, value]) => {
      TimestampStats_GranularStats_BucketsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampStats_GranularStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampStats_GranularStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = TimestampStats_GranularStats_BucketsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.buckets[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampStats_GranularStats {
    return {
      buckets: isObject(object.buckets)
        ? Object.entries(object.buckets).reduce<{ [key: number]: Long }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TimestampStats_GranularStats): unknown {
    const obj: any = {};
    if (message.buckets) {
      const entries = Object.entries(message.buckets);
      if (entries.length > 0) {
        obj.buckets = {};
        entries.forEach(([k, v]) => {
          obj.buckets[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampStats_GranularStats>): TimestampStats_GranularStats {
    return TimestampStats_GranularStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampStats_GranularStats>): TimestampStats_GranularStats {
    const message = createBaseTimestampStats_GranularStats();
    message.buckets = Object.entries(object.buckets ?? {}).reduce<{ [key: number]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[globalThis.Number(key)] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTimestampStats_GranularStats_BucketsEntry(): TimestampStats_GranularStats_BucketsEntry {
  return { key: 0, value: Long.ZERO };
}

export const TimestampStats_GranularStats_BucketsEntry: MessageFns<TimestampStats_GranularStats_BucketsEntry> = {
  encode(message: TimestampStats_GranularStats_BucketsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampStats_GranularStats_BucketsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampStats_GranularStats_BucketsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampStats_GranularStats_BucketsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: TimestampStats_GranularStats_BucketsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampStats_GranularStats_BucketsEntry>): TimestampStats_GranularStats_BucketsEntry {
    return TimestampStats_GranularStats_BucketsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TimestampStats_GranularStats_BucketsEntry>,
  ): TimestampStats_GranularStats_BucketsEntry {
    const message = createBaseTimestampStats_GranularStats_BucketsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseTimestampStats_GranularStatsEntry(): TimestampStats_GranularStatsEntry {
  return { key: "", value: undefined };
}

export const TimestampStats_GranularStatsEntry: MessageFns<TimestampStats_GranularStatsEntry> = {
  encode(message: TimestampStats_GranularStatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TimestampStats_GranularStats.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampStats_GranularStatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampStats_GranularStatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TimestampStats_GranularStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampStats_GranularStatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TimestampStats_GranularStats.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TimestampStats_GranularStatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TimestampStats_GranularStats.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampStats_GranularStatsEntry>): TimestampStats_GranularStatsEntry {
    return TimestampStats_GranularStatsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampStats_GranularStatsEntry>): TimestampStats_GranularStatsEntry {
    const message = createBaseTimestampStats_GranularStatsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TimestampStats_GranularStats.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseArrayStats(): ArrayStats {
  return { memberStats: undefined };
}

export const ArrayStats: MessageFns<ArrayStats> = {
  encode(message: ArrayStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memberStats !== undefined) {
      DataStats.encode(message.memberStats, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArrayStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArrayStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memberStats = DataStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArrayStats {
    return { memberStats: isSet(object.memberStats) ? DataStats.fromJSON(object.memberStats) : undefined };
  },

  toJSON(message: ArrayStats): unknown {
    const obj: any = {};
    if (message.memberStats !== undefined) {
      obj.memberStats = DataStats.toJSON(message.memberStats);
    }
    return obj;
  },

  create(base?: DeepPartial<ArrayStats>): ArrayStats {
    return ArrayStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArrayStats>): ArrayStats {
    const message = createBaseArrayStats();
    message.memberStats = (object.memberStats !== undefined && object.memberStats !== null)
      ? DataStats.fromPartial(object.memberStats)
      : undefined;
    return message;
  },
};

function createBaseStructStats(): StructStats {
  return { fieldStats: {} };
}

export const StructStats: MessageFns<StructStats> = {
  encode(message: StructStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fieldStats).forEach(([key, value]) => {
      StructStats_FieldStatsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = StructStats_FieldStatsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fieldStats[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructStats {
    return {
      fieldStats: isObject(object.fieldStats)
        ? Object.entries(object.fieldStats).reduce<{ [key: string]: DataStats }>((acc, [key, value]) => {
          acc[key] = DataStats.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: StructStats): unknown {
    const obj: any = {};
    if (message.fieldStats) {
      const entries = Object.entries(message.fieldStats);
      if (entries.length > 0) {
        obj.fieldStats = {};
        entries.forEach(([k, v]) => {
          obj.fieldStats[k] = DataStats.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<StructStats>): StructStats {
    return StructStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructStats>): StructStats {
    const message = createBaseStructStats();
    message.fieldStats = Object.entries(object.fieldStats ?? {}).reduce<{ [key: string]: DataStats }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = DataStats.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseStructStats_FieldStatsEntry(): StructStats_FieldStatsEntry {
  return { key: "", value: undefined };
}

export const StructStats_FieldStatsEntry: MessageFns<StructStats_FieldStatsEntry> = {
  encode(message: StructStats_FieldStatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DataStats.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructStats_FieldStatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructStats_FieldStatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DataStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructStats_FieldStatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DataStats.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StructStats_FieldStatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DataStats.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StructStats_FieldStatsEntry>): StructStats_FieldStatsEntry {
    return StructStats_FieldStatsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructStats_FieldStatsEntry>): StructStats_FieldStatsEntry {
    const message = createBaseStructStats_FieldStatsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DataStats.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCategoryStats(): CategoryStats {
  return { topCategoryStats: [] };
}

export const CategoryStats: MessageFns<CategoryStats> = {
  encode(message: CategoryStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topCategoryStats) {
      CategoryStats_SingleCategoryStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topCategoryStats.push(CategoryStats_SingleCategoryStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryStats {
    return {
      topCategoryStats: globalThis.Array.isArray(object?.topCategoryStats)
        ? object.topCategoryStats.map((e: any) => CategoryStats_SingleCategoryStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CategoryStats): unknown {
    const obj: any = {};
    if (message.topCategoryStats?.length) {
      obj.topCategoryStats = message.topCategoryStats.map((e) => CategoryStats_SingleCategoryStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CategoryStats>): CategoryStats {
    return CategoryStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CategoryStats>): CategoryStats {
    const message = createBaseCategoryStats();
    message.topCategoryStats = object.topCategoryStats?.map((e) => CategoryStats_SingleCategoryStats.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCategoryStats_SingleCategoryStats(): CategoryStats_SingleCategoryStats {
  return { value: "", count: Long.ZERO };
}

export const CategoryStats_SingleCategoryStats: MessageFns<CategoryStats_SingleCategoryStats> = {
  encode(message: CategoryStats_SingleCategoryStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CategoryStats_SingleCategoryStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryStats_SingleCategoryStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CategoryStats_SingleCategoryStats {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: CategoryStats_SingleCategoryStats): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<CategoryStats_SingleCategoryStats>): CategoryStats_SingleCategoryStats {
    return CategoryStats_SingleCategoryStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CategoryStats_SingleCategoryStats>): CategoryStats_SingleCategoryStats {
    const message = createBaseCategoryStats_SingleCategoryStats();
    message.value = object.value ?? "";
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseCorrelationStats(): CorrelationStats {
  return { cramersV: 0 };
}

export const CorrelationStats: MessageFns<CorrelationStats> = {
  encode(message: CorrelationStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cramersV !== 0) {
      writer.uint32(9).double(message.cramersV);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CorrelationStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorrelationStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.cramersV = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CorrelationStats {
    return { cramersV: isSet(object.cramersV) ? globalThis.Number(object.cramersV) : 0 };
  },

  toJSON(message: CorrelationStats): unknown {
    const obj: any = {};
    if (message.cramersV !== 0) {
      obj.cramersV = message.cramersV;
    }
    return obj;
  },

  create(base?: DeepPartial<CorrelationStats>): CorrelationStats {
    return CorrelationStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CorrelationStats>): CorrelationStats {
    const message = createBaseCorrelationStats();
    message.cramersV = object.cramersV ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
