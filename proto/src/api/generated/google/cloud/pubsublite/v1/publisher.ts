// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/pubsublite/v1/publisher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Cursor, PubSubMessage } from "./common.js";

export const protobufPackage = "google.cloud.pubsublite.v1";

/** The first request that must be sent on a newly-opened stream. */
export interface InitialPublishRequest {
  /** The topic to which messages will be written. */
  topic: string;
  /**
   * The partition within the topic to which messages will be written.
   * Partitions are zero indexed, so `partition` must be in the range [0,
   * topic.num_partitions).
   */
  partition: Long;
  /**
   * Unique identifier for a publisher client. If set, enables publish
   * idempotency within a publisher client session.
   *
   * The length of this field must be exactly 16 bytes long and should be
   * populated with a 128 bit uuid, generated by standard uuid algorithms like
   * uuid1 or uuid4. The same identifier should be reused following
   * disconnections with retryable stream errors.
   */
  clientId: Buffer;
}

/** Response to an InitialPublishRequest. */
export interface InitialPublishResponse {
}

/** Request to publish messages to the topic. */
export interface MessagePublishRequest {
  /** The messages to publish. */
  messages: PubSubMessage[];
  /**
   * The sequence number corresponding to the first message in `messages`.
   * Messages within a batch are ordered and the sequence numbers of all
   * subsequent messages in the batch are assumed to be incremental.
   *
   * Sequence numbers are assigned at the message level and the first message
   * published in a publisher client session must have a sequence number of 0.
   * All messages must have contiguous sequence numbers, which uniquely identify
   * the messages accepted by the publisher client. Since messages are ordered,
   * the client only needs to specify the sequence number of the first message
   * in a published batch. The server deduplicates messages with the same
   * sequence number from the same publisher `client_id`.
   */
  firstSequenceNumber: Long;
}

/** Response to a MessagePublishRequest. */
export interface MessagePublishResponse {
  /**
   * The cursor of the first published message in the batch. The cursors for any
   * remaining messages in the batch are guaranteed to be sequential.
   */
  startCursor:
    | Cursor
    | undefined;
  /**
   * Cursors for messages published in the batch. There will exist multiple
   * ranges when cursors are not contiguous within the batch.
   *
   * The cursor ranges may not account for all messages in the batch when
   * publish idempotency is enabled. A missing range indicates that cursors
   * could not be determined for messages within the range, as they were
   * deduplicated and the necessary data was not available at publish time.
   * These messages will have offsets when received by a subscriber.
   */
  cursorRanges: MessagePublishResponse_CursorRange[];
}

/** Cursors for a subrange of published messages. */
export interface MessagePublishResponse_CursorRange {
  /**
   * The cursor of the message at the start index. The cursors for remaining
   * messages up to the end index (exclusive) are sequential.
   */
  startCursor:
    | Cursor
    | undefined;
  /**
   * Index of the message in the published batch that corresponds to the
   * start cursor. Inclusive.
   */
  startIndex: number;
  /** Index of the last message in this range. Exclusive. */
  endIndex: number;
}

/** Request sent from the client to the server on a stream. */
export interface PublishRequest {
  /** Initial request on the stream. */
  initialRequest?:
    | InitialPublishRequest
    | undefined;
  /** Request to publish messages. */
  messagePublishRequest?: MessagePublishRequest | undefined;
}

/** Response to a PublishRequest. */
export interface PublishResponse {
  /** Initial response on the stream. */
  initialResponse?:
    | InitialPublishResponse
    | undefined;
  /** Response to publishing messages. */
  messageResponse?: MessagePublishResponse | undefined;
}

function createBaseInitialPublishRequest(): InitialPublishRequest {
  return { topic: "", partition: Long.ZERO, clientId: Buffer.alloc(0) };
}

export const InitialPublishRequest: MessageFns<InitialPublishRequest> = {
  encode(message: InitialPublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (!message.partition.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.partition.toString());
    }
    if (message.clientId.length !== 0) {
      writer.uint32(26).bytes(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialPublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.partition = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clientId = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialPublishRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? Long.fromValue(object.partition) : Long.ZERO,
      clientId: isSet(object.clientId) ? Buffer.from(bytesFromBase64(object.clientId)) : Buffer.alloc(0),
    };
  },

  toJSON(message: InitialPublishRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (!message.partition.equals(Long.ZERO)) {
      obj.partition = (message.partition || Long.ZERO).toString();
    }
    if (message.clientId.length !== 0) {
      obj.clientId = base64FromBytes(message.clientId);
    }
    return obj;
  },

  create(base?: DeepPartial<InitialPublishRequest>): InitialPublishRequest {
    return InitialPublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialPublishRequest>): InitialPublishRequest {
    const message = createBaseInitialPublishRequest();
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Long.fromValue(object.partition)
      : Long.ZERO;
    message.clientId = object.clientId ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseInitialPublishResponse(): InitialPublishResponse {
  return {};
}

export const InitialPublishResponse: MessageFns<InitialPublishResponse> = {
  encode(_: InitialPublishResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialPublishResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InitialPublishResponse {
    return {};
  },

  toJSON(_: InitialPublishResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InitialPublishResponse>): InitialPublishResponse {
    return InitialPublishResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InitialPublishResponse>): InitialPublishResponse {
    const message = createBaseInitialPublishResponse();
    return message;
  },
};

function createBaseMessagePublishRequest(): MessagePublishRequest {
  return { messages: [], firstSequenceNumber: Long.ZERO };
}

export const MessagePublishRequest: MessageFns<MessagePublishRequest> = {
  encode(message: MessagePublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      PubSubMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (!message.firstSequenceNumber.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.firstSequenceNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagePublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagePublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(PubSubMessage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.firstSequenceNumber = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessagePublishRequest {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => PubSubMessage.fromJSON(e))
        : [],
      firstSequenceNumber: isSet(object.firstSequenceNumber) ? Long.fromValue(object.firstSequenceNumber) : Long.ZERO,
    };
  },

  toJSON(message: MessagePublishRequest): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => PubSubMessage.toJSON(e));
    }
    if (!message.firstSequenceNumber.equals(Long.ZERO)) {
      obj.firstSequenceNumber = (message.firstSequenceNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MessagePublishRequest>): MessagePublishRequest {
    return MessagePublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessagePublishRequest>): MessagePublishRequest {
    const message = createBaseMessagePublishRequest();
    message.messages = object.messages?.map((e) => PubSubMessage.fromPartial(e)) || [];
    message.firstSequenceNumber = (object.firstSequenceNumber !== undefined && object.firstSequenceNumber !== null)
      ? Long.fromValue(object.firstSequenceNumber)
      : Long.ZERO;
    return message;
  },
};

function createBaseMessagePublishResponse(): MessagePublishResponse {
  return { startCursor: undefined, cursorRanges: [] };
}

export const MessagePublishResponse: MessageFns<MessagePublishResponse> = {
  encode(message: MessagePublishResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startCursor !== undefined) {
      Cursor.encode(message.startCursor, writer.uint32(10).fork()).join();
    }
    for (const v of message.cursorRanges) {
      MessagePublishResponse_CursorRange.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagePublishResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagePublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursorRanges.push(MessagePublishResponse_CursorRange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessagePublishResponse {
    return {
      startCursor: isSet(object.startCursor) ? Cursor.fromJSON(object.startCursor) : undefined,
      cursorRanges: globalThis.Array.isArray(object?.cursorRanges)
        ? object.cursorRanges.map((e: any) => MessagePublishResponse_CursorRange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessagePublishResponse): unknown {
    const obj: any = {};
    if (message.startCursor !== undefined) {
      obj.startCursor = Cursor.toJSON(message.startCursor);
    }
    if (message.cursorRanges?.length) {
      obj.cursorRanges = message.cursorRanges.map((e) => MessagePublishResponse_CursorRange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessagePublishResponse>): MessagePublishResponse {
    return MessagePublishResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessagePublishResponse>): MessagePublishResponse {
    const message = createBaseMessagePublishResponse();
    message.startCursor = (object.startCursor !== undefined && object.startCursor !== null)
      ? Cursor.fromPartial(object.startCursor)
      : undefined;
    message.cursorRanges = object.cursorRanges?.map((e) => MessagePublishResponse_CursorRange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessagePublishResponse_CursorRange(): MessagePublishResponse_CursorRange {
  return { startCursor: undefined, startIndex: 0, endIndex: 0 };
}

export const MessagePublishResponse_CursorRange: MessageFns<MessagePublishResponse_CursorRange> = {
  encode(message: MessagePublishResponse_CursorRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startCursor !== undefined) {
      Cursor.encode(message.startCursor, writer.uint32(10).fork()).join();
    }
    if (message.startIndex !== 0) {
      writer.uint32(16).int32(message.startIndex);
    }
    if (message.endIndex !== 0) {
      writer.uint32(24).int32(message.endIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagePublishResponse_CursorRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagePublishResponse_CursorRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessagePublishResponse_CursorRange {
    return {
      startCursor: isSet(object.startCursor) ? Cursor.fromJSON(object.startCursor) : undefined,
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      endIndex: isSet(object.endIndex) ? globalThis.Number(object.endIndex) : 0,
    };
  },

  toJSON(message: MessagePublishResponse_CursorRange): unknown {
    const obj: any = {};
    if (message.startCursor !== undefined) {
      obj.startCursor = Cursor.toJSON(message.startCursor);
    }
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.endIndex !== 0) {
      obj.endIndex = Math.round(message.endIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<MessagePublishResponse_CursorRange>): MessagePublishResponse_CursorRange {
    return MessagePublishResponse_CursorRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessagePublishResponse_CursorRange>): MessagePublishResponse_CursorRange {
    const message = createBaseMessagePublishResponse_CursorRange();
    message.startCursor = (object.startCursor !== undefined && object.startCursor !== null)
      ? Cursor.fromPartial(object.startCursor)
      : undefined;
    message.startIndex = object.startIndex ?? 0;
    message.endIndex = object.endIndex ?? 0;
    return message;
  },
};

function createBasePublishRequest(): PublishRequest {
  return { initialRequest: undefined, messagePublishRequest: undefined };
}

export const PublishRequest: MessageFns<PublishRequest> = {
  encode(message: PublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialRequest !== undefined) {
      InitialPublishRequest.encode(message.initialRequest, writer.uint32(10).fork()).join();
    }
    if (message.messagePublishRequest !== undefined) {
      MessagePublishRequest.encode(message.messagePublishRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initialRequest = InitialPublishRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messagePublishRequest = MessagePublishRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishRequest {
    return {
      initialRequest: isSet(object.initialRequest) ? InitialPublishRequest.fromJSON(object.initialRequest) : undefined,
      messagePublishRequest: isSet(object.messagePublishRequest)
        ? MessagePublishRequest.fromJSON(object.messagePublishRequest)
        : undefined,
    };
  },

  toJSON(message: PublishRequest): unknown {
    const obj: any = {};
    if (message.initialRequest !== undefined) {
      obj.initialRequest = InitialPublishRequest.toJSON(message.initialRequest);
    }
    if (message.messagePublishRequest !== undefined) {
      obj.messagePublishRequest = MessagePublishRequest.toJSON(message.messagePublishRequest);
    }
    return obj;
  },

  create(base?: DeepPartial<PublishRequest>): PublishRequest {
    return PublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishRequest>): PublishRequest {
    const message = createBasePublishRequest();
    message.initialRequest = (object.initialRequest !== undefined && object.initialRequest !== null)
      ? InitialPublishRequest.fromPartial(object.initialRequest)
      : undefined;
    message.messagePublishRequest =
      (object.messagePublishRequest !== undefined && object.messagePublishRequest !== null)
        ? MessagePublishRequest.fromPartial(object.messagePublishRequest)
        : undefined;
    return message;
  },
};

function createBasePublishResponse(): PublishResponse {
  return { initialResponse: undefined, messageResponse: undefined };
}

export const PublishResponse: MessageFns<PublishResponse> = {
  encode(message: PublishResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialResponse !== undefined) {
      InitialPublishResponse.encode(message.initialResponse, writer.uint32(10).fork()).join();
    }
    if (message.messageResponse !== undefined) {
      MessagePublishResponse.encode(message.messageResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initialResponse = InitialPublishResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messageResponse = MessagePublishResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishResponse {
    return {
      initialResponse: isSet(object.initialResponse)
        ? InitialPublishResponse.fromJSON(object.initialResponse)
        : undefined,
      messageResponse: isSet(object.messageResponse)
        ? MessagePublishResponse.fromJSON(object.messageResponse)
        : undefined,
    };
  },

  toJSON(message: PublishResponse): unknown {
    const obj: any = {};
    if (message.initialResponse !== undefined) {
      obj.initialResponse = InitialPublishResponse.toJSON(message.initialResponse);
    }
    if (message.messageResponse !== undefined) {
      obj.messageResponse = MessagePublishResponse.toJSON(message.messageResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<PublishResponse>): PublishResponse {
    return PublishResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishResponse>): PublishResponse {
    const message = createBasePublishResponse();
    message.initialResponse = (object.initialResponse !== undefined && object.initialResponse !== null)
      ? InitialPublishResponse.fromPartial(object.initialResponse)
      : undefined;
    message.messageResponse = (object.messageResponse !== undefined && object.messageResponse !== null)
      ? MessagePublishResponse.fromPartial(object.messageResponse)
      : undefined;
    return message;
  },
};

/**
 * The service that a publisher client application uses to publish messages to
 * topics. Published messages are retained by the service for the duration of
 * the retention period configured for the respective topic, and are delivered
 * to subscriber clients upon request (via the `SubscriberService`).
 */
export type PublisherServiceDefinition = typeof PublisherServiceDefinition;
export const PublisherServiceDefinition = {
  name: "PublisherService",
  fullName: "google.cloud.pubsublite.v1.PublisherService",
  methods: {
    /**
     * Establishes a stream with the server for publishing messages. Once the
     * stream is initialized, the client publishes messages by sending publish
     * requests on the stream. The server responds with a PublishResponse for each
     * PublishRequest sent by the client, in the same order that the requests
     * were sent. Note that multiple PublishRequests can be in flight
     * simultaneously, but they will be processed by the server in the order that
     * they are sent by the client on a given stream.
     */
    publish: {
      name: "Publish",
      requestType: PublishRequest,
      requestStream: true,
      responseType: PublishResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface PublisherServiceImplementation<CallContextExt = {}> {
  /**
   * Establishes a stream with the server for publishing messages. Once the
   * stream is initialized, the client publishes messages by sending publish
   * requests on the stream. The server responds with a PublishResponse for each
   * PublishRequest sent by the client, in the same order that the requests
   * were sent. Note that multiple PublishRequests can be in flight
   * simultaneously, but they will be processed by the server in the order that
   * they are sent by the client on a given stream.
   */
  publish(
    request: AsyncIterable<PublishRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<PublishResponse>>;
}

export interface PublisherServiceClient<CallOptionsExt = {}> {
  /**
   * Establishes a stream with the server for publishing messages. Once the
   * stream is initialized, the client publishes messages by sending publish
   * requests on the stream. The server responds with a PublishResponse for each
   * PublishRequest sent by the client, in the same order that the requests
   * were sent. Note that multiple PublishRequests can be in flight
   * simultaneously, but they will be processed by the server in the order that
   * they are sent by the client on a given stream.
   */
  publish(
    request: AsyncIterable<DeepPartial<PublishRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<PublishResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
