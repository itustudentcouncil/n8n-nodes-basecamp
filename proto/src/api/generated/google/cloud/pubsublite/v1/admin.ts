// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/pubsublite/v1/admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Reservation, Subscription, TimeTarget, Topic } from "./common.js";

export const protobufPackage = "google.cloud.pubsublite.v1";

/** Request for CreateTopic. */
export interface CreateTopicRequest {
  /**
   * Required. The parent location in which to create the topic.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * Required. Configuration of the topic to create. Its `name` field is
   * ignored.
   */
  topic:
    | Topic
    | undefined;
  /**
   * Required. The ID to use for the topic, which will become the final
   * component of the topic's name.
   *
   * This value is structured like: `my-topic-name`.
   */
  topicId: string;
}

/** Request for GetTopic. */
export interface GetTopicRequest {
  /** Required. The name of the topic whose configuration to return. */
  name: string;
}

/** Request for GetTopicPartitions. */
export interface GetTopicPartitionsRequest {
  /** Required. The topic whose partition information to return. */
  name: string;
}

/** Response for GetTopicPartitions. */
export interface TopicPartitions {
  /** The number of partitions in the topic. */
  partitionCount: Long;
}

/** Request for ListTopics. */
export interface ListTopicsRequest {
  /**
   * Required. The parent whose topics are to be listed.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * The maximum number of topics to return. The service may return fewer than
   * this value.
   * If unset or zero, all topics for the parent will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListTopics` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTopics` must match
   * the call that provided the page token.
   */
  pageToken: string;
}

/** Response for ListTopics. */
export interface ListTopicsResponse {
  /**
   * The list of topic in the requested parent. The order of the topics is
   * unspecified.
   */
  topics: Topic[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page of
   * results. If this field is omitted, there are no more results.
   */
  nextPageToken: string;
}

/** Request for UpdateTopic. */
export interface UpdateTopicRequest {
  /** Required. The topic to update. Its `name` field must be populated. */
  topic:
    | Topic
    | undefined;
  /** Required. A mask specifying the topic fields to change. */
  updateMask: string[] | undefined;
}

/** Request for DeleteTopic. */
export interface DeleteTopicRequest {
  /** Required. The name of the topic to delete. */
  name: string;
}

/** Request for ListTopicSubscriptions. */
export interface ListTopicSubscriptionsRequest {
  /** Required. The name of the topic whose subscriptions to list. */
  name: string;
  /**
   * The maximum number of subscriptions to return. The service may return fewer
   * than this value.
   * If unset or zero, all subscriptions for the given topic will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListTopicSubscriptions` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListTopicSubscriptions`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** Response for ListTopicSubscriptions. */
export interface ListTopicSubscriptionsResponse {
  /**
   * The names of subscriptions attached to the topic. The order of the
   * subscriptions is unspecified.
   */
  subscriptions: string[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page of
   * results. If this field is omitted, there are no more results.
   */
  nextPageToken: string;
}

/** Request for CreateSubscription. */
export interface CreateSubscriptionRequest {
  /**
   * Required. The parent location in which to create the subscription.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * Required. Configuration of the subscription to create. Its `name` field is
   * ignored.
   */
  subscription:
    | Subscription
    | undefined;
  /**
   * Required. The ID to use for the subscription, which will become the final
   * component of the subscription's name.
   *
   * This value is structured like: `my-sub-name`.
   */
  subscriptionId: string;
  /**
   * If true, the newly created subscription will only receive messages
   * published after the subscription was created. Otherwise, the entire
   * message backlog will be received on the subscription. Defaults to false.
   */
  skipBacklog: boolean;
}

/** Request for GetSubscription. */
export interface GetSubscriptionRequest {
  /** Required. The name of the subscription whose configuration to return. */
  name: string;
}

/** Request for ListSubscriptions. */
export interface ListSubscriptionsRequest {
  /**
   * Required. The parent whose subscriptions are to be listed.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * The maximum number of subscriptions to return. The service may return fewer
   * than this value.
   * If unset or zero, all subscriptions for the parent will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListSubscriptions` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListSubscriptions` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response for ListSubscriptions. */
export interface ListSubscriptionsResponse {
  /**
   * The list of subscriptions in the requested parent. The order of the
   * subscriptions is unspecified.
   */
  subscriptions: Subscription[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page of
   * results. If this field is omitted, there are no more results.
   */
  nextPageToken: string;
}

/** Request for UpdateSubscription. */
export interface UpdateSubscriptionRequest {
  /**
   * Required. The subscription to update. Its `name` field must be populated.
   * Topic field must not be populated.
   */
  subscription:
    | Subscription
    | undefined;
  /** Required. A mask specifying the subscription fields to change. */
  updateMask: string[] | undefined;
}

/** Request for DeleteSubscription. */
export interface DeleteSubscriptionRequest {
  /** Required. The name of the subscription to delete. */
  name: string;
}

/** Request for SeekSubscription. */
export interface SeekSubscriptionRequest {
  /** Required. The name of the subscription to seek. */
  name: string;
  /** Seek to a named position with respect to the message backlog. */
  namedTarget?:
    | SeekSubscriptionRequest_NamedTarget
    | undefined;
  /**
   * Seek to the first message whose publish or event time is greater than or
   * equal to the specified query time. If no such message can be located,
   * will seek to the end of the message backlog.
   */
  timeTarget?: TimeTarget | undefined;
}

/** A named position with respect to the message backlog. */
export enum SeekSubscriptionRequest_NamedTarget {
  /** NAMED_TARGET_UNSPECIFIED - Unspecified named target. Do not use. */
  NAMED_TARGET_UNSPECIFIED = 0,
  /** TAIL - Seek to the oldest retained message. */
  TAIL = 1,
  /**
   * HEAD - Seek past all recently published messages, skipping the entire message
   * backlog.
   */
  HEAD = 2,
  UNRECOGNIZED = -1,
}

export function seekSubscriptionRequest_NamedTargetFromJSON(object: any): SeekSubscriptionRequest_NamedTarget {
  switch (object) {
    case 0:
    case "NAMED_TARGET_UNSPECIFIED":
      return SeekSubscriptionRequest_NamedTarget.NAMED_TARGET_UNSPECIFIED;
    case 1:
    case "TAIL":
      return SeekSubscriptionRequest_NamedTarget.TAIL;
    case 2:
    case "HEAD":
      return SeekSubscriptionRequest_NamedTarget.HEAD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SeekSubscriptionRequest_NamedTarget.UNRECOGNIZED;
  }
}

export function seekSubscriptionRequest_NamedTargetToJSON(object: SeekSubscriptionRequest_NamedTarget): string {
  switch (object) {
    case SeekSubscriptionRequest_NamedTarget.NAMED_TARGET_UNSPECIFIED:
      return "NAMED_TARGET_UNSPECIFIED";
    case SeekSubscriptionRequest_NamedTarget.TAIL:
      return "TAIL";
    case SeekSubscriptionRequest_NamedTarget.HEAD:
      return "HEAD";
    case SeekSubscriptionRequest_NamedTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response for SeekSubscription long running operation. */
export interface SeekSubscriptionResponse {
}

/** Metadata for long running operations. */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /**
   * The time the operation finished running. Not set if the operation has not
   * completed.
   */
  endTime:
    | Date
    | undefined;
  /**
   * Resource path for the target of the operation. For example, targets of
   * seeks are subscription resources, structured like:
   * projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
   */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
}

/** Request for CreateReservation. */
export interface CreateReservationRequest {
  /**
   * Required. The parent location in which to create the reservation.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * Required. Configuration of the reservation to create. Its `name` field is
   * ignored.
   */
  reservation:
    | Reservation
    | undefined;
  /**
   * Required. The ID to use for the reservation, which will become the final
   * component of the reservation's name.
   *
   * This value is structured like: `my-reservation-name`.
   */
  reservationId: string;
}

/** Request for GetReservation. */
export interface GetReservationRequest {
  /**
   * Required. The name of the reservation whose configuration to return.
   * Structured like:
   * projects/{project_number}/locations/{location}/reservations/{reservation_id}
   */
  name: string;
}

/** Request for ListReservations. */
export interface ListReservationsRequest {
  /**
   * Required. The parent whose reservations are to be listed.
   * Structured like `projects/{project_number}/locations/{location}`.
   */
  parent: string;
  /**
   * The maximum number of reservations to return. The service may return fewer
   * than this value. If unset or zero, all reservations for the parent will be
   * returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListReservations` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListReservations` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** Response for ListReservations. */
export interface ListReservationsResponse {
  /**
   * The list of reservation in the requested parent. The order of the
   * reservations is unspecified.
   */
  reservations: Reservation[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page of
   * results. If this field is omitted, there are no more results.
   */
  nextPageToken: string;
}

/** Request for UpdateReservation. */
export interface UpdateReservationRequest {
  /** Required. The reservation to update. Its `name` field must be populated. */
  reservation:
    | Reservation
    | undefined;
  /** Required. A mask specifying the reservation fields to change. */
  updateMask: string[] | undefined;
}

/** Request for DeleteReservation. */
export interface DeleteReservationRequest {
  /**
   * Required. The name of the reservation to delete.
   * Structured like:
   * projects/{project_number}/locations/{location}/reservations/{reservation_id}
   */
  name: string;
}

/** Request for ListReservationTopics. */
export interface ListReservationTopicsRequest {
  /**
   * Required. The name of the reservation whose topics to list.
   * Structured like:
   * projects/{project_number}/locations/{location}/reservations/{reservation_id}
   */
  name: string;
  /**
   * The maximum number of topics to return. The service may return fewer
   * than this value.
   * If unset or zero, all topics for the given reservation will be returned.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListReservationTopics` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListReservationTopics`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/** Response for ListReservationTopics. */
export interface ListReservationTopicsResponse {
  /**
   * The names of topics attached to the reservation. The order of the
   * topics is unspecified.
   */
  topics: string[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page of
   * results. If this field is omitted, there are no more results.
   */
  nextPageToken: string;
}

function createBaseCreateTopicRequest(): CreateTopicRequest {
  return { parent: "", topic: undefined, topicId: "" };
}

export const CreateTopicRequest: MessageFns<CreateTopicRequest> = {
  encode(message: CreateTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(18).fork()).join();
    }
    if (message.topicId !== "") {
      writer.uint32(26).string(message.topicId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topicId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTopicRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "",
    };
  },

  toJSON(message: CreateTopicRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    if (message.topicId !== "") {
      obj.topicId = message.topicId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTopicRequest>): CreateTopicRequest {
    return CreateTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTopicRequest>): CreateTopicRequest {
    const message = createBaseCreateTopicRequest();
    message.parent = object.parent ?? "";
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    message.topicId = object.topicId ?? "";
    return message;
  },
};

function createBaseGetTopicRequest(): GetTopicRequest {
  return { name: "" };
}

export const GetTopicRequest: MessageFns<GetTopicRequest> = {
  encode(message: GetTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicRequest>): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicRequest>): GetTopicRequest {
    const message = createBaseGetTopicRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetTopicPartitionsRequest(): GetTopicPartitionsRequest {
  return { name: "" };
}

export const GetTopicPartitionsRequest: MessageFns<GetTopicPartitionsRequest> = {
  encode(message: GetTopicPartitionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicPartitionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicPartitionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicPartitionsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTopicPartitionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicPartitionsRequest>): GetTopicPartitionsRequest {
    return GetTopicPartitionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicPartitionsRequest>): GetTopicPartitionsRequest {
    const message = createBaseGetTopicPartitionsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTopicPartitions(): TopicPartitions {
  return { partitionCount: Long.ZERO };
}

export const TopicPartitions: MessageFns<TopicPartitions> = {
  encode(message: TopicPartitions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.partitionCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.partitionCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TopicPartitions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicPartitions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.partitionCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicPartitions {
    return { partitionCount: isSet(object.partitionCount) ? Long.fromValue(object.partitionCount) : Long.ZERO };
  },

  toJSON(message: TopicPartitions): unknown {
    const obj: any = {};
    if (!message.partitionCount.equals(Long.ZERO)) {
      obj.partitionCount = (message.partitionCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<TopicPartitions>): TopicPartitions {
    return TopicPartitions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicPartitions>): TopicPartitions {
    const message = createBaseTopicPartitions();
    message.partitionCount = (object.partitionCount !== undefined && object.partitionCount !== null)
      ? Long.fromValue(object.partitionCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseListTopicsRequest(): ListTopicsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTopicsRequest: MessageFns<ListTopicsRequest> = {
  encode(message: ListTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTopicsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicsRequest>): ListTopicsRequest {
    return ListTopicsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicsRequest>): ListTopicsRequest {
    const message = createBaseListTopicsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTopicsResponse(): ListTopicsResponse {
  return { topics: [], nextPageToken: "" };
}

export const ListTopicsResponse: MessageFns<ListTopicsResponse> = {
  encode(message: ListTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicsResponse>): ListTopicsResponse {
    return ListTopicsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicsResponse>): ListTopicsResponse {
    const message = createBaseListTopicsResponse();
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateTopicRequest(): UpdateTopicRequest {
  return { topic: undefined, updateMask: undefined };
}

export const UpdateTopicRequest: MessageFns<UpdateTopicRequest> = {
  encode(message: UpdateTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTopicRequest {
    return {
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateTopicRequest): unknown {
    const obj: any = {};
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTopicRequest>): UpdateTopicRequest {
    return UpdateTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTopicRequest>): UpdateTopicRequest {
    const message = createBaseUpdateTopicRequest();
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteTopicRequest(): DeleteTopicRequest {
  return { name: "" };
}

export const DeleteTopicRequest: MessageFns<DeleteTopicRequest> = {
  encode(message: DeleteTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTopicRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTopicRequest>): DeleteTopicRequest {
    return DeleteTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTopicRequest>): DeleteTopicRequest {
    const message = createBaseDeleteTopicRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTopicSubscriptionsRequest(): ListTopicSubscriptionsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListTopicSubscriptionsRequest: MessageFns<ListTopicSubscriptionsRequest> = {
  encode(message: ListTopicSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicSubscriptionsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTopicSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicSubscriptionsRequest>): ListTopicSubscriptionsRequest {
    return ListTopicSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicSubscriptionsRequest>): ListTopicSubscriptionsRequest {
    const message = createBaseListTopicSubscriptionsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTopicSubscriptionsResponse(): ListTopicSubscriptionsResponse {
  return { subscriptions: [], nextPageToken: "" };
}

export const ListTopicSubscriptionsResponse: MessageFns<ListTopicSubscriptionsResponse> = {
  encode(message: ListTopicSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      writer.uint32(10).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => globalThis.String(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    return ListTopicSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    const message = createBaseListTopicSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateSubscriptionRequest(): CreateSubscriptionRequest {
  return { parent: "", subscription: undefined, subscriptionId: "", skipBacklog: false };
}

export const CreateSubscriptionRequest: MessageFns<CreateSubscriptionRequest> = {
  encode(message: CreateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.subscription !== undefined) {
      Subscription.encode(message.subscription, writer.uint32(18).fork()).join();
    }
    if (message.subscriptionId !== "") {
      writer.uint32(26).string(message.subscriptionId);
    }
    if (message.skipBacklog !== false) {
      writer.uint32(32).bool(message.skipBacklog);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subscription = Subscription.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.skipBacklog = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubscriptionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      subscription: isSet(object.subscription) ? Subscription.fromJSON(object.subscription) : undefined,
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      skipBacklog: isSet(object.skipBacklog) ? globalThis.Boolean(object.skipBacklog) : false,
    };
  },

  toJSON(message: CreateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.subscription !== undefined) {
      obj.subscription = Subscription.toJSON(message.subscription);
    }
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.skipBacklog !== false) {
      obj.skipBacklog = message.skipBacklog;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSubscriptionRequest>): CreateSubscriptionRequest {
    return CreateSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSubscriptionRequest>): CreateSubscriptionRequest {
    const message = createBaseCreateSubscriptionRequest();
    message.parent = object.parent ?? "";
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? Subscription.fromPartial(object.subscription)
      : undefined;
    message.subscriptionId = object.subscriptionId ?? "";
    message.skipBacklog = object.skipBacklog ?? false;
    return message;
  },
};

function createBaseGetSubscriptionRequest(): GetSubscriptionRequest {
  return { name: "" };
}

export const GetSubscriptionRequest: MessageFns<GetSubscriptionRequest> = {
  encode(message: GetSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubscriptionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSubscriptionRequest>): GetSubscriptionRequest {
    return GetSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubscriptionRequest>): GetSubscriptionRequest {
    const message = createBaseGetSubscriptionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListSubscriptionsRequest(): ListSubscriptionsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSubscriptionsRequest: MessageFns<ListSubscriptionsRequest> = {
  encode(message: ListSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscriptionsRequest>): ListSubscriptionsRequest {
    return ListSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscriptionsRequest>): ListSubscriptionsRequest {
    const message = createBaseListSubscriptionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSubscriptionsResponse(): ListSubscriptionsResponse {
  return { subscriptions: [], nextPageToken: "" };
}

export const ListSubscriptionsResponse: MessageFns<ListSubscriptionsResponse> = {
  encode(message: ListSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      Subscription.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(Subscription.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => Subscription.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => Subscription.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscriptionsResponse>): ListSubscriptionsResponse {
    return ListSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscriptionsResponse>): ListSubscriptionsResponse {
    const message = createBaseListSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => Subscription.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateSubscriptionRequest(): UpdateSubscriptionRequest {
  return { subscription: undefined, updateMask: undefined };
}

export const UpdateSubscriptionRequest: MessageFns<UpdateSubscriptionRequest> = {
  encode(message: UpdateSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== undefined) {
      Subscription.encode(message.subscription, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = Subscription.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionRequest {
    return {
      subscription: isSet(object.subscription) ? Subscription.fromJSON(object.subscription) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscription !== undefined) {
      obj.subscription = Subscription.toJSON(message.subscription);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSubscriptionRequest>): UpdateSubscriptionRequest {
    return UpdateSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSubscriptionRequest>): UpdateSubscriptionRequest {
    const message = createBaseUpdateSubscriptionRequest();
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? Subscription.fromPartial(object.subscription)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteSubscriptionRequest(): DeleteSubscriptionRequest {
  return { name: "" };
}

export const DeleteSubscriptionRequest: MessageFns<DeleteSubscriptionRequest> = {
  encode(message: DeleteSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSubscriptionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSubscriptionRequest>): DeleteSubscriptionRequest {
    return DeleteSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSubscriptionRequest>): DeleteSubscriptionRequest {
    const message = createBaseDeleteSubscriptionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSeekSubscriptionRequest(): SeekSubscriptionRequest {
  return { name: "", namedTarget: undefined, timeTarget: undefined };
}

export const SeekSubscriptionRequest: MessageFns<SeekSubscriptionRequest> = {
  encode(message: SeekSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namedTarget !== undefined) {
      writer.uint32(16).int32(message.namedTarget);
    }
    if (message.timeTarget !== undefined) {
      TimeTarget.encode(message.timeTarget, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeekSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeekSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.namedTarget = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timeTarget = TimeTarget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeekSubscriptionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      namedTarget: isSet(object.namedTarget)
        ? seekSubscriptionRequest_NamedTargetFromJSON(object.namedTarget)
        : undefined,
      timeTarget: isSet(object.timeTarget) ? TimeTarget.fromJSON(object.timeTarget) : undefined,
    };
  },

  toJSON(message: SeekSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namedTarget !== undefined) {
      obj.namedTarget = seekSubscriptionRequest_NamedTargetToJSON(message.namedTarget);
    }
    if (message.timeTarget !== undefined) {
      obj.timeTarget = TimeTarget.toJSON(message.timeTarget);
    }
    return obj;
  },

  create(base?: DeepPartial<SeekSubscriptionRequest>): SeekSubscriptionRequest {
    return SeekSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SeekSubscriptionRequest>): SeekSubscriptionRequest {
    const message = createBaseSeekSubscriptionRequest();
    message.name = object.name ?? "";
    message.namedTarget = object.namedTarget ?? undefined;
    message.timeTarget = (object.timeTarget !== undefined && object.timeTarget !== null)
      ? TimeTarget.fromPartial(object.timeTarget)
      : undefined;
    return message;
  },
};

function createBaseSeekSubscriptionResponse(): SeekSubscriptionResponse {
  return {};
}

export const SeekSubscriptionResponse: MessageFns<SeekSubscriptionResponse> = {
  encode(_: SeekSubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeekSubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeekSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SeekSubscriptionResponse {
    return {};
  },

  toJSON(_: SeekSubscriptionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SeekSubscriptionResponse>): SeekSubscriptionResponse {
    return SeekSubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SeekSubscriptionResponse>): SeekSubscriptionResponse {
    const message = createBaseSeekSubscriptionResponse();
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return { createTime: undefined, endTime: undefined, target: "", verb: "" };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    return message;
  },
};

function createBaseCreateReservationRequest(): CreateReservationRequest {
  return { parent: "", reservation: undefined, reservationId: "" };
}

export const CreateReservationRequest: MessageFns<CreateReservationRequest> = {
  encode(message: CreateReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reservation !== undefined) {
      Reservation.encode(message.reservation, writer.uint32(18).fork()).join();
    }
    if (message.reservationId !== "") {
      writer.uint32(26).string(message.reservationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reservation = Reservation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reservationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReservationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reservation: isSet(object.reservation) ? Reservation.fromJSON(object.reservation) : undefined,
      reservationId: isSet(object.reservationId) ? globalThis.String(object.reservationId) : "",
    };
  },

  toJSON(message: CreateReservationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reservation !== undefined) {
      obj.reservation = Reservation.toJSON(message.reservation);
    }
    if (message.reservationId !== "") {
      obj.reservationId = message.reservationId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReservationRequest>): CreateReservationRequest {
    return CreateReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReservationRequest>): CreateReservationRequest {
    const message = createBaseCreateReservationRequest();
    message.parent = object.parent ?? "";
    message.reservation = (object.reservation !== undefined && object.reservation !== null)
      ? Reservation.fromPartial(object.reservation)
      : undefined;
    message.reservationId = object.reservationId ?? "";
    return message;
  },
};

function createBaseGetReservationRequest(): GetReservationRequest {
  return { name: "" };
}

export const GetReservationRequest: MessageFns<GetReservationRequest> = {
  encode(message: GetReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReservationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationRequest>): GetReservationRequest {
    return GetReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationRequest>): GetReservationRequest {
    const message = createBaseGetReservationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListReservationsRequest(): ListReservationsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReservationsRequest: MessageFns<ListReservationsRequest> = {
  encode(message: ListReservationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReservationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationsRequest>): ListReservationsRequest {
    return ListReservationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationsRequest>): ListReservationsRequest {
    const message = createBaseListReservationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReservationsResponse(): ListReservationsResponse {
  return { reservations: [], nextPageToken: "" };
}

export const ListReservationsResponse: MessageFns<ListReservationsResponse> = {
  encode(message: ListReservationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reservations) {
      Reservation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reservations.push(Reservation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationsResponse {
    return {
      reservations: globalThis.Array.isArray(object?.reservations)
        ? object.reservations.map((e: any) => Reservation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReservationsResponse): unknown {
    const obj: any = {};
    if (message.reservations?.length) {
      obj.reservations = message.reservations.map((e) => Reservation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationsResponse>): ListReservationsResponse {
    return ListReservationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationsResponse>): ListReservationsResponse {
    const message = createBaseListReservationsResponse();
    message.reservations = object.reservations?.map((e) => Reservation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateReservationRequest(): UpdateReservationRequest {
  return { reservation: undefined, updateMask: undefined };
}

export const UpdateReservationRequest: MessageFns<UpdateReservationRequest> = {
  encode(message: UpdateReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservation !== undefined) {
      Reservation.encode(message.reservation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reservation = Reservation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateReservationRequest {
    return {
      reservation: isSet(object.reservation) ? Reservation.fromJSON(object.reservation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateReservationRequest): unknown {
    const obj: any = {};
    if (message.reservation !== undefined) {
      obj.reservation = Reservation.toJSON(message.reservation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateReservationRequest>): UpdateReservationRequest {
    return UpdateReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateReservationRequest>): UpdateReservationRequest {
    const message = createBaseUpdateReservationRequest();
    message.reservation = (object.reservation !== undefined && object.reservation !== null)
      ? Reservation.fromPartial(object.reservation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteReservationRequest(): DeleteReservationRequest {
  return { name: "" };
}

export const DeleteReservationRequest: MessageFns<DeleteReservationRequest> = {
  encode(message: DeleteReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReservationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteReservationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReservationRequest>): DeleteReservationRequest {
    return DeleteReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReservationRequest>): DeleteReservationRequest {
    const message = createBaseDeleteReservationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListReservationTopicsRequest(): ListReservationTopicsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListReservationTopicsRequest: MessageFns<ListReservationTopicsRequest> = {
  encode(message: ListReservationTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationTopicsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationTopicsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReservationTopicsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationTopicsRequest>): ListReservationTopicsRequest {
    return ListReservationTopicsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationTopicsRequest>): ListReservationTopicsRequest {
    const message = createBaseListReservationTopicsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReservationTopicsResponse(): ListReservationTopicsResponse {
  return { topics: [], nextPageToken: "" };
}

export const ListReservationTopicsResponse: MessageFns<ListReservationTopicsResponse> = {
  encode(message: ListReservationTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      writer.uint32(10).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationTopicsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topics.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationTopicsResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => globalThis.String(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReservationTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationTopicsResponse>): ListReservationTopicsResponse {
    return ListReservationTopicsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationTopicsResponse>): ListReservationTopicsResponse {
    const message = createBaseListReservationTopicsResponse();
    message.topics = object.topics?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * The service that a client application uses to manage topics and
 * subscriptions, such creating, listing, and deleting topics and subscriptions.
 */
export type AdminServiceDefinition = typeof AdminServiceDefinition;
export const AdminServiceDefinition = {
  name: "AdminService",
  fullName: "google.cloud.pubsublite.v1.AdminService",
  methods: {
    /** Creates a new topic. */
    createTopic: {
      name: "CreateTopic",
      requestType: CreateTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              111,
              112,
              105,
              99,
              44,
              116,
              111,
              112,
              105,
              99,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              116,
              111,
              112,
              105,
              99,
              34,
              48,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the topic configuration. */
    getTopic: {
      name: "GetTopic",
      requestType: GetTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the partition information for the requested topic. */
    getTopicPartitions: {
      name: "GetTopicPartitions",
      requestType: GetTopicPartitionsRequest,
      requestStream: false,
      responseType: TopicPartitions,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the list of topics for the given project. */
    listTopics: {
      name: "ListTopics",
      requestType: ListTopicsRequest,
      requestStream: false,
      responseType: ListTopicsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates properties of the specified topic. */
    updateTopic: {
      name: "UpdateTopic",
      requestType: UpdateTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 116, 111, 112, 105, 99, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              63,
              58,
              5,
              116,
              111,
              112,
              105,
              99,
              50,
              54,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              116,
              111,
              112,
              105,
              99,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified topic. */
    deleteTopic: {
      name: "DeleteTopic",
      requestType: DeleteTopicRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists the subscriptions attached to the specified topic. */
    listTopicSubscriptions: {
      name: "ListTopicSubscriptions",
      requestType: ListTopicSubscriptionsRequest,
      requestStream: false,
      responseType: ListTopicSubscriptionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a new subscription. */
    createSubscription: {
      name: "CreateSubscription",
      requestType: CreateSubscriptionRequest,
      requestStream: false,
      responseType: Subscription,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              35,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              44,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              12,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              34,
              55,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the subscription configuration. */
    getSubscription: {
      name: "GetSubscription",
      requestType: GetSubscriptionRequest,
      requestStream: false,
      responseType: Subscription,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the list of subscriptions for the given project. */
    listSubscriptions: {
      name: "ListSubscriptions",
      requestType: ListSubscriptionsRequest,
      requestStream: false,
      responseType: ListSubscriptionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates properties of the specified subscription. */
    updateSubscription: {
      name: "UpdateSubscription",
      requestType: UpdateSubscriptionRequest,
      requestStream: false,
      responseType: Subscription,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              24,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              12,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              50,
              68,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified subscription. */
    deleteSubscription: {
      name: "DeleteSubscription",
      requestType: DeleteSubscriptionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              42,
              55,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Performs an out-of-band seek for a subscription to a specified target,
     * which may be timestamps or named positions within the message backlog.
     * Seek translates these targets to cursors for each partition and
     * orchestrates subscribers to start consuming messages from these seek
     * cursors.
     *
     * If an operation is returned, the seek has been registered and subscribers
     * will eventually receive messages from the seek cursors (i.e. eventual
     * consistency), as long as they are using a minimum supported client library
     * version and not a system that tracks cursors independently of Pub/Sub Lite
     * (e.g. Apache Beam, Dataflow, Spark). The seek operation will fail for
     * unsupported clients.
     *
     * If clients would like to know when subscribers react to the seek (or not),
     * they can poll the operation. The seek operation will succeed and complete
     * once subscribers are ready to receive messages from the seek cursors for
     * all partitions of the topic. This means that the seek operation will not
     * complete until all subscribers come online.
     *
     * If the previous seek operation has not yet completed, it will be aborted
     * and the new invocation of seek will supersede it.
     */
    seekSubscription: {
      name: "SeekSubscription",
      requestType: SeekSubscriptionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              83,
              101,
              101,
              107,
              83,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              115,
              99,
              114,
              105,
              112,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              101,
              107,
            ]),
          ],
        },
      },
    },
    /** Creates a new reservation. */
    createReservation: {
      name: "CreateReservation",
      requestType: CreateReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              44,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              11,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              34,
              54,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the reservation configuration. */
    getReservation: {
      name: "GetReservation",
      requestType: GetReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the list of reservations for the given project. */
    listReservations: {
      name: "ListReservations",
      requestType: ListReservationsRequest,
      requestStream: false,
      responseType: ListReservationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates properties of the specified reservation. */
    updateReservation: {
      name: "UpdateReservation",
      requestType: UpdateReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              11,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              50,
              66,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified reservation. */
    deleteReservation: {
      name: "DeleteReservation",
      requestType: DeleteReservationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              42,
              54,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists the topics attached to the specified reservation. */
    listReservationTopics: {
      name: "ListReservationTopics",
      requestType: ListReservationTopicsRequest,
      requestStream: false,
      responseType: ListReservationTopicsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              49,
              47,
              97,
              100,
              109,
              105,
              110,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AdminServiceImplementation<CallContextExt = {}> {
  /** Creates a new topic. */
  createTopic(request: CreateTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Returns the topic configuration. */
  getTopic(request: GetTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Returns the partition information for the requested topic. */
  getTopicPartitions(
    request: GetTopicPartitionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TopicPartitions>>;
  /** Returns the list of topics for the given project. */
  listTopics(
    request: ListTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicsResponse>>;
  /** Updates properties of the specified topic. */
  updateTopic(request: UpdateTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Deletes the specified topic. */
  deleteTopic(request: DeleteTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Lists the subscriptions attached to the specified topic. */
  listTopicSubscriptions(
    request: ListTopicSubscriptionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicSubscriptionsResponse>>;
  /** Creates a new subscription. */
  createSubscription(
    request: CreateSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Subscription>>;
  /** Returns the subscription configuration. */
  getSubscription(
    request: GetSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Subscription>>;
  /** Returns the list of subscriptions for the given project. */
  listSubscriptions(
    request: ListSubscriptionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubscriptionsResponse>>;
  /** Updates properties of the specified subscription. */
  updateSubscription(
    request: UpdateSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Subscription>>;
  /** Deletes the specified subscription. */
  deleteSubscription(
    request: DeleteSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Performs an out-of-band seek for a subscription to a specified target,
   * which may be timestamps or named positions within the message backlog.
   * Seek translates these targets to cursors for each partition and
   * orchestrates subscribers to start consuming messages from these seek
   * cursors.
   *
   * If an operation is returned, the seek has been registered and subscribers
   * will eventually receive messages from the seek cursors (i.e. eventual
   * consistency), as long as they are using a minimum supported client library
   * version and not a system that tracks cursors independently of Pub/Sub Lite
   * (e.g. Apache Beam, Dataflow, Spark). The seek operation will fail for
   * unsupported clients.
   *
   * If clients would like to know when subscribers react to the seek (or not),
   * they can poll the operation. The seek operation will succeed and complete
   * once subscribers are ready to receive messages from the seek cursors for
   * all partitions of the topic. This means that the seek operation will not
   * complete until all subscribers come online.
   *
   * If the previous seek operation has not yet completed, it will be aborted
   * and the new invocation of seek will supersede it.
   */
  seekSubscription(
    request: SeekSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a new reservation. */
  createReservation(
    request: CreateReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /** Returns the reservation configuration. */
  getReservation(
    request: GetReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /** Returns the list of reservations for the given project. */
  listReservations(
    request: ListReservationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReservationsResponse>>;
  /** Updates properties of the specified reservation. */
  updateReservation(
    request: UpdateReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /** Deletes the specified reservation. */
  deleteReservation(
    request: DeleteReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists the topics attached to the specified reservation. */
  listReservationTopics(
    request: ListReservationTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReservationTopicsResponse>>;
}

export interface AdminServiceClient<CallOptionsExt = {}> {
  /** Creates a new topic. */
  createTopic(request: DeepPartial<CreateTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Returns the topic configuration. */
  getTopic(request: DeepPartial<GetTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Returns the partition information for the requested topic. */
  getTopicPartitions(
    request: DeepPartial<GetTopicPartitionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TopicPartitions>;
  /** Returns the list of topics for the given project. */
  listTopics(
    request: DeepPartial<ListTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicsResponse>;
  /** Updates properties of the specified topic. */
  updateTopic(request: DeepPartial<UpdateTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Deletes the specified topic. */
  deleteTopic(request: DeepPartial<DeleteTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Lists the subscriptions attached to the specified topic. */
  listTopicSubscriptions(
    request: DeepPartial<ListTopicSubscriptionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicSubscriptionsResponse>;
  /** Creates a new subscription. */
  createSubscription(
    request: DeepPartial<CreateSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Subscription>;
  /** Returns the subscription configuration. */
  getSubscription(
    request: DeepPartial<GetSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Subscription>;
  /** Returns the list of subscriptions for the given project. */
  listSubscriptions(
    request: DeepPartial<ListSubscriptionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubscriptionsResponse>;
  /** Updates properties of the specified subscription. */
  updateSubscription(
    request: DeepPartial<UpdateSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Subscription>;
  /** Deletes the specified subscription. */
  deleteSubscription(
    request: DeepPartial<DeleteSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Performs an out-of-band seek for a subscription to a specified target,
   * which may be timestamps or named positions within the message backlog.
   * Seek translates these targets to cursors for each partition and
   * orchestrates subscribers to start consuming messages from these seek
   * cursors.
   *
   * If an operation is returned, the seek has been registered and subscribers
   * will eventually receive messages from the seek cursors (i.e. eventual
   * consistency), as long as they are using a minimum supported client library
   * version and not a system that tracks cursors independently of Pub/Sub Lite
   * (e.g. Apache Beam, Dataflow, Spark). The seek operation will fail for
   * unsupported clients.
   *
   * If clients would like to know when subscribers react to the seek (or not),
   * they can poll the operation. The seek operation will succeed and complete
   * once subscribers are ready to receive messages from the seek cursors for
   * all partitions of the topic. This means that the seek operation will not
   * complete until all subscribers come online.
   *
   * If the previous seek operation has not yet completed, it will be aborted
   * and the new invocation of seek will supersede it.
   */
  seekSubscription(
    request: DeepPartial<SeekSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a new reservation. */
  createReservation(
    request: DeepPartial<CreateReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /** Returns the reservation configuration. */
  getReservation(
    request: DeepPartial<GetReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /** Returns the list of reservations for the given project. */
  listReservations(
    request: DeepPartial<ListReservationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReservationsResponse>;
  /** Updates properties of the specified reservation. */
  updateReservation(
    request: DeepPartial<UpdateReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /** Deletes the specified reservation. */
  deleteReservation(
    request: DeepPartial<DeleteReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists the topics attached to the specified reservation. */
  listReservationTopics(
    request: DeepPartial<ListReservationTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReservationTopicsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
