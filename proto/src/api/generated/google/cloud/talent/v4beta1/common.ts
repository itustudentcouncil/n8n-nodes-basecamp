// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/talent/v4beta1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DoubleValue } from "../../../protobuf/wrappers.js";
import { LatLng } from "../../../type/latlng.js";
import { Money } from "../../../type/money.js";
import { PostalAddress } from "../../../type/postal_address.js";

export const protobufPackage = "google.cloud.talent.v4beta1";

/** An enum that represents the size of the company. */
export enum CompanySize {
  /** COMPANY_SIZE_UNSPECIFIED - Default value if the size isn't specified. */
  COMPANY_SIZE_UNSPECIFIED = 0,
  /** MINI - The company has less than 50 employees. */
  MINI = 1,
  /** SMALL - The company has between 50 and 99 employees. */
  SMALL = 2,
  /** SMEDIUM - The company has between 100 and 499 employees. */
  SMEDIUM = 3,
  /** MEDIUM - The company has between 500 and 999 employees. */
  MEDIUM = 4,
  /** BIG - The company has between 1,000 and 4,999 employees. */
  BIG = 5,
  /** BIGGER - The company has between 5,000 and 9,999 employees. */
  BIGGER = 6,
  /** GIANT - The company has 10,000 or more employees. */
  GIANT = 7,
  UNRECOGNIZED = -1,
}

export function companySizeFromJSON(object: any): CompanySize {
  switch (object) {
    case 0:
    case "COMPANY_SIZE_UNSPECIFIED":
      return CompanySize.COMPANY_SIZE_UNSPECIFIED;
    case 1:
    case "MINI":
      return CompanySize.MINI;
    case 2:
    case "SMALL":
      return CompanySize.SMALL;
    case 3:
    case "SMEDIUM":
      return CompanySize.SMEDIUM;
    case 4:
    case "MEDIUM":
      return CompanySize.MEDIUM;
    case 5:
    case "BIG":
      return CompanySize.BIG;
    case 6:
    case "BIGGER":
      return CompanySize.BIGGER;
    case 7:
    case "GIANT":
      return CompanySize.GIANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompanySize.UNRECOGNIZED;
  }
}

export function companySizeToJSON(object: CompanySize): string {
  switch (object) {
    case CompanySize.COMPANY_SIZE_UNSPECIFIED:
      return "COMPANY_SIZE_UNSPECIFIED";
    case CompanySize.MINI:
      return "MINI";
    case CompanySize.SMALL:
      return "SMALL";
    case CompanySize.SMEDIUM:
      return "SMEDIUM";
    case CompanySize.MEDIUM:
      return "MEDIUM";
    case CompanySize.BIG:
      return "BIG";
    case CompanySize.BIGGER:
      return "BIGGER";
    case CompanySize.GIANT:
      return "GIANT";
    case CompanySize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An enum that represents employee benefits included with the job. */
export enum JobBenefit {
  /** JOB_BENEFIT_UNSPECIFIED - Default value if the type isn't specified. */
  JOB_BENEFIT_UNSPECIFIED = 0,
  /**
   * CHILD_CARE - The job includes access to programs that support child care, such
   * as daycare.
   */
  CHILD_CARE = 1,
  /**
   * DENTAL - The job includes dental services covered by a dental
   * insurance plan.
   */
  DENTAL = 2,
  /** DOMESTIC_PARTNER - The job offers specific benefits to domestic partners. */
  DOMESTIC_PARTNER = 3,
  /** FLEXIBLE_HOURS - The job allows for a flexible work schedule. */
  FLEXIBLE_HOURS = 4,
  /** MEDICAL - The job includes health services covered by a medical insurance plan. */
  MEDICAL = 5,
  /**
   * LIFE_INSURANCE - The job includes a life insurance plan provided by the employer or
   * available for purchase by the employee.
   */
  LIFE_INSURANCE = 6,
  /**
   * PARENTAL_LEAVE - The job allows for a leave of absence to a parent to care for a newborn
   * child.
   */
  PARENTAL_LEAVE = 7,
  /**
   * RETIREMENT_PLAN - The job includes a workplace retirement plan provided by the
   * employer or available for purchase by the employee.
   */
  RETIREMENT_PLAN = 8,
  /** SICK_DAYS - The job allows for paid time off due to illness. */
  SICK_DAYS = 9,
  /** VACATION - The job includes paid time off for vacation. */
  VACATION = 10,
  /**
   * VISION - The job includes vision services covered by a vision
   * insurance plan.
   */
  VISION = 11,
  UNRECOGNIZED = -1,
}

export function jobBenefitFromJSON(object: any): JobBenefit {
  switch (object) {
    case 0:
    case "JOB_BENEFIT_UNSPECIFIED":
      return JobBenefit.JOB_BENEFIT_UNSPECIFIED;
    case 1:
    case "CHILD_CARE":
      return JobBenefit.CHILD_CARE;
    case 2:
    case "DENTAL":
      return JobBenefit.DENTAL;
    case 3:
    case "DOMESTIC_PARTNER":
      return JobBenefit.DOMESTIC_PARTNER;
    case 4:
    case "FLEXIBLE_HOURS":
      return JobBenefit.FLEXIBLE_HOURS;
    case 5:
    case "MEDICAL":
      return JobBenefit.MEDICAL;
    case 6:
    case "LIFE_INSURANCE":
      return JobBenefit.LIFE_INSURANCE;
    case 7:
    case "PARENTAL_LEAVE":
      return JobBenefit.PARENTAL_LEAVE;
    case 8:
    case "RETIREMENT_PLAN":
      return JobBenefit.RETIREMENT_PLAN;
    case 9:
    case "SICK_DAYS":
      return JobBenefit.SICK_DAYS;
    case 10:
    case "VACATION":
      return JobBenefit.VACATION;
    case 11:
    case "VISION":
      return JobBenefit.VISION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobBenefit.UNRECOGNIZED;
  }
}

export function jobBenefitToJSON(object: JobBenefit): string {
  switch (object) {
    case JobBenefit.JOB_BENEFIT_UNSPECIFIED:
      return "JOB_BENEFIT_UNSPECIFIED";
    case JobBenefit.CHILD_CARE:
      return "CHILD_CARE";
    case JobBenefit.DENTAL:
      return "DENTAL";
    case JobBenefit.DOMESTIC_PARTNER:
      return "DOMESTIC_PARTNER";
    case JobBenefit.FLEXIBLE_HOURS:
      return "FLEXIBLE_HOURS";
    case JobBenefit.MEDICAL:
      return "MEDICAL";
    case JobBenefit.LIFE_INSURANCE:
      return "LIFE_INSURANCE";
    case JobBenefit.PARENTAL_LEAVE:
      return "PARENTAL_LEAVE";
    case JobBenefit.RETIREMENT_PLAN:
      return "RETIREMENT_PLAN";
    case JobBenefit.SICK_DAYS:
      return "SICK_DAYS";
    case JobBenefit.VACATION:
      return "VACATION";
    case JobBenefit.VISION:
      return "VISION";
    case JobBenefit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Educational degree level defined in International Standard Classification
 * of Education (ISCED).
 */
export enum DegreeType {
  /**
   * DEGREE_TYPE_UNSPECIFIED - Default value. Represents no degree, or early childhood education.
   * Maps to ISCED code 0.
   * Ex) Kindergarten
   */
  DEGREE_TYPE_UNSPECIFIED = 0,
  /**
   * PRIMARY_EDUCATION - Primary education which is typically the first stage of compulsory
   * education. ISCED code 1.
   * Ex) Elementary school
   */
  PRIMARY_EDUCATION = 1,
  /**
   * LOWER_SECONDARY_EDUCATION - Lower secondary education; First stage of secondary education building on
   * primary education, typically with a more subject-oriented curriculum.
   * ISCED code 2.
   * Ex) Middle school
   */
  LOWER_SECONDARY_EDUCATION = 2,
  /**
   * UPPER_SECONDARY_EDUCATION - Middle education; Second/final stage of secondary education preparing for
   * tertiary education and/or providing skills relevant to employment.
   * Usually with an increased range of subject options and streams. ISCED
   * code 3.
   * Ex) High school
   */
  UPPER_SECONDARY_EDUCATION = 3,
  /**
   * ADULT_REMEDIAL_EDUCATION - Adult Remedial Education; Programmes providing learning experiences that
   * build on secondary education and prepare for labour market entry and/or
   * tertiary education. The content is broader than secondary but not as
   * complex as tertiary education. ISCED code 4.
   */
  ADULT_REMEDIAL_EDUCATION = 4,
  /**
   * ASSOCIATES_OR_EQUIVALENT - Associate's or equivalent; Short first tertiary programmes that are
   * typically practically-based, occupationally-specific and prepare for
   * labour market entry. These programmes may also provide a pathway to other
   * tertiary programmes. ISCED code 5.
   */
  ASSOCIATES_OR_EQUIVALENT = 5,
  /**
   * BACHELORS_OR_EQUIVALENT - Bachelor's or equivalent; Programmes designed to provide intermediate
   * academic and/or professional knowledge, skills and competencies leading
   * to a first tertiary degree or equivalent qualification. ISCED code 6.
   */
  BACHELORS_OR_EQUIVALENT = 6,
  /**
   * MASTERS_OR_EQUIVALENT - Master's or equivalent; Programmes designed to provide advanced academic
   * and/or professional knowledge, skills and competencies leading to a
   * second tertiary degree or equivalent qualification. ISCED code 7.
   */
  MASTERS_OR_EQUIVALENT = 7,
  /**
   * DOCTORAL_OR_EQUIVALENT - Doctoral or equivalent; Programmes designed primarily to lead to an
   * advanced research qualification, usually concluding with the submission
   * and defense of a substantive dissertation of publishable quality based on
   * original research. ISCED code 8.
   */
  DOCTORAL_OR_EQUIVALENT = 8,
  UNRECOGNIZED = -1,
}

export function degreeTypeFromJSON(object: any): DegreeType {
  switch (object) {
    case 0:
    case "DEGREE_TYPE_UNSPECIFIED":
      return DegreeType.DEGREE_TYPE_UNSPECIFIED;
    case 1:
    case "PRIMARY_EDUCATION":
      return DegreeType.PRIMARY_EDUCATION;
    case 2:
    case "LOWER_SECONDARY_EDUCATION":
      return DegreeType.LOWER_SECONDARY_EDUCATION;
    case 3:
    case "UPPER_SECONDARY_EDUCATION":
      return DegreeType.UPPER_SECONDARY_EDUCATION;
    case 4:
    case "ADULT_REMEDIAL_EDUCATION":
      return DegreeType.ADULT_REMEDIAL_EDUCATION;
    case 5:
    case "ASSOCIATES_OR_EQUIVALENT":
      return DegreeType.ASSOCIATES_OR_EQUIVALENT;
    case 6:
    case "BACHELORS_OR_EQUIVALENT":
      return DegreeType.BACHELORS_OR_EQUIVALENT;
    case 7:
    case "MASTERS_OR_EQUIVALENT":
      return DegreeType.MASTERS_OR_EQUIVALENT;
    case 8:
    case "DOCTORAL_OR_EQUIVALENT":
      return DegreeType.DOCTORAL_OR_EQUIVALENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DegreeType.UNRECOGNIZED;
  }
}

export function degreeTypeToJSON(object: DegreeType): string {
  switch (object) {
    case DegreeType.DEGREE_TYPE_UNSPECIFIED:
      return "DEGREE_TYPE_UNSPECIFIED";
    case DegreeType.PRIMARY_EDUCATION:
      return "PRIMARY_EDUCATION";
    case DegreeType.LOWER_SECONDARY_EDUCATION:
      return "LOWER_SECONDARY_EDUCATION";
    case DegreeType.UPPER_SECONDARY_EDUCATION:
      return "UPPER_SECONDARY_EDUCATION";
    case DegreeType.ADULT_REMEDIAL_EDUCATION:
      return "ADULT_REMEDIAL_EDUCATION";
    case DegreeType.ASSOCIATES_OR_EQUIVALENT:
      return "ASSOCIATES_OR_EQUIVALENT";
    case DegreeType.BACHELORS_OR_EQUIVALENT:
      return "BACHELORS_OR_EQUIVALENT";
    case DegreeType.MASTERS_OR_EQUIVALENT:
      return "MASTERS_OR_EQUIVALENT";
    case DegreeType.DOCTORAL_OR_EQUIVALENT:
      return "DOCTORAL_OR_EQUIVALENT";
    case DegreeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An enum that represents the employment type of a job. */
export enum EmploymentType {
  /** EMPLOYMENT_TYPE_UNSPECIFIED - The default value if the employment type isn't specified. */
  EMPLOYMENT_TYPE_UNSPECIFIED = 0,
  /**
   * FULL_TIME - The job requires working a number of hours that constitute full
   * time employment, typically 40 or more hours per week.
   */
  FULL_TIME = 1,
  /**
   * PART_TIME - The job entails working fewer hours than a full time job,
   * typically less than 40 hours a week.
   */
  PART_TIME = 2,
  /**
   * CONTRACTOR - The job is offered as a contracted, as opposed to a salaried employee,
   * position.
   */
  CONTRACTOR = 3,
  /**
   * CONTRACT_TO_HIRE - The job is offered as a contracted position with the understanding
   * that it's converted into a full-time position at the end of the
   * contract. Jobs of this type are also returned by a search for
   * [EmploymentType.CONTRACTOR][google.cloud.talent.v4beta1.EmploymentType.CONTRACTOR]
   * jobs.
   */
  CONTRACT_TO_HIRE = 4,
  /**
   * TEMPORARY - The job is offered as a temporary employment opportunity, usually
   * a short-term engagement.
   */
  TEMPORARY = 5,
  /**
   * INTERN - The job is a fixed-term opportunity for students or entry-level job
   * seekers to obtain on-the-job training, typically offered as a summer
   * position.
   */
  INTERN = 6,
  /**
   * VOLUNTEER - The is an opportunity for an individual to volunteer, where there's no
   * expectation of compensation for the provided services.
   */
  VOLUNTEER = 7,
  /**
   * PER_DIEM - The job requires an employee to work on an as-needed basis with a
   * flexible schedule.
   */
  PER_DIEM = 8,
  /**
   * FLY_IN_FLY_OUT - The job involves employing people in remote areas and flying them
   * temporarily to the work site instead of relocating employees and their
   * families permanently.
   */
  FLY_IN_FLY_OUT = 9,
  /** OTHER_EMPLOYMENT_TYPE - The job does not fit any of the other listed types. */
  OTHER_EMPLOYMENT_TYPE = 10,
  UNRECOGNIZED = -1,
}

export function employmentTypeFromJSON(object: any): EmploymentType {
  switch (object) {
    case 0:
    case "EMPLOYMENT_TYPE_UNSPECIFIED":
      return EmploymentType.EMPLOYMENT_TYPE_UNSPECIFIED;
    case 1:
    case "FULL_TIME":
      return EmploymentType.FULL_TIME;
    case 2:
    case "PART_TIME":
      return EmploymentType.PART_TIME;
    case 3:
    case "CONTRACTOR":
      return EmploymentType.CONTRACTOR;
    case 4:
    case "CONTRACT_TO_HIRE":
      return EmploymentType.CONTRACT_TO_HIRE;
    case 5:
    case "TEMPORARY":
      return EmploymentType.TEMPORARY;
    case 6:
    case "INTERN":
      return EmploymentType.INTERN;
    case 7:
    case "VOLUNTEER":
      return EmploymentType.VOLUNTEER;
    case 8:
    case "PER_DIEM":
      return EmploymentType.PER_DIEM;
    case 9:
    case "FLY_IN_FLY_OUT":
      return EmploymentType.FLY_IN_FLY_OUT;
    case 10:
    case "OTHER_EMPLOYMENT_TYPE":
      return EmploymentType.OTHER_EMPLOYMENT_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EmploymentType.UNRECOGNIZED;
  }
}

export function employmentTypeToJSON(object: EmploymentType): string {
  switch (object) {
    case EmploymentType.EMPLOYMENT_TYPE_UNSPECIFIED:
      return "EMPLOYMENT_TYPE_UNSPECIFIED";
    case EmploymentType.FULL_TIME:
      return "FULL_TIME";
    case EmploymentType.PART_TIME:
      return "PART_TIME";
    case EmploymentType.CONTRACTOR:
      return "CONTRACTOR";
    case EmploymentType.CONTRACT_TO_HIRE:
      return "CONTRACT_TO_HIRE";
    case EmploymentType.TEMPORARY:
      return "TEMPORARY";
    case EmploymentType.INTERN:
      return "INTERN";
    case EmploymentType.VOLUNTEER:
      return "VOLUNTEER";
    case EmploymentType.PER_DIEM:
      return "PER_DIEM";
    case EmploymentType.FLY_IN_FLY_OUT:
      return "FLY_IN_FLY_OUT";
    case EmploymentType.OTHER_EMPLOYMENT_TYPE:
      return "OTHER_EMPLOYMENT_TYPE";
    case EmploymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An enum that represents the required experience level required for the job. */
export enum JobLevel {
  /** JOB_LEVEL_UNSPECIFIED - The default value if the level isn't specified. */
  JOB_LEVEL_UNSPECIFIED = 0,
  /**
   * ENTRY_LEVEL - Entry-level individual contributors, typically with less than 2 years of
   * experience in a similar role. Includes interns.
   */
  ENTRY_LEVEL = 1,
  /**
   * EXPERIENCED - Experienced individual contributors, typically with 2+ years of
   * experience in a similar role.
   */
  EXPERIENCED = 2,
  /** MANAGER - Entry- to mid-level managers responsible for managing a team of people. */
  MANAGER = 3,
  /** DIRECTOR - Senior-level managers responsible for managing teams of managers. */
  DIRECTOR = 4,
  /** EXECUTIVE - Executive-level managers and above, including C-level positions. */
  EXECUTIVE = 5,
  UNRECOGNIZED = -1,
}

export function jobLevelFromJSON(object: any): JobLevel {
  switch (object) {
    case 0:
    case "JOB_LEVEL_UNSPECIFIED":
      return JobLevel.JOB_LEVEL_UNSPECIFIED;
    case 1:
    case "ENTRY_LEVEL":
      return JobLevel.ENTRY_LEVEL;
    case 2:
    case "EXPERIENCED":
      return JobLevel.EXPERIENCED;
    case 3:
    case "MANAGER":
      return JobLevel.MANAGER;
    case 4:
    case "DIRECTOR":
      return JobLevel.DIRECTOR;
    case 5:
    case "EXECUTIVE":
      return JobLevel.EXECUTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobLevel.UNRECOGNIZED;
  }
}

export function jobLevelToJSON(object: JobLevel): string {
  switch (object) {
    case JobLevel.JOB_LEVEL_UNSPECIFIED:
      return "JOB_LEVEL_UNSPECIFIED";
    case JobLevel.ENTRY_LEVEL:
      return "ENTRY_LEVEL";
    case JobLevel.EXPERIENCED:
      return "EXPERIENCED";
    case JobLevel.MANAGER:
      return "MANAGER";
    case JobLevel.DIRECTOR:
      return "DIRECTOR";
    case JobLevel.EXECUTIVE:
      return "EXECUTIVE";
    case JobLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An enum that represents the categorization or primary focus of specific
 * role. This value is different than the "industry" associated with a role,
 * which is related to the categorization of the company listing the job.
 */
export enum JobCategory {
  /** JOB_CATEGORY_UNSPECIFIED - The default value if the category isn't specified. */
  JOB_CATEGORY_UNSPECIFIED = 0,
  /** ACCOUNTING_AND_FINANCE - An accounting and finance job, such as an Accountant. */
  ACCOUNTING_AND_FINANCE = 1,
  /** ADMINISTRATIVE_AND_OFFICE - An administrative and office job, such as an Administrative Assistant. */
  ADMINISTRATIVE_AND_OFFICE = 2,
  /** ADVERTISING_AND_MARKETING - An advertising and marketing job, such as Marketing Manager. */
  ADVERTISING_AND_MARKETING = 3,
  /** ANIMAL_CARE - An animal care job, such as Veterinarian. */
  ANIMAL_CARE = 4,
  /** ART_FASHION_AND_DESIGN - An art, fashion, or design job, such as Designer. */
  ART_FASHION_AND_DESIGN = 5,
  /** BUSINESS_OPERATIONS - A business operations job, such as Business Operations Manager. */
  BUSINESS_OPERATIONS = 6,
  /** CLEANING_AND_FACILITIES - A cleaning and facilities job, such as Custodial Staff. */
  CLEANING_AND_FACILITIES = 7,
  /** COMPUTER_AND_IT - A computer and IT job, such as Systems Administrator. */
  COMPUTER_AND_IT = 8,
  /** CONSTRUCTION - A construction job, such as General Laborer. */
  CONSTRUCTION = 9,
  /** CUSTOMER_SERVICE - A customer service job, such s Cashier. */
  CUSTOMER_SERVICE = 10,
  /** EDUCATION - An education job, such as School Teacher. */
  EDUCATION = 11,
  /** ENTERTAINMENT_AND_TRAVEL - An entertainment and travel job, such as Flight Attendant. */
  ENTERTAINMENT_AND_TRAVEL = 12,
  /** FARMING_AND_OUTDOORS - A farming or outdoor job, such as Park Ranger. */
  FARMING_AND_OUTDOORS = 13,
  /** HEALTHCARE - A healthcare job, such as Registered Nurse. */
  HEALTHCARE = 14,
  /** HUMAN_RESOURCES - A human resources job, such as Human Resources Director. */
  HUMAN_RESOURCES = 15,
  /** INSTALLATION_MAINTENANCE_AND_REPAIR - An installation, maintenance, or repair job, such as Electrician. */
  INSTALLATION_MAINTENANCE_AND_REPAIR = 16,
  /** LEGAL - A legal job, such as Law Clerk. */
  LEGAL = 17,
  /**
   * MANAGEMENT - A management job, often used in conjunction with another category,
   * such as Store Manager.
   */
  MANAGEMENT = 18,
  /** MANUFACTURING_AND_WAREHOUSE - A manufacturing or warehouse job, such as Assembly Technician. */
  MANUFACTURING_AND_WAREHOUSE = 19,
  /** MEDIA_COMMUNICATIONS_AND_WRITING - A media, communications, or writing job, such as Media Relations. */
  MEDIA_COMMUNICATIONS_AND_WRITING = 20,
  /** OIL_GAS_AND_MINING - An oil, gas or mining job, such as Offshore Driller. */
  OIL_GAS_AND_MINING = 21,
  /** PERSONAL_CARE_AND_SERVICES - A personal care and services job, such as Hair Stylist. */
  PERSONAL_CARE_AND_SERVICES = 22,
  /** PROTECTIVE_SERVICES - A protective services job, such as Security Guard. */
  PROTECTIVE_SERVICES = 23,
  /** REAL_ESTATE - A real estate job, such as Buyer's Agent. */
  REAL_ESTATE = 24,
  /** RESTAURANT_AND_HOSPITALITY - A restaurant and hospitality job, such as Restaurant Server. */
  RESTAURANT_AND_HOSPITALITY = 25,
  /** SALES_AND_RETAIL - A sales and/or retail job, such Sales Associate. */
  SALES_AND_RETAIL = 26,
  /** SCIENCE_AND_ENGINEERING - A science and engineering job, such as Lab Technician. */
  SCIENCE_AND_ENGINEERING = 27,
  /** SOCIAL_SERVICES_AND_NON_PROFIT - A social services or non-profit job, such as Case Worker. */
  SOCIAL_SERVICES_AND_NON_PROFIT = 28,
  /** SPORTS_FITNESS_AND_RECREATION - A sports, fitness, or recreation job, such as Personal Trainer. */
  SPORTS_FITNESS_AND_RECREATION = 29,
  /** TRANSPORTATION_AND_LOGISTICS - A transportation or logistics job, such as Truck Driver. */
  TRANSPORTATION_AND_LOGISTICS = 30,
  UNRECOGNIZED = -1,
}

export function jobCategoryFromJSON(object: any): JobCategory {
  switch (object) {
    case 0:
    case "JOB_CATEGORY_UNSPECIFIED":
      return JobCategory.JOB_CATEGORY_UNSPECIFIED;
    case 1:
    case "ACCOUNTING_AND_FINANCE":
      return JobCategory.ACCOUNTING_AND_FINANCE;
    case 2:
    case "ADMINISTRATIVE_AND_OFFICE":
      return JobCategory.ADMINISTRATIVE_AND_OFFICE;
    case 3:
    case "ADVERTISING_AND_MARKETING":
      return JobCategory.ADVERTISING_AND_MARKETING;
    case 4:
    case "ANIMAL_CARE":
      return JobCategory.ANIMAL_CARE;
    case 5:
    case "ART_FASHION_AND_DESIGN":
      return JobCategory.ART_FASHION_AND_DESIGN;
    case 6:
    case "BUSINESS_OPERATIONS":
      return JobCategory.BUSINESS_OPERATIONS;
    case 7:
    case "CLEANING_AND_FACILITIES":
      return JobCategory.CLEANING_AND_FACILITIES;
    case 8:
    case "COMPUTER_AND_IT":
      return JobCategory.COMPUTER_AND_IT;
    case 9:
    case "CONSTRUCTION":
      return JobCategory.CONSTRUCTION;
    case 10:
    case "CUSTOMER_SERVICE":
      return JobCategory.CUSTOMER_SERVICE;
    case 11:
    case "EDUCATION":
      return JobCategory.EDUCATION;
    case 12:
    case "ENTERTAINMENT_AND_TRAVEL":
      return JobCategory.ENTERTAINMENT_AND_TRAVEL;
    case 13:
    case "FARMING_AND_OUTDOORS":
      return JobCategory.FARMING_AND_OUTDOORS;
    case 14:
    case "HEALTHCARE":
      return JobCategory.HEALTHCARE;
    case 15:
    case "HUMAN_RESOURCES":
      return JobCategory.HUMAN_RESOURCES;
    case 16:
    case "INSTALLATION_MAINTENANCE_AND_REPAIR":
      return JobCategory.INSTALLATION_MAINTENANCE_AND_REPAIR;
    case 17:
    case "LEGAL":
      return JobCategory.LEGAL;
    case 18:
    case "MANAGEMENT":
      return JobCategory.MANAGEMENT;
    case 19:
    case "MANUFACTURING_AND_WAREHOUSE":
      return JobCategory.MANUFACTURING_AND_WAREHOUSE;
    case 20:
    case "MEDIA_COMMUNICATIONS_AND_WRITING":
      return JobCategory.MEDIA_COMMUNICATIONS_AND_WRITING;
    case 21:
    case "OIL_GAS_AND_MINING":
      return JobCategory.OIL_GAS_AND_MINING;
    case 22:
    case "PERSONAL_CARE_AND_SERVICES":
      return JobCategory.PERSONAL_CARE_AND_SERVICES;
    case 23:
    case "PROTECTIVE_SERVICES":
      return JobCategory.PROTECTIVE_SERVICES;
    case 24:
    case "REAL_ESTATE":
      return JobCategory.REAL_ESTATE;
    case 25:
    case "RESTAURANT_AND_HOSPITALITY":
      return JobCategory.RESTAURANT_AND_HOSPITALITY;
    case 26:
    case "SALES_AND_RETAIL":
      return JobCategory.SALES_AND_RETAIL;
    case 27:
    case "SCIENCE_AND_ENGINEERING":
      return JobCategory.SCIENCE_AND_ENGINEERING;
    case 28:
    case "SOCIAL_SERVICES_AND_NON_PROFIT":
      return JobCategory.SOCIAL_SERVICES_AND_NON_PROFIT;
    case 29:
    case "SPORTS_FITNESS_AND_RECREATION":
      return JobCategory.SPORTS_FITNESS_AND_RECREATION;
    case 30:
    case "TRANSPORTATION_AND_LOGISTICS":
      return JobCategory.TRANSPORTATION_AND_LOGISTICS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobCategory.UNRECOGNIZED;
  }
}

export function jobCategoryToJSON(object: JobCategory): string {
  switch (object) {
    case JobCategory.JOB_CATEGORY_UNSPECIFIED:
      return "JOB_CATEGORY_UNSPECIFIED";
    case JobCategory.ACCOUNTING_AND_FINANCE:
      return "ACCOUNTING_AND_FINANCE";
    case JobCategory.ADMINISTRATIVE_AND_OFFICE:
      return "ADMINISTRATIVE_AND_OFFICE";
    case JobCategory.ADVERTISING_AND_MARKETING:
      return "ADVERTISING_AND_MARKETING";
    case JobCategory.ANIMAL_CARE:
      return "ANIMAL_CARE";
    case JobCategory.ART_FASHION_AND_DESIGN:
      return "ART_FASHION_AND_DESIGN";
    case JobCategory.BUSINESS_OPERATIONS:
      return "BUSINESS_OPERATIONS";
    case JobCategory.CLEANING_AND_FACILITIES:
      return "CLEANING_AND_FACILITIES";
    case JobCategory.COMPUTER_AND_IT:
      return "COMPUTER_AND_IT";
    case JobCategory.CONSTRUCTION:
      return "CONSTRUCTION";
    case JobCategory.CUSTOMER_SERVICE:
      return "CUSTOMER_SERVICE";
    case JobCategory.EDUCATION:
      return "EDUCATION";
    case JobCategory.ENTERTAINMENT_AND_TRAVEL:
      return "ENTERTAINMENT_AND_TRAVEL";
    case JobCategory.FARMING_AND_OUTDOORS:
      return "FARMING_AND_OUTDOORS";
    case JobCategory.HEALTHCARE:
      return "HEALTHCARE";
    case JobCategory.HUMAN_RESOURCES:
      return "HUMAN_RESOURCES";
    case JobCategory.INSTALLATION_MAINTENANCE_AND_REPAIR:
      return "INSTALLATION_MAINTENANCE_AND_REPAIR";
    case JobCategory.LEGAL:
      return "LEGAL";
    case JobCategory.MANAGEMENT:
      return "MANAGEMENT";
    case JobCategory.MANUFACTURING_AND_WAREHOUSE:
      return "MANUFACTURING_AND_WAREHOUSE";
    case JobCategory.MEDIA_COMMUNICATIONS_AND_WRITING:
      return "MEDIA_COMMUNICATIONS_AND_WRITING";
    case JobCategory.OIL_GAS_AND_MINING:
      return "OIL_GAS_AND_MINING";
    case JobCategory.PERSONAL_CARE_AND_SERVICES:
      return "PERSONAL_CARE_AND_SERVICES";
    case JobCategory.PROTECTIVE_SERVICES:
      return "PROTECTIVE_SERVICES";
    case JobCategory.REAL_ESTATE:
      return "REAL_ESTATE";
    case JobCategory.RESTAURANT_AND_HOSPITALITY:
      return "RESTAURANT_AND_HOSPITALITY";
    case JobCategory.SALES_AND_RETAIL:
      return "SALES_AND_RETAIL";
    case JobCategory.SCIENCE_AND_ENGINEERING:
      return "SCIENCE_AND_ENGINEERING";
    case JobCategory.SOCIAL_SERVICES_AND_NON_PROFIT:
      return "SOCIAL_SERVICES_AND_NON_PROFIT";
    case JobCategory.SPORTS_FITNESS_AND_RECREATION:
      return "SPORTS_FITNESS_AND_RECREATION";
    case JobCategory.TRANSPORTATION_AND_LOGISTICS:
      return "TRANSPORTATION_AND_LOGISTICS";
    case JobCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An enum that represents the job posting region. In most cases, job postings
 * don't need to specify a region. If a region is given, jobs are
 * eligible for searches in the specified region.
 */
export enum PostingRegion {
  /**
   * POSTING_REGION_UNSPECIFIED - If the region is unspecified, the job is only returned if it
   * matches the [LocationFilter][google.cloud.talent.v4beta1.LocationFilter].
   */
  POSTING_REGION_UNSPECIFIED = 0,
  /**
   * ADMINISTRATIVE_AREA - In addition to exact location matching, job posting is returned when the
   * [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] in the search
   * query is in the same administrative area as the returned job posting. For
   * example, if a `ADMINISTRATIVE_AREA` job is posted in "CA, USA", it's
   * returned if [LocationFilter][google.cloud.talent.v4beta1.LocationFilter]
   * has "Mountain View".
   *
   * Administrative area refers to top-level administrative subdivision of this
   * country. For example, US state, IT region, UK constituent nation and
   * JP prefecture.
   */
  ADMINISTRATIVE_AREA = 1,
  /**
   * NATION - In addition to exact location matching, job is returned when
   * [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] in search
   * query is in the same country as this job. For example, if a `NATION_WIDE`
   * job is posted in "USA", it's returned if
   * [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] has 'Mountain
   * View'.
   */
  NATION = 2,
  /**
   * TELECOMMUTE - Job allows employees to work remotely (telecommute).
   * If locations are provided with this value, the job is
   * considered as having a location, but telecommuting is allowed.
   */
  TELECOMMUTE = 3,
  UNRECOGNIZED = -1,
}

export function postingRegionFromJSON(object: any): PostingRegion {
  switch (object) {
    case 0:
    case "POSTING_REGION_UNSPECIFIED":
      return PostingRegion.POSTING_REGION_UNSPECIFIED;
    case 1:
    case "ADMINISTRATIVE_AREA":
      return PostingRegion.ADMINISTRATIVE_AREA;
    case 2:
    case "NATION":
      return PostingRegion.NATION;
    case 3:
    case "TELECOMMUTE":
      return PostingRegion.TELECOMMUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PostingRegion.UNRECOGNIZED;
  }
}

export function postingRegionToJSON(object: PostingRegion): string {
  switch (object) {
    case PostingRegion.POSTING_REGION_UNSPECIFIED:
      return "POSTING_REGION_UNSPECIFIED";
    case PostingRegion.ADMINISTRATIVE_AREA:
      return "ADMINISTRATIVE_AREA";
    case PostingRegion.NATION:
      return "NATION";
    case PostingRegion.TELECOMMUTE:
      return "TELECOMMUTE";
    case PostingRegion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Deprecated. All resources are only visible to the owner.
 *
 * An enum that represents who has view access to the resource.
 *
 * @deprecated
 */
export enum Visibility {
  /** VISIBILITY_UNSPECIFIED - Default value. */
  VISIBILITY_UNSPECIFIED = 0,
  /** ACCOUNT_ONLY - The resource is only visible to the GCP account who owns it. */
  ACCOUNT_ONLY = 1,
  /**
   * SHARED_WITH_GOOGLE - The resource is visible to the owner and may be visible to other
   * applications and processes at Google.
   */
  SHARED_WITH_GOOGLE = 2,
  /**
   * SHARED_WITH_PUBLIC - The resource is visible to the owner and may be visible to all other API
   * clients.
   */
  SHARED_WITH_PUBLIC = 3,
  UNRECOGNIZED = -1,
}

export function visibilityFromJSON(object: any): Visibility {
  switch (object) {
    case 0:
    case "VISIBILITY_UNSPECIFIED":
      return Visibility.VISIBILITY_UNSPECIFIED;
    case 1:
    case "ACCOUNT_ONLY":
      return Visibility.ACCOUNT_ONLY;
    case 2:
    case "SHARED_WITH_GOOGLE":
      return Visibility.SHARED_WITH_GOOGLE;
    case 3:
    case "SHARED_WITH_PUBLIC":
      return Visibility.SHARED_WITH_PUBLIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Visibility.UNRECOGNIZED;
  }
}

export function visibilityToJSON(object: Visibility): string {
  switch (object) {
    case Visibility.VISIBILITY_UNSPECIFIED:
      return "VISIBILITY_UNSPECIFIED";
    case Visibility.ACCOUNT_ONLY:
      return "ACCOUNT_ONLY";
    case Visibility.SHARED_WITH_GOOGLE:
      return "SHARED_WITH_GOOGLE";
    case Visibility.SHARED_WITH_PUBLIC:
      return "SHARED_WITH_PUBLIC";
    case Visibility.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Option for HTML content sanitization on user input fields, for example, job
 * description. By setting this option, user can determine whether and how
 * sanitization is performed on these fields.
 */
export enum HtmlSanitization {
  /** HTML_SANITIZATION_UNSPECIFIED - Default value. */
  HTML_SANITIZATION_UNSPECIFIED = 0,
  /** HTML_SANITIZATION_DISABLED - Disables sanitization on HTML input. */
  HTML_SANITIZATION_DISABLED = 1,
  /**
   * SIMPLE_FORMATTING_ONLY - Sanitizes HTML input, only accepts bold, italic, ordered list, and
   * unordered list markup tags.
   */
  SIMPLE_FORMATTING_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function htmlSanitizationFromJSON(object: any): HtmlSanitization {
  switch (object) {
    case 0:
    case "HTML_SANITIZATION_UNSPECIFIED":
      return HtmlSanitization.HTML_SANITIZATION_UNSPECIFIED;
    case 1:
    case "HTML_SANITIZATION_DISABLED":
      return HtmlSanitization.HTML_SANITIZATION_DISABLED;
    case 2:
    case "SIMPLE_FORMATTING_ONLY":
      return HtmlSanitization.SIMPLE_FORMATTING_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HtmlSanitization.UNRECOGNIZED;
  }
}

export function htmlSanitizationToJSON(object: HtmlSanitization): string {
  switch (object) {
    case HtmlSanitization.HTML_SANITIZATION_UNSPECIFIED:
      return "HTML_SANITIZATION_UNSPECIFIED";
    case HtmlSanitization.HTML_SANITIZATION_DISABLED:
      return "HTML_SANITIZATION_DISABLED";
    case HtmlSanitization.SIMPLE_FORMATTING_ONLY:
      return "SIMPLE_FORMATTING_ONLY";
    case HtmlSanitization.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Method for commute. */
export enum CommuteMethod {
  /** COMMUTE_METHOD_UNSPECIFIED - Commute method isn't specified. */
  COMMUTE_METHOD_UNSPECIFIED = 0,
  /** DRIVING - Commute time is calculated based on driving time. */
  DRIVING = 1,
  /**
   * TRANSIT - Commute time is calculated based on public transit including bus, metro,
   * subway, and so on.
   */
  TRANSIT = 2,
  /** WALKING - Commute time is calculated based on walking time. */
  WALKING = 3,
  /** CYCLING - Commute time is calculated based on biking time. */
  CYCLING = 4,
  UNRECOGNIZED = -1,
}

export function commuteMethodFromJSON(object: any): CommuteMethod {
  switch (object) {
    case 0:
    case "COMMUTE_METHOD_UNSPECIFIED":
      return CommuteMethod.COMMUTE_METHOD_UNSPECIFIED;
    case 1:
    case "DRIVING":
      return CommuteMethod.DRIVING;
    case 2:
    case "TRANSIT":
      return CommuteMethod.TRANSIT;
    case 3:
    case "WALKING":
      return CommuteMethod.WALKING;
    case 4:
    case "CYCLING":
      return CommuteMethod.CYCLING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommuteMethod.UNRECOGNIZED;
  }
}

export function commuteMethodToJSON(object: CommuteMethod): string {
  switch (object) {
    case CommuteMethod.COMMUTE_METHOD_UNSPECIFIED:
      return "COMMUTE_METHOD_UNSPECIFIED";
    case CommuteMethod.DRIVING:
      return "DRIVING";
    case CommuteMethod.TRANSIT:
      return "TRANSIT";
    case CommuteMethod.WALKING:
      return "WALKING";
    case CommuteMethod.CYCLING:
      return "CYCLING";
    case CommuteMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message representing a period of time between two timestamps. */
export interface TimestampRange {
  /** Begin of the period (inclusive). */
  startTime:
    | Date
    | undefined;
  /** End of the period (exclusive). */
  endTime: Date | undefined;
}

/** A resource that represents a location with full geographic information. */
export interface Location {
  /**
   * The type of a location, which corresponds to the address lines field of
   * [google.type.PostalAddress][google.type.PostalAddress]. For example,
   * "Downtown, Atlanta, GA, USA" has a type of
   * [LocationType.NEIGHBORHOOD][google.cloud.talent.v4beta1.Location.LocationType.NEIGHBORHOOD],
   * and "Kansas City, KS, USA" has a type of
   * [LocationType.LOCALITY][google.cloud.talent.v4beta1.Location.LocationType.LOCALITY].
   */
  locationType: Location_LocationType;
  /**
   * Postal address of the location that includes human readable information,
   * such as postal delivery and payments addresses. Given a postal address,
   * a postal service can deliver items to a premises, P.O. Box, or other
   * delivery location.
   */
  postalAddress:
    | PostalAddress
    | undefined;
  /** An object representing a latitude/longitude pair. */
  latLng:
    | LatLng
    | undefined;
  /**
   * Radius in miles of the job location. This value is derived from the
   * location bounding box in which a circle with the specified radius
   * centered from [google.type.LatLng][google.type.LatLng] covers the area
   * associated with the job location. For example, currently, "Mountain View,
   * CA, USA" has a radius of 6.17 miles.
   */
  radiusMiles: number;
}

/** An enum which represents the type of a location. */
export enum Location_LocationType {
  /** LOCATION_TYPE_UNSPECIFIED - Default value if the type isn't specified. */
  LOCATION_TYPE_UNSPECIFIED = 0,
  /** COUNTRY - A country level location. */
  COUNTRY = 1,
  /** ADMINISTRATIVE_AREA - A state or equivalent level location. */
  ADMINISTRATIVE_AREA = 2,
  /** SUB_ADMINISTRATIVE_AREA - A county or equivalent level location. */
  SUB_ADMINISTRATIVE_AREA = 3,
  /** LOCALITY - A city or equivalent level location. */
  LOCALITY = 4,
  /** POSTAL_CODE - A postal code level location. */
  POSTAL_CODE = 5,
  /**
   * SUB_LOCALITY - A sublocality is a subdivision of a locality, for example a city borough,
   * ward, or arrondissement. Sublocalities are usually recognized by a local
   * political authority. For example, Manhattan and Brooklyn are recognized
   * as boroughs by the City of New York, and are therefore modeled as
   * sublocalities.
   */
  SUB_LOCALITY = 6,
  /** SUB_LOCALITY_1 - A district or equivalent level location. */
  SUB_LOCALITY_1 = 7,
  /** SUB_LOCALITY_2 - A smaller district or equivalent level display. */
  SUB_LOCALITY_2 = 8,
  /** NEIGHBORHOOD - A neighborhood level location. */
  NEIGHBORHOOD = 9,
  /** STREET_ADDRESS - A street address level location. */
  STREET_ADDRESS = 10,
  UNRECOGNIZED = -1,
}

export function location_LocationTypeFromJSON(object: any): Location_LocationType {
  switch (object) {
    case 0:
    case "LOCATION_TYPE_UNSPECIFIED":
      return Location_LocationType.LOCATION_TYPE_UNSPECIFIED;
    case 1:
    case "COUNTRY":
      return Location_LocationType.COUNTRY;
    case 2:
    case "ADMINISTRATIVE_AREA":
      return Location_LocationType.ADMINISTRATIVE_AREA;
    case 3:
    case "SUB_ADMINISTRATIVE_AREA":
      return Location_LocationType.SUB_ADMINISTRATIVE_AREA;
    case 4:
    case "LOCALITY":
      return Location_LocationType.LOCALITY;
    case 5:
    case "POSTAL_CODE":
      return Location_LocationType.POSTAL_CODE;
    case 6:
    case "SUB_LOCALITY":
      return Location_LocationType.SUB_LOCALITY;
    case 7:
    case "SUB_LOCALITY_1":
      return Location_LocationType.SUB_LOCALITY_1;
    case 8:
    case "SUB_LOCALITY_2":
      return Location_LocationType.SUB_LOCALITY_2;
    case 9:
    case "NEIGHBORHOOD":
      return Location_LocationType.NEIGHBORHOOD;
    case 10:
    case "STREET_ADDRESS":
      return Location_LocationType.STREET_ADDRESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Location_LocationType.UNRECOGNIZED;
  }
}

export function location_LocationTypeToJSON(object: Location_LocationType): string {
  switch (object) {
    case Location_LocationType.LOCATION_TYPE_UNSPECIFIED:
      return "LOCATION_TYPE_UNSPECIFIED";
    case Location_LocationType.COUNTRY:
      return "COUNTRY";
    case Location_LocationType.ADMINISTRATIVE_AREA:
      return "ADMINISTRATIVE_AREA";
    case Location_LocationType.SUB_ADMINISTRATIVE_AREA:
      return "SUB_ADMINISTRATIVE_AREA";
    case Location_LocationType.LOCALITY:
      return "LOCALITY";
    case Location_LocationType.POSTAL_CODE:
      return "POSTAL_CODE";
    case Location_LocationType.SUB_LOCALITY:
      return "SUB_LOCALITY";
    case Location_LocationType.SUB_LOCALITY_1:
      return "SUB_LOCALITY_1";
    case Location_LocationType.SUB_LOCALITY_2:
      return "SUB_LOCALITY_2";
    case Location_LocationType.NEIGHBORHOOD:
      return "NEIGHBORHOOD";
    case Location_LocationType.STREET_ADDRESS:
      return "STREET_ADDRESS";
    case Location_LocationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Meta information related to the job searcher or entity
 * conducting the job search. This information is used to improve the
 * performance of the service.
 */
export interface RequestMetadata {
  /**
   * Required if
   * [allow_missing_ids][google.cloud.talent.v4beta1.RequestMetadata.allow_missing_ids]
   * is unset or `false`.
   *
   * The client-defined scope or source of the service call, which typically
   * is the domain on
   * which the service has been implemented and is currently being run.
   *
   * For example, if the service is being run by client <em>Foo, Inc.</em>, on
   * job board www.foo.com and career site www.bar.com, then this field is
   * set to "foo.com" for use on the job board, and "bar.com" for use on the
   * career site.
   *
   * Note that any improvements to the model for a particular tenant site rely
   * on this field being set correctly to a unique domain.
   *
   * The maximum number of allowed characters is 255.
   */
  domain: string;
  /**
   * Required if
   * [allow_missing_ids][google.cloud.talent.v4beta1.RequestMetadata.allow_missing_ids]
   * is unset or `false`.
   *
   * A unique session identification string. A session is defined as the
   * duration of an end user's interaction with the service over a certain
   * period.
   * Obfuscate this field for privacy concerns before
   * providing it to the service.
   *
   * Note that any improvements to the model for a particular tenant site rely
   * on this field being set correctly to a unique session ID.
   *
   * The maximum number of allowed characters is 255.
   */
  sessionId: string;
  /**
   * Required if
   * [allow_missing_ids][google.cloud.talent.v4beta1.RequestMetadata.allow_missing_ids]
   * is unset or `false`.
   *
   * A unique user identification string, as determined by the client.
   * To have the strongest positive impact on search quality
   * make sure the client-level is unique.
   * Obfuscate this field for privacy concerns before
   * providing it to the service.
   *
   * Note that any improvements to the model for a particular tenant site rely
   * on this field being set correctly to a unique user ID.
   *
   * The maximum number of allowed characters is 255.
   */
  userId: string;
  /**
   * Only set when any of
   * [domain][google.cloud.talent.v4beta1.RequestMetadata.domain],
   * [session_id][google.cloud.talent.v4beta1.RequestMetadata.session_id] and
   * [user_id][google.cloud.talent.v4beta1.RequestMetadata.user_id] isn't
   * available for some reason. It is highly recommended not to set this field
   * and provide accurate
   * [domain][google.cloud.talent.v4beta1.RequestMetadata.domain],
   * [session_id][google.cloud.talent.v4beta1.RequestMetadata.session_id] and
   * [user_id][google.cloud.talent.v4beta1.RequestMetadata.user_id] for the best
   * service experience.
   */
  allowMissingIds: boolean;
  /**
   * The type of device used by the job seeker at the time of the call to the
   * service.
   */
  deviceInfo: DeviceInfo | undefined;
}

/** Additional information returned to client, such as debugging information. */
export interface ResponseMetadata {
  /**
   * A unique id associated with this call.
   * This id is logged for tracking purposes.
   */
  requestId: string;
}

/**
 * Device information collected from the job seeker, candidate, or
 * other entity conducting the job search. Providing this information improves
 * the quality of the search results across devices.
 */
export interface DeviceInfo {
  /** Type of the device. */
  deviceType: DeviceInfo_DeviceType;
  /**
   * A device-specific ID. The ID must be a unique identifier that
   * distinguishes the device from other devices.
   */
  id: string;
}

/** An enumeration describing an API access portal and exposure mechanism. */
export enum DeviceInfo_DeviceType {
  /** DEVICE_TYPE_UNSPECIFIED - The device type isn't specified. */
  DEVICE_TYPE_UNSPECIFIED = 0,
  /**
   * WEB - A desktop web browser, such as, Chrome, Firefox, Safari, or Internet
   * Explorer)
   */
  WEB = 1,
  /**
   * MOBILE_WEB - A mobile device web browser, such as a phone or tablet with a Chrome
   * browser.
   */
  MOBILE_WEB = 2,
  /** ANDROID - An Android device native application. */
  ANDROID = 3,
  /** IOS - An iOS device native application. */
  IOS = 4,
  /**
   * BOT - A bot, as opposed to a device operated by human beings, such as a web
   * crawler.
   */
  BOT = 5,
  /** OTHER - Other devices types. */
  OTHER = 6,
  UNRECOGNIZED = -1,
}

export function deviceInfo_DeviceTypeFromJSON(object: any): DeviceInfo_DeviceType {
  switch (object) {
    case 0:
    case "DEVICE_TYPE_UNSPECIFIED":
      return DeviceInfo_DeviceType.DEVICE_TYPE_UNSPECIFIED;
    case 1:
    case "WEB":
      return DeviceInfo_DeviceType.WEB;
    case 2:
    case "MOBILE_WEB":
      return DeviceInfo_DeviceType.MOBILE_WEB;
    case 3:
    case "ANDROID":
      return DeviceInfo_DeviceType.ANDROID;
    case 4:
    case "IOS":
      return DeviceInfo_DeviceType.IOS;
    case 5:
    case "BOT":
      return DeviceInfo_DeviceType.BOT;
    case 6:
    case "OTHER":
      return DeviceInfo_DeviceType.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeviceInfo_DeviceType.UNRECOGNIZED;
  }
}

export function deviceInfo_DeviceTypeToJSON(object: DeviceInfo_DeviceType): string {
  switch (object) {
    case DeviceInfo_DeviceType.DEVICE_TYPE_UNSPECIFIED:
      return "DEVICE_TYPE_UNSPECIFIED";
    case DeviceInfo_DeviceType.WEB:
      return "WEB";
    case DeviceInfo_DeviceType.MOBILE_WEB:
      return "MOBILE_WEB";
    case DeviceInfo_DeviceType.ANDROID:
      return "ANDROID";
    case DeviceInfo_DeviceType.IOS:
      return "IOS";
    case DeviceInfo_DeviceType.BOT:
      return "BOT";
    case DeviceInfo_DeviceType.OTHER:
      return "OTHER";
    case DeviceInfo_DeviceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Custom attribute values that are either filterable or non-filterable. */
export interface CustomAttribute {
  /**
   * Exactly one of
   * [string_values][google.cloud.talent.v4beta1.CustomAttribute.string_values]
   * or [long_values][google.cloud.talent.v4beta1.CustomAttribute.long_values]
   * must be specified.
   *
   * This field is used to perform a string match (`CASE_SENSITIVE_MATCH` or
   * `CASE_INSENSITIVE_MATCH`) search.
   * For filterable `string_value`s, a maximum total number of 200 values
   * is allowed, with each `string_value` has a byte size of no more than
   * 500B. For unfilterable `string_values`, the maximum total byte size of
   * unfilterable `string_values` is 50KB.
   *
   * Empty string isn't allowed.
   */
  stringValues: string[];
  /**
   * Exactly one of
   * [string_values][google.cloud.talent.v4beta1.CustomAttribute.string_values]
   * or [long_values][google.cloud.talent.v4beta1.CustomAttribute.long_values]
   * must be specified.
   *
   * This field is used to perform number range search.
   * (`EQ`, `GT`, `GE`, `LE`, `LT`) over filterable `long_value`.
   *
   * Currently at most 1
   * [long_values][google.cloud.talent.v4beta1.CustomAttribute.long_values] is
   * supported.
   */
  longValues: Long[];
  /**
   * If the `filterable` flag is true, the custom field values may be used for
   * custom attribute filters
   * [JobQuery.custom_attribute_filter][google.cloud.talent.v4beta1.JobQuery.custom_attribute_filter].
   * If false, these values may not be used for custom attribute filters.
   *
   * Default is false.
   */
  filterable: boolean;
  /**
   * If the `keyword_searchable` flag is true, the keywords in custom fields are
   * searchable by keyword match.
   * If false, the values are not searchable by keyword match.
   *
   * Default is false.
   */
  keywordSearchable: boolean;
}

/** Spell check result. */
export interface SpellingCorrection {
  /** Indicates if the query was corrected by the spell checker. */
  corrected: boolean;
  /** Correction output consisting of the corrected keyword string. */
  correctedText: string;
  /**
   * Corrected output with html tags to highlight the corrected words.
   * Corrected words are called out with the "<b><i>...</i></b>" html tags.
   *
   * For example, the user input query is "software enginear", where the second
   * word, "enginear," is incorrect. It should be "engineer". When spelling
   * correction is enabled, this value is
   * "software <b><i>engineer</i></b>".
   */
  correctedHtml: string;
}

/** Job compensation details. */
export interface CompensationInfo {
  /**
   * Job compensation information.
   *
   * At most one entry can be of type
   * [CompensationInfo.CompensationType.BASE][google.cloud.talent.v4beta1.CompensationInfo.CompensationType.BASE],
   * which is referred as **base compensation entry** for the job.
   */
  entries: CompensationInfo_CompensationEntry[];
  /**
   * Output only. Annualized base compensation range. Computed as base
   * compensation entry's
   * [CompensationEntry.amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
   * times
   * [CompensationEntry.expected_units_per_year][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.expected_units_per_year].
   *
   * See
   * [CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry]
   * for explanation on compensation annualization.
   */
  annualizedBaseCompensationRange:
    | CompensationInfo_CompensationRange
    | undefined;
  /**
   * Output only. Annualized total compensation range. Computed as all
   * compensation entries'
   * [CompensationEntry.amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
   * times
   * [CompensationEntry.expected_units_per_year][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.expected_units_per_year].
   *
   * See
   * [CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry]
   * for explanation on compensation annualization.
   */
  annualizedTotalCompensationRange: CompensationInfo_CompensationRange | undefined;
}

/**
 * The type of compensation.
 *
 * For compensation amounts specified in non-monetary amounts,
 * describe the compensation scheme in the
 * [CompensationEntry.description][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.description].
 *
 * For example, tipping format is described in
 * [CompensationEntry.description][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.description]
 * (for example, "expect 15-20% tips based on customer bill.") and an estimate
 * of the tips provided in
 * [CompensationEntry.amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
 * or
 * [CompensationEntry.range][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.range]
 * ($10 per hour).
 *
 * For example, equity is described in
 * [CompensationEntry.description][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.description]
 * (for example, "1% - 2% equity vesting over 4 years, 1 year cliff") and
 * value estimated in
 * [CompensationEntry.amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
 * or
 * [CompensationEntry.range][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.range].
 * If no value estimate is possible, units are
 * [CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED]
 * and then further clarified in
 * [CompensationEntry.description][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.description]
 * field.
 */
export enum CompensationInfo_CompensationType {
  /** COMPENSATION_TYPE_UNSPECIFIED - Default value. */
  COMPENSATION_TYPE_UNSPECIFIED = 0,
  /**
   * BASE - Base compensation: Refers to the fixed amount of money paid to an
   * employee by an employer in return for work performed. Base compensation
   * does not include benefits, bonuses or any other potential compensation
   * from an employer.
   */
  BASE = 1,
  /** BONUS - Bonus. */
  BONUS = 2,
  /** SIGNING_BONUS - Signing bonus. */
  SIGNING_BONUS = 3,
  /** EQUITY - Equity. */
  EQUITY = 4,
  /** PROFIT_SHARING - Profit sharing. */
  PROFIT_SHARING = 5,
  /** COMMISSIONS - Commission. */
  COMMISSIONS = 6,
  /** TIPS - Tips. */
  TIPS = 7,
  /** OTHER_COMPENSATION_TYPE - Other compensation type. */
  OTHER_COMPENSATION_TYPE = 8,
  UNRECOGNIZED = -1,
}

export function compensationInfo_CompensationTypeFromJSON(object: any): CompensationInfo_CompensationType {
  switch (object) {
    case 0:
    case "COMPENSATION_TYPE_UNSPECIFIED":
      return CompensationInfo_CompensationType.COMPENSATION_TYPE_UNSPECIFIED;
    case 1:
    case "BASE":
      return CompensationInfo_CompensationType.BASE;
    case 2:
    case "BONUS":
      return CompensationInfo_CompensationType.BONUS;
    case 3:
    case "SIGNING_BONUS":
      return CompensationInfo_CompensationType.SIGNING_BONUS;
    case 4:
    case "EQUITY":
      return CompensationInfo_CompensationType.EQUITY;
    case 5:
    case "PROFIT_SHARING":
      return CompensationInfo_CompensationType.PROFIT_SHARING;
    case 6:
    case "COMMISSIONS":
      return CompensationInfo_CompensationType.COMMISSIONS;
    case 7:
    case "TIPS":
      return CompensationInfo_CompensationType.TIPS;
    case 8:
    case "OTHER_COMPENSATION_TYPE":
      return CompensationInfo_CompensationType.OTHER_COMPENSATION_TYPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompensationInfo_CompensationType.UNRECOGNIZED;
  }
}

export function compensationInfo_CompensationTypeToJSON(object: CompensationInfo_CompensationType): string {
  switch (object) {
    case CompensationInfo_CompensationType.COMPENSATION_TYPE_UNSPECIFIED:
      return "COMPENSATION_TYPE_UNSPECIFIED";
    case CompensationInfo_CompensationType.BASE:
      return "BASE";
    case CompensationInfo_CompensationType.BONUS:
      return "BONUS";
    case CompensationInfo_CompensationType.SIGNING_BONUS:
      return "SIGNING_BONUS";
    case CompensationInfo_CompensationType.EQUITY:
      return "EQUITY";
    case CompensationInfo_CompensationType.PROFIT_SHARING:
      return "PROFIT_SHARING";
    case CompensationInfo_CompensationType.COMMISSIONS:
      return "COMMISSIONS";
    case CompensationInfo_CompensationType.TIPS:
      return "TIPS";
    case CompensationInfo_CompensationType.OTHER_COMPENSATION_TYPE:
      return "OTHER_COMPENSATION_TYPE";
    case CompensationInfo_CompensationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Pay frequency. */
export enum CompensationInfo_CompensationUnit {
  /** COMPENSATION_UNIT_UNSPECIFIED - Default value. */
  COMPENSATION_UNIT_UNSPECIFIED = 0,
  /** HOURLY - Hourly. */
  HOURLY = 1,
  /** DAILY - Daily. */
  DAILY = 2,
  /** WEEKLY - Weekly */
  WEEKLY = 3,
  /** MONTHLY - Monthly. */
  MONTHLY = 4,
  /** YEARLY - Yearly. */
  YEARLY = 5,
  /** ONE_TIME - One time. */
  ONE_TIME = 6,
  /** OTHER_COMPENSATION_UNIT - Other compensation units. */
  OTHER_COMPENSATION_UNIT = 7,
  UNRECOGNIZED = -1,
}

export function compensationInfo_CompensationUnitFromJSON(object: any): CompensationInfo_CompensationUnit {
  switch (object) {
    case 0:
    case "COMPENSATION_UNIT_UNSPECIFIED":
      return CompensationInfo_CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED;
    case 1:
    case "HOURLY":
      return CompensationInfo_CompensationUnit.HOURLY;
    case 2:
    case "DAILY":
      return CompensationInfo_CompensationUnit.DAILY;
    case 3:
    case "WEEKLY":
      return CompensationInfo_CompensationUnit.WEEKLY;
    case 4:
    case "MONTHLY":
      return CompensationInfo_CompensationUnit.MONTHLY;
    case 5:
    case "YEARLY":
      return CompensationInfo_CompensationUnit.YEARLY;
    case 6:
    case "ONE_TIME":
      return CompensationInfo_CompensationUnit.ONE_TIME;
    case 7:
    case "OTHER_COMPENSATION_UNIT":
      return CompensationInfo_CompensationUnit.OTHER_COMPENSATION_UNIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompensationInfo_CompensationUnit.UNRECOGNIZED;
  }
}

export function compensationInfo_CompensationUnitToJSON(object: CompensationInfo_CompensationUnit): string {
  switch (object) {
    case CompensationInfo_CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED:
      return "COMPENSATION_UNIT_UNSPECIFIED";
    case CompensationInfo_CompensationUnit.HOURLY:
      return "HOURLY";
    case CompensationInfo_CompensationUnit.DAILY:
      return "DAILY";
    case CompensationInfo_CompensationUnit.WEEKLY:
      return "WEEKLY";
    case CompensationInfo_CompensationUnit.MONTHLY:
      return "MONTHLY";
    case CompensationInfo_CompensationUnit.YEARLY:
      return "YEARLY";
    case CompensationInfo_CompensationUnit.ONE_TIME:
      return "ONE_TIME";
    case CompensationInfo_CompensationUnit.OTHER_COMPENSATION_UNIT:
      return "OTHER_COMPENSATION_UNIT";
    case CompensationInfo_CompensationUnit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A compensation entry that represents one component of compensation, such
 * as base pay, bonus, or other compensation type.
 *
 * Annualization: One compensation entry can be annualized if
 * - it contains valid
 * [amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
 * or
 * [range][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.range].
 * - and its
 * [expected_units_per_year][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.expected_units_per_year]
 * is set or can be derived. Its annualized range is determined as
 * ([amount][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.amount]
 * or
 * [range][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.range])
 * times
 * [expected_units_per_year][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.expected_units_per_year].
 */
export interface CompensationInfo_CompensationEntry {
  /**
   * Compensation type.
   *
   * Default is
   * [CompensationType.COMPENSATION_TYPE_UNSPECIFIED][google.cloud.talent.v4beta1.CompensationInfo.CompensationType.COMPENSATION_TYPE_UNSPECIFIED].
   */
  type: CompensationInfo_CompensationType;
  /**
   * Frequency of the specified amount.
   *
   * Default is
   * [CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit.COMPENSATION_UNIT_UNSPECIFIED].
   */
  unit: CompensationInfo_CompensationUnit;
  /** Compensation amount. */
  amount?:
    | Money
    | undefined;
  /** Compensation range. */
  range?:
    | CompensationInfo_CompensationRange
    | undefined;
  /**
   * Compensation description.  For example, could
   * indicate equity terms or provide additional context to an estimated
   * bonus.
   */
  description: string;
  /**
   * Expected number of units paid each year. If not specified, when
   * [Job.employment_types][google.cloud.talent.v4beta1.Job.employment_types]
   * is FULLTIME, a default value is inferred based on
   * [unit][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry.unit].
   * Default values:
   * - HOURLY: 2080
   * - DAILY: 260
   * - WEEKLY: 52
   * - MONTHLY: 12
   * - ANNUAL: 1
   */
  expectedUnitsPerYear: number | undefined;
}

/** Compensation range. */
export interface CompensationInfo_CompensationRange {
  /**
   * The maximum amount of compensation. If left empty, the value is set
   * to a maximal compensation value and the currency code is set to
   * match the [currency code][google.type.Money.currency_code] of
   * min_compensation.
   */
  maxCompensation:
    | Money
    | undefined;
  /**
   * The minimum amount of compensation. If left empty, the value is set
   * to zero and the currency code is set to match the
   * [currency code][google.type.Money.currency_code] of max_compensation.
   */
  minCompensation: Money | undefined;
}

/**
 * Metadata used for long running operations returned by CTS batch APIs.
 * It's used to replace
 * [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata].
 */
export interface BatchOperationMetadata {
  /** The state of a long running operation. */
  state: BatchOperationMetadata_State;
  /** More detailed information about operation state. */
  stateDescription: string;
  /** Count of successful item(s) inside an operation. */
  successCount: number;
  /** Count of failed item(s) inside an operation. */
  failureCount: number;
  /** Count of total item(s) inside an operation. */
  totalCount: number;
  /** The time when the batch operation is created. */
  createTime:
    | Date
    | undefined;
  /**
   * The time when the batch operation status is updated. The metadata and the
   * [update_time][google.cloud.talent.v4beta1.BatchOperationMetadata.update_time]
   * is refreshed every minute otherwise cached data is returned.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * The time when the batch operation is finished and
   * [google.longrunning.Operation.done][google.longrunning.Operation.done] is
   * set to `true`.
   */
  endTime: Date | undefined;
}

export enum BatchOperationMetadata_State {
  /** STATE_UNSPECIFIED - Default value. */
  STATE_UNSPECIFIED = 0,
  /** INITIALIZING - The batch operation is being prepared for processing. */
  INITIALIZING = 1,
  /** PROCESSING - The batch operation is actively being processed. */
  PROCESSING = 2,
  /**
   * SUCCEEDED - The batch operation is processed, and at least one item has been
   * successfully processed.
   */
  SUCCEEDED = 3,
  /** FAILED - The batch operation is done and no item has been successfully processed. */
  FAILED = 4,
  /**
   * CANCELLING - The batch operation is in the process of cancelling after
   * [google.longrunning.Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
   * is called.
   */
  CANCELLING = 5,
  /**
   * CANCELLED - The batch operation is done after
   * [google.longrunning.Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
   * is called. Any items processed before cancelling are returned in the
   * response.
   */
  CANCELLED = 6,
  UNRECOGNIZED = -1,
}

export function batchOperationMetadata_StateFromJSON(object: any): BatchOperationMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BatchOperationMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "INITIALIZING":
      return BatchOperationMetadata_State.INITIALIZING;
    case 2:
    case "PROCESSING":
      return BatchOperationMetadata_State.PROCESSING;
    case 3:
    case "SUCCEEDED":
      return BatchOperationMetadata_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return BatchOperationMetadata_State.FAILED;
    case 5:
    case "CANCELLING":
      return BatchOperationMetadata_State.CANCELLING;
    case 6:
    case "CANCELLED":
      return BatchOperationMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchOperationMetadata_State.UNRECOGNIZED;
  }
}

export function batchOperationMetadata_StateToJSON(object: BatchOperationMetadata_State): string {
  switch (object) {
    case BatchOperationMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BatchOperationMetadata_State.INITIALIZING:
      return "INITIALIZING";
    case BatchOperationMetadata_State.PROCESSING:
      return "PROCESSING";
    case BatchOperationMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case BatchOperationMetadata_State.FAILED:
      return "FAILED";
    case BatchOperationMetadata_State.CANCELLING:
      return "CANCELLING";
    case BatchOperationMetadata_State.CANCELLED:
      return "CANCELLED";
    case BatchOperationMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseTimestampRange(): TimestampRange {
  return { startTime: undefined, endTime: undefined };
}

export const TimestampRange: MessageFns<TimestampRange> = {
  encode(message: TimestampRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampRange {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimestampRange): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampRange>): TimestampRange {
    return TimestampRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampRange>): TimestampRange {
    const message = createBaseTimestampRange();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseLocation(): Location {
  return { locationType: 0, postalAddress: undefined, latLng: undefined, radiusMiles: 0 };
}

export const Location: MessageFns<Location> = {
  encode(message: Location, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locationType !== 0) {
      writer.uint32(8).int32(message.locationType);
    }
    if (message.postalAddress !== undefined) {
      PostalAddress.encode(message.postalAddress, writer.uint32(18).fork()).join();
    }
    if (message.latLng !== undefined) {
      LatLng.encode(message.latLng, writer.uint32(26).fork()).join();
    }
    if (message.radiusMiles !== 0) {
      writer.uint32(33).double(message.radiusMiles);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Location {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.locationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.postalAddress = PostalAddress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latLng = LatLng.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.radiusMiles = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Location {
    return {
      locationType: isSet(object.locationType) ? location_LocationTypeFromJSON(object.locationType) : 0,
      postalAddress: isSet(object.postalAddress) ? PostalAddress.fromJSON(object.postalAddress) : undefined,
      latLng: isSet(object.latLng) ? LatLng.fromJSON(object.latLng) : undefined,
      radiusMiles: isSet(object.radiusMiles) ? globalThis.Number(object.radiusMiles) : 0,
    };
  },

  toJSON(message: Location): unknown {
    const obj: any = {};
    if (message.locationType !== 0) {
      obj.locationType = location_LocationTypeToJSON(message.locationType);
    }
    if (message.postalAddress !== undefined) {
      obj.postalAddress = PostalAddress.toJSON(message.postalAddress);
    }
    if (message.latLng !== undefined) {
      obj.latLng = LatLng.toJSON(message.latLng);
    }
    if (message.radiusMiles !== 0) {
      obj.radiusMiles = message.radiusMiles;
    }
    return obj;
  },

  create(base?: DeepPartial<Location>): Location {
    return Location.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Location>): Location {
    const message = createBaseLocation();
    message.locationType = object.locationType ?? 0;
    message.postalAddress = (object.postalAddress !== undefined && object.postalAddress !== null)
      ? PostalAddress.fromPartial(object.postalAddress)
      : undefined;
    message.latLng = (object.latLng !== undefined && object.latLng !== null)
      ? LatLng.fromPartial(object.latLng)
      : undefined;
    message.radiusMiles = object.radiusMiles ?? 0;
    return message;
  },
};

function createBaseRequestMetadata(): RequestMetadata {
  return { domain: "", sessionId: "", userId: "", allowMissingIds: false, deviceInfo: undefined };
}

export const RequestMetadata: MessageFns<RequestMetadata> = {
  encode(message: RequestMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.allowMissingIds !== false) {
      writer.uint32(32).bool(message.allowMissingIds);
    }
    if (message.deviceInfo !== undefined) {
      DeviceInfo.encode(message.deviceInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissingIds = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deviceInfo = DeviceInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      allowMissingIds: isSet(object.allowMissingIds) ? globalThis.Boolean(object.allowMissingIds) : false,
      deviceInfo: isSet(object.deviceInfo) ? DeviceInfo.fromJSON(object.deviceInfo) : undefined,
    };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.allowMissingIds !== false) {
      obj.allowMissingIds = message.allowMissingIds;
    }
    if (message.deviceInfo !== undefined) {
      obj.deviceInfo = DeviceInfo.toJSON(message.deviceInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata>): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata>): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.domain = object.domain ?? "";
    message.sessionId = object.sessionId ?? "";
    message.userId = object.userId ?? "";
    message.allowMissingIds = object.allowMissingIds ?? false;
    message.deviceInfo = (object.deviceInfo !== undefined && object.deviceInfo !== null)
      ? DeviceInfo.fromPartial(object.deviceInfo)
      : undefined;
    return message;
  },
};

function createBaseResponseMetadata(): ResponseMetadata {
  return { requestId: "" };
}

export const ResponseMetadata: MessageFns<ResponseMetadata> = {
  encode(message: ResponseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetadata {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: ResponseMetadata): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMetadata>): ResponseMetadata {
    return ResponseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMetadata>): ResponseMetadata {
    const message = createBaseResponseMetadata();
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeviceInfo(): DeviceInfo {
  return { deviceType: 0, id: "" };
}

export const DeviceInfo: MessageFns<DeviceInfo> = {
  encode(message: DeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceType !== 0) {
      writer.uint32(8).int32(message.deviceType);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.deviceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceInfo {
    return {
      deviceType: isSet(object.deviceType) ? deviceInfo_DeviceTypeFromJSON(object.deviceType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DeviceInfo): unknown {
    const obj: any = {};
    if (message.deviceType !== 0) {
      obj.deviceType = deviceInfo_DeviceTypeToJSON(message.deviceType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceInfo>): DeviceInfo {
    return DeviceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceInfo>): DeviceInfo {
    const message = createBaseDeviceInfo();
    message.deviceType = object.deviceType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCustomAttribute(): CustomAttribute {
  return { stringValues: [], longValues: [], filterable: false, keywordSearchable: false };
}

export const CustomAttribute: MessageFns<CustomAttribute> = {
  encode(message: CustomAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stringValues) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.longValues) {
      writer.int64(v.toString());
    }
    writer.join();
    if (message.filterable !== false) {
      writer.uint32(24).bool(message.filterable);
    }
    if (message.keywordSearchable !== false) {
      writer.uint32(32).bool(message.keywordSearchable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValues.push(reader.string());
          continue;
        case 2:
          if (tag === 16) {
            message.longValues.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.longValues.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.filterable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.keywordSearchable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAttribute {
    return {
      stringValues: globalThis.Array.isArray(object?.stringValues)
        ? object.stringValues.map((e: any) => globalThis.String(e))
        : [],
      longValues: globalThis.Array.isArray(object?.longValues)
        ? object.longValues.map((e: any) => Long.fromValue(e))
        : [],
      filterable: isSet(object.filterable) ? globalThis.Boolean(object.filterable) : false,
      keywordSearchable: isSet(object.keywordSearchable) ? globalThis.Boolean(object.keywordSearchable) : false,
    };
  },

  toJSON(message: CustomAttribute): unknown {
    const obj: any = {};
    if (message.stringValues?.length) {
      obj.stringValues = message.stringValues;
    }
    if (message.longValues?.length) {
      obj.longValues = message.longValues.map((e) => (e || Long.ZERO).toString());
    }
    if (message.filterable !== false) {
      obj.filterable = message.filterable;
    }
    if (message.keywordSearchable !== false) {
      obj.keywordSearchable = message.keywordSearchable;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAttribute>): CustomAttribute {
    return CustomAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAttribute>): CustomAttribute {
    const message = createBaseCustomAttribute();
    message.stringValues = object.stringValues?.map((e) => e) || [];
    message.longValues = object.longValues?.map((e) => Long.fromValue(e)) || [];
    message.filterable = object.filterable ?? false;
    message.keywordSearchable = object.keywordSearchable ?? false;
    return message;
  },
};

function createBaseSpellingCorrection(): SpellingCorrection {
  return { corrected: false, correctedText: "", correctedHtml: "" };
}

export const SpellingCorrection: MessageFns<SpellingCorrection> = {
  encode(message: SpellingCorrection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corrected !== false) {
      writer.uint32(8).bool(message.corrected);
    }
    if (message.correctedText !== "") {
      writer.uint32(18).string(message.correctedText);
    }
    if (message.correctedHtml !== "") {
      writer.uint32(26).string(message.correctedHtml);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpellingCorrection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpellingCorrection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.corrected = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.correctedText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.correctedHtml = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpellingCorrection {
    return {
      corrected: isSet(object.corrected) ? globalThis.Boolean(object.corrected) : false,
      correctedText: isSet(object.correctedText) ? globalThis.String(object.correctedText) : "",
      correctedHtml: isSet(object.correctedHtml) ? globalThis.String(object.correctedHtml) : "",
    };
  },

  toJSON(message: SpellingCorrection): unknown {
    const obj: any = {};
    if (message.corrected !== false) {
      obj.corrected = message.corrected;
    }
    if (message.correctedText !== "") {
      obj.correctedText = message.correctedText;
    }
    if (message.correctedHtml !== "") {
      obj.correctedHtml = message.correctedHtml;
    }
    return obj;
  },

  create(base?: DeepPartial<SpellingCorrection>): SpellingCorrection {
    return SpellingCorrection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpellingCorrection>): SpellingCorrection {
    const message = createBaseSpellingCorrection();
    message.corrected = object.corrected ?? false;
    message.correctedText = object.correctedText ?? "";
    message.correctedHtml = object.correctedHtml ?? "";
    return message;
  },
};

function createBaseCompensationInfo(): CompensationInfo {
  return { entries: [], annualizedBaseCompensationRange: undefined, annualizedTotalCompensationRange: undefined };
}

export const CompensationInfo: MessageFns<CompensationInfo> = {
  encode(message: CompensationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      CompensationInfo_CompensationEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.annualizedBaseCompensationRange !== undefined) {
      CompensationInfo_CompensationRange.encode(message.annualizedBaseCompensationRange, writer.uint32(18).fork())
        .join();
    }
    if (message.annualizedTotalCompensationRange !== undefined) {
      CompensationInfo_CompensationRange.encode(message.annualizedTotalCompensationRange, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompensationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompensationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(CompensationInfo_CompensationEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annualizedBaseCompensationRange = CompensationInfo_CompensationRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annualizedTotalCompensationRange = CompensationInfo_CompensationRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompensationInfo {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => CompensationInfo_CompensationEntry.fromJSON(e))
        : [],
      annualizedBaseCompensationRange: isSet(object.annualizedBaseCompensationRange)
        ? CompensationInfo_CompensationRange.fromJSON(object.annualizedBaseCompensationRange)
        : undefined,
      annualizedTotalCompensationRange: isSet(object.annualizedTotalCompensationRange)
        ? CompensationInfo_CompensationRange.fromJSON(object.annualizedTotalCompensationRange)
        : undefined,
    };
  },

  toJSON(message: CompensationInfo): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => CompensationInfo_CompensationEntry.toJSON(e));
    }
    if (message.annualizedBaseCompensationRange !== undefined) {
      obj.annualizedBaseCompensationRange = CompensationInfo_CompensationRange.toJSON(
        message.annualizedBaseCompensationRange,
      );
    }
    if (message.annualizedTotalCompensationRange !== undefined) {
      obj.annualizedTotalCompensationRange = CompensationInfo_CompensationRange.toJSON(
        message.annualizedTotalCompensationRange,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<CompensationInfo>): CompensationInfo {
    return CompensationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompensationInfo>): CompensationInfo {
    const message = createBaseCompensationInfo();
    message.entries = object.entries?.map((e) => CompensationInfo_CompensationEntry.fromPartial(e)) || [];
    message.annualizedBaseCompensationRange =
      (object.annualizedBaseCompensationRange !== undefined && object.annualizedBaseCompensationRange !== null)
        ? CompensationInfo_CompensationRange.fromPartial(object.annualizedBaseCompensationRange)
        : undefined;
    message.annualizedTotalCompensationRange =
      (object.annualizedTotalCompensationRange !== undefined && object.annualizedTotalCompensationRange !== null)
        ? CompensationInfo_CompensationRange.fromPartial(object.annualizedTotalCompensationRange)
        : undefined;
    return message;
  },
};

function createBaseCompensationInfo_CompensationEntry(): CompensationInfo_CompensationEntry {
  return { type: 0, unit: 0, amount: undefined, range: undefined, description: "", expectedUnitsPerYear: undefined };
}

export const CompensationInfo_CompensationEntry: MessageFns<CompensationInfo_CompensationEntry> = {
  encode(message: CompensationInfo_CompensationEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).join();
    }
    if (message.range !== undefined) {
      CompensationInfo_CompensationRange.encode(message.range, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.expectedUnitsPerYear !== undefined) {
      DoubleValue.encode({ value: message.expectedUnitsPerYear! }, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompensationInfo_CompensationEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompensationInfo_CompensationEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.range = CompensationInfo_CompensationRange.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expectedUnitsPerYear = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompensationInfo_CompensationEntry {
    return {
      type: isSet(object.type) ? compensationInfo_CompensationTypeFromJSON(object.type) : 0,
      unit: isSet(object.unit) ? compensationInfo_CompensationUnitFromJSON(object.unit) : 0,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
      range: isSet(object.range) ? CompensationInfo_CompensationRange.fromJSON(object.range) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      expectedUnitsPerYear: isSet(object.expectedUnitsPerYear) ? Number(object.expectedUnitsPerYear) : undefined,
    };
  },

  toJSON(message: CompensationInfo_CompensationEntry): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = compensationInfo_CompensationTypeToJSON(message.type);
    }
    if (message.unit !== 0) {
      obj.unit = compensationInfo_CompensationUnitToJSON(message.unit);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    if (message.range !== undefined) {
      obj.range = CompensationInfo_CompensationRange.toJSON(message.range);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.expectedUnitsPerYear !== undefined) {
      obj.expectedUnitsPerYear = message.expectedUnitsPerYear;
    }
    return obj;
  },

  create(base?: DeepPartial<CompensationInfo_CompensationEntry>): CompensationInfo_CompensationEntry {
    return CompensationInfo_CompensationEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompensationInfo_CompensationEntry>): CompensationInfo_CompensationEntry {
    const message = createBaseCompensationInfo_CompensationEntry();
    message.type = object.type ?? 0;
    message.unit = object.unit ?? 0;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    message.range = (object.range !== undefined && object.range !== null)
      ? CompensationInfo_CompensationRange.fromPartial(object.range)
      : undefined;
    message.description = object.description ?? "";
    message.expectedUnitsPerYear = object.expectedUnitsPerYear ?? undefined;
    return message;
  },
};

function createBaseCompensationInfo_CompensationRange(): CompensationInfo_CompensationRange {
  return { maxCompensation: undefined, minCompensation: undefined };
}

export const CompensationInfo_CompensationRange: MessageFns<CompensationInfo_CompensationRange> = {
  encode(message: CompensationInfo_CompensationRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxCompensation !== undefined) {
      Money.encode(message.maxCompensation, writer.uint32(18).fork()).join();
    }
    if (message.minCompensation !== undefined) {
      Money.encode(message.minCompensation, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompensationInfo_CompensationRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompensationInfo_CompensationRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxCompensation = Money.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minCompensation = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompensationInfo_CompensationRange {
    return {
      maxCompensation: isSet(object.maxCompensation) ? Money.fromJSON(object.maxCompensation) : undefined,
      minCompensation: isSet(object.minCompensation) ? Money.fromJSON(object.minCompensation) : undefined,
    };
  },

  toJSON(message: CompensationInfo_CompensationRange): unknown {
    const obj: any = {};
    if (message.maxCompensation !== undefined) {
      obj.maxCompensation = Money.toJSON(message.maxCompensation);
    }
    if (message.minCompensation !== undefined) {
      obj.minCompensation = Money.toJSON(message.minCompensation);
    }
    return obj;
  },

  create(base?: DeepPartial<CompensationInfo_CompensationRange>): CompensationInfo_CompensationRange {
    return CompensationInfo_CompensationRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompensationInfo_CompensationRange>): CompensationInfo_CompensationRange {
    const message = createBaseCompensationInfo_CompensationRange();
    message.maxCompensation = (object.maxCompensation !== undefined && object.maxCompensation !== null)
      ? Money.fromPartial(object.maxCompensation)
      : undefined;
    message.minCompensation = (object.minCompensation !== undefined && object.minCompensation !== null)
      ? Money.fromPartial(object.minCompensation)
      : undefined;
    return message;
  },
};

function createBaseBatchOperationMetadata(): BatchOperationMetadata {
  return {
    state: 0,
    stateDescription: "",
    successCount: 0,
    failureCount: 0,
    totalCount: 0,
    createTime: undefined,
    updateTime: undefined,
    endTime: undefined,
  };
}

export const BatchOperationMetadata: MessageFns<BatchOperationMetadata> = {
  encode(message: BatchOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.stateDescription !== "") {
      writer.uint32(18).string(message.stateDescription);
    }
    if (message.successCount !== 0) {
      writer.uint32(24).int32(message.successCount);
    }
    if (message.failureCount !== 0) {
      writer.uint32(32).int32(message.failureCount);
    }
    if (message.totalCount !== 0) {
      writer.uint32(40).int32(message.totalCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateDescription = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.successCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failureCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchOperationMetadata {
    return {
      state: isSet(object.state) ? batchOperationMetadata_StateFromJSON(object.state) : 0,
      stateDescription: isSet(object.stateDescription) ? globalThis.String(object.stateDescription) : "",
      successCount: isSet(object.successCount) ? globalThis.Number(object.successCount) : 0,
      failureCount: isSet(object.failureCount) ? globalThis.Number(object.failureCount) : 0,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: BatchOperationMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = batchOperationMetadata_StateToJSON(message.state);
    }
    if (message.stateDescription !== "") {
      obj.stateDescription = message.stateDescription;
    }
    if (message.successCount !== 0) {
      obj.successCount = Math.round(message.successCount);
    }
    if (message.failureCount !== 0) {
      obj.failureCount = Math.round(message.failureCount);
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchOperationMetadata>): BatchOperationMetadata {
    return BatchOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchOperationMetadata>): BatchOperationMetadata {
    const message = createBaseBatchOperationMetadata();
    message.state = object.state ?? 0;
    message.stateDescription = object.stateDescription ?? "";
    message.successCount = object.successCount ?? 0;
    message.failureCount = object.failureCount ?? 0;
    message.totalCount = object.totalCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
