// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/talent/v4beta1/filters.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { LatLng } from "../../../type/latlng.js";
import { TimeOfDay } from "../../../type/timeofday.js";
import {
  CommuteMethod,
  commuteMethodFromJSON,
  commuteMethodToJSON,
  CompensationInfo_CompensationRange,
  CompensationInfo_CompensationUnit,
  compensationInfo_CompensationUnitFromJSON,
  compensationInfo_CompensationUnitToJSON,
  EmploymentType,
  employmentTypeFromJSON,
  employmentTypeToJSON,
  JobCategory,
  jobCategoryFromJSON,
  jobCategoryToJSON,
  TimestampRange,
} from "./common.js";

export const protobufPackage = "google.cloud.talent.v4beta1";

/** The query required to perform a search query. */
export interface JobQuery {
  /**
   * The query string that matches against the job title, description, and
   * location fields.
   *
   * The maximum number of allowed characters is 255.
   */
  query: string;
  /**
   * The language code of [query][google.cloud.talent.v4beta1.JobQuery.query].
   * For example, "en-US". This field helps to better interpret the query.
   *
   * If a value isn't specified, the query language code is automatically
   * detected, which may not be accurate.
   *
   * Language code should be in BCP-47 format, such as "en-US" or "sr-Latn".
   * For more information, see
   * [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
   */
  queryLanguageCode: string;
  /**
   * This filter specifies the company entities to search against.
   *
   * If a value isn't specified, jobs are searched for against all
   * companies.
   *
   * If multiple values are specified, jobs are searched against the
   * companies specified.
   *
   * The format is
   * "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
   * example, "projects/foo/tenants/bar/companies/baz".
   *
   * If tenant id is unspecified, the default tenant is used. For
   * example, "projects/foo/companies/bar".
   *
   * At most 20 company filters are allowed.
   */
  companies: string[];
  /**
   * The location filter specifies geo-regions containing the jobs to
   * search against. See
   * [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] for more
   * information.
   *
   * If a location value isn't specified, jobs fitting the other search
   * criteria are retrieved regardless of where they're located.
   *
   * If multiple values are specified, jobs are retrieved from any of the
   * specified locations. If different values are specified for the
   * [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles]
   * parameter, the maximum provided distance is used for all locations.
   *
   * At most 5 location filters are allowed.
   */
  locationFilters: LocationFilter[];
  /**
   * The category filter specifies the categories of jobs to search against.
   * See [JobCategory][google.cloud.talent.v4beta1.JobCategory] for more
   * information.
   *
   * If a value isn't specified, jobs from any category are searched against.
   *
   * If multiple values are specified, jobs from any of the specified
   * categories are searched against.
   */
  jobCategories: JobCategory[];
  /**
   * Allows filtering jobs by commute time with different travel methods (for
   *  example, driving or public transit).
   *
   * Note: This only works when you specify a
   * [CommuteMethod][google.cloud.talent.v4beta1.CommuteMethod]. In this case,
   * [location_filters][google.cloud.talent.v4beta1.JobQuery.location_filters]
   * is ignored.
   *
   *  Currently we don't support sorting by commute time.
   */
  commuteFilter:
    | CommuteFilter
    | undefined;
  /**
   * This filter specifies the company
   * [Company.display_name][google.cloud.talent.v4beta1.Company.display_name] of
   * the jobs to search against. The company name must match the value exactly.
   *
   * Alternatively, the value being searched for can be wrapped in different
   * match operators.
   * `SUBSTRING_MATCH([value])`
   * The company name must contain a case insensitive substring match of the
   * value. Using this function may increase latency.
   *
   * Sample Value: `SUBSTRING_MATCH(google)`
   *
   * `MULTI_WORD_TOKEN_MATCH([value])`
   * The value will be treated as a multi word token and the company name must
   * contain a case insensitive match of the value. Using this function may
   * increase latency.
   *
   * Sample Value: `MULTI_WORD_TOKEN_MATCH(google)`
   *
   * If a value isn't specified, jobs within the search results are
   * associated with any company.
   *
   * If multiple values are specified, jobs within the search results may be
   * associated with any of the specified companies.
   *
   * At most 20 company display name filters are allowed.
   */
  companyDisplayNames: string[];
  /**
   * This search filter is applied only to
   * [Job.compensation_info][google.cloud.talent.v4beta1.Job.compensation_info].
   * For example, if the filter is specified as "Hourly job with per-hour
   * compensation > $15", only jobs meeting these criteria are searched. If a
   * filter isn't defined, all open jobs are searched.
   */
  compensationFilter:
    | CompensationFilter
    | undefined;
  /**
   * This filter specifies a structured syntax to match against the
   * [Job.custom_attributes][google.cloud.talent.v4beta1.Job.custom_attributes]
   * marked as `filterable`.
   *
   * The syntax for this expression is a subset of SQL syntax.
   *
   * Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the
   * left of the operator is a custom field key and the right of the operator
   * is a number or a quoted string. You must escape backslash (\\) and
   * quote (\") characters.
   *
   * Supported functions are `LOWER([field_name])` to
   * perform a case insensitive match and `EMPTY([field_name])` to filter on the
   * existence of a key.
   *
   * Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
   * nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
   * comparisons or functions are allowed in the expression. The expression
   * must be < 10000 bytes in length.
   *
   * Sample Query:
   * `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
   * driving_years > 10`
   */
  customAttributeFilter: string;
  /**
   * This flag controls the spell-check feature. If false, the
   * service attempts to correct a misspelled query,
   * for example, "enginee" is corrected to "engineer".
   *
   * Defaults to false: a spell check is performed.
   */
  disableSpellCheck: boolean;
  /**
   * The employment type filter specifies the employment type of jobs to
   * search against, such as
   * [EmploymentType.FULL_TIME][google.cloud.talent.v4beta1.EmploymentType.FULL_TIME].
   *
   * If a value isn't specified, jobs in the search results includes any
   * employment type.
   *
   * If multiple values are specified, jobs in the search results include
   * any of the specified employment types.
   */
  employmentTypes: EmploymentType[];
  /**
   * This filter specifies the locale of jobs to search against,
   * for example, "en-US".
   *
   * If a value isn't specified, the search results can contain jobs in any
   * locale.
   *
   * Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
   * For more information, see
   * [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
   *
   * At most 10 language code filters are allowed.
   */
  languageCodes: string[];
  /**
   * Jobs published within a range specified by this filter are searched
   * against.
   */
  publishTimeRange:
    | TimestampRange
    | undefined;
  /**
   * This filter specifies a list of job names to be excluded during search.
   *
   * At most 400 excluded job names are allowed.
   */
  excludedJobs: string[];
}

/** Geographic region of the search. */
export interface LocationFilter {
  /** The address name, such as "Mountain View" or "Bay Area". */
  address: string;
  /**
   * CLDR region code of the country/region. This field may be used in two ways:
   *
   * 1) If telecommute preference is not set, this field is used address
   * ambiguity of the user-input address. For example, "Liverpool" may refer to
   * "Liverpool, NY, US" or "Liverpool, UK". This region code biases the
   * address resolution toward a specific country or territory. If this field is
   * not set, address resolution is biased toward the United States by default.
   *
   * 2) If telecommute preference is set to TELECOMMUTE_ALLOWED, the
   * telecommute location filter will be limited to the region specified in this
   * field. If this field is not set, the telecommute job locations will not be
   *
   * See
   * https://unicode-org.github.io/cldr-staging/charts/latest/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   */
  regionCode: string;
  /**
   * The latitude and longitude of the geographic center to search from. This
   * field is ignored if `address` is provided.
   */
  latLng:
    | LatLng
    | undefined;
  /**
   * The distance_in_miles is applied when the location being searched for is
   * identified as a city or smaller. This field is ignored if the location
   * being searched for is a state or larger.
   */
  distanceInMiles: number;
  /**
   * Allows the client to return jobs without a
   * set location, specifically, telecommuting jobs (telecommuting is considered
   * by the service as a special location).
   * [Job.posting_region][google.cloud.talent.v4beta1.Job.posting_region]
   * indicates if a job permits telecommuting. If this field is set to
   * [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
   * telecommuting jobs are searched, and
   * [address][google.cloud.talent.v4beta1.LocationFilter.address] and
   * [lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] are ignored.
   * If not set or set to
   * [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED],
   * the telecommute status of the jobs is ignored. Jobs that have
   * [PostingRegion.TELECOMMUTE][google.cloud.talent.v4beta1.PostingRegion.TELECOMMUTE]
   * and have additional
   * [Job.addresses][google.cloud.talent.v4beta1.Job.addresses] may still be
   * matched based on other location filters using
   * [address][google.cloud.talent.v4beta1.LocationFilter.address] or
   * [latlng][].
   *
   * This filter can be used by itself to search exclusively for telecommuting
   * jobs, or it can be combined with another location
   * filter to search for a combination of job locations,
   * such as "Mountain View" or "telecommuting" jobs. However, when used in
   * combination with other location filters, telecommuting jobs can be
   * treated as less relevant than other jobs in the search response.
   *
   * This field is only used for job search requests.
   */
  telecommutePreference: LocationFilter_TelecommutePreference;
  /**
   * Whether to apply negation to the filter so profiles matching the filter
   * are excluded.
   */
  negated: boolean;
}

/** Specify whether to include telecommute jobs. */
export enum LocationFilter_TelecommutePreference {
  /** TELECOMMUTE_PREFERENCE_UNSPECIFIED - Default value if the telecommute preference isn't specified. */
  TELECOMMUTE_PREFERENCE_UNSPECIFIED = 0,
  /**
   * TELECOMMUTE_EXCLUDED - Deprecated: Ignore telecommute status of jobs. Use
   * TELECOMMUTE_JOBS_EXCLUDED if want to exclude telecommute jobs.
   *
   * @deprecated
   */
  TELECOMMUTE_EXCLUDED = 1,
  /** TELECOMMUTE_ALLOWED - Allow telecommute jobs. */
  TELECOMMUTE_ALLOWED = 2,
  /** TELECOMMUTE_JOBS_EXCLUDED - Exclude telecommute jobs. */
  TELECOMMUTE_JOBS_EXCLUDED = 3,
  UNRECOGNIZED = -1,
}

export function locationFilter_TelecommutePreferenceFromJSON(object: any): LocationFilter_TelecommutePreference {
  switch (object) {
    case 0:
    case "TELECOMMUTE_PREFERENCE_UNSPECIFIED":
      return LocationFilter_TelecommutePreference.TELECOMMUTE_PREFERENCE_UNSPECIFIED;
    case 1:
    case "TELECOMMUTE_EXCLUDED":
      return LocationFilter_TelecommutePreference.TELECOMMUTE_EXCLUDED;
    case 2:
    case "TELECOMMUTE_ALLOWED":
      return LocationFilter_TelecommutePreference.TELECOMMUTE_ALLOWED;
    case 3:
    case "TELECOMMUTE_JOBS_EXCLUDED":
      return LocationFilter_TelecommutePreference.TELECOMMUTE_JOBS_EXCLUDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocationFilter_TelecommutePreference.UNRECOGNIZED;
  }
}

export function locationFilter_TelecommutePreferenceToJSON(object: LocationFilter_TelecommutePreference): string {
  switch (object) {
    case LocationFilter_TelecommutePreference.TELECOMMUTE_PREFERENCE_UNSPECIFIED:
      return "TELECOMMUTE_PREFERENCE_UNSPECIFIED";
    case LocationFilter_TelecommutePreference.TELECOMMUTE_EXCLUDED:
      return "TELECOMMUTE_EXCLUDED";
    case LocationFilter_TelecommutePreference.TELECOMMUTE_ALLOWED:
      return "TELECOMMUTE_ALLOWED";
    case LocationFilter_TelecommutePreference.TELECOMMUTE_JOBS_EXCLUDED:
      return "TELECOMMUTE_JOBS_EXCLUDED";
    case LocationFilter_TelecommutePreference.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Filter on job compensation type and amount. */
export interface CompensationFilter {
  /** Required. Type of filter. */
  type: CompensationFilter_FilterType;
  /**
   * Required. Specify desired `base compensation entry's`
   * [CompensationInfo.CompensationUnit][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit].
   */
  units: CompensationInfo_CompensationUnit[];
  /** Compensation range. */
  range:
    | CompensationInfo_CompensationRange
    | undefined;
  /**
   * If set to true, jobs with unspecified compensation range fields are
   * included.
   */
  includeJobsWithUnspecifiedCompensationRange: boolean;
}

/** Specify the type of filtering. */
export enum CompensationFilter_FilterType {
  /** FILTER_TYPE_UNSPECIFIED - Filter type unspecified. Position holder, INVALID, should never be used. */
  FILTER_TYPE_UNSPECIFIED = 0,
  /**
   * UNIT_ONLY - Filter by `base compensation entry's` unit. A job is a match if and
   * only if the job contains a base CompensationEntry and the base
   * CompensationEntry's unit matches provided
   * [units][google.cloud.talent.v4beta1.CompensationFilter.units]. Populate
   * one or more
   * [units][google.cloud.talent.v4beta1.CompensationFilter.units].
   *
   * See
   * [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry]
   * for definition of base compensation entry.
   */
  UNIT_ONLY = 1,
  /**
   * UNIT_AND_AMOUNT - Filter by `base compensation entry's` unit and amount / range. A job
   * is a match if and only if the job contains a base CompensationEntry, and
   * the base entry's unit matches provided
   * [CompensationUnit][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit]
   * and amount or range overlaps with provided
   * [CompensationRange][google.cloud.talent.v4beta1.CompensationInfo.CompensationRange].
   *
   * See
   * [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry]
   * for definition of base compensation entry.
   *
   * Set exactly one
   * [units][google.cloud.talent.v4beta1.CompensationFilter.units] and
   * populate [range][google.cloud.talent.v4beta1.CompensationFilter.range].
   */
  UNIT_AND_AMOUNT = 2,
  /**
   * ANNUALIZED_BASE_AMOUNT - Filter by annualized base compensation amount and `base compensation
   * entry's` unit. Populate
   * [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or
   * more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
   */
  ANNUALIZED_BASE_AMOUNT = 3,
  /**
   * ANNUALIZED_TOTAL_AMOUNT - Filter by annualized total compensation amount and `base compensation
   * entry's` unit . Populate
   * [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or
   * more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
   */
  ANNUALIZED_TOTAL_AMOUNT = 4,
  UNRECOGNIZED = -1,
}

export function compensationFilter_FilterTypeFromJSON(object: any): CompensationFilter_FilterType {
  switch (object) {
    case 0:
    case "FILTER_TYPE_UNSPECIFIED":
      return CompensationFilter_FilterType.FILTER_TYPE_UNSPECIFIED;
    case 1:
    case "UNIT_ONLY":
      return CompensationFilter_FilterType.UNIT_ONLY;
    case 2:
    case "UNIT_AND_AMOUNT":
      return CompensationFilter_FilterType.UNIT_AND_AMOUNT;
    case 3:
    case "ANNUALIZED_BASE_AMOUNT":
      return CompensationFilter_FilterType.ANNUALIZED_BASE_AMOUNT;
    case 4:
    case "ANNUALIZED_TOTAL_AMOUNT":
      return CompensationFilter_FilterType.ANNUALIZED_TOTAL_AMOUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompensationFilter_FilterType.UNRECOGNIZED;
  }
}

export function compensationFilter_FilterTypeToJSON(object: CompensationFilter_FilterType): string {
  switch (object) {
    case CompensationFilter_FilterType.FILTER_TYPE_UNSPECIFIED:
      return "FILTER_TYPE_UNSPECIFIED";
    case CompensationFilter_FilterType.UNIT_ONLY:
      return "UNIT_ONLY";
    case CompensationFilter_FilterType.UNIT_AND_AMOUNT:
      return "UNIT_AND_AMOUNT";
    case CompensationFilter_FilterType.ANNUALIZED_BASE_AMOUNT:
      return "ANNUALIZED_BASE_AMOUNT";
    case CompensationFilter_FilterType.ANNUALIZED_TOTAL_AMOUNT:
      return "ANNUALIZED_TOTAL_AMOUNT";
    case CompensationFilter_FilterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Parameters needed for commute search. */
export interface CommuteFilter {
  /** Required. The method of transportation to calculate the commute time for. */
  commuteMethod: CommuteMethod;
  /**
   * Required. The latitude and longitude of the location to calculate the
   * commute time from.
   */
  startCoordinates:
    | LatLng
    | undefined;
  /**
   * Required. The maximum travel time in seconds. The maximum allowed value is
   * `3600s` (one hour). Format is `123s`.
   */
  travelDuration:
    | Duration
    | undefined;
  /**
   * If `true`, jobs without street level addresses may also be returned.
   * For city level addresses, the city center is used. For state and coarser
   * level addresses, text matching is used.
   * If this field is set to `false` or isn't specified, only jobs that include
   * street level addresses will be returned by commute search.
   */
  allowImpreciseAddresses: boolean;
  /** Specifies the traffic density to use when calculating commute time. */
  roadTraffic?:
    | CommuteFilter_RoadTraffic
    | undefined;
  /**
   * The departure time used to calculate traffic impact, represented as
   * [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
   *
   * Currently traffic model is restricted to hour level resolution.
   */
  departureTime?: TimeOfDay | undefined;
}

/** The traffic density to use when calculating commute time. */
export enum CommuteFilter_RoadTraffic {
  /** ROAD_TRAFFIC_UNSPECIFIED - Road traffic situation isn't specified. */
  ROAD_TRAFFIC_UNSPECIFIED = 0,
  /** TRAFFIC_FREE - Optimal commute time without considering any traffic impact. */
  TRAFFIC_FREE = 1,
  /** BUSY_HOUR - Commute time calculation takes in account the peak traffic impact. */
  BUSY_HOUR = 2,
  UNRECOGNIZED = -1,
}

export function commuteFilter_RoadTrafficFromJSON(object: any): CommuteFilter_RoadTraffic {
  switch (object) {
    case 0:
    case "ROAD_TRAFFIC_UNSPECIFIED":
      return CommuteFilter_RoadTraffic.ROAD_TRAFFIC_UNSPECIFIED;
    case 1:
    case "TRAFFIC_FREE":
      return CommuteFilter_RoadTraffic.TRAFFIC_FREE;
    case 2:
    case "BUSY_HOUR":
      return CommuteFilter_RoadTraffic.BUSY_HOUR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommuteFilter_RoadTraffic.UNRECOGNIZED;
  }
}

export function commuteFilter_RoadTrafficToJSON(object: CommuteFilter_RoadTraffic): string {
  switch (object) {
    case CommuteFilter_RoadTraffic.ROAD_TRAFFIC_UNSPECIFIED:
      return "ROAD_TRAFFIC_UNSPECIFIED";
    case CommuteFilter_RoadTraffic.TRAFFIC_FREE:
      return "TRAFFIC_FREE";
    case CommuteFilter_RoadTraffic.BUSY_HOUR:
      return "BUSY_HOUR";
    case CommuteFilter_RoadTraffic.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseJobQuery(): JobQuery {
  return {
    query: "",
    queryLanguageCode: "",
    companies: [],
    locationFilters: [],
    jobCategories: [],
    commuteFilter: undefined,
    companyDisplayNames: [],
    compensationFilter: undefined,
    customAttributeFilter: "",
    disableSpellCheck: false,
    employmentTypes: [],
    languageCodes: [],
    publishTimeRange: undefined,
    excludedJobs: [],
  };
}

export const JobQuery: MessageFns<JobQuery> = {
  encode(message: JobQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.queryLanguageCode !== "") {
      writer.uint32(114).string(message.queryLanguageCode);
    }
    for (const v of message.companies) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.locationFilters) {
      LocationFilter.encode(v!, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.jobCategories) {
      writer.int32(v);
    }
    writer.join();
    if (message.commuteFilter !== undefined) {
      CommuteFilter.encode(message.commuteFilter, writer.uint32(42).fork()).join();
    }
    for (const v of message.companyDisplayNames) {
      writer.uint32(50).string(v!);
    }
    if (message.compensationFilter !== undefined) {
      CompensationFilter.encode(message.compensationFilter, writer.uint32(58).fork()).join();
    }
    if (message.customAttributeFilter !== "") {
      writer.uint32(66).string(message.customAttributeFilter);
    }
    if (message.disableSpellCheck !== false) {
      writer.uint32(72).bool(message.disableSpellCheck);
    }
    writer.uint32(82).fork();
    for (const v of message.employmentTypes) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.languageCodes) {
      writer.uint32(90).string(v!);
    }
    if (message.publishTimeRange !== undefined) {
      TimestampRange.encode(message.publishTimeRange, writer.uint32(98).fork()).join();
    }
    for (const v of message.excludedJobs) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.queryLanguageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.companies.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locationFilters.push(LocationFilter.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 32) {
            message.jobCategories.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.jobCategories.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.commuteFilter = CommuteFilter.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.companyDisplayNames.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.compensationFilter = CompensationFilter.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.customAttributeFilter = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.disableSpellCheck = reader.bool();
          continue;
        case 10:
          if (tag === 80) {
            message.employmentTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.employmentTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.languageCodes.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.publishTimeRange = TimestampRange.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.excludedJobs.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobQuery {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      queryLanguageCode: isSet(object.queryLanguageCode) ? globalThis.String(object.queryLanguageCode) : "",
      companies: globalThis.Array.isArray(object?.companies)
        ? object.companies.map((e: any) => globalThis.String(e))
        : [],
      locationFilters: globalThis.Array.isArray(object?.locationFilters)
        ? object.locationFilters.map((e: any) => LocationFilter.fromJSON(e))
        : [],
      jobCategories: globalThis.Array.isArray(object?.jobCategories)
        ? object.jobCategories.map((e: any) => jobCategoryFromJSON(e))
        : [],
      commuteFilter: isSet(object.commuteFilter) ? CommuteFilter.fromJSON(object.commuteFilter) : undefined,
      companyDisplayNames: globalThis.Array.isArray(object?.companyDisplayNames)
        ? object.companyDisplayNames.map((e: any) => globalThis.String(e))
        : [],
      compensationFilter: isSet(object.compensationFilter)
        ? CompensationFilter.fromJSON(object.compensationFilter)
        : undefined,
      customAttributeFilter: isSet(object.customAttributeFilter) ? globalThis.String(object.customAttributeFilter) : "",
      disableSpellCheck: isSet(object.disableSpellCheck) ? globalThis.Boolean(object.disableSpellCheck) : false,
      employmentTypes: globalThis.Array.isArray(object?.employmentTypes)
        ? object.employmentTypes.map((e: any) => employmentTypeFromJSON(e))
        : [],
      languageCodes: globalThis.Array.isArray(object?.languageCodes)
        ? object.languageCodes.map((e: any) => globalThis.String(e))
        : [],
      publishTimeRange: isSet(object.publishTimeRange) ? TimestampRange.fromJSON(object.publishTimeRange) : undefined,
      excludedJobs: globalThis.Array.isArray(object?.excludedJobs)
        ? object.excludedJobs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: JobQuery): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.queryLanguageCode !== "") {
      obj.queryLanguageCode = message.queryLanguageCode;
    }
    if (message.companies?.length) {
      obj.companies = message.companies;
    }
    if (message.locationFilters?.length) {
      obj.locationFilters = message.locationFilters.map((e) => LocationFilter.toJSON(e));
    }
    if (message.jobCategories?.length) {
      obj.jobCategories = message.jobCategories.map((e) => jobCategoryToJSON(e));
    }
    if (message.commuteFilter !== undefined) {
      obj.commuteFilter = CommuteFilter.toJSON(message.commuteFilter);
    }
    if (message.companyDisplayNames?.length) {
      obj.companyDisplayNames = message.companyDisplayNames;
    }
    if (message.compensationFilter !== undefined) {
      obj.compensationFilter = CompensationFilter.toJSON(message.compensationFilter);
    }
    if (message.customAttributeFilter !== "") {
      obj.customAttributeFilter = message.customAttributeFilter;
    }
    if (message.disableSpellCheck !== false) {
      obj.disableSpellCheck = message.disableSpellCheck;
    }
    if (message.employmentTypes?.length) {
      obj.employmentTypes = message.employmentTypes.map((e) => employmentTypeToJSON(e));
    }
    if (message.languageCodes?.length) {
      obj.languageCodes = message.languageCodes;
    }
    if (message.publishTimeRange !== undefined) {
      obj.publishTimeRange = TimestampRange.toJSON(message.publishTimeRange);
    }
    if (message.excludedJobs?.length) {
      obj.excludedJobs = message.excludedJobs;
    }
    return obj;
  },

  create(base?: DeepPartial<JobQuery>): JobQuery {
    return JobQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobQuery>): JobQuery {
    const message = createBaseJobQuery();
    message.query = object.query ?? "";
    message.queryLanguageCode = object.queryLanguageCode ?? "";
    message.companies = object.companies?.map((e) => e) || [];
    message.locationFilters = object.locationFilters?.map((e) => LocationFilter.fromPartial(e)) || [];
    message.jobCategories = object.jobCategories?.map((e) => e) || [];
    message.commuteFilter = (object.commuteFilter !== undefined && object.commuteFilter !== null)
      ? CommuteFilter.fromPartial(object.commuteFilter)
      : undefined;
    message.companyDisplayNames = object.companyDisplayNames?.map((e) => e) || [];
    message.compensationFilter = (object.compensationFilter !== undefined && object.compensationFilter !== null)
      ? CompensationFilter.fromPartial(object.compensationFilter)
      : undefined;
    message.customAttributeFilter = object.customAttributeFilter ?? "";
    message.disableSpellCheck = object.disableSpellCheck ?? false;
    message.employmentTypes = object.employmentTypes?.map((e) => e) || [];
    message.languageCodes = object.languageCodes?.map((e) => e) || [];
    message.publishTimeRange = (object.publishTimeRange !== undefined && object.publishTimeRange !== null)
      ? TimestampRange.fromPartial(object.publishTimeRange)
      : undefined;
    message.excludedJobs = object.excludedJobs?.map((e) => e) || [];
    return message;
  },
};

function createBaseLocationFilter(): LocationFilter {
  return {
    address: "",
    regionCode: "",
    latLng: undefined,
    distanceInMiles: 0,
    telecommutePreference: 0,
    negated: false,
  };
}

export const LocationFilter: MessageFns<LocationFilter> = {
  encode(message: LocationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.regionCode !== "") {
      writer.uint32(18).string(message.regionCode);
    }
    if (message.latLng !== undefined) {
      LatLng.encode(message.latLng, writer.uint32(26).fork()).join();
    }
    if (message.distanceInMiles !== 0) {
      writer.uint32(33).double(message.distanceInMiles);
    }
    if (message.telecommutePreference !== 0) {
      writer.uint32(40).int32(message.telecommutePreference);
    }
    if (message.negated !== false) {
      writer.uint32(48).bool(message.negated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latLng = LatLng.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.distanceInMiles = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.telecommutePreference = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.negated = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationFilter {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      latLng: isSet(object.latLng) ? LatLng.fromJSON(object.latLng) : undefined,
      distanceInMiles: isSet(object.distanceInMiles) ? globalThis.Number(object.distanceInMiles) : 0,
      telecommutePreference: isSet(object.telecommutePreference)
        ? locationFilter_TelecommutePreferenceFromJSON(object.telecommutePreference)
        : 0,
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
    };
  },

  toJSON(message: LocationFilter): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.latLng !== undefined) {
      obj.latLng = LatLng.toJSON(message.latLng);
    }
    if (message.distanceInMiles !== 0) {
      obj.distanceInMiles = message.distanceInMiles;
    }
    if (message.telecommutePreference !== 0) {
      obj.telecommutePreference = locationFilter_TelecommutePreferenceToJSON(message.telecommutePreference);
    }
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    return obj;
  },

  create(base?: DeepPartial<LocationFilter>): LocationFilter {
    return LocationFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationFilter>): LocationFilter {
    const message = createBaseLocationFilter();
    message.address = object.address ?? "";
    message.regionCode = object.regionCode ?? "";
    message.latLng = (object.latLng !== undefined && object.latLng !== null)
      ? LatLng.fromPartial(object.latLng)
      : undefined;
    message.distanceInMiles = object.distanceInMiles ?? 0;
    message.telecommutePreference = object.telecommutePreference ?? 0;
    message.negated = object.negated ?? false;
    return message;
  },
};

function createBaseCompensationFilter(): CompensationFilter {
  return { type: 0, units: [], range: undefined, includeJobsWithUnspecifiedCompensationRange: false };
}

export const CompensationFilter: MessageFns<CompensationFilter> = {
  encode(message: CompensationFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    writer.uint32(18).fork();
    for (const v of message.units) {
      writer.int32(v);
    }
    writer.join();
    if (message.range !== undefined) {
      CompensationInfo_CompensationRange.encode(message.range, writer.uint32(26).fork()).join();
    }
    if (message.includeJobsWithUnspecifiedCompensationRange !== false) {
      writer.uint32(32).bool(message.includeJobsWithUnspecifiedCompensationRange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompensationFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompensationFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag === 16) {
            message.units.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.units.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.range = CompensationInfo_CompensationRange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeJobsWithUnspecifiedCompensationRange = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompensationFilter {
    return {
      type: isSet(object.type) ? compensationFilter_FilterTypeFromJSON(object.type) : 0,
      units: globalThis.Array.isArray(object?.units)
        ? object.units.map((e: any) => compensationInfo_CompensationUnitFromJSON(e))
        : [],
      range: isSet(object.range) ? CompensationInfo_CompensationRange.fromJSON(object.range) : undefined,
      includeJobsWithUnspecifiedCompensationRange: isSet(object.includeJobsWithUnspecifiedCompensationRange)
        ? globalThis.Boolean(object.includeJobsWithUnspecifiedCompensationRange)
        : false,
    };
  },

  toJSON(message: CompensationFilter): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = compensationFilter_FilterTypeToJSON(message.type);
    }
    if (message.units?.length) {
      obj.units = message.units.map((e) => compensationInfo_CompensationUnitToJSON(e));
    }
    if (message.range !== undefined) {
      obj.range = CompensationInfo_CompensationRange.toJSON(message.range);
    }
    if (message.includeJobsWithUnspecifiedCompensationRange !== false) {
      obj.includeJobsWithUnspecifiedCompensationRange = message.includeJobsWithUnspecifiedCompensationRange;
    }
    return obj;
  },

  create(base?: DeepPartial<CompensationFilter>): CompensationFilter {
    return CompensationFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompensationFilter>): CompensationFilter {
    const message = createBaseCompensationFilter();
    message.type = object.type ?? 0;
    message.units = object.units?.map((e) => e) || [];
    message.range = (object.range !== undefined && object.range !== null)
      ? CompensationInfo_CompensationRange.fromPartial(object.range)
      : undefined;
    message.includeJobsWithUnspecifiedCompensationRange = object.includeJobsWithUnspecifiedCompensationRange ?? false;
    return message;
  },
};

function createBaseCommuteFilter(): CommuteFilter {
  return {
    commuteMethod: 0,
    startCoordinates: undefined,
    travelDuration: undefined,
    allowImpreciseAddresses: false,
    roadTraffic: undefined,
    departureTime: undefined,
  };
}

export const CommuteFilter: MessageFns<CommuteFilter> = {
  encode(message: CommuteFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commuteMethod !== 0) {
      writer.uint32(8).int32(message.commuteMethod);
    }
    if (message.startCoordinates !== undefined) {
      LatLng.encode(message.startCoordinates, writer.uint32(18).fork()).join();
    }
    if (message.travelDuration !== undefined) {
      Duration.encode(message.travelDuration, writer.uint32(26).fork()).join();
    }
    if (message.allowImpreciseAddresses !== false) {
      writer.uint32(32).bool(message.allowImpreciseAddresses);
    }
    if (message.roadTraffic !== undefined) {
      writer.uint32(40).int32(message.roadTraffic);
    }
    if (message.departureTime !== undefined) {
      TimeOfDay.encode(message.departureTime, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommuteFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommuteFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.commuteMethod = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startCoordinates = LatLng.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.travelDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowImpreciseAddresses = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.roadTraffic = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.departureTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommuteFilter {
    return {
      commuteMethod: isSet(object.commuteMethod) ? commuteMethodFromJSON(object.commuteMethod) : 0,
      startCoordinates: isSet(object.startCoordinates) ? LatLng.fromJSON(object.startCoordinates) : undefined,
      travelDuration: isSet(object.travelDuration) ? Duration.fromJSON(object.travelDuration) : undefined,
      allowImpreciseAddresses: isSet(object.allowImpreciseAddresses)
        ? globalThis.Boolean(object.allowImpreciseAddresses)
        : false,
      roadTraffic: isSet(object.roadTraffic) ? commuteFilter_RoadTrafficFromJSON(object.roadTraffic) : undefined,
      departureTime: isSet(object.departureTime) ? TimeOfDay.fromJSON(object.departureTime) : undefined,
    };
  },

  toJSON(message: CommuteFilter): unknown {
    const obj: any = {};
    if (message.commuteMethod !== 0) {
      obj.commuteMethod = commuteMethodToJSON(message.commuteMethod);
    }
    if (message.startCoordinates !== undefined) {
      obj.startCoordinates = LatLng.toJSON(message.startCoordinates);
    }
    if (message.travelDuration !== undefined) {
      obj.travelDuration = Duration.toJSON(message.travelDuration);
    }
    if (message.allowImpreciseAddresses !== false) {
      obj.allowImpreciseAddresses = message.allowImpreciseAddresses;
    }
    if (message.roadTraffic !== undefined) {
      obj.roadTraffic = commuteFilter_RoadTrafficToJSON(message.roadTraffic);
    }
    if (message.departureTime !== undefined) {
      obj.departureTime = TimeOfDay.toJSON(message.departureTime);
    }
    return obj;
  },

  create(base?: DeepPartial<CommuteFilter>): CommuteFilter {
    return CommuteFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommuteFilter>): CommuteFilter {
    const message = createBaseCommuteFilter();
    message.commuteMethod = object.commuteMethod ?? 0;
    message.startCoordinates = (object.startCoordinates !== undefined && object.startCoordinates !== null)
      ? LatLng.fromPartial(object.startCoordinates)
      : undefined;
    message.travelDuration = (object.travelDuration !== undefined && object.travelDuration !== null)
      ? Duration.fromPartial(object.travelDuration)
      : undefined;
    message.allowImpreciseAddresses = object.allowImpreciseAddresses ?? false;
    message.roadTraffic = object.roadTraffic ?? undefined;
    message.departureTime = (object.departureTime !== undefined && object.departureTime !== null)
      ? TimeOfDay.fromPartial(object.departureTime)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
