// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recommendationengine/v1beta1/catalog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FeatureMap } from "./common.js";

export const protobufPackage = "google.cloud.recommendationengine.v1beta1";

/** CatalogItem captures all metadata information of items to be recommended. */
export interface CatalogItem {
  /**
   * Required. Catalog item identifier. UTF-8 encoded string with a length limit
   * of 128 bytes.
   *
   * This id must be unique among all catalog items within the same catalog. It
   * should also be used when logging user events in order for the user events
   * to be joined with the Catalog.
   */
  id: string;
  /**
   * Required. Catalog item categories. This field is repeated for supporting
   * one catalog item belonging to several parallel category hierarchies.
   *
   * For example, if a shoes product belongs to both
   * ["Shoes & Accessories" -> "Shoes"] and
   * ["Sports & Fitness" -> "Athletic Clothing" -> "Shoes"], it could be
   * represented as:
   *
   *      "categoryHierarchies": [
   *        { "categories": ["Shoes & Accessories", "Shoes"]},
   *        { "categories": ["Sports & Fitness", "Athletic Clothing", "Shoes"] }
   *      ]
   */
  categoryHierarchies: CatalogItem_CategoryHierarchy[];
  /**
   * Required. Catalog item title. UTF-8 encoded string with a length limit of 1
   * KiB.
   */
  title: string;
  /**
   * Optional. Catalog item description. UTF-8 encoded string with a length
   * limit of 5 KiB.
   */
  description: string;
  /**
   * Optional. Highly encouraged. Extra catalog item attributes to be
   * included in the recommendation model. For example, for retail products,
   * this could include the store name, vendor, style, color, etc. These are
   * very strong signals for recommendation model, thus we highly recommend
   * providing the item attributes here.
   */
  itemAttributes:
    | FeatureMap
    | undefined;
  /**
   * Optional. Language of the title/description/item_attributes. Use language
   * tags defined by BCP 47. https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Our
   * supported language codes include 'en', 'es', 'fr', 'de', 'ar', 'fa', 'zh',
   * 'ja', 'ko', 'sv', 'ro', 'nl'. For other languages, contact
   * your Google account manager.
   */
  languageCode: string;
  /**
   * Optional. Filtering tags associated with the catalog item. Each tag should
   * be a UTF-8 encoded string with a length limit of 1 KiB.
   *
   * This tag can be used for filtering recommendation results by passing the
   * tag as part of the predict request filter.
   */
  tags: string[];
  /**
   * Optional. Variant group identifier for prediction results. UTF-8 encoded
   * string with a length limit of 128 bytes.
   *
   * This field must be enabled before it can be used. [Learn
   * more](/recommendations-ai/docs/catalog#item-group-id).
   */
  itemGroupId: string;
  /** Optional. Metadata specific to retail products. */
  productMetadata?: ProductCatalogItem | undefined;
}

/** Category represents catalog item category hierarchy. */
export interface CatalogItem_CategoryHierarchy {
  /**
   * Required. Catalog item categories. Each category should be a UTF-8
   * encoded string with a length limit of 2 KiB.
   *
   * Note that the order in the list denotes the specificity (from least to
   * most specific).
   */
  categories: string[];
}

/** ProductCatalogItem captures item metadata specific to retail products. */
export interface ProductCatalogItem {
  /** Optional. The exact product price. */
  exactPrice?:
    | ProductCatalogItem_ExactPrice
    | undefined;
  /** Optional. The product price range. */
  priceRange?:
    | ProductCatalogItem_PriceRange
    | undefined;
  /**
   * Optional. A map to pass the costs associated with the product.
   *
   * For example:
   * {"manufacturing": 45.5} The profit of selling this item is computed like
   * so:
   *
   * * If 'exactPrice' is provided, profit = displayPrice - sum(costs)
   * * If 'priceRange' is provided, profit = minPrice - sum(costs)
   */
  costs: { [key: string]: number };
  /**
   * Optional. Only required if the price is set. Currency code for price/costs. Use
   * three-character ISO-4217 code.
   */
  currencyCode: string;
  /** Optional. Online stock state of the catalog item. Default is `IN_STOCK`. */
  stockState: ProductCatalogItem_StockState;
  /** Optional. The available quantity of the item. */
  availableQuantity: Long;
  /**
   * Optional. Canonical URL directly linking to the item detail page with a
   * length limit of 5 KiB..
   */
  canonicalProductUri: string;
  /** Optional. Product images for the catalog item. */
  images: Image[];
}

/**
 * Item stock state. If this field is unspecified, the item is
 * assumed to be in stock.
 */
export enum ProductCatalogItem_StockState {
  /** STOCK_STATE_UNSPECIFIED - Default item stock status. Should never be used. */
  STOCK_STATE_UNSPECIFIED = 0,
  /** IN_STOCK - Item in stock. */
  IN_STOCK = 0,
  /** OUT_OF_STOCK - Item out of stock. */
  OUT_OF_STOCK = 1,
  /** PREORDER - Item that is in pre-order state. */
  PREORDER = 2,
  /** BACKORDER - Item that is back-ordered (i.e. temporarily out of stock). */
  BACKORDER = 3,
  UNRECOGNIZED = -1,
}

export function productCatalogItem_StockStateFromJSON(object: any): ProductCatalogItem_StockState {
  switch (object) {
    case 0:
    case "STOCK_STATE_UNSPECIFIED":
      return ProductCatalogItem_StockState.STOCK_STATE_UNSPECIFIED;
    case 0:
    case "IN_STOCK":
      return ProductCatalogItem_StockState.IN_STOCK;
    case 1:
    case "OUT_OF_STOCK":
      return ProductCatalogItem_StockState.OUT_OF_STOCK;
    case 2:
    case "PREORDER":
      return ProductCatalogItem_StockState.PREORDER;
    case 3:
    case "BACKORDER":
      return ProductCatalogItem_StockState.BACKORDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProductCatalogItem_StockState.UNRECOGNIZED;
  }
}

export function productCatalogItem_StockStateToJSON(object: ProductCatalogItem_StockState): string {
  switch (object) {
    case ProductCatalogItem_StockState.STOCK_STATE_UNSPECIFIED:
      return "STOCK_STATE_UNSPECIFIED";
    case ProductCatalogItem_StockState.IN_STOCK:
      return "IN_STOCK";
    case ProductCatalogItem_StockState.OUT_OF_STOCK:
      return "OUT_OF_STOCK";
    case ProductCatalogItem_StockState.PREORDER:
      return "PREORDER";
    case ProductCatalogItem_StockState.BACKORDER:
      return "BACKORDER";
    case ProductCatalogItem_StockState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Exact product price. */
export interface ProductCatalogItem_ExactPrice {
  /** Optional. Display price of the product. */
  displayPrice: number;
  /**
   * Optional. Price of the product without any discount. If zero, by default
   * set to be the 'displayPrice'.
   */
  originalPrice: number;
}

/**
 * Product price range when there are a range of prices for different
 * variations of the same product.
 */
export interface ProductCatalogItem_PriceRange {
  /** Required. The minimum product price. */
  min: number;
  /** Required. The maximum product price. */
  max: number;
}

export interface ProductCatalogItem_CostsEntry {
  key: string;
  value: number;
}

/** Catalog item thumbnail/detail image. */
export interface Image {
  /** Required. URL of the image with a length limit of 5 KiB. */
  uri: string;
  /** Optional. Height of the image in number of pixels. */
  height: number;
  /** Optional. Width of the image in number of pixels. */
  width: number;
}

function createBaseCatalogItem(): CatalogItem {
  return {
    id: "",
    categoryHierarchies: [],
    title: "",
    description: "",
    itemAttributes: undefined,
    languageCode: "",
    tags: [],
    itemGroupId: "",
    productMetadata: undefined,
  };
}

export const CatalogItem: MessageFns<CatalogItem> = {
  encode(message: CatalogItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.categoryHierarchies) {
      CatalogItem_CategoryHierarchy.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.itemAttributes !== undefined) {
      FeatureMap.encode(message.itemAttributes, writer.uint32(42).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.itemGroupId !== "") {
      writer.uint32(74).string(message.itemGroupId);
    }
    if (message.productMetadata !== undefined) {
      ProductCatalogItem.encode(message.productMetadata, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.categoryHierarchies.push(CatalogItem_CategoryHierarchy.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.itemAttributes = FeatureMap.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.itemGroupId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.productMetadata = ProductCatalogItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      categoryHierarchies: globalThis.Array.isArray(object?.categoryHierarchies)
        ? object.categoryHierarchies.map((e: any) => CatalogItem_CategoryHierarchy.fromJSON(e))
        : [],
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      itemAttributes: isSet(object.itemAttributes) ? FeatureMap.fromJSON(object.itemAttributes) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      itemGroupId: isSet(object.itemGroupId) ? globalThis.String(object.itemGroupId) : "",
      productMetadata: isSet(object.productMetadata) ? ProductCatalogItem.fromJSON(object.productMetadata) : undefined,
    };
  },

  toJSON(message: CatalogItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.categoryHierarchies?.length) {
      obj.categoryHierarchies = message.categoryHierarchies.map((e) => CatalogItem_CategoryHierarchy.toJSON(e));
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.itemAttributes !== undefined) {
      obj.itemAttributes = FeatureMap.toJSON(message.itemAttributes);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.itemGroupId !== "") {
      obj.itemGroupId = message.itemGroupId;
    }
    if (message.productMetadata !== undefined) {
      obj.productMetadata = ProductCatalogItem.toJSON(message.productMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogItem>): CatalogItem {
    return CatalogItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CatalogItem>): CatalogItem {
    const message = createBaseCatalogItem();
    message.id = object.id ?? "";
    message.categoryHierarchies =
      object.categoryHierarchies?.map((e) => CatalogItem_CategoryHierarchy.fromPartial(e)) || [];
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.itemAttributes = (object.itemAttributes !== undefined && object.itemAttributes !== null)
      ? FeatureMap.fromPartial(object.itemAttributes)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.itemGroupId = object.itemGroupId ?? "";
    message.productMetadata = (object.productMetadata !== undefined && object.productMetadata !== null)
      ? ProductCatalogItem.fromPartial(object.productMetadata)
      : undefined;
    return message;
  },
};

function createBaseCatalogItem_CategoryHierarchy(): CatalogItem_CategoryHierarchy {
  return { categories: [] };
}

export const CatalogItem_CategoryHierarchy: MessageFns<CatalogItem_CategoryHierarchy> = {
  encode(message: CatalogItem_CategoryHierarchy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.categories) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogItem_CategoryHierarchy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogItem_CategoryHierarchy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categories.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogItem_CategoryHierarchy {
    return {
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CatalogItem_CategoryHierarchy): unknown {
    const obj: any = {};
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogItem_CategoryHierarchy>): CatalogItem_CategoryHierarchy {
    return CatalogItem_CategoryHierarchy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CatalogItem_CategoryHierarchy>): CatalogItem_CategoryHierarchy {
    const message = createBaseCatalogItem_CategoryHierarchy();
    message.categories = object.categories?.map((e) => e) || [];
    return message;
  },
};

function createBaseProductCatalogItem(): ProductCatalogItem {
  return {
    exactPrice: undefined,
    priceRange: undefined,
    costs: {},
    currencyCode: "",
    stockState: 0,
    availableQuantity: Long.ZERO,
    canonicalProductUri: "",
    images: [],
  };
}

export const ProductCatalogItem: MessageFns<ProductCatalogItem> = {
  encode(message: ProductCatalogItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactPrice !== undefined) {
      ProductCatalogItem_ExactPrice.encode(message.exactPrice, writer.uint32(10).fork()).join();
    }
    if (message.priceRange !== undefined) {
      ProductCatalogItem_PriceRange.encode(message.priceRange, writer.uint32(18).fork()).join();
    }
    Object.entries(message.costs).forEach(([key, value]) => {
      ProductCatalogItem_CostsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.currencyCode !== "") {
      writer.uint32(34).string(message.currencyCode);
    }
    if (message.stockState !== 0) {
      writer.uint32(40).int32(message.stockState);
    }
    if (!message.availableQuantity.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.availableQuantity.toString());
    }
    if (message.canonicalProductUri !== "") {
      writer.uint32(58).string(message.canonicalProductUri);
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCatalogItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCatalogItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exactPrice = ProductCatalogItem_ExactPrice.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.priceRange = ProductCatalogItem_PriceRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ProductCatalogItem_CostsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.costs[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stockState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.availableQuantity = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.canonicalProductUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCatalogItem {
    return {
      exactPrice: isSet(object.exactPrice) ? ProductCatalogItem_ExactPrice.fromJSON(object.exactPrice) : undefined,
      priceRange: isSet(object.priceRange) ? ProductCatalogItem_PriceRange.fromJSON(object.priceRange) : undefined,
      costs: isObject(object.costs)
        ? Object.entries(object.costs).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      stockState: isSet(object.stockState) ? productCatalogItem_StockStateFromJSON(object.stockState) : 0,
      availableQuantity: isSet(object.availableQuantity) ? Long.fromValue(object.availableQuantity) : Long.ZERO,
      canonicalProductUri: isSet(object.canonicalProductUri) ? globalThis.String(object.canonicalProductUri) : "",
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => Image.fromJSON(e)) : [],
    };
  },

  toJSON(message: ProductCatalogItem): unknown {
    const obj: any = {};
    if (message.exactPrice !== undefined) {
      obj.exactPrice = ProductCatalogItem_ExactPrice.toJSON(message.exactPrice);
    }
    if (message.priceRange !== undefined) {
      obj.priceRange = ProductCatalogItem_PriceRange.toJSON(message.priceRange);
    }
    if (message.costs) {
      const entries = Object.entries(message.costs);
      if (entries.length > 0) {
        obj.costs = {};
        entries.forEach(([k, v]) => {
          obj.costs[k] = v;
        });
      }
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.stockState !== 0) {
      obj.stockState = productCatalogItem_StockStateToJSON(message.stockState);
    }
    if (!message.availableQuantity.equals(Long.ZERO)) {
      obj.availableQuantity = (message.availableQuantity || Long.ZERO).toString();
    }
    if (message.canonicalProductUri !== "") {
      obj.canonicalProductUri = message.canonicalProductUri;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCatalogItem>): ProductCatalogItem {
    return ProductCatalogItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCatalogItem>): ProductCatalogItem {
    const message = createBaseProductCatalogItem();
    message.exactPrice = (object.exactPrice !== undefined && object.exactPrice !== null)
      ? ProductCatalogItem_ExactPrice.fromPartial(object.exactPrice)
      : undefined;
    message.priceRange = (object.priceRange !== undefined && object.priceRange !== null)
      ? ProductCatalogItem_PriceRange.fromPartial(object.priceRange)
      : undefined;
    message.costs = Object.entries(object.costs ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.currencyCode = object.currencyCode ?? "";
    message.stockState = object.stockState ?? 0;
    message.availableQuantity = (object.availableQuantity !== undefined && object.availableQuantity !== null)
      ? Long.fromValue(object.availableQuantity)
      : Long.ZERO;
    message.canonicalProductUri = object.canonicalProductUri ?? "";
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProductCatalogItem_ExactPrice(): ProductCatalogItem_ExactPrice {
  return { displayPrice: 0, originalPrice: 0 };
}

export const ProductCatalogItem_ExactPrice: MessageFns<ProductCatalogItem_ExactPrice> = {
  encode(message: ProductCatalogItem_ExactPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayPrice !== 0) {
      writer.uint32(13).float(message.displayPrice);
    }
    if (message.originalPrice !== 0) {
      writer.uint32(21).float(message.originalPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCatalogItem_ExactPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCatalogItem_ExactPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.displayPrice = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCatalogItem_ExactPrice {
    return {
      displayPrice: isSet(object.displayPrice) ? globalThis.Number(object.displayPrice) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : 0,
    };
  },

  toJSON(message: ProductCatalogItem_ExactPrice): unknown {
    const obj: any = {};
    if (message.displayPrice !== 0) {
      obj.displayPrice = message.displayPrice;
    }
    if (message.originalPrice !== 0) {
      obj.originalPrice = message.originalPrice;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCatalogItem_ExactPrice>): ProductCatalogItem_ExactPrice {
    return ProductCatalogItem_ExactPrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCatalogItem_ExactPrice>): ProductCatalogItem_ExactPrice {
    const message = createBaseProductCatalogItem_ExactPrice();
    message.displayPrice = object.displayPrice ?? 0;
    message.originalPrice = object.originalPrice ?? 0;
    return message;
  },
};

function createBaseProductCatalogItem_PriceRange(): ProductCatalogItem_PriceRange {
  return { min: 0, max: 0 };
}

export const ProductCatalogItem_PriceRange: MessageFns<ProductCatalogItem_PriceRange> = {
  encode(message: ProductCatalogItem_PriceRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(13).float(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(21).float(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCatalogItem_PriceRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCatalogItem_PriceRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.min = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.max = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCatalogItem_PriceRange {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
    };
  },

  toJSON(message: ProductCatalogItem_PriceRange): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCatalogItem_PriceRange>): ProductCatalogItem_PriceRange {
    return ProductCatalogItem_PriceRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCatalogItem_PriceRange>): ProductCatalogItem_PriceRange {
    const message = createBaseProductCatalogItem_PriceRange();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseProductCatalogItem_CostsEntry(): ProductCatalogItem_CostsEntry {
  return { key: "", value: 0 };
}

export const ProductCatalogItem_CostsEntry: MessageFns<ProductCatalogItem_CostsEntry> = {
  encode(message: ProductCatalogItem_CostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductCatalogItem_CostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductCatalogItem_CostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductCatalogItem_CostsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ProductCatalogItem_CostsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductCatalogItem_CostsEntry>): ProductCatalogItem_CostsEntry {
    return ProductCatalogItem_CostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductCatalogItem_CostsEntry>): ProductCatalogItem_CostsEntry {
    const message = createBaseProductCatalogItem_CostsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseImage(): Image {
  return { uri: "", height: 0, width: 0 };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    return obj;
  },

  create(base?: DeepPartial<Image>): Image {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Image>): Image {
    const message = createBaseImage();
    message.uri = object.uri ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
