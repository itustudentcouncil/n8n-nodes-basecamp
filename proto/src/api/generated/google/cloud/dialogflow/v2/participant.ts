// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/v2/participant.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct, Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { InputAudioConfig, OutputAudioConfig, TelephonyDtmfEvents } from "./audio_config.js";
import {
  CloudConversationDebuggingInfo,
  DetectIntentResponse,
  EventInput,
  QueryParameters,
  QueryResult,
  SentimentAnalysisResult,
  StreamingRecognitionResult,
  TextInput,
} from "./session.js";

export const protobufPackage = "google.cloud.dialogflow.v2";

/** Represents a conversation participant (human agent, virtual agent, end-user). */
export interface Participant {
  /**
   * Optional. The unique identifier of this participant.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  name: string;
  /**
   * Immutable. The role this participant plays in the conversation. This field
   * must be set during participant creation and is then immutable.
   */
  role: Participant_Role;
  /**
   * Optional. Label applied to streams representing this participant in SIPREC
   * XML metadata and SDP. This is used to assign transcriptions from that
   * media stream to this participant. This field can be updated.
   */
  sipRecordingMediaLabel: string;
  /**
   * Optional. Obfuscated user id that should be associated with the created
   * participant.
   *
   * You can specify a user id as follows:
   *
   * 1. If you set this field in
   *    [CreateParticipantRequest][google.cloud.dialogflow.v2.CreateParticipantRequest.participant]
   *    or
   *    [UpdateParticipantRequest][google.cloud.dialogflow.v2.UpdateParticipantRequest.participant],
   *    Dialogflow adds the obfuscated user id with the participant.
   *
   * 2. If you set this field in
   *    [AnalyzeContent][google.cloud.dialogflow.v2.AnalyzeContentRequest.obfuscated_external_user_id]
   *    or
   *    [StreamingAnalyzeContent][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.obfuscated_external_user_id],
   *    Dialogflow will update
   *    [Participant.obfuscated_external_user_id][google.cloud.dialogflow.v2.Participant.obfuscated_external_user_id].
   *
   * Dialogflow returns an error if you try to add a user id for a
   * non-[END_USER][google.cloud.dialogflow.v2.Participant.Role.END_USER]
   * participant.
   *
   * Dialogflow uses this user id for billing and measurement purposes. For
   * example, Dialogflow determines whether a user in one conversation returned
   * in a later conversation.
   *
   * Note:
   *
   * * Please never pass raw user ids to Dialogflow. Always obfuscate your user
   *   id first.
   * * Dialogflow only accepts a UTF-8 encoded string, e.g., a hex digest of a
   *   hash function like SHA-512.
   * * The length of the user id must be <= 256 characters.
   */
  obfuscatedExternalUserId: string;
  /**
   * Optional. Key-value filters on the metadata of documents returned by
   * article suggestion. If specified, article suggestion only returns suggested
   * documents that match all filters in their
   * [Document.metadata][google.cloud.dialogflow.v2.Document.metadata]. Multiple
   * values for a metadata key should be concatenated by comma. For example,
   * filters to match all documents that have 'US' or 'CA' in their market
   * metadata values and 'agent' in their user metadata values will be
   * ```
   * documents_metadata_filters {
   *   key: "market"
   *   value: "US,CA"
   * }
   * documents_metadata_filters {
   *   key: "user"
   *   value: "agent"
   * }
   * ```
   */
  documentsMetadataFilters: { [key: string]: string };
}

/** Enumeration of the roles a participant can play in a conversation. */
export enum Participant_Role {
  /** ROLE_UNSPECIFIED - Participant role not set. */
  ROLE_UNSPECIFIED = 0,
  /** HUMAN_AGENT - Participant is a human agent. */
  HUMAN_AGENT = 1,
  /** AUTOMATED_AGENT - Participant is an automated agent, such as a Dialogflow agent. */
  AUTOMATED_AGENT = 2,
  /**
   * END_USER - Participant is an end user that has called or chatted with
   * Dialogflow services.
   */
  END_USER = 3,
  UNRECOGNIZED = -1,
}

export function participant_RoleFromJSON(object: any): Participant_Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return Participant_Role.ROLE_UNSPECIFIED;
    case 1:
    case "HUMAN_AGENT":
      return Participant_Role.HUMAN_AGENT;
    case 2:
    case "AUTOMATED_AGENT":
      return Participant_Role.AUTOMATED_AGENT;
    case 3:
    case "END_USER":
      return Participant_Role.END_USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Participant_Role.UNRECOGNIZED;
  }
}

export function participant_RoleToJSON(object: Participant_Role): string {
  switch (object) {
    case Participant_Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case Participant_Role.HUMAN_AGENT:
      return "HUMAN_AGENT";
    case Participant_Role.AUTOMATED_AGENT:
      return "AUTOMATED_AGENT";
    case Participant_Role.END_USER:
      return "END_USER";
    case Participant_Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Participant_DocumentsMetadataFiltersEntry {
  key: string;
  value: string;
}

/** Represents a message posted into a conversation. */
export interface Message {
  /**
   * Optional. The unique identifier of the message.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  name: string;
  /** Required. The message content. */
  content: string;
  /**
   * Optional. The message language.
   * This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag. Example: "en-US".
   */
  languageCode: string;
  /** Output only. The participant that sends this message. */
  participant: string;
  /** Output only. The role of the participant. */
  participantRole: Participant_Role;
  /** Output only. The time when the message was created in Contact Center AI. */
  createTime:
    | Date
    | undefined;
  /** Optional. The time when the message was sent. */
  sendTime:
    | Date
    | undefined;
  /** Output only. The annotation for the message. */
  messageAnnotation:
    | MessageAnnotation
    | undefined;
  /** Output only. The sentiment analysis result for the message. */
  sentimentAnalysis: SentimentAnalysisResult | undefined;
}

/**
 * The request message for
 * [Participants.CreateParticipant][google.cloud.dialogflow.v2.Participants.CreateParticipant].
 */
export interface CreateParticipantRequest {
  /**
   * Required. Resource identifier of the conversation adding the participant.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  parent: string;
  /** Required. The participant to create. */
  participant: Participant | undefined;
}

/**
 * The request message for
 * [Participants.GetParticipant][google.cloud.dialogflow.v2.Participants.GetParticipant].
 */
export interface GetParticipantRequest {
  /**
   * Required. The name of the participant. Format:
   * `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
   * ID>/participants/<Participant ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Participants.ListParticipants][google.cloud.dialogflow.v2.Participants.ListParticipants].
 */
export interface ListParticipantsRequest {
  /**
   * Required. The conversation to list all participants from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  parent: string;
  /**
   * Optional. The maximum number of items to return in a single page. By
   * default 100 and at most 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Participants.ListParticipants][google.cloud.dialogflow.v2.Participants.ListParticipants].
 */
export interface ListParticipantsResponse {
  /**
   * The list of participants. There is a maximum number of items
   * returned based on the page_size field in the request.
   */
  participants: Participant[];
  /**
   * Token to retrieve the next page of results or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Participants.UpdateParticipant][google.cloud.dialogflow.v2.Participants.UpdateParticipant].
 */
export interface UpdateParticipantRequest {
  /** Required. The participant to update. */
  participant:
    | Participant
    | undefined;
  /** Required. The mask to specify which fields to update. */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent].
 */
export interface AnalyzeContentRequest {
  /**
   * Required. The name of the participant this text comes from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  participant: string;
  /** The natural language text to be processed. */
  textInput?:
    | TextInput
    | undefined;
  /** An input event to send to Dialogflow. */
  eventInput?:
    | EventInput
    | undefined;
  /** An input representing the selection of a suggestion. */
  suggestionInput?:
    | SuggestionInput
    | undefined;
  /**
   * Speech synthesis configuration.
   * The speech synthesis settings for a virtual agent that may be configured
   * for the associated conversation profile are not used when calling
   * AnalyzeContent. If this configuration is not supplied, speech synthesis
   * is disabled.
   */
  replyAudioConfig:
    | OutputAudioConfig
    | undefined;
  /** Parameters for a Dialogflow virtual-agent query. */
  queryParams:
    | QueryParameters
    | undefined;
  /** Parameters for a human assist query. */
  assistQueryParams:
    | AssistQueryParameters
    | undefined;
  /**
   * Additional parameters to be put into Dialogflow CX session parameters. To
   * remove a parameter from the session, clients should explicitly set the
   * parameter value to null.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended.
   * This request is only idempotent if a `request_id` is provided.
   */
  requestId: string;
}

/** The message in the response that indicates the parameters of DTMF. */
export interface DtmfParameters {
  /** Indicates whether DTMF input can be handled in the next request. */
  acceptsDtmfInput: boolean;
}

/**
 * The response message for
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent].
 */
export interface AnalyzeContentResponse {
  /**
   * The output text content.
   * This field is set if the automated agent responded with text to show to
   * the user.
   */
  replyText: string;
  /**
   * The audio data bytes encoded as specified in the request.
   * This field is set if:
   *
   *  - `reply_audio_config` was specified in the request, or
   *  - The automated agent responded with audio to play to the user. In such
   *    case, `reply_audio.config` contains settings used to synthesize the
   *    speech.
   *
   * In some scenarios, multiple output audio fields may be present in the
   * response structure. In these cases, only the top-most-level audio output
   * has content.
   */
  replyAudio:
    | OutputAudio
    | undefined;
  /**
   * Only set if a Dialogflow automated agent has responded.
   * Note that: [AutomatedAgentReply.detect_intent_response.output_audio][]
   * and [AutomatedAgentReply.detect_intent_response.output_audio_config][]
   * are always empty, use
   * [reply_audio][google.cloud.dialogflow.v2.AnalyzeContentResponse.reply_audio]
   * instead.
   */
  automatedAgentReply:
    | AutomatedAgentReply
    | undefined;
  /** Message analyzed by CCAI. */
  message:
    | Message
    | undefined;
  /**
   * The suggestions for most recent human agent. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config].
   *
   * Note that any failure of Agent Assist features will not lead to the overall
   * failure of an AnalyzeContent API call. Instead, the features will
   * fail silently with the error field set in the corresponding
   * SuggestionResult.
   */
  humanAgentSuggestionResults: SuggestionResult[];
  /**
   * The suggestions for end user. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config].
   *
   * Same as human_agent_suggestion_results, any failure of Agent Assist
   * features will not lead to the overall failure of an AnalyzeContent API
   * call. Instead, the features will fail silently with the error field set in
   * the corresponding SuggestionResult.
   */
  endUserSuggestionResults: SuggestionResult[];
  /** Indicates the parameters of DTMF. */
  dtmfParameters: DtmfParameters | undefined;
}

/**
 * The top-level message sent by the client to the
 * [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2.Participants.StreamingAnalyzeContent]
 * method.
 *
 * Multiple request messages should be sent in order:
 *
 * 1.  The first message must contain
 *     [participant][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.participant],
 *     [config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config]
 *     and optionally
 *     [query_params][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.query_params].
 *     If you want to receive an audio response, it should also contain
 *     [reply_audio_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.reply_audio_config].
 *     The message must not contain
 *     [input][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input].
 *
 * 2.  If
 * [config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config] in
 * the first message
 *     was set to
 *     [audio_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.audio_config],
 *     all subsequent messages must contain
 *     [input_audio][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_audio]
 *     to continue with Speech recognition. However, note that:
 *
 *     * Dialogflow will bill you for the audio so far.
 *     * Dialogflow discards all Speech recognition results in favor of the
 *       text input.
 *
 *  3. If
 *  [StreamingAnalyzeContentRequest.config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config]
 *  in the first message was set
 *    to
 *    [StreamingAnalyzeContentRequest.text_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.text_config],
 *    then the second message must contain only
 *    [input_text][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_text].
 *    Moreover, you must not send more than two messages.
 *
 *  After you sent all input, you must half-close or abort the request stream.
 */
export interface StreamingAnalyzeContentRequest {
  /**
   * Required. The name of the participant this text comes from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  participant: string;
  /** Instructs the speech recognizer how to process the speech audio. */
  audioConfig?:
    | InputAudioConfig
    | undefined;
  /** The natural language text to be processed. */
  textConfig?:
    | InputTextConfig
    | undefined;
  /**
   * Speech synthesis configuration.
   * The speech synthesis settings for a virtual agent that may be configured
   * for the associated conversation profile are not used when calling
   * StreamingAnalyzeContent. If this configuration is not supplied, speech
   * synthesis is disabled.
   */
  replyAudioConfig:
    | OutputAudioConfig
    | undefined;
  /**
   * The input audio content to be recognized. Must be sent if `audio_config`
   * is set in the first message. The complete audio over all streaming
   * messages must not exceed 1 minute.
   */
  inputAudio?:
    | Buffer
    | undefined;
  /**
   * The UTF-8 encoded natural language text to be processed. Must be sent if
   * `text_config` is set in the first message. Text length must not exceed
   * 256 bytes for virtual agent interactions. The `input_text` field can be
   * only sent once, and would cancel the speech recognition if any ongoing.
   */
  inputText?:
    | string
    | undefined;
  /**
   * The DTMF digits used to invoke intent and fill in parameter value.
   *
   * This input is ignored if the previous response indicated that DTMF input
   * is not accepted.
   */
  inputDtmf?:
    | TelephonyDtmfEvents
    | undefined;
  /** Parameters for a Dialogflow virtual-agent query. */
  queryParams:
    | QueryParameters
    | undefined;
  /** Parameters for a human assist query. */
  assistQueryParams:
    | AssistQueryParameters
    | undefined;
  /**
   * Additional parameters to be put into Dialogflow CX session parameters. To
   * remove a parameter from the session, clients should explicitly set the
   * parameter value to null.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional. Enable full bidirectional streaming. You can keep streaming the
   * audio until timeout, and there's no need to half close the stream to get
   * the response.
   *
   * Restrictions:
   *
   * - Timeout: 3 mins.
   * - Audio Encoding: only supports
   * [AudioEncoding.AUDIO_ENCODING_LINEAR_16][google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_LINEAR_16]
   * and
   * [AudioEncoding.AUDIO_ENCODING_MULAW][google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_MULAW]
   * - Lifecycle: conversation should be in `Assist Stage`, go to
   *   [Conversation.CreateConversation][] for more information.
   *
   * InvalidArgument Error will be returned if the one of restriction checks
   * failed.
   *
   * You can find more details in
   * https://cloud.google.com/agent-assist/docs/extended-streaming
   */
  enableExtendedStreaming: boolean;
  /**
   * Enable partial virtual agent responses. If this flag is not enabled,
   * response stream still contains only one final response even if some
   * `Fulfillment`s in Dialogflow virtual agent have been configured to return
   * partial responses.
   */
  enablePartialAutomatedAgentReply: boolean;
  /**
   * If true, `StreamingAnalyzeContentResponse.debugging_info` will get
   * populated.
   */
  enableDebuggingInfo: boolean;
}

/**
 * The top-level message returned from the `StreamingAnalyzeContent` method.
 *
 * Multiple response messages can be returned in order:
 *
 * 1.  If the input was set to streaming audio, the first one or more messages
 *     contain `recognition_result`. Each `recognition_result` represents a more
 *     complete transcript of what the user said. The last `recognition_result`
 *     has `is_final` set to `true`.
 *
 * 2.  In virtual agent stage: if `enable_partial_automated_agent_reply` is
 *     true, the following N (currently 1 <= N <= 4) messages
 *     contain `automated_agent_reply` and optionally `reply_audio`
 *     returned by the virtual agent. The first (N-1)
 *     `automated_agent_reply`s will have `automated_agent_reply_type` set to
 *     `PARTIAL`. The last `automated_agent_reply` has
 *     `automated_agent_reply_type` set to `FINAL`.
 *     If `enable_partial_automated_agent_reply` is not enabled, response stream
 *     only contains the final reply.
 *
 *     In human assist stage: the following N (N >= 1) messages contain
 *     `human_agent_suggestion_results`, `end_user_suggestion_results` or
 *     `message`.
 */
export interface StreamingAnalyzeContentResponse {
  /** The result of speech recognition. */
  recognitionResult:
    | StreamingRecognitionResult
    | undefined;
  /**
   * The output text content.
   * This field is set if an automated agent responded with a text for the user.
   */
  replyText: string;
  /**
   * The audio data bytes encoded as specified in the request.
   * This field is set if:
   *
   *  - The `reply_audio_config` field is specified in the request.
   *  - The automated agent, which this output comes from, responded with audio.
   *    In such case, the `reply_audio.config` field contains settings used to
   *    synthesize the speech.
   *
   * In some scenarios, multiple output audio fields may be present in the
   * response structure. In these cases, only the top-most-level audio output
   * has content.
   */
  replyAudio:
    | OutputAudio
    | undefined;
  /**
   * Only set if a Dialogflow automated agent has responded.
   * Note that: [AutomatedAgentReply.detect_intent_response.output_audio][]
   * and [AutomatedAgentReply.detect_intent_response.output_audio_config][]
   * are always empty, use
   * [reply_audio][google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse.reply_audio]
   * instead.
   */
  automatedAgentReply:
    | AutomatedAgentReply
    | undefined;
  /** Message analyzed by CCAI. */
  message:
    | Message
    | undefined;
  /**
   * The suggestions for most recent human agent. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config].
   */
  humanAgentSuggestionResults: SuggestionResult[];
  /**
   * The suggestions for end user. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config].
   */
  endUserSuggestionResults: SuggestionResult[];
  /** Indicates the parameters of DTMF. */
  dtmfParameters:
    | DtmfParameters
    | undefined;
  /**
   * Debugging info that would get populated when
   * `StreamingAnalyzeContentRequest.enable_debugging_info` is set to true.
   */
  debuggingInfo: CloudConversationDebuggingInfo | undefined;
}

/**
 * The request message for
 * [Participants.SuggestArticles][google.cloud.dialogflow.v2.Participants.SuggestArticles].
 */
export interface SuggestArticlesRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestArticlesRequest.latest_message]
   * to use as context when compiling the suggestion. By default 20 and at
   * most 50.
   */
  contextSize: number;
  /** Parameters for a human assist query. */
  assistQueryParams: AssistQueryParameters | undefined;
}

/**
 * The response message for
 * [Participants.SuggestArticles][google.cloud.dialogflow.v2.Participants.SuggestArticles].
 */
export interface SuggestArticlesResponse {
  /** Articles ordered by score in descending order. */
  articleAnswers: ArticleAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestArticlesResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestArticlesRequest.context_size][google.cloud.dialogflow.v2.SuggestArticlesRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * The request message for
 * [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers].
 */
export interface SuggestFaqAnswersRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 20 and at most 50.
   */
  contextSize: number;
  /** Parameters for a human assist query. */
  assistQueryParams: AssistQueryParameters | undefined;
}

/**
 * The request message for
 * [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers].
 */
export interface SuggestFaqAnswersResponse {
  /** Answers extracted from FAQ documents. */
  faqAnswers: FaqAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestFaqAnswersResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestFaqAnswersRequest.context_size][google.cloud.dialogflow.v2.SuggestFaqAnswersRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * The request message for
 * [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2.Participants.SuggestSmartReplies].
 */
export interface SuggestSmartRepliesRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * The current natural language text segment to compile suggestion
   * for. This provides a way for user to get follow up smart reply suggestion
   * after a smart reply selection, without sending a text message.
   */
  currentTextInput:
    | TextInput
    | undefined;
  /**
   * The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 20 and at most 50.
   */
  contextSize: number;
}

/**
 * The response message for
 * [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2.Participants.SuggestSmartReplies].
 */
export interface SuggestSmartRepliesResponse {
  /**
   * Output only. Multiple reply options provided by smart reply service. The
   * order is based on the rank of the model prediction.
   * The maximum number of the returned replies is set in SmartReplyConfig.
   */
  smartReplyAnswers: SmartReplyAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestSmartRepliesResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestSmartRepliesRequest.context_size][google.cloud.dialogflow.v2.SuggestSmartRepliesRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/** Represents the natural language speech audio to be played to the end user. */
export interface OutputAudio {
  /**
   * Instructs the speech synthesizer how to generate the speech
   * audio.
   */
  config:
    | OutputAudioConfig
    | undefined;
  /** The natural language speech audio. */
  audio: Buffer;
}

/** Represents a response from an automated agent. */
export interface AutomatedAgentReply {
  /**
   * Response of the Dialogflow
   * [Sessions.DetectIntent][google.cloud.dialogflow.v2.Sessions.DetectIntent]
   * call.
   */
  detectIntentResponse:
    | DetectIntentResponse
    | undefined;
  /** AutomatedAgentReply type. */
  automatedAgentReplyType: AutomatedAgentReply_AutomatedAgentReplyType;
  /**
   * Indicates whether the partial automated agent reply is interruptible when a
   * later reply message arrives. e.g. if the agent specified some music as
   * partial response, it can be cancelled.
   */
  allowCancellation: boolean;
  /**
   * The unique identifier of the current Dialogflow CX conversation page.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  cxCurrentPage: string;
}

/** Represents different automated agent reply types. */
export enum AutomatedAgentReply_AutomatedAgentReplyType {
  /** AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED - Not specified. This should never happen. */
  AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED = 0,
  /**
   * PARTIAL - Partial reply. e.g. Aggregated responses in a `Fulfillment` that enables
   * `return_partial_response` can be returned as partial reply.
   * WARNING: partial reply is not eligible for barge-in.
   */
  PARTIAL = 1,
  /** FINAL - Final reply. */
  FINAL = 2,
  UNRECOGNIZED = -1,
}

export function automatedAgentReply_AutomatedAgentReplyTypeFromJSON(
  object: any,
): AutomatedAgentReply_AutomatedAgentReplyType {
  switch (object) {
    case 0:
    case "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED":
      return AutomatedAgentReply_AutomatedAgentReplyType.AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED;
    case 1:
    case "PARTIAL":
      return AutomatedAgentReply_AutomatedAgentReplyType.PARTIAL;
    case 2:
    case "FINAL":
      return AutomatedAgentReply_AutomatedAgentReplyType.FINAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomatedAgentReply_AutomatedAgentReplyType.UNRECOGNIZED;
  }
}

export function automatedAgentReply_AutomatedAgentReplyTypeToJSON(
  object: AutomatedAgentReply_AutomatedAgentReplyType,
): string {
  switch (object) {
    case AutomatedAgentReply_AutomatedAgentReplyType.AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED:
      return "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED";
    case AutomatedAgentReply_AutomatedAgentReplyType.PARTIAL:
      return "PARTIAL";
    case AutomatedAgentReply_AutomatedAgentReplyType.FINAL:
      return "FINAL";
    case AutomatedAgentReply_AutomatedAgentReplyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents article answer. */
export interface ArticleAnswer {
  /** The article title. */
  title: string;
  /** The article URI. */
  uri: string;
  /** Article snippets. */
  snippets: string[];
  /**
   * Article match confidence.
   * The system's confidence score that this article is a good match for this
   * conversation, as a value from 0.0 (completely uncertain) to 1.0
   * (completely certain).
   */
  confidence: number;
  /**
   * A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

export interface ArticleAnswer_MetadataEntry {
  key: string;
  value: string;
}

/** Represents answer from "frequently asked questions". */
export interface FaqAnswer {
  /** The piece of text from the `source` knowledge base document. */
  answer: string;
  /**
   * The system's confidence score that this Knowledge answer is a good match
   * for this conversational query, range from 0.0 (completely uncertain)
   * to 1.0 (completely certain).
   */
  confidence: number;
  /** The corresponding FAQ question. */
  question: string;
  /**
   * Indicates which Knowledge Document this answer was extracted
   * from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/agent/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
   */
  source: string;
  /**
   * A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

export interface FaqAnswer_MetadataEntry {
  key: string;
  value: string;
}

/** Represents a smart reply answer. */
export interface SmartReplyAnswer {
  /** The content of the reply. */
  reply: string;
  /**
   * Smart reply confidence.
   * The system's confidence score that this reply is a good match for
   * this conversation, as a value from 0.0 (completely uncertain) to 1.0
   * (completely certain).
   */
  confidence: number;
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

/** Represents an intent suggestion. */
export interface IntentSuggestion {
  /** The display name of the intent. */
  displayName: string;
  /**
   * The unique identifier of this
   * [intent][google.cloud.dialogflow.v2.Intent]. Format: `projects/<Project
   * ID>/locations/<Location ID>/agent/intents/<Intent ID>`.
   */
  intentV2?:
    | string
    | undefined;
  /**
   * Human readable description for better understanding an intent like its
   * scope, content, result etc. Maximum character limit: 140 characters.
   */
  description: string;
}

/** Represents a Dialogflow assist answer. */
export interface DialogflowAssistAnswer {
  /** Result from v2 agent. */
  queryResult?:
    | QueryResult
    | undefined;
  /** An intent suggestion generated from conversation. */
  intentSuggestion?:
    | IntentSuggestion
    | undefined;
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

/**
 * One response of different type of suggestion response which is used in
 * the response of
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent]
 * and
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent],
 * as well as
 * [HumanAgentAssistantEvent][google.cloud.dialogflow.v2.HumanAgentAssistantEvent].
 */
export interface SuggestionResult {
  /** Error status if the request failed. */
  error?:
    | Status
    | undefined;
  /** SuggestArticlesResponse if request is for ARTICLE_SUGGESTION. */
  suggestArticlesResponse?:
    | SuggestArticlesResponse
    | undefined;
  /** SuggestKnowledgeAssistResponse if request is for KNOWLEDGE_ASSIST. */
  suggestKnowledgeAssistResponse?:
    | SuggestKnowledgeAssistResponse
    | undefined;
  /** SuggestFaqAnswersResponse if request is for FAQ_ANSWER. */
  suggestFaqAnswersResponse?:
    | SuggestFaqAnswersResponse
    | undefined;
  /** SuggestSmartRepliesResponse if request is for SMART_REPLY. */
  suggestSmartRepliesResponse?: SuggestSmartRepliesResponse | undefined;
}

/** Defines the language used in the input text. */
export interface InputTextConfig {
  /**
   * Required. The language of this conversational query. See [Language
   * Support](https://cloud.google.com/dialogflow/docs/reference/language)
   * for a list of the currently supported language codes.
   */
  languageCode: string;
}

/**
 * Represents a part of a message possibly annotated with an entity. The part
 * can be an entity or purely a part of the message between two entities or
 * message start/end.
 */
export interface AnnotatedMessagePart {
  /** A part of a message possibly annotated with an entity. */
  text: string;
  /**
   * The [Dialogflow system entity
   * type](https://cloud.google.com/dialogflow/docs/reference/system-entities)
   * of this message part. If this is empty, Dialogflow could not annotate the
   * phrase part with a system entity.
   */
  entityType: string;
  /**
   * The [Dialogflow system entity formatted value
   * ](https://cloud.google.com/dialogflow/docs/reference/system-entities) of
   * this message part. For example for a system entity of type
   * `@sys.unit-currency`, this may contain:
   * <pre>
   * {
   *   "amount": 5,
   *   "currency": "USD"
   * }
   * </pre>
   */
  formattedValue: any | undefined;
}

/** Represents the result of annotation for the message. */
export interface MessageAnnotation {
  /**
   * The collection of annotated message parts ordered by their
   * position in the message. You can recover the annotated message by
   * concatenating [AnnotatedMessagePart.text].
   */
  parts: AnnotatedMessagePart[];
  /** Indicates whether the text message contains entities. */
  containEntities: boolean;
}

/** Represents the selection of a suggestion. */
export interface SuggestionInput {
  /**
   * Required. The ID of a suggestion selected by the human agent.
   * The suggestion(s) were generated in a previous call to
   * request Dialogflow assist.
   * The format is:
   * `projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>` where <Answer Record ID> is an alphanumeric string.
   */
  answerRecord: string;
}

/** Represents the parameters of human assist query. */
export interface AssistQueryParameters {
  /**
   * Key-value filters on the metadata of documents returned by article
   * suggestion. If specified, article suggestion only returns suggested
   * documents that match all filters in their
   * [Document.metadata][google.cloud.dialogflow.v2.Document.metadata]. Multiple
   * values for a metadata key should be concatenated by comma. For example,
   * filters to match all documents that have 'US' or 'CA' in their market
   * metadata values and 'agent' in their user metadata values will be
   * ```
   * documents_metadata_filters {
   *   key: "market"
   *   value: "US,CA"
   * }
   * documents_metadata_filters {
   *   key: "user"
   *   value: "agent"
   * }
   * ```
   */
  documentsMetadataFilters: { [key: string]: string };
}

export interface AssistQueryParameters_DocumentsMetadataFiltersEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
 */
export interface SuggestKnowledgeAssistRequest {
  /**
   * Required. The name of the participant to fetch suggestions for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile
   * suggestions for. If empty, it will be the latest message of the
   * conversation. Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.latest_message]
   * to use as context when compiling the suggestion. The context size is by
   * default 100 and at most 100.
   */
  contextSize: number;
  /**
   * Optional. The previously suggested query for the given conversation. This
   * helps identify whether the next suggestion we generate is resonably
   * different from the previous one. This is useful to avoid similar
   * suggestions within the conversation.
   */
  previousSuggestedQuery: string;
}

/**
 * The response message for
 * [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
 */
export interface SuggestKnowledgeAssistResponse {
  /** Output only. Knowledge Assist suggestion. */
  knowledgeAssistAnswer:
    | KnowledgeAssistAnswer
    | undefined;
  /**
   * The name of the latest conversation message used to compile suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2.SuggestKnowledgeAssistResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestKnowledgeAssistRequest.context_size][google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.context_size]
   * field in the request if there are fewer messages in the conversation.
   */
  contextSize: number;
}

/** Represents a Knowledge Assist answer. */
export interface KnowledgeAssistAnswer {
  /**
   * The query suggested based on the context. Suggestion is made only if it
   * is different from the previous suggestion.
   */
  suggestedQuery:
    | KnowledgeAssistAnswer_SuggestedQuery
    | undefined;
  /**
   * The answer generated for the suggested query. Whether or not an answer is
   * generated depends on how confident we are about the generated query.
   */
  suggestedQueryAnswer:
    | KnowledgeAssistAnswer_KnowledgeAnswer
    | undefined;
  /**
   * The name of the answer record.
   * Format: `projects/<Project ID>/locations/<location ID>/answer
   * Records/<Answer Record ID>`.
   */
  answerRecord: string;
}

/** Represents a suggested query. */
export interface KnowledgeAssistAnswer_SuggestedQuery {
  /** Suggested query text. */
  queryText: string;
}

/**
 * Represents an answer from Knowledge. Currently supports FAQ and Generative
 * answers.
 */
export interface KnowledgeAssistAnswer_KnowledgeAnswer {
  /** The piece of text from the `source` that answers this suggested query. */
  answerText: string;
  /** Populated if the prediction came from FAQ. */
  faqSource?:
    | KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource
    | undefined;
  /** Populated if the prediction was Generative. */
  generativeSource?: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource | undefined;
}

/** Details about source of FAQ answer. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
  /** The corresponding FAQ question. */
  question: string;
}

/** Details about source of Generative answer. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
  /**
   * All snippets used for this Generative Prediction, with their source URI
   * and data.
   */
  snippets: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet[];
}

/** Snippet Source for a Generative Prediction. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
  /** URI the data is sourced from. */
  uri: string;
  /** Text taken from that URI. */
  text: string;
  /** Title of the document. */
  title: string;
}

function createBaseParticipant(): Participant {
  return { name: "", role: 0, sipRecordingMediaLabel: "", obfuscatedExternalUserId: "", documentsMetadataFilters: {} };
}

export const Participant: MessageFns<Participant> = {
  encode(message: Participant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.sipRecordingMediaLabel !== "") {
      writer.uint32(50).string(message.sipRecordingMediaLabel);
    }
    if (message.obfuscatedExternalUserId !== "") {
      writer.uint32(58).string(message.obfuscatedExternalUserId);
    }
    Object.entries(message.documentsMetadataFilters).forEach(([key, value]) => {
      Participant_DocumentsMetadataFiltersEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sipRecordingMediaLabel = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.obfuscatedExternalUserId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Participant_DocumentsMetadataFiltersEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.documentsMetadataFilters[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      role: isSet(object.role) ? participant_RoleFromJSON(object.role) : 0,
      sipRecordingMediaLabel: isSet(object.sipRecordingMediaLabel)
        ? globalThis.String(object.sipRecordingMediaLabel)
        : "",
      obfuscatedExternalUserId: isSet(object.obfuscatedExternalUserId)
        ? globalThis.String(object.obfuscatedExternalUserId)
        : "",
      documentsMetadataFilters: isObject(object.documentsMetadataFilters)
        ? Object.entries(object.documentsMetadataFilters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Participant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.role !== 0) {
      obj.role = participant_RoleToJSON(message.role);
    }
    if (message.sipRecordingMediaLabel !== "") {
      obj.sipRecordingMediaLabel = message.sipRecordingMediaLabel;
    }
    if (message.obfuscatedExternalUserId !== "") {
      obj.obfuscatedExternalUserId = message.obfuscatedExternalUserId;
    }
    if (message.documentsMetadataFilters) {
      const entries = Object.entries(message.documentsMetadataFilters);
      if (entries.length > 0) {
        obj.documentsMetadataFilters = {};
        entries.forEach(([k, v]) => {
          obj.documentsMetadataFilters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Participant>): Participant {
    return Participant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Participant>): Participant {
    const message = createBaseParticipant();
    message.name = object.name ?? "";
    message.role = object.role ?? 0;
    message.sipRecordingMediaLabel = object.sipRecordingMediaLabel ?? "";
    message.obfuscatedExternalUserId = object.obfuscatedExternalUserId ?? "";
    message.documentsMetadataFilters = Object.entries(object.documentsMetadataFilters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseParticipant_DocumentsMetadataFiltersEntry(): Participant_DocumentsMetadataFiltersEntry {
  return { key: "", value: "" };
}

export const Participant_DocumentsMetadataFiltersEntry: MessageFns<Participant_DocumentsMetadataFiltersEntry> = {
  encode(message: Participant_DocumentsMetadataFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant_DocumentsMetadataFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant_DocumentsMetadataFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant_DocumentsMetadataFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Participant_DocumentsMetadataFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Participant_DocumentsMetadataFiltersEntry>): Participant_DocumentsMetadataFiltersEntry {
    return Participant_DocumentsMetadataFiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Participant_DocumentsMetadataFiltersEntry>,
  ): Participant_DocumentsMetadataFiltersEntry {
    const message = createBaseParticipant_DocumentsMetadataFiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    name: "",
    content: "",
    languageCode: "",
    participant: "",
    participantRole: 0,
    createTime: undefined,
    sendTime: undefined,
    messageAnnotation: undefined,
    sentimentAnalysis: undefined,
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    if (message.participantRole !== 0) {
      writer.uint32(40).int32(message.participantRole);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.sendTime !== undefined) {
      Timestamp.encode(toTimestamp(message.sendTime), writer.uint32(74).fork()).join();
    }
    if (message.messageAnnotation !== undefined) {
      MessageAnnotation.encode(message.messageAnnotation, writer.uint32(58).fork()).join();
    }
    if (message.sentimentAnalysis !== undefined) {
      SentimentAnalysisResult.encode(message.sentimentAnalysis, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.participantRole = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sendTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.messageAnnotation = MessageAnnotation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sentimentAnalysis = SentimentAnalysisResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      participantRole: isSet(object.participantRole) ? participant_RoleFromJSON(object.participantRole) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      sendTime: isSet(object.sendTime) ? fromJsonTimestamp(object.sendTime) : undefined,
      messageAnnotation: isSet(object.messageAnnotation)
        ? MessageAnnotation.fromJSON(object.messageAnnotation)
        : undefined,
      sentimentAnalysis: isSet(object.sentimentAnalysis)
        ? SentimentAnalysisResult.fromJSON(object.sentimentAnalysis)
        : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.participantRole !== 0) {
      obj.participantRole = participant_RoleToJSON(message.participantRole);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.sendTime !== undefined) {
      obj.sendTime = message.sendTime.toISOString();
    }
    if (message.messageAnnotation !== undefined) {
      obj.messageAnnotation = MessageAnnotation.toJSON(message.messageAnnotation);
    }
    if (message.sentimentAnalysis !== undefined) {
      obj.sentimentAnalysis = SentimentAnalysisResult.toJSON(message.sentimentAnalysis);
    }
    return obj;
  },

  create(base?: DeepPartial<Message>): Message {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message>): Message {
    const message = createBaseMessage();
    message.name = object.name ?? "";
    message.content = object.content ?? "";
    message.languageCode = object.languageCode ?? "";
    message.participant = object.participant ?? "";
    message.participantRole = object.participantRole ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.sendTime = object.sendTime ?? undefined;
    message.messageAnnotation = (object.messageAnnotation !== undefined && object.messageAnnotation !== null)
      ? MessageAnnotation.fromPartial(object.messageAnnotation)
      : undefined;
    message.sentimentAnalysis = (object.sentimentAnalysis !== undefined && object.sentimentAnalysis !== null)
      ? SentimentAnalysisResult.fromPartial(object.sentimentAnalysis)
      : undefined;
    return message;
  },
};

function createBaseCreateParticipantRequest(): CreateParticipantRequest {
  return { parent: "", participant: undefined };
}

export const CreateParticipantRequest: MessageFns<CreateParticipantRequest> = {
  encode(message: CreateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.participant !== undefined) {
      Participant.encode(message.participant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.participant = Participant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateParticipantRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
    };
  },

  toJSON(message: CreateParticipantRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.participant !== undefined) {
      obj.participant = Participant.toJSON(message.participant);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateParticipantRequest>): CreateParticipantRequest {
    return CreateParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateParticipantRequest>): CreateParticipantRequest {
    const message = createBaseCreateParticipantRequest();
    message.parent = object.parent ?? "";
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? Participant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseGetParticipantRequest(): GetParticipantRequest {
  return { name: "" };
}

export const GetParticipantRequest: MessageFns<GetParticipantRequest> = {
  encode(message: GetParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParticipantRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetParticipantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    return GetParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    const message = createBaseGetParticipantRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListParticipantsRequest(): ListParticipantsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListParticipantsRequest: MessageFns<ListParticipantsRequest> = {
  encode(message: ListParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListParticipantsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    return ListParticipantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    const message = createBaseListParticipantsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListParticipantsResponse(): ListParticipantsResponse {
  return { participants: [], nextPageToken: "" };
}

export const ListParticipantsResponse: MessageFns<ListParticipantsResponse> = {
  encode(message: ListParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      Participant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participants.push(Participant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => Participant.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => Participant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    return ListParticipantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    const message = createBaseListParticipantsResponse();
    message.participants = object.participants?.map((e) => Participant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateParticipantRequest(): UpdateParticipantRequest {
  return { participant: undefined, updateMask: undefined };
}

export const UpdateParticipantRequest: MessageFns<UpdateParticipantRequest> = {
  encode(message: UpdateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== undefined) {
      Participant.encode(message.participant, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = Participant.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest {
    return {
      participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateParticipantRequest): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = Participant.toJSON(message.participant);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    return UpdateParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    const message = createBaseUpdateParticipantRequest();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? Participant.fromPartial(object.participant)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseAnalyzeContentRequest(): AnalyzeContentRequest {
  return {
    participant: "",
    textInput: undefined,
    eventInput: undefined,
    suggestionInput: undefined,
    replyAudioConfig: undefined,
    queryParams: undefined,
    assistQueryParams: undefined,
    cxParameters: undefined,
    requestId: "",
  };
}

export const AnalyzeContentRequest: MessageFns<AnalyzeContentRequest> = {
  encode(message: AnalyzeContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== "") {
      writer.uint32(10).string(message.participant);
    }
    if (message.textInput !== undefined) {
      TextInput.encode(message.textInput, writer.uint32(50).fork()).join();
    }
    if (message.eventInput !== undefined) {
      EventInput.encode(message.eventInput, writer.uint32(66).fork()).join();
    }
    if (message.suggestionInput !== undefined) {
      SuggestionInput.encode(message.suggestionInput, writer.uint32(98).fork()).join();
    }
    if (message.replyAudioConfig !== undefined) {
      OutputAudioConfig.encode(message.replyAudioConfig, writer.uint32(42).fork()).join();
    }
    if (message.queryParams !== undefined) {
      QueryParameters.encode(message.queryParams, writer.uint32(74).fork()).join();
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(114).fork()).join();
    }
    if (message.cxParameters !== undefined) {
      Struct.encode(Struct.wrap(message.cxParameters), writer.uint32(146).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(90).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.eventInput = EventInput.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.suggestionInput = SuggestionInput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.replyAudioConfig = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.queryParams = QueryParameters.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.cxParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeContentRequest {
    return {
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      textInput: isSet(object.textInput) ? TextInput.fromJSON(object.textInput) : undefined,
      eventInput: isSet(object.eventInput) ? EventInput.fromJSON(object.eventInput) : undefined,
      suggestionInput: isSet(object.suggestionInput) ? SuggestionInput.fromJSON(object.suggestionInput) : undefined,
      replyAudioConfig: isSet(object.replyAudioConfig)
        ? OutputAudioConfig.fromJSON(object.replyAudioConfig)
        : undefined,
      queryParams: isSet(object.queryParams) ? QueryParameters.fromJSON(object.queryParams) : undefined,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
      cxParameters: isObject(object.cxParameters) ? object.cxParameters : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: AnalyzeContentRequest): unknown {
    const obj: any = {};
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInput.toJSON(message.textInput);
    }
    if (message.eventInput !== undefined) {
      obj.eventInput = EventInput.toJSON(message.eventInput);
    }
    if (message.suggestionInput !== undefined) {
      obj.suggestionInput = SuggestionInput.toJSON(message.suggestionInput);
    }
    if (message.replyAudioConfig !== undefined) {
      obj.replyAudioConfig = OutputAudioConfig.toJSON(message.replyAudioConfig);
    }
    if (message.queryParams !== undefined) {
      obj.queryParams = QueryParameters.toJSON(message.queryParams);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    if (message.cxParameters !== undefined) {
      obj.cxParameters = message.cxParameters;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeContentRequest>): AnalyzeContentRequest {
    return AnalyzeContentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeContentRequest>): AnalyzeContentRequest {
    const message = createBaseAnalyzeContentRequest();
    message.participant = object.participant ?? "";
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInput.fromPartial(object.textInput)
      : undefined;
    message.eventInput = (object.eventInput !== undefined && object.eventInput !== null)
      ? EventInput.fromPartial(object.eventInput)
      : undefined;
    message.suggestionInput = (object.suggestionInput !== undefined && object.suggestionInput !== null)
      ? SuggestionInput.fromPartial(object.suggestionInput)
      : undefined;
    message.replyAudioConfig = (object.replyAudioConfig !== undefined && object.replyAudioConfig !== null)
      ? OutputAudioConfig.fromPartial(object.replyAudioConfig)
      : undefined;
    message.queryParams = (object.queryParams !== undefined && object.queryParams !== null)
      ? QueryParameters.fromPartial(object.queryParams)
      : undefined;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    message.cxParameters = object.cxParameters ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDtmfParameters(): DtmfParameters {
  return { acceptsDtmfInput: false };
}

export const DtmfParameters: MessageFns<DtmfParameters> = {
  encode(message: DtmfParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceptsDtmfInput !== false) {
      writer.uint32(8).bool(message.acceptsDtmfInput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DtmfParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDtmfParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceptsDtmfInput = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DtmfParameters {
    return { acceptsDtmfInput: isSet(object.acceptsDtmfInput) ? globalThis.Boolean(object.acceptsDtmfInput) : false };
  },

  toJSON(message: DtmfParameters): unknown {
    const obj: any = {};
    if (message.acceptsDtmfInput !== false) {
      obj.acceptsDtmfInput = message.acceptsDtmfInput;
    }
    return obj;
  },

  create(base?: DeepPartial<DtmfParameters>): DtmfParameters {
    return DtmfParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DtmfParameters>): DtmfParameters {
    const message = createBaseDtmfParameters();
    message.acceptsDtmfInput = object.acceptsDtmfInput ?? false;
    return message;
  },
};

function createBaseAnalyzeContentResponse(): AnalyzeContentResponse {
  return {
    replyText: "",
    replyAudio: undefined,
    automatedAgentReply: undefined,
    message: undefined,
    humanAgentSuggestionResults: [],
    endUserSuggestionResults: [],
    dtmfParameters: undefined,
  };
}

export const AnalyzeContentResponse: MessageFns<AnalyzeContentResponse> = {
  encode(message: AnalyzeContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyText !== "") {
      writer.uint32(10).string(message.replyText);
    }
    if (message.replyAudio !== undefined) {
      OutputAudio.encode(message.replyAudio, writer.uint32(18).fork()).join();
    }
    if (message.automatedAgentReply !== undefined) {
      AutomatedAgentReply.encode(message.automatedAgentReply, writer.uint32(26).fork()).join();
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(42).fork()).join();
    }
    for (const v of message.humanAgentSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.endUserSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.dtmfParameters !== undefined) {
      DtmfParameters.encode(message.dtmfParameters, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.replyText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replyAudio = OutputAudio.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.automatedAgentReply = AutomatedAgentReply.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.humanAgentSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endUserSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dtmfParameters = DtmfParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeContentResponse {
    return {
      replyText: isSet(object.replyText) ? globalThis.String(object.replyText) : "",
      replyAudio: isSet(object.replyAudio) ? OutputAudio.fromJSON(object.replyAudio) : undefined,
      automatedAgentReply: isSet(object.automatedAgentReply)
        ? AutomatedAgentReply.fromJSON(object.automatedAgentReply)
        : undefined,
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      humanAgentSuggestionResults: globalThis.Array.isArray(object?.humanAgentSuggestionResults)
        ? object.humanAgentSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      endUserSuggestionResults: globalThis.Array.isArray(object?.endUserSuggestionResults)
        ? object.endUserSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      dtmfParameters: isSet(object.dtmfParameters) ? DtmfParameters.fromJSON(object.dtmfParameters) : undefined,
    };
  },

  toJSON(message: AnalyzeContentResponse): unknown {
    const obj: any = {};
    if (message.replyText !== "") {
      obj.replyText = message.replyText;
    }
    if (message.replyAudio !== undefined) {
      obj.replyAudio = OutputAudio.toJSON(message.replyAudio);
    }
    if (message.automatedAgentReply !== undefined) {
      obj.automatedAgentReply = AutomatedAgentReply.toJSON(message.automatedAgentReply);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.humanAgentSuggestionResults?.length) {
      obj.humanAgentSuggestionResults = message.humanAgentSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.endUserSuggestionResults?.length) {
      obj.endUserSuggestionResults = message.endUserSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.dtmfParameters !== undefined) {
      obj.dtmfParameters = DtmfParameters.toJSON(message.dtmfParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeContentResponse>): AnalyzeContentResponse {
    return AnalyzeContentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeContentResponse>): AnalyzeContentResponse {
    const message = createBaseAnalyzeContentResponse();
    message.replyText = object.replyText ?? "";
    message.replyAudio = (object.replyAudio !== undefined && object.replyAudio !== null)
      ? OutputAudio.fromPartial(object.replyAudio)
      : undefined;
    message.automatedAgentReply = (object.automatedAgentReply !== undefined && object.automatedAgentReply !== null)
      ? AutomatedAgentReply.fromPartial(object.automatedAgentReply)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.humanAgentSuggestionResults =
      object.humanAgentSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) || [];
    message.endUserSuggestionResults = object.endUserSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) ||
      [];
    message.dtmfParameters = (object.dtmfParameters !== undefined && object.dtmfParameters !== null)
      ? DtmfParameters.fromPartial(object.dtmfParameters)
      : undefined;
    return message;
  },
};

function createBaseStreamingAnalyzeContentRequest(): StreamingAnalyzeContentRequest {
  return {
    participant: "",
    audioConfig: undefined,
    textConfig: undefined,
    replyAudioConfig: undefined,
    inputAudio: undefined,
    inputText: undefined,
    inputDtmf: undefined,
    queryParams: undefined,
    assistQueryParams: undefined,
    cxParameters: undefined,
    enableExtendedStreaming: false,
    enablePartialAutomatedAgentReply: false,
    enableDebuggingInfo: false,
  };
}

export const StreamingAnalyzeContentRequest: MessageFns<StreamingAnalyzeContentRequest> = {
  encode(message: StreamingAnalyzeContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== "") {
      writer.uint32(10).string(message.participant);
    }
    if (message.audioConfig !== undefined) {
      InputAudioConfig.encode(message.audioConfig, writer.uint32(18).fork()).join();
    }
    if (message.textConfig !== undefined) {
      InputTextConfig.encode(message.textConfig, writer.uint32(26).fork()).join();
    }
    if (message.replyAudioConfig !== undefined) {
      OutputAudioConfig.encode(message.replyAudioConfig, writer.uint32(34).fork()).join();
    }
    if (message.inputAudio !== undefined) {
      writer.uint32(42).bytes(message.inputAudio);
    }
    if (message.inputText !== undefined) {
      writer.uint32(50).string(message.inputText);
    }
    if (message.inputDtmf !== undefined) {
      TelephonyDtmfEvents.encode(message.inputDtmf, writer.uint32(74).fork()).join();
    }
    if (message.queryParams !== undefined) {
      QueryParameters.encode(message.queryParams, writer.uint32(58).fork()).join();
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(66).fork()).join();
    }
    if (message.cxParameters !== undefined) {
      Struct.encode(Struct.wrap(message.cxParameters), writer.uint32(106).fork()).join();
    }
    if (message.enableExtendedStreaming !== false) {
      writer.uint32(88).bool(message.enableExtendedStreaming);
    }
    if (message.enablePartialAutomatedAgentReply !== false) {
      writer.uint32(96).bool(message.enablePartialAutomatedAgentReply);
    }
    if (message.enableDebuggingInfo !== false) {
      writer.uint32(152).bool(message.enableDebuggingInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingAnalyzeContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingAnalyzeContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioConfig = InputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textConfig = InputTextConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.replyAudioConfig = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputAudio = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputText = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.inputDtmf = TelephonyDtmfEvents.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.queryParams = QueryParameters.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cxParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableExtendedStreaming = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enablePartialAutomatedAgentReply = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.enableDebuggingInfo = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingAnalyzeContentRequest {
    return {
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      audioConfig: isSet(object.audioConfig) ? InputAudioConfig.fromJSON(object.audioConfig) : undefined,
      textConfig: isSet(object.textConfig) ? InputTextConfig.fromJSON(object.textConfig) : undefined,
      replyAudioConfig: isSet(object.replyAudioConfig)
        ? OutputAudioConfig.fromJSON(object.replyAudioConfig)
        : undefined,
      inputAudio: isSet(object.inputAudio) ? Buffer.from(bytesFromBase64(object.inputAudio)) : undefined,
      inputText: isSet(object.inputText) ? globalThis.String(object.inputText) : undefined,
      inputDtmf: isSet(object.inputDtmf) ? TelephonyDtmfEvents.fromJSON(object.inputDtmf) : undefined,
      queryParams: isSet(object.queryParams) ? QueryParameters.fromJSON(object.queryParams) : undefined,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
      cxParameters: isObject(object.cxParameters) ? object.cxParameters : undefined,
      enableExtendedStreaming: isSet(object.enableExtendedStreaming)
        ? globalThis.Boolean(object.enableExtendedStreaming)
        : false,
      enablePartialAutomatedAgentReply: isSet(object.enablePartialAutomatedAgentReply)
        ? globalThis.Boolean(object.enablePartialAutomatedAgentReply)
        : false,
      enableDebuggingInfo: isSet(object.enableDebuggingInfo) ? globalThis.Boolean(object.enableDebuggingInfo) : false,
    };
  },

  toJSON(message: StreamingAnalyzeContentRequest): unknown {
    const obj: any = {};
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.audioConfig !== undefined) {
      obj.audioConfig = InputAudioConfig.toJSON(message.audioConfig);
    }
    if (message.textConfig !== undefined) {
      obj.textConfig = InputTextConfig.toJSON(message.textConfig);
    }
    if (message.replyAudioConfig !== undefined) {
      obj.replyAudioConfig = OutputAudioConfig.toJSON(message.replyAudioConfig);
    }
    if (message.inputAudio !== undefined) {
      obj.inputAudio = base64FromBytes(message.inputAudio);
    }
    if (message.inputText !== undefined) {
      obj.inputText = message.inputText;
    }
    if (message.inputDtmf !== undefined) {
      obj.inputDtmf = TelephonyDtmfEvents.toJSON(message.inputDtmf);
    }
    if (message.queryParams !== undefined) {
      obj.queryParams = QueryParameters.toJSON(message.queryParams);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    if (message.cxParameters !== undefined) {
      obj.cxParameters = message.cxParameters;
    }
    if (message.enableExtendedStreaming !== false) {
      obj.enableExtendedStreaming = message.enableExtendedStreaming;
    }
    if (message.enablePartialAutomatedAgentReply !== false) {
      obj.enablePartialAutomatedAgentReply = message.enablePartialAutomatedAgentReply;
    }
    if (message.enableDebuggingInfo !== false) {
      obj.enableDebuggingInfo = message.enableDebuggingInfo;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingAnalyzeContentRequest>): StreamingAnalyzeContentRequest {
    return StreamingAnalyzeContentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingAnalyzeContentRequest>): StreamingAnalyzeContentRequest {
    const message = createBaseStreamingAnalyzeContentRequest();
    message.participant = object.participant ?? "";
    message.audioConfig = (object.audioConfig !== undefined && object.audioConfig !== null)
      ? InputAudioConfig.fromPartial(object.audioConfig)
      : undefined;
    message.textConfig = (object.textConfig !== undefined && object.textConfig !== null)
      ? InputTextConfig.fromPartial(object.textConfig)
      : undefined;
    message.replyAudioConfig = (object.replyAudioConfig !== undefined && object.replyAudioConfig !== null)
      ? OutputAudioConfig.fromPartial(object.replyAudioConfig)
      : undefined;
    message.inputAudio = object.inputAudio ?? undefined;
    message.inputText = object.inputText ?? undefined;
    message.inputDtmf = (object.inputDtmf !== undefined && object.inputDtmf !== null)
      ? TelephonyDtmfEvents.fromPartial(object.inputDtmf)
      : undefined;
    message.queryParams = (object.queryParams !== undefined && object.queryParams !== null)
      ? QueryParameters.fromPartial(object.queryParams)
      : undefined;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    message.cxParameters = object.cxParameters ?? undefined;
    message.enableExtendedStreaming = object.enableExtendedStreaming ?? false;
    message.enablePartialAutomatedAgentReply = object.enablePartialAutomatedAgentReply ?? false;
    message.enableDebuggingInfo = object.enableDebuggingInfo ?? false;
    return message;
  },
};

function createBaseStreamingAnalyzeContentResponse(): StreamingAnalyzeContentResponse {
  return {
    recognitionResult: undefined,
    replyText: "",
    replyAudio: undefined,
    automatedAgentReply: undefined,
    message: undefined,
    humanAgentSuggestionResults: [],
    endUserSuggestionResults: [],
    dtmfParameters: undefined,
    debuggingInfo: undefined,
  };
}

export const StreamingAnalyzeContentResponse: MessageFns<StreamingAnalyzeContentResponse> = {
  encode(message: StreamingAnalyzeContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recognitionResult !== undefined) {
      StreamingRecognitionResult.encode(message.recognitionResult, writer.uint32(10).fork()).join();
    }
    if (message.replyText !== "") {
      writer.uint32(18).string(message.replyText);
    }
    if (message.replyAudio !== undefined) {
      OutputAudio.encode(message.replyAudio, writer.uint32(26).fork()).join();
    }
    if (message.automatedAgentReply !== undefined) {
      AutomatedAgentReply.encode(message.automatedAgentReply, writer.uint32(34).fork()).join();
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(50).fork()).join();
    }
    for (const v of message.humanAgentSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.endUserSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.dtmfParameters !== undefined) {
      DtmfParameters.encode(message.dtmfParameters, writer.uint32(82).fork()).join();
    }
    if (message.debuggingInfo !== undefined) {
      CloudConversationDebuggingInfo.encode(message.debuggingInfo, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingAnalyzeContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingAnalyzeContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recognitionResult = StreamingRecognitionResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replyText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.replyAudio = OutputAudio.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.automatedAgentReply = AutomatedAgentReply.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.humanAgentSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endUserSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dtmfParameters = DtmfParameters.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.debuggingInfo = CloudConversationDebuggingInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingAnalyzeContentResponse {
    return {
      recognitionResult: isSet(object.recognitionResult)
        ? StreamingRecognitionResult.fromJSON(object.recognitionResult)
        : undefined,
      replyText: isSet(object.replyText) ? globalThis.String(object.replyText) : "",
      replyAudio: isSet(object.replyAudio) ? OutputAudio.fromJSON(object.replyAudio) : undefined,
      automatedAgentReply: isSet(object.automatedAgentReply)
        ? AutomatedAgentReply.fromJSON(object.automatedAgentReply)
        : undefined,
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      humanAgentSuggestionResults: globalThis.Array.isArray(object?.humanAgentSuggestionResults)
        ? object.humanAgentSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      endUserSuggestionResults: globalThis.Array.isArray(object?.endUserSuggestionResults)
        ? object.endUserSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      dtmfParameters: isSet(object.dtmfParameters) ? DtmfParameters.fromJSON(object.dtmfParameters) : undefined,
      debuggingInfo: isSet(object.debuggingInfo)
        ? CloudConversationDebuggingInfo.fromJSON(object.debuggingInfo)
        : undefined,
    };
  },

  toJSON(message: StreamingAnalyzeContentResponse): unknown {
    const obj: any = {};
    if (message.recognitionResult !== undefined) {
      obj.recognitionResult = StreamingRecognitionResult.toJSON(message.recognitionResult);
    }
    if (message.replyText !== "") {
      obj.replyText = message.replyText;
    }
    if (message.replyAudio !== undefined) {
      obj.replyAudio = OutputAudio.toJSON(message.replyAudio);
    }
    if (message.automatedAgentReply !== undefined) {
      obj.automatedAgentReply = AutomatedAgentReply.toJSON(message.automatedAgentReply);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.humanAgentSuggestionResults?.length) {
      obj.humanAgentSuggestionResults = message.humanAgentSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.endUserSuggestionResults?.length) {
      obj.endUserSuggestionResults = message.endUserSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.dtmfParameters !== undefined) {
      obj.dtmfParameters = DtmfParameters.toJSON(message.dtmfParameters);
    }
    if (message.debuggingInfo !== undefined) {
      obj.debuggingInfo = CloudConversationDebuggingInfo.toJSON(message.debuggingInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingAnalyzeContentResponse>): StreamingAnalyzeContentResponse {
    return StreamingAnalyzeContentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingAnalyzeContentResponse>): StreamingAnalyzeContentResponse {
    const message = createBaseStreamingAnalyzeContentResponse();
    message.recognitionResult = (object.recognitionResult !== undefined && object.recognitionResult !== null)
      ? StreamingRecognitionResult.fromPartial(object.recognitionResult)
      : undefined;
    message.replyText = object.replyText ?? "";
    message.replyAudio = (object.replyAudio !== undefined && object.replyAudio !== null)
      ? OutputAudio.fromPartial(object.replyAudio)
      : undefined;
    message.automatedAgentReply = (object.automatedAgentReply !== undefined && object.automatedAgentReply !== null)
      ? AutomatedAgentReply.fromPartial(object.automatedAgentReply)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.humanAgentSuggestionResults =
      object.humanAgentSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) || [];
    message.endUserSuggestionResults = object.endUserSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) ||
      [];
    message.dtmfParameters = (object.dtmfParameters !== undefined && object.dtmfParameters !== null)
      ? DtmfParameters.fromPartial(object.dtmfParameters)
      : undefined;
    message.debuggingInfo = (object.debuggingInfo !== undefined && object.debuggingInfo !== null)
      ? CloudConversationDebuggingInfo.fromPartial(object.debuggingInfo)
      : undefined;
    return message;
  },
};

function createBaseSuggestArticlesRequest(): SuggestArticlesRequest {
  return { parent: "", latestMessage: "", contextSize: 0, assistQueryParams: undefined };
}

export const SuggestArticlesRequest: MessageFns<SuggestArticlesRequest> = {
  encode(message: SuggestArticlesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestArticlesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestArticlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestArticlesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
    };
  },

  toJSON(message: SuggestArticlesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestArticlesRequest>): SuggestArticlesRequest {
    return SuggestArticlesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestArticlesRequest>): SuggestArticlesRequest {
    const message = createBaseSuggestArticlesRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    return message;
  },
};

function createBaseSuggestArticlesResponse(): SuggestArticlesResponse {
  return { articleAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestArticlesResponse: MessageFns<SuggestArticlesResponse> = {
  encode(message: SuggestArticlesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.articleAnswers) {
      ArticleAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestArticlesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestArticlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.articleAnswers.push(ArticleAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestArticlesResponse {
    return {
      articleAnswers: globalThis.Array.isArray(object?.articleAnswers)
        ? object.articleAnswers.map((e: any) => ArticleAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestArticlesResponse): unknown {
    const obj: any = {};
    if (message.articleAnswers?.length) {
      obj.articleAnswers = message.articleAnswers.map((e) => ArticleAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestArticlesResponse>): SuggestArticlesResponse {
    return SuggestArticlesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestArticlesResponse>): SuggestArticlesResponse {
    const message = createBaseSuggestArticlesResponse();
    message.articleAnswers = object.articleAnswers?.map((e) => ArticleAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestFaqAnswersRequest(): SuggestFaqAnswersRequest {
  return { parent: "", latestMessage: "", contextSize: 0, assistQueryParams: undefined };
}

export const SuggestFaqAnswersRequest: MessageFns<SuggestFaqAnswersRequest> = {
  encode(message: SuggestFaqAnswersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestFaqAnswersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestFaqAnswersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestFaqAnswersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
    };
  },

  toJSON(message: SuggestFaqAnswersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestFaqAnswersRequest>): SuggestFaqAnswersRequest {
    return SuggestFaqAnswersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestFaqAnswersRequest>): SuggestFaqAnswersRequest {
    const message = createBaseSuggestFaqAnswersRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    return message;
  },
};

function createBaseSuggestFaqAnswersResponse(): SuggestFaqAnswersResponse {
  return { faqAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestFaqAnswersResponse: MessageFns<SuggestFaqAnswersResponse> = {
  encode(message: SuggestFaqAnswersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.faqAnswers) {
      FaqAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestFaqAnswersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestFaqAnswersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.faqAnswers.push(FaqAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestFaqAnswersResponse {
    return {
      faqAnswers: globalThis.Array.isArray(object?.faqAnswers)
        ? object.faqAnswers.map((e: any) => FaqAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestFaqAnswersResponse): unknown {
    const obj: any = {};
    if (message.faqAnswers?.length) {
      obj.faqAnswers = message.faqAnswers.map((e) => FaqAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestFaqAnswersResponse>): SuggestFaqAnswersResponse {
    return SuggestFaqAnswersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestFaqAnswersResponse>): SuggestFaqAnswersResponse {
    const message = createBaseSuggestFaqAnswersResponse();
    message.faqAnswers = object.faqAnswers?.map((e) => FaqAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestSmartRepliesRequest(): SuggestSmartRepliesRequest {
  return { parent: "", currentTextInput: undefined, latestMessage: "", contextSize: 0 };
}

export const SuggestSmartRepliesRequest: MessageFns<SuggestSmartRepliesRequest> = {
  encode(message: SuggestSmartRepliesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.currentTextInput !== undefined) {
      TextInput.encode(message.currentTextInput, writer.uint32(34).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestSmartRepliesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestSmartRepliesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentTextInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestSmartRepliesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      currentTextInput: isSet(object.currentTextInput) ? TextInput.fromJSON(object.currentTextInput) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestSmartRepliesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.currentTextInput !== undefined) {
      obj.currentTextInput = TextInput.toJSON(message.currentTextInput);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestSmartRepliesRequest>): SuggestSmartRepliesRequest {
    return SuggestSmartRepliesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestSmartRepliesRequest>): SuggestSmartRepliesRequest {
    const message = createBaseSuggestSmartRepliesRequest();
    message.parent = object.parent ?? "";
    message.currentTextInput = (object.currentTextInput !== undefined && object.currentTextInput !== null)
      ? TextInput.fromPartial(object.currentTextInput)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestSmartRepliesResponse(): SuggestSmartRepliesResponse {
  return { smartReplyAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestSmartRepliesResponse: MessageFns<SuggestSmartRepliesResponse> = {
  encode(message: SuggestSmartRepliesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.smartReplyAnswers) {
      SmartReplyAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestSmartRepliesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestSmartRepliesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.smartReplyAnswers.push(SmartReplyAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestSmartRepliesResponse {
    return {
      smartReplyAnswers: globalThis.Array.isArray(object?.smartReplyAnswers)
        ? object.smartReplyAnswers.map((e: any) => SmartReplyAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestSmartRepliesResponse): unknown {
    const obj: any = {};
    if (message.smartReplyAnswers?.length) {
      obj.smartReplyAnswers = message.smartReplyAnswers.map((e) => SmartReplyAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestSmartRepliesResponse>): SuggestSmartRepliesResponse {
    return SuggestSmartRepliesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestSmartRepliesResponse>): SuggestSmartRepliesResponse {
    const message = createBaseSuggestSmartRepliesResponse();
    message.smartReplyAnswers = object.smartReplyAnswers?.map((e) => SmartReplyAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseOutputAudio(): OutputAudio {
  return { config: undefined, audio: Buffer.alloc(0) };
}

export const OutputAudio: MessageFns<OutputAudio> = {
  encode(message: OutputAudio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      OutputAudioConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audio.length !== 0) {
      writer.uint32(18).bytes(message.audio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputAudio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputAudio {
    return {
      config: isSet(object.config) ? OutputAudioConfig.fromJSON(object.config) : undefined,
      audio: isSet(object.audio) ? Buffer.from(bytesFromBase64(object.audio)) : Buffer.alloc(0),
    };
  },

  toJSON(message: OutputAudio): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = OutputAudioConfig.toJSON(message.config);
    }
    if (message.audio.length !== 0) {
      obj.audio = base64FromBytes(message.audio);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputAudio>): OutputAudio {
    return OutputAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputAudio>): OutputAudio {
    const message = createBaseOutputAudio();
    message.config = (object.config !== undefined && object.config !== null)
      ? OutputAudioConfig.fromPartial(object.config)
      : undefined;
    message.audio = object.audio ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAutomatedAgentReply(): AutomatedAgentReply {
  return { detectIntentResponse: undefined, automatedAgentReplyType: 0, allowCancellation: false, cxCurrentPage: "" };
}

export const AutomatedAgentReply: MessageFns<AutomatedAgentReply> = {
  encode(message: AutomatedAgentReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detectIntentResponse !== undefined) {
      DetectIntentResponse.encode(message.detectIntentResponse, writer.uint32(10).fork()).join();
    }
    if (message.automatedAgentReplyType !== 0) {
      writer.uint32(56).int32(message.automatedAgentReplyType);
    }
    if (message.allowCancellation !== false) {
      writer.uint32(64).bool(message.allowCancellation);
    }
    if (message.cxCurrentPage !== "") {
      writer.uint32(90).string(message.cxCurrentPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomatedAgentReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomatedAgentReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.detectIntentResponse = DetectIntentResponse.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.automatedAgentReplyType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.allowCancellation = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.cxCurrentPage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomatedAgentReply {
    return {
      detectIntentResponse: isSet(object.detectIntentResponse)
        ? DetectIntentResponse.fromJSON(object.detectIntentResponse)
        : undefined,
      automatedAgentReplyType: isSet(object.automatedAgentReplyType)
        ? automatedAgentReply_AutomatedAgentReplyTypeFromJSON(object.automatedAgentReplyType)
        : 0,
      allowCancellation: isSet(object.allowCancellation) ? globalThis.Boolean(object.allowCancellation) : false,
      cxCurrentPage: isSet(object.cxCurrentPage) ? globalThis.String(object.cxCurrentPage) : "",
    };
  },

  toJSON(message: AutomatedAgentReply): unknown {
    const obj: any = {};
    if (message.detectIntentResponse !== undefined) {
      obj.detectIntentResponse = DetectIntentResponse.toJSON(message.detectIntentResponse);
    }
    if (message.automatedAgentReplyType !== 0) {
      obj.automatedAgentReplyType = automatedAgentReply_AutomatedAgentReplyTypeToJSON(message.automatedAgentReplyType);
    }
    if (message.allowCancellation !== false) {
      obj.allowCancellation = message.allowCancellation;
    }
    if (message.cxCurrentPage !== "") {
      obj.cxCurrentPage = message.cxCurrentPage;
    }
    return obj;
  },

  create(base?: DeepPartial<AutomatedAgentReply>): AutomatedAgentReply {
    return AutomatedAgentReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomatedAgentReply>): AutomatedAgentReply {
    const message = createBaseAutomatedAgentReply();
    message.detectIntentResponse = (object.detectIntentResponse !== undefined && object.detectIntentResponse !== null)
      ? DetectIntentResponse.fromPartial(object.detectIntentResponse)
      : undefined;
    message.automatedAgentReplyType = object.automatedAgentReplyType ?? 0;
    message.allowCancellation = object.allowCancellation ?? false;
    message.cxCurrentPage = object.cxCurrentPage ?? "";
    return message;
  },
};

function createBaseArticleAnswer(): ArticleAnswer {
  return { title: "", uri: "", snippets: [], confidence: 0, metadata: {}, answerRecord: "" };
}

export const ArticleAnswer: MessageFns<ArticleAnswer> = {
  encode(message: ArticleAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    for (const v of message.snippets) {
      writer.uint32(26).string(v!);
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ArticleAnswer_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snippets.push(reader.string());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ArticleAnswer_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleAnswer {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      snippets: globalThis.Array.isArray(object?.snippets) ? object.snippets.map((e: any) => globalThis.String(e)) : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: ArticleAnswer): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.snippets?.length) {
      obj.snippets = message.snippets;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleAnswer>): ArticleAnswer {
    return ArticleAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleAnswer>): ArticleAnswer {
    const message = createBaseArticleAnswer();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.snippets = object.snippets?.map((e) => e) || [];
    message.confidence = object.confidence ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseArticleAnswer_MetadataEntry(): ArticleAnswer_MetadataEntry {
  return { key: "", value: "" };
}

export const ArticleAnswer_MetadataEntry: MessageFns<ArticleAnswer_MetadataEntry> = {
  encode(message: ArticleAnswer_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleAnswer_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleAnswer_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleAnswer_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ArticleAnswer_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleAnswer_MetadataEntry>): ArticleAnswer_MetadataEntry {
    return ArticleAnswer_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleAnswer_MetadataEntry>): ArticleAnswer_MetadataEntry {
    const message = createBaseArticleAnswer_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFaqAnswer(): FaqAnswer {
  return { answer: "", confidence: 0, question: "", source: "", metadata: {}, answerRecord: "" };
}

export const FaqAnswer: MessageFns<FaqAnswer> = {
  encode(message: FaqAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.question !== "") {
      writer.uint32(26).string(message.question);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      FaqAnswer_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.question = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = FaqAnswer_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswer {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: FaqAnswer): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswer>): FaqAnswer {
    return FaqAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswer>): FaqAnswer {
    const message = createBaseFaqAnswer();
    message.answer = object.answer ?? "";
    message.confidence = object.confidence ?? 0;
    message.question = object.question ?? "";
    message.source = object.source ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseFaqAnswer_MetadataEntry(): FaqAnswer_MetadataEntry {
  return { key: "", value: "" };
}

export const FaqAnswer_MetadataEntry: MessageFns<FaqAnswer_MetadataEntry> = {
  encode(message: FaqAnswer_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswer_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswer_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswer_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FaqAnswer_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswer_MetadataEntry>): FaqAnswer_MetadataEntry {
    return FaqAnswer_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswer_MetadataEntry>): FaqAnswer_MetadataEntry {
    const message = createBaseFaqAnswer_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSmartReplyAnswer(): SmartReplyAnswer {
  return { reply: "", confidence: 0, answerRecord: "" };
}

export const SmartReplyAnswer: MessageFns<SmartReplyAnswer> = {
  encode(message: SmartReplyAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reply !== "") {
      writer.uint32(10).string(message.reply);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.answerRecord !== "") {
      writer.uint32(26).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartReplyAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartReplyAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reply = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartReplyAnswer {
    return {
      reply: isSet(object.reply) ? globalThis.String(object.reply) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: SmartReplyAnswer): unknown {
    const obj: any = {};
    if (message.reply !== "") {
      obj.reply = message.reply;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartReplyAnswer>): SmartReplyAnswer {
    return SmartReplyAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartReplyAnswer>): SmartReplyAnswer {
    const message = createBaseSmartReplyAnswer();
    message.reply = object.reply ?? "";
    message.confidence = object.confidence ?? 0;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseIntentSuggestion(): IntentSuggestion {
  return { displayName: "", intentV2: undefined, description: "" };
}

export const IntentSuggestion: MessageFns<IntentSuggestion> = {
  encode(message: IntentSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.intentV2 !== undefined) {
      writer.uint32(18).string(message.intentV2);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentV2 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentSuggestion {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      intentV2: isSet(object.intentV2) ? globalThis.String(object.intentV2) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: IntentSuggestion): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.intentV2 !== undefined) {
      obj.intentV2 = message.intentV2;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentSuggestion>): IntentSuggestion {
    return IntentSuggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentSuggestion>): IntentSuggestion {
    const message = createBaseIntentSuggestion();
    message.displayName = object.displayName ?? "";
    message.intentV2 = object.intentV2 ?? undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseDialogflowAssistAnswer(): DialogflowAssistAnswer {
  return { queryResult: undefined, intentSuggestion: undefined, answerRecord: "" };
}

export const DialogflowAssistAnswer: MessageFns<DialogflowAssistAnswer> = {
  encode(message: DialogflowAssistAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryResult !== undefined) {
      QueryResult.encode(message.queryResult, writer.uint32(10).fork()).join();
    }
    if (message.intentSuggestion !== undefined) {
      IntentSuggestion.encode(message.intentSuggestion, writer.uint32(42).fork()).join();
    }
    if (message.answerRecord !== "") {
      writer.uint32(18).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogflowAssistAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogflowAssistAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryResult = QueryResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intentSuggestion = IntentSuggestion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogflowAssistAnswer {
    return {
      queryResult: isSet(object.queryResult) ? QueryResult.fromJSON(object.queryResult) : undefined,
      intentSuggestion: isSet(object.intentSuggestion) ? IntentSuggestion.fromJSON(object.intentSuggestion) : undefined,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: DialogflowAssistAnswer): unknown {
    const obj: any = {};
    if (message.queryResult !== undefined) {
      obj.queryResult = QueryResult.toJSON(message.queryResult);
    }
    if (message.intentSuggestion !== undefined) {
      obj.intentSuggestion = IntentSuggestion.toJSON(message.intentSuggestion);
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<DialogflowAssistAnswer>): DialogflowAssistAnswer {
    return DialogflowAssistAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogflowAssistAnswer>): DialogflowAssistAnswer {
    const message = createBaseDialogflowAssistAnswer();
    message.queryResult = (object.queryResult !== undefined && object.queryResult !== null)
      ? QueryResult.fromPartial(object.queryResult)
      : undefined;
    message.intentSuggestion = (object.intentSuggestion !== undefined && object.intentSuggestion !== null)
      ? IntentSuggestion.fromPartial(object.intentSuggestion)
      : undefined;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseSuggestionResult(): SuggestionResult {
  return {
    error: undefined,
    suggestArticlesResponse: undefined,
    suggestKnowledgeAssistResponse: undefined,
    suggestFaqAnswersResponse: undefined,
    suggestSmartRepliesResponse: undefined,
  };
}

export const SuggestionResult: MessageFns<SuggestionResult> = {
  encode(message: SuggestionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.suggestArticlesResponse !== undefined) {
      SuggestArticlesResponse.encode(message.suggestArticlesResponse, writer.uint32(18).fork()).join();
    }
    if (message.suggestKnowledgeAssistResponse !== undefined) {
      SuggestKnowledgeAssistResponse.encode(message.suggestKnowledgeAssistResponse, writer.uint32(66).fork()).join();
    }
    if (message.suggestFaqAnswersResponse !== undefined) {
      SuggestFaqAnswersResponse.encode(message.suggestFaqAnswersResponse, writer.uint32(26).fork()).join();
    }
    if (message.suggestSmartRepliesResponse !== undefined) {
      SuggestSmartRepliesResponse.encode(message.suggestSmartRepliesResponse, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestArticlesResponse = SuggestArticlesResponse.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.suggestKnowledgeAssistResponse = SuggestKnowledgeAssistResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.suggestFaqAnswersResponse = SuggestFaqAnswersResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.suggestSmartRepliesResponse = SuggestSmartRepliesResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionResult {
    return {
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      suggestArticlesResponse: isSet(object.suggestArticlesResponse)
        ? SuggestArticlesResponse.fromJSON(object.suggestArticlesResponse)
        : undefined,
      suggestKnowledgeAssistResponse: isSet(object.suggestKnowledgeAssistResponse)
        ? SuggestKnowledgeAssistResponse.fromJSON(object.suggestKnowledgeAssistResponse)
        : undefined,
      suggestFaqAnswersResponse: isSet(object.suggestFaqAnswersResponse)
        ? SuggestFaqAnswersResponse.fromJSON(object.suggestFaqAnswersResponse)
        : undefined,
      suggestSmartRepliesResponse: isSet(object.suggestSmartRepliesResponse)
        ? SuggestSmartRepliesResponse.fromJSON(object.suggestSmartRepliesResponse)
        : undefined,
    };
  },

  toJSON(message: SuggestionResult): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.suggestArticlesResponse !== undefined) {
      obj.suggestArticlesResponse = SuggestArticlesResponse.toJSON(message.suggestArticlesResponse);
    }
    if (message.suggestKnowledgeAssistResponse !== undefined) {
      obj.suggestKnowledgeAssistResponse = SuggestKnowledgeAssistResponse.toJSON(
        message.suggestKnowledgeAssistResponse,
      );
    }
    if (message.suggestFaqAnswersResponse !== undefined) {
      obj.suggestFaqAnswersResponse = SuggestFaqAnswersResponse.toJSON(message.suggestFaqAnswersResponse);
    }
    if (message.suggestSmartRepliesResponse !== undefined) {
      obj.suggestSmartRepliesResponse = SuggestSmartRepliesResponse.toJSON(message.suggestSmartRepliesResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestionResult>): SuggestionResult {
    return SuggestionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestionResult>): SuggestionResult {
    const message = createBaseSuggestionResult();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.suggestArticlesResponse =
      (object.suggestArticlesResponse !== undefined && object.suggestArticlesResponse !== null)
        ? SuggestArticlesResponse.fromPartial(object.suggestArticlesResponse)
        : undefined;
    message.suggestKnowledgeAssistResponse =
      (object.suggestKnowledgeAssistResponse !== undefined && object.suggestKnowledgeAssistResponse !== null)
        ? SuggestKnowledgeAssistResponse.fromPartial(object.suggestKnowledgeAssistResponse)
        : undefined;
    message.suggestFaqAnswersResponse =
      (object.suggestFaqAnswersResponse !== undefined && object.suggestFaqAnswersResponse !== null)
        ? SuggestFaqAnswersResponse.fromPartial(object.suggestFaqAnswersResponse)
        : undefined;
    message.suggestSmartRepliesResponse =
      (object.suggestSmartRepliesResponse !== undefined && object.suggestSmartRepliesResponse !== null)
        ? SuggestSmartRepliesResponse.fromPartial(object.suggestSmartRepliesResponse)
        : undefined;
    return message;
  },
};

function createBaseInputTextConfig(): InputTextConfig {
  return { languageCode: "" };
}

export const InputTextConfig: MessageFns<InputTextConfig> = {
  encode(message: InputTextConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputTextConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputTextConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputTextConfig {
    return { languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "" };
  },

  toJSON(message: InputTextConfig): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<InputTextConfig>): InputTextConfig {
    return InputTextConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputTextConfig>): InputTextConfig {
    const message = createBaseInputTextConfig();
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseAnnotatedMessagePart(): AnnotatedMessagePart {
  return { text: "", entityType: "", formattedValue: undefined };
}

export const AnnotatedMessagePart: MessageFns<AnnotatedMessagePart> = {
  encode(message: AnnotatedMessagePart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.formattedValue !== undefined) {
      Value.encode(Value.wrap(message.formattedValue), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedMessagePart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedMessagePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.formattedValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedMessagePart {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      formattedValue: isSet(object?.formattedValue) ? object.formattedValue : undefined,
    };
  },

  toJSON(message: AnnotatedMessagePart): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.formattedValue !== undefined) {
      obj.formattedValue = message.formattedValue;
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatedMessagePart>): AnnotatedMessagePart {
    return AnnotatedMessagePart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatedMessagePart>): AnnotatedMessagePart {
    const message = createBaseAnnotatedMessagePart();
    message.text = object.text ?? "";
    message.entityType = object.entityType ?? "";
    message.formattedValue = object.formattedValue ?? undefined;
    return message;
  },
};

function createBaseMessageAnnotation(): MessageAnnotation {
  return { parts: [], containEntities: false };
}

export const MessageAnnotation: MessageFns<MessageAnnotation> = {
  encode(message: MessageAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parts) {
      AnnotatedMessagePart.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.containEntities !== false) {
      writer.uint32(16).bool(message.containEntities);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parts.push(AnnotatedMessagePart.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.containEntities = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageAnnotation {
    return {
      parts: globalThis.Array.isArray(object?.parts)
        ? object.parts.map((e: any) => AnnotatedMessagePart.fromJSON(e))
        : [],
      containEntities: isSet(object.containEntities) ? globalThis.Boolean(object.containEntities) : false,
    };
  },

  toJSON(message: MessageAnnotation): unknown {
    const obj: any = {};
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => AnnotatedMessagePart.toJSON(e));
    }
    if (message.containEntities !== false) {
      obj.containEntities = message.containEntities;
    }
    return obj;
  },

  create(base?: DeepPartial<MessageAnnotation>): MessageAnnotation {
    return MessageAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageAnnotation>): MessageAnnotation {
    const message = createBaseMessageAnnotation();
    message.parts = object.parts?.map((e) => AnnotatedMessagePart.fromPartial(e)) || [];
    message.containEntities = object.containEntities ?? false;
    return message;
  },
};

function createBaseSuggestionInput(): SuggestionInput {
  return { answerRecord: "" };
}

export const SuggestionInput: MessageFns<SuggestionInput> = {
  encode(message: SuggestionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerRecord !== "") {
      writer.uint32(10).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionInput {
    return { answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "" };
  },

  toJSON(message: SuggestionInput): unknown {
    const obj: any = {};
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestionInput>): SuggestionInput {
    return SuggestionInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestionInput>): SuggestionInput {
    const message = createBaseSuggestionInput();
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseAssistQueryParameters(): AssistQueryParameters {
  return { documentsMetadataFilters: {} };
}

export const AssistQueryParameters: MessageFns<AssistQueryParameters> = {
  encode(message: AssistQueryParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.documentsMetadataFilters).forEach(([key, value]) => {
      AssistQueryParameters_DocumentsMetadataFiltersEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistQueryParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistQueryParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AssistQueryParameters_DocumentsMetadataFiltersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.documentsMetadataFilters[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistQueryParameters {
    return {
      documentsMetadataFilters: isObject(object.documentsMetadataFilters)
        ? Object.entries(object.documentsMetadataFilters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AssistQueryParameters): unknown {
    const obj: any = {};
    if (message.documentsMetadataFilters) {
      const entries = Object.entries(message.documentsMetadataFilters);
      if (entries.length > 0) {
        obj.documentsMetadataFilters = {};
        entries.forEach(([k, v]) => {
          obj.documentsMetadataFilters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AssistQueryParameters>): AssistQueryParameters {
    return AssistQueryParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssistQueryParameters>): AssistQueryParameters {
    const message = createBaseAssistQueryParameters();
    message.documentsMetadataFilters = Object.entries(object.documentsMetadataFilters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry(): AssistQueryParameters_DocumentsMetadataFiltersEntry {
  return { key: "", value: "" };
}

export const AssistQueryParameters_DocumentsMetadataFiltersEntry: MessageFns<
  AssistQueryParameters_DocumentsMetadataFiltersEntry
> = {
  encode(
    message: AssistQueryParameters_DocumentsMetadataFiltersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssistQueryParameters_DocumentsMetadataFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AssistQueryParameters_DocumentsMetadataFiltersEntry>,
  ): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    return AssistQueryParameters_DocumentsMetadataFiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AssistQueryParameters_DocumentsMetadataFiltersEntry>,
  ): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    const message = createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSuggestKnowledgeAssistRequest(): SuggestKnowledgeAssistRequest {
  return { parent: "", latestMessage: "", contextSize: 0, previousSuggestedQuery: "" };
}

export const SuggestKnowledgeAssistRequest: MessageFns<SuggestKnowledgeAssistRequest> = {
  encode(message: SuggestKnowledgeAssistRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.previousSuggestedQuery !== "") {
      writer.uint32(34).string(message.previousSuggestedQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestKnowledgeAssistRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestKnowledgeAssistRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.previousSuggestedQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestKnowledgeAssistRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      previousSuggestedQuery: isSet(object.previousSuggestedQuery)
        ? globalThis.String(object.previousSuggestedQuery)
        : "",
    };
  },

  toJSON(message: SuggestKnowledgeAssistRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.previousSuggestedQuery !== "") {
      obj.previousSuggestedQuery = message.previousSuggestedQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestKnowledgeAssistRequest>): SuggestKnowledgeAssistRequest {
    return SuggestKnowledgeAssistRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestKnowledgeAssistRequest>): SuggestKnowledgeAssistRequest {
    const message = createBaseSuggestKnowledgeAssistRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.previousSuggestedQuery = object.previousSuggestedQuery ?? "";
    return message;
  },
};

function createBaseSuggestKnowledgeAssistResponse(): SuggestKnowledgeAssistResponse {
  return { knowledgeAssistAnswer: undefined, latestMessage: "", contextSize: 0 };
}

export const SuggestKnowledgeAssistResponse: MessageFns<SuggestKnowledgeAssistResponse> = {
  encode(message: SuggestKnowledgeAssistResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.knowledgeAssistAnswer !== undefined) {
      KnowledgeAssistAnswer.encode(message.knowledgeAssistAnswer, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestKnowledgeAssistResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestKnowledgeAssistResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.knowledgeAssistAnswer = KnowledgeAssistAnswer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestKnowledgeAssistResponse {
    return {
      knowledgeAssistAnswer: isSet(object.knowledgeAssistAnswer)
        ? KnowledgeAssistAnswer.fromJSON(object.knowledgeAssistAnswer)
        : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestKnowledgeAssistResponse): unknown {
    const obj: any = {};
    if (message.knowledgeAssistAnswer !== undefined) {
      obj.knowledgeAssistAnswer = KnowledgeAssistAnswer.toJSON(message.knowledgeAssistAnswer);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestKnowledgeAssistResponse>): SuggestKnowledgeAssistResponse {
    return SuggestKnowledgeAssistResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestKnowledgeAssistResponse>): SuggestKnowledgeAssistResponse {
    const message = createBaseSuggestKnowledgeAssistResponse();
    message.knowledgeAssistAnswer =
      (object.knowledgeAssistAnswer !== undefined && object.knowledgeAssistAnswer !== null)
        ? KnowledgeAssistAnswer.fromPartial(object.knowledgeAssistAnswer)
        : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseKnowledgeAssistAnswer(): KnowledgeAssistAnswer {
  return { suggestedQuery: undefined, suggestedQueryAnswer: undefined, answerRecord: "" };
}

export const KnowledgeAssistAnswer: MessageFns<KnowledgeAssistAnswer> = {
  encode(message: KnowledgeAssistAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestedQuery !== undefined) {
      KnowledgeAssistAnswer_SuggestedQuery.encode(message.suggestedQuery, writer.uint32(10).fork()).join();
    }
    if (message.suggestedQueryAnswer !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer.encode(message.suggestedQueryAnswer, writer.uint32(18).fork()).join();
    }
    if (message.answerRecord !== "") {
      writer.uint32(26).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestedQuery = KnowledgeAssistAnswer_SuggestedQuery.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestedQueryAnswer = KnowledgeAssistAnswer_KnowledgeAnswer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer {
    return {
      suggestedQuery: isSet(object.suggestedQuery)
        ? KnowledgeAssistAnswer_SuggestedQuery.fromJSON(object.suggestedQuery)
        : undefined,
      suggestedQueryAnswer: isSet(object.suggestedQueryAnswer)
        ? KnowledgeAssistAnswer_KnowledgeAnswer.fromJSON(object.suggestedQueryAnswer)
        : undefined,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: KnowledgeAssistAnswer): unknown {
    const obj: any = {};
    if (message.suggestedQuery !== undefined) {
      obj.suggestedQuery = KnowledgeAssistAnswer_SuggestedQuery.toJSON(message.suggestedQuery);
    }
    if (message.suggestedQueryAnswer !== undefined) {
      obj.suggestedQueryAnswer = KnowledgeAssistAnswer_KnowledgeAnswer.toJSON(message.suggestedQueryAnswer);
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer>): KnowledgeAssistAnswer {
    return KnowledgeAssistAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer>): KnowledgeAssistAnswer {
    const message = createBaseKnowledgeAssistAnswer();
    message.suggestedQuery = (object.suggestedQuery !== undefined && object.suggestedQuery !== null)
      ? KnowledgeAssistAnswer_SuggestedQuery.fromPartial(object.suggestedQuery)
      : undefined;
    message.suggestedQueryAnswer = (object.suggestedQueryAnswer !== undefined && object.suggestedQueryAnswer !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer.fromPartial(object.suggestedQueryAnswer)
      : undefined;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_SuggestedQuery(): KnowledgeAssistAnswer_SuggestedQuery {
  return { queryText: "" };
}

export const KnowledgeAssistAnswer_SuggestedQuery: MessageFns<KnowledgeAssistAnswer_SuggestedQuery> = {
  encode(message: KnowledgeAssistAnswer_SuggestedQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryText !== "") {
      writer.uint32(10).string(message.queryText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_SuggestedQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_SuggestedQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_SuggestedQuery {
    return { queryText: isSet(object.queryText) ? globalThis.String(object.queryText) : "" };
  },

  toJSON(message: KnowledgeAssistAnswer_SuggestedQuery): unknown {
    const obj: any = {};
    if (message.queryText !== "") {
      obj.queryText = message.queryText;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer_SuggestedQuery>): KnowledgeAssistAnswer_SuggestedQuery {
    return KnowledgeAssistAnswer_SuggestedQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer_SuggestedQuery>): KnowledgeAssistAnswer_SuggestedQuery {
    const message = createBaseKnowledgeAssistAnswer_SuggestedQuery();
    message.queryText = object.queryText ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer(): KnowledgeAssistAnswer_KnowledgeAnswer {
  return { answerText: "", faqSource: undefined, generativeSource: undefined };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer: MessageFns<KnowledgeAssistAnswer_KnowledgeAnswer> = {
  encode(message: KnowledgeAssistAnswer_KnowledgeAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerText !== "") {
      writer.uint32(10).string(message.answerText);
    }
    if (message.faqSource !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.encode(message.faqSource, writer.uint32(26).fork()).join();
    }
    if (message.generativeSource !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.encode(message.generativeSource, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.faqSource = KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.generativeSource = KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer {
    return {
      answerText: isSet(object.answerText) ? globalThis.String(object.answerText) : "",
      faqSource: isSet(object.faqSource)
        ? KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromJSON(object.faqSource)
        : undefined,
      generativeSource: isSet(object.generativeSource)
        ? KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromJSON(object.generativeSource)
        : undefined,
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer): unknown {
    const obj: any = {};
    if (message.answerText !== "") {
      obj.answerText = message.answerText;
    }
    if (message.faqSource !== undefined) {
      obj.faqSource = KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.toJSON(message.faqSource);
    }
    if (message.generativeSource !== undefined) {
      obj.generativeSource = KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.toJSON(message.generativeSource);
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer>): KnowledgeAssistAnswer_KnowledgeAnswer {
    return KnowledgeAssistAnswer_KnowledgeAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer>): KnowledgeAssistAnswer_KnowledgeAnswer {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer();
    message.answerText = object.answerText ?? "";
    message.faqSource = (object.faqSource !== undefined && object.faqSource !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromPartial(object.faqSource)
      : undefined;
    message.generativeSource = (object.generativeSource !== undefined && object.generativeSource !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromPartial(object.generativeSource)
      : undefined;
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource(): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
  return { question: "" };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    return { question: isSet(object.question) ? globalThis.String(object.question) : "" };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource): unknown {
    const obj: any = {};
    if (message.question !== "") {
      obj.question = message.question;
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    return KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource();
    message.question = object.question ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource(): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
  return { snippets: [] };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.snippets) {
      KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snippets.push(
            KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    return {
      snippets: globalThis.Array.isArray(object?.snippets)
        ? object.snippets.map((e: any) => KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource): unknown {
    const obj: any = {};
    if (message.snippets?.length) {
      obj.snippets = message.snippets.map((e) =>
        KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    return KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource();
    message.snippets =
      object.snippets?.map((e) => KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet(): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
  return { uri: "", text: "", title: "" };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    return KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet();
    message.uri = object.uri ?? "";
    message.text = object.text ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

/** Service for managing [Participants][google.cloud.dialogflow.v2.Participant]. */
export type ParticipantsDefinition = typeof ParticipantsDefinition;
export const ParticipantsDefinition = {
  name: "Participants",
  fullName: "google.cloud.dialogflow.v2.Participants",
  methods: {
    /** Creates a new participant in a conversation. */
    createParticipant: {
      name: "CreateParticipant",
      requestType: CreateParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 112, 97, 114, 116, 105, 99, 105, 112, 97, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              148,
              1,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              90,
              79,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              34,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              34,
              52,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a conversation participant. */
    getParticipant: {
      name: "GetParticipant",
      requestType: GetParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              122,
              90,
              66,
              18,
              64,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              18,
              52,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all participants in the specified conversation. */
    listParticipants: {
      name: "ListParticipants",
      requestType: ListParticipantsRequest,
      requestStream: false,
      responseType: ListParticipantsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              122,
              90,
              66,
              18,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              18,
              52,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the specified participant. */
    updateParticipant: {
      name: "UpdateParticipant",
      requestType: UpdateParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              172,
              1,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              90,
              91,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              50,
              76,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              50,
              64,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a text (chat, for example), or audio (phone recording, for example)
     * message from a participant into the conversation.
     *
     * Note: Always use agent versions for production traffic
     * sent to virtual agents. See [Versions and
     * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
     */
    analyzeContent: {
      name: "AnalyzeContent",
      requestType: AnalyzeContentRequest,
      requestStream: false,
      responseType: AnalyzeContentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              116,
              101,
              120,
              116,
              95,
              105,
              110,
              112,
              117,
              116,
            ]),
            Buffer.from([
              23,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              101,
              118,
              101,
              110,
              116,
              95,
              105,
              110,
              112,
              117,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              172,
              1,
              58,
              1,
              42,
              90,
              91,
              58,
              1,
              42,
              34,
              86,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              110,
              116,
              101,
              110,
              116,
              34,
              74,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              110,
              116,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a text (chat, for example), or audio (phone recording, for example)
     * message from a participant into the conversation.
     * Note: This method is only available through the gRPC API (not REST).
     *
     * The top-level message sent to the client by the server is
     * `StreamingAnalyzeContentResponse`. Multiple response messages can be
     * returned in order. The first one or more messages contain the
     * `recognition_result` field. Each result represents a more complete
     * transcript of what the user said. The next message contains the
     * `reply_text` field and potentially the `reply_audio` field. The message can
     * also contain the `automated_agent_reply` field.
     *
     * Note: Always use agent versions for production traffic
     * sent to virtual agents. See [Versions and
     * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
     */
    streamingAnalyzeContent: {
      name: "StreamingAnalyzeContent",
      requestType: StreamingAnalyzeContentRequest,
      requestStream: true,
      responseType: StreamingAnalyzeContentResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Gets suggested articles for a participant based on specific historical
     * messages.
     */
    suggestArticles: {
      name: "SuggestArticles",
      requestType: SuggestArticlesRequest,
      requestStream: false,
      responseType: SuggestArticlesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              188,
              1,
              58,
              1,
              42,
              90,
              99,
              58,
              1,
              42,
              34,
              94,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              65,
              114,
              116,
              105,
              99,
              108,
              101,
              115,
              34,
              82,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              65,
              114,
              116,
              105,
              99,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets suggested faq answers for a participant based on specific historical
     * messages.
     */
    suggestFaqAnswers: {
      name: "SuggestFaqAnswers",
      requestType: SuggestFaqAnswersRequest,
      requestStream: false,
      responseType: SuggestFaqAnswersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              192,
              1,
              58,
              1,
              42,
              90,
              101,
              58,
              1,
              42,
              34,
              96,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              70,
              97,
              113,
              65,
              110,
              115,
              119,
              101,
              114,
              115,
              34,
              84,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              70,
              97,
              113,
              65,
              110,
              115,
              119,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets smart replies for a participant based on specific historical
     * messages.
     */
    suggestSmartReplies: {
      name: "SuggestSmartReplies",
      requestType: SuggestSmartRepliesRequest,
      requestStream: false,
      responseType: SuggestSmartRepliesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              196,
              1,
              58,
              1,
              42,
              90,
              103,
              58,
              1,
              42,
              34,
              98,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              83,
              109,
              97,
              114,
              116,
              82,
              101,
              112,
              108,
              105,
              101,
              115,
              34,
              86,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              83,
              109,
              97,
              114,
              116,
              82,
              101,
              112,
              108,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets knowledge assist suggestions based on historical messages. */
    suggestKnowledgeAssist: {
      name: "SuggestKnowledgeAssist",
      requestType: SuggestKnowledgeAssistRequest,
      requestStream: false,
      responseType: SuggestKnowledgeAssistResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              202,
              1,
              58,
              1,
              42,
              90,
              106,
              58,
              1,
              42,
              34,
              101,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              65,
              115,
              115,
              105,
              115,
              116,
              34,
              89,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              65,
              115,
              115,
              105,
              115,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ParticipantsServiceImplementation<CallContextExt = {}> {
  /** Creates a new participant in a conversation. */
  createParticipant(
    request: CreateParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /** Retrieves a conversation participant. */
  getParticipant(
    request: GetParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /** Returns the list of all participants in the specified conversation. */
  listParticipants(
    request: ListParticipantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListParticipantsResponse>>;
  /** Updates the specified participant. */
  updateParticipant(
    request: UpdateParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  analyzeContent(
    request: AnalyzeContentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnalyzeContentResponse>>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   * Note: This method is only available through the gRPC API (not REST).
   *
   * The top-level message sent to the client by the server is
   * `StreamingAnalyzeContentResponse`. Multiple response messages can be
   * returned in order. The first one or more messages contain the
   * `recognition_result` field. Each result represents a more complete
   * transcript of what the user said. The next message contains the
   * `reply_text` field and potentially the `reply_audio` field. The message can
   * also contain the `automated_agent_reply` field.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  streamingAnalyzeContent(
    request: AsyncIterable<StreamingAnalyzeContentRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamingAnalyzeContentResponse>>;
  /**
   * Gets suggested articles for a participant based on specific historical
   * messages.
   */
  suggestArticles(
    request: SuggestArticlesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestArticlesResponse>>;
  /**
   * Gets suggested faq answers for a participant based on specific historical
   * messages.
   */
  suggestFaqAnswers(
    request: SuggestFaqAnswersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestFaqAnswersResponse>>;
  /**
   * Gets smart replies for a participant based on specific historical
   * messages.
   */
  suggestSmartReplies(
    request: SuggestSmartRepliesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestSmartRepliesResponse>>;
  /** Gets knowledge assist suggestions based on historical messages. */
  suggestKnowledgeAssist(
    request: SuggestKnowledgeAssistRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestKnowledgeAssistResponse>>;
}

export interface ParticipantsClient<CallOptionsExt = {}> {
  /** Creates a new participant in a conversation. */
  createParticipant(
    request: DeepPartial<CreateParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /** Retrieves a conversation participant. */
  getParticipant(
    request: DeepPartial<GetParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /** Returns the list of all participants in the specified conversation. */
  listParticipants(
    request: DeepPartial<ListParticipantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListParticipantsResponse>;
  /** Updates the specified participant. */
  updateParticipant(
    request: DeepPartial<UpdateParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  analyzeContent(
    request: DeepPartial<AnalyzeContentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnalyzeContentResponse>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   * Note: This method is only available through the gRPC API (not REST).
   *
   * The top-level message sent to the client by the server is
   * `StreamingAnalyzeContentResponse`. Multiple response messages can be
   * returned in order. The first one or more messages contain the
   * `recognition_result` field. Each result represents a more complete
   * transcript of what the user said. The next message contains the
   * `reply_text` field and potentially the `reply_audio` field. The message can
   * also contain the `automated_agent_reply` field.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  streamingAnalyzeContent(
    request: AsyncIterable<DeepPartial<StreamingAnalyzeContentRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamingAnalyzeContentResponse>;
  /**
   * Gets suggested articles for a participant based on specific historical
   * messages.
   */
  suggestArticles(
    request: DeepPartial<SuggestArticlesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestArticlesResponse>;
  /**
   * Gets suggested faq answers for a participant based on specific historical
   * messages.
   */
  suggestFaqAnswers(
    request: DeepPartial<SuggestFaqAnswersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestFaqAnswersResponse>;
  /**
   * Gets smart replies for a participant based on specific historical
   * messages.
   */
  suggestSmartReplies(
    request: DeepPartial<SuggestSmartRepliesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestSmartRepliesResponse>;
  /** Gets knowledge assist suggestions based on historical messages. */
  suggestKnowledgeAssist(
    request: DeepPartial<SuggestKnowledgeAssistRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestKnowledgeAssistResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
