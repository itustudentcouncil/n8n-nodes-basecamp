// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/v2beta1/participant.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct, Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { InputAudioConfig, OutputAudioConfig, TelephonyDtmfEvents } from "./audio_config.js";
import {
  CloudConversationDebuggingInfo,
  DetectIntentResponse,
  EventInput,
  QueryParameters,
  QueryResult,
  SentimentAnalysisResult,
  StreamingRecognitionResult,
  TextInput,
} from "./session.js";

export const protobufPackage = "google.cloud.dialogflow.v2beta1";

/** Represents a conversation participant (human agent, virtual agent, end-user). */
export interface Participant {
  /**
   * Optional. The unique identifier of this participant.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  name: string;
  /**
   * Immutable. The role this participant plays in the conversation. This field
   * must be set during participant creation and is then immutable.
   */
  role: Participant_Role;
  /**
   * Optional. Obfuscated user id that should be associated with the created
   * participant.
   *
   * You can specify a user id as follows:
   *
   * 1. If you set this field in
   *    [CreateParticipantRequest][google.cloud.dialogflow.v2beta1.CreateParticipantRequest.participant]
   *    or
   *    [UpdateParticipantRequest][google.cloud.dialogflow.v2beta1.UpdateParticipantRequest.participant],
   *    Dialogflow adds the obfuscated user id with the participant.
   *
   * 2. If you set this field in
   *    [AnalyzeContent][google.cloud.dialogflow.v2beta1.AnalyzeContentRequest.obfuscated_external_user_id]
   *    or
   *    [StreamingAnalyzeContent][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.obfuscated_external_user_id],
   *    Dialogflow will update
   *    [Participant.obfuscated_external_user_id][google.cloud.dialogflow.v2beta1.Participant.obfuscated_external_user_id].
   *
   * Dialogflow uses this user id for billing and measurement. If a user with
   * the same obfuscated_external_user_id is created in a later conversation,
   * Dialogflow will know it's the same user.
   *
   * Dialogflow also uses this user id for Agent Assist suggestion
   * personalization. For example, Dialogflow can use it to provide personalized
   * smart reply suggestions for this user.
   *
   * Note:
   *
   * * Please never pass raw user ids to Dialogflow. Always obfuscate your user
   *   id first.
   * * Dialogflow only accepts a UTF-8 encoded string, e.g., a hex digest of a
   *   hash function like SHA-512.
   * * The length of the user id must be <= 256 characters.
   */
  obfuscatedExternalUserId: string;
  /**
   * Optional. Key-value filters on the metadata of documents returned by
   * article suggestion. If specified, article suggestion only returns suggested
   * documents that match all filters in their
   * [Document.metadata][google.cloud.dialogflow.v2beta1.Document.metadata].
   * Multiple values for a metadata key should be concatenated by comma. For
   * example, filters to match all documents that have 'US' or 'CA' in their
   * market metadata values and 'agent' in their user metadata values will be
   * ```
   * documents_metadata_filters {
   *   key: "market"
   *   value: "US,CA"
   * }
   * documents_metadata_filters {
   *   key: "user"
   *   value: "agent"
   * }
   * ```
   */
  documentsMetadataFilters: { [key: string]: string };
}

/** Enumeration of the roles a participant can play in a conversation. */
export enum Participant_Role {
  /** ROLE_UNSPECIFIED - Participant role not set. */
  ROLE_UNSPECIFIED = 0,
  /** HUMAN_AGENT - Participant is a human agent. */
  HUMAN_AGENT = 1,
  /** AUTOMATED_AGENT - Participant is an automated agent, such as a Dialogflow agent. */
  AUTOMATED_AGENT = 2,
  /**
   * END_USER - Participant is an end user that has called or chatted with
   * Dialogflow services.
   */
  END_USER = 3,
  UNRECOGNIZED = -1,
}

export function participant_RoleFromJSON(object: any): Participant_Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return Participant_Role.ROLE_UNSPECIFIED;
    case 1:
    case "HUMAN_AGENT":
      return Participant_Role.HUMAN_AGENT;
    case 2:
    case "AUTOMATED_AGENT":
      return Participant_Role.AUTOMATED_AGENT;
    case 3:
    case "END_USER":
      return Participant_Role.END_USER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Participant_Role.UNRECOGNIZED;
  }
}

export function participant_RoleToJSON(object: Participant_Role): string {
  switch (object) {
    case Participant_Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case Participant_Role.HUMAN_AGENT:
      return "HUMAN_AGENT";
    case Participant_Role.AUTOMATED_AGENT:
      return "AUTOMATED_AGENT";
    case Participant_Role.END_USER:
      return "END_USER";
    case Participant_Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Participant_DocumentsMetadataFiltersEntry {
  key: string;
  value: string;
}

/** Represents a message posted into a conversation. */
export interface Message {
  /**
   * Optional. The unique identifier of the message.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  name: string;
  /** Required. The message content. */
  content: string;
  /** Optional. Automated agent responses. */
  responseMessages: ResponseMessage[];
  /**
   * Optional. The message language.
   * This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag. Example: "en-US".
   */
  languageCode: string;
  /** Output only. The participant that sends this message. */
  participant: string;
  /** Output only. The role of the participant. */
  participantRole: Participant_Role;
  /** Output only. The time when the message was created in Contact Center AI. */
  createTime:
    | Date
    | undefined;
  /** Optional. The time when the message was sent. */
  sendTime:
    | Date
    | undefined;
  /** Output only. The annotation for the message. */
  messageAnnotation:
    | MessageAnnotation
    | undefined;
  /** Output only. The sentiment analysis result for the message. */
  sentimentAnalysis: SentimentAnalysisResult | undefined;
}

/**
 * The request message for
 * [Participants.CreateParticipant][google.cloud.dialogflow.v2beta1.Participants.CreateParticipant].
 */
export interface CreateParticipantRequest {
  /**
   * Required. Resource identifier of the conversation adding the participant.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  parent: string;
  /** Required. The participant to create. */
  participant: Participant | undefined;
}

/**
 * The request message for
 * [Participants.GetParticipant][google.cloud.dialogflow.v2beta1.Participants.GetParticipant].
 */
export interface GetParticipantRequest {
  /**
   * Required. The name of the participant. Format:
   * `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
   * ID>/participants/<Participant ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Participants.ListParticipants][google.cloud.dialogflow.v2beta1.Participants.ListParticipants].
 */
export interface ListParticipantsRequest {
  /**
   * Required. The conversation to list all participants from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>`.
   */
  parent: string;
  /**
   * Optional. The maximum number of items to return in a single page. By
   * default 100 and at most 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Participants.ListParticipants][google.cloud.dialogflow.v2beta1.Participants.ListParticipants].
 */
export interface ListParticipantsResponse {
  /**
   * The list of participants. There is a maximum number of items
   * returned based on the page_size field in the request.
   */
  participants: Participant[];
  /**
   * Token to retrieve the next page of results or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Participants.UpdateParticipant][google.cloud.dialogflow.v2beta1.Participants.UpdateParticipant].
 */
export interface UpdateParticipantRequest {
  /** Required. The participant to update. */
  participant:
    | Participant
    | undefined;
  /** Required. The mask to specify which fields to update. */
  updateMask: string[] | undefined;
}

/** Represents the natural language speech audio to be processed. */
export interface AudioInput {
  /** Required. Instructs the speech recognizer how to process the speech audio. */
  config:
    | InputAudioConfig
    | undefined;
  /**
   * Required. The natural language speech audio to be processed.
   * A single request can contain up to 2 minutes of speech audio data.
   * The transcribed text cannot contain more than 256 bytes for virtual agent
   * interactions.
   */
  audio: Buffer;
}

/** Represents the natural language speech audio to be played to the end user. */
export interface OutputAudio {
  /**
   * Required. Instructs the speech synthesizer how to generate the speech
   * audio.
   */
  config:
    | OutputAudioConfig
    | undefined;
  /** Required. The natural language speech audio. */
  audio: Buffer;
}

/** Represents a response from an automated agent. */
export interface AutomatedAgentReply {
  /**
   * Response of the Dialogflow
   * [Sessions.DetectIntent][google.cloud.dialogflow.v2beta1.Sessions.DetectIntent]
   * call.
   */
  detectIntentResponse?:
    | DetectIntentResponse
    | undefined;
  /** Response messages from the automated agent. */
  responseMessages: ResponseMessage[];
  /**
   * Name of the intent if an intent is matched for the query.
   * For a V2 query, the value format is `projects/<Project ID>/locations/
   * <Location ID>/agent/intents/<Intent ID>`.
   * For a V3 query, the value format is `projects/<Project ID>/locations/
   * <Location ID>/agents/<Agent ID>/intents/<Intent ID>`.
   */
  intent?:
    | string
    | undefined;
  /** Event name if an event is triggered for the query. */
  event?:
    | string
    | undefined;
  /**
   * The confidence of the match. Values range from 0.0 (completely uncertain)
   * to 1.0 (completely certain).
   * This value is for informational purpose only and is only used to help match
   * the best intent within the classification threshold. This value may change
   * for the same end-user expression at any time due to a model retraining or
   * change in implementation.
   */
  matchConfidence: number;
  /** The collection of current parameters at the time of this response. */
  parameters:
    | { [key: string]: any }
    | undefined;
  /**
   * The collection of current Dialogflow CX agent session parameters at the
   * time of this response.
   * Deprecated: Use `parameters` instead.
   *
   * @deprecated
   */
  cxSessionParameters:
    | { [key: string]: any }
    | undefined;
  /** AutomatedAgentReply type. */
  automatedAgentReplyType: AutomatedAgentReply_AutomatedAgentReplyType;
  /**
   * Indicates whether the partial automated agent reply is interruptible when a
   * later reply message arrives. e.g. if the agent specified some music as
   * partial response, it can be cancelled.
   */
  allowCancellation: boolean;
  /**
   * The unique identifier of the current Dialogflow CX conversation page.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  cxCurrentPage: string;
  /** The auth code for accessing Call Companion UI. */
  callCompanionAuthCode: Buffer;
}

/** Represents different automated agent reply types. */
export enum AutomatedAgentReply_AutomatedAgentReplyType {
  /** AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED - Not specified. This should never happen. */
  AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED = 0,
  /**
   * PARTIAL - Partial reply. e.g. Aggregated responses in a `Fulfillment` that enables
   * `return_partial_response` can be returned as partial reply.
   * WARNING: partial reply is not eligible for barge-in.
   */
  PARTIAL = 1,
  /** FINAL - Final reply. */
  FINAL = 2,
  UNRECOGNIZED = -1,
}

export function automatedAgentReply_AutomatedAgentReplyTypeFromJSON(
  object: any,
): AutomatedAgentReply_AutomatedAgentReplyType {
  switch (object) {
    case 0:
    case "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED":
      return AutomatedAgentReply_AutomatedAgentReplyType.AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED;
    case 1:
    case "PARTIAL":
      return AutomatedAgentReply_AutomatedAgentReplyType.PARTIAL;
    case 2:
    case "FINAL":
      return AutomatedAgentReply_AutomatedAgentReplyType.FINAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomatedAgentReply_AutomatedAgentReplyType.UNRECOGNIZED;
  }
}

export function automatedAgentReply_AutomatedAgentReplyTypeToJSON(
  object: AutomatedAgentReply_AutomatedAgentReplyType,
): string {
  switch (object) {
    case AutomatedAgentReply_AutomatedAgentReplyType.AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED:
      return "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED";
    case AutomatedAgentReply_AutomatedAgentReplyType.PARTIAL:
      return "PARTIAL";
    case AutomatedAgentReply_AutomatedAgentReplyType.FINAL:
      return "FINAL";
    case AutomatedAgentReply_AutomatedAgentReplyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the selection of a suggestion. */
export interface SuggestionInput {
  /**
   * Required. The ID of a suggestion selected by the human agent.
   * The suggestion(s) were generated in a previous call to
   * request Dialogflow assist.
   * The format is:
   * `projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>` where <Answer Record ID> is an alphanumeric string.
   */
  answerRecord: string;
  /**
   * Optional. If the customer edited the suggestion before using it, include
   * the revised text here.
   */
  textOverride:
    | TextInput
    | undefined;
  /**
   * In Dialogflow assist for v3, the user can submit a form by sending
   * a [SuggestionInput][google.cloud.dialogflow.v2beta1.SuggestionInput]. The
   * form is uniquely determined by the
   * [answer_record][google.cloud.dialogflow.v2beta1.SuggestionInput.answer_record]
   * field, which identifies a v3
   * [QueryResult][google.cloud.dialogflow.v3alpha1.QueryResult] containing the
   * current [page][google.cloud.dialogflow.v3alpha1.Page]. The form parameters
   * are specified via the
   * [parameters][google.cloud.dialogflow.v2beta1.SuggestionInput.parameters]
   * field.
   *
   * Depending on your protocol or client library language, this is a
   * map, associative array, symbol table, dictionary, or JSON object
   * composed of a collection of (MapKey, MapValue) pairs:
   *
   * * MapKey type: string
   * * MapKey value: parameter name
   * * MapValue type: If parameter's entity type is a composite entity then use
   * map, otherwise, depending on the parameter value type, it could be one of
   * string, number, boolean, null, list or map.
   * * MapValue value: If parameter's entity type is a composite entity then use
   * map from composite entity property names to property values, otherwise,
   * use parameter value.
   */
  parameters:
    | { [key: string]: any }
    | undefined;
  /** The intent to be triggered on V3 agent. */
  intentInput: IntentInput | undefined;
}

/**
 * Represents the intent to trigger programmatically rather than as a result of
 * natural language processing. The intent input is only used for V3 agent.
 */
export interface IntentInput {
  /**
   * Required. The unique identifier of the intent in V3 agent.
   * Format: `projects/<Project ID>/locations/<Location ID>/locations/<Location
   * ID>/agents/<Agent ID>/intents/<Intent ID>`.
   */
  intent: string;
  /**
   * Required. The language of this conversational query. See [Language
   * Support](https://cloud.google.com/dialogflow/docs/reference/language)
   * for a list of the currently supported language codes.
   */
  languageCode: string;
}

/**
 * The type of Human Agent Assistant API suggestion to perform, and the maximum
 * number of results to return for that type. Multiple `Feature` objects can
 * be specified in the `features` list.
 */
export interface SuggestionFeature {
  /** Type of Human Agent Assistant API feature to request. */
  type: SuggestionFeature_Type;
}

/** Defines the type of Human Agent Assistant feature. */
export enum SuggestionFeature_Type {
  /** TYPE_UNSPECIFIED - Unspecified feature type. */
  TYPE_UNSPECIFIED = 0,
  /** ARTICLE_SUGGESTION - Run article suggestion model for chat. */
  ARTICLE_SUGGESTION = 1,
  /** FAQ - Run FAQ model. */
  FAQ = 2,
  /** SMART_REPLY - Run smart reply model for chat. */
  SMART_REPLY = 3,
  /**
   * DIALOGFLOW_ASSIST - Run Dialogflow assist model for chat, which will return automated agent
   * response as suggestion.
   */
  DIALOGFLOW_ASSIST = 4,
  /** CONVERSATION_SUMMARIZATION - Run conversation summarization model for chat. */
  CONVERSATION_SUMMARIZATION = 8,
  /** KNOWLEDGE_SEARCH - Run knowledge search with text input from agent or text generated query. */
  KNOWLEDGE_SEARCH = 14,
  /** KNOWLEDGE_ASSIST - Run knowledge assist with automatic query generation. */
  KNOWLEDGE_ASSIST = 15,
  UNRECOGNIZED = -1,
}

export function suggestionFeature_TypeFromJSON(object: any): SuggestionFeature_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return SuggestionFeature_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ARTICLE_SUGGESTION":
      return SuggestionFeature_Type.ARTICLE_SUGGESTION;
    case 2:
    case "FAQ":
      return SuggestionFeature_Type.FAQ;
    case 3:
    case "SMART_REPLY":
      return SuggestionFeature_Type.SMART_REPLY;
    case 4:
    case "DIALOGFLOW_ASSIST":
      return SuggestionFeature_Type.DIALOGFLOW_ASSIST;
    case 8:
    case "CONVERSATION_SUMMARIZATION":
      return SuggestionFeature_Type.CONVERSATION_SUMMARIZATION;
    case 14:
    case "KNOWLEDGE_SEARCH":
      return SuggestionFeature_Type.KNOWLEDGE_SEARCH;
    case 15:
    case "KNOWLEDGE_ASSIST":
      return SuggestionFeature_Type.KNOWLEDGE_ASSIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SuggestionFeature_Type.UNRECOGNIZED;
  }
}

export function suggestionFeature_TypeToJSON(object: SuggestionFeature_Type): string {
  switch (object) {
    case SuggestionFeature_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case SuggestionFeature_Type.ARTICLE_SUGGESTION:
      return "ARTICLE_SUGGESTION";
    case SuggestionFeature_Type.FAQ:
      return "FAQ";
    case SuggestionFeature_Type.SMART_REPLY:
      return "SMART_REPLY";
    case SuggestionFeature_Type.DIALOGFLOW_ASSIST:
      return "DIALOGFLOW_ASSIST";
    case SuggestionFeature_Type.CONVERSATION_SUMMARIZATION:
      return "CONVERSATION_SUMMARIZATION";
    case SuggestionFeature_Type.KNOWLEDGE_SEARCH:
      return "KNOWLEDGE_SEARCH";
    case SuggestionFeature_Type.KNOWLEDGE_ASSIST:
      return "KNOWLEDGE_ASSIST";
    case SuggestionFeature_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the parameters of human assist query. */
export interface AssistQueryParameters {
  /**
   * Key-value filters on the metadata of documents returned by article
   * suggestion. If specified, article suggestion only returns suggested
   * documents that match all filters in their
   * [Document.metadata][google.cloud.dialogflow.v2beta1.Document.metadata].
   * Multiple values for a metadata key should be concatenated by comma. For
   * example, filters to match all documents that have 'US' or 'CA' in their
   * market metadata values and 'agent' in their user metadata values will be
   * ```
   * documents_metadata_filters {
   *   key: "market"
   *   value: "US,CA"
   * }
   * documents_metadata_filters {
   *   key: "user"
   *   value: "agent"
   * }
   * ```
   */
  documentsMetadataFilters: { [key: string]: string };
}

export interface AssistQueryParameters_DocumentsMetadataFiltersEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.AnalyzeContent].
 */
export interface AnalyzeContentRequest {
  /**
   * Required. The name of the participant this text comes from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  participant: string;
  /** The natural language text to be processed. */
  textInput?:
    | TextInput
    | undefined;
  /** The natural language speech audio to be processed. */
  audioInput?:
    | AudioInput
    | undefined;
  /** An input event to send to Dialogflow. */
  eventInput?:
    | EventInput
    | undefined;
  /** An input representing the selection of a suggestion. */
  suggestionInput?:
    | SuggestionInput
    | undefined;
  /** The intent to be triggered on V3 agent. */
  intentInput?:
    | IntentInput
    | undefined;
  /**
   * Speech synthesis configuration.
   * The speech synthesis settings for a virtual agent that may be configured
   * for the associated conversation profile are not used when calling
   * AnalyzeContent. If this configuration is not supplied, speech synthesis
   * is disabled.
   */
  replyAudioConfig:
    | OutputAudioConfig
    | undefined;
  /** Parameters for a Dialogflow virtual-agent query. */
  queryParams:
    | QueryParameters
    | undefined;
  /** Parameters for a human assist query. */
  assistQueryParams:
    | AssistQueryParameters
    | undefined;
  /**
   * Additional parameters to be put into Dialogflow CX session parameters. To
   * remove a parameter from the session, clients should explicitly set the
   * parameter value to null.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * The unique identifier of the CX page to override the `current_page` in the
   * session.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   *
   * If `cx_current_page` is specified, the previous state of the session will
   * be ignored by Dialogflow CX, including the [previous
   * page][QueryResult.current_page] and the [previous session
   * parameters][QueryResult.parameters]. In most cases, `cx_current_page` and
   * `cx_parameters` should be configured together to direct a session to a
   * specific state.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxCurrentPage: string;
  /**
   * Optional. The send time of the message from end user or human agent's
   * perspective. It is used for identifying the same message under one
   * participant.
   *
   * Given two messages under the same participant:
   * * If send time are different regardless of whether the content of the
   * messages are exactly the same, the conversation will regard them as
   * two distinct messages sent by the participant.
   * * If send time is the same regardless of whether the content of the
   * messages are exactly the same, the conversation will regard them as
   * same message, and ignore the message received later.
   *
   * If the value is not provided, a new request will always be regarded as a
   * new message without any de-duplication.
   */
  messageSendTime:
    | Date
    | undefined;
  /**
   * A unique identifier for this request. Restricted to 36 ASCII characters.
   * A random UUID is recommended.
   * This request is only idempotent if a `request_id` is provided.
   */
  requestId: string;
}

/** The message in the response that indicates the parameters of DTMF. */
export interface DtmfParameters {
  /** Indicates whether DTMF input can be handled in the next request. */
  acceptsDtmfInput: boolean;
}

/**
 * The response message for
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.AnalyzeContent].
 */
export interface AnalyzeContentResponse {
  /**
   * Output only. The output text content.
   * This field is set if the automated agent responded with text to show to
   * the user.
   */
  replyText: string;
  /**
   * Optional. The audio data bytes encoded as specified in the request.
   * This field is set if:
   *
   *  - `reply_audio_config` was specified in the request, or
   *  - The automated agent responded with audio to play to the user. In such
   *    case, `reply_audio.config` contains settings used to synthesize the
   *    speech.
   *
   * In some scenarios, multiple output audio fields may be present in the
   * response structure. In these cases, only the top-most-level audio output
   * has content.
   */
  replyAudio:
    | OutputAudio
    | undefined;
  /**
   * Optional. Only set if a Dialogflow automated agent has responded.
   * Note that: [AutomatedAgentReply.detect_intent_response.output_audio][]
   * and [AutomatedAgentReply.detect_intent_response.output_audio_config][]
   * are always empty, use
   * [reply_audio][google.cloud.dialogflow.v2beta1.AnalyzeContentResponse.reply_audio]
   * instead.
   */
  automatedAgentReply:
    | AutomatedAgentReply
    | undefined;
  /** Output only. Message analyzed by CCAI. */
  message:
    | Message
    | undefined;
  /**
   * The suggestions for most recent human agent. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.human_agent_suggestion_config].
   *
   * Note that any failure of Agent Assist features will not lead to the overall
   * failure of an AnalyzeContent API call. Instead, the features will
   * fail silently with the error field set in the corresponding
   * SuggestionResult.
   */
  humanAgentSuggestionResults: SuggestionResult[];
  /**
   * The suggestions for end user. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.end_user_suggestion_config].
   *
   * Same as human_agent_suggestion_results, any failure of Agent Assist
   * features will not lead to the overall failure of an AnalyzeContent API
   * call. Instead, the features will fail silently with the error field set in
   * the corresponding SuggestionResult.
   */
  endUserSuggestionResults: SuggestionResult[];
  /** Indicates the parameters of DTMF. */
  dtmfParameters: DtmfParameters | undefined;
}

/** Defines the language used in the input text. */
export interface InputTextConfig {
  /**
   * Required. The language of this conversational query. See [Language
   * Support](https://cloud.google.com/dialogflow/docs/reference/language)
   * for a list of the currently supported language codes.
   */
  languageCode: string;
}

/**
 * The top-level message sent by the client to the
 * [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.StreamingAnalyzeContent]
 * method.
 *
 * Multiple request messages should be sent in order:
 *
 * 1.  The first message must contain
 *     [participant][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.participant],
 *     [config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.config]
 *     and optionally
 *     [query_params][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.query_params].
 *     If you want to receive an audio response, it should also contain
 *     [reply_audio_config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.reply_audio_config].
 *     The message must not contain
 *     [input][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.input].
 *
 * 2.  If
 * [config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.config]
 * in the first message
 *     was set to
 *     [audio_config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.audio_config],
 *     all subsequent messages must contain
 *     [input_audio][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.input_audio]
 *     to continue with Speech recognition. If you decide to rather analyze text
 *     input after you already started Speech recognition, please send a message
 *     with
 *     [StreamingAnalyzeContentRequest.input_text][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.input_text].
 *
 *     However, note that:
 *
 *     * Dialogflow will bill you for the audio so far.
 *     * Dialogflow discards all Speech recognition results in favor of the
 *       text input.
 *
 *  3. If
 *  [StreamingAnalyzeContentRequest.config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.config]
 *  in the first message was set
 *    to
 *    [StreamingAnalyzeContentRequest.text_config][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.text_config],
 *    then the second message must contain only
 *    [input_text][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentRequest.input_text].
 *    Moreover, you must not send more than two messages.
 *
 *  After you sent all input, you must half-close or abort the request stream.
 */
export interface StreamingAnalyzeContentRequest {
  /**
   * Required. The name of the participant this text comes from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  participant: string;
  /** Instructs the speech recognizer how to process the speech audio. */
  audioConfig?:
    | InputAudioConfig
    | undefined;
  /** The natural language text to be processed. */
  textConfig?:
    | InputTextConfig
    | undefined;
  /**
   * Speech synthesis configuration.
   * The speech synthesis settings for a virtual agent that may be configured
   * for the associated conversation profile are not used when calling
   * StreamingAnalyzeContent. If this configuration is not supplied, speech
   * synthesis is disabled.
   */
  replyAudioConfig:
    | OutputAudioConfig
    | undefined;
  /**
   * The input audio content to be recognized. Must be sent if `audio_config`
   * is set in the first message. The complete audio over all streaming
   * messages must not exceed 1 minute.
   */
  inputAudio?:
    | Buffer
    | undefined;
  /**
   * The UTF-8 encoded natural language text to be processed. Must be sent if
   * `text_config` is set in the first message. Text length must not exceed
   * 256 bytes for virtual agent interactions. The `input_text` field can be
   * only sent once, and would cancel the speech recognition if any ongoing.
   */
  inputText?:
    | string
    | undefined;
  /**
   * The DTMF digits used to invoke intent and fill in parameter value.
   *
   * This input is ignored if the previous response indicated that DTMF input
   * is not accepted.
   */
  inputDtmf?:
    | TelephonyDtmfEvents
    | undefined;
  /**
   * The intent to be triggered on V3 agent.
   * Format: `projects/<Project ID>/locations/<Location ID>/locations/
   * <Location ID>/agents/<Agent ID>/intents/<Intent ID>`.
   */
  inputIntent?:
    | string
    | undefined;
  /**
   * The input event name.
   * This can only be sent once and would cancel the ongoing speech
   * recognition if any.
   */
  inputEvent?:
    | string
    | undefined;
  /** Parameters for a Dialogflow virtual-agent query. */
  queryParams:
    | QueryParameters
    | undefined;
  /** Parameters for a human assist query. */
  assistQueryParams:
    | AssistQueryParameters
    | undefined;
  /**
   * Additional parameters to be put into Dialogflow CX session parameters. To
   * remove a parameter from the session, clients should explicitly set the
   * parameter value to null.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxParameters:
    | { [key: string]: any }
    | undefined;
  /**
   * The unique identifier of the CX page to override the `current_page` in the
   * session.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   *
   * If `cx_current_page` is specified, the previous state of the session will
   * be ignored by Dialogflow CX, including the [previous
   * page][QueryResult.current_page] and the [previous session
   * parameters][QueryResult.parameters]. In most cases, `cx_current_page` and
   * `cx_parameters` should be configured together to direct a session to a
   * specific state.
   *
   * Note: this field should only be used if you are connecting to a Dialogflow
   * CX agent.
   */
  cxCurrentPage: string;
  /**
   * Optional. Enable full bidirectional streaming. You can keep streaming the
   * audio until timeout, and there's no need to half close the stream to get
   * the response.
   *
   * Restrictions:
   *
   * - Timeout: 3 mins.
   * - Audio Encoding: only supports
   * [AudioEncoding.AUDIO_ENCODING_LINEAR_16][google.cloud.dialogflow.v2beta1.AudioEncoding.AUDIO_ENCODING_LINEAR_16]
   * and
   * [AudioEncoding.AUDIO_ENCODING_MULAW][google.cloud.dialogflow.v2beta1.AudioEncoding.AUDIO_ENCODING_MULAW]
   * - Lifecycle: conversation should be in `Assist Stage`, go to
   *   [Conversation.CreateConversation][] for more information.
   *
   * InvalidArgument Error will be returned if the one of restriction checks
   * failed.
   *
   * You can find more details in
   * https://cloud.google.com/agent-assist/docs/extended-streaming
   */
  enableExtendedStreaming: boolean;
  /**
   * Enable partial virtual agent responses. If this flag is not enabled,
   * response stream still contains only one final response even if some
   * `Fulfillment`s in Dialogflow virtual agent have been configured to return
   * partial responses.
   */
  enablePartialAutomatedAgentReply: boolean;
  /**
   * if true, `StreamingAnalyzeContentResponse.debugging_info` will get
   * populated.
   */
  enableDebuggingInfo: boolean;
}

/**
 * The top-level message returned from the `StreamingAnalyzeContent` method.
 *
 * Multiple response messages can be returned in order:
 *
 * 1.  If the input was set to streaming audio, the first one or more messages
 *     contain `recognition_result`. Each `recognition_result` represents a more
 *     complete transcript of what the user said. The last `recognition_result`
 *     has `is_final` set to `true`.
 *
 * 2.  In virtual agent stage: if `enable_partial_automated_agent_reply` is
 *     true, the following N (currently 1 <= N <= 4) messages
 *     contain `automated_agent_reply` and optionally `reply_audio`
 *     returned by the virtual agent. The first (N-1)
 *     `automated_agent_reply`s will have `automated_agent_reply_type` set to
 *     `PARTIAL`. The last `automated_agent_reply` has
 *     `automated_agent_reply_type` set to `FINAL`.
 *     If `enable_partial_automated_agent_reply` is not enabled, response stream
 *     only contains the final reply.
 *
 *     In human assist stage: the following N (N >= 1) messages contain
 *     `human_agent_suggestion_results`, `end_user_suggestion_results` or
 *     `message`.
 */
export interface StreamingAnalyzeContentResponse {
  /** The result of speech recognition. */
  recognitionResult:
    | StreamingRecognitionResult
    | undefined;
  /**
   * Optional. The output text content.
   * This field is set if an automated agent responded with a text for the user.
   */
  replyText: string;
  /**
   * Optional. The audio data bytes encoded as specified in the request.
   * This field is set if:
   *
   *  - The `reply_audio_config` field is specified in the request.
   *  - The automated agent, which this output comes from, responded with audio.
   *    In such case, the `reply_audio.config` field contains settings used to
   *    synthesize the speech.
   *
   * In some scenarios, multiple output audio fields may be present in the
   * response structure. In these cases, only the top-most-level audio output
   * has content.
   */
  replyAudio:
    | OutputAudio
    | undefined;
  /**
   * Optional. Only set if a Dialogflow automated agent has responded.
   * Note that: [AutomatedAgentReply.detect_intent_response.output_audio][]
   * and [AutomatedAgentReply.detect_intent_response.output_audio_config][]
   * are always empty, use
   * [reply_audio][google.cloud.dialogflow.v2beta1.StreamingAnalyzeContentResponse.reply_audio]
   * instead.
   */
  automatedAgentReply:
    | AutomatedAgentReply
    | undefined;
  /** Output only. Message analyzed by CCAI. */
  message:
    | Message
    | undefined;
  /**
   * The suggestions for most recent human agent. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.human_agent_suggestion_config].
   */
  humanAgentSuggestionResults: SuggestionResult[];
  /**
   * The suggestions for end user. The order is the same as
   * [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
   * of
   * [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.end_user_suggestion_config].
   */
  endUserSuggestionResults: SuggestionResult[];
  /** Indicates the parameters of DTMF. */
  dtmfParameters:
    | DtmfParameters
    | undefined;
  /**
   * Debugging info that would get populated when
   * `StreamingAnalyzeContentRequest.enable_debugging_info` is set to true.
   */
  debuggingInfo: CloudConversationDebuggingInfo | undefined;
}

/**
 * Represents a part of a message possibly annotated with an entity. The part
 * can be an entity or purely a part of the message between two entities or
 * message start/end.
 */
export interface AnnotatedMessagePart {
  /** Required. A part of a message possibly annotated with an entity. */
  text: string;
  /**
   * Optional. The [Dialogflow system entity
   * type](https://cloud.google.com/dialogflow/docs/reference/system-entities)
   * of this message part. If this is empty, Dialogflow could not annotate the
   * phrase part with a system entity.
   */
  entityType: string;
  /**
   * Optional. The [Dialogflow system entity formatted value
   * ](https://cloud.google.com/dialogflow/docs/reference/system-entities) of
   * this message part. For example for a system entity of type
   * `@sys.unit-currency`, this may contain:
   * <pre>
   * {
   *   "amount": 5,
   *   "currency": "USD"
   * }
   * </pre>
   */
  formattedValue: any | undefined;
}

/** Represents the result of annotation for the message. */
export interface MessageAnnotation {
  /**
   * Optional. The collection of annotated message parts ordered by their
   * position in the message. You can recover the annotated message by
   * concatenating [AnnotatedMessagePart.text].
   */
  parts: AnnotatedMessagePart[];
  /** Required. Indicates whether the text message contains entities. */
  containEntities: boolean;
}

/** Represents article answer. */
export interface ArticleAnswer {
  /** The article title. */
  title: string;
  /** The article URI. */
  uri: string;
  /** Output only. Article snippets. */
  snippets: string[];
  /**
   * A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

export interface ArticleAnswer_MetadataEntry {
  key: string;
  value: string;
}

/** Represents answer from "frequently asked questions". */
export interface FaqAnswer {
  /** The piece of text from the `source` knowledge base document. */
  answer: string;
  /**
   * The system's confidence score that this Knowledge answer is a good match
   * for this conversational query, range from 0.0 (completely uncertain)
   * to 1.0 (completely certain).
   */
  confidence: number;
  /** The corresponding FAQ question. */
  question: string;
  /**
   * Indicates which Knowledge Document this answer was extracted
   * from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/agent/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
   */
  source: string;
  /**
   * A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

export interface FaqAnswer_MetadataEntry {
  key: string;
  value: string;
}

/** Represents a smart reply answer. */
export interface SmartReplyAnswer {
  /** The content of the reply. */
  reply: string;
  /**
   * Smart reply confidence.
   * The system's confidence score that this reply is a good match for
   * this conversation, as a value from 0.0 (completely uncertain) to 1.0
   * (completely certain).
   */
  confidence: number;
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

/** Represents an intent suggestion. */
export interface IntentSuggestion {
  /** The display name of the intent. */
  displayName: string;
  /**
   * The unique identifier of this
   * [intent][google.cloud.dialogflow.v2beta1.Intent]. Format:
   * `projects/<Project ID>/locations/<Location ID>/agent/intents/<Intent
   * ID>`.
   */
  intentV2?:
    | string
    | undefined;
  /**
   * Human readable description for better understanding an intent like its
   * scope, content, result etc. Maximum character limit: 140 characters.
   */
  description: string;
}

/** Represents a Dialogflow assist answer. */
export interface DialogflowAssistAnswer {
  /** Result from v2 agent. */
  queryResult?:
    | QueryResult
    | undefined;
  /** An intent suggestion generated from conversation. */
  intentSuggestion?:
    | IntentSuggestion
    | undefined;
  /**
   * The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
   * ID>"
   */
  answerRecord: string;
}

/**
 * One response of different type of suggestion response which is used in
 * the response of
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.AnalyzeContent]
 * and
 * [Participants.AnalyzeContent][google.cloud.dialogflow.v2beta1.Participants.AnalyzeContent],
 * as well as
 * [HumanAgentAssistantEvent][google.cloud.dialogflow.v2beta1.HumanAgentAssistantEvent].
 */
export interface SuggestionResult {
  /** Error status if the request failed. */
  error?:
    | Status
    | undefined;
  /** SuggestArticlesResponse if request is for ARTICLE_SUGGESTION. */
  suggestArticlesResponse?:
    | SuggestArticlesResponse
    | undefined;
  /** SuggestKnowledgeAssistResponse if request is for KNOWLEDGE_ASSIST. */
  suggestKnowledgeAssistResponse?:
    | SuggestKnowledgeAssistResponse
    | undefined;
  /** SuggestFaqAnswersResponse if request is for FAQ_ANSWER. */
  suggestFaqAnswersResponse?:
    | SuggestFaqAnswersResponse
    | undefined;
  /** SuggestSmartRepliesResponse if request is for SMART_REPLY. */
  suggestSmartRepliesResponse?:
    | SuggestSmartRepliesResponse
    | undefined;
  /** SuggestDialogflowAssistsResponse if request is for DIALOGFLOW_ASSIST. */
  suggestDialogflowAssistsResponse?:
    | SuggestDialogflowAssistsResponse
    | undefined;
  /** SuggestDialogflowAssistsResponse if request is for ENTITY_EXTRACTION. */
  suggestEntityExtractionResponse?: SuggestDialogflowAssistsResponse | undefined;
}

/**
 * The request message for
 * [Participants.SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles].
 */
export interface SuggestArticlesRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestArticlesRequest.latest_message]
   * to use as context when compiling the suggestion. By default 20 and at
   * most 50.
   */
  contextSize: number;
  /** Optional. Parameters for a human assist query. */
  assistQueryParams: AssistQueryParameters | undefined;
}

/**
 * The response message for
 * [Participants.SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles].
 */
export interface SuggestArticlesResponse {
  /** Output only. Articles ordered by score in descending order. */
  articleAnswers: ArticleAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestArticlesResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestArticlesResponse.context_size][google.cloud.dialogflow.v2beta1.SuggestArticlesResponse.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * The request message for
 * [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers].
 */
export interface SuggestFaqAnswersRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 20 and at most 50.
   */
  contextSize: number;
  /** Optional. Parameters for a human assist query. */
  assistQueryParams: AssistQueryParameters | undefined;
}

/**
 * The request message for
 * [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers].
 */
export interface SuggestFaqAnswersResponse {
  /** Output only. Answers extracted from FAQ documents. */
  faqAnswers: FaqAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestFaqAnswersResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestFaqAnswersRequest.context_size][google.cloud.dialogflow.v2beta1.SuggestFaqAnswersRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * The request message for
 * [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2beta1.Participants.SuggestSmartReplies].
 */
export interface SuggestSmartRepliesRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * The current natural language text segment to compile suggestion
   * for. This provides a way for user to get follow up smart reply suggestion
   * after a smart reply selection, without sending a text message.
   */
  currentTextInput:
    | TextInput
    | undefined;
  /**
   * The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. By default 20 and at most 50.
   */
  contextSize: number;
}

/**
 * The response message for
 * [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2beta1.Participants.SuggestSmartReplies].
 */
export interface SuggestSmartRepliesResponse {
  /**
   * Output only. Multiple reply options provided by smart reply service. The
   * order is based on the rank of the model prediction.
   * The maximum number of the returned replies is set in SmartReplyConfig.
   */
  smartReplyAnswers: SmartReplyAnswer[];
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestSmartRepliesResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestSmartRepliesRequest.context_size][google.cloud.dialogflow.v2beta1.SuggestSmartRepliesRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * The response message for
 * [Participants.SuggestDialogflowAssists][google.cloud.dialogflow.v2beta1.Participants.SuggestDialogflowAssists].
 */
export interface SuggestDialogflowAssistsResponse {
  /**
   * Output only. Multiple reply options provided by Dialogflow assist
   * service. The order is based on the rank of the model prediction.
   */
  dialogflowAssistAnswers: DialogflowAssistAnswer[];
  /**
   * The name of the latest conversation message used to suggest answer.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestDialogflowAssistsResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestDialogflowAssistsRequest.context_size][google.cloud.dialogflow.v2beta1.SuggestDialogflowAssistsRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/**
 * Represents a suggestion for a human agent.
 *
 * @deprecated
 */
export interface Suggestion {
  /**
   * Output only. The name of this suggestion.
   * Format:
   * `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
   * ID>/participants/* /suggestions/<Suggestion ID>`.
   */
  name: string;
  /** Output only. Articles ordered by score in descending order. */
  articles: Suggestion_Article[];
  /** Output only. Answers extracted from FAQ documents. */
  faqAnswers: Suggestion_FaqAnswer[];
  /** Output only. The time the suggestion was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Latest message used as context to compile this suggestion.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
}

/** Represents suggested article. */
export interface Suggestion_Article {
  /** Output only. The article title. */
  title: string;
  /** Output only. The article URI. */
  uri: string;
  /** Output only. Article snippets. */
  snippets: string[];
  /**
   * Output only. A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * Output only. The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer
   * Record ID>"
   */
  answerRecord: string;
}

export interface Suggestion_Article_MetadataEntry {
  key: string;
  value: string;
}

/** Represents suggested answer from "frequently asked questions". */
export interface Suggestion_FaqAnswer {
  /** Output only. The piece of text from the `source` knowledge base document. */
  answer: string;
  /**
   * The system's confidence score that this Knowledge answer is a good match
   * for this conversational query, range from 0.0 (completely uncertain)
   * to 1.0 (completely certain).
   */
  confidence: number;
  /** Output only. The corresponding FAQ question. */
  question: string;
  /**
   * Output only. Indicates which Knowledge Document this answer was extracted
   * from.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/agent/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
   */
  source: string;
  /**
   * Output only. A map that contains metadata about the answer and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * Output only. The name of answer record, in the format of
   * "projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer
   * Record ID>"
   */
  answerRecord: string;
}

export interface Suggestion_FaqAnswer_MetadataEntry {
  key: string;
  value: string;
}

/**
 * The request message for
 * [Participants.ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions].
 *
 * @deprecated
 */
export interface ListSuggestionsRequest {
  /**
   * Required. The name of the participant to fetch suggestions for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The maximum number of items to return in a single page. The
   * default value is 100; the maximum value is 1000.
   */
  pageSize: number;
  /** Optional. The next_page_token value returned from a previous list request. */
  pageToken: string;
  /**
   * Optional. Filter on suggestions fields. Currently predicates on
   * `create_time` and `create_time_epoch_microseconds` are supported.
   * `create_time` only support milliseconds accuracy. E.g.,
   * `create_time_epoch_microseconds > 1551790877964485` or
   * `create_time > "2017-01-15T01:30:15.01Z"`
   *
   * For more information about filtering, see
   * [API Filtering](https://aip.dev/160).
   */
  filter: string;
}

/**
 * The response message for
 * [Participants.ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions].
 *
 * @deprecated
 */
export interface ListSuggestionsResponse {
  /**
   * Required. The list of suggestions. There will be a maximum number of items
   * returned based on the page_size field in the request. `suggestions` is
   * sorted by `create_time` in descending order.
   */
  suggestions: Suggestion[];
  /**
   * Optional. Token to retrieve the next page of results or empty if there are
   * no more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Participants.CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion].
 *
 * @deprecated
 */
export interface CompileSuggestionRequest {
  /**
   * Required. The name of the participant to fetch suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile suggestion
   * for. If empty, it will be the latest message of the conversation.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message] to use as context when compiling the
   * suggestion. If zero or less than zero, 20 is used.
   */
  contextSize: number;
}

/**
 * The response message for
 * [Participants.CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion].
 *
 * @deprecated
 */
export interface CompileSuggestionResponse {
  /** The compiled suggestion. */
  suggestion:
    | Suggestion
    | undefined;
  /**
   * The name of the latest conversation message used to compile
   * suggestion for.
   *
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.CompileSuggestionResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [CompileSuggestionRequest.context_size][google.cloud.dialogflow.v2beta1.CompileSuggestionRequest.context_size]
   * field in the request if there aren't that many messages in the
   * conversation.
   */
  contextSize: number;
}

/** Response messages from an automated agent. */
export interface ResponseMessage {
  /** Returns a text response. */
  text?:
    | ResponseMessage_Text
    | undefined;
  /** Returns a response containing a custom, platform-specific payload. */
  payload?:
    | { [key: string]: any }
    | undefined;
  /** Hands off conversation to a live agent. */
  liveAgentHandoff?:
    | ResponseMessage_LiveAgentHandoff
    | undefined;
  /**
   * A signal that indicates the interaction with the Dialogflow agent has
   * ended.
   */
  endInteraction?:
    | ResponseMessage_EndInteraction
    | undefined;
  /**
   * An audio response message composed of both the synthesized Dialogflow
   * agent responses and the audios hosted in places known to the client.
   */
  mixedAudio?:
    | ResponseMessage_MixedAudio
    | undefined;
  /**
   * A signal that the client should transfer the phone call connected to
   * this agent to a third-party endpoint.
   */
  telephonyTransferCall?: ResponseMessage_TelephonyTransferCall | undefined;
}

/** The text response message. */
export interface ResponseMessage_Text {
  /** A collection of text responses. */
  text: string[];
}

/**
 * Indicates that the conversation should be handed off to a human agent.
 *
 * Dialogflow only uses this to determine which conversations were handed off
 * to a human agent for measurement purposes. What else to do with this signal
 * is up to you and your handoff procedures.
 *
 * You may set this, for example:
 *
 * * In the entry fulfillment of a CX Page if entering the page indicates
 *   something went extremely wrong in the conversation.
 * * In a webhook response when you determine that the customer issue can only
 *   be handled by a human.
 */
export interface ResponseMessage_LiveAgentHandoff {
  /**
   * Custom metadata for your handoff procedure. Dialogflow doesn't impose
   * any structure on this.
   */
  metadata: { [key: string]: any } | undefined;
}

/** Indicates that interaction with the Dialogflow agent has ended. */
export interface ResponseMessage_EndInteraction {
}

/**
 * Represents an audio message that is composed of both segments
 * synthesized from the Dialogflow agent prompts and ones hosted externally
 * at the specified URIs.
 */
export interface ResponseMessage_MixedAudio {
  /** Segments this audio response is composed of. */
  segments: ResponseMessage_MixedAudio_Segment[];
}

/** Represents one segment of audio. */
export interface ResponseMessage_MixedAudio_Segment {
  /**
   * Raw audio synthesized from the Dialogflow agent's response using
   * the output config specified in the request.
   */
  audio?:
    | Buffer
    | undefined;
  /**
   * Client-specific URI that points to an audio clip accessible to the
   * client.
   */
  uri?:
    | string
    | undefined;
  /**
   * Whether the playback of this segment can be interrupted by the end
   * user's speech and the client should then start the next Dialogflow
   * request.
   */
  allowPlaybackInterruption: boolean;
}

/**
 * Represents the signal that telles the client to transfer the phone call
 * connected to the agent to a third-party endpoint.
 */
export interface ResponseMessage_TelephonyTransferCall {
  /**
   * Transfer the call to a phone number
   * in [E.164 format](https://en.wikipedia.org/wiki/E.164).
   */
  phoneNumber?:
    | string
    | undefined;
  /** Transfer the call to a SIP endpoint. */
  sipUri?: string | undefined;
}

/**
 * The request message for
 * [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2beta1.Participants.SuggestKnowledgeAssist].
 */
export interface SuggestKnowledgeAssistRequest {
  /**
   * Required. The name of the participant to fetch suggestions for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
   */
  parent: string;
  /**
   * Optional. The name of the latest conversation message to compile
   * suggestions for. If empty, it will be the latest message of the
   * conversation. Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Optional. Max number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestKnowledgeAssistRequest.latest_message]
   * to use as context when compiling the suggestion. The context size is by
   * default 100 and at most 100.
   */
  contextSize: number;
  /**
   * Optional. The previously suggested query for the given conversation. This
   * helps identify whether the next suggestion we generate is resonably
   * different from the previous one. This is useful to avoid similar
   * suggestions within the conversation.
   */
  previousSuggestedQuery: string;
}

/**
 * The response message for
 * [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2beta1.Participants.SuggestKnowledgeAssist].
 */
export interface SuggestKnowledgeAssistResponse {
  /** Output only. Knowledge Assist suggestion. */
  knowledgeAssistAnswer:
    | KnowledgeAssistAnswer
    | undefined;
  /**
   * The name of the latest conversation message used to compile suggestion for.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/conversations/<Conversation ID>/messages/<Message ID>`.
   */
  latestMessage: string;
  /**
   * Number of messages prior to and including
   * [latest_message][google.cloud.dialogflow.v2beta1.SuggestKnowledgeAssistResponse.latest_message]
   * to compile the suggestion. It may be smaller than the
   * [SuggestKnowledgeAssistRequest.context_size][google.cloud.dialogflow.v2beta1.SuggestKnowledgeAssistRequest.context_size]
   * field in the request if there are fewer messages in the conversation.
   */
  contextSize: number;
}

/** Represents a Knowledge Assist answer. */
export interface KnowledgeAssistAnswer {
  /**
   * The query suggested based on the context. Suggestion is made only if it
   * is different from the previous suggestion.
   */
  suggestedQuery:
    | KnowledgeAssistAnswer_SuggestedQuery
    | undefined;
  /**
   * The answer generated for the suggested query. Whether or not an answer is
   * generated depends on how confident we are about the generated query.
   */
  suggestedQueryAnswer:
    | KnowledgeAssistAnswer_KnowledgeAnswer
    | undefined;
  /**
   * The name of the answer record.
   * Format: `projects/<Project ID>/locations/<location ID>/answer
   * Records/<Answer Record ID>`.
   */
  answerRecord: string;
}

/** Represents a suggested query. */
export interface KnowledgeAssistAnswer_SuggestedQuery {
  /** Suggested query text. */
  queryText: string;
}

/**
 * Represents an answer from Knowledge. Currently supports FAQ and Generative
 * answers.
 */
export interface KnowledgeAssistAnswer_KnowledgeAnswer {
  /** The piece of text from the `source` that answers this suggested query. */
  answerText: string;
  /** Populated if the prediction came from FAQ. */
  faqSource?:
    | KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource
    | undefined;
  /** Populated if the prediction was Generative. */
  generativeSource?: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource | undefined;
}

/** Details about source of FAQ answer. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
  /** The corresponding FAQ question. */
  question: string;
}

/** Details about source of Generative answer. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
  /**
   * All snippets used for this Generative Prediction, with their source URI
   * and data.
   */
  snippets: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet[];
}

/** Snippet Source for a Generative Prediction. */
export interface KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
  /** URI the data is sourced from. */
  uri: string;
  /** Text taken from that URI. */
  text: string;
  /** Title of the document. */
  title: string;
}

function createBaseParticipant(): Participant {
  return { name: "", role: 0, obfuscatedExternalUserId: "", documentsMetadataFilters: {} };
}

export const Participant: MessageFns<Participant> = {
  encode(message: Participant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.obfuscatedExternalUserId !== "") {
      writer.uint32(58).string(message.obfuscatedExternalUserId);
    }
    Object.entries(message.documentsMetadataFilters).forEach(([key, value]) => {
      Participant_DocumentsMetadataFiltersEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.obfuscatedExternalUserId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Participant_DocumentsMetadataFiltersEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.documentsMetadataFilters[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      role: isSet(object.role) ? participant_RoleFromJSON(object.role) : 0,
      obfuscatedExternalUserId: isSet(object.obfuscatedExternalUserId)
        ? globalThis.String(object.obfuscatedExternalUserId)
        : "",
      documentsMetadataFilters: isObject(object.documentsMetadataFilters)
        ? Object.entries(object.documentsMetadataFilters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Participant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.role !== 0) {
      obj.role = participant_RoleToJSON(message.role);
    }
    if (message.obfuscatedExternalUserId !== "") {
      obj.obfuscatedExternalUserId = message.obfuscatedExternalUserId;
    }
    if (message.documentsMetadataFilters) {
      const entries = Object.entries(message.documentsMetadataFilters);
      if (entries.length > 0) {
        obj.documentsMetadataFilters = {};
        entries.forEach(([k, v]) => {
          obj.documentsMetadataFilters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Participant>): Participant {
    return Participant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Participant>): Participant {
    const message = createBaseParticipant();
    message.name = object.name ?? "";
    message.role = object.role ?? 0;
    message.obfuscatedExternalUserId = object.obfuscatedExternalUserId ?? "";
    message.documentsMetadataFilters = Object.entries(object.documentsMetadataFilters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseParticipant_DocumentsMetadataFiltersEntry(): Participant_DocumentsMetadataFiltersEntry {
  return { key: "", value: "" };
}

export const Participant_DocumentsMetadataFiltersEntry: MessageFns<Participant_DocumentsMetadataFiltersEntry> = {
  encode(message: Participant_DocumentsMetadataFiltersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant_DocumentsMetadataFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant_DocumentsMetadataFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant_DocumentsMetadataFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Participant_DocumentsMetadataFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Participant_DocumentsMetadataFiltersEntry>): Participant_DocumentsMetadataFiltersEntry {
    return Participant_DocumentsMetadataFiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Participant_DocumentsMetadataFiltersEntry>,
  ): Participant_DocumentsMetadataFiltersEntry {
    const message = createBaseParticipant_DocumentsMetadataFiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return {
    name: "",
    content: "",
    responseMessages: [],
    languageCode: "",
    participant: "",
    participantRole: 0,
    createTime: undefined,
    sendTime: undefined,
    messageAnnotation: undefined,
    sentimentAnalysis: undefined,
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    for (const v of message.responseMessages) {
      ResponseMessage.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    if (message.participant !== "") {
      writer.uint32(34).string(message.participant);
    }
    if (message.participantRole !== 0) {
      writer.uint32(40).int32(message.participantRole);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.sendTime !== undefined) {
      Timestamp.encode(toTimestamp(message.sendTime), writer.uint32(74).fork()).join();
    }
    if (message.messageAnnotation !== undefined) {
      MessageAnnotation.encode(message.messageAnnotation, writer.uint32(58).fork()).join();
    }
    if (message.sentimentAnalysis !== undefined) {
      SentimentAnalysisResult.encode(message.sentimentAnalysis, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.responseMessages.push(ResponseMessage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.participantRole = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sendTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.messageAnnotation = MessageAnnotation.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sentimentAnalysis = SentimentAnalysisResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      responseMessages: globalThis.Array.isArray(object?.responseMessages)
        ? object.responseMessages.map((e: any) => ResponseMessage.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      participantRole: isSet(object.participantRole) ? participant_RoleFromJSON(object.participantRole) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      sendTime: isSet(object.sendTime) ? fromJsonTimestamp(object.sendTime) : undefined,
      messageAnnotation: isSet(object.messageAnnotation)
        ? MessageAnnotation.fromJSON(object.messageAnnotation)
        : undefined,
      sentimentAnalysis: isSet(object.sentimentAnalysis)
        ? SentimentAnalysisResult.fromJSON(object.sentimentAnalysis)
        : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.responseMessages?.length) {
      obj.responseMessages = message.responseMessages.map((e) => ResponseMessage.toJSON(e));
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.participantRole !== 0) {
      obj.participantRole = participant_RoleToJSON(message.participantRole);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.sendTime !== undefined) {
      obj.sendTime = message.sendTime.toISOString();
    }
    if (message.messageAnnotation !== undefined) {
      obj.messageAnnotation = MessageAnnotation.toJSON(message.messageAnnotation);
    }
    if (message.sentimentAnalysis !== undefined) {
      obj.sentimentAnalysis = SentimentAnalysisResult.toJSON(message.sentimentAnalysis);
    }
    return obj;
  },

  create(base?: DeepPartial<Message>): Message {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message>): Message {
    const message = createBaseMessage();
    message.name = object.name ?? "";
    message.content = object.content ?? "";
    message.responseMessages = object.responseMessages?.map((e) => ResponseMessage.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    message.participant = object.participant ?? "";
    message.participantRole = object.participantRole ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.sendTime = object.sendTime ?? undefined;
    message.messageAnnotation = (object.messageAnnotation !== undefined && object.messageAnnotation !== null)
      ? MessageAnnotation.fromPartial(object.messageAnnotation)
      : undefined;
    message.sentimentAnalysis = (object.sentimentAnalysis !== undefined && object.sentimentAnalysis !== null)
      ? SentimentAnalysisResult.fromPartial(object.sentimentAnalysis)
      : undefined;
    return message;
  },
};

function createBaseCreateParticipantRequest(): CreateParticipantRequest {
  return { parent: "", participant: undefined };
}

export const CreateParticipantRequest: MessageFns<CreateParticipantRequest> = {
  encode(message: CreateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.participant !== undefined) {
      Participant.encode(message.participant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.participant = Participant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateParticipantRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
    };
  },

  toJSON(message: CreateParticipantRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.participant !== undefined) {
      obj.participant = Participant.toJSON(message.participant);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateParticipantRequest>): CreateParticipantRequest {
    return CreateParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateParticipantRequest>): CreateParticipantRequest {
    const message = createBaseCreateParticipantRequest();
    message.parent = object.parent ?? "";
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? Participant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseGetParticipantRequest(): GetParticipantRequest {
  return { name: "" };
}

export const GetParticipantRequest: MessageFns<GetParticipantRequest> = {
  encode(message: GetParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetParticipantRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetParticipantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    return GetParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetParticipantRequest>): GetParticipantRequest {
    const message = createBaseGetParticipantRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListParticipantsRequest(): ListParticipantsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListParticipantsRequest: MessageFns<ListParticipantsRequest> = {
  encode(message: ListParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListParticipantsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    return ListParticipantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    const message = createBaseListParticipantsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListParticipantsResponse(): ListParticipantsResponse {
  return { participants: [], nextPageToken: "" };
}

export const ListParticipantsResponse: MessageFns<ListParticipantsResponse> = {
  encode(message: ListParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      Participant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participants.push(Participant.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => Participant.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => Participant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    return ListParticipantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    const message = createBaseListParticipantsResponse();
    message.participants = object.participants?.map((e) => Participant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateParticipantRequest(): UpdateParticipantRequest {
  return { participant: undefined, updateMask: undefined };
}

export const UpdateParticipantRequest: MessageFns<UpdateParticipantRequest> = {
  encode(message: UpdateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== undefined) {
      Participant.encode(message.participant, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = Participant.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest {
    return {
      participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateParticipantRequest): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = Participant.toJSON(message.participant);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    return UpdateParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    const message = createBaseUpdateParticipantRequest();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? Participant.fromPartial(object.participant)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseAudioInput(): AudioInput {
  return { config: undefined, audio: Buffer.alloc(0) };
}

export const AudioInput: MessageFns<AudioInput> = {
  encode(message: AudioInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      InputAudioConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audio.length !== 0) {
      writer.uint32(18).bytes(message.audio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = InputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioInput {
    return {
      config: isSet(object.config) ? InputAudioConfig.fromJSON(object.config) : undefined,
      audio: isSet(object.audio) ? Buffer.from(bytesFromBase64(object.audio)) : Buffer.alloc(0),
    };
  },

  toJSON(message: AudioInput): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = InputAudioConfig.toJSON(message.config);
    }
    if (message.audio.length !== 0) {
      obj.audio = base64FromBytes(message.audio);
    }
    return obj;
  },

  create(base?: DeepPartial<AudioInput>): AudioInput {
    return AudioInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioInput>): AudioInput {
    const message = createBaseAudioInput();
    message.config = (object.config !== undefined && object.config !== null)
      ? InputAudioConfig.fromPartial(object.config)
      : undefined;
    message.audio = object.audio ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseOutputAudio(): OutputAudio {
  return { config: undefined, audio: Buffer.alloc(0) };
}

export const OutputAudio: MessageFns<OutputAudio> = {
  encode(message: OutputAudio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      OutputAudioConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audio.length !== 0) {
      writer.uint32(18).bytes(message.audio);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputAudio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputAudio {
    return {
      config: isSet(object.config) ? OutputAudioConfig.fromJSON(object.config) : undefined,
      audio: isSet(object.audio) ? Buffer.from(bytesFromBase64(object.audio)) : Buffer.alloc(0),
    };
  },

  toJSON(message: OutputAudio): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = OutputAudioConfig.toJSON(message.config);
    }
    if (message.audio.length !== 0) {
      obj.audio = base64FromBytes(message.audio);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputAudio>): OutputAudio {
    return OutputAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputAudio>): OutputAudio {
    const message = createBaseOutputAudio();
    message.config = (object.config !== undefined && object.config !== null)
      ? OutputAudioConfig.fromPartial(object.config)
      : undefined;
    message.audio = object.audio ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAutomatedAgentReply(): AutomatedAgentReply {
  return {
    detectIntentResponse: undefined,
    responseMessages: [],
    intent: undefined,
    event: undefined,
    matchConfidence: 0,
    parameters: undefined,
    cxSessionParameters: undefined,
    automatedAgentReplyType: 0,
    allowCancellation: false,
    cxCurrentPage: "",
    callCompanionAuthCode: Buffer.alloc(0),
  };
}

export const AutomatedAgentReply: MessageFns<AutomatedAgentReply> = {
  encode(message: AutomatedAgentReply, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detectIntentResponse !== undefined) {
      DetectIntentResponse.encode(message.detectIntentResponse, writer.uint32(10).fork()).join();
    }
    for (const v of message.responseMessages) {
      ResponseMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.intent !== undefined) {
      writer.uint32(34).string(message.intent);
    }
    if (message.event !== undefined) {
      writer.uint32(42).string(message.event);
    }
    if (message.matchConfidence !== 0) {
      writer.uint32(77).float(message.matchConfidence);
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(82).fork()).join();
    }
    if (message.cxSessionParameters !== undefined) {
      Struct.encode(Struct.wrap(message.cxSessionParameters), writer.uint32(50).fork()).join();
    }
    if (message.automatedAgentReplyType !== 0) {
      writer.uint32(56).int32(message.automatedAgentReplyType);
    }
    if (message.allowCancellation !== false) {
      writer.uint32(64).bool(message.allowCancellation);
    }
    if (message.cxCurrentPage !== "") {
      writer.uint32(90).string(message.cxCurrentPage);
    }
    if (message.callCompanionAuthCode.length !== 0) {
      writer.uint32(98).bytes(message.callCompanionAuthCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomatedAgentReply {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomatedAgentReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.detectIntentResponse = DetectIntentResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseMessages.push(ResponseMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.event = reader.string();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.matchConfidence = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cxSessionParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.automatedAgentReplyType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.allowCancellation = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.cxCurrentPage = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.callCompanionAuthCode = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomatedAgentReply {
    return {
      detectIntentResponse: isSet(object.detectIntentResponse)
        ? DetectIntentResponse.fromJSON(object.detectIntentResponse)
        : undefined,
      responseMessages: globalThis.Array.isArray(object?.responseMessages)
        ? object.responseMessages.map((e: any) => ResponseMessage.fromJSON(e))
        : [],
      intent: isSet(object.intent) ? globalThis.String(object.intent) : undefined,
      event: isSet(object.event) ? globalThis.String(object.event) : undefined,
      matchConfidence: isSet(object.matchConfidence) ? globalThis.Number(object.matchConfidence) : 0,
      parameters: isObject(object.parameters) ? object.parameters : undefined,
      cxSessionParameters: isObject(object.cxSessionParameters) ? object.cxSessionParameters : undefined,
      automatedAgentReplyType: isSet(object.automatedAgentReplyType)
        ? automatedAgentReply_AutomatedAgentReplyTypeFromJSON(object.automatedAgentReplyType)
        : 0,
      allowCancellation: isSet(object.allowCancellation) ? globalThis.Boolean(object.allowCancellation) : false,
      cxCurrentPage: isSet(object.cxCurrentPage) ? globalThis.String(object.cxCurrentPage) : "",
      callCompanionAuthCode: isSet(object.callCompanionAuthCode)
        ? Buffer.from(bytesFromBase64(object.callCompanionAuthCode))
        : Buffer.alloc(0),
    };
  },

  toJSON(message: AutomatedAgentReply): unknown {
    const obj: any = {};
    if (message.detectIntentResponse !== undefined) {
      obj.detectIntentResponse = DetectIntentResponse.toJSON(message.detectIntentResponse);
    }
    if (message.responseMessages?.length) {
      obj.responseMessages = message.responseMessages.map((e) => ResponseMessage.toJSON(e));
    }
    if (message.intent !== undefined) {
      obj.intent = message.intent;
    }
    if (message.event !== undefined) {
      obj.event = message.event;
    }
    if (message.matchConfidence !== 0) {
      obj.matchConfidence = message.matchConfidence;
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    if (message.cxSessionParameters !== undefined) {
      obj.cxSessionParameters = message.cxSessionParameters;
    }
    if (message.automatedAgentReplyType !== 0) {
      obj.automatedAgentReplyType = automatedAgentReply_AutomatedAgentReplyTypeToJSON(message.automatedAgentReplyType);
    }
    if (message.allowCancellation !== false) {
      obj.allowCancellation = message.allowCancellation;
    }
    if (message.cxCurrentPage !== "") {
      obj.cxCurrentPage = message.cxCurrentPage;
    }
    if (message.callCompanionAuthCode.length !== 0) {
      obj.callCompanionAuthCode = base64FromBytes(message.callCompanionAuthCode);
    }
    return obj;
  },

  create(base?: DeepPartial<AutomatedAgentReply>): AutomatedAgentReply {
    return AutomatedAgentReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomatedAgentReply>): AutomatedAgentReply {
    const message = createBaseAutomatedAgentReply();
    message.detectIntentResponse = (object.detectIntentResponse !== undefined && object.detectIntentResponse !== null)
      ? DetectIntentResponse.fromPartial(object.detectIntentResponse)
      : undefined;
    message.responseMessages = object.responseMessages?.map((e) => ResponseMessage.fromPartial(e)) || [];
    message.intent = object.intent ?? undefined;
    message.event = object.event ?? undefined;
    message.matchConfidence = object.matchConfidence ?? 0;
    message.parameters = object.parameters ?? undefined;
    message.cxSessionParameters = object.cxSessionParameters ?? undefined;
    message.automatedAgentReplyType = object.automatedAgentReplyType ?? 0;
    message.allowCancellation = object.allowCancellation ?? false;
    message.cxCurrentPage = object.cxCurrentPage ?? "";
    message.callCompanionAuthCode = object.callCompanionAuthCode ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSuggestionInput(): SuggestionInput {
  return { answerRecord: "", textOverride: undefined, parameters: undefined, intentInput: undefined };
}

export const SuggestionInput: MessageFns<SuggestionInput> = {
  encode(message: SuggestionInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerRecord !== "") {
      writer.uint32(10).string(message.answerRecord);
    }
    if (message.textOverride !== undefined) {
      TextInput.encode(message.textOverride, writer.uint32(18).fork()).join();
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(34).fork()).join();
    }
    if (message.intentInput !== undefined) {
      IntentInput.encode(message.intentInput, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textOverride = TextInput.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.intentInput = IntentInput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionInput {
    return {
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
      textOverride: isSet(object.textOverride) ? TextInput.fromJSON(object.textOverride) : undefined,
      parameters: isObject(object.parameters) ? object.parameters : undefined,
      intentInput: isSet(object.intentInput) ? IntentInput.fromJSON(object.intentInput) : undefined,
    };
  },

  toJSON(message: SuggestionInput): unknown {
    const obj: any = {};
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    if (message.textOverride !== undefined) {
      obj.textOverride = TextInput.toJSON(message.textOverride);
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    if (message.intentInput !== undefined) {
      obj.intentInput = IntentInput.toJSON(message.intentInput);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestionInput>): SuggestionInput {
    return SuggestionInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestionInput>): SuggestionInput {
    const message = createBaseSuggestionInput();
    message.answerRecord = object.answerRecord ?? "";
    message.textOverride = (object.textOverride !== undefined && object.textOverride !== null)
      ? TextInput.fromPartial(object.textOverride)
      : undefined;
    message.parameters = object.parameters ?? undefined;
    message.intentInput = (object.intentInput !== undefined && object.intentInput !== null)
      ? IntentInput.fromPartial(object.intentInput)
      : undefined;
    return message;
  },
};

function createBaseIntentInput(): IntentInput {
  return { intent: "", languageCode: "" };
}

export const IntentInput: MessageFns<IntentInput> = {
  encode(message: IntentInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentInput {
    return {
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: IntentInput): unknown {
    const obj: any = {};
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentInput>): IntentInput {
    return IntentInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentInput>): IntentInput {
    const message = createBaseIntentInput();
    message.intent = object.intent ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseSuggestionFeature(): SuggestionFeature {
  return { type: 0 };
}

export const SuggestionFeature: MessageFns<SuggestionFeature> = {
  encode(message: SuggestionFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionFeature {
    return { type: isSet(object.type) ? suggestionFeature_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: SuggestionFeature): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = suggestionFeature_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestionFeature>): SuggestionFeature {
    return SuggestionFeature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestionFeature>): SuggestionFeature {
    const message = createBaseSuggestionFeature();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseAssistQueryParameters(): AssistQueryParameters {
  return { documentsMetadataFilters: {} };
}

export const AssistQueryParameters: MessageFns<AssistQueryParameters> = {
  encode(message: AssistQueryParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.documentsMetadataFilters).forEach(([key, value]) => {
      AssistQueryParameters_DocumentsMetadataFiltersEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistQueryParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistQueryParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AssistQueryParameters_DocumentsMetadataFiltersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.documentsMetadataFilters[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistQueryParameters {
    return {
      documentsMetadataFilters: isObject(object.documentsMetadataFilters)
        ? Object.entries(object.documentsMetadataFilters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AssistQueryParameters): unknown {
    const obj: any = {};
    if (message.documentsMetadataFilters) {
      const entries = Object.entries(message.documentsMetadataFilters);
      if (entries.length > 0) {
        obj.documentsMetadataFilters = {};
        entries.forEach(([k, v]) => {
          obj.documentsMetadataFilters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AssistQueryParameters>): AssistQueryParameters {
    return AssistQueryParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssistQueryParameters>): AssistQueryParameters {
    const message = createBaseAssistQueryParameters();
    message.documentsMetadataFilters = Object.entries(object.documentsMetadataFilters ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry(): AssistQueryParameters_DocumentsMetadataFiltersEntry {
  return { key: "", value: "" };
}

export const AssistQueryParameters_DocumentsMetadataFiltersEntry: MessageFns<
  AssistQueryParameters_DocumentsMetadataFiltersEntry
> = {
  encode(
    message: AssistQueryParameters_DocumentsMetadataFiltersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssistQueryParameters_DocumentsMetadataFiltersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AssistQueryParameters_DocumentsMetadataFiltersEntry>,
  ): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    return AssistQueryParameters_DocumentsMetadataFiltersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AssistQueryParameters_DocumentsMetadataFiltersEntry>,
  ): AssistQueryParameters_DocumentsMetadataFiltersEntry {
    const message = createBaseAssistQueryParameters_DocumentsMetadataFiltersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnalyzeContentRequest(): AnalyzeContentRequest {
  return {
    participant: "",
    textInput: undefined,
    audioInput: undefined,
    eventInput: undefined,
    suggestionInput: undefined,
    intentInput: undefined,
    replyAudioConfig: undefined,
    queryParams: undefined,
    assistQueryParams: undefined,
    cxParameters: undefined,
    cxCurrentPage: "",
    messageSendTime: undefined,
    requestId: "",
  };
}

export const AnalyzeContentRequest: MessageFns<AnalyzeContentRequest> = {
  encode(message: AnalyzeContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== "") {
      writer.uint32(10).string(message.participant);
    }
    if (message.textInput !== undefined) {
      TextInput.encode(message.textInput, writer.uint32(50).fork()).join();
    }
    if (message.audioInput !== undefined) {
      AudioInput.encode(message.audioInput, writer.uint32(58).fork()).join();
    }
    if (message.eventInput !== undefined) {
      EventInput.encode(message.eventInput, writer.uint32(66).fork()).join();
    }
    if (message.suggestionInput !== undefined) {
      SuggestionInput.encode(message.suggestionInput, writer.uint32(98).fork()).join();
    }
    if (message.intentInput !== undefined) {
      IntentInput.encode(message.intentInput, writer.uint32(106).fork()).join();
    }
    if (message.replyAudioConfig !== undefined) {
      OutputAudioConfig.encode(message.replyAudioConfig, writer.uint32(42).fork()).join();
    }
    if (message.queryParams !== undefined) {
      QueryParameters.encode(message.queryParams, writer.uint32(74).fork()).join();
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(114).fork()).join();
    }
    if (message.cxParameters !== undefined) {
      Struct.encode(Struct.wrap(message.cxParameters), writer.uint32(146).fork()).join();
    }
    if (message.cxCurrentPage !== "") {
      writer.uint32(162).string(message.cxCurrentPage);
    }
    if (message.messageSendTime !== undefined) {
      Timestamp.encode(toTimestamp(message.messageSendTime), writer.uint32(82).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(90).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.audioInput = AudioInput.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.eventInput = EventInput.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.suggestionInput = SuggestionInput.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.intentInput = IntentInput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.replyAudioConfig = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.queryParams = QueryParameters.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.cxParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.cxCurrentPage = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.messageSendTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeContentRequest {
    return {
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      textInput: isSet(object.textInput) ? TextInput.fromJSON(object.textInput) : undefined,
      audioInput: isSet(object.audioInput) ? AudioInput.fromJSON(object.audioInput) : undefined,
      eventInput: isSet(object.eventInput) ? EventInput.fromJSON(object.eventInput) : undefined,
      suggestionInput: isSet(object.suggestionInput) ? SuggestionInput.fromJSON(object.suggestionInput) : undefined,
      intentInput: isSet(object.intentInput) ? IntentInput.fromJSON(object.intentInput) : undefined,
      replyAudioConfig: isSet(object.replyAudioConfig)
        ? OutputAudioConfig.fromJSON(object.replyAudioConfig)
        : undefined,
      queryParams: isSet(object.queryParams) ? QueryParameters.fromJSON(object.queryParams) : undefined,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
      cxParameters: isObject(object.cxParameters) ? object.cxParameters : undefined,
      cxCurrentPage: isSet(object.cxCurrentPage) ? globalThis.String(object.cxCurrentPage) : "",
      messageSendTime: isSet(object.messageSendTime) ? fromJsonTimestamp(object.messageSendTime) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: AnalyzeContentRequest): unknown {
    const obj: any = {};
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.textInput !== undefined) {
      obj.textInput = TextInput.toJSON(message.textInput);
    }
    if (message.audioInput !== undefined) {
      obj.audioInput = AudioInput.toJSON(message.audioInput);
    }
    if (message.eventInput !== undefined) {
      obj.eventInput = EventInput.toJSON(message.eventInput);
    }
    if (message.suggestionInput !== undefined) {
      obj.suggestionInput = SuggestionInput.toJSON(message.suggestionInput);
    }
    if (message.intentInput !== undefined) {
      obj.intentInput = IntentInput.toJSON(message.intentInput);
    }
    if (message.replyAudioConfig !== undefined) {
      obj.replyAudioConfig = OutputAudioConfig.toJSON(message.replyAudioConfig);
    }
    if (message.queryParams !== undefined) {
      obj.queryParams = QueryParameters.toJSON(message.queryParams);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    if (message.cxParameters !== undefined) {
      obj.cxParameters = message.cxParameters;
    }
    if (message.cxCurrentPage !== "") {
      obj.cxCurrentPage = message.cxCurrentPage;
    }
    if (message.messageSendTime !== undefined) {
      obj.messageSendTime = message.messageSendTime.toISOString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeContentRequest>): AnalyzeContentRequest {
    return AnalyzeContentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeContentRequest>): AnalyzeContentRequest {
    const message = createBaseAnalyzeContentRequest();
    message.participant = object.participant ?? "";
    message.textInput = (object.textInput !== undefined && object.textInput !== null)
      ? TextInput.fromPartial(object.textInput)
      : undefined;
    message.audioInput = (object.audioInput !== undefined && object.audioInput !== null)
      ? AudioInput.fromPartial(object.audioInput)
      : undefined;
    message.eventInput = (object.eventInput !== undefined && object.eventInput !== null)
      ? EventInput.fromPartial(object.eventInput)
      : undefined;
    message.suggestionInput = (object.suggestionInput !== undefined && object.suggestionInput !== null)
      ? SuggestionInput.fromPartial(object.suggestionInput)
      : undefined;
    message.intentInput = (object.intentInput !== undefined && object.intentInput !== null)
      ? IntentInput.fromPartial(object.intentInput)
      : undefined;
    message.replyAudioConfig = (object.replyAudioConfig !== undefined && object.replyAudioConfig !== null)
      ? OutputAudioConfig.fromPartial(object.replyAudioConfig)
      : undefined;
    message.queryParams = (object.queryParams !== undefined && object.queryParams !== null)
      ? QueryParameters.fromPartial(object.queryParams)
      : undefined;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    message.cxParameters = object.cxParameters ?? undefined;
    message.cxCurrentPage = object.cxCurrentPage ?? "";
    message.messageSendTime = object.messageSendTime ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDtmfParameters(): DtmfParameters {
  return { acceptsDtmfInput: false };
}

export const DtmfParameters: MessageFns<DtmfParameters> = {
  encode(message: DtmfParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceptsDtmfInput !== false) {
      writer.uint32(8).bool(message.acceptsDtmfInput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DtmfParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDtmfParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceptsDtmfInput = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DtmfParameters {
    return { acceptsDtmfInput: isSet(object.acceptsDtmfInput) ? globalThis.Boolean(object.acceptsDtmfInput) : false };
  },

  toJSON(message: DtmfParameters): unknown {
    const obj: any = {};
    if (message.acceptsDtmfInput !== false) {
      obj.acceptsDtmfInput = message.acceptsDtmfInput;
    }
    return obj;
  },

  create(base?: DeepPartial<DtmfParameters>): DtmfParameters {
    return DtmfParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DtmfParameters>): DtmfParameters {
    const message = createBaseDtmfParameters();
    message.acceptsDtmfInput = object.acceptsDtmfInput ?? false;
    return message;
  },
};

function createBaseAnalyzeContentResponse(): AnalyzeContentResponse {
  return {
    replyText: "",
    replyAudio: undefined,
    automatedAgentReply: undefined,
    message: undefined,
    humanAgentSuggestionResults: [],
    endUserSuggestionResults: [],
    dtmfParameters: undefined,
  };
}

export const AnalyzeContentResponse: MessageFns<AnalyzeContentResponse> = {
  encode(message: AnalyzeContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.replyText !== "") {
      writer.uint32(10).string(message.replyText);
    }
    if (message.replyAudio !== undefined) {
      OutputAudio.encode(message.replyAudio, writer.uint32(18).fork()).join();
    }
    if (message.automatedAgentReply !== undefined) {
      AutomatedAgentReply.encode(message.automatedAgentReply, writer.uint32(26).fork()).join();
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(42).fork()).join();
    }
    for (const v of message.humanAgentSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.endUserSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.dtmfParameters !== undefined) {
      DtmfParameters.encode(message.dtmfParameters, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalyzeContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalyzeContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.replyText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replyAudio = OutputAudio.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.automatedAgentReply = AutomatedAgentReply.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.humanAgentSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endUserSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dtmfParameters = DtmfParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalyzeContentResponse {
    return {
      replyText: isSet(object.replyText) ? globalThis.String(object.replyText) : "",
      replyAudio: isSet(object.replyAudio) ? OutputAudio.fromJSON(object.replyAudio) : undefined,
      automatedAgentReply: isSet(object.automatedAgentReply)
        ? AutomatedAgentReply.fromJSON(object.automatedAgentReply)
        : undefined,
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      humanAgentSuggestionResults: globalThis.Array.isArray(object?.humanAgentSuggestionResults)
        ? object.humanAgentSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      endUserSuggestionResults: globalThis.Array.isArray(object?.endUserSuggestionResults)
        ? object.endUserSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      dtmfParameters: isSet(object.dtmfParameters) ? DtmfParameters.fromJSON(object.dtmfParameters) : undefined,
    };
  },

  toJSON(message: AnalyzeContentResponse): unknown {
    const obj: any = {};
    if (message.replyText !== "") {
      obj.replyText = message.replyText;
    }
    if (message.replyAudio !== undefined) {
      obj.replyAudio = OutputAudio.toJSON(message.replyAudio);
    }
    if (message.automatedAgentReply !== undefined) {
      obj.automatedAgentReply = AutomatedAgentReply.toJSON(message.automatedAgentReply);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.humanAgentSuggestionResults?.length) {
      obj.humanAgentSuggestionResults = message.humanAgentSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.endUserSuggestionResults?.length) {
      obj.endUserSuggestionResults = message.endUserSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.dtmfParameters !== undefined) {
      obj.dtmfParameters = DtmfParameters.toJSON(message.dtmfParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalyzeContentResponse>): AnalyzeContentResponse {
    return AnalyzeContentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalyzeContentResponse>): AnalyzeContentResponse {
    const message = createBaseAnalyzeContentResponse();
    message.replyText = object.replyText ?? "";
    message.replyAudio = (object.replyAudio !== undefined && object.replyAudio !== null)
      ? OutputAudio.fromPartial(object.replyAudio)
      : undefined;
    message.automatedAgentReply = (object.automatedAgentReply !== undefined && object.automatedAgentReply !== null)
      ? AutomatedAgentReply.fromPartial(object.automatedAgentReply)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.humanAgentSuggestionResults =
      object.humanAgentSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) || [];
    message.endUserSuggestionResults = object.endUserSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) ||
      [];
    message.dtmfParameters = (object.dtmfParameters !== undefined && object.dtmfParameters !== null)
      ? DtmfParameters.fromPartial(object.dtmfParameters)
      : undefined;
    return message;
  },
};

function createBaseInputTextConfig(): InputTextConfig {
  return { languageCode: "" };
}

export const InputTextConfig: MessageFns<InputTextConfig> = {
  encode(message: InputTextConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputTextConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputTextConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputTextConfig {
    return { languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "" };
  },

  toJSON(message: InputTextConfig): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<InputTextConfig>): InputTextConfig {
    return InputTextConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputTextConfig>): InputTextConfig {
    const message = createBaseInputTextConfig();
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseStreamingAnalyzeContentRequest(): StreamingAnalyzeContentRequest {
  return {
    participant: "",
    audioConfig: undefined,
    textConfig: undefined,
    replyAudioConfig: undefined,
    inputAudio: undefined,
    inputText: undefined,
    inputDtmf: undefined,
    inputIntent: undefined,
    inputEvent: undefined,
    queryParams: undefined,
    assistQueryParams: undefined,
    cxParameters: undefined,
    cxCurrentPage: "",
    enableExtendedStreaming: false,
    enablePartialAutomatedAgentReply: false,
    enableDebuggingInfo: false,
  };
}

export const StreamingAnalyzeContentRequest: MessageFns<StreamingAnalyzeContentRequest> = {
  encode(message: StreamingAnalyzeContentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== "") {
      writer.uint32(10).string(message.participant);
    }
    if (message.audioConfig !== undefined) {
      InputAudioConfig.encode(message.audioConfig, writer.uint32(18).fork()).join();
    }
    if (message.textConfig !== undefined) {
      InputTextConfig.encode(message.textConfig, writer.uint32(26).fork()).join();
    }
    if (message.replyAudioConfig !== undefined) {
      OutputAudioConfig.encode(message.replyAudioConfig, writer.uint32(34).fork()).join();
    }
    if (message.inputAudio !== undefined) {
      writer.uint32(42).bytes(message.inputAudio);
    }
    if (message.inputText !== undefined) {
      writer.uint32(50).string(message.inputText);
    }
    if (message.inputDtmf !== undefined) {
      TelephonyDtmfEvents.encode(message.inputDtmf, writer.uint32(74).fork()).join();
    }
    if (message.inputIntent !== undefined) {
      writer.uint32(138).string(message.inputIntent);
    }
    if (message.inputEvent !== undefined) {
      writer.uint32(162).string(message.inputEvent);
    }
    if (message.queryParams !== undefined) {
      QueryParameters.encode(message.queryParams, writer.uint32(58).fork()).join();
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(66).fork()).join();
    }
    if (message.cxParameters !== undefined) {
      Struct.encode(Struct.wrap(message.cxParameters), writer.uint32(106).fork()).join();
    }
    if (message.cxCurrentPage !== "") {
      writer.uint32(122).string(message.cxCurrentPage);
    }
    if (message.enableExtendedStreaming !== false) {
      writer.uint32(88).bool(message.enableExtendedStreaming);
    }
    if (message.enablePartialAutomatedAgentReply !== false) {
      writer.uint32(96).bool(message.enablePartialAutomatedAgentReply);
    }
    if (message.enableDebuggingInfo !== false) {
      writer.uint32(152).bool(message.enableDebuggingInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingAnalyzeContentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingAnalyzeContentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioConfig = InputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textConfig = InputTextConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.replyAudioConfig = OutputAudioConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputAudio = Buffer.from(reader.bytes());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputText = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.inputDtmf = TelephonyDtmfEvents.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.inputIntent = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.inputEvent = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.queryParams = QueryParameters.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cxParameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.cxCurrentPage = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableExtendedStreaming = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enablePartialAutomatedAgentReply = reader.bool();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.enableDebuggingInfo = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingAnalyzeContentRequest {
    return {
      participant: isSet(object.participant) ? globalThis.String(object.participant) : "",
      audioConfig: isSet(object.audioConfig) ? InputAudioConfig.fromJSON(object.audioConfig) : undefined,
      textConfig: isSet(object.textConfig) ? InputTextConfig.fromJSON(object.textConfig) : undefined,
      replyAudioConfig: isSet(object.replyAudioConfig)
        ? OutputAudioConfig.fromJSON(object.replyAudioConfig)
        : undefined,
      inputAudio: isSet(object.inputAudio) ? Buffer.from(bytesFromBase64(object.inputAudio)) : undefined,
      inputText: isSet(object.inputText) ? globalThis.String(object.inputText) : undefined,
      inputDtmf: isSet(object.inputDtmf) ? TelephonyDtmfEvents.fromJSON(object.inputDtmf) : undefined,
      inputIntent: isSet(object.inputIntent) ? globalThis.String(object.inputIntent) : undefined,
      inputEvent: isSet(object.inputEvent) ? globalThis.String(object.inputEvent) : undefined,
      queryParams: isSet(object.queryParams) ? QueryParameters.fromJSON(object.queryParams) : undefined,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
      cxParameters: isObject(object.cxParameters) ? object.cxParameters : undefined,
      cxCurrentPage: isSet(object.cxCurrentPage) ? globalThis.String(object.cxCurrentPage) : "",
      enableExtendedStreaming: isSet(object.enableExtendedStreaming)
        ? globalThis.Boolean(object.enableExtendedStreaming)
        : false,
      enablePartialAutomatedAgentReply: isSet(object.enablePartialAutomatedAgentReply)
        ? globalThis.Boolean(object.enablePartialAutomatedAgentReply)
        : false,
      enableDebuggingInfo: isSet(object.enableDebuggingInfo) ? globalThis.Boolean(object.enableDebuggingInfo) : false,
    };
  },

  toJSON(message: StreamingAnalyzeContentRequest): unknown {
    const obj: any = {};
    if (message.participant !== "") {
      obj.participant = message.participant;
    }
    if (message.audioConfig !== undefined) {
      obj.audioConfig = InputAudioConfig.toJSON(message.audioConfig);
    }
    if (message.textConfig !== undefined) {
      obj.textConfig = InputTextConfig.toJSON(message.textConfig);
    }
    if (message.replyAudioConfig !== undefined) {
      obj.replyAudioConfig = OutputAudioConfig.toJSON(message.replyAudioConfig);
    }
    if (message.inputAudio !== undefined) {
      obj.inputAudio = base64FromBytes(message.inputAudio);
    }
    if (message.inputText !== undefined) {
      obj.inputText = message.inputText;
    }
    if (message.inputDtmf !== undefined) {
      obj.inputDtmf = TelephonyDtmfEvents.toJSON(message.inputDtmf);
    }
    if (message.inputIntent !== undefined) {
      obj.inputIntent = message.inputIntent;
    }
    if (message.inputEvent !== undefined) {
      obj.inputEvent = message.inputEvent;
    }
    if (message.queryParams !== undefined) {
      obj.queryParams = QueryParameters.toJSON(message.queryParams);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    if (message.cxParameters !== undefined) {
      obj.cxParameters = message.cxParameters;
    }
    if (message.cxCurrentPage !== "") {
      obj.cxCurrentPage = message.cxCurrentPage;
    }
    if (message.enableExtendedStreaming !== false) {
      obj.enableExtendedStreaming = message.enableExtendedStreaming;
    }
    if (message.enablePartialAutomatedAgentReply !== false) {
      obj.enablePartialAutomatedAgentReply = message.enablePartialAutomatedAgentReply;
    }
    if (message.enableDebuggingInfo !== false) {
      obj.enableDebuggingInfo = message.enableDebuggingInfo;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingAnalyzeContentRequest>): StreamingAnalyzeContentRequest {
    return StreamingAnalyzeContentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingAnalyzeContentRequest>): StreamingAnalyzeContentRequest {
    const message = createBaseStreamingAnalyzeContentRequest();
    message.participant = object.participant ?? "";
    message.audioConfig = (object.audioConfig !== undefined && object.audioConfig !== null)
      ? InputAudioConfig.fromPartial(object.audioConfig)
      : undefined;
    message.textConfig = (object.textConfig !== undefined && object.textConfig !== null)
      ? InputTextConfig.fromPartial(object.textConfig)
      : undefined;
    message.replyAudioConfig = (object.replyAudioConfig !== undefined && object.replyAudioConfig !== null)
      ? OutputAudioConfig.fromPartial(object.replyAudioConfig)
      : undefined;
    message.inputAudio = object.inputAudio ?? undefined;
    message.inputText = object.inputText ?? undefined;
    message.inputDtmf = (object.inputDtmf !== undefined && object.inputDtmf !== null)
      ? TelephonyDtmfEvents.fromPartial(object.inputDtmf)
      : undefined;
    message.inputIntent = object.inputIntent ?? undefined;
    message.inputEvent = object.inputEvent ?? undefined;
    message.queryParams = (object.queryParams !== undefined && object.queryParams !== null)
      ? QueryParameters.fromPartial(object.queryParams)
      : undefined;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    message.cxParameters = object.cxParameters ?? undefined;
    message.cxCurrentPage = object.cxCurrentPage ?? "";
    message.enableExtendedStreaming = object.enableExtendedStreaming ?? false;
    message.enablePartialAutomatedAgentReply = object.enablePartialAutomatedAgentReply ?? false;
    message.enableDebuggingInfo = object.enableDebuggingInfo ?? false;
    return message;
  },
};

function createBaseStreamingAnalyzeContentResponse(): StreamingAnalyzeContentResponse {
  return {
    recognitionResult: undefined,
    replyText: "",
    replyAudio: undefined,
    automatedAgentReply: undefined,
    message: undefined,
    humanAgentSuggestionResults: [],
    endUserSuggestionResults: [],
    dtmfParameters: undefined,
    debuggingInfo: undefined,
  };
}

export const StreamingAnalyzeContentResponse: MessageFns<StreamingAnalyzeContentResponse> = {
  encode(message: StreamingAnalyzeContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recognitionResult !== undefined) {
      StreamingRecognitionResult.encode(message.recognitionResult, writer.uint32(10).fork()).join();
    }
    if (message.replyText !== "") {
      writer.uint32(18).string(message.replyText);
    }
    if (message.replyAudio !== undefined) {
      OutputAudio.encode(message.replyAudio, writer.uint32(26).fork()).join();
    }
    if (message.automatedAgentReply !== undefined) {
      AutomatedAgentReply.encode(message.automatedAgentReply, writer.uint32(34).fork()).join();
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(50).fork()).join();
    }
    for (const v of message.humanAgentSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.endUserSuggestionResults) {
      SuggestionResult.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.dtmfParameters !== undefined) {
      DtmfParameters.encode(message.dtmfParameters, writer.uint32(82).fork()).join();
    }
    if (message.debuggingInfo !== undefined) {
      CloudConversationDebuggingInfo.encode(message.debuggingInfo, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingAnalyzeContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingAnalyzeContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recognitionResult = StreamingRecognitionResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replyText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.replyAudio = OutputAudio.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.automatedAgentReply = AutomatedAgentReply.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.humanAgentSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endUserSuggestionResults.push(SuggestionResult.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dtmfParameters = DtmfParameters.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.debuggingInfo = CloudConversationDebuggingInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingAnalyzeContentResponse {
    return {
      recognitionResult: isSet(object.recognitionResult)
        ? StreamingRecognitionResult.fromJSON(object.recognitionResult)
        : undefined,
      replyText: isSet(object.replyText) ? globalThis.String(object.replyText) : "",
      replyAudio: isSet(object.replyAudio) ? OutputAudio.fromJSON(object.replyAudio) : undefined,
      automatedAgentReply: isSet(object.automatedAgentReply)
        ? AutomatedAgentReply.fromJSON(object.automatedAgentReply)
        : undefined,
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      humanAgentSuggestionResults: globalThis.Array.isArray(object?.humanAgentSuggestionResults)
        ? object.humanAgentSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      endUserSuggestionResults: globalThis.Array.isArray(object?.endUserSuggestionResults)
        ? object.endUserSuggestionResults.map((e: any) => SuggestionResult.fromJSON(e))
        : [],
      dtmfParameters: isSet(object.dtmfParameters) ? DtmfParameters.fromJSON(object.dtmfParameters) : undefined,
      debuggingInfo: isSet(object.debuggingInfo)
        ? CloudConversationDebuggingInfo.fromJSON(object.debuggingInfo)
        : undefined,
    };
  },

  toJSON(message: StreamingAnalyzeContentResponse): unknown {
    const obj: any = {};
    if (message.recognitionResult !== undefined) {
      obj.recognitionResult = StreamingRecognitionResult.toJSON(message.recognitionResult);
    }
    if (message.replyText !== "") {
      obj.replyText = message.replyText;
    }
    if (message.replyAudio !== undefined) {
      obj.replyAudio = OutputAudio.toJSON(message.replyAudio);
    }
    if (message.automatedAgentReply !== undefined) {
      obj.automatedAgentReply = AutomatedAgentReply.toJSON(message.automatedAgentReply);
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.humanAgentSuggestionResults?.length) {
      obj.humanAgentSuggestionResults = message.humanAgentSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.endUserSuggestionResults?.length) {
      obj.endUserSuggestionResults = message.endUserSuggestionResults.map((e) => SuggestionResult.toJSON(e));
    }
    if (message.dtmfParameters !== undefined) {
      obj.dtmfParameters = DtmfParameters.toJSON(message.dtmfParameters);
    }
    if (message.debuggingInfo !== undefined) {
      obj.debuggingInfo = CloudConversationDebuggingInfo.toJSON(message.debuggingInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingAnalyzeContentResponse>): StreamingAnalyzeContentResponse {
    return StreamingAnalyzeContentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingAnalyzeContentResponse>): StreamingAnalyzeContentResponse {
    const message = createBaseStreamingAnalyzeContentResponse();
    message.recognitionResult = (object.recognitionResult !== undefined && object.recognitionResult !== null)
      ? StreamingRecognitionResult.fromPartial(object.recognitionResult)
      : undefined;
    message.replyText = object.replyText ?? "";
    message.replyAudio = (object.replyAudio !== undefined && object.replyAudio !== null)
      ? OutputAudio.fromPartial(object.replyAudio)
      : undefined;
    message.automatedAgentReply = (object.automatedAgentReply !== undefined && object.automatedAgentReply !== null)
      ? AutomatedAgentReply.fromPartial(object.automatedAgentReply)
      : undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.humanAgentSuggestionResults =
      object.humanAgentSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) || [];
    message.endUserSuggestionResults = object.endUserSuggestionResults?.map((e) => SuggestionResult.fromPartial(e)) ||
      [];
    message.dtmfParameters = (object.dtmfParameters !== undefined && object.dtmfParameters !== null)
      ? DtmfParameters.fromPartial(object.dtmfParameters)
      : undefined;
    message.debuggingInfo = (object.debuggingInfo !== undefined && object.debuggingInfo !== null)
      ? CloudConversationDebuggingInfo.fromPartial(object.debuggingInfo)
      : undefined;
    return message;
  },
};

function createBaseAnnotatedMessagePart(): AnnotatedMessagePart {
  return { text: "", entityType: "", formattedValue: undefined };
}

export const AnnotatedMessagePart: MessageFns<AnnotatedMessagePart> = {
  encode(message: AnnotatedMessagePart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.formattedValue !== undefined) {
      Value.encode(Value.wrap(message.formattedValue), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatedMessagePart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatedMessagePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.formattedValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatedMessagePart {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      formattedValue: isSet(object?.formattedValue) ? object.formattedValue : undefined,
    };
  },

  toJSON(message: AnnotatedMessagePart): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.formattedValue !== undefined) {
      obj.formattedValue = message.formattedValue;
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatedMessagePart>): AnnotatedMessagePart {
    return AnnotatedMessagePart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatedMessagePart>): AnnotatedMessagePart {
    const message = createBaseAnnotatedMessagePart();
    message.text = object.text ?? "";
    message.entityType = object.entityType ?? "";
    message.formattedValue = object.formattedValue ?? undefined;
    return message;
  },
};

function createBaseMessageAnnotation(): MessageAnnotation {
  return { parts: [], containEntities: false };
}

export const MessageAnnotation: MessageFns<MessageAnnotation> = {
  encode(message: MessageAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parts) {
      AnnotatedMessagePart.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.containEntities !== false) {
      writer.uint32(16).bool(message.containEntities);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parts.push(AnnotatedMessagePart.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.containEntities = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageAnnotation {
    return {
      parts: globalThis.Array.isArray(object?.parts)
        ? object.parts.map((e: any) => AnnotatedMessagePart.fromJSON(e))
        : [],
      containEntities: isSet(object.containEntities) ? globalThis.Boolean(object.containEntities) : false,
    };
  },

  toJSON(message: MessageAnnotation): unknown {
    const obj: any = {};
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => AnnotatedMessagePart.toJSON(e));
    }
    if (message.containEntities !== false) {
      obj.containEntities = message.containEntities;
    }
    return obj;
  },

  create(base?: DeepPartial<MessageAnnotation>): MessageAnnotation {
    return MessageAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageAnnotation>): MessageAnnotation {
    const message = createBaseMessageAnnotation();
    message.parts = object.parts?.map((e) => AnnotatedMessagePart.fromPartial(e)) || [];
    message.containEntities = object.containEntities ?? false;
    return message;
  },
};

function createBaseArticleAnswer(): ArticleAnswer {
  return { title: "", uri: "", snippets: [], metadata: {}, answerRecord: "" };
}

export const ArticleAnswer: MessageFns<ArticleAnswer> = {
  encode(message: ArticleAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    for (const v of message.snippets) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ArticleAnswer_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snippets.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ArticleAnswer_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleAnswer {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      snippets: globalThis.Array.isArray(object?.snippets) ? object.snippets.map((e: any) => globalThis.String(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: ArticleAnswer): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.snippets?.length) {
      obj.snippets = message.snippets;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleAnswer>): ArticleAnswer {
    return ArticleAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleAnswer>): ArticleAnswer {
    const message = createBaseArticleAnswer();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.snippets = object.snippets?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseArticleAnswer_MetadataEntry(): ArticleAnswer_MetadataEntry {
  return { key: "", value: "" };
}

export const ArticleAnswer_MetadataEntry: MessageFns<ArticleAnswer_MetadataEntry> = {
  encode(message: ArticleAnswer_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleAnswer_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleAnswer_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleAnswer_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ArticleAnswer_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleAnswer_MetadataEntry>): ArticleAnswer_MetadataEntry {
    return ArticleAnswer_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleAnswer_MetadataEntry>): ArticleAnswer_MetadataEntry {
    const message = createBaseArticleAnswer_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFaqAnswer(): FaqAnswer {
  return { answer: "", confidence: 0, question: "", source: "", metadata: {}, answerRecord: "" };
}

export const FaqAnswer: MessageFns<FaqAnswer> = {
  encode(message: FaqAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.question !== "") {
      writer.uint32(26).string(message.question);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      FaqAnswer_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.question = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = FaqAnswer_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswer {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: FaqAnswer): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswer>): FaqAnswer {
    return FaqAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswer>): FaqAnswer {
    const message = createBaseFaqAnswer();
    message.answer = object.answer ?? "";
    message.confidence = object.confidence ?? 0;
    message.question = object.question ?? "";
    message.source = object.source ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseFaqAnswer_MetadataEntry(): FaqAnswer_MetadataEntry {
  return { key: "", value: "" };
}

export const FaqAnswer_MetadataEntry: MessageFns<FaqAnswer_MetadataEntry> = {
  encode(message: FaqAnswer_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswer_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswer_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswer_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FaqAnswer_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswer_MetadataEntry>): FaqAnswer_MetadataEntry {
    return FaqAnswer_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswer_MetadataEntry>): FaqAnswer_MetadataEntry {
    const message = createBaseFaqAnswer_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSmartReplyAnswer(): SmartReplyAnswer {
  return { reply: "", confidence: 0, answerRecord: "" };
}

export const SmartReplyAnswer: MessageFns<SmartReplyAnswer> = {
  encode(message: SmartReplyAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reply !== "") {
      writer.uint32(10).string(message.reply);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.answerRecord !== "") {
      writer.uint32(26).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartReplyAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartReplyAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reply = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartReplyAnswer {
    return {
      reply: isSet(object.reply) ? globalThis.String(object.reply) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: SmartReplyAnswer): unknown {
    const obj: any = {};
    if (message.reply !== "") {
      obj.reply = message.reply;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartReplyAnswer>): SmartReplyAnswer {
    return SmartReplyAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartReplyAnswer>): SmartReplyAnswer {
    const message = createBaseSmartReplyAnswer();
    message.reply = object.reply ?? "";
    message.confidence = object.confidence ?? 0;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseIntentSuggestion(): IntentSuggestion {
  return { displayName: "", intentV2: undefined, description: "" };
}

export const IntentSuggestion: MessageFns<IntentSuggestion> = {
  encode(message: IntentSuggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.intentV2 !== undefined) {
      writer.uint32(18).string(message.intentV2);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentSuggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intentV2 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentSuggestion {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      intentV2: isSet(object.intentV2) ? globalThis.String(object.intentV2) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: IntentSuggestion): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.intentV2 !== undefined) {
      obj.intentV2 = message.intentV2;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentSuggestion>): IntentSuggestion {
    return IntentSuggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentSuggestion>): IntentSuggestion {
    const message = createBaseIntentSuggestion();
    message.displayName = object.displayName ?? "";
    message.intentV2 = object.intentV2 ?? undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseDialogflowAssistAnswer(): DialogflowAssistAnswer {
  return { queryResult: undefined, intentSuggestion: undefined, answerRecord: "" };
}

export const DialogflowAssistAnswer: MessageFns<DialogflowAssistAnswer> = {
  encode(message: DialogflowAssistAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryResult !== undefined) {
      QueryResult.encode(message.queryResult, writer.uint32(10).fork()).join();
    }
    if (message.intentSuggestion !== undefined) {
      IntentSuggestion.encode(message.intentSuggestion, writer.uint32(42).fork()).join();
    }
    if (message.answerRecord !== "") {
      writer.uint32(18).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogflowAssistAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogflowAssistAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryResult = QueryResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intentSuggestion = IntentSuggestion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogflowAssistAnswer {
    return {
      queryResult: isSet(object.queryResult) ? QueryResult.fromJSON(object.queryResult) : undefined,
      intentSuggestion: isSet(object.intentSuggestion) ? IntentSuggestion.fromJSON(object.intentSuggestion) : undefined,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: DialogflowAssistAnswer): unknown {
    const obj: any = {};
    if (message.queryResult !== undefined) {
      obj.queryResult = QueryResult.toJSON(message.queryResult);
    }
    if (message.intentSuggestion !== undefined) {
      obj.intentSuggestion = IntentSuggestion.toJSON(message.intentSuggestion);
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<DialogflowAssistAnswer>): DialogflowAssistAnswer {
    return DialogflowAssistAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogflowAssistAnswer>): DialogflowAssistAnswer {
    const message = createBaseDialogflowAssistAnswer();
    message.queryResult = (object.queryResult !== undefined && object.queryResult !== null)
      ? QueryResult.fromPartial(object.queryResult)
      : undefined;
    message.intentSuggestion = (object.intentSuggestion !== undefined && object.intentSuggestion !== null)
      ? IntentSuggestion.fromPartial(object.intentSuggestion)
      : undefined;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseSuggestionResult(): SuggestionResult {
  return {
    error: undefined,
    suggestArticlesResponse: undefined,
    suggestKnowledgeAssistResponse: undefined,
    suggestFaqAnswersResponse: undefined,
    suggestSmartRepliesResponse: undefined,
    suggestDialogflowAssistsResponse: undefined,
    suggestEntityExtractionResponse: undefined,
  };
}

export const SuggestionResult: MessageFns<SuggestionResult> = {
  encode(message: SuggestionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(10).fork()).join();
    }
    if (message.suggestArticlesResponse !== undefined) {
      SuggestArticlesResponse.encode(message.suggestArticlesResponse, writer.uint32(18).fork()).join();
    }
    if (message.suggestKnowledgeAssistResponse !== undefined) {
      SuggestKnowledgeAssistResponse.encode(message.suggestKnowledgeAssistResponse, writer.uint32(66).fork()).join();
    }
    if (message.suggestFaqAnswersResponse !== undefined) {
      SuggestFaqAnswersResponse.encode(message.suggestFaqAnswersResponse, writer.uint32(26).fork()).join();
    }
    if (message.suggestSmartRepliesResponse !== undefined) {
      SuggestSmartRepliesResponse.encode(message.suggestSmartRepliesResponse, writer.uint32(34).fork()).join();
    }
    if (message.suggestDialogflowAssistsResponse !== undefined) {
      SuggestDialogflowAssistsResponse.encode(message.suggestDialogflowAssistsResponse, writer.uint32(42).fork())
        .join();
    }
    if (message.suggestEntityExtractionResponse !== undefined) {
      SuggestDialogflowAssistsResponse.encode(message.suggestEntityExtractionResponse, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestArticlesResponse = SuggestArticlesResponse.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.suggestKnowledgeAssistResponse = SuggestKnowledgeAssistResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.suggestFaqAnswersResponse = SuggestFaqAnswersResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.suggestSmartRepliesResponse = SuggestSmartRepliesResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.suggestDialogflowAssistsResponse = SuggestDialogflowAssistsResponse.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.suggestEntityExtractionResponse = SuggestDialogflowAssistsResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestionResult {
    return {
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      suggestArticlesResponse: isSet(object.suggestArticlesResponse)
        ? SuggestArticlesResponse.fromJSON(object.suggestArticlesResponse)
        : undefined,
      suggestKnowledgeAssistResponse: isSet(object.suggestKnowledgeAssistResponse)
        ? SuggestKnowledgeAssistResponse.fromJSON(object.suggestKnowledgeAssistResponse)
        : undefined,
      suggestFaqAnswersResponse: isSet(object.suggestFaqAnswersResponse)
        ? SuggestFaqAnswersResponse.fromJSON(object.suggestFaqAnswersResponse)
        : undefined,
      suggestSmartRepliesResponse: isSet(object.suggestSmartRepliesResponse)
        ? SuggestSmartRepliesResponse.fromJSON(object.suggestSmartRepliesResponse)
        : undefined,
      suggestDialogflowAssistsResponse: isSet(object.suggestDialogflowAssistsResponse)
        ? SuggestDialogflowAssistsResponse.fromJSON(object.suggestDialogflowAssistsResponse)
        : undefined,
      suggestEntityExtractionResponse: isSet(object.suggestEntityExtractionResponse)
        ? SuggestDialogflowAssistsResponse.fromJSON(object.suggestEntityExtractionResponse)
        : undefined,
    };
  },

  toJSON(message: SuggestionResult): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.suggestArticlesResponse !== undefined) {
      obj.suggestArticlesResponse = SuggestArticlesResponse.toJSON(message.suggestArticlesResponse);
    }
    if (message.suggestKnowledgeAssistResponse !== undefined) {
      obj.suggestKnowledgeAssistResponse = SuggestKnowledgeAssistResponse.toJSON(
        message.suggestKnowledgeAssistResponse,
      );
    }
    if (message.suggestFaqAnswersResponse !== undefined) {
      obj.suggestFaqAnswersResponse = SuggestFaqAnswersResponse.toJSON(message.suggestFaqAnswersResponse);
    }
    if (message.suggestSmartRepliesResponse !== undefined) {
      obj.suggestSmartRepliesResponse = SuggestSmartRepliesResponse.toJSON(message.suggestSmartRepliesResponse);
    }
    if (message.suggestDialogflowAssistsResponse !== undefined) {
      obj.suggestDialogflowAssistsResponse = SuggestDialogflowAssistsResponse.toJSON(
        message.suggestDialogflowAssistsResponse,
      );
    }
    if (message.suggestEntityExtractionResponse !== undefined) {
      obj.suggestEntityExtractionResponse = SuggestDialogflowAssistsResponse.toJSON(
        message.suggestEntityExtractionResponse,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestionResult>): SuggestionResult {
    return SuggestionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestionResult>): SuggestionResult {
    const message = createBaseSuggestionResult();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.suggestArticlesResponse =
      (object.suggestArticlesResponse !== undefined && object.suggestArticlesResponse !== null)
        ? SuggestArticlesResponse.fromPartial(object.suggestArticlesResponse)
        : undefined;
    message.suggestKnowledgeAssistResponse =
      (object.suggestKnowledgeAssistResponse !== undefined && object.suggestKnowledgeAssistResponse !== null)
        ? SuggestKnowledgeAssistResponse.fromPartial(object.suggestKnowledgeAssistResponse)
        : undefined;
    message.suggestFaqAnswersResponse =
      (object.suggestFaqAnswersResponse !== undefined && object.suggestFaqAnswersResponse !== null)
        ? SuggestFaqAnswersResponse.fromPartial(object.suggestFaqAnswersResponse)
        : undefined;
    message.suggestSmartRepliesResponse =
      (object.suggestSmartRepliesResponse !== undefined && object.suggestSmartRepliesResponse !== null)
        ? SuggestSmartRepliesResponse.fromPartial(object.suggestSmartRepliesResponse)
        : undefined;
    message.suggestDialogflowAssistsResponse =
      (object.suggestDialogflowAssistsResponse !== undefined && object.suggestDialogflowAssistsResponse !== null)
        ? SuggestDialogflowAssistsResponse.fromPartial(object.suggestDialogflowAssistsResponse)
        : undefined;
    message.suggestEntityExtractionResponse =
      (object.suggestEntityExtractionResponse !== undefined && object.suggestEntityExtractionResponse !== null)
        ? SuggestDialogflowAssistsResponse.fromPartial(object.suggestEntityExtractionResponse)
        : undefined;
    return message;
  },
};

function createBaseSuggestArticlesRequest(): SuggestArticlesRequest {
  return { parent: "", latestMessage: "", contextSize: 0, assistQueryParams: undefined };
}

export const SuggestArticlesRequest: MessageFns<SuggestArticlesRequest> = {
  encode(message: SuggestArticlesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestArticlesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestArticlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestArticlesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
    };
  },

  toJSON(message: SuggestArticlesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestArticlesRequest>): SuggestArticlesRequest {
    return SuggestArticlesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestArticlesRequest>): SuggestArticlesRequest {
    const message = createBaseSuggestArticlesRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    return message;
  },
};

function createBaseSuggestArticlesResponse(): SuggestArticlesResponse {
  return { articleAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestArticlesResponse: MessageFns<SuggestArticlesResponse> = {
  encode(message: SuggestArticlesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.articleAnswers) {
      ArticleAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestArticlesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestArticlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.articleAnswers.push(ArticleAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestArticlesResponse {
    return {
      articleAnswers: globalThis.Array.isArray(object?.articleAnswers)
        ? object.articleAnswers.map((e: any) => ArticleAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestArticlesResponse): unknown {
    const obj: any = {};
    if (message.articleAnswers?.length) {
      obj.articleAnswers = message.articleAnswers.map((e) => ArticleAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestArticlesResponse>): SuggestArticlesResponse {
    return SuggestArticlesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestArticlesResponse>): SuggestArticlesResponse {
    const message = createBaseSuggestArticlesResponse();
    message.articleAnswers = object.articleAnswers?.map((e) => ArticleAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestFaqAnswersRequest(): SuggestFaqAnswersRequest {
  return { parent: "", latestMessage: "", contextSize: 0, assistQueryParams: undefined };
}

export const SuggestFaqAnswersRequest: MessageFns<SuggestFaqAnswersRequest> = {
  encode(message: SuggestFaqAnswersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      AssistQueryParameters.encode(message.assistQueryParams, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestFaqAnswersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestFaqAnswersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assistQueryParams = AssistQueryParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestFaqAnswersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      assistQueryParams: isSet(object.assistQueryParams)
        ? AssistQueryParameters.fromJSON(object.assistQueryParams)
        : undefined,
    };
  },

  toJSON(message: SuggestFaqAnswersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.assistQueryParams !== undefined) {
      obj.assistQueryParams = AssistQueryParameters.toJSON(message.assistQueryParams);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestFaqAnswersRequest>): SuggestFaqAnswersRequest {
    return SuggestFaqAnswersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestFaqAnswersRequest>): SuggestFaqAnswersRequest {
    const message = createBaseSuggestFaqAnswersRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.assistQueryParams = (object.assistQueryParams !== undefined && object.assistQueryParams !== null)
      ? AssistQueryParameters.fromPartial(object.assistQueryParams)
      : undefined;
    return message;
  },
};

function createBaseSuggestFaqAnswersResponse(): SuggestFaqAnswersResponse {
  return { faqAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestFaqAnswersResponse: MessageFns<SuggestFaqAnswersResponse> = {
  encode(message: SuggestFaqAnswersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.faqAnswers) {
      FaqAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestFaqAnswersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestFaqAnswersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.faqAnswers.push(FaqAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestFaqAnswersResponse {
    return {
      faqAnswers: globalThis.Array.isArray(object?.faqAnswers)
        ? object.faqAnswers.map((e: any) => FaqAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestFaqAnswersResponse): unknown {
    const obj: any = {};
    if (message.faqAnswers?.length) {
      obj.faqAnswers = message.faqAnswers.map((e) => FaqAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestFaqAnswersResponse>): SuggestFaqAnswersResponse {
    return SuggestFaqAnswersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestFaqAnswersResponse>): SuggestFaqAnswersResponse {
    const message = createBaseSuggestFaqAnswersResponse();
    message.faqAnswers = object.faqAnswers?.map((e) => FaqAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestSmartRepliesRequest(): SuggestSmartRepliesRequest {
  return { parent: "", currentTextInput: undefined, latestMessage: "", contextSize: 0 };
}

export const SuggestSmartRepliesRequest: MessageFns<SuggestSmartRepliesRequest> = {
  encode(message: SuggestSmartRepliesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.currentTextInput !== undefined) {
      TextInput.encode(message.currentTextInput, writer.uint32(34).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestSmartRepliesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestSmartRepliesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentTextInput = TextInput.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestSmartRepliesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      currentTextInput: isSet(object.currentTextInput) ? TextInput.fromJSON(object.currentTextInput) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestSmartRepliesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.currentTextInput !== undefined) {
      obj.currentTextInput = TextInput.toJSON(message.currentTextInput);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestSmartRepliesRequest>): SuggestSmartRepliesRequest {
    return SuggestSmartRepliesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestSmartRepliesRequest>): SuggestSmartRepliesRequest {
    const message = createBaseSuggestSmartRepliesRequest();
    message.parent = object.parent ?? "";
    message.currentTextInput = (object.currentTextInput !== undefined && object.currentTextInput !== null)
      ? TextInput.fromPartial(object.currentTextInput)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestSmartRepliesResponse(): SuggestSmartRepliesResponse {
  return { smartReplyAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestSmartRepliesResponse: MessageFns<SuggestSmartRepliesResponse> = {
  encode(message: SuggestSmartRepliesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.smartReplyAnswers) {
      SmartReplyAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestSmartRepliesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestSmartRepliesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.smartReplyAnswers.push(SmartReplyAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestSmartRepliesResponse {
    return {
      smartReplyAnswers: globalThis.Array.isArray(object?.smartReplyAnswers)
        ? object.smartReplyAnswers.map((e: any) => SmartReplyAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestSmartRepliesResponse): unknown {
    const obj: any = {};
    if (message.smartReplyAnswers?.length) {
      obj.smartReplyAnswers = message.smartReplyAnswers.map((e) => SmartReplyAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestSmartRepliesResponse>): SuggestSmartRepliesResponse {
    return SuggestSmartRepliesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestSmartRepliesResponse>): SuggestSmartRepliesResponse {
    const message = createBaseSuggestSmartRepliesResponse();
    message.smartReplyAnswers = object.smartReplyAnswers?.map((e) => SmartReplyAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestDialogflowAssistsResponse(): SuggestDialogflowAssistsResponse {
  return { dialogflowAssistAnswers: [], latestMessage: "", contextSize: 0 };
}

export const SuggestDialogflowAssistsResponse: MessageFns<SuggestDialogflowAssistsResponse> = {
  encode(message: SuggestDialogflowAssistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dialogflowAssistAnswers) {
      DialogflowAssistAnswer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestDialogflowAssistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestDialogflowAssistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialogflowAssistAnswers.push(DialogflowAssistAnswer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestDialogflowAssistsResponse {
    return {
      dialogflowAssistAnswers: globalThis.Array.isArray(object?.dialogflowAssistAnswers)
        ? object.dialogflowAssistAnswers.map((e: any) => DialogflowAssistAnswer.fromJSON(e))
        : [],
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestDialogflowAssistsResponse): unknown {
    const obj: any = {};
    if (message.dialogflowAssistAnswers?.length) {
      obj.dialogflowAssistAnswers = message.dialogflowAssistAnswers.map((e) => DialogflowAssistAnswer.toJSON(e));
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestDialogflowAssistsResponse>): SuggestDialogflowAssistsResponse {
    return SuggestDialogflowAssistsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestDialogflowAssistsResponse>): SuggestDialogflowAssistsResponse {
    const message = createBaseSuggestDialogflowAssistsResponse();
    message.dialogflowAssistAnswers =
      object.dialogflowAssistAnswers?.map((e) => DialogflowAssistAnswer.fromPartial(e)) || [];
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseSuggestion(): Suggestion {
  return { name: "", articles: [], faqAnswers: [], createTime: undefined, latestMessage: "" };
}

export const Suggestion: MessageFns<Suggestion> = {
  encode(message: Suggestion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.articles) {
      Suggestion_Article.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.faqAnswers) {
      Suggestion_FaqAnswer.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(58).string(message.latestMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.articles.push(Suggestion_Article.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.faqAnswers.push(Suggestion_FaqAnswer.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      articles: globalThis.Array.isArray(object?.articles)
        ? object.articles.map((e: any) => Suggestion_Article.fromJSON(e))
        : [],
      faqAnswers: globalThis.Array.isArray(object?.faqAnswers)
        ? object.faqAnswers.map((e: any) => Suggestion_FaqAnswer.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
    };
  },

  toJSON(message: Suggestion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.articles?.length) {
      obj.articles = message.articles.map((e) => Suggestion_Article.toJSON(e));
    }
    if (message.faqAnswers?.length) {
      obj.faqAnswers = message.faqAnswers.map((e) => Suggestion_FaqAnswer.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestion>): Suggestion {
    return Suggestion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestion>): Suggestion {
    const message = createBaseSuggestion();
    message.name = object.name ?? "";
    message.articles = object.articles?.map((e) => Suggestion_Article.fromPartial(e)) || [];
    message.faqAnswers = object.faqAnswers?.map((e) => Suggestion_FaqAnswer.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.latestMessage = object.latestMessage ?? "";
    return message;
  },
};

function createBaseSuggestion_Article(): Suggestion_Article {
  return { title: "", uri: "", snippets: [], metadata: {}, answerRecord: "" };
}

export const Suggestion_Article: MessageFns<Suggestion_Article> = {
  encode(message: Suggestion_Article, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    for (const v of message.snippets) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Suggestion_Article_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestion_Article {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestion_Article();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snippets.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Suggestion_Article_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestion_Article {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      snippets: globalThis.Array.isArray(object?.snippets) ? object.snippets.map((e: any) => globalThis.String(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: Suggestion_Article): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.snippets?.length) {
      obj.snippets = message.snippets;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestion_Article>): Suggestion_Article {
    return Suggestion_Article.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestion_Article>): Suggestion_Article {
    const message = createBaseSuggestion_Article();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.snippets = object.snippets?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseSuggestion_Article_MetadataEntry(): Suggestion_Article_MetadataEntry {
  return { key: "", value: "" };
}

export const Suggestion_Article_MetadataEntry: MessageFns<Suggestion_Article_MetadataEntry> = {
  encode(message: Suggestion_Article_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestion_Article_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestion_Article_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestion_Article_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Suggestion_Article_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestion_Article_MetadataEntry>): Suggestion_Article_MetadataEntry {
    return Suggestion_Article_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestion_Article_MetadataEntry>): Suggestion_Article_MetadataEntry {
    const message = createBaseSuggestion_Article_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSuggestion_FaqAnswer(): Suggestion_FaqAnswer {
  return { answer: "", confidence: 0, question: "", source: "", metadata: {}, answerRecord: "" };
}

export const Suggestion_FaqAnswer: MessageFns<Suggestion_FaqAnswer> = {
  encode(message: Suggestion_FaqAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.question !== "") {
      writer.uint32(26).string(message.question);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Suggestion_FaqAnswer_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(50).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestion_FaqAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestion_FaqAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.question = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Suggestion_FaqAnswer_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestion_FaqAnswer {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: Suggestion_FaqAnswer): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestion_FaqAnswer>): Suggestion_FaqAnswer {
    return Suggestion_FaqAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestion_FaqAnswer>): Suggestion_FaqAnswer {
    const message = createBaseSuggestion_FaqAnswer();
    message.answer = object.answer ?? "";
    message.confidence = object.confidence ?? 0;
    message.question = object.question ?? "";
    message.source = object.source ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseSuggestion_FaqAnswer_MetadataEntry(): Suggestion_FaqAnswer_MetadataEntry {
  return { key: "", value: "" };
}

export const Suggestion_FaqAnswer_MetadataEntry: MessageFns<Suggestion_FaqAnswer_MetadataEntry> = {
  encode(message: Suggestion_FaqAnswer_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Suggestion_FaqAnswer_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestion_FaqAnswer_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Suggestion_FaqAnswer_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Suggestion_FaqAnswer_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Suggestion_FaqAnswer_MetadataEntry>): Suggestion_FaqAnswer_MetadataEntry {
    return Suggestion_FaqAnswer_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Suggestion_FaqAnswer_MetadataEntry>): Suggestion_FaqAnswer_MetadataEntry {
    const message = createBaseSuggestion_FaqAnswer_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListSuggestionsRequest(): ListSuggestionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListSuggestionsRequest: MessageFns<ListSuggestionsRequest> = {
  encode(message: ListSuggestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSuggestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSuggestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSuggestionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListSuggestionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSuggestionsRequest>): ListSuggestionsRequest {
    return ListSuggestionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSuggestionsRequest>): ListSuggestionsRequest {
    const message = createBaseListSuggestionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListSuggestionsResponse(): ListSuggestionsResponse {
  return { suggestions: [], nextPageToken: "" };
}

export const ListSuggestionsResponse: MessageFns<ListSuggestionsResponse> = {
  encode(message: ListSuggestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.suggestions) {
      Suggestion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSuggestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSuggestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestions.push(Suggestion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSuggestionsResponse {
    return {
      suggestions: globalThis.Array.isArray(object?.suggestions)
        ? object.suggestions.map((e: any) => Suggestion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSuggestionsResponse): unknown {
    const obj: any = {};
    if (message.suggestions?.length) {
      obj.suggestions = message.suggestions.map((e) => Suggestion.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSuggestionsResponse>): ListSuggestionsResponse {
    return ListSuggestionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSuggestionsResponse>): ListSuggestionsResponse {
    const message = createBaseListSuggestionsResponse();
    message.suggestions = object.suggestions?.map((e) => Suggestion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCompileSuggestionRequest(): CompileSuggestionRequest {
  return { parent: "", latestMessage: "", contextSize: 0 };
}

export const CompileSuggestionRequest: MessageFns<CompileSuggestionRequest> = {
  encode(message: CompileSuggestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompileSuggestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompileSuggestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompileSuggestionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: CompileSuggestionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<CompileSuggestionRequest>): CompileSuggestionRequest {
    return CompileSuggestionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompileSuggestionRequest>): CompileSuggestionRequest {
    const message = createBaseCompileSuggestionRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseCompileSuggestionResponse(): CompileSuggestionResponse {
  return { suggestion: undefined, latestMessage: "", contextSize: 0 };
}

export const CompileSuggestionResponse: MessageFns<CompileSuggestionResponse> = {
  encode(message: CompileSuggestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestion !== undefined) {
      Suggestion.encode(message.suggestion, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompileSuggestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompileSuggestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestion = Suggestion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompileSuggestionResponse {
    return {
      suggestion: isSet(object.suggestion) ? Suggestion.fromJSON(object.suggestion) : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: CompileSuggestionResponse): unknown {
    const obj: any = {};
    if (message.suggestion !== undefined) {
      obj.suggestion = Suggestion.toJSON(message.suggestion);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<CompileSuggestionResponse>): CompileSuggestionResponse {
    return CompileSuggestionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompileSuggestionResponse>): CompileSuggestionResponse {
    const message = createBaseCompileSuggestionResponse();
    message.suggestion = (object.suggestion !== undefined && object.suggestion !== null)
      ? Suggestion.fromPartial(object.suggestion)
      : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseResponseMessage(): ResponseMessage {
  return {
    text: undefined,
    payload: undefined,
    liveAgentHandoff: undefined,
    endInteraction: undefined,
    mixedAudio: undefined,
    telephonyTransferCall: undefined,
  };
}

export const ResponseMessage: MessageFns<ResponseMessage> = {
  encode(message: ResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      ResponseMessage_Text.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(18).fork()).join();
    }
    if (message.liveAgentHandoff !== undefined) {
      ResponseMessage_LiveAgentHandoff.encode(message.liveAgentHandoff, writer.uint32(26).fork()).join();
    }
    if (message.endInteraction !== undefined) {
      ResponseMessage_EndInteraction.encode(message.endInteraction, writer.uint32(34).fork()).join();
    }
    if (message.mixedAudio !== undefined) {
      ResponseMessage_MixedAudio.encode(message.mixedAudio, writer.uint32(42).fork()).join();
    }
    if (message.telephonyTransferCall !== undefined) {
      ResponseMessage_TelephonyTransferCall.encode(message.telephonyTransferCall, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = ResponseMessage_Text.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.liveAgentHandoff = ResponseMessage_LiveAgentHandoff.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endInteraction = ResponseMessage_EndInteraction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mixedAudio = ResponseMessage_MixedAudio.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.telephonyTransferCall = ResponseMessage_TelephonyTransferCall.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage {
    return {
      text: isSet(object.text) ? ResponseMessage_Text.fromJSON(object.text) : undefined,
      payload: isObject(object.payload) ? object.payload : undefined,
      liveAgentHandoff: isSet(object.liveAgentHandoff)
        ? ResponseMessage_LiveAgentHandoff.fromJSON(object.liveAgentHandoff)
        : undefined,
      endInteraction: isSet(object.endInteraction)
        ? ResponseMessage_EndInteraction.fromJSON(object.endInteraction)
        : undefined,
      mixedAudio: isSet(object.mixedAudio) ? ResponseMessage_MixedAudio.fromJSON(object.mixedAudio) : undefined,
      telephonyTransferCall: isSet(object.telephonyTransferCall)
        ? ResponseMessage_TelephonyTransferCall.fromJSON(object.telephonyTransferCall)
        : undefined,
    };
  },

  toJSON(message: ResponseMessage): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = ResponseMessage_Text.toJSON(message.text);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.liveAgentHandoff !== undefined) {
      obj.liveAgentHandoff = ResponseMessage_LiveAgentHandoff.toJSON(message.liveAgentHandoff);
    }
    if (message.endInteraction !== undefined) {
      obj.endInteraction = ResponseMessage_EndInteraction.toJSON(message.endInteraction);
    }
    if (message.mixedAudio !== undefined) {
      obj.mixedAudio = ResponseMessage_MixedAudio.toJSON(message.mixedAudio);
    }
    if (message.telephonyTransferCall !== undefined) {
      obj.telephonyTransferCall = ResponseMessage_TelephonyTransferCall.toJSON(message.telephonyTransferCall);
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage>): ResponseMessage {
    return ResponseMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage>): ResponseMessage {
    const message = createBaseResponseMessage();
    message.text = (object.text !== undefined && object.text !== null)
      ? ResponseMessage_Text.fromPartial(object.text)
      : undefined;
    message.payload = object.payload ?? undefined;
    message.liveAgentHandoff = (object.liveAgentHandoff !== undefined && object.liveAgentHandoff !== null)
      ? ResponseMessage_LiveAgentHandoff.fromPartial(object.liveAgentHandoff)
      : undefined;
    message.endInteraction = (object.endInteraction !== undefined && object.endInteraction !== null)
      ? ResponseMessage_EndInteraction.fromPartial(object.endInteraction)
      : undefined;
    message.mixedAudio = (object.mixedAudio !== undefined && object.mixedAudio !== null)
      ? ResponseMessage_MixedAudio.fromPartial(object.mixedAudio)
      : undefined;
    message.telephonyTransferCall =
      (object.telephonyTransferCall !== undefined && object.telephonyTransferCall !== null)
        ? ResponseMessage_TelephonyTransferCall.fromPartial(object.telephonyTransferCall)
        : undefined;
    return message;
  },
};

function createBaseResponseMessage_Text(): ResponseMessage_Text {
  return { text: [] };
}

export const ResponseMessage_Text: MessageFns<ResponseMessage_Text> = {
  encode(message: ResponseMessage_Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.text) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage_Text {
    return { text: globalThis.Array.isArray(object?.text) ? object.text.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ResponseMessage_Text): unknown {
    const obj: any = {};
    if (message.text?.length) {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_Text>): ResponseMessage_Text {
    return ResponseMessage_Text.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage_Text>): ResponseMessage_Text {
    const message = createBaseResponseMessage_Text();
    message.text = object.text?.map((e) => e) || [];
    return message;
  },
};

function createBaseResponseMessage_LiveAgentHandoff(): ResponseMessage_LiveAgentHandoff {
  return { metadata: undefined };
}

export const ResponseMessage_LiveAgentHandoff: MessageFns<ResponseMessage_LiveAgentHandoff> = {
  encode(message: ResponseMessage_LiveAgentHandoff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_LiveAgentHandoff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_LiveAgentHandoff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage_LiveAgentHandoff {
    return { metadata: isObject(object.metadata) ? object.metadata : undefined };
  },

  toJSON(message: ResponseMessage_LiveAgentHandoff): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_LiveAgentHandoff>): ResponseMessage_LiveAgentHandoff {
    return ResponseMessage_LiveAgentHandoff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage_LiveAgentHandoff>): ResponseMessage_LiveAgentHandoff {
    const message = createBaseResponseMessage_LiveAgentHandoff();
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseResponseMessage_EndInteraction(): ResponseMessage_EndInteraction {
  return {};
}

export const ResponseMessage_EndInteraction: MessageFns<ResponseMessage_EndInteraction> = {
  encode(_: ResponseMessage_EndInteraction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_EndInteraction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_EndInteraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResponseMessage_EndInteraction {
    return {};
  },

  toJSON(_: ResponseMessage_EndInteraction): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_EndInteraction>): ResponseMessage_EndInteraction {
    return ResponseMessage_EndInteraction.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ResponseMessage_EndInteraction>): ResponseMessage_EndInteraction {
    const message = createBaseResponseMessage_EndInteraction();
    return message;
  },
};

function createBaseResponseMessage_MixedAudio(): ResponseMessage_MixedAudio {
  return { segments: [] };
}

export const ResponseMessage_MixedAudio: MessageFns<ResponseMessage_MixedAudio> = {
  encode(message: ResponseMessage_MixedAudio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.segments) {
      ResponseMessage_MixedAudio_Segment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_MixedAudio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_MixedAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segments.push(ResponseMessage_MixedAudio_Segment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage_MixedAudio {
    return {
      segments: globalThis.Array.isArray(object?.segments)
        ? object.segments.map((e: any) => ResponseMessage_MixedAudio_Segment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResponseMessage_MixedAudio): unknown {
    const obj: any = {};
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => ResponseMessage_MixedAudio_Segment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_MixedAudio>): ResponseMessage_MixedAudio {
    return ResponseMessage_MixedAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage_MixedAudio>): ResponseMessage_MixedAudio {
    const message = createBaseResponseMessage_MixedAudio();
    message.segments = object.segments?.map((e) => ResponseMessage_MixedAudio_Segment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResponseMessage_MixedAudio_Segment(): ResponseMessage_MixedAudio_Segment {
  return { audio: undefined, uri: undefined, allowPlaybackInterruption: false };
}

export const ResponseMessage_MixedAudio_Segment: MessageFns<ResponseMessage_MixedAudio_Segment> = {
  encode(message: ResponseMessage_MixedAudio_Segment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audio !== undefined) {
      writer.uint32(10).bytes(message.audio);
    }
    if (message.uri !== undefined) {
      writer.uint32(18).string(message.uri);
    }
    if (message.allowPlaybackInterruption !== false) {
      writer.uint32(24).bool(message.allowPlaybackInterruption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_MixedAudio_Segment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_MixedAudio_Segment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowPlaybackInterruption = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage_MixedAudio_Segment {
    return {
      audio: isSet(object.audio) ? Buffer.from(bytesFromBase64(object.audio)) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      allowPlaybackInterruption: isSet(object.allowPlaybackInterruption)
        ? globalThis.Boolean(object.allowPlaybackInterruption)
        : false,
    };
  },

  toJSON(message: ResponseMessage_MixedAudio_Segment): unknown {
    const obj: any = {};
    if (message.audio !== undefined) {
      obj.audio = base64FromBytes(message.audio);
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.allowPlaybackInterruption !== false) {
      obj.allowPlaybackInterruption = message.allowPlaybackInterruption;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_MixedAudio_Segment>): ResponseMessage_MixedAudio_Segment {
    return ResponseMessage_MixedAudio_Segment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage_MixedAudio_Segment>): ResponseMessage_MixedAudio_Segment {
    const message = createBaseResponseMessage_MixedAudio_Segment();
    message.audio = object.audio ?? undefined;
    message.uri = object.uri ?? undefined;
    message.allowPlaybackInterruption = object.allowPlaybackInterruption ?? false;
    return message;
  },
};

function createBaseResponseMessage_TelephonyTransferCall(): ResponseMessage_TelephonyTransferCall {
  return { phoneNumber: undefined, sipUri: undefined };
}

export const ResponseMessage_TelephonyTransferCall: MessageFns<ResponseMessage_TelephonyTransferCall> = {
  encode(message: ResponseMessage_TelephonyTransferCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phoneNumber !== undefined) {
      writer.uint32(10).string(message.phoneNumber);
    }
    if (message.sipUri !== undefined) {
      writer.uint32(18).string(message.sipUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage_TelephonyTransferCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage_TelephonyTransferCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sipUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage_TelephonyTransferCall {
    return {
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      sipUri: isSet(object.sipUri) ? globalThis.String(object.sipUri) : undefined,
    };
  },

  toJSON(message: ResponseMessage_TelephonyTransferCall): unknown {
    const obj: any = {};
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.sipUri !== undefined) {
      obj.sipUri = message.sipUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ResponseMessage_TelephonyTransferCall>): ResponseMessage_TelephonyTransferCall {
    return ResponseMessage_TelephonyTransferCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMessage_TelephonyTransferCall>): ResponseMessage_TelephonyTransferCall {
    const message = createBaseResponseMessage_TelephonyTransferCall();
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.sipUri = object.sipUri ?? undefined;
    return message;
  },
};

function createBaseSuggestKnowledgeAssistRequest(): SuggestKnowledgeAssistRequest {
  return { parent: "", latestMessage: "", contextSize: 0, previousSuggestedQuery: "" };
}

export const SuggestKnowledgeAssistRequest: MessageFns<SuggestKnowledgeAssistRequest> = {
  encode(message: SuggestKnowledgeAssistRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    if (message.previousSuggestedQuery !== "") {
      writer.uint32(34).string(message.previousSuggestedQuery);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestKnowledgeAssistRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestKnowledgeAssistRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.previousSuggestedQuery = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestKnowledgeAssistRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
      previousSuggestedQuery: isSet(object.previousSuggestedQuery)
        ? globalThis.String(object.previousSuggestedQuery)
        : "",
    };
  },

  toJSON(message: SuggestKnowledgeAssistRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    if (message.previousSuggestedQuery !== "") {
      obj.previousSuggestedQuery = message.previousSuggestedQuery;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestKnowledgeAssistRequest>): SuggestKnowledgeAssistRequest {
    return SuggestKnowledgeAssistRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestKnowledgeAssistRequest>): SuggestKnowledgeAssistRequest {
    const message = createBaseSuggestKnowledgeAssistRequest();
    message.parent = object.parent ?? "";
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    message.previousSuggestedQuery = object.previousSuggestedQuery ?? "";
    return message;
  },
};

function createBaseSuggestKnowledgeAssistResponse(): SuggestKnowledgeAssistResponse {
  return { knowledgeAssistAnswer: undefined, latestMessage: "", contextSize: 0 };
}

export const SuggestKnowledgeAssistResponse: MessageFns<SuggestKnowledgeAssistResponse> = {
  encode(message: SuggestKnowledgeAssistResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.knowledgeAssistAnswer !== undefined) {
      KnowledgeAssistAnswer.encode(message.knowledgeAssistAnswer, writer.uint32(10).fork()).join();
    }
    if (message.latestMessage !== "") {
      writer.uint32(18).string(message.latestMessage);
    }
    if (message.contextSize !== 0) {
      writer.uint32(24).int32(message.contextSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestKnowledgeAssistResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestKnowledgeAssistResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.knowledgeAssistAnswer = KnowledgeAssistAnswer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.latestMessage = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.contextSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestKnowledgeAssistResponse {
    return {
      knowledgeAssistAnswer: isSet(object.knowledgeAssistAnswer)
        ? KnowledgeAssistAnswer.fromJSON(object.knowledgeAssistAnswer)
        : undefined,
      latestMessage: isSet(object.latestMessage) ? globalThis.String(object.latestMessage) : "",
      contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
    };
  },

  toJSON(message: SuggestKnowledgeAssistResponse): unknown {
    const obj: any = {};
    if (message.knowledgeAssistAnswer !== undefined) {
      obj.knowledgeAssistAnswer = KnowledgeAssistAnswer.toJSON(message.knowledgeAssistAnswer);
    }
    if (message.latestMessage !== "") {
      obj.latestMessage = message.latestMessage;
    }
    if (message.contextSize !== 0) {
      obj.contextSize = Math.round(message.contextSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestKnowledgeAssistResponse>): SuggestKnowledgeAssistResponse {
    return SuggestKnowledgeAssistResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestKnowledgeAssistResponse>): SuggestKnowledgeAssistResponse {
    const message = createBaseSuggestKnowledgeAssistResponse();
    message.knowledgeAssistAnswer =
      (object.knowledgeAssistAnswer !== undefined && object.knowledgeAssistAnswer !== null)
        ? KnowledgeAssistAnswer.fromPartial(object.knowledgeAssistAnswer)
        : undefined;
    message.latestMessage = object.latestMessage ?? "";
    message.contextSize = object.contextSize ?? 0;
    return message;
  },
};

function createBaseKnowledgeAssistAnswer(): KnowledgeAssistAnswer {
  return { suggestedQuery: undefined, suggestedQueryAnswer: undefined, answerRecord: "" };
}

export const KnowledgeAssistAnswer: MessageFns<KnowledgeAssistAnswer> = {
  encode(message: KnowledgeAssistAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestedQuery !== undefined) {
      KnowledgeAssistAnswer_SuggestedQuery.encode(message.suggestedQuery, writer.uint32(10).fork()).join();
    }
    if (message.suggestedQueryAnswer !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer.encode(message.suggestedQueryAnswer, writer.uint32(18).fork()).join();
    }
    if (message.answerRecord !== "") {
      writer.uint32(26).string(message.answerRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestedQuery = KnowledgeAssistAnswer_SuggestedQuery.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.suggestedQueryAnswer = KnowledgeAssistAnswer_KnowledgeAnswer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer {
    return {
      suggestedQuery: isSet(object.suggestedQuery)
        ? KnowledgeAssistAnswer_SuggestedQuery.fromJSON(object.suggestedQuery)
        : undefined,
      suggestedQueryAnswer: isSet(object.suggestedQueryAnswer)
        ? KnowledgeAssistAnswer_KnowledgeAnswer.fromJSON(object.suggestedQueryAnswer)
        : undefined,
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
    };
  },

  toJSON(message: KnowledgeAssistAnswer): unknown {
    const obj: any = {};
    if (message.suggestedQuery !== undefined) {
      obj.suggestedQuery = KnowledgeAssistAnswer_SuggestedQuery.toJSON(message.suggestedQuery);
    }
    if (message.suggestedQueryAnswer !== undefined) {
      obj.suggestedQueryAnswer = KnowledgeAssistAnswer_KnowledgeAnswer.toJSON(message.suggestedQueryAnswer);
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer>): KnowledgeAssistAnswer {
    return KnowledgeAssistAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer>): KnowledgeAssistAnswer {
    const message = createBaseKnowledgeAssistAnswer();
    message.suggestedQuery = (object.suggestedQuery !== undefined && object.suggestedQuery !== null)
      ? KnowledgeAssistAnswer_SuggestedQuery.fromPartial(object.suggestedQuery)
      : undefined;
    message.suggestedQueryAnswer = (object.suggestedQueryAnswer !== undefined && object.suggestedQueryAnswer !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer.fromPartial(object.suggestedQueryAnswer)
      : undefined;
    message.answerRecord = object.answerRecord ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_SuggestedQuery(): KnowledgeAssistAnswer_SuggestedQuery {
  return { queryText: "" };
}

export const KnowledgeAssistAnswer_SuggestedQuery: MessageFns<KnowledgeAssistAnswer_SuggestedQuery> = {
  encode(message: KnowledgeAssistAnswer_SuggestedQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryText !== "") {
      writer.uint32(10).string(message.queryText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_SuggestedQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_SuggestedQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_SuggestedQuery {
    return { queryText: isSet(object.queryText) ? globalThis.String(object.queryText) : "" };
  },

  toJSON(message: KnowledgeAssistAnswer_SuggestedQuery): unknown {
    const obj: any = {};
    if (message.queryText !== "") {
      obj.queryText = message.queryText;
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer_SuggestedQuery>): KnowledgeAssistAnswer_SuggestedQuery {
    return KnowledgeAssistAnswer_SuggestedQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer_SuggestedQuery>): KnowledgeAssistAnswer_SuggestedQuery {
    const message = createBaseKnowledgeAssistAnswer_SuggestedQuery();
    message.queryText = object.queryText ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer(): KnowledgeAssistAnswer_KnowledgeAnswer {
  return { answerText: "", faqSource: undefined, generativeSource: undefined };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer: MessageFns<KnowledgeAssistAnswer_KnowledgeAnswer> = {
  encode(message: KnowledgeAssistAnswer_KnowledgeAnswer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answerText !== "") {
      writer.uint32(10).string(message.answerText);
    }
    if (message.faqSource !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.encode(message.faqSource, writer.uint32(26).fork()).join();
    }
    if (message.generativeSource !== undefined) {
      KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.encode(message.generativeSource, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answerText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.faqSource = KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.generativeSource = KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer {
    return {
      answerText: isSet(object.answerText) ? globalThis.String(object.answerText) : "",
      faqSource: isSet(object.faqSource)
        ? KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromJSON(object.faqSource)
        : undefined,
      generativeSource: isSet(object.generativeSource)
        ? KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromJSON(object.generativeSource)
        : undefined,
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer): unknown {
    const obj: any = {};
    if (message.answerText !== "") {
      obj.answerText = message.answerText;
    }
    if (message.faqSource !== undefined) {
      obj.faqSource = KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.toJSON(message.faqSource);
    }
    if (message.generativeSource !== undefined) {
      obj.generativeSource = KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.toJSON(message.generativeSource);
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer>): KnowledgeAssistAnswer_KnowledgeAnswer {
    return KnowledgeAssistAnswer_KnowledgeAnswer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer>): KnowledgeAssistAnswer_KnowledgeAnswer {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer();
    message.answerText = object.answerText ?? "";
    message.faqSource = (object.faqSource !== undefined && object.faqSource !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromPartial(object.faqSource)
      : undefined;
    message.generativeSource = (object.generativeSource !== undefined && object.generativeSource !== null)
      ? KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromPartial(object.generativeSource)
      : undefined;
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource(): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
  return { question: "" };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    return { question: isSet(object.question) ? globalThis.String(object.question) : "" };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource): unknown {
    const obj: any = {};
    if (message.question !== "") {
      obj.question = message.question;
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    return KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_FaqSource {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_FaqSource();
    message.question = object.question ?? "";
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource(): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
  return { snippets: [] };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.snippets) {
      KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snippets.push(
            KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    return {
      snippets: globalThis.Array.isArray(object?.snippets)
        ? object.snippets.map((e: any) => KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource): unknown {
    const obj: any = {};
    if (message.snippets?.length) {
      obj.snippets = message.snippets.map((e) =>
        KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    return KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource();
    message.snippets =
      object.snippets?.map((e) => KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet(): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
  return { uri: "", text: "", title: "" };
}

export const KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet: MessageFns<
  KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet
> = {
  encode(
    message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.title !== "") {
      writer.uint32(34).string(message.title);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.title = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
    };
  },

  toJSON(message: KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    return obj;
  },

  create(
    base?: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    return KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet>,
  ): KnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet {
    const message = createBaseKnowledgeAssistAnswer_KnowledgeAnswer_GenerativeSource_Snippet();
    message.uri = object.uri ?? "";
    message.text = object.text ?? "";
    message.title = object.title ?? "";
    return message;
  },
};

/**
 * Service for managing
 * [Participants][google.cloud.dialogflow.v2beta1.Participant].
 */
export type ParticipantsDefinition = typeof ParticipantsDefinition;
export const ParticipantsDefinition = {
  name: "Participants",
  fullName: "google.cloud.dialogflow.v2beta1.Participants",
  methods: {
    /** Creates a new participant in a conversation. */
    createParticipant: {
      name: "CreateParticipant",
      requestType: CreateParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 112, 97, 114, 116, 105, 99, 105, 112, 97, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              158,
              1,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              90,
              84,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              34,
              69,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              34,
              57,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a conversation participant. */
    getParticipant: {
      name: "GetParticipant",
      requestType: GetParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              132,
              1,
              90,
              71,
              18,
              69,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              18,
              57,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all participants in the specified conversation. */
    listParticipants: {
      name: "ListParticipants",
      requestType: ListParticipantsRequest,
      requestStream: false,
      responseType: ListParticipantsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              132,
              1,
              90,
              71,
              18,
              69,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              18,
              57,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the specified participant. */
    updateParticipant: {
      name: "UpdateParticipant",
      requestType: UpdateParticipantRequest,
      requestStream: false,
      responseType: Participant,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              182,
              1,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              90,
              96,
              58,
              11,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              50,
              81,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              50,
              69,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a text (chat, for example), or audio (phone recording, for example)
     * message from a participant into the conversation.
     *
     * Note: Always use agent versions for production traffic
     * sent to virtual agents. See [Versions and
     * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
     */
    analyzeContent: {
      name: "AnalyzeContent",
      requestType: AnalyzeContentRequest,
      requestStream: false,
      responseType: AnalyzeContentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              116,
              101,
              120,
              116,
              95,
              105,
              110,
              112,
              117,
              116,
            ]),
            Buffer.from([
              23,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              97,
              117,
              100,
              105,
              111,
              95,
              105,
              110,
              112,
              117,
              116,
            ]),
            Buffer.from([
              23,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              44,
              101,
              118,
              101,
              110,
              116,
              95,
              105,
              110,
              112,
              117,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              182,
              1,
              58,
              1,
              42,
              90,
              96,
              58,
              1,
              42,
              34,
              91,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              110,
              116,
              101,
              110,
              116,
              34,
              79,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              110,
              97,
              108,
              121,
              122,
              101,
              67,
              111,
              110,
              116,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Adds a text (e.g., chat) or audio (e.g., phone recording) message from a
     * participant into the conversation.
     * Note: This method is only available through the gRPC API (not REST).
     *
     * The top-level message sent to the client by the server is
     * `StreamingAnalyzeContentResponse`. Multiple response messages can be
     * returned in order. The first one or more messages contain the
     * `recognition_result` field. Each result represents a more complete
     * transcript of what the user said. The next message contains the
     * `reply_text` field, and potentially the `reply_audio` and/or the
     * `automated_agent_reply` fields.
     *
     * Note: Always use agent versions for production traffic
     * sent to virtual agents. See [Versions and
     * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
     */
    streamingAnalyzeContent: {
      name: "StreamingAnalyzeContent",
      requestType: StreamingAnalyzeContentRequest,
      requestStream: true,
      responseType: StreamingAnalyzeContentResponse,
      responseStream: true,
      options: {},
    },
    /**
     * Gets suggested articles for a participant based on specific historical
     * messages.
     *
     * Note that
     * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
     * will only list the auto-generated suggestions, while
     * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
     * will try to compile suggestion based on the provided conversation context
     * in the real time.
     */
    suggestArticles: {
      name: "SuggestArticles",
      requestType: SuggestArticlesRequest,
      requestStream: false,
      responseType: SuggestArticlesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              198,
              1,
              58,
              1,
              42,
              90,
              104,
              58,
              1,
              42,
              34,
              99,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              65,
              114,
              116,
              105,
              99,
              108,
              101,
              115,
              34,
              87,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              65,
              114,
              116,
              105,
              99,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets suggested faq answers for a participant based on specific historical
     * messages.
     */
    suggestFaqAnswers: {
      name: "SuggestFaqAnswers",
      requestType: SuggestFaqAnswersRequest,
      requestStream: false,
      responseType: SuggestFaqAnswersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              202,
              1,
              58,
              1,
              42,
              90,
              106,
              58,
              1,
              42,
              34,
              101,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              70,
              97,
              113,
              65,
              110,
              115,
              119,
              101,
              114,
              115,
              34,
              89,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              70,
              97,
              113,
              65,
              110,
              115,
              119,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets smart replies for a participant based on specific historical
     * messages.
     */
    suggestSmartReplies: {
      name: "SuggestSmartReplies",
      requestType: SuggestSmartRepliesRequest,
      requestStream: false,
      responseType: SuggestSmartRepliesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              206,
              1,
              58,
              1,
              42,
              90,
              108,
              58,
              1,
              42,
              34,
              103,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              83,
              109,
              97,
              114,
              116,
              82,
              101,
              112,
              108,
              105,
              101,
              115,
              34,
              91,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              83,
              109,
              97,
              114,
              116,
              82,
              101,
              112,
              108,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets knowledge assist suggestions based on historical messages. */
    suggestKnowledgeAssist: {
      name: "SuggestKnowledgeAssist",
      requestType: SuggestKnowledgeAssistRequest,
      requestStream: false,
      responseType: SuggestKnowledgeAssistResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              212,
              1,
              58,
              1,
              42,
              90,
              111,
              58,
              1,
              42,
              34,
              106,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              65,
              115,
              115,
              105,
              115,
              116,
              34,
              94,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              75,
              110,
              111,
              119,
              108,
              101,
              100,
              103,
              101,
              65,
              115,
              115,
              105,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Deprecated: Use inline suggestion, event based suggestion or
     * Suggestion* API instead.
     * See
     * [HumanAgentAssistantConfig.name][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.name]
     * for more details. Removal Date: 2020-09-01.
     *
     * Retrieves suggestions for live agents.
     *
     * This method should be used by human agent client software to fetch auto
     * generated suggestions in real-time, while the conversation with an end user
     * is in progress. The functionality is implemented in terms of the
     * [list
     * pagination](https://cloud.google.com/apis/design/design_patterns#list_pagination)
     * design pattern. The client app should use the `next_page_token` field
     * to fetch the next batch of suggestions. `suggestions` are sorted by
     * `create_time` in descending order.
     * To fetch latest suggestion, just set `page_size` to 1.
     * To fetch new suggestions without duplication, send request with filter
     * `create_time_epoch_microseconds > [first item's create_time of previous
     * request]` and empty page_token.
     *
     * @deprecated
     */
    listSuggestions: {
      name: "ListSuggestions",
      requestType: ListSuggestionsRequest,
      requestStream: false,
      responseType: ListSuggestionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              73,
              18,
              71,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deprecated. use
     * [SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles]
     * and
     * [SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers]
     * instead.
     *
     * Gets suggestions for a participant based on specific historical
     * messages.
     *
     * Note that
     * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
     * will only list the auto-generated suggestions, while
     * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
     * will try to compile suggestion based on the provided conversation context
     * in the real time.
     *
     * @deprecated
     */
    compileSuggestion: {
      name: "CompileSuggestion",
      requestType: CompileSuggestionRequest,
      requestStream: false,
      responseType: CompileSuggestionResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              99,
              111,
              110,
              118,
              101,
              114,
              115,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              97,
              114,
              116,
              105,
              99,
              105,
              112,
              97,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              103,
              103,
              101,
              115,
              116,
              105,
              111,
              110,
              115,
              58,
              99,
              111,
              109,
              112,
              105,
              108,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ParticipantsServiceImplementation<CallContextExt = {}> {
  /** Creates a new participant in a conversation. */
  createParticipant(
    request: CreateParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /** Retrieves a conversation participant. */
  getParticipant(
    request: GetParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /** Returns the list of all participants in the specified conversation. */
  listParticipants(
    request: ListParticipantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListParticipantsResponse>>;
  /** Updates the specified participant. */
  updateParticipant(
    request: UpdateParticipantRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Participant>>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  analyzeContent(
    request: AnalyzeContentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AnalyzeContentResponse>>;
  /**
   * Adds a text (e.g., chat) or audio (e.g., phone recording) message from a
   * participant into the conversation.
   * Note: This method is only available through the gRPC API (not REST).
   *
   * The top-level message sent to the client by the server is
   * `StreamingAnalyzeContentResponse`. Multiple response messages can be
   * returned in order. The first one or more messages contain the
   * `recognition_result` field. Each result represents a more complete
   * transcript of what the user said. The next message contains the
   * `reply_text` field, and potentially the `reply_audio` and/or the
   * `automated_agent_reply` fields.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  streamingAnalyzeContent(
    request: AsyncIterable<StreamingAnalyzeContentRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamingAnalyzeContentResponse>>;
  /**
   * Gets suggested articles for a participant based on specific historical
   * messages.
   *
   * Note that
   * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
   * will only list the auto-generated suggestions, while
   * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
   * will try to compile suggestion based on the provided conversation context
   * in the real time.
   */
  suggestArticles(
    request: SuggestArticlesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestArticlesResponse>>;
  /**
   * Gets suggested faq answers for a participant based on specific historical
   * messages.
   */
  suggestFaqAnswers(
    request: SuggestFaqAnswersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestFaqAnswersResponse>>;
  /**
   * Gets smart replies for a participant based on specific historical
   * messages.
   */
  suggestSmartReplies(
    request: SuggestSmartRepliesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestSmartRepliesResponse>>;
  /** Gets knowledge assist suggestions based on historical messages. */
  suggestKnowledgeAssist(
    request: SuggestKnowledgeAssistRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SuggestKnowledgeAssistResponse>>;
  /**
   * Deprecated: Use inline suggestion, event based suggestion or
   * Suggestion* API instead.
   * See
   * [HumanAgentAssistantConfig.name][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.name]
   * for more details. Removal Date: 2020-09-01.
   *
   * Retrieves suggestions for live agents.
   *
   * This method should be used by human agent client software to fetch auto
   * generated suggestions in real-time, while the conversation with an end user
   * is in progress. The functionality is implemented in terms of the
   * [list
   * pagination](https://cloud.google.com/apis/design/design_patterns#list_pagination)
   * design pattern. The client app should use the `next_page_token` field
   * to fetch the next batch of suggestions. `suggestions` are sorted by
   * `create_time` in descending order.
   * To fetch latest suggestion, just set `page_size` to 1.
   * To fetch new suggestions without duplication, send request with filter
   * `create_time_epoch_microseconds > [first item's create_time of previous
   * request]` and empty page_token.
   *
   * @deprecated
   */
  listSuggestions(
    request: ListSuggestionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSuggestionsResponse>>;
  /**
   * Deprecated. use
   * [SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles]
   * and
   * [SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers]
   * instead.
   *
   * Gets suggestions for a participant based on specific historical
   * messages.
   *
   * Note that
   * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
   * will only list the auto-generated suggestions, while
   * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
   * will try to compile suggestion based on the provided conversation context
   * in the real time.
   *
   * @deprecated
   */
  compileSuggestion(
    request: CompileSuggestionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CompileSuggestionResponse>>;
}

export interface ParticipantsClient<CallOptionsExt = {}> {
  /** Creates a new participant in a conversation. */
  createParticipant(
    request: DeepPartial<CreateParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /** Retrieves a conversation participant. */
  getParticipant(
    request: DeepPartial<GetParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /** Returns the list of all participants in the specified conversation. */
  listParticipants(
    request: DeepPartial<ListParticipantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListParticipantsResponse>;
  /** Updates the specified participant. */
  updateParticipant(
    request: DeepPartial<UpdateParticipantRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Participant>;
  /**
   * Adds a text (chat, for example), or audio (phone recording, for example)
   * message from a participant into the conversation.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  analyzeContent(
    request: DeepPartial<AnalyzeContentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AnalyzeContentResponse>;
  /**
   * Adds a text (e.g., chat) or audio (e.g., phone recording) message from a
   * participant into the conversation.
   * Note: This method is only available through the gRPC API (not REST).
   *
   * The top-level message sent to the client by the server is
   * `StreamingAnalyzeContentResponse`. Multiple response messages can be
   * returned in order. The first one or more messages contain the
   * `recognition_result` field. Each result represents a more complete
   * transcript of what the user said. The next message contains the
   * `reply_text` field, and potentially the `reply_audio` and/or the
   * `automated_agent_reply` fields.
   *
   * Note: Always use agent versions for production traffic
   * sent to virtual agents. See [Versions and
   * environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
   */
  streamingAnalyzeContent(
    request: AsyncIterable<DeepPartial<StreamingAnalyzeContentRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamingAnalyzeContentResponse>;
  /**
   * Gets suggested articles for a participant based on specific historical
   * messages.
   *
   * Note that
   * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
   * will only list the auto-generated suggestions, while
   * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
   * will try to compile suggestion based on the provided conversation context
   * in the real time.
   */
  suggestArticles(
    request: DeepPartial<SuggestArticlesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestArticlesResponse>;
  /**
   * Gets suggested faq answers for a participant based on specific historical
   * messages.
   */
  suggestFaqAnswers(
    request: DeepPartial<SuggestFaqAnswersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestFaqAnswersResponse>;
  /**
   * Gets smart replies for a participant based on specific historical
   * messages.
   */
  suggestSmartReplies(
    request: DeepPartial<SuggestSmartRepliesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestSmartRepliesResponse>;
  /** Gets knowledge assist suggestions based on historical messages. */
  suggestKnowledgeAssist(
    request: DeepPartial<SuggestKnowledgeAssistRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SuggestKnowledgeAssistResponse>;
  /**
   * Deprecated: Use inline suggestion, event based suggestion or
   * Suggestion* API instead.
   * See
   * [HumanAgentAssistantConfig.name][google.cloud.dialogflow.v2beta1.HumanAgentAssistantConfig.name]
   * for more details. Removal Date: 2020-09-01.
   *
   * Retrieves suggestions for live agents.
   *
   * This method should be used by human agent client software to fetch auto
   * generated suggestions in real-time, while the conversation with an end user
   * is in progress. The functionality is implemented in terms of the
   * [list
   * pagination](https://cloud.google.com/apis/design/design_patterns#list_pagination)
   * design pattern. The client app should use the `next_page_token` field
   * to fetch the next batch of suggestions. `suggestions` are sorted by
   * `create_time` in descending order.
   * To fetch latest suggestion, just set `page_size` to 1.
   * To fetch new suggestions without duplication, send request with filter
   * `create_time_epoch_microseconds > [first item's create_time of previous
   * request]` and empty page_token.
   *
   * @deprecated
   */
  listSuggestions(
    request: DeepPartial<ListSuggestionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSuggestionsResponse>;
  /**
   * Deprecated. use
   * [SuggestArticles][google.cloud.dialogflow.v2beta1.Participants.SuggestArticles]
   * and
   * [SuggestFaqAnswers][google.cloud.dialogflow.v2beta1.Participants.SuggestFaqAnswers]
   * instead.
   *
   * Gets suggestions for a participant based on specific historical
   * messages.
   *
   * Note that
   * [ListSuggestions][google.cloud.dialogflow.v2beta1.Participants.ListSuggestions]
   * will only list the auto-generated suggestions, while
   * [CompileSuggestion][google.cloud.dialogflow.v2beta1.Participants.CompileSuggestion]
   * will try to compile suggestion based on the provided conversation context
   * in the real time.
   *
   * @deprecated
   */
  compileSuggestion(
    request: DeepPartial<CompileSuggestionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CompileSuggestionResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
