// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3/page.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Value } from "../../../../protobuf/struct.js";
import { AdvancedSettings } from "./advanced_settings.js";
import { DataStoreConnection } from "./data_store_connection.js";
import { Fulfillment } from "./fulfillment.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3";

/**
 * A Dialogflow CX conversation (session) can be described and visualized as a
 * state machine. The states of a CX session are represented by pages.
 *
 * For each flow, you define many pages, where your combined pages can handle a
 * complete conversation on the topics the flow is designed for. At any given
 * moment, exactly one page is the current page, the current page is considered
 * active, and the flow associated with that page is considered active. Every
 * flow has a special start page. When a flow initially becomes active, the
 * start page page becomes the current page. For each conversational turn, the
 * current page will either stay the same or transition to another page.
 *
 * You configure each page to collect information from the end-user that is
 * relevant for the conversational state represented by the page.
 *
 * For more information, see the
 * [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
 */
export interface Page {
  /**
   * The unique identifier of the page.
   * Required for the
   * [Pages.UpdatePage][google.cloud.dialogflow.cx.v3.Pages.UpdatePage] method.
   * [Pages.CreatePage][google.cloud.dialogflow.cx.v3.Pages.CreatePage]
   * populates the name automatically.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  name: string;
  /** Required. The human-readable name of the page, unique within the flow. */
  displayName: string;
  /** The description of the page. The maximum length is 500 characters. */
  description: string;
  /** The fulfillment to call when the session is entering the page. */
  entryFulfillment:
    | Fulfillment
    | undefined;
  /**
   * The form associated with the page, used for collecting parameters
   * relevant to the page.
   */
  form:
    | Form
    | undefined;
  /**
   * Ordered list of
   * [`TransitionRouteGroups`][google.cloud.dialogflow.cx.v3.TransitionRouteGroup]
   * added to the page. Transition route groups must be unique within a page. If
   * the page links both flow-level transition route groups and agent-level
   * transition route groups, the flow-level ones will have higher priority and
   * will be put before the agent-level ones.
   *
   * *   If multiple transition routes within a page scope refer to the same
   *     intent, then the precedence order is: page's transition route -> page's
   *     transition route group -> flow's transition routes.
   *
   * *   If multiple transition route groups within a page contain the same
   *     intent, then the first group in the ordered list takes precedence.
   *
   * Format:`projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/transitionRouteGroups/<TransitionRouteGroup ID>`
   * or `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/transitionRouteGroups/<TransitionRouteGroup ID>` for agent-level
   * groups.
   */
  transitionRouteGroups: string[];
  /**
   * A list of transitions for the transition rules of this page.
   * They route the conversation to another page in the same flow, or another
   * flow.
   *
   * When we are in a certain page, the TransitionRoutes are evalauted in the
   * following order:
   *
   * *   TransitionRoutes defined in the page with intent specified.
   * *   TransitionRoutes defined in the
   *     [transition route
   *     groups][google.cloud.dialogflow.cx.v3.Page.transition_route_groups]
   *     with intent specified.
   * *   TransitionRoutes defined in flow with intent specified.
   * *   TransitionRoutes defined in the
   *     [transition route
   *     groups][google.cloud.dialogflow.cx.v3.Flow.transition_route_groups]
   *     with intent specified.
   * *   TransitionRoutes defined in the page with only condition specified.
   * *   TransitionRoutes defined in the
   *     [transition route
   *     groups][google.cloud.dialogflow.cx.v3.Page.transition_route_groups]
   *     with only condition specified.
   */
  transitionRoutes: TransitionRoute[];
  /**
   * Handlers associated with the page to handle events such as webhook errors,
   * no match or no input.
   */
  eventHandlers: EventHandler[];
  /**
   * Hierarchical advanced settings for this page. The settings exposed at the
   * lower level overrides the settings exposed at the higher level.
   */
  advancedSettings:
    | AdvancedSettings
    | undefined;
  /** Optional. Knowledge connector configuration. */
  knowledgeConnectorSettings: KnowledgeConnectorSettings | undefined;
}

/**
 * A form is a data model that groups related parameters that can be collected
 * from the user. The process in which the agent prompts the user and collects
 * parameter values from the user is called form filling. A form can be added to
 * a [page][google.cloud.dialogflow.cx.v3.Page]. When form filling is done, the
 * filled parameters will be written to the
 * [session][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
 */
export interface Form {
  /** Parameters to collect from the user. */
  parameters: Form_Parameter[];
}

/** Represents a form parameter. */
export interface Form_Parameter {
  /**
   * Required. The human-readable name of the parameter, unique within the
   * form.
   */
  displayName: string;
  /**
   * Indicates whether the parameter is required. Optional parameters will not
   * trigger prompts; however, they are filled if the user specifies them.
   * Required parameters must be filled before form filling concludes.
   */
  required: boolean;
  /**
   * Required. The entity type of the parameter.
   * Format: `projects/-/locations/-/agents/-/entityTypes/<System Entity Type
   * ID>` for system entity types (for example,
   * `projects/-/locations/-/agents/-/entityTypes/sys.date`), or
   * `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<Entity Type ID>` for developer entity types.
   */
  entityType: string;
  /** Indicates whether the parameter represents a list of values. */
  isList: boolean;
  /** Required. Defines fill behavior for the parameter. */
  fillBehavior:
    | Form_Parameter_FillBehavior
    | undefined;
  /**
   * The default value of an optional parameter. If the parameter is required,
   * the default value will be ignored.
   */
  defaultValue:
    | any
    | undefined;
  /**
   * Indicates whether the parameter content should be redacted in log.  If
   * redaction is enabled, the parameter content will be replaced by parameter
   * name during logging.
   * Note: the parameter content is subject to redaction if either parameter
   * level redaction or [entity type level
   * redaction][google.cloud.dialogflow.cx.v3.EntityType.redact] is enabled.
   */
  redact: boolean;
  /**
   * Hierarchical advanced settings for this parameter. The settings exposed
   * at the lower level overrides the settings exposed at the higher level.
   */
  advancedSettings: AdvancedSettings | undefined;
}

/** Configuration for how the filling of a parameter should be handled. */
export interface Form_Parameter_FillBehavior {
  /**
   * Required. The fulfillment to provide the initial prompt that the agent
   * can present to the user in order to fill the parameter.
   */
  initialPromptFulfillment:
    | Fulfillment
    | undefined;
  /**
   * The handlers for parameter-level events, used to provide reprompt for
   * the parameter or transition to a different page/flow. The supported
   * events are:
   * *   `sys.no-match-<N>`, where N can be from 1 to 6
   * *   `sys.no-match-default`
   * *   `sys.no-input-<N>`, where N can be from 1 to 6
   * *   `sys.no-input-default`
   * *   `sys.invalid-parameter`
   *
   * `initial_prompt_fulfillment` provides the first prompt for the
   * parameter.
   *
   * If the user's response does not fill the parameter, a
   * no-match/no-input event will be triggered, and the fulfillment
   * associated with the `sys.no-match-1`/`sys.no-input-1` handler (if
   * defined) will be called to provide a prompt. The
   * `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to
   * the next no-match/no-input event, and so on.
   *
   * A `sys.no-match-default` or `sys.no-input-default` handler will be used
   * to handle all following no-match/no-input events after all numbered
   * no-match/no-input handlers for the parameter are consumed.
   *
   * A `sys.invalid-parameter` handler can be defined to handle the case
   * where the parameter values have been `invalidated` by webhook. For
   * example, if the user's response fill the parameter, however the
   * parameter was invalidated by webhook, the fulfillment associated with
   * the `sys.invalid-parameter` handler (if defined) will be called to
   * provide a prompt.
   *
   * If the event handler for the corresponding event can't be found on the
   * parameter, `initial_prompt_fulfillment` will be re-prompted.
   */
  repromptEventHandlers: EventHandler[];
}

/**
 * An event handler specifies an
 * [event][google.cloud.dialogflow.cx.v3.EventHandler.event] that can be handled
 * during a session. When the specified event happens, the following actions are
 * taken in order:
 *
 * *   If there is a
 * [`trigger_fulfillment`][google.cloud.dialogflow.cx.v3.EventHandler.trigger_fulfillment]
 * associated with the event, it will be called.
 * *   If there is a
 * [`target_page`][google.cloud.dialogflow.cx.v3.EventHandler.target_page]
 * associated with the event, the session will transition into the specified
 * page.
 * *   If there is a
 * [`target_flow`][google.cloud.dialogflow.cx.v3.EventHandler.target_flow]
 * associated with the event, the session will transition into the specified
 * flow.
 */
export interface EventHandler {
  /** Output only. The unique identifier of this event handler. */
  name: string;
  /** Required. The name of the event to handle. */
  event: string;
  /**
   * The fulfillment to call when the event occurs.
   * Handling webhook errors with a fulfillment enabled with webhook could
   * cause infinite loop. It is invalid to specify such fulfillment for a
   * handler handling webhooks.
   */
  triggerFulfillment:
    | Fulfillment
    | undefined;
  /**
   * The target page to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  targetPage?:
    | string
    | undefined;
  /**
   * The target flow to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  targetFlow?: string | undefined;
}

/**
 * A transition route specifies a [intent][google.cloud.dialogflow.cx.v3.Intent]
 * that can be matched and/or a data condition that can be evaluated during a
 * session. When a specified transition is matched, the following actions are
 * taken in order:
 *
 * *   If there is a
 * [`trigger_fulfillment`][google.cloud.dialogflow.cx.v3.TransitionRoute.trigger_fulfillment]
 * associated with the transition, it will be called.
 * *   If there is a
 * [`target_page`][google.cloud.dialogflow.cx.v3.TransitionRoute.target_page]
 * associated with the transition, the session will transition into the
 * specified page.
 * *   If there is a
 * [`target_flow`][google.cloud.dialogflow.cx.v3.TransitionRoute.target_flow]
 * associated with the transition, the session will transition into the
 * specified flow.
 */
export interface TransitionRoute {
  /** Output only. The unique identifier of this transition route. */
  name: string;
  /**
   * Optional. The description of the transition route. The maximum length is
   * 500 characters.
   */
  description: string;
  /**
   * The unique identifier of an [Intent][google.cloud.dialogflow.cx.v3.Intent].
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   * Indicates that the transition can only happen when the given intent is
   * matched.
   * At least one of `intent` or `condition` must be specified. When both
   * `intent` and `condition` are specified, the transition can only happen
   * when both are fulfilled.
   */
  intent: string;
  /**
   * The condition to evaluate against [form
   * parameters][google.cloud.dialogflow.cx.v3.Form.parameters] or [session
   * parameters][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
   *
   * See the [conditions
   * reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
   * At least one of `intent` or `condition` must be specified. When both
   * `intent` and `condition` are specified, the transition can only happen
   * when both are fulfilled.
   */
  condition: string;
  /**
   * The fulfillment to call when the condition is satisfied. At least one of
   * `trigger_fulfillment` and `target` must be specified. When both are
   * defined, `trigger_fulfillment` is executed first.
   */
  triggerFulfillment:
    | Fulfillment
    | undefined;
  /**
   * The target page to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  targetPage?:
    | string
    | undefined;
  /**
   * The target flow to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  targetFlow?: string | undefined;
}

/**
 * The request message for
 * [Pages.ListPages][google.cloud.dialogflow.cx.v3.Pages.ListPages].
 */
export interface ListPagesRequest {
  /**
   * Required. The flow to list all pages for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  parent: string;
  /**
   * The language to list pages for. The following fields are language
   * dependent:
   *
   * *  `Page.entry_fulfillment.messages`
   * *  `Page.entry_fulfillment.conditional_cases`
   * *  `Page.event_handlers.trigger_fulfillment.messages`
   * *  `Page.event_handlers.trigger_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
   * *
   * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
   * *
   * `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
   * *  `Page.transition_routes.trigger_fulfillment.messages`
   * *  `Page.transition_routes.trigger_fulfillment.conditional_cases`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /**
   * The maximum number of items to return in a single page. By default 100 and
   * at most 1000.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Pages.ListPages][google.cloud.dialogflow.cx.v3.Pages.ListPages].
 */
export interface ListPagesResponse {
  /**
   * The list of pages. There will be a maximum number of items returned based
   * on the page_size field in the request.
   */
  pages: Page[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Pages.GetPage][google.cloud.dialogflow.cx.v3.Pages.GetPage].
 */
export interface GetPageRequest {
  /**
   * Required. The name of the page.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  name: string;
  /**
   * The language to retrieve the page for. The following fields are language
   * dependent:
   *
   * *  `Page.entry_fulfillment.messages`
   * *  `Page.entry_fulfillment.conditional_cases`
   * *  `Page.event_handlers.trigger_fulfillment.messages`
   * *  `Page.event_handlers.trigger_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
   * *
   * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
   * *
   * `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
   * *  `Page.transition_routes.trigger_fulfillment.messages`
   * *  `Page.transition_routes.trigger_fulfillment.conditional_cases`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [Pages.CreatePage][google.cloud.dialogflow.cx.v3.Pages.CreatePage].
 */
export interface CreatePageRequest {
  /**
   * Required. The flow to create a page for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  parent: string;
  /** Required. The page to create. */
  page:
    | Page
    | undefined;
  /**
   * The language of the following fields in `page`:
   *
   * *  `Page.entry_fulfillment.messages`
   * *  `Page.entry_fulfillment.conditional_cases`
   * *  `Page.event_handlers.trigger_fulfillment.messages`
   * *  `Page.event_handlers.trigger_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
   * *
   * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
   * *
   * `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
   * *  `Page.transition_routes.trigger_fulfillment.messages`
   * *  `Page.transition_routes.trigger_fulfillment.conditional_cases`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [Pages.UpdatePage][google.cloud.dialogflow.cx.v3.Pages.UpdatePage].
 */
export interface UpdatePageRequest {
  /** Required. The page to update. */
  page:
    | Page
    | undefined;
  /**
   * The language of the following fields in `page`:
   *
   * *  `Page.entry_fulfillment.messages`
   * *  `Page.entry_fulfillment.conditional_cases`
   * *  `Page.event_handlers.trigger_fulfillment.messages`
   * *  `Page.event_handlers.trigger_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
   * *
   * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
   * *  `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
   * *
   * `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
   * *  `Page.transition_routes.trigger_fulfillment.messages`
   * *  `Page.transition_routes.trigger_fulfillment.conditional_cases`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /**
   * The mask to control which fields get updated. If the mask is not present,
   * all fields will be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [Pages.DeletePage][google.cloud.dialogflow.cx.v3.Pages.DeletePage].
 */
export interface DeletePageRequest {
  /**
   * Required. The name of the page to delete.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/Flows/<flow ID>/pages/<Page ID>`.
   */
  name: string;
  /**
   * This field has no effect for pages with no incoming transitions.
   * For pages with incoming transitions:
   *
   * *  If `force` is set to false, an error will be returned with message
   *    indicating the incoming transitions.
   * *  If `force` is set to true, Dialogflow will remove the page, as well as
   *    any transitions to the page (i.e. [Target
   *    page][EventHandler.target_page] in event handlers or [Target
   *    page][TransitionRoute.target_page] in transition routes that point to
   *    this page will be cleared).
   */
  force: boolean;
}

/**
 * The Knowledge Connector settings for this page or flow.
 * This includes information such as the attached Knowledge Bases, and the way
 * to execute fulfillment.
 */
export interface KnowledgeConnectorSettings {
  /** Whether Knowledge Connector is enabled or not. */
  enabled: boolean;
  /**
   * The fulfillment to be triggered.
   *
   * When the answers from the Knowledge Connector are selected by Dialogflow,
   * you can utitlize the request scoped parameter `$request.knowledge.answers`
   * (contains up to the 5 highest confidence answers) and
   * `$request.knowledge.questions` (contains the corresponding questions) to
   * construct the fulfillment.
   */
  triggerFulfillment:
    | Fulfillment
    | undefined;
  /**
   * The target page to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  targetPage?:
    | string
    | undefined;
  /**
   * The target flow to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  targetFlow?:
    | string
    | undefined;
  /** Optional. List of related data store connections. */
  dataStoreConnections: DataStoreConnection[];
}

function createBasePage(): Page {
  return {
    name: "",
    displayName: "",
    description: "",
    entryFulfillment: undefined,
    form: undefined,
    transitionRouteGroups: [],
    transitionRoutes: [],
    eventHandlers: [],
    advancedSettings: undefined,
    knowledgeConnectorSettings: undefined,
  };
}

export const Page: MessageFns<Page> = {
  encode(message: Page, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(154).string(message.description);
    }
    if (message.entryFulfillment !== undefined) {
      Fulfillment.encode(message.entryFulfillment, writer.uint32(58).fork()).join();
    }
    if (message.form !== undefined) {
      Form.encode(message.form, writer.uint32(34).fork()).join();
    }
    for (const v of message.transitionRouteGroups) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.transitionRoutes) {
      TransitionRoute.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.eventHandlers) {
      EventHandler.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.advancedSettings !== undefined) {
      AdvancedSettings.encode(message.advancedSettings, writer.uint32(106).fork()).join();
    }
    if (message.knowledgeConnectorSettings !== undefined) {
      KnowledgeConnectorSettings.encode(message.knowledgeConnectorSettings, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Page {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entryFulfillment = Fulfillment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.form = Form.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transitionRouteGroups.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transitionRoutes.push(TransitionRoute.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.eventHandlers.push(EventHandler.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.advancedSettings = AdvancedSettings.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.knowledgeConnectorSettings = KnowledgeConnectorSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Page {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      entryFulfillment: isSet(object.entryFulfillment) ? Fulfillment.fromJSON(object.entryFulfillment) : undefined,
      form: isSet(object.form) ? Form.fromJSON(object.form) : undefined,
      transitionRouteGroups: globalThis.Array.isArray(object?.transitionRouteGroups)
        ? object.transitionRouteGroups.map((e: any) => globalThis.String(e))
        : [],
      transitionRoutes: globalThis.Array.isArray(object?.transitionRoutes)
        ? object.transitionRoutes.map((e: any) => TransitionRoute.fromJSON(e))
        : [],
      eventHandlers: globalThis.Array.isArray(object?.eventHandlers)
        ? object.eventHandlers.map((e: any) => EventHandler.fromJSON(e))
        : [],
      advancedSettings: isSet(object.advancedSettings) ? AdvancedSettings.fromJSON(object.advancedSettings) : undefined,
      knowledgeConnectorSettings: isSet(object.knowledgeConnectorSettings)
        ? KnowledgeConnectorSettings.fromJSON(object.knowledgeConnectorSettings)
        : undefined,
    };
  },

  toJSON(message: Page): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.entryFulfillment !== undefined) {
      obj.entryFulfillment = Fulfillment.toJSON(message.entryFulfillment);
    }
    if (message.form !== undefined) {
      obj.form = Form.toJSON(message.form);
    }
    if (message.transitionRouteGroups?.length) {
      obj.transitionRouteGroups = message.transitionRouteGroups;
    }
    if (message.transitionRoutes?.length) {
      obj.transitionRoutes = message.transitionRoutes.map((e) => TransitionRoute.toJSON(e));
    }
    if (message.eventHandlers?.length) {
      obj.eventHandlers = message.eventHandlers.map((e) => EventHandler.toJSON(e));
    }
    if (message.advancedSettings !== undefined) {
      obj.advancedSettings = AdvancedSettings.toJSON(message.advancedSettings);
    }
    if (message.knowledgeConnectorSettings !== undefined) {
      obj.knowledgeConnectorSettings = KnowledgeConnectorSettings.toJSON(message.knowledgeConnectorSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<Page>): Page {
    return Page.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Page>): Page {
    const message = createBasePage();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.entryFulfillment = (object.entryFulfillment !== undefined && object.entryFulfillment !== null)
      ? Fulfillment.fromPartial(object.entryFulfillment)
      : undefined;
    message.form = (object.form !== undefined && object.form !== null) ? Form.fromPartial(object.form) : undefined;
    message.transitionRouteGroups = object.transitionRouteGroups?.map((e) => e) || [];
    message.transitionRoutes = object.transitionRoutes?.map((e) => TransitionRoute.fromPartial(e)) || [];
    message.eventHandlers = object.eventHandlers?.map((e) => EventHandler.fromPartial(e)) || [];
    message.advancedSettings = (object.advancedSettings !== undefined && object.advancedSettings !== null)
      ? AdvancedSettings.fromPartial(object.advancedSettings)
      : undefined;
    message.knowledgeConnectorSettings =
      (object.knowledgeConnectorSettings !== undefined && object.knowledgeConnectorSettings !== null)
        ? KnowledgeConnectorSettings.fromPartial(object.knowledgeConnectorSettings)
        : undefined;
    return message;
  },
};

function createBaseForm(): Form {
  return { parameters: [] };
}

export const Form: MessageFns<Form> = {
  encode(message: Form, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameters) {
      Form_Parameter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Form {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameters.push(Form_Parameter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Form {
    return {
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Form_Parameter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Form): unknown {
    const obj: any = {};
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Form_Parameter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Form>): Form {
    return Form.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Form>): Form {
    const message = createBaseForm();
    message.parameters = object.parameters?.map((e) => Form_Parameter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseForm_Parameter(): Form_Parameter {
  return {
    displayName: "",
    required: false,
    entityType: "",
    isList: false,
    fillBehavior: undefined,
    defaultValue: undefined,
    redact: false,
    advancedSettings: undefined,
  };
}

export const Form_Parameter: MessageFns<Form_Parameter> = {
  encode(message: Form_Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    if (message.entityType !== "") {
      writer.uint32(26).string(message.entityType);
    }
    if (message.isList !== false) {
      writer.uint32(32).bool(message.isList);
    }
    if (message.fillBehavior !== undefined) {
      Form_Parameter_FillBehavior.encode(message.fillBehavior, writer.uint32(58).fork()).join();
    }
    if (message.defaultValue !== undefined) {
      Value.encode(Value.wrap(message.defaultValue), writer.uint32(74).fork()).join();
    }
    if (message.redact !== false) {
      writer.uint32(88).bool(message.redact);
    }
    if (message.advancedSettings !== undefined) {
      AdvancedSettings.encode(message.advancedSettings, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Form_Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForm_Parameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isList = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fillBehavior = Form_Parameter_FillBehavior.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.defaultValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.redact = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.advancedSettings = AdvancedSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Form_Parameter {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      isList: isSet(object.isList) ? globalThis.Boolean(object.isList) : false,
      fillBehavior: isSet(object.fillBehavior) ? Form_Parameter_FillBehavior.fromJSON(object.fillBehavior) : undefined,
      defaultValue: isSet(object?.defaultValue) ? object.defaultValue : undefined,
      redact: isSet(object.redact) ? globalThis.Boolean(object.redact) : false,
      advancedSettings: isSet(object.advancedSettings) ? AdvancedSettings.fromJSON(object.advancedSettings) : undefined,
    };
  },

  toJSON(message: Form_Parameter): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.isList !== false) {
      obj.isList = message.isList;
    }
    if (message.fillBehavior !== undefined) {
      obj.fillBehavior = Form_Parameter_FillBehavior.toJSON(message.fillBehavior);
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.redact !== false) {
      obj.redact = message.redact;
    }
    if (message.advancedSettings !== undefined) {
      obj.advancedSettings = AdvancedSettings.toJSON(message.advancedSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<Form_Parameter>): Form_Parameter {
    return Form_Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Form_Parameter>): Form_Parameter {
    const message = createBaseForm_Parameter();
    message.displayName = object.displayName ?? "";
    message.required = object.required ?? false;
    message.entityType = object.entityType ?? "";
    message.isList = object.isList ?? false;
    message.fillBehavior = (object.fillBehavior !== undefined && object.fillBehavior !== null)
      ? Form_Parameter_FillBehavior.fromPartial(object.fillBehavior)
      : undefined;
    message.defaultValue = object.defaultValue ?? undefined;
    message.redact = object.redact ?? false;
    message.advancedSettings = (object.advancedSettings !== undefined && object.advancedSettings !== null)
      ? AdvancedSettings.fromPartial(object.advancedSettings)
      : undefined;
    return message;
  },
};

function createBaseForm_Parameter_FillBehavior(): Form_Parameter_FillBehavior {
  return { initialPromptFulfillment: undefined, repromptEventHandlers: [] };
}

export const Form_Parameter_FillBehavior: MessageFns<Form_Parameter_FillBehavior> = {
  encode(message: Form_Parameter_FillBehavior, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialPromptFulfillment !== undefined) {
      Fulfillment.encode(message.initialPromptFulfillment, writer.uint32(26).fork()).join();
    }
    for (const v of message.repromptEventHandlers) {
      EventHandler.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Form_Parameter_FillBehavior {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForm_Parameter_FillBehavior();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.initialPromptFulfillment = Fulfillment.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.repromptEventHandlers.push(EventHandler.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Form_Parameter_FillBehavior {
    return {
      initialPromptFulfillment: isSet(object.initialPromptFulfillment)
        ? Fulfillment.fromJSON(object.initialPromptFulfillment)
        : undefined,
      repromptEventHandlers: globalThis.Array.isArray(object?.repromptEventHandlers)
        ? object.repromptEventHandlers.map((e: any) => EventHandler.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Form_Parameter_FillBehavior): unknown {
    const obj: any = {};
    if (message.initialPromptFulfillment !== undefined) {
      obj.initialPromptFulfillment = Fulfillment.toJSON(message.initialPromptFulfillment);
    }
    if (message.repromptEventHandlers?.length) {
      obj.repromptEventHandlers = message.repromptEventHandlers.map((e) => EventHandler.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Form_Parameter_FillBehavior>): Form_Parameter_FillBehavior {
    return Form_Parameter_FillBehavior.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Form_Parameter_FillBehavior>): Form_Parameter_FillBehavior {
    const message = createBaseForm_Parameter_FillBehavior();
    message.initialPromptFulfillment =
      (object.initialPromptFulfillment !== undefined && object.initialPromptFulfillment !== null)
        ? Fulfillment.fromPartial(object.initialPromptFulfillment)
        : undefined;
    message.repromptEventHandlers = object.repromptEventHandlers?.map((e) => EventHandler.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventHandler(): EventHandler {
  return { name: "", event: "", triggerFulfillment: undefined, targetPage: undefined, targetFlow: undefined };
}

export const EventHandler: MessageFns<EventHandler> = {
  encode(message: EventHandler, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.event !== "") {
      writer.uint32(34).string(message.event);
    }
    if (message.triggerFulfillment !== undefined) {
      Fulfillment.encode(message.triggerFulfillment, writer.uint32(42).fork()).join();
    }
    if (message.targetPage !== undefined) {
      writer.uint32(18).string(message.targetPage);
    }
    if (message.targetFlow !== undefined) {
      writer.uint32(26).string(message.targetFlow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventHandler {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.event = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerFulfillment = Fulfillment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetPage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetFlow = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventHandler {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      event: isSet(object.event) ? globalThis.String(object.event) : "",
      triggerFulfillment: isSet(object.triggerFulfillment)
        ? Fulfillment.fromJSON(object.triggerFulfillment)
        : undefined,
      targetPage: isSet(object.targetPage) ? globalThis.String(object.targetPage) : undefined,
      targetFlow: isSet(object.targetFlow) ? globalThis.String(object.targetFlow) : undefined,
    };
  },

  toJSON(message: EventHandler): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.event !== "") {
      obj.event = message.event;
    }
    if (message.triggerFulfillment !== undefined) {
      obj.triggerFulfillment = Fulfillment.toJSON(message.triggerFulfillment);
    }
    if (message.targetPage !== undefined) {
      obj.targetPage = message.targetPage;
    }
    if (message.targetFlow !== undefined) {
      obj.targetFlow = message.targetFlow;
    }
    return obj;
  },

  create(base?: DeepPartial<EventHandler>): EventHandler {
    return EventHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventHandler>): EventHandler {
    const message = createBaseEventHandler();
    message.name = object.name ?? "";
    message.event = object.event ?? "";
    message.triggerFulfillment = (object.triggerFulfillment !== undefined && object.triggerFulfillment !== null)
      ? Fulfillment.fromPartial(object.triggerFulfillment)
      : undefined;
    message.targetPage = object.targetPage ?? undefined;
    message.targetFlow = object.targetFlow ?? undefined;
    return message;
  },
};

function createBaseTransitionRoute(): TransitionRoute {
  return {
    name: "",
    description: "",
    intent: "",
    condition: "",
    triggerFulfillment: undefined,
    targetPage: undefined,
    targetFlow: undefined,
  };
}

export const TransitionRoute: MessageFns<TransitionRoute> = {
  encode(message: TransitionRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.intent !== "") {
      writer.uint32(10).string(message.intent);
    }
    if (message.condition !== "") {
      writer.uint32(18).string(message.condition);
    }
    if (message.triggerFulfillment !== undefined) {
      Fulfillment.encode(message.triggerFulfillment, writer.uint32(26).fork()).join();
    }
    if (message.targetPage !== undefined) {
      writer.uint32(34).string(message.targetPage);
    }
    if (message.targetFlow !== undefined) {
      writer.uint32(42).string(message.targetFlow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitionRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitionRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggerFulfillment = Fulfillment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetPage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetFlow = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitionRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      intent: isSet(object.intent) ? globalThis.String(object.intent) : "",
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      triggerFulfillment: isSet(object.triggerFulfillment)
        ? Fulfillment.fromJSON(object.triggerFulfillment)
        : undefined,
      targetPage: isSet(object.targetPage) ? globalThis.String(object.targetPage) : undefined,
      targetFlow: isSet(object.targetFlow) ? globalThis.String(object.targetFlow) : undefined,
    };
  },

  toJSON(message: TransitionRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.intent !== "") {
      obj.intent = message.intent;
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.triggerFulfillment !== undefined) {
      obj.triggerFulfillment = Fulfillment.toJSON(message.triggerFulfillment);
    }
    if (message.targetPage !== undefined) {
      obj.targetPage = message.targetPage;
    }
    if (message.targetFlow !== undefined) {
      obj.targetFlow = message.targetFlow;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitionRoute>): TransitionRoute {
    return TransitionRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitionRoute>): TransitionRoute {
    const message = createBaseTransitionRoute();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.intent = object.intent ?? "";
    message.condition = object.condition ?? "";
    message.triggerFulfillment = (object.triggerFulfillment !== undefined && object.triggerFulfillment !== null)
      ? Fulfillment.fromPartial(object.triggerFulfillment)
      : undefined;
    message.targetPage = object.targetPage ?? undefined;
    message.targetFlow = object.targetFlow ?? undefined;
    return message;
  },
};

function createBaseListPagesRequest(): ListPagesRequest {
  return { parent: "", languageCode: "", pageSize: 0, pageToken: "" };
}

export const ListPagesRequest: MessageFns<ListPagesRequest> = {
  encode(message: ListPagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPagesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPagesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPagesRequest>): ListPagesRequest {
    return ListPagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPagesRequest>): ListPagesRequest {
    const message = createBaseListPagesRequest();
    message.parent = object.parent ?? "";
    message.languageCode = object.languageCode ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPagesResponse(): ListPagesResponse {
  return { pages: [], nextPageToken: "" };
}

export const ListPagesResponse: MessageFns<ListPagesResponse> = {
  encode(message: ListPagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pages) {
      Page.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pages.push(Page.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPagesResponse {
    return {
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => Page.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPagesResponse): unknown {
    const obj: any = {};
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => Page.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPagesResponse>): ListPagesResponse {
    return ListPagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPagesResponse>): ListPagesResponse {
    const message = createBaseListPagesResponse();
    message.pages = object.pages?.map((e) => Page.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetPageRequest(): GetPageRequest {
  return { name: "", languageCode: "" };
}

export const GetPageRequest: MessageFns<GetPageRequest> = {
  encode(message: GetPageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPageRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: GetPageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPageRequest>): GetPageRequest {
    return GetPageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPageRequest>): GetPageRequest {
    const message = createBaseGetPageRequest();
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseCreatePageRequest(): CreatePageRequest {
  return { parent: "", page: undefined, languageCode: "" };
}

export const CreatePageRequest: MessageFns<CreatePageRequest> = {
  encode(message: CreatePageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.page !== undefined) {
      Page.encode(message.page, writer.uint32(18).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.page = Page.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePageRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      page: isSet(object.page) ? Page.fromJSON(object.page) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: CreatePageRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.page !== undefined) {
      obj.page = Page.toJSON(message.page);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePageRequest>): CreatePageRequest {
    return CreatePageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePageRequest>): CreatePageRequest {
    const message = createBaseCreatePageRequest();
    message.parent = object.parent ?? "";
    message.page = (object.page !== undefined && object.page !== null) ? Page.fromPartial(object.page) : undefined;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseUpdatePageRequest(): UpdatePageRequest {
  return { page: undefined, languageCode: "", updateMask: undefined };
}

export const UpdatePageRequest: MessageFns<UpdatePageRequest> = {
  encode(message: UpdatePageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Page.encode(message.page, writer.uint32(10).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.page = Page.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePageRequest {
    return {
      page: isSet(object.page) ? Page.fromJSON(object.page) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdatePageRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Page.toJSON(message.page);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePageRequest>): UpdatePageRequest {
    return UpdatePageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePageRequest>): UpdatePageRequest {
    const message = createBaseUpdatePageRequest();
    message.page = (object.page !== undefined && object.page !== null) ? Page.fromPartial(object.page) : undefined;
    message.languageCode = object.languageCode ?? "";
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeletePageRequest(): DeletePageRequest {
  return { name: "", force: false };
}

export const DeletePageRequest: MessageFns<DeletePageRequest> = {
  encode(message: DeletePageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePageRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeletePageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePageRequest>): DeletePageRequest {
    return DeletePageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePageRequest>): DeletePageRequest {
    const message = createBaseDeletePageRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseKnowledgeConnectorSettings(): KnowledgeConnectorSettings {
  return {
    enabled: false,
    triggerFulfillment: undefined,
    targetPage: undefined,
    targetFlow: undefined,
    dataStoreConnections: [],
  };
}

export const KnowledgeConnectorSettings: MessageFns<KnowledgeConnectorSettings> = {
  encode(message: KnowledgeConnectorSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.triggerFulfillment !== undefined) {
      Fulfillment.encode(message.triggerFulfillment, writer.uint32(26).fork()).join();
    }
    if (message.targetPage !== undefined) {
      writer.uint32(34).string(message.targetPage);
    }
    if (message.targetFlow !== undefined) {
      writer.uint32(42).string(message.targetFlow);
    }
    for (const v of message.dataStoreConnections) {
      DataStoreConnection.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeConnectorSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeConnectorSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.triggerFulfillment = Fulfillment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetPage = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetFlow = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dataStoreConnections.push(DataStoreConnection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeConnectorSettings {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      triggerFulfillment: isSet(object.triggerFulfillment)
        ? Fulfillment.fromJSON(object.triggerFulfillment)
        : undefined,
      targetPage: isSet(object.targetPage) ? globalThis.String(object.targetPage) : undefined,
      targetFlow: isSet(object.targetFlow) ? globalThis.String(object.targetFlow) : undefined,
      dataStoreConnections: globalThis.Array.isArray(object?.dataStoreConnections)
        ? object.dataStoreConnections.map((e: any) => DataStoreConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KnowledgeConnectorSettings): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.triggerFulfillment !== undefined) {
      obj.triggerFulfillment = Fulfillment.toJSON(message.triggerFulfillment);
    }
    if (message.targetPage !== undefined) {
      obj.targetPage = message.targetPage;
    }
    if (message.targetFlow !== undefined) {
      obj.targetFlow = message.targetFlow;
    }
    if (message.dataStoreConnections?.length) {
      obj.dataStoreConnections = message.dataStoreConnections.map((e) => DataStoreConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KnowledgeConnectorSettings>): KnowledgeConnectorSettings {
    return KnowledgeConnectorSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KnowledgeConnectorSettings>): KnowledgeConnectorSettings {
    const message = createBaseKnowledgeConnectorSettings();
    message.enabled = object.enabled ?? false;
    message.triggerFulfillment = (object.triggerFulfillment !== undefined && object.triggerFulfillment !== null)
      ? Fulfillment.fromPartial(object.triggerFulfillment)
      : undefined;
    message.targetPage = object.targetPage ?? undefined;
    message.targetFlow = object.targetFlow ?? undefined;
    message.dataStoreConnections = object.dataStoreConnections?.map((e) => DataStoreConnection.fromPartial(e)) || [];
    return message;
  },
};

/** Service for managing [Pages][google.cloud.dialogflow.cx.v3.Page]. */
export type PagesDefinition = typeof PagesDefinition;
export const PagesDefinition = {
  name: "Pages",
  fullName: "google.cloud.dialogflow.cx.v3.Pages",
  methods: {
    /** Returns the list of all pages in the specified flow. */
    listPages: {
      name: "ListPages",
      requestType: ListPagesRequest,
      requestStream: false,
      responseType: ListPagesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              102,
              108,
              111,
              119,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the specified page. */
    getPage: {
      name: "GetPage",
      requestType: GetPageRequest,
      requestStream: false,
      responseType: Page,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              102,
              108,
              111,
              119,
              115,
              47,
              42,
              47,
              112,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a page in the specified flow.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    createPage: {
      name: "CreatePage",
      requestType: CreatePageRequest,
      requestStream: false,
      responseType: Page,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([11, 112, 97, 114, 101, 110, 116, 44, 112, 97, 103, 101])],
          578365826: [
            Buffer.from([
              66,
              58,
              4,
              112,
              97,
              103,
              101,
              34,
              58,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              102,
              108,
              111,
              119,
              115,
              47,
              42,
              125,
              47,
              112,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified page.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    updatePage: {
      name: "UpdatePage",
      requestType: UpdatePageRequest,
      requestStream: false,
      responseType: Page,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 112, 97, 103, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              71,
              58,
              4,
              112,
              97,
              103,
              101,
              50,
              63,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              103,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              102,
              108,
              111,
              119,
              115,
              47,
              42,
              47,
              112,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified page.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    deletePage: {
      name: "DeletePage",
      requestType: DeletePageRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              102,
              108,
              111,
              119,
              115,
              47,
              42,
              47,
              112,
              97,
              103,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PagesServiceImplementation<CallContextExt = {}> {
  /** Returns the list of all pages in the specified flow. */
  listPages(request: ListPagesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListPagesResponse>>;
  /** Retrieves the specified page. */
  getPage(request: GetPageRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Page>>;
  /**
   * Creates a page in the specified flow.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createPage(request: CreatePageRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Page>>;
  /**
   * Updates the specified page.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updatePage(request: UpdatePageRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Page>>;
  /**
   * Deletes the specified page.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deletePage(request: DeletePageRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface PagesClient<CallOptionsExt = {}> {
  /** Returns the list of all pages in the specified flow. */
  listPages(request: DeepPartial<ListPagesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListPagesResponse>;
  /** Retrieves the specified page. */
  getPage(request: DeepPartial<GetPageRequest>, options?: CallOptions & CallOptionsExt): Promise<Page>;
  /**
   * Creates a page in the specified flow.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createPage(request: DeepPartial<CreatePageRequest>, options?: CallOptions & CallOptionsExt): Promise<Page>;
  /**
   * Updates the specified page.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updatePage(request: DeepPartial<UpdatePageRequest>, options?: CallOptions & CallOptionsExt): Promise<Page>;
  /**
   * Deletes the specified page.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deletePage(request: DeepPartial<DeletePageRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
