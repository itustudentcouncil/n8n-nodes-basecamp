// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3beta1/webhook.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../../protobuf/duration.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Struct, Value } from "../../../../protobuf/struct.js";
import { ResponseMessage } from "./response_message.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3beta1";

/**
 * Webhooks host the developer's business logic. During a session, webhooks
 * allow the developer to use the data extracted by Dialogflow's natural
 * language processing to generate dynamic responses, validate collected data,
 * or trigger actions on the backend.
 */
export interface Webhook {
  /**
   * The unique identifier of the webhook.
   * Required for the
   * [Webhooks.UpdateWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.UpdateWebhook]
   * method.
   * [Webhooks.CreateWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.CreateWebhook]
   * populates the name automatically. Format: `projects/<Project
   * ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>`.
   */
  name: string;
  /** Required. The human-readable name of the webhook, unique within the agent. */
  displayName: string;
  /** Configuration for a generic web service. */
  genericWebService?:
    | Webhook_GenericWebService
    | undefined;
  /**
   * Configuration for a [Service
   * Directory](https://cloud.google.com/service-directory) service.
   */
  serviceDirectory?:
    | Webhook_ServiceDirectoryConfig
    | undefined;
  /**
   * Webhook execution timeout. Execution is considered failed if Dialogflow
   * doesn't receive a response from webhook at the end of the timeout period.
   * Defaults to 5 seconds, maximum allowed timeout is 30 seconds.
   */
  timeout:
    | Duration
    | undefined;
  /** Indicates whether the webhook is disabled. */
  disabled: boolean;
}

/** Represents configuration for a generic web service. */
export interface Webhook_GenericWebService {
  /**
   * Required. The webhook URI for receiving POST requests. It must use https
   * protocol.
   */
  uri: string;
  /**
   * The user name for HTTP Basic authentication.
   *
   * @deprecated
   */
  username: string;
  /**
   * The password for HTTP Basic authentication.
   *
   * @deprecated
   */
  password: string;
  /**
   * The HTTP request headers to send together with webhook
   * requests.
   */
  requestHeaders: { [key: string]: string };
  /**
   * Optional. Specifies a list of allowed custom CA certificates (in DER
   * format) for HTTPS verification. This overrides the default SSL trust
   * store. If this is empty or unspecified, Dialogflow will use Google's
   * default trust store to verify certificates. N.B. Make sure the HTTPS
   * server certificates are signed with "subject alt name". For instance a
   * certificate can be self-signed using the following command,
   * ```
   *    openssl x509 -req -days 200 -in example.com.csr \
   *      -signkey example.com.key \
   *      -out example.com.crt \
   *      -extfile <(printf "\nsubjectAltName='DNS:www.example.com'")
   * ```
   */
  allowedCaCerts: Buffer[];
  /**
   * Optional. The OAuth configuration of the webhook. If specified,
   * Dialogflow will initiate the OAuth client credential flow to exchange an
   * access token from the 3rd party platform and put it in the auth header.
   */
  oauthConfig:
    | Webhook_GenericWebService_OAuthConfig
    | undefined;
  /**
   * Optional. Indicate the auth token type generated from the [Diglogflow
   * service
   * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
   * The generated token is sent in the Authorization header.
   */
  serviceAgentAuth: Webhook_GenericWebService_ServiceAgentAuth;
  /** Optional. Type of the webhook. */
  webhookType: Webhook_GenericWebService_WebhookType;
  /**
   * Optional. HTTP method for the flexible webhook calls. Standard webhook
   * always uses POST.
   */
  httpMethod: Webhook_GenericWebService_HttpMethod;
  /**
   * Optional. Defines a custom JSON object as request body to send to
   * flexible webhook.
   */
  requestBody: string;
  /**
   * Optional. Maps the values extracted from specific fields of the flexible
   * webhook response into session parameters.
   * - Key: session parameter name
   * - Value: field path in the webhook response
   */
  parameterMapping: { [key: string]: string };
}

/**
 * Indicate the auth token type generated from the [Diglogflow service
 * agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
 */
export enum Webhook_GenericWebService_ServiceAgentAuth {
  /** SERVICE_AGENT_AUTH_UNSPECIFIED - Service agent auth type unspecified. Default to ID_TOKEN. */
  SERVICE_AGENT_AUTH_UNSPECIFIED = 0,
  /** NONE - No token used. */
  NONE = 1,
  /**
   * ID_TOKEN - Use [ID
   * token](https://cloud.google.com/docs/authentication/token-types#id)
   * generated from service agent. This can be used to access Cloud Function
   * and Cloud Run after you grant Invoker role to
   * `service-<PROJECT-NUMBER>@gcp-sa-dialogflow.iam.gserviceaccount.com`.
   */
  ID_TOKEN = 2,
  /**
   * ACCESS_TOKEN - Use [access
   * token](https://cloud.google.com/docs/authentication/token-types#access)
   * generated from service agent. This can be used to access other Google
   * Cloud APIs after you grant required roles to
   * `service-<PROJECT-NUMBER>@gcp-sa-dialogflow.iam.gserviceaccount.com`.
   */
  ACCESS_TOKEN = 3,
  UNRECOGNIZED = -1,
}

export function webhook_GenericWebService_ServiceAgentAuthFromJSON(
  object: any,
): Webhook_GenericWebService_ServiceAgentAuth {
  switch (object) {
    case 0:
    case "SERVICE_AGENT_AUTH_UNSPECIFIED":
      return Webhook_GenericWebService_ServiceAgentAuth.SERVICE_AGENT_AUTH_UNSPECIFIED;
    case 1:
    case "NONE":
      return Webhook_GenericWebService_ServiceAgentAuth.NONE;
    case 2:
    case "ID_TOKEN":
      return Webhook_GenericWebService_ServiceAgentAuth.ID_TOKEN;
    case 3:
    case "ACCESS_TOKEN":
      return Webhook_GenericWebService_ServiceAgentAuth.ACCESS_TOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Webhook_GenericWebService_ServiceAgentAuth.UNRECOGNIZED;
  }
}

export function webhook_GenericWebService_ServiceAgentAuthToJSON(
  object: Webhook_GenericWebService_ServiceAgentAuth,
): string {
  switch (object) {
    case Webhook_GenericWebService_ServiceAgentAuth.SERVICE_AGENT_AUTH_UNSPECIFIED:
      return "SERVICE_AGENT_AUTH_UNSPECIFIED";
    case Webhook_GenericWebService_ServiceAgentAuth.NONE:
      return "NONE";
    case Webhook_GenericWebService_ServiceAgentAuth.ID_TOKEN:
      return "ID_TOKEN";
    case Webhook_GenericWebService_ServiceAgentAuth.ACCESS_TOKEN:
      return "ACCESS_TOKEN";
    case Webhook_GenericWebService_ServiceAgentAuth.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the type of webhook configuration. */
export enum Webhook_GenericWebService_WebhookType {
  /** WEBHOOK_TYPE_UNSPECIFIED - Default value. This value is unused. */
  WEBHOOK_TYPE_UNSPECIFIED = 0,
  /** STANDARD - Represents a standard webhook. */
  STANDARD = 1,
  /** FLEXIBLE - Represents a flexible webhook. */
  FLEXIBLE = 2,
  UNRECOGNIZED = -1,
}

export function webhook_GenericWebService_WebhookTypeFromJSON(object: any): Webhook_GenericWebService_WebhookType {
  switch (object) {
    case 0:
    case "WEBHOOK_TYPE_UNSPECIFIED":
      return Webhook_GenericWebService_WebhookType.WEBHOOK_TYPE_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return Webhook_GenericWebService_WebhookType.STANDARD;
    case 2:
    case "FLEXIBLE":
      return Webhook_GenericWebService_WebhookType.FLEXIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Webhook_GenericWebService_WebhookType.UNRECOGNIZED;
  }
}

export function webhook_GenericWebService_WebhookTypeToJSON(object: Webhook_GenericWebService_WebhookType): string {
  switch (object) {
    case Webhook_GenericWebService_WebhookType.WEBHOOK_TYPE_UNSPECIFIED:
      return "WEBHOOK_TYPE_UNSPECIFIED";
    case Webhook_GenericWebService_WebhookType.STANDARD:
      return "STANDARD";
    case Webhook_GenericWebService_WebhookType.FLEXIBLE:
      return "FLEXIBLE";
    case Webhook_GenericWebService_WebhookType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HTTP method to use when calling webhooks. */
export enum Webhook_GenericWebService_HttpMethod {
  /** HTTP_METHOD_UNSPECIFIED - HTTP method not specified. */
  HTTP_METHOD_UNSPECIFIED = 0,
  /** POST - HTTP POST Method. */
  POST = 1,
  /** GET - HTTP GET Method. */
  GET = 2,
  /** HEAD - HTTP HEAD Method. */
  HEAD = 3,
  /** PUT - HTTP PUT Method. */
  PUT = 4,
  /** DELETE - HTTP DELETE Method. */
  DELETE = 5,
  /** PATCH - HTTP PATCH Method. */
  PATCH = 6,
  /** OPTIONS - HTTP OPTIONS Method. */
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function webhook_GenericWebService_HttpMethodFromJSON(object: any): Webhook_GenericWebService_HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return Webhook_GenericWebService_HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return Webhook_GenericWebService_HttpMethod.POST;
    case 2:
    case "GET":
      return Webhook_GenericWebService_HttpMethod.GET;
    case 3:
    case "HEAD":
      return Webhook_GenericWebService_HttpMethod.HEAD;
    case 4:
    case "PUT":
      return Webhook_GenericWebService_HttpMethod.PUT;
    case 5:
    case "DELETE":
      return Webhook_GenericWebService_HttpMethod.DELETE;
    case 6:
    case "PATCH":
      return Webhook_GenericWebService_HttpMethod.PATCH;
    case 7:
    case "OPTIONS":
      return Webhook_GenericWebService_HttpMethod.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Webhook_GenericWebService_HttpMethod.UNRECOGNIZED;
  }
}

export function webhook_GenericWebService_HttpMethodToJSON(object: Webhook_GenericWebService_HttpMethod): string {
  switch (object) {
    case Webhook_GenericWebService_HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case Webhook_GenericWebService_HttpMethod.POST:
      return "POST";
    case Webhook_GenericWebService_HttpMethod.GET:
      return "GET";
    case Webhook_GenericWebService_HttpMethod.HEAD:
      return "HEAD";
    case Webhook_GenericWebService_HttpMethod.PUT:
      return "PUT";
    case Webhook_GenericWebService_HttpMethod.DELETE:
      return "DELETE";
    case Webhook_GenericWebService_HttpMethod.PATCH:
      return "PATCH";
    case Webhook_GenericWebService_HttpMethod.OPTIONS:
      return "OPTIONS";
    case Webhook_GenericWebService_HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents configuration of OAuth client credential flow for 3rd party
 * API authentication.
 */
export interface Webhook_GenericWebService_OAuthConfig {
  /** Required. The client ID provided by the 3rd party platform. */
  clientId: string;
  /** Required. The client secret provided by the 3rd party platform. */
  clientSecret: string;
  /**
   * Required. The token endpoint provided by the 3rd party platform to
   * exchange an access token.
   */
  tokenEndpoint: string;
  /** Optional. The OAuth scopes to grant. */
  scopes: string[];
}

export interface Webhook_GenericWebService_RequestHeadersEntry {
  key: string;
  value: string;
}

export interface Webhook_GenericWebService_ParameterMappingEntry {
  key: string;
  value: string;
}

/**
 * Represents configuration for a [Service
 * Directory](https://cloud.google.com/service-directory) service.
 */
export interface Webhook_ServiceDirectoryConfig {
  /**
   * Required. The name of [Service
   * Directory](https://cloud.google.com/service-directory) service.
   * Format: `projects/<Project ID>/locations/<Location
   * ID>/namespaces/<Namespace ID>/services/<Service ID>`.
   * `Location ID` of the service directory must be the same as the location
   * of the agent.
   */
  service: string;
  /** Generic Service configuration of this webhook. */
  genericWebService: Webhook_GenericWebService | undefined;
}

/**
 * The request message for
 * [Webhooks.ListWebhooks][google.cloud.dialogflow.cx.v3beta1.Webhooks.ListWebhooks].
 */
export interface ListWebhooksRequest {
  /**
   * Required. The agent to list all webhooks for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The maximum number of items to return in a single page. By default 100 and
   * at most 1000.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [Webhooks.ListWebhooks][google.cloud.dialogflow.cx.v3beta1.Webhooks.ListWebhooks].
 */
export interface ListWebhooksResponse {
  /**
   * The list of webhooks. There will be a maximum number of items returned
   * based on the page_size field in the request.
   */
  webhooks: Webhook[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [Webhooks.GetWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.GetWebhook].
 */
export interface GetWebhookRequest {
  /**
   * Required. The name of the webhook.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/webhooks/<Webhook ID>`.
   */
  name: string;
}

/**
 * The request message for
 * [Webhooks.CreateWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.CreateWebhook].
 */
export interface CreateWebhookRequest {
  /**
   * Required. The agent to create a webhook for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /** Required. The webhook to create. */
  webhook: Webhook | undefined;
}

/**
 * The request message for
 * [Webhooks.UpdateWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.UpdateWebhook].
 */
export interface UpdateWebhookRequest {
  /** Required. The webhook to update. */
  webhook:
    | Webhook
    | undefined;
  /**
   * The mask to control which fields get updated. If the mask is not present,
   * all fields will be updated.
   */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [Webhooks.DeleteWebhook][google.cloud.dialogflow.cx.v3beta1.Webhooks.DeleteWebhook].
 */
export interface DeleteWebhookRequest {
  /**
   * Required. The name of the webhook to delete.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/webhooks/<Webhook ID>`.
   */
  name: string;
  /**
   * This field has no effect for webhook not being used.
   * For webhooks that are used by pages/flows/transition route groups:
   *
   * *  If `force` is set to false, an error will be returned with message
   *    indicating the referenced resources.
   * *  If `force` is set to true, Dialogflow will remove the webhook, as well
   *    as any references to the webhook (i.e.
   *    [Webhook][google.cloud.dialogflow.cx.v3beta1.Fulfillment.webhook] and
   *    [tag][google.cloud.dialogflow.cx.v3beta1.Fulfillment.tag]in fulfillments
   *    that point to this webhook will be removed).
   */
  force: boolean;
}

/**
 * The request message for a webhook call. The request is sent as a JSON object
 * and the field names will be presented in camel cases.
 *
 * You may see undocumented fields in an actual request. These fields are used
 * internally by Dialogflow and should be ignored.
 */
export interface WebhookRequest {
  /**
   * Always present. The unique identifier of the
   * [DetectIntentResponse][google.cloud.dialogflow.cx.v3beta1.DetectIntentResponse]
   * that will be returned to the API caller.
   */
  detectIntentResponseId: string;
  /**
   * If [natural language text][google.cloud.dialogflow.cx.v3beta1.TextInput]
   * was provided as input, this field will contain a copy of the text.
   */
  text?:
    | string
    | undefined;
  /**
   * If an [intent][google.cloud.dialogflow.cx.v3beta1.IntentInput] was
   * provided as input, this field will contain a copy of the intent
   * identifier. Format: `projects/<Project ID>/locations/<Location
   * ID>/agents/<Agent ID>/intents/<Intent ID>`.
   */
  triggerIntent?:
    | string
    | undefined;
  /**
   * If [natural language speech
   * audio][google.cloud.dialogflow.cx.v3beta1.AudioInput] was provided as
   * input, this field will contain the transcript for the audio.
   */
  transcript?:
    | string
    | undefined;
  /**
   * If an [event][google.cloud.dialogflow.cx.v3beta1.EventInput] was provided
   * as input, this field will contain the name of the event.
   */
  triggerEvent?:
    | string
    | undefined;
  /**
   * If [DTMF][google.cloud.dialogflow.cx.v3beta1.DtmfInput] was provided as
   * input, this field will contain the DTMF digits.
   */
  dtmfDigits?:
    | string
    | undefined;
  /**
   * The language code specified in the [original
   * request][QueryInput.language_code].
   */
  languageCode: string;
  /**
   * Always present. Information about the fulfillment that triggered this
   * webhook call.
   */
  fulfillmentInfo:
    | WebhookRequest_FulfillmentInfo
    | undefined;
  /** Information about the last matched intent. */
  intentInfo:
    | WebhookRequest_IntentInfo
    | undefined;
  /** Information about page status. */
  pageInfo:
    | PageInfo
    | undefined;
  /** Information about session status. */
  sessionInfo:
    | SessionInfo
    | undefined;
  /**
   * The list of rich message responses to present to the user. Webhook can
   * choose to append or replace this list in
   * [WebhookResponse.fulfillment_response][google.cloud.dialogflow.cx.v3beta1.WebhookResponse.fulfillment_response];
   */
  messages: ResponseMessage[];
  /**
   * Custom data set in
   * [QueryParameters.payload][google.cloud.dialogflow.cx.v3beta1.QueryParameters.payload].
   */
  payload:
    | { [key: string]: any }
    | undefined;
  /**
   * The sentiment analysis result of the current user request. The field is
   * filled when sentiment analysis is configured to be enabled for the request.
   */
  sentimentAnalysisResult:
    | WebhookRequest_SentimentAnalysisResult
    | undefined;
  /** Information about the language of the request. */
  languageInfo: LanguageInfo | undefined;
}

/** Represents fulfillment information communicated to the webhook. */
export interface WebhookRequest_FulfillmentInfo {
  /**
   * Always present.
   * The value of the
   * [Fulfillment.tag][google.cloud.dialogflow.cx.v3beta1.Fulfillment.tag]
   * field will be populated in this field by Dialogflow when the associated
   * webhook is called. The tag is typically used by the webhook service to
   * identify which fulfillment is being called, but it could be used for
   * other purposes.
   */
  tag: string;
}

/** Represents intent information communicated to the webhook. */
export interface WebhookRequest_IntentInfo {
  /**
   * Always present. The unique identifier of the last matched
   * [intent][google.cloud.dialogflow.cx.v3beta1.Intent].
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/intents/<Intent ID>`.
   */
  lastMatchedIntent: string;
  /**
   * Always present. The display name of the last matched
   * [intent][google.cloud.dialogflow.cx.v3beta1.Intent].
   */
  displayName: string;
  /**
   * Parameters identified as a result of intent matching. This is a map of
   * the name of the identified parameter to the value of the parameter
   * identified from the user's utterance. All parameters defined in the
   * matched intent that are identified will be surfaced here.
   */
  parameters: { [key: string]: WebhookRequest_IntentInfo_IntentParameterValue };
  /**
   * The confidence of the matched intent. Values range from 0.0 (completely
   * uncertain) to 1.0 (completely certain).
   */
  confidence: number;
}

/** Represents a value for an intent parameter. */
export interface WebhookRequest_IntentInfo_IntentParameterValue {
  /** Always present. Original text value extracted from user utterance. */
  originalValue: string;
  /**
   * Always present. Structured value for the parameter extracted from user
   * utterance.
   */
  resolvedValue: any | undefined;
}

export interface WebhookRequest_IntentInfo_ParametersEntry {
  key: string;
  value: WebhookRequest_IntentInfo_IntentParameterValue | undefined;
}

/** Represents the result of sentiment analysis. */
export interface WebhookRequest_SentimentAnalysisResult {
  /**
   * Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
   * sentiment).
   */
  score: number;
  /**
   * A non-negative number in the [0, +inf) range, which represents the
   * absolute magnitude of sentiment, regardless of score (positive or
   * negative).
   */
  magnitude: number;
}

/** The response message for a webhook call. */
export interface WebhookResponse {
  /**
   * The fulfillment response to send to the user. This field can be omitted by
   * the webhook if it does not intend to send any response to the user.
   */
  fulfillmentResponse:
    | WebhookResponse_FulfillmentResponse
    | undefined;
  /**
   * Information about page status. This field can be omitted by the webhook if
   * it does not intend to modify page status.
   */
  pageInfo:
    | PageInfo
    | undefined;
  /**
   * Information about session status. This field can be omitted by the webhook
   * if it does not intend to modify session status.
   */
  sessionInfo:
    | SessionInfo
    | undefined;
  /**
   * Value to append directly to
   * [QueryResult.webhook_payloads][google.cloud.dialogflow.cx.v3beta1.QueryResult.webhook_payloads].
   */
  payload:
    | { [key: string]: any }
    | undefined;
  /**
   * The target page to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>/pages/<Page ID>`.
   */
  targetPage?:
    | string
    | undefined;
  /**
   * The target flow to transition to.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/flows/<Flow ID>`.
   */
  targetFlow?: string | undefined;
}

/** Represents a fulfillment response to the user. */
export interface WebhookResponse_FulfillmentResponse {
  /** The list of rich message responses to present to the user. */
  messages: ResponseMessage[];
  /** Merge behavior for `messages`. */
  mergeBehavior: WebhookResponse_FulfillmentResponse_MergeBehavior;
}

/** Defines merge behavior for `messages`. */
export enum WebhookResponse_FulfillmentResponse_MergeBehavior {
  /** MERGE_BEHAVIOR_UNSPECIFIED - Not specified. `APPEND` will be used. */
  MERGE_BEHAVIOR_UNSPECIFIED = 0,
  /**
   * APPEND - `messages` will be appended to the list of messages waiting to be sent
   * to the user.
   */
  APPEND = 1,
  /**
   * REPLACE - `messages` will replace the list of messages waiting to be sent to the
   * user.
   */
  REPLACE = 2,
  UNRECOGNIZED = -1,
}

export function webhookResponse_FulfillmentResponse_MergeBehaviorFromJSON(
  object: any,
): WebhookResponse_FulfillmentResponse_MergeBehavior {
  switch (object) {
    case 0:
    case "MERGE_BEHAVIOR_UNSPECIFIED":
      return WebhookResponse_FulfillmentResponse_MergeBehavior.MERGE_BEHAVIOR_UNSPECIFIED;
    case 1:
    case "APPEND":
      return WebhookResponse_FulfillmentResponse_MergeBehavior.APPEND;
    case 2:
    case "REPLACE":
      return WebhookResponse_FulfillmentResponse_MergeBehavior.REPLACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WebhookResponse_FulfillmentResponse_MergeBehavior.UNRECOGNIZED;
  }
}

export function webhookResponse_FulfillmentResponse_MergeBehaviorToJSON(
  object: WebhookResponse_FulfillmentResponse_MergeBehavior,
): string {
  switch (object) {
    case WebhookResponse_FulfillmentResponse_MergeBehavior.MERGE_BEHAVIOR_UNSPECIFIED:
      return "MERGE_BEHAVIOR_UNSPECIFIED";
    case WebhookResponse_FulfillmentResponse_MergeBehavior.APPEND:
      return "APPEND";
    case WebhookResponse_FulfillmentResponse_MergeBehavior.REPLACE:
      return "REPLACE";
    case WebhookResponse_FulfillmentResponse_MergeBehavior.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents page information communicated to and from the webhook. */
export interface PageInfo {
  /**
   * Always present for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Ignored for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse]. The
   * unique identifier of the current page. Format: `projects/<Project
   * ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page
   * ID>`.
   */
  currentPage: string;
  /**
   * Always present for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Ignored for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse]. The
   * display name of the current page.
   */
  displayName: string;
  /**
   * Optional for both
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest] and
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * Information about the form.
   */
  formInfo: PageInfo_FormInfo | undefined;
}

/** Represents form information. */
export interface PageInfo_FormInfo {
  /**
   * Optional for both
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest] and
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * The parameters contained in the form. Note that the webhook cannot add
   * or remove any form parameter.
   */
  parameterInfo: PageInfo_FormInfo_ParameterInfo[];
}

/** Represents parameter information. */
export interface PageInfo_FormInfo_ParameterInfo {
  /**
   * Always present for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Required for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * The human-readable name of the parameter, unique within the form. This
   * field cannot be modified by the webhook.
   */
  displayName: string;
  /**
   * Optional for both
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest] and
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * Indicates whether the parameter is required. Optional parameters will
   * not trigger prompts; however, they are filled if the user specifies
   * them. Required parameters must be filled before form filling concludes.
   */
  required: boolean;
  /**
   * Always present for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Required for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * The state of the parameter. This field can be set to
   * [INVALID][google.cloud.dialogflow.cx.v3beta1.PageInfo.FormInfo.ParameterInfo.ParameterState.INVALID]
   * by the webhook to invalidate the parameter; other values set by the
   * webhook will be ignored.
   */
  state: PageInfo_FormInfo_ParameterInfo_ParameterState;
  /**
   * Optional for both
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest] and
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * The value of the parameter. This field can be set by the webhook to
   * change the parameter value.
   */
  value:
    | any
    | undefined;
  /**
   * Optional for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Ignored for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse].
   * Indicates if the parameter value was just collected on the last
   * conversation turn.
   */
  justCollected: boolean;
}

/** Represents the state of a parameter. */
export enum PageInfo_FormInfo_ParameterInfo_ParameterState {
  /** PARAMETER_STATE_UNSPECIFIED - Not specified. This value should be never used. */
  PARAMETER_STATE_UNSPECIFIED = 0,
  /** EMPTY - Indicates that the parameter does not have a value. */
  EMPTY = 1,
  /**
   * INVALID - Indicates that the parameter value is invalid. This field can be used
   * by the webhook to invalidate the parameter and ask the server to
   * collect it from the user again.
   */
  INVALID = 2,
  /** FILLED - Indicates that the parameter has a value. */
  FILLED = 3,
  UNRECOGNIZED = -1,
}

export function pageInfo_FormInfo_ParameterInfo_ParameterStateFromJSON(
  object: any,
): PageInfo_FormInfo_ParameterInfo_ParameterState {
  switch (object) {
    case 0:
    case "PARAMETER_STATE_UNSPECIFIED":
      return PageInfo_FormInfo_ParameterInfo_ParameterState.PARAMETER_STATE_UNSPECIFIED;
    case 1:
    case "EMPTY":
      return PageInfo_FormInfo_ParameterInfo_ParameterState.EMPTY;
    case 2:
    case "INVALID":
      return PageInfo_FormInfo_ParameterInfo_ParameterState.INVALID;
    case 3:
    case "FILLED":
      return PageInfo_FormInfo_ParameterInfo_ParameterState.FILLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PageInfo_FormInfo_ParameterInfo_ParameterState.UNRECOGNIZED;
  }
}

export function pageInfo_FormInfo_ParameterInfo_ParameterStateToJSON(
  object: PageInfo_FormInfo_ParameterInfo_ParameterState,
): string {
  switch (object) {
    case PageInfo_FormInfo_ParameterInfo_ParameterState.PARAMETER_STATE_UNSPECIFIED:
      return "PARAMETER_STATE_UNSPECIFIED";
    case PageInfo_FormInfo_ParameterInfo_ParameterState.EMPTY:
      return "EMPTY";
    case PageInfo_FormInfo_ParameterInfo_ParameterState.INVALID:
      return "INVALID";
    case PageInfo_FormInfo_ParameterInfo_ParameterState.FILLED:
      return "FILLED";
    case PageInfo_FormInfo_ParameterInfo_ParameterState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents session information communicated to and from the webhook. */
export interface SessionInfo {
  /**
   * Always present for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Ignored for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse]. The
   * unique identifier of the
   * [session][google.cloud.dialogflow.cx.v3beta1.DetectIntentRequest.session].
   * This field can be used by the webhook to identify a session. Format:
   * `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/sessions/<Session ID>` or `projects/<Project ID>/locations/<Location
   * ID>/agents/<Agent ID>/environments/<Environment ID>/sessions/<Session ID>`
   * if environment is specified.
   */
  session: string;
  /**
   * Optional for
   * [WebhookRequest][google.cloud.dialogflow.cx.v3beta1.WebhookRequest].
   * Optional for
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse]. All
   * parameters collected from forms and intents during the session. Parameters
   * can be created, updated, or removed by the webhook. To remove a parameter
   * from the session, the webhook should explicitly set the parameter value to
   * null in
   * [WebhookResponse][google.cloud.dialogflow.cx.v3beta1.WebhookResponse]. The
   * map is keyed by parameters' display names.
   */
  parameters: { [key: string]: any | undefined };
}

export interface SessionInfo_ParametersEntry {
  key: string;
  value: any | undefined;
}

/** Represents the language information of the request. */
export interface LanguageInfo {
  /**
   * The language code specified in the original
   * [request][google.cloud.dialogflow.cx.v3beta1.QueryInput.language_code].
   */
  inputLanguageCode: string;
  /**
   * The language code detected for this request based on the user
   * conversation.
   */
  resolvedLanguageCode: string;
  /** The confidence score of the detected language between 0 and 1. */
  confidenceScore: number;
}

function createBaseWebhook(): Webhook {
  return {
    name: "",
    displayName: "",
    genericWebService: undefined,
    serviceDirectory: undefined,
    timeout: undefined,
    disabled: false,
  };
}

export const Webhook: MessageFns<Webhook> = {
  encode(message: Webhook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.genericWebService !== undefined) {
      Webhook_GenericWebService.encode(message.genericWebService, writer.uint32(34).fork()).join();
    }
    if (message.serviceDirectory !== undefined) {
      Webhook_ServiceDirectoryConfig.encode(message.serviceDirectory, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(50).fork()).join();
    }
    if (message.disabled !== false) {
      writer.uint32(40).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Webhook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.genericWebService = Webhook_GenericWebService.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceDirectory = Webhook_ServiceDirectoryConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      genericWebService: isSet(object.genericWebService)
        ? Webhook_GenericWebService.fromJSON(object.genericWebService)
        : undefined,
      serviceDirectory: isSet(object.serviceDirectory)
        ? Webhook_ServiceDirectoryConfig.fromJSON(object.serviceDirectory)
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: Webhook): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.genericWebService !== undefined) {
      obj.genericWebService = Webhook_GenericWebService.toJSON(message.genericWebService);
    }
    if (message.serviceDirectory !== undefined) {
      obj.serviceDirectory = Webhook_ServiceDirectoryConfig.toJSON(message.serviceDirectory);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<Webhook>): Webhook {
    return Webhook.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Webhook>): Webhook {
    const message = createBaseWebhook();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.genericWebService = (object.genericWebService !== undefined && object.genericWebService !== null)
      ? Webhook_GenericWebService.fromPartial(object.genericWebService)
      : undefined;
    message.serviceDirectory = (object.serviceDirectory !== undefined && object.serviceDirectory !== null)
      ? Webhook_ServiceDirectoryConfig.fromPartial(object.serviceDirectory)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseWebhook_GenericWebService(): Webhook_GenericWebService {
  return {
    uri: "",
    username: "",
    password: "",
    requestHeaders: {},
    allowedCaCerts: [],
    oauthConfig: undefined,
    serviceAgentAuth: 0,
    webhookType: 0,
    httpMethod: 0,
    requestBody: "",
    parameterMapping: {},
  };
}

export const Webhook_GenericWebService: MessageFns<Webhook_GenericWebService> = {
  encode(message: Webhook_GenericWebService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    Object.entries(message.requestHeaders).forEach(([key, value]) => {
      Webhook_GenericWebService_RequestHeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.allowedCaCerts) {
      writer.uint32(42).bytes(v!);
    }
    if (message.oauthConfig !== undefined) {
      Webhook_GenericWebService_OAuthConfig.encode(message.oauthConfig, writer.uint32(90).fork()).join();
    }
    if (message.serviceAgentAuth !== 0) {
      writer.uint32(96).int32(message.serviceAgentAuth);
    }
    if (message.webhookType !== 0) {
      writer.uint32(48).int32(message.webhookType);
    }
    if (message.httpMethod !== 0) {
      writer.uint32(56).int32(message.httpMethod);
    }
    if (message.requestBody !== "") {
      writer.uint32(66).string(message.requestBody);
    }
    Object.entries(message.parameterMapping).forEach(([key, value]) => {
      Webhook_GenericWebService_ParameterMappingEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Webhook_GenericWebService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook_GenericWebService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Webhook_GenericWebService_RequestHeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.requestHeaders[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.allowedCaCerts.push(Buffer.from(reader.bytes()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.oauthConfig = Webhook_GenericWebService_OAuthConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.serviceAgentAuth = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.webhookType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.requestBody = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Webhook_GenericWebService_ParameterMappingEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.parameterMapping[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook_GenericWebService {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      requestHeaders: isObject(object.requestHeaders)
        ? Object.entries(object.requestHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      allowedCaCerts: globalThis.Array.isArray(object?.allowedCaCerts)
        ? object.allowedCaCerts.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      oauthConfig: isSet(object.oauthConfig)
        ? Webhook_GenericWebService_OAuthConfig.fromJSON(object.oauthConfig)
        : undefined,
      serviceAgentAuth: isSet(object.serviceAgentAuth)
        ? webhook_GenericWebService_ServiceAgentAuthFromJSON(object.serviceAgentAuth)
        : 0,
      webhookType: isSet(object.webhookType) ? webhook_GenericWebService_WebhookTypeFromJSON(object.webhookType) : 0,
      httpMethod: isSet(object.httpMethod) ? webhook_GenericWebService_HttpMethodFromJSON(object.httpMethod) : 0,
      requestBody: isSet(object.requestBody) ? globalThis.String(object.requestBody) : "",
      parameterMapping: isObject(object.parameterMapping)
        ? Object.entries(object.parameterMapping).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Webhook_GenericWebService): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.requestHeaders) {
      const entries = Object.entries(message.requestHeaders);
      if (entries.length > 0) {
        obj.requestHeaders = {};
        entries.forEach(([k, v]) => {
          obj.requestHeaders[k] = v;
        });
      }
    }
    if (message.allowedCaCerts?.length) {
      obj.allowedCaCerts = message.allowedCaCerts.map((e) => base64FromBytes(e));
    }
    if (message.oauthConfig !== undefined) {
      obj.oauthConfig = Webhook_GenericWebService_OAuthConfig.toJSON(message.oauthConfig);
    }
    if (message.serviceAgentAuth !== 0) {
      obj.serviceAgentAuth = webhook_GenericWebService_ServiceAgentAuthToJSON(message.serviceAgentAuth);
    }
    if (message.webhookType !== 0) {
      obj.webhookType = webhook_GenericWebService_WebhookTypeToJSON(message.webhookType);
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = webhook_GenericWebService_HttpMethodToJSON(message.httpMethod);
    }
    if (message.requestBody !== "") {
      obj.requestBody = message.requestBody;
    }
    if (message.parameterMapping) {
      const entries = Object.entries(message.parameterMapping);
      if (entries.length > 0) {
        obj.parameterMapping = {};
        entries.forEach(([k, v]) => {
          obj.parameterMapping[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Webhook_GenericWebService>): Webhook_GenericWebService {
    return Webhook_GenericWebService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Webhook_GenericWebService>): Webhook_GenericWebService {
    const message = createBaseWebhook_GenericWebService();
    message.uri = object.uri ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.requestHeaders = Object.entries(object.requestHeaders ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.allowedCaCerts = object.allowedCaCerts?.map((e) => e) || [];
    message.oauthConfig = (object.oauthConfig !== undefined && object.oauthConfig !== null)
      ? Webhook_GenericWebService_OAuthConfig.fromPartial(object.oauthConfig)
      : undefined;
    message.serviceAgentAuth = object.serviceAgentAuth ?? 0;
    message.webhookType = object.webhookType ?? 0;
    message.httpMethod = object.httpMethod ?? 0;
    message.requestBody = object.requestBody ?? "";
    message.parameterMapping = Object.entries(object.parameterMapping ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseWebhook_GenericWebService_OAuthConfig(): Webhook_GenericWebService_OAuthConfig {
  return { clientId: "", clientSecret: "", tokenEndpoint: "", scopes: [] };
}

export const Webhook_GenericWebService_OAuthConfig: MessageFns<Webhook_GenericWebService_OAuthConfig> = {
  encode(message: Webhook_GenericWebService_OAuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.tokenEndpoint !== "") {
      writer.uint32(26).string(message.tokenEndpoint);
    }
    for (const v of message.scopes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Webhook_GenericWebService_OAuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook_GenericWebService_OAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenEndpoint = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook_GenericWebService_OAuthConfig {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : "",
      tokenEndpoint: isSet(object.tokenEndpoint) ? globalThis.String(object.tokenEndpoint) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Webhook_GenericWebService_OAuthConfig): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.tokenEndpoint !== "") {
      obj.tokenEndpoint = message.tokenEndpoint;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create(base?: DeepPartial<Webhook_GenericWebService_OAuthConfig>): Webhook_GenericWebService_OAuthConfig {
    return Webhook_GenericWebService_OAuthConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Webhook_GenericWebService_OAuthConfig>): Webhook_GenericWebService_OAuthConfig {
    const message = createBaseWebhook_GenericWebService_OAuthConfig();
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.tokenEndpoint = object.tokenEndpoint ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseWebhook_GenericWebService_RequestHeadersEntry(): Webhook_GenericWebService_RequestHeadersEntry {
  return { key: "", value: "" };
}

export const Webhook_GenericWebService_RequestHeadersEntry: MessageFns<Webhook_GenericWebService_RequestHeadersEntry> =
  {
    encode(
      message: Webhook_GenericWebService_RequestHeadersEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Webhook_GenericWebService_RequestHeadersEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseWebhook_GenericWebService_RequestHeadersEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Webhook_GenericWebService_RequestHeadersEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: Webhook_GenericWebService_RequestHeadersEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<Webhook_GenericWebService_RequestHeadersEntry>,
    ): Webhook_GenericWebService_RequestHeadersEntry {
      return Webhook_GenericWebService_RequestHeadersEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Webhook_GenericWebService_RequestHeadersEntry>,
    ): Webhook_GenericWebService_RequestHeadersEntry {
      const message = createBaseWebhook_GenericWebService_RequestHeadersEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseWebhook_GenericWebService_ParameterMappingEntry(): Webhook_GenericWebService_ParameterMappingEntry {
  return { key: "", value: "" };
}

export const Webhook_GenericWebService_ParameterMappingEntry: MessageFns<
  Webhook_GenericWebService_ParameterMappingEntry
> = {
  encode(
    message: Webhook_GenericWebService_ParameterMappingEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Webhook_GenericWebService_ParameterMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook_GenericWebService_ParameterMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook_GenericWebService_ParameterMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Webhook_GenericWebService_ParameterMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Webhook_GenericWebService_ParameterMappingEntry>,
  ): Webhook_GenericWebService_ParameterMappingEntry {
    return Webhook_GenericWebService_ParameterMappingEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Webhook_GenericWebService_ParameterMappingEntry>,
  ): Webhook_GenericWebService_ParameterMappingEntry {
    const message = createBaseWebhook_GenericWebService_ParameterMappingEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWebhook_ServiceDirectoryConfig(): Webhook_ServiceDirectoryConfig {
  return { service: "", genericWebService: undefined };
}

export const Webhook_ServiceDirectoryConfig: MessageFns<Webhook_ServiceDirectoryConfig> = {
  encode(message: Webhook_ServiceDirectoryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.genericWebService !== undefined) {
      Webhook_GenericWebService.encode(message.genericWebService, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Webhook_ServiceDirectoryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhook_ServiceDirectoryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.genericWebService = Webhook_GenericWebService.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Webhook_ServiceDirectoryConfig {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      genericWebService: isSet(object.genericWebService)
        ? Webhook_GenericWebService.fromJSON(object.genericWebService)
        : undefined,
    };
  },

  toJSON(message: Webhook_ServiceDirectoryConfig): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.genericWebService !== undefined) {
      obj.genericWebService = Webhook_GenericWebService.toJSON(message.genericWebService);
    }
    return obj;
  },

  create(base?: DeepPartial<Webhook_ServiceDirectoryConfig>): Webhook_ServiceDirectoryConfig {
    return Webhook_ServiceDirectoryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Webhook_ServiceDirectoryConfig>): Webhook_ServiceDirectoryConfig {
    const message = createBaseWebhook_ServiceDirectoryConfig();
    message.service = object.service ?? "";
    message.genericWebService = (object.genericWebService !== undefined && object.genericWebService !== null)
      ? Webhook_GenericWebService.fromPartial(object.genericWebService)
      : undefined;
    return message;
  },
};

function createBaseListWebhooksRequest(): ListWebhooksRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListWebhooksRequest: MessageFns<ListWebhooksRequest> = {
  encode(message: ListWebhooksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWebhooksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWebhooksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWebhooksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListWebhooksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWebhooksRequest>): ListWebhooksRequest {
    return ListWebhooksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWebhooksRequest>): ListWebhooksRequest {
    const message = createBaseListWebhooksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListWebhooksResponse(): ListWebhooksResponse {
  return { webhooks: [], nextPageToken: "" };
}

export const ListWebhooksResponse: MessageFns<ListWebhooksResponse> = {
  encode(message: ListWebhooksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.webhooks) {
      Webhook.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWebhooksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWebhooksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webhooks.push(Webhook.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWebhooksResponse {
    return {
      webhooks: globalThis.Array.isArray(object?.webhooks) ? object.webhooks.map((e: any) => Webhook.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListWebhooksResponse): unknown {
    const obj: any = {};
    if (message.webhooks?.length) {
      obj.webhooks = message.webhooks.map((e) => Webhook.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWebhooksResponse>): ListWebhooksResponse {
    return ListWebhooksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWebhooksResponse>): ListWebhooksResponse {
    const message = createBaseListWebhooksResponse();
    message.webhooks = object.webhooks?.map((e) => Webhook.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetWebhookRequest(): GetWebhookRequest {
  return { name: "" };
}

export const GetWebhookRequest: MessageFns<GetWebhookRequest> = {
  encode(message: GetWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWebhookRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWebhookRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWebhookRequest>): GetWebhookRequest {
    return GetWebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWebhookRequest>): GetWebhookRequest {
    const message = createBaseGetWebhookRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateWebhookRequest(): CreateWebhookRequest {
  return { parent: "", webhook: undefined };
}

export const CreateWebhookRequest: MessageFns<CreateWebhookRequest> = {
  encode(message: CreateWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.webhook !== undefined) {
      Webhook.encode(message.webhook, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.webhook = Webhook.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWebhookRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      webhook: isSet(object.webhook) ? Webhook.fromJSON(object.webhook) : undefined,
    };
  },

  toJSON(message: CreateWebhookRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.webhook !== undefined) {
      obj.webhook = Webhook.toJSON(message.webhook);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWebhookRequest>): CreateWebhookRequest {
    return CreateWebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWebhookRequest>): CreateWebhookRequest {
    const message = createBaseCreateWebhookRequest();
    message.parent = object.parent ?? "";
    message.webhook = (object.webhook !== undefined && object.webhook !== null)
      ? Webhook.fromPartial(object.webhook)
      : undefined;
    return message;
  },
};

function createBaseUpdateWebhookRequest(): UpdateWebhookRequest {
  return { webhook: undefined, updateMask: undefined };
}

export const UpdateWebhookRequest: MessageFns<UpdateWebhookRequest> = {
  encode(message: UpdateWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.webhook !== undefined) {
      Webhook.encode(message.webhook, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webhook = Webhook.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWebhookRequest {
    return {
      webhook: isSet(object.webhook) ? Webhook.fromJSON(object.webhook) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateWebhookRequest): unknown {
    const obj: any = {};
    if (message.webhook !== undefined) {
      obj.webhook = Webhook.toJSON(message.webhook);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWebhookRequest>): UpdateWebhookRequest {
    return UpdateWebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWebhookRequest>): UpdateWebhookRequest {
    const message = createBaseUpdateWebhookRequest();
    message.webhook = (object.webhook !== undefined && object.webhook !== null)
      ? Webhook.fromPartial(object.webhook)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteWebhookRequest(): DeleteWebhookRequest {
  return { name: "", force: false };
}

export const DeleteWebhookRequest: MessageFns<DeleteWebhookRequest> = {
  encode(message: DeleteWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWebhookRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteWebhookRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWebhookRequest>): DeleteWebhookRequest {
    return DeleteWebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWebhookRequest>): DeleteWebhookRequest {
    const message = createBaseDeleteWebhookRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseWebhookRequest(): WebhookRequest {
  return {
    detectIntentResponseId: "",
    text: undefined,
    triggerIntent: undefined,
    transcript: undefined,
    triggerEvent: undefined,
    dtmfDigits: undefined,
    languageCode: "",
    fulfillmentInfo: undefined,
    intentInfo: undefined,
    pageInfo: undefined,
    sessionInfo: undefined,
    messages: [],
    payload: undefined,
    sentimentAnalysisResult: undefined,
    languageInfo: undefined,
  };
}

export const WebhookRequest: MessageFns<WebhookRequest> = {
  encode(message: WebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.detectIntentResponseId !== "") {
      writer.uint32(10).string(message.detectIntentResponseId);
    }
    if (message.text !== undefined) {
      writer.uint32(82).string(message.text);
    }
    if (message.triggerIntent !== undefined) {
      writer.uint32(90).string(message.triggerIntent);
    }
    if (message.transcript !== undefined) {
      writer.uint32(98).string(message.transcript);
    }
    if (message.triggerEvent !== undefined) {
      writer.uint32(114).string(message.triggerEvent);
    }
    if (message.dtmfDigits !== undefined) {
      writer.uint32(138).string(message.dtmfDigits);
    }
    if (message.languageCode !== "") {
      writer.uint32(122).string(message.languageCode);
    }
    if (message.fulfillmentInfo !== undefined) {
      WebhookRequest_FulfillmentInfo.encode(message.fulfillmentInfo, writer.uint32(50).fork()).join();
    }
    if (message.intentInfo !== undefined) {
      WebhookRequest_IntentInfo.encode(message.intentInfo, writer.uint32(26).fork()).join();
    }
    if (message.pageInfo !== undefined) {
      PageInfo.encode(message.pageInfo, writer.uint32(34).fork()).join();
    }
    if (message.sessionInfo !== undefined) {
      SessionInfo.encode(message.sessionInfo, writer.uint32(42).fork()).join();
    }
    for (const v of message.messages) {
      ResponseMessage.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(66).fork()).join();
    }
    if (message.sentimentAnalysisResult !== undefined) {
      WebhookRequest_SentimentAnalysisResult.encode(message.sentimentAnalysisResult, writer.uint32(74).fork()).join();
    }
    if (message.languageInfo !== undefined) {
      LanguageInfo.encode(message.languageInfo, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.detectIntentResponseId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.text = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.triggerIntent = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transcript = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.triggerEvent = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.dtmfDigits = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fulfillmentInfo = WebhookRequest_FulfillmentInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intentInfo = WebhookRequest_IntentInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageInfo = PageInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sessionInfo = SessionInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.messages.push(ResponseMessage.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sentimentAnalysisResult = WebhookRequest_SentimentAnalysisResult.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.languageInfo = LanguageInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest {
    return {
      detectIntentResponseId: isSet(object.detectIntentResponseId)
        ? globalThis.String(object.detectIntentResponseId)
        : "",
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      triggerIntent: isSet(object.triggerIntent) ? globalThis.String(object.triggerIntent) : undefined,
      transcript: isSet(object.transcript) ? globalThis.String(object.transcript) : undefined,
      triggerEvent: isSet(object.triggerEvent) ? globalThis.String(object.triggerEvent) : undefined,
      dtmfDigits: isSet(object.dtmfDigits) ? globalThis.String(object.dtmfDigits) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      fulfillmentInfo: isSet(object.fulfillmentInfo)
        ? WebhookRequest_FulfillmentInfo.fromJSON(object.fulfillmentInfo)
        : undefined,
      intentInfo: isSet(object.intentInfo) ? WebhookRequest_IntentInfo.fromJSON(object.intentInfo) : undefined,
      pageInfo: isSet(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : undefined,
      sessionInfo: isSet(object.sessionInfo) ? SessionInfo.fromJSON(object.sessionInfo) : undefined,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ResponseMessage.fromJSON(e))
        : [],
      payload: isObject(object.payload) ? object.payload : undefined,
      sentimentAnalysisResult: isSet(object.sentimentAnalysisResult)
        ? WebhookRequest_SentimentAnalysisResult.fromJSON(object.sentimentAnalysisResult)
        : undefined,
      languageInfo: isSet(object.languageInfo) ? LanguageInfo.fromJSON(object.languageInfo) : undefined,
    };
  },

  toJSON(message: WebhookRequest): unknown {
    const obj: any = {};
    if (message.detectIntentResponseId !== "") {
      obj.detectIntentResponseId = message.detectIntentResponseId;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.triggerIntent !== undefined) {
      obj.triggerIntent = message.triggerIntent;
    }
    if (message.transcript !== undefined) {
      obj.transcript = message.transcript;
    }
    if (message.triggerEvent !== undefined) {
      obj.triggerEvent = message.triggerEvent;
    }
    if (message.dtmfDigits !== undefined) {
      obj.dtmfDigits = message.dtmfDigits;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.fulfillmentInfo !== undefined) {
      obj.fulfillmentInfo = WebhookRequest_FulfillmentInfo.toJSON(message.fulfillmentInfo);
    }
    if (message.intentInfo !== undefined) {
      obj.intentInfo = WebhookRequest_IntentInfo.toJSON(message.intentInfo);
    }
    if (message.pageInfo !== undefined) {
      obj.pageInfo = PageInfo.toJSON(message.pageInfo);
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = SessionInfo.toJSON(message.sessionInfo);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ResponseMessage.toJSON(e));
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.sentimentAnalysisResult !== undefined) {
      obj.sentimentAnalysisResult = WebhookRequest_SentimentAnalysisResult.toJSON(message.sentimentAnalysisResult);
    }
    if (message.languageInfo !== undefined) {
      obj.languageInfo = LanguageInfo.toJSON(message.languageInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest>): WebhookRequest {
    return WebhookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookRequest>): WebhookRequest {
    const message = createBaseWebhookRequest();
    message.detectIntentResponseId = object.detectIntentResponseId ?? "";
    message.text = object.text ?? undefined;
    message.triggerIntent = object.triggerIntent ?? undefined;
    message.transcript = object.transcript ?? undefined;
    message.triggerEvent = object.triggerEvent ?? undefined;
    message.dtmfDigits = object.dtmfDigits ?? undefined;
    message.languageCode = object.languageCode ?? "";
    message.fulfillmentInfo = (object.fulfillmentInfo !== undefined && object.fulfillmentInfo !== null)
      ? WebhookRequest_FulfillmentInfo.fromPartial(object.fulfillmentInfo)
      : undefined;
    message.intentInfo = (object.intentInfo !== undefined && object.intentInfo !== null)
      ? WebhookRequest_IntentInfo.fromPartial(object.intentInfo)
      : undefined;
    message.pageInfo = (object.pageInfo !== undefined && object.pageInfo !== null)
      ? PageInfo.fromPartial(object.pageInfo)
      : undefined;
    message.sessionInfo = (object.sessionInfo !== undefined && object.sessionInfo !== null)
      ? SessionInfo.fromPartial(object.sessionInfo)
      : undefined;
    message.messages = object.messages?.map((e) => ResponseMessage.fromPartial(e)) || [];
    message.payload = object.payload ?? undefined;
    message.sentimentAnalysisResult =
      (object.sentimentAnalysisResult !== undefined && object.sentimentAnalysisResult !== null)
        ? WebhookRequest_SentimentAnalysisResult.fromPartial(object.sentimentAnalysisResult)
        : undefined;
    message.languageInfo = (object.languageInfo !== undefined && object.languageInfo !== null)
      ? LanguageInfo.fromPartial(object.languageInfo)
      : undefined;
    return message;
  },
};

function createBaseWebhookRequest_FulfillmentInfo(): WebhookRequest_FulfillmentInfo {
  return { tag: "" };
}

export const WebhookRequest_FulfillmentInfo: MessageFns<WebhookRequest_FulfillmentInfo> = {
  encode(message: WebhookRequest_FulfillmentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== "") {
      writer.uint32(10).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest_FulfillmentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest_FulfillmentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest_FulfillmentInfo {
    return { tag: isSet(object.tag) ? globalThis.String(object.tag) : "" };
  },

  toJSON(message: WebhookRequest_FulfillmentInfo): unknown {
    const obj: any = {};
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest_FulfillmentInfo>): WebhookRequest_FulfillmentInfo {
    return WebhookRequest_FulfillmentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookRequest_FulfillmentInfo>): WebhookRequest_FulfillmentInfo {
    const message = createBaseWebhookRequest_FulfillmentInfo();
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseWebhookRequest_IntentInfo(): WebhookRequest_IntentInfo {
  return { lastMatchedIntent: "", displayName: "", parameters: {}, confidence: 0 };
}

export const WebhookRequest_IntentInfo: MessageFns<WebhookRequest_IntentInfo> = {
  encode(message: WebhookRequest_IntentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastMatchedIntent !== "") {
      writer.uint32(10).string(message.lastMatchedIntent);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      WebhookRequest_IntentInfo_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest_IntentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest_IntentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastMatchedIntent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = WebhookRequest_IntentInfo_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest_IntentInfo {
    return {
      lastMatchedIntent: isSet(object.lastMatchedIntent) ? globalThis.String(object.lastMatchedIntent) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: WebhookRequest_IntentInfo_IntentParameterValue }>(
          (acc, [key, value]) => {
            acc[key] = WebhookRequest_IntentInfo_IntentParameterValue.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: WebhookRequest_IntentInfo): unknown {
    const obj: any = {};
    if (message.lastMatchedIntent !== "") {
      obj.lastMatchedIntent = message.lastMatchedIntent;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = WebhookRequest_IntentInfo_IntentParameterValue.toJSON(v);
        });
      }
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest_IntentInfo>): WebhookRequest_IntentInfo {
    return WebhookRequest_IntentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookRequest_IntentInfo>): WebhookRequest_IntentInfo {
    const message = createBaseWebhookRequest_IntentInfo();
    message.lastMatchedIntent = object.lastMatchedIntent ?? "";
    message.displayName = object.displayName ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<
      { [key: string]: WebhookRequest_IntentInfo_IntentParameterValue }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = WebhookRequest_IntentInfo_IntentParameterValue.fromPartial(value);
      }
      return acc;
    }, {});
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseWebhookRequest_IntentInfo_IntentParameterValue(): WebhookRequest_IntentInfo_IntentParameterValue {
  return { originalValue: "", resolvedValue: undefined };
}

export const WebhookRequest_IntentInfo_IntentParameterValue: MessageFns<
  WebhookRequest_IntentInfo_IntentParameterValue
> = {
  encode(
    message: WebhookRequest_IntentInfo_IntentParameterValue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.originalValue !== "") {
      writer.uint32(10).string(message.originalValue);
    }
    if (message.resolvedValue !== undefined) {
      Value.encode(Value.wrap(message.resolvedValue), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest_IntentInfo_IntentParameterValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest_IntentInfo_IntentParameterValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalValue = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolvedValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest_IntentInfo_IntentParameterValue {
    return {
      originalValue: isSet(object.originalValue) ? globalThis.String(object.originalValue) : "",
      resolvedValue: isSet(object?.resolvedValue) ? object.resolvedValue : undefined,
    };
  },

  toJSON(message: WebhookRequest_IntentInfo_IntentParameterValue): unknown {
    const obj: any = {};
    if (message.originalValue !== "") {
      obj.originalValue = message.originalValue;
    }
    if (message.resolvedValue !== undefined) {
      obj.resolvedValue = message.resolvedValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<WebhookRequest_IntentInfo_IntentParameterValue>,
  ): WebhookRequest_IntentInfo_IntentParameterValue {
    return WebhookRequest_IntentInfo_IntentParameterValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WebhookRequest_IntentInfo_IntentParameterValue>,
  ): WebhookRequest_IntentInfo_IntentParameterValue {
    const message = createBaseWebhookRequest_IntentInfo_IntentParameterValue();
    message.originalValue = object.originalValue ?? "";
    message.resolvedValue = object.resolvedValue ?? undefined;
    return message;
  },
};

function createBaseWebhookRequest_IntentInfo_ParametersEntry(): WebhookRequest_IntentInfo_ParametersEntry {
  return { key: "", value: undefined };
}

export const WebhookRequest_IntentInfo_ParametersEntry: MessageFns<WebhookRequest_IntentInfo_ParametersEntry> = {
  encode(message: WebhookRequest_IntentInfo_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      WebhookRequest_IntentInfo_IntentParameterValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest_IntentInfo_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest_IntentInfo_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = WebhookRequest_IntentInfo_IntentParameterValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest_IntentInfo_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? WebhookRequest_IntentInfo_IntentParameterValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: WebhookRequest_IntentInfo_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = WebhookRequest_IntentInfo_IntentParameterValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest_IntentInfo_ParametersEntry>): WebhookRequest_IntentInfo_ParametersEntry {
    return WebhookRequest_IntentInfo_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WebhookRequest_IntentInfo_ParametersEntry>,
  ): WebhookRequest_IntentInfo_ParametersEntry {
    const message = createBaseWebhookRequest_IntentInfo_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? WebhookRequest_IntentInfo_IntentParameterValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseWebhookRequest_SentimentAnalysisResult(): WebhookRequest_SentimentAnalysisResult {
  return { score: 0, magnitude: 0 };
}

export const WebhookRequest_SentimentAnalysisResult: MessageFns<WebhookRequest_SentimentAnalysisResult> = {
  encode(message: WebhookRequest_SentimentAnalysisResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== 0) {
      writer.uint32(13).float(message.score);
    }
    if (message.magnitude !== 0) {
      writer.uint32(21).float(message.magnitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookRequest_SentimentAnalysisResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookRequest_SentimentAnalysisResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.magnitude = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookRequest_SentimentAnalysisResult {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      magnitude: isSet(object.magnitude) ? globalThis.Number(object.magnitude) : 0,
    };
  },

  toJSON(message: WebhookRequest_SentimentAnalysisResult): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.magnitude !== 0) {
      obj.magnitude = message.magnitude;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookRequest_SentimentAnalysisResult>): WebhookRequest_SentimentAnalysisResult {
    return WebhookRequest_SentimentAnalysisResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookRequest_SentimentAnalysisResult>): WebhookRequest_SentimentAnalysisResult {
    const message = createBaseWebhookRequest_SentimentAnalysisResult();
    message.score = object.score ?? 0;
    message.magnitude = object.magnitude ?? 0;
    return message;
  },
};

function createBaseWebhookResponse(): WebhookResponse {
  return {
    fulfillmentResponse: undefined,
    pageInfo: undefined,
    sessionInfo: undefined,
    payload: undefined,
    targetPage: undefined,
    targetFlow: undefined,
  };
}

export const WebhookResponse: MessageFns<WebhookResponse> = {
  encode(message: WebhookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fulfillmentResponse !== undefined) {
      WebhookResponse_FulfillmentResponse.encode(message.fulfillmentResponse, writer.uint32(10).fork()).join();
    }
    if (message.pageInfo !== undefined) {
      PageInfo.encode(message.pageInfo, writer.uint32(18).fork()).join();
    }
    if (message.sessionInfo !== undefined) {
      SessionInfo.encode(message.sessionInfo, writer.uint32(26).fork()).join();
    }
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(34).fork()).join();
    }
    if (message.targetPage !== undefined) {
      writer.uint32(42).string(message.targetPage);
    }
    if (message.targetFlow !== undefined) {
      writer.uint32(50).string(message.targetFlow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fulfillmentResponse = WebhookResponse_FulfillmentResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageInfo = PageInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionInfo = SessionInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetPage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetFlow = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookResponse {
    return {
      fulfillmentResponse: isSet(object.fulfillmentResponse)
        ? WebhookResponse_FulfillmentResponse.fromJSON(object.fulfillmentResponse)
        : undefined,
      pageInfo: isSet(object.pageInfo) ? PageInfo.fromJSON(object.pageInfo) : undefined,
      sessionInfo: isSet(object.sessionInfo) ? SessionInfo.fromJSON(object.sessionInfo) : undefined,
      payload: isObject(object.payload) ? object.payload : undefined,
      targetPage: isSet(object.targetPage) ? globalThis.String(object.targetPage) : undefined,
      targetFlow: isSet(object.targetFlow) ? globalThis.String(object.targetFlow) : undefined,
    };
  },

  toJSON(message: WebhookResponse): unknown {
    const obj: any = {};
    if (message.fulfillmentResponse !== undefined) {
      obj.fulfillmentResponse = WebhookResponse_FulfillmentResponse.toJSON(message.fulfillmentResponse);
    }
    if (message.pageInfo !== undefined) {
      obj.pageInfo = PageInfo.toJSON(message.pageInfo);
    }
    if (message.sessionInfo !== undefined) {
      obj.sessionInfo = SessionInfo.toJSON(message.sessionInfo);
    }
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.targetPage !== undefined) {
      obj.targetPage = message.targetPage;
    }
    if (message.targetFlow !== undefined) {
      obj.targetFlow = message.targetFlow;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookResponse>): WebhookResponse {
    return WebhookResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookResponse>): WebhookResponse {
    const message = createBaseWebhookResponse();
    message.fulfillmentResponse = (object.fulfillmentResponse !== undefined && object.fulfillmentResponse !== null)
      ? WebhookResponse_FulfillmentResponse.fromPartial(object.fulfillmentResponse)
      : undefined;
    message.pageInfo = (object.pageInfo !== undefined && object.pageInfo !== null)
      ? PageInfo.fromPartial(object.pageInfo)
      : undefined;
    message.sessionInfo = (object.sessionInfo !== undefined && object.sessionInfo !== null)
      ? SessionInfo.fromPartial(object.sessionInfo)
      : undefined;
    message.payload = object.payload ?? undefined;
    message.targetPage = object.targetPage ?? undefined;
    message.targetFlow = object.targetFlow ?? undefined;
    return message;
  },
};

function createBaseWebhookResponse_FulfillmentResponse(): WebhookResponse_FulfillmentResponse {
  return { messages: [], mergeBehavior: 0 };
}

export const WebhookResponse_FulfillmentResponse: MessageFns<WebhookResponse_FulfillmentResponse> = {
  encode(message: WebhookResponse_FulfillmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      ResponseMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.mergeBehavior !== 0) {
      writer.uint32(16).int32(message.mergeBehavior);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookResponse_FulfillmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookResponse_FulfillmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(ResponseMessage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mergeBehavior = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookResponse_FulfillmentResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => ResponseMessage.fromJSON(e))
        : [],
      mergeBehavior: isSet(object.mergeBehavior)
        ? webhookResponse_FulfillmentResponse_MergeBehaviorFromJSON(object.mergeBehavior)
        : 0,
    };
  },

  toJSON(message: WebhookResponse_FulfillmentResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => ResponseMessage.toJSON(e));
    }
    if (message.mergeBehavior !== 0) {
      obj.mergeBehavior = webhookResponse_FulfillmentResponse_MergeBehaviorToJSON(message.mergeBehavior);
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookResponse_FulfillmentResponse>): WebhookResponse_FulfillmentResponse {
    return WebhookResponse_FulfillmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookResponse_FulfillmentResponse>): WebhookResponse_FulfillmentResponse {
    const message = createBaseWebhookResponse_FulfillmentResponse();
    message.messages = object.messages?.map((e) => ResponseMessage.fromPartial(e)) || [];
    message.mergeBehavior = object.mergeBehavior ?? 0;
    return message;
  },
};

function createBasePageInfo(): PageInfo {
  return { currentPage: "", displayName: "", formInfo: undefined };
}

export const PageInfo: MessageFns<PageInfo> = {
  encode(message: PageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentPage !== "") {
      writer.uint32(10).string(message.currentPage);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.formInfo !== undefined) {
      PageInfo_FormInfo.encode(message.formInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentPage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.formInfo = PageInfo_FormInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageInfo {
    return {
      currentPage: isSet(object.currentPage) ? globalThis.String(object.currentPage) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      formInfo: isSet(object.formInfo) ? PageInfo_FormInfo.fromJSON(object.formInfo) : undefined,
    };
  },

  toJSON(message: PageInfo): unknown {
    const obj: any = {};
    if (message.currentPage !== "") {
      obj.currentPage = message.currentPage;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.formInfo !== undefined) {
      obj.formInfo = PageInfo_FormInfo.toJSON(message.formInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<PageInfo>): PageInfo {
    return PageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageInfo>): PageInfo {
    const message = createBasePageInfo();
    message.currentPage = object.currentPage ?? "";
    message.displayName = object.displayName ?? "";
    message.formInfo = (object.formInfo !== undefined && object.formInfo !== null)
      ? PageInfo_FormInfo.fromPartial(object.formInfo)
      : undefined;
    return message;
  },
};

function createBasePageInfo_FormInfo(): PageInfo_FormInfo {
  return { parameterInfo: [] };
}

export const PageInfo_FormInfo: MessageFns<PageInfo_FormInfo> = {
  encode(message: PageInfo_FormInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameterInfo) {
      PageInfo_FormInfo_ParameterInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageInfo_FormInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageInfo_FormInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameterInfo.push(PageInfo_FormInfo_ParameterInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageInfo_FormInfo {
    return {
      parameterInfo: globalThis.Array.isArray(object?.parameterInfo)
        ? object.parameterInfo.map((e: any) => PageInfo_FormInfo_ParameterInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PageInfo_FormInfo): unknown {
    const obj: any = {};
    if (message.parameterInfo?.length) {
      obj.parameterInfo = message.parameterInfo.map((e) => PageInfo_FormInfo_ParameterInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PageInfo_FormInfo>): PageInfo_FormInfo {
    return PageInfo_FormInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageInfo_FormInfo>): PageInfo_FormInfo {
    const message = createBasePageInfo_FormInfo();
    message.parameterInfo = object.parameterInfo?.map((e) => PageInfo_FormInfo_ParameterInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBasePageInfo_FormInfo_ParameterInfo(): PageInfo_FormInfo_ParameterInfo {
  return { displayName: "", required: false, state: 0, value: undefined, justCollected: false };
}

export const PageInfo_FormInfo_ParameterInfo: MessageFns<PageInfo_FormInfo_ParameterInfo> = {
  encode(message: PageInfo_FormInfo_ParameterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.required !== false) {
      writer.uint32(16).bool(message.required);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(34).fork()).join();
    }
    if (message.justCollected !== false) {
      writer.uint32(40).bool(message.justCollected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageInfo_FormInfo_ParameterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageInfo_FormInfo_ParameterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.justCollected = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageInfo_FormInfo_ParameterInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      state: isSet(object.state) ? pageInfo_FormInfo_ParameterInfo_ParameterStateFromJSON(object.state) : 0,
      value: isSet(object?.value) ? object.value : undefined,
      justCollected: isSet(object.justCollected) ? globalThis.Boolean(object.justCollected) : false,
    };
  },

  toJSON(message: PageInfo_FormInfo_ParameterInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.state !== 0) {
      obj.state = pageInfo_FormInfo_ParameterInfo_ParameterStateToJSON(message.state);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.justCollected !== false) {
      obj.justCollected = message.justCollected;
    }
    return obj;
  },

  create(base?: DeepPartial<PageInfo_FormInfo_ParameterInfo>): PageInfo_FormInfo_ParameterInfo {
    return PageInfo_FormInfo_ParameterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PageInfo_FormInfo_ParameterInfo>): PageInfo_FormInfo_ParameterInfo {
    const message = createBasePageInfo_FormInfo_ParameterInfo();
    message.displayName = object.displayName ?? "";
    message.required = object.required ?? false;
    message.state = object.state ?? 0;
    message.value = object.value ?? undefined;
    message.justCollected = object.justCollected ?? false;
    return message;
  },
};

function createBaseSessionInfo(): SessionInfo {
  return { session: "", parameters: {} };
}

export const SessionInfo: MessageFns<SessionInfo> = {
  encode(message: SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== "") {
      writer.uint32(10).string(message.session);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      if (value !== undefined) {
        SessionInfo_ParametersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.session = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SessionInfo_ParametersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.parameters[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo {
    return {
      session: isSet(object.session) ? globalThis.String(object.session) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SessionInfo): unknown {
    const obj: any = {};
    if (message.session !== "") {
      obj.session = message.session;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SessionInfo>): SessionInfo {
    return SessionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionInfo>): SessionInfo {
    const message = createBaseSessionInfo();
    message.session = object.session ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSessionInfo_ParametersEntry(): SessionInfo_ParametersEntry {
  return { key: "", value: undefined };
}

export const SessionInfo_ParametersEntry: MessageFns<SessionInfo_ParametersEntry> = {
  encode(message: SessionInfo_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SessionInfo_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SessionInfo_ParametersEntry>): SessionInfo_ParametersEntry {
    return SessionInfo_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionInfo_ParametersEntry>): SessionInfo_ParametersEntry {
    const message = createBaseSessionInfo_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseLanguageInfo(): LanguageInfo {
  return { inputLanguageCode: "", resolvedLanguageCode: "", confidenceScore: 0 };
}

export const LanguageInfo: MessageFns<LanguageInfo> = {
  encode(message: LanguageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputLanguageCode !== "") {
      writer.uint32(10).string(message.inputLanguageCode);
    }
    if (message.resolvedLanguageCode !== "") {
      writer.uint32(18).string(message.resolvedLanguageCode);
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(29).float(message.confidenceScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LanguageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputLanguageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolvedLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidenceScore = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LanguageInfo {
    return {
      inputLanguageCode: isSet(object.inputLanguageCode) ? globalThis.String(object.inputLanguageCode) : "",
      resolvedLanguageCode: isSet(object.resolvedLanguageCode) ? globalThis.String(object.resolvedLanguageCode) : "",
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
    };
  },

  toJSON(message: LanguageInfo): unknown {
    const obj: any = {};
    if (message.inputLanguageCode !== "") {
      obj.inputLanguageCode = message.inputLanguageCode;
    }
    if (message.resolvedLanguageCode !== "") {
      obj.resolvedLanguageCode = message.resolvedLanguageCode;
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    return obj;
  },

  create(base?: DeepPartial<LanguageInfo>): LanguageInfo {
    return LanguageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LanguageInfo>): LanguageInfo {
    const message = createBaseLanguageInfo();
    message.inputLanguageCode = object.inputLanguageCode ?? "";
    message.resolvedLanguageCode = object.resolvedLanguageCode ?? "";
    message.confidenceScore = object.confidenceScore ?? 0;
    return message;
  },
};

/** Service for managing [Webhooks][google.cloud.dialogflow.cx.v3beta1.Webhook]. */
export type WebhooksDefinition = typeof WebhooksDefinition;
export const WebhooksDefinition = {
  name: "Webhooks",
  fullName: "google.cloud.dialogflow.cx.v3beta1.Webhooks",
  methods: {
    /** Returns the list of all webhooks in the specified agent. */
    listWebhooks: {
      name: "ListWebhooks",
      requestType: ListWebhooksRequest,
      requestStream: false,
      responseType: ListWebhooksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the specified webhook. */
    getWebhook: {
      name: "GetWebhook",
      requestType: GetWebhookRequest,
      requestStream: false,
      responseType: Webhook,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a webhook in the specified agent. */
    createWebhook: {
      name: "CreateWebhook",
      requestType: CreateWebhookRequest,
      requestStream: false,
      responseType: Webhook,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 112, 97, 114, 101, 110, 116, 44, 119, 101, 98, 104, 111, 111, 107])],
          578365826: [
            Buffer.from([
              69,
              58,
              7,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              34,
              58,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the specified webhook. */
    updateWebhook: {
      name: "UpdateWebhook",
      requestType: UpdateWebhookRequest,
      requestStream: false,
      responseType: Webhook,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([19, 119, 101, 98, 104, 111, 111, 107, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              77,
              58,
              7,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              50,
              66,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified webhook. */
    deleteWebhook: {
      name: "DeleteWebhook",
      requestType: DeleteWebhookRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              119,
              101,
              98,
              104,
              111,
              111,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface WebhooksServiceImplementation<CallContextExt = {}> {
  /** Returns the list of all webhooks in the specified agent. */
  listWebhooks(
    request: ListWebhooksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWebhooksResponse>>;
  /** Retrieves the specified webhook. */
  getWebhook(request: GetWebhookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Webhook>>;
  /** Creates a webhook in the specified agent. */
  createWebhook(request: CreateWebhookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Webhook>>;
  /** Updates the specified webhook. */
  updateWebhook(request: UpdateWebhookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Webhook>>;
  /** Deletes the specified webhook. */
  deleteWebhook(request: DeleteWebhookRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface WebhooksClient<CallOptionsExt = {}> {
  /** Returns the list of all webhooks in the specified agent. */
  listWebhooks(
    request: DeepPartial<ListWebhooksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWebhooksResponse>;
  /** Retrieves the specified webhook. */
  getWebhook(request: DeepPartial<GetWebhookRequest>, options?: CallOptions & CallOptionsExt): Promise<Webhook>;
  /** Creates a webhook in the specified agent. */
  createWebhook(request: DeepPartial<CreateWebhookRequest>, options?: CallOptions & CallOptionsExt): Promise<Webhook>;
  /** Updates the specified webhook. */
  updateWebhook(request: DeepPartial<UpdateWebhookRequest>, options?: CallOptions & CallOptionsExt): Promise<Webhook>;
  /** Deletes the specified webhook. */
  deleteWebhook(request: DeepPartial<DeleteWebhookRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
