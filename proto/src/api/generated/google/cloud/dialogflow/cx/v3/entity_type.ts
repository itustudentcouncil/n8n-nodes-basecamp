// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dialogflow/cx/v3/entity_type.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { InlineDestination, InlineSource } from "./inline.js";

export const protobufPackage = "google.cloud.dialogflow.cx.v3";

/**
 * Entities are extracted from user input and represent parameters that are
 * meaningful to your application. For example, a date range, a proper name
 * such as a geographic location or landmark, and so on. Entities represent
 * actionable data for your application.
 *
 * When you define an entity, you can also include synonyms that all map to
 * that entity. For example, "soft drink", "soda", "pop", and so on.
 *
 * There are three types of entities:
 *
 * *   **System** - entities that are defined by the Dialogflow API for common
 *     data types such as date, time, currency, and so on. A system entity is
 *     represented by the `EntityType` type.
 *
 * *   **Custom** - entities that are defined by you that represent
 *     actionable data that is meaningful to your application. For example,
 *     you could define a `pizza.sauce` entity for red or white pizza sauce,
 *     a `pizza.cheese` entity for the different types of cheese on a pizza,
 *     a `pizza.topping` entity for different toppings, and so on. A custom
 *     entity is represented by the `EntityType` type.
 *
 * *   **User** - entities that are built for an individual user such as
 *     favorites, preferences, playlists, and so on. A user entity is
 *     represented by the
 *     [SessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityType]
 *     type.
 *
 * For more information about entity types, see the [Dialogflow
 * documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
 */
export interface EntityType {
  /**
   * The unique identifier of the entity type.
   * Required for
   * [EntityTypes.UpdateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType].
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<Entity Type ID>`.
   */
  name: string;
  /**
   * Required. The human-readable name of the entity type, unique within the
   * agent.
   */
  displayName: string;
  /** Required. Indicates the kind of entity type. */
  kind: EntityType_Kind;
  /** Indicates whether the entity type can be automatically expanded. */
  autoExpansionMode: EntityType_AutoExpansionMode;
  /** The collection of entity entries associated with the entity type. */
  entities: EntityType_Entity[];
  /**
   * Collection of exceptional words and phrases that shouldn't be matched.
   * For example, if you have a size entity type with entry `giant`(an
   * adjective), you might consider adding `giants`(a noun) as an exclusion.
   * If the kind of entity type is `KIND_MAP`, then the phrases specified by
   * entities and excluded phrases should be mutually exclusive.
   */
  excludedPhrases: EntityType_ExcludedPhrase[];
  /** Enables fuzzy entity extraction during classification. */
  enableFuzzyExtraction: boolean;
  /**
   * Indicates whether parameters of the entity type should be redacted in log.
   * If redaction is enabled, page parameters and intent parameters referring to
   * the entity type will be replaced by parameter name when logging.
   */
  redact: boolean;
}

/** Represents kinds of entities. */
export enum EntityType_Kind {
  /** KIND_UNSPECIFIED - Not specified. This value should be never used. */
  KIND_UNSPECIFIED = 0,
  /**
   * KIND_MAP - Map entity types allow mapping of a group of synonyms to a canonical
   * value.
   */
  KIND_MAP = 1,
  /**
   * KIND_LIST - List entity types contain a set of entries that do not map to canonical
   * values. However, list entity types can contain references to other entity
   * types (with or without aliases).
   */
  KIND_LIST = 2,
  /**
   * KIND_REGEXP - Regexp entity types allow to specify regular expressions in entries
   * values.
   */
  KIND_REGEXP = 3,
  UNRECOGNIZED = -1,
}

export function entityType_KindFromJSON(object: any): EntityType_Kind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return EntityType_Kind.KIND_UNSPECIFIED;
    case 1:
    case "KIND_MAP":
      return EntityType_Kind.KIND_MAP;
    case 2:
    case "KIND_LIST":
      return EntityType_Kind.KIND_LIST;
    case 3:
    case "KIND_REGEXP":
      return EntityType_Kind.KIND_REGEXP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityType_Kind.UNRECOGNIZED;
  }
}

export function entityType_KindToJSON(object: EntityType_Kind): string {
  switch (object) {
    case EntityType_Kind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case EntityType_Kind.KIND_MAP:
      return "KIND_MAP";
    case EntityType_Kind.KIND_LIST:
      return "KIND_LIST";
    case EntityType_Kind.KIND_REGEXP:
      return "KIND_REGEXP";
    case EntityType_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents different entity type expansion modes. Automated expansion
 * allows an agent to recognize values that have not been explicitly listed in
 * the entity (for example, new kinds of shopping list items).
 */
export enum EntityType_AutoExpansionMode {
  /** AUTO_EXPANSION_MODE_UNSPECIFIED - Auto expansion disabled for the entity. */
  AUTO_EXPANSION_MODE_UNSPECIFIED = 0,
  /**
   * AUTO_EXPANSION_MODE_DEFAULT - Allows an agent to recognize values that have not been explicitly
   * listed in the entity.
   */
  AUTO_EXPANSION_MODE_DEFAULT = 1,
  UNRECOGNIZED = -1,
}

export function entityType_AutoExpansionModeFromJSON(object: any): EntityType_AutoExpansionMode {
  switch (object) {
    case 0:
    case "AUTO_EXPANSION_MODE_UNSPECIFIED":
      return EntityType_AutoExpansionMode.AUTO_EXPANSION_MODE_UNSPECIFIED;
    case 1:
    case "AUTO_EXPANSION_MODE_DEFAULT":
      return EntityType_AutoExpansionMode.AUTO_EXPANSION_MODE_DEFAULT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityType_AutoExpansionMode.UNRECOGNIZED;
  }
}

export function entityType_AutoExpansionModeToJSON(object: EntityType_AutoExpansionMode): string {
  switch (object) {
    case EntityType_AutoExpansionMode.AUTO_EXPANSION_MODE_UNSPECIFIED:
      return "AUTO_EXPANSION_MODE_UNSPECIFIED";
    case EntityType_AutoExpansionMode.AUTO_EXPANSION_MODE_DEFAULT:
      return "AUTO_EXPANSION_MODE_DEFAULT";
    case EntityType_AutoExpansionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An **entity entry** for an associated entity type. */
export interface EntityType_Entity {
  /**
   * Required. The primary value associated with this entity entry.
   * For example, if the entity type is *vegetable*, the value could be
   * *scallions*.
   *
   * For `KIND_MAP` entity types:
   *
   * *   A canonical value to be used in place of synonyms.
   *
   * For `KIND_LIST` entity types:
   *
   * *   A string that can contain references to other entity types (with or
   *     without aliases).
   */
  value: string;
  /**
   * Required. A collection of value synonyms. For example, if the entity type
   * is *vegetable*, and `value` is *scallions*, a synonym could be *green
   * onions*.
   *
   * For `KIND_LIST` entity types:
   *
   * *   This collection must contain exactly one synonym equal to `value`.
   */
  synonyms: string[];
}

/** An excluded entity phrase that should not be matched. */
export interface EntityType_ExcludedPhrase {
  /** Required. The word or phrase to be excluded. */
  value: string;
}

/**
 * The request message for
 * [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes].
 */
export interface ExportEntityTypesRequest {
  /**
   * Required. The name of the parent agent to export entity types.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>`.
   */
  parent: string;
  /**
   * Required. The name of the entity types to export.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<EntityType ID>`.
   */
  entityTypes: string[];
  /**
   * Optional. The [Google Cloud
   * Storage](https://cloud.google.com/storage/docs/) URI to export the entity
   * types to. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`.
   *
   * Dialogflow performs a write operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have write permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  entityTypesUri?:
    | string
    | undefined;
  /** Optional. The option to return the serialized entity types inline. */
  entityTypesContentInline?:
    | boolean
    | undefined;
  /**
   * Optional. The data format of the exported entity types. If not specified,
   * `BLOB` is assumed.
   */
  dataFormat: ExportEntityTypesRequest_DataFormat;
  /**
   * Optional. The language to retrieve the entity type for. The following
   * fields are language dependent:
   *
   * *   `EntityType.entities.value`
   * *   `EntityType.entities.synonyms`
   * *   `EntityType.excluded_phrases.value`
   *
   * If not specified, all language dependent fields will be retrieved.
   * [Many
   * languages](https://cloud.google.com/dialogflow/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/** Data format of the exported entity types. */
export enum ExportEntityTypesRequest_DataFormat {
  /** DATA_FORMAT_UNSPECIFIED - Unspecified format. Treated as `BLOB`. */
  DATA_FORMAT_UNSPECIFIED = 0,
  /** BLOB - EntityTypes will be exported as raw bytes. */
  BLOB = 1,
  /** JSON_PACKAGE - EntityTypes will be exported in JSON Package format. */
  JSON_PACKAGE = 5,
  UNRECOGNIZED = -1,
}

export function exportEntityTypesRequest_DataFormatFromJSON(object: any): ExportEntityTypesRequest_DataFormat {
  switch (object) {
    case 0:
    case "DATA_FORMAT_UNSPECIFIED":
      return ExportEntityTypesRequest_DataFormat.DATA_FORMAT_UNSPECIFIED;
    case 1:
    case "BLOB":
      return ExportEntityTypesRequest_DataFormat.BLOB;
    case 5:
    case "JSON_PACKAGE":
      return ExportEntityTypesRequest_DataFormat.JSON_PACKAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportEntityTypesRequest_DataFormat.UNRECOGNIZED;
  }
}

export function exportEntityTypesRequest_DataFormatToJSON(object: ExportEntityTypesRequest_DataFormat): string {
  switch (object) {
    case ExportEntityTypesRequest_DataFormat.DATA_FORMAT_UNSPECIFIED:
      return "DATA_FORMAT_UNSPECIFIED";
    case ExportEntityTypesRequest_DataFormat.BLOB:
      return "BLOB";
    case ExportEntityTypesRequest_DataFormat.JSON_PACKAGE:
      return "JSON_PACKAGE";
    case ExportEntityTypesRequest_DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes].
 */
export interface ExportEntityTypesResponse {
  /**
   * The URI to a file containing the exported entity types. This field is
   * populated only if `entity_types_uri` is specified in
   * [ExportEntityTypesRequest][google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest].
   */
  entityTypesUri?:
    | string
    | undefined;
  /**
   * Uncompressed byte content for entity types. This field is populated only
   * if `entity_types_content_inline` is set to true in
   * [ExportEntityTypesRequest][google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest].
   */
  entityTypesContent?: InlineDestination | undefined;
}

/**
 * Metadata returned for the
 * [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes]
 * long running operation.
 */
export interface ExportEntityTypesMetadata {
}

/**
 * The request message for
 * [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes].
 */
export interface ImportEntityTypesRequest {
  /**
   * Required. The agent to import the entity types into.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
   * to import entity types from. The format of this URI must be
   * `gs://<bucket-name>/<object-name>`.
   *
   * Dialogflow performs a read operation for the Cloud Storage object
   * on the caller's behalf, so your request authentication must
   * have read permissions for the object. For more information, see
   * [Dialogflow access
   * control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
   */
  entityTypesUri?:
    | string
    | undefined;
  /** Uncompressed byte content of entity types. */
  entityTypesContent?:
    | InlineSource
    | undefined;
  /** Required. Merge option for importing entity types. */
  mergeOption: ImportEntityTypesRequest_MergeOption;
  /**
   * Optional. The target entity type to import into.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entity_types/<EntityType ID>`.
   * If set, there should be only one entity type included in
   * [entity_types][google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.entity_types],
   * of which the type should match the type of the target entity type. All
   * [entities][google.cloud.dialogflow.cx.v3.EntityType.entities] in the
   * imported entity type will be added to the target entity type.
   */
  targetEntityType: string;
}

/** Merge option when display name conflicts exist during import. */
export enum ImportEntityTypesRequest_MergeOption {
  /** MERGE_OPTION_UNSPECIFIED - Unspecified. If used, system uses REPORT_CONFLICT as default. */
  MERGE_OPTION_UNSPECIFIED = 0,
  /**
   * REPLACE - Replace the original entity type in the agent with the new entity type
   * when display name conflicts exist.
   */
  REPLACE = 1,
  /**
   * MERGE - Merge the original entity type with the new entity type when display name
   * conflicts exist.
   */
  MERGE = 2,
  /**
   * RENAME - Create new entity types with new display names to differentiate them from
   * the existing entity types when display name conflicts exist.
   */
  RENAME = 3,
  /**
   * REPORT_CONFLICT - Report conflict information if display names conflict is detected.
   * Otherwise, import entity types.
   */
  REPORT_CONFLICT = 4,
  /**
   * KEEP - Keep the original entity type and discard the conflicting new entity type
   * when display name conflicts exist.
   */
  KEEP = 5,
  UNRECOGNIZED = -1,
}

export function importEntityTypesRequest_MergeOptionFromJSON(object: any): ImportEntityTypesRequest_MergeOption {
  switch (object) {
    case 0:
    case "MERGE_OPTION_UNSPECIFIED":
      return ImportEntityTypesRequest_MergeOption.MERGE_OPTION_UNSPECIFIED;
    case 1:
    case "REPLACE":
      return ImportEntityTypesRequest_MergeOption.REPLACE;
    case 2:
    case "MERGE":
      return ImportEntityTypesRequest_MergeOption.MERGE;
    case 3:
    case "RENAME":
      return ImportEntityTypesRequest_MergeOption.RENAME;
    case 4:
    case "REPORT_CONFLICT":
      return ImportEntityTypesRequest_MergeOption.REPORT_CONFLICT;
    case 5:
    case "KEEP":
      return ImportEntityTypesRequest_MergeOption.KEEP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportEntityTypesRequest_MergeOption.UNRECOGNIZED;
  }
}

export function importEntityTypesRequest_MergeOptionToJSON(object: ImportEntityTypesRequest_MergeOption): string {
  switch (object) {
    case ImportEntityTypesRequest_MergeOption.MERGE_OPTION_UNSPECIFIED:
      return "MERGE_OPTION_UNSPECIFIED";
    case ImportEntityTypesRequest_MergeOption.REPLACE:
      return "REPLACE";
    case ImportEntityTypesRequest_MergeOption.MERGE:
      return "MERGE";
    case ImportEntityTypesRequest_MergeOption.RENAME:
      return "RENAME";
    case ImportEntityTypesRequest_MergeOption.REPORT_CONFLICT:
      return "REPORT_CONFLICT";
    case ImportEntityTypesRequest_MergeOption.KEEP:
      return "KEEP";
    case ImportEntityTypesRequest_MergeOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The response message for
 * [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes].
 */
export interface ImportEntityTypesResponse {
  /**
   * The unique identifier of the imported entity types.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entity_types/<EntityType ID>`.
   */
  entityTypes: string[];
  /**
   * Info which resources have conflicts when
   * [REPORT_CONFLICT][ImportEntityTypesResponse.REPORT_CONFLICT] merge_option
   * is set in ImportEntityTypesRequest.
   */
  conflictingResources: ImportEntityTypesResponse_ConflictingResources | undefined;
}

/**
 * Conflicting resources detected during the import process. Only filled when
 * [REPORT_CONFLICT][ImportEntityTypesResponse.REPORT_CONFLICT] is set in the
 * request and there are conflicts in the display names.
 */
export interface ImportEntityTypesResponse_ConflictingResources {
  /** Display names of conflicting entity types. */
  entityTypeDisplayNames: string[];
  /** Display names of conflicting entities. */
  entityDisplayNames: string[];
}

/**
 * Metadata returned for the
 * [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes]
 * long running operation.
 */
export interface ImportEntityTypesMetadata {
}

/**
 * The request message for
 * [EntityTypes.ListEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes].
 */
export interface ListEntityTypesRequest {
  /**
   * Required. The agent to list all entity types for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /**
   * The language to list entity types for. The following fields are language
   * dependent:
   *
   * *   `EntityType.entities.value`
   * *   `EntityType.entities.synonyms`
   * *   `EntityType.excluded_phrases.value`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /**
   * The maximum number of items to return in a single page. By default 100 and
   * at most 1000.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous list request. */
  pageToken: string;
}

/**
 * The response message for
 * [EntityTypes.ListEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes].
 */
export interface ListEntityTypesResponse {
  /**
   * The list of entity types. There will be a maximum number of items returned
   * based on the page_size field in the request.
   */
  entityTypes: EntityType[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request message for
 * [EntityTypes.GetEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.GetEntityType].
 */
export interface GetEntityTypeRequest {
  /**
   * Required. The name of the entity type.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<Entity Type ID>`.
   */
  name: string;
  /**
   * The language to retrieve the entity type for. The following fields are
   * language dependent:
   *
   * *   `EntityType.entities.value`
   * *   `EntityType.entities.synonyms`
   * *   `EntityType.excluded_phrases.value`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [EntityTypes.CreateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.CreateEntityType].
 */
export interface CreateEntityTypeRequest {
  /**
   * Required. The agent to create a entity type for.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
   */
  parent: string;
  /** Required. The entity type to create. */
  entityType:
    | EntityType
    | undefined;
  /**
   * The language of the following fields in `entity_type`:
   *
   * *   `EntityType.entities.value`
   * *   `EntityType.entities.synonyms`
   * *   `EntityType.excluded_phrases.value`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
}

/**
 * The request message for
 * [EntityTypes.UpdateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType].
 */
export interface UpdateEntityTypeRequest {
  /** Required. The entity type to update. */
  entityType:
    | EntityType
    | undefined;
  /**
   * The language of the following fields in `entity_type`:
   *
   * *   `EntityType.entities.value`
   * *   `EntityType.entities.synonyms`
   * *   `EntityType.excluded_phrases.value`
   *
   * If not specified, the agent's default language is used.
   * [Many
   * languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
   * are supported.
   * Note: languages must be enabled in the agent before they can be used.
   */
  languageCode: string;
  /** The mask to control which fields get updated. */
  updateMask: string[] | undefined;
}

/**
 * The request message for
 * [EntityTypes.DeleteEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.DeleteEntityType].
 */
export interface DeleteEntityTypeRequest {
  /**
   * Required. The name of the entity type to delete.
   * Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
   * ID>/entityTypes/<Entity Type ID>`.
   */
  name: string;
  /**
   * This field has no effect for entity type not being used.
   * For entity types that are used by intents or pages:
   *
   * *  If `force` is set to false, an error will be returned with message
   *    indicating the referencing resources.
   * *  If `force` is set to true, Dialogflow will remove the entity type, as
   *    well as any references to the entity type (i.e. Page
   *    [parameter][google.cloud.dialogflow.cx.v3.Form.Parameter] of the entity
   *    type will be changed to
   *    '@sys.any' and intent
   *    [parameter][google.cloud.dialogflow.cx.v3.Intent.Parameter] of the
   *    entity type will be removed).
   */
  force: boolean;
}

function createBaseEntityType(): EntityType {
  return {
    name: "",
    displayName: "",
    kind: 0,
    autoExpansionMode: 0,
    entities: [],
    excludedPhrases: [],
    enableFuzzyExtraction: false,
    redact: false,
  };
}

export const EntityType: MessageFns<EntityType> = {
  encode(message: EntityType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.autoExpansionMode !== 0) {
      writer.uint32(32).int32(message.autoExpansionMode);
    }
    for (const v of message.entities) {
      EntityType_Entity.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.excludedPhrases) {
      EntityType_ExcludedPhrase.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.enableFuzzyExtraction !== false) {
      writer.uint32(56).bool(message.enableFuzzyExtraction);
    }
    if (message.redact !== false) {
      writer.uint32(72).bool(message.redact);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.autoExpansionMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.entities.push(EntityType_Entity.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.excludedPhrases.push(EntityType_ExcludedPhrase.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.enableFuzzyExtraction = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.redact = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      kind: isSet(object.kind) ? entityType_KindFromJSON(object.kind) : 0,
      autoExpansionMode: isSet(object.autoExpansionMode)
        ? entityType_AutoExpansionModeFromJSON(object.autoExpansionMode)
        : 0,
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => EntityType_Entity.fromJSON(e))
        : [],
      excludedPhrases: globalThis.Array.isArray(object?.excludedPhrases)
        ? object.excludedPhrases.map((e: any) => EntityType_ExcludedPhrase.fromJSON(e))
        : [],
      enableFuzzyExtraction: isSet(object.enableFuzzyExtraction)
        ? globalThis.Boolean(object.enableFuzzyExtraction)
        : false,
      redact: isSet(object.redact) ? globalThis.Boolean(object.redact) : false,
    };
  },

  toJSON(message: EntityType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.kind !== 0) {
      obj.kind = entityType_KindToJSON(message.kind);
    }
    if (message.autoExpansionMode !== 0) {
      obj.autoExpansionMode = entityType_AutoExpansionModeToJSON(message.autoExpansionMode);
    }
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => EntityType_Entity.toJSON(e));
    }
    if (message.excludedPhrases?.length) {
      obj.excludedPhrases = message.excludedPhrases.map((e) => EntityType_ExcludedPhrase.toJSON(e));
    }
    if (message.enableFuzzyExtraction !== false) {
      obj.enableFuzzyExtraction = message.enableFuzzyExtraction;
    }
    if (message.redact !== false) {
      obj.redact = message.redact;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityType>): EntityType {
    return EntityType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityType>): EntityType {
    const message = createBaseEntityType();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.kind = object.kind ?? 0;
    message.autoExpansionMode = object.autoExpansionMode ?? 0;
    message.entities = object.entities?.map((e) => EntityType_Entity.fromPartial(e)) || [];
    message.excludedPhrases = object.excludedPhrases?.map((e) => EntityType_ExcludedPhrase.fromPartial(e)) || [];
    message.enableFuzzyExtraction = object.enableFuzzyExtraction ?? false;
    message.redact = object.redact ?? false;
    return message;
  },
};

function createBaseEntityType_Entity(): EntityType_Entity {
  return { value: "", synonyms: [] };
}

export const EntityType_Entity: MessageFns<EntityType_Entity> = {
  encode(message: EntityType_Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    for (const v of message.synonyms) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityType_Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityType_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.synonyms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityType_Entity {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      synonyms: globalThis.Array.isArray(object?.synonyms) ? object.synonyms.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EntityType_Entity): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.synonyms?.length) {
      obj.synonyms = message.synonyms;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityType_Entity>): EntityType_Entity {
    return EntityType_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityType_Entity>): EntityType_Entity {
    const message = createBaseEntityType_Entity();
    message.value = object.value ?? "";
    message.synonyms = object.synonyms?.map((e) => e) || [];
    return message;
  },
};

function createBaseEntityType_ExcludedPhrase(): EntityType_ExcludedPhrase {
  return { value: "" };
}

export const EntityType_ExcludedPhrase: MessageFns<EntityType_ExcludedPhrase> = {
  encode(message: EntityType_ExcludedPhrase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityType_ExcludedPhrase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityType_ExcludedPhrase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityType_ExcludedPhrase {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: EntityType_ExcludedPhrase): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityType_ExcludedPhrase>): EntityType_ExcludedPhrase {
    return EntityType_ExcludedPhrase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityType_ExcludedPhrase>): EntityType_ExcludedPhrase {
    const message = createBaseEntityType_ExcludedPhrase();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExportEntityTypesRequest(): ExportEntityTypesRequest {
  return {
    parent: "",
    entityTypes: [],
    entityTypesUri: undefined,
    entityTypesContentInline: undefined,
    dataFormat: 0,
    languageCode: "",
  };
}

export const ExportEntityTypesRequest: MessageFns<ExportEntityTypesRequest> = {
  encode(message: ExportEntityTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.entityTypes) {
      writer.uint32(18).string(v!);
    }
    if (message.entityTypesUri !== undefined) {
      writer.uint32(26).string(message.entityTypesUri);
    }
    if (message.entityTypesContentInline !== undefined) {
      writer.uint32(32).bool(message.entityTypesContentInline);
    }
    if (message.dataFormat !== 0) {
      writer.uint32(40).int32(message.dataFormat);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportEntityTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportEntityTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityTypesUri = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.entityTypesContentInline = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dataFormat = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportEntityTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entityTypes: globalThis.Array.isArray(object?.entityTypes)
        ? object.entityTypes.map((e: any) => globalThis.String(e))
        : [],
      entityTypesUri: isSet(object.entityTypesUri) ? globalThis.String(object.entityTypesUri) : undefined,
      entityTypesContentInline: isSet(object.entityTypesContentInline)
        ? globalThis.Boolean(object.entityTypesContentInline)
        : undefined,
      dataFormat: isSet(object.dataFormat) ? exportEntityTypesRequest_DataFormatFromJSON(object.dataFormat) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ExportEntityTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entityTypes?.length) {
      obj.entityTypes = message.entityTypes;
    }
    if (message.entityTypesUri !== undefined) {
      obj.entityTypesUri = message.entityTypesUri;
    }
    if (message.entityTypesContentInline !== undefined) {
      obj.entityTypesContentInline = message.entityTypesContentInline;
    }
    if (message.dataFormat !== 0) {
      obj.dataFormat = exportEntityTypesRequest_DataFormatToJSON(message.dataFormat);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportEntityTypesRequest>): ExportEntityTypesRequest {
    return ExportEntityTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportEntityTypesRequest>): ExportEntityTypesRequest {
    const message = createBaseExportEntityTypesRequest();
    message.parent = object.parent ?? "";
    message.entityTypes = object.entityTypes?.map((e) => e) || [];
    message.entityTypesUri = object.entityTypesUri ?? undefined;
    message.entityTypesContentInline = object.entityTypesContentInline ?? undefined;
    message.dataFormat = object.dataFormat ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseExportEntityTypesResponse(): ExportEntityTypesResponse {
  return { entityTypesUri: undefined, entityTypesContent: undefined };
}

export const ExportEntityTypesResponse: MessageFns<ExportEntityTypesResponse> = {
  encode(message: ExportEntityTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityTypesUri !== undefined) {
      writer.uint32(10).string(message.entityTypesUri);
    }
    if (message.entityTypesContent !== undefined) {
      InlineDestination.encode(message.entityTypesContent, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportEntityTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportEntityTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityTypesUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityTypesContent = InlineDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportEntityTypesResponse {
    return {
      entityTypesUri: isSet(object.entityTypesUri) ? globalThis.String(object.entityTypesUri) : undefined,
      entityTypesContent: isSet(object.entityTypesContent)
        ? InlineDestination.fromJSON(object.entityTypesContent)
        : undefined,
    };
  },

  toJSON(message: ExportEntityTypesResponse): unknown {
    const obj: any = {};
    if (message.entityTypesUri !== undefined) {
      obj.entityTypesUri = message.entityTypesUri;
    }
    if (message.entityTypesContent !== undefined) {
      obj.entityTypesContent = InlineDestination.toJSON(message.entityTypesContent);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportEntityTypesResponse>): ExportEntityTypesResponse {
    return ExportEntityTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportEntityTypesResponse>): ExportEntityTypesResponse {
    const message = createBaseExportEntityTypesResponse();
    message.entityTypesUri = object.entityTypesUri ?? undefined;
    message.entityTypesContent = (object.entityTypesContent !== undefined && object.entityTypesContent !== null)
      ? InlineDestination.fromPartial(object.entityTypesContent)
      : undefined;
    return message;
  },
};

function createBaseExportEntityTypesMetadata(): ExportEntityTypesMetadata {
  return {};
}

export const ExportEntityTypesMetadata: MessageFns<ExportEntityTypesMetadata> = {
  encode(_: ExportEntityTypesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportEntityTypesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportEntityTypesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ExportEntityTypesMetadata {
    return {};
  },

  toJSON(_: ExportEntityTypesMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ExportEntityTypesMetadata>): ExportEntityTypesMetadata {
    return ExportEntityTypesMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ExportEntityTypesMetadata>): ExportEntityTypesMetadata {
    const message = createBaseExportEntityTypesMetadata();
    return message;
  },
};

function createBaseImportEntityTypesRequest(): ImportEntityTypesRequest {
  return { parent: "", entityTypesUri: undefined, entityTypesContent: undefined, mergeOption: 0, targetEntityType: "" };
}

export const ImportEntityTypesRequest: MessageFns<ImportEntityTypesRequest> = {
  encode(message: ImportEntityTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entityTypesUri !== undefined) {
      writer.uint32(18).string(message.entityTypesUri);
    }
    if (message.entityTypesContent !== undefined) {
      InlineSource.encode(message.entityTypesContent, writer.uint32(26).fork()).join();
    }
    if (message.mergeOption !== 0) {
      writer.uint32(32).int32(message.mergeOption);
    }
    if (message.targetEntityType !== "") {
      writer.uint32(42).string(message.targetEntityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportEntityTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportEntityTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityTypesUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entityTypesContent = InlineSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mergeOption = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetEntityType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportEntityTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entityTypesUri: isSet(object.entityTypesUri) ? globalThis.String(object.entityTypesUri) : undefined,
      entityTypesContent: isSet(object.entityTypesContent)
        ? InlineSource.fromJSON(object.entityTypesContent)
        : undefined,
      mergeOption: isSet(object.mergeOption) ? importEntityTypesRequest_MergeOptionFromJSON(object.mergeOption) : 0,
      targetEntityType: isSet(object.targetEntityType) ? globalThis.String(object.targetEntityType) : "",
    };
  },

  toJSON(message: ImportEntityTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entityTypesUri !== undefined) {
      obj.entityTypesUri = message.entityTypesUri;
    }
    if (message.entityTypesContent !== undefined) {
      obj.entityTypesContent = InlineSource.toJSON(message.entityTypesContent);
    }
    if (message.mergeOption !== 0) {
      obj.mergeOption = importEntityTypesRequest_MergeOptionToJSON(message.mergeOption);
    }
    if (message.targetEntityType !== "") {
      obj.targetEntityType = message.targetEntityType;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportEntityTypesRequest>): ImportEntityTypesRequest {
    return ImportEntityTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportEntityTypesRequest>): ImportEntityTypesRequest {
    const message = createBaseImportEntityTypesRequest();
    message.parent = object.parent ?? "";
    message.entityTypesUri = object.entityTypesUri ?? undefined;
    message.entityTypesContent = (object.entityTypesContent !== undefined && object.entityTypesContent !== null)
      ? InlineSource.fromPartial(object.entityTypesContent)
      : undefined;
    message.mergeOption = object.mergeOption ?? 0;
    message.targetEntityType = object.targetEntityType ?? "";
    return message;
  },
};

function createBaseImportEntityTypesResponse(): ImportEntityTypesResponse {
  return { entityTypes: [], conflictingResources: undefined };
}

export const ImportEntityTypesResponse: MessageFns<ImportEntityTypesResponse> = {
  encode(message: ImportEntityTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entityTypes) {
      writer.uint32(10).string(v!);
    }
    if (message.conflictingResources !== undefined) {
      ImportEntityTypesResponse_ConflictingResources.encode(message.conflictingResources, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportEntityTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportEntityTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityTypes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conflictingResources = ImportEntityTypesResponse_ConflictingResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportEntityTypesResponse {
    return {
      entityTypes: globalThis.Array.isArray(object?.entityTypes)
        ? object.entityTypes.map((e: any) => globalThis.String(e))
        : [],
      conflictingResources: isSet(object.conflictingResources)
        ? ImportEntityTypesResponse_ConflictingResources.fromJSON(object.conflictingResources)
        : undefined,
    };
  },

  toJSON(message: ImportEntityTypesResponse): unknown {
    const obj: any = {};
    if (message.entityTypes?.length) {
      obj.entityTypes = message.entityTypes;
    }
    if (message.conflictingResources !== undefined) {
      obj.conflictingResources = ImportEntityTypesResponse_ConflictingResources.toJSON(message.conflictingResources);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportEntityTypesResponse>): ImportEntityTypesResponse {
    return ImportEntityTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportEntityTypesResponse>): ImportEntityTypesResponse {
    const message = createBaseImportEntityTypesResponse();
    message.entityTypes = object.entityTypes?.map((e) => e) || [];
    message.conflictingResources = (object.conflictingResources !== undefined && object.conflictingResources !== null)
      ? ImportEntityTypesResponse_ConflictingResources.fromPartial(object.conflictingResources)
      : undefined;
    return message;
  },
};

function createBaseImportEntityTypesResponse_ConflictingResources(): ImportEntityTypesResponse_ConflictingResources {
  return { entityTypeDisplayNames: [], entityDisplayNames: [] };
}

export const ImportEntityTypesResponse_ConflictingResources: MessageFns<
  ImportEntityTypesResponse_ConflictingResources
> = {
  encode(
    message: ImportEntityTypesResponse_ConflictingResources,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.entityTypeDisplayNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.entityDisplayNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportEntityTypesResponse_ConflictingResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportEntityTypesResponse_ConflictingResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityTypeDisplayNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityDisplayNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportEntityTypesResponse_ConflictingResources {
    return {
      entityTypeDisplayNames: globalThis.Array.isArray(object?.entityTypeDisplayNames)
        ? object.entityTypeDisplayNames.map((e: any) => globalThis.String(e))
        : [],
      entityDisplayNames: globalThis.Array.isArray(object?.entityDisplayNames)
        ? object.entityDisplayNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ImportEntityTypesResponse_ConflictingResources): unknown {
    const obj: any = {};
    if (message.entityTypeDisplayNames?.length) {
      obj.entityTypeDisplayNames = message.entityTypeDisplayNames;
    }
    if (message.entityDisplayNames?.length) {
      obj.entityDisplayNames = message.entityDisplayNames;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ImportEntityTypesResponse_ConflictingResources>,
  ): ImportEntityTypesResponse_ConflictingResources {
    return ImportEntityTypesResponse_ConflictingResources.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ImportEntityTypesResponse_ConflictingResources>,
  ): ImportEntityTypesResponse_ConflictingResources {
    const message = createBaseImportEntityTypesResponse_ConflictingResources();
    message.entityTypeDisplayNames = object.entityTypeDisplayNames?.map((e) => e) || [];
    message.entityDisplayNames = object.entityDisplayNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseImportEntityTypesMetadata(): ImportEntityTypesMetadata {
  return {};
}

export const ImportEntityTypesMetadata: MessageFns<ImportEntityTypesMetadata> = {
  encode(_: ImportEntityTypesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportEntityTypesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportEntityTypesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ImportEntityTypesMetadata {
    return {};
  },

  toJSON(_: ImportEntityTypesMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ImportEntityTypesMetadata>): ImportEntityTypesMetadata {
    return ImportEntityTypesMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ImportEntityTypesMetadata>): ImportEntityTypesMetadata {
    const message = createBaseImportEntityTypesMetadata();
    return message;
  },
};

function createBaseListEntityTypesRequest(): ListEntityTypesRequest {
  return { parent: "", languageCode: "", pageSize: 0, pageToken: "" };
}

export const ListEntityTypesRequest: MessageFns<ListEntityTypesRequest> = {
  encode(message: ListEntityTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntityTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntityTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntityTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListEntityTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntityTypesRequest>): ListEntityTypesRequest {
    return ListEntityTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntityTypesRequest>): ListEntityTypesRequest {
    const message = createBaseListEntityTypesRequest();
    message.parent = object.parent ?? "";
    message.languageCode = object.languageCode ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListEntityTypesResponse(): ListEntityTypesResponse {
  return { entityTypes: [], nextPageToken: "" };
}

export const ListEntityTypesResponse: MessageFns<ListEntityTypesResponse> = {
  encode(message: ListEntityTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entityTypes) {
      EntityType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntityTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntityTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityTypes.push(EntityType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntityTypesResponse {
    return {
      entityTypes: globalThis.Array.isArray(object?.entityTypes)
        ? object.entityTypes.map((e: any) => EntityType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEntityTypesResponse): unknown {
    const obj: any = {};
    if (message.entityTypes?.length) {
      obj.entityTypes = message.entityTypes.map((e) => EntityType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntityTypesResponse>): ListEntityTypesResponse {
    return ListEntityTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntityTypesResponse>): ListEntityTypesResponse {
    const message = createBaseListEntityTypesResponse();
    message.entityTypes = object.entityTypes?.map((e) => EntityType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetEntityTypeRequest(): GetEntityTypeRequest {
  return { name: "", languageCode: "" };
}

export const GetEntityTypeRequest: MessageFns<GetEntityTypeRequest> = {
  encode(message: GetEntityTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEntityTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntityTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEntityTypeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: GetEntityTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEntityTypeRequest>): GetEntityTypeRequest {
    return GetEntityTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEntityTypeRequest>): GetEntityTypeRequest {
    const message = createBaseGetEntityTypeRequest();
    message.name = object.name ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseCreateEntityTypeRequest(): CreateEntityTypeRequest {
  return { parent: "", entityType: undefined, languageCode: "" };
}

export const CreateEntityTypeRequest: MessageFns<CreateEntityTypeRequest> = {
  encode(message: CreateEntityTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entityType !== undefined) {
      EntityType.encode(message.entityType, writer.uint32(18).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEntityTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEntityTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityType = EntityType.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEntityTypeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entityType: isSet(object.entityType) ? EntityType.fromJSON(object.entityType) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: CreateEntityTypeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entityType !== undefined) {
      obj.entityType = EntityType.toJSON(message.entityType);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEntityTypeRequest>): CreateEntityTypeRequest {
    return CreateEntityTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEntityTypeRequest>): CreateEntityTypeRequest {
    const message = createBaseCreateEntityTypeRequest();
    message.parent = object.parent ?? "";
    message.entityType = (object.entityType !== undefined && object.entityType !== null)
      ? EntityType.fromPartial(object.entityType)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseUpdateEntityTypeRequest(): UpdateEntityTypeRequest {
  return { entityType: undefined, languageCode: "", updateMask: undefined };
}

export const UpdateEntityTypeRequest: MessageFns<UpdateEntityTypeRequest> = {
  encode(message: UpdateEntityTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityType !== undefined) {
      EntityType.encode(message.entityType, writer.uint32(10).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEntityTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntityTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityType = EntityType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEntityTypeRequest {
    return {
      entityType: isSet(object.entityType) ? EntityType.fromJSON(object.entityType) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateEntityTypeRequest): unknown {
    const obj: any = {};
    if (message.entityType !== undefined) {
      obj.entityType = EntityType.toJSON(message.entityType);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEntityTypeRequest>): UpdateEntityTypeRequest {
    return UpdateEntityTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEntityTypeRequest>): UpdateEntityTypeRequest {
    const message = createBaseUpdateEntityTypeRequest();
    message.entityType = (object.entityType !== undefined && object.entityType !== null)
      ? EntityType.fromPartial(object.entityType)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteEntityTypeRequest(): DeleteEntityTypeRequest {
  return { name: "", force: false };
}

export const DeleteEntityTypeRequest: MessageFns<DeleteEntityTypeRequest> = {
  encode(message: DeleteEntityTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEntityTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEntityTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEntityTypeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteEntityTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEntityTypeRequest>): DeleteEntityTypeRequest {
    return DeleteEntityTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEntityTypeRequest>): DeleteEntityTypeRequest {
    const message = createBaseDeleteEntityTypeRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

/** Service for managing [EntityTypes][google.cloud.dialogflow.cx.v3.EntityType]. */
export type EntityTypesDefinition = typeof EntityTypesDefinition;
export const EntityTypesDefinition = {
  name: "EntityTypes",
  fullName: "google.cloud.dialogflow.cx.v3.EntityTypes",
  methods: {
    /** Retrieves the specified entity type. */
    getEntityType: {
      name: "GetEntityType",
      requestType: GetEntityTypeRequest,
      requestStream: false,
      responseType: EntityType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              18,
              56,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an entity type in the specified agent.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    createEntityType: {
      name: "CreateEntityType",
      requestType: CreateEntityTypeRequest,
      requestStream: false,
      responseType: EntityType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 101, 110, 116, 105, 116, 121, 95, 116, 121, 112, 101]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              11,
              101,
              110,
              116,
              105,
              116,
              121,
              95,
              116,
              121,
              112,
              101,
              34,
              56,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the specified entity type.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    updateEntityType: {
      name: "UpdateEntityType",
      requestType: UpdateEntityTypeRequest,
      requestStream: false,
      responseType: EntityType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              101,
              110,
              116,
              105,
              116,
              121,
              95,
              116,
              121,
              112,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              11,
              101,
              110,
              116,
              105,
              116,
              121,
              95,
              116,
              121,
              112,
              101,
              50,
              68,
              47,
              118,
              51,
              47,
              123,
              101,
              110,
              116,
              105,
              116,
              121,
              95,
              116,
              121,
              112,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified entity type.
     *
     * Note: You should always train a flow prior to sending it queries. See the
     * [training
     * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
     */
    deleteEntityType: {
      name: "DeleteEntityType",
      requestType: DeleteEntityTypeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              42,
              56,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the list of all entity types in the specified agent. */
    listEntityTypes: {
      name: "ListEntityTypes",
      requestType: ListEntityTypesRequest,
      requestStream: false,
      responseType: ListEntityTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              58,
              18,
              56,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Exports the selected entity types. */
    exportEntityTypes: {
      name: "ExportEntityTypes",
      requestType: ExportEntityTypesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              54,
              10,
              25,
              69,
              120,
              112,
              111,
              114,
              116,
              69,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              25,
              69,
              120,
              112,
              111,
              114,
              116,
              69,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Imports the specified entitytypes into the agent. */
    importEntityTypes: {
      name: "ImportEntityTypes",
      requestType: ImportEntityTypesRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              54,
              10,
              25,
              73,
              109,
              112,
              111,
              114,
              116,
              69,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              25,
              73,
              109,
              112,
              111,
              114,
              116,
              69,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              51,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              103,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              105,
              116,
              121,
              84,
              121,
              112,
              101,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface EntityTypesServiceImplementation<CallContextExt = {}> {
  /** Retrieves the specified entity type. */
  getEntityType(request: GetEntityTypeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EntityType>>;
  /**
   * Creates an entity type in the specified agent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createEntityType(
    request: CreateEntityTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EntityType>>;
  /**
   * Updates the specified entity type.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updateEntityType(
    request: UpdateEntityTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<EntityType>>;
  /**
   * Deletes the specified entity type.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deleteEntityType(
    request: DeleteEntityTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Returns the list of all entity types in the specified agent. */
  listEntityTypes(
    request: ListEntityTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntityTypesResponse>>;
  /** Exports the selected entity types. */
  exportEntityTypes(
    request: ExportEntityTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Imports the specified entitytypes into the agent. */
  importEntityTypes(
    request: ImportEntityTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface EntityTypesClient<CallOptionsExt = {}> {
  /** Retrieves the specified entity type. */
  getEntityType(
    request: DeepPartial<GetEntityTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EntityType>;
  /**
   * Creates an entity type in the specified agent.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  createEntityType(
    request: DeepPartial<CreateEntityTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EntityType>;
  /**
   * Updates the specified entity type.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  updateEntityType(
    request: DeepPartial<UpdateEntityTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EntityType>;
  /**
   * Deletes the specified entity type.
   *
   * Note: You should always train a flow prior to sending it queries. See the
   * [training
   * documentation](https://cloud.google.com/dialogflow/cx/docs/concept/training).
   */
  deleteEntityType(
    request: DeepPartial<DeleteEntityTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Returns the list of all entity types in the specified agent. */
  listEntityTypes(
    request: DeepPartial<ListEntityTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntityTypesResponse>;
  /** Exports the selected entity types. */
  exportEntityTypes(
    request: DeepPartial<ExportEntityTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Imports the specified entitytypes into the agent. */
  importEntityTypes(
    request: DeepPartial<ImportEntityTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
