// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contentwarehouse/v1/document.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateTime } from "../../../type/datetime.js";
import { Document as Document1 } from "../../documentai/v1/document.js";

export const protobufPackage = "google.cloud.contentwarehouse.v1";

/** When a raw document is supplied, this indicates the file format */
export enum RawDocumentFileType {
  /** RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED - No raw document specified or it is non-parsable */
  RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED = 0,
  /** RAW_DOCUMENT_FILE_TYPE_PDF - Adobe PDF format */
  RAW_DOCUMENT_FILE_TYPE_PDF = 1,
  /** RAW_DOCUMENT_FILE_TYPE_DOCX - Microsoft Word format */
  RAW_DOCUMENT_FILE_TYPE_DOCX = 2,
  /** RAW_DOCUMENT_FILE_TYPE_XLSX - Microsoft Excel format */
  RAW_DOCUMENT_FILE_TYPE_XLSX = 3,
  /** RAW_DOCUMENT_FILE_TYPE_PPTX - Microsoft Powerpoint format */
  RAW_DOCUMENT_FILE_TYPE_PPTX = 4,
  /** RAW_DOCUMENT_FILE_TYPE_TEXT - UTF-8 encoded text format */
  RAW_DOCUMENT_FILE_TYPE_TEXT = 5,
  /** RAW_DOCUMENT_FILE_TYPE_TIFF - TIFF or TIF image file format */
  RAW_DOCUMENT_FILE_TYPE_TIFF = 6,
  UNRECOGNIZED = -1,
}

export function rawDocumentFileTypeFromJSON(object: any): RawDocumentFileType {
  switch (object) {
    case 0:
    case "RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED;
    case 1:
    case "RAW_DOCUMENT_FILE_TYPE_PDF":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_PDF;
    case 2:
    case "RAW_DOCUMENT_FILE_TYPE_DOCX":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_DOCX;
    case 3:
    case "RAW_DOCUMENT_FILE_TYPE_XLSX":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_XLSX;
    case 4:
    case "RAW_DOCUMENT_FILE_TYPE_PPTX":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_PPTX;
    case 5:
    case "RAW_DOCUMENT_FILE_TYPE_TEXT":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_TEXT;
    case 6:
    case "RAW_DOCUMENT_FILE_TYPE_TIFF":
      return RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_TIFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RawDocumentFileType.UNRECOGNIZED;
  }
}

export function rawDocumentFileTypeToJSON(object: RawDocumentFileType): string {
  switch (object) {
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED:
      return "RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_PDF:
      return "RAW_DOCUMENT_FILE_TYPE_PDF";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_DOCX:
      return "RAW_DOCUMENT_FILE_TYPE_DOCX";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_XLSX:
      return "RAW_DOCUMENT_FILE_TYPE_XLSX";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_PPTX:
      return "RAW_DOCUMENT_FILE_TYPE_PPTX";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_TEXT:
      return "RAW_DOCUMENT_FILE_TYPE_TEXT";
    case RawDocumentFileType.RAW_DOCUMENT_FILE_TYPE_TIFF:
      return "RAW_DOCUMENT_FILE_TYPE_TIFF";
    case RawDocumentFileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * When a raw document or structured content is supplied, this stores the
 * content category.
 */
export enum ContentCategory {
  /** CONTENT_CATEGORY_UNSPECIFIED - No category is specified. */
  CONTENT_CATEGORY_UNSPECIFIED = 0,
  /** CONTENT_CATEGORY_IMAGE - Content is of image type. */
  CONTENT_CATEGORY_IMAGE = 1,
  /** CONTENT_CATEGORY_AUDIO - Content is of audio type. */
  CONTENT_CATEGORY_AUDIO = 2,
  /** CONTENT_CATEGORY_VIDEO - Content is of video type. */
  CONTENT_CATEGORY_VIDEO = 3,
  UNRECOGNIZED = -1,
}

export function contentCategoryFromJSON(object: any): ContentCategory {
  switch (object) {
    case 0:
    case "CONTENT_CATEGORY_UNSPECIFIED":
      return ContentCategory.CONTENT_CATEGORY_UNSPECIFIED;
    case 1:
    case "CONTENT_CATEGORY_IMAGE":
      return ContentCategory.CONTENT_CATEGORY_IMAGE;
    case 2:
    case "CONTENT_CATEGORY_AUDIO":
      return ContentCategory.CONTENT_CATEGORY_AUDIO;
    case 3:
    case "CONTENT_CATEGORY_VIDEO":
      return ContentCategory.CONTENT_CATEGORY_VIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContentCategory.UNRECOGNIZED;
  }
}

export function contentCategoryToJSON(object: ContentCategory): string {
  switch (object) {
    case ContentCategory.CONTENT_CATEGORY_UNSPECIFIED:
      return "CONTENT_CATEGORY_UNSPECIFIED";
    case ContentCategory.CONTENT_CATEGORY_IMAGE:
      return "CONTENT_CATEGORY_IMAGE";
    case ContentCategory.CONTENT_CATEGORY_AUDIO:
      return "CONTENT_CATEGORY_AUDIO";
    case ContentCategory.CONTENT_CATEGORY_VIDEO:
      return "CONTENT_CATEGORY_VIDEO";
    case ContentCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the structure for content warehouse document proto. */
export interface Document {
  /**
   * The resource name of the document.
   * Format:
   * projects/{project_number}/locations/{location}/documents/{document_id}.
   *
   * The name is ignored when creating a document.
   */
  name: string;
  /** The reference ID set by customers. Must be unique per project and location. */
  referenceId: string;
  /**
   * Required. Display name of the document given by the user. This name will be
   * displayed in the UI. Customer can populate this field with the name of the
   * document. This differs from the 'title' field as 'title' is optional and
   * stores the top heading in the document.
   */
  displayName: string;
  /**
   * Title that describes the document.
   * This can be the top heading or text that describes the document.
   */
  title: string;
  /** Uri to display the document, for example, in the UI. */
  displayUri: string;
  /**
   * The Document schema name.
   * Format:
   * projects/{project_number}/locations/{location}/documentSchemas/{document_schema_id}.
   */
  documentSchemaName: string;
  /** Other document format, such as PPTX, XLXS */
  plainText?:
    | string
    | undefined;
  /** Document AI format to save the structured content, including OCR. */
  cloudAiDocument?:
    | Document1
    | undefined;
  /**
   * A path linked to structured content file.
   *
   * @deprecated
   */
  structuredContentUri: string;
  /** Raw document file in Cloud Storage path. */
  rawDocumentPath?:
    | string
    | undefined;
  /** Raw document content. */
  inlineRawDocument?:
    | Buffer
    | undefined;
  /** List of values that are user supplied metadata. */
  properties: Property[];
  /** Output only. The time when the document is last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The time when the document is created. */
  createTime:
    | Date
    | undefined;
  /**
   * This is used when DocAI was not used to load the document and parsing/
   * extracting is needed for the inline_raw_document.  For example, if
   * inline_raw_document is the byte representation of a PDF file, then
   * this should be set to: RAW_DOCUMENT_FILE_TYPE_PDF.
   */
  rawDocumentFileType: RawDocumentFileType;
  /**
   * If true, makes the document visible to asynchronous policies and rules.
   *
   * @deprecated
   */
  asyncEnabled: boolean;
  /** Indicates the category (image, audio, video etc.) of the original content. */
  contentCategory: ContentCategory;
  /**
   * If true, text extraction will not be performed.
   *
   * @deprecated
   */
  textExtractionDisabled: boolean;
  /** If true, text extraction will be performed. */
  textExtractionEnabled: boolean;
  /** The user who creates the document. */
  creator: string;
  /** The user who lastly updates the document. */
  updater: string;
  /**
   * Output only. If linked to a Collection with RetentionPolicy, the date when
   * the document becomes mutable.
   */
  dispositionTime:
    | Date
    | undefined;
  /** Output only. Indicates if the document has a legal hold on it. */
  legalHold: boolean;
}

/** References to the documents. */
export interface DocumentReference {
  /** Required. Name of the referenced document. */
  documentName: string;
  /**
   * display_name of the referenced document; this name does not need to be
   * consistent to the display_name in the Document proto, depending on the ACL
   * constraint.
   */
  displayName: string;
  /**
   * Stores the subset of the referenced document's content.
   * This is useful to allow user peek the information of the referenced
   * document.
   */
  snippet: string;
  /** The document type of the document being referenced. */
  documentIsFolder: boolean;
  /** Output only. The time when the document is last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The time when the document is created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the document is deleted. */
  deleteTime:
    | Date
    | undefined;
  /** Document is a folder with retention policy. */
  documentIsRetentionFolder: boolean;
  /** Document is a folder with legal hold. */
  documentIsLegalHoldFolder: boolean;
}

/** Property of a document. */
export interface Property {
  /**
   * Required. Must match the name of a PropertyDefinition in the
   * DocumentSchema.
   */
  name: string;
  /** Integer property values. */
  integerValues?:
    | IntegerArray
    | undefined;
  /** Float property values. */
  floatValues?:
    | FloatArray
    | undefined;
  /** String/text property values. */
  textValues?:
    | TextArray
    | undefined;
  /** Enum property values. */
  enumValues?:
    | EnumArray
    | undefined;
  /** Nested structured data property values. */
  propertyValues?:
    | PropertyArray
    | undefined;
  /**
   * Date time property values.
   * It is not supported by CMEK compliant deployment.
   */
  dateTimeValues?:
    | DateTimeArray
    | undefined;
  /** Map property values. */
  mapProperty?:
    | MapProperty
    | undefined;
  /**
   * Timestamp property values.
   * It is not supported by CMEK compliant deployment.
   */
  timestampValues?: TimestampArray | undefined;
}

/** Integer values. */
export interface IntegerArray {
  /** List of integer values. */
  values: number[];
}

/** Float values. */
export interface FloatArray {
  /** List of float values. */
  values: number[];
}

/** String/text values. */
export interface TextArray {
  /** List of text values. */
  values: string[];
}

/** Enum values. */
export interface EnumArray {
  /** List of enum values. */
  values: string[];
}

/** DateTime values. */
export interface DateTimeArray {
  /**
   * List of datetime values.
   * Both OffsetDateTime and ZonedDateTime are supported.
   */
  values: DateTime[];
}

/** Timestamp values. */
export interface TimestampArray {
  /** List of timestamp values. */
  values: TimestampValue[];
}

/** Timestamp value type. */
export interface TimestampValue {
  /** Timestamp value */
  timestampValue?:
    | Date
    | undefined;
  /**
   * The string must represent a valid instant in UTC and is parsed using
   * java.time.format.DateTimeFormatter.ISO_INSTANT.
   * e.g. "2013-09-29T18:46:19Z"
   */
  textValue?: string | undefined;
}

/** Property values. */
export interface PropertyArray {
  /** List of property values. */
  properties: Property[];
}

/**
 * Map property value.
 * Represents a structured entries of key value pairs, consisting of field names
 * which map to dynamically typed values.
 */
export interface MapProperty {
  /** Unordered map of dynamically typed values. */
  fields: { [key: string]: Value };
}

export interface MapProperty_FieldsEntry {
  key: string;
  value: Value | undefined;
}

/**
 * `Value` represents a dynamically typed value which can be either be
 * a float, a integer, a string, or a datetime value. A producer of value is
 * expected to set one of these variants. Absence of any variant indicates an
 * error.
 */
export interface Value {
  /** Represents a float value. */
  floatValue?:
    | number
    | undefined;
  /** Represents a integer value. */
  intValue?:
    | number
    | undefined;
  /** Represents a string value. */
  stringValue?:
    | string
    | undefined;
  /** Represents an enum value. */
  enumValue?:
    | EnumValue
    | undefined;
  /** Represents a datetime value. */
  datetimeValue?:
    | DateTime
    | undefined;
  /** Represents a timestamp value. */
  timestampValue?:
    | TimestampValue
    | undefined;
  /** Represents a boolean value. */
  booleanValue?: boolean | undefined;
}

/** Represents the string value of the enum field. */
export interface EnumValue {
  /**
   * String value of the enum field. This must match defined set of enums
   * in document schema using EnumTypeOptions.
   */
  value: string;
}

function createBaseDocument(): Document {
  return {
    name: "",
    referenceId: "",
    displayName: "",
    title: "",
    displayUri: "",
    documentSchemaName: "",
    plainText: undefined,
    cloudAiDocument: undefined,
    structuredContentUri: "",
    rawDocumentPath: undefined,
    inlineRawDocument: undefined,
    properties: [],
    updateTime: undefined,
    createTime: undefined,
    rawDocumentFileType: 0,
    asyncEnabled: false,
    contentCategory: 0,
    textExtractionDisabled: false,
    textExtractionEnabled: false,
    creator: "",
    updater: "",
    dispositionTime: undefined,
    legalHold: false,
  };
}

export const Document: MessageFns<Document> = {
  encode(message: Document, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.referenceId !== "") {
      writer.uint32(90).string(message.referenceId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.title !== "") {
      writer.uint32(146).string(message.title);
    }
    if (message.displayUri !== "") {
      writer.uint32(138).string(message.displayUri);
    }
    if (message.documentSchemaName !== "") {
      writer.uint32(26).string(message.documentSchemaName);
    }
    if (message.plainText !== undefined) {
      writer.uint32(122).string(message.plainText);
    }
    if (message.cloudAiDocument !== undefined) {
      Document1.encode(message.cloudAiDocument, writer.uint32(34).fork()).join();
    }
    if (message.structuredContentUri !== "") {
      writer.uint32(130).string(message.structuredContentUri);
    }
    if (message.rawDocumentPath !== undefined) {
      writer.uint32(42).string(message.rawDocumentPath);
    }
    if (message.inlineRawDocument !== undefined) {
      writer.uint32(50).bytes(message.inlineRawDocument);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.rawDocumentFileType !== 0) {
      writer.uint32(80).int32(message.rawDocumentFileType);
    }
    if (message.asyncEnabled !== false) {
      writer.uint32(96).bool(message.asyncEnabled);
    }
    if (message.contentCategory !== 0) {
      writer.uint32(160).int32(message.contentCategory);
    }
    if (message.textExtractionDisabled !== false) {
      writer.uint32(152).bool(message.textExtractionDisabled);
    }
    if (message.textExtractionEnabled !== false) {
      writer.uint32(168).bool(message.textExtractionEnabled);
    }
    if (message.creator !== "") {
      writer.uint32(106).string(message.creator);
    }
    if (message.updater !== "") {
      writer.uint32(114).string(message.updater);
    }
    if (message.dispositionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dispositionTime), writer.uint32(178).fork()).join();
    }
    if (message.legalHold !== false) {
      writer.uint32(184).bool(message.legalHold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.title = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.displayUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documentSchemaName = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.plainText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudAiDocument = Document1.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.structuredContentUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rawDocumentPath = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inlineRawDocument = Buffer.from(reader.bytes());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.rawDocumentFileType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.asyncEnabled = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.contentCategory = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.textExtractionDisabled = reader.bool();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.textExtractionEnabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updater = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.dispositionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.legalHold = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      referenceId: isSet(object.referenceId) ? globalThis.String(object.referenceId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      displayUri: isSet(object.displayUri) ? globalThis.String(object.displayUri) : "",
      documentSchemaName: isSet(object.documentSchemaName) ? globalThis.String(object.documentSchemaName) : "",
      plainText: isSet(object.plainText) ? globalThis.String(object.plainText) : undefined,
      cloudAiDocument: isSet(object.cloudAiDocument) ? Document1.fromJSON(object.cloudAiDocument) : undefined,
      structuredContentUri: isSet(object.structuredContentUri) ? globalThis.String(object.structuredContentUri) : "",
      rawDocumentPath: isSet(object.rawDocumentPath) ? globalThis.String(object.rawDocumentPath) : undefined,
      inlineRawDocument: isSet(object.inlineRawDocument)
        ? Buffer.from(bytesFromBase64(object.inlineRawDocument))
        : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      rawDocumentFileType: isSet(object.rawDocumentFileType)
        ? rawDocumentFileTypeFromJSON(object.rawDocumentFileType)
        : 0,
      asyncEnabled: isSet(object.asyncEnabled) ? globalThis.Boolean(object.asyncEnabled) : false,
      contentCategory: isSet(object.contentCategory) ? contentCategoryFromJSON(object.contentCategory) : 0,
      textExtractionDisabled: isSet(object.textExtractionDisabled)
        ? globalThis.Boolean(object.textExtractionDisabled)
        : false,
      textExtractionEnabled: isSet(object.textExtractionEnabled)
        ? globalThis.Boolean(object.textExtractionEnabled)
        : false,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      updater: isSet(object.updater) ? globalThis.String(object.updater) : "",
      dispositionTime: isSet(object.dispositionTime) ? fromJsonTimestamp(object.dispositionTime) : undefined,
      legalHold: isSet(object.legalHold) ? globalThis.Boolean(object.legalHold) : false,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.referenceId !== "") {
      obj.referenceId = message.referenceId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.displayUri !== "") {
      obj.displayUri = message.displayUri;
    }
    if (message.documentSchemaName !== "") {
      obj.documentSchemaName = message.documentSchemaName;
    }
    if (message.plainText !== undefined) {
      obj.plainText = message.plainText;
    }
    if (message.cloudAiDocument !== undefined) {
      obj.cloudAiDocument = Document1.toJSON(message.cloudAiDocument);
    }
    if (message.structuredContentUri !== "") {
      obj.structuredContentUri = message.structuredContentUri;
    }
    if (message.rawDocumentPath !== undefined) {
      obj.rawDocumentPath = message.rawDocumentPath;
    }
    if (message.inlineRawDocument !== undefined) {
      obj.inlineRawDocument = base64FromBytes(message.inlineRawDocument);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.rawDocumentFileType !== 0) {
      obj.rawDocumentFileType = rawDocumentFileTypeToJSON(message.rawDocumentFileType);
    }
    if (message.asyncEnabled !== false) {
      obj.asyncEnabled = message.asyncEnabled;
    }
    if (message.contentCategory !== 0) {
      obj.contentCategory = contentCategoryToJSON(message.contentCategory);
    }
    if (message.textExtractionDisabled !== false) {
      obj.textExtractionDisabled = message.textExtractionDisabled;
    }
    if (message.textExtractionEnabled !== false) {
      obj.textExtractionEnabled = message.textExtractionEnabled;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.updater !== "") {
      obj.updater = message.updater;
    }
    if (message.dispositionTime !== undefined) {
      obj.dispositionTime = message.dispositionTime.toISOString();
    }
    if (message.legalHold !== false) {
      obj.legalHold = message.legalHold;
    }
    return obj;
  },

  create(base?: DeepPartial<Document>): Document {
    return Document.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document>): Document {
    const message = createBaseDocument();
    message.name = object.name ?? "";
    message.referenceId = object.referenceId ?? "";
    message.displayName = object.displayName ?? "";
    message.title = object.title ?? "";
    message.displayUri = object.displayUri ?? "";
    message.documentSchemaName = object.documentSchemaName ?? "";
    message.plainText = object.plainText ?? undefined;
    message.cloudAiDocument = (object.cloudAiDocument !== undefined && object.cloudAiDocument !== null)
      ? Document1.fromPartial(object.cloudAiDocument)
      : undefined;
    message.structuredContentUri = object.structuredContentUri ?? "";
    message.rawDocumentPath = object.rawDocumentPath ?? undefined;
    message.inlineRawDocument = object.inlineRawDocument ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.updateTime = object.updateTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.rawDocumentFileType = object.rawDocumentFileType ?? 0;
    message.asyncEnabled = object.asyncEnabled ?? false;
    message.contentCategory = object.contentCategory ?? 0;
    message.textExtractionDisabled = object.textExtractionDisabled ?? false;
    message.textExtractionEnabled = object.textExtractionEnabled ?? false;
    message.creator = object.creator ?? "";
    message.updater = object.updater ?? "";
    message.dispositionTime = object.dispositionTime ?? undefined;
    message.legalHold = object.legalHold ?? false;
    return message;
  },
};

function createBaseDocumentReference(): DocumentReference {
  return {
    documentName: "",
    displayName: "",
    snippet: "",
    documentIsFolder: false,
    updateTime: undefined,
    createTime: undefined,
    deleteTime: undefined,
    documentIsRetentionFolder: false,
    documentIsLegalHoldFolder: false,
  };
}

export const DocumentReference: MessageFns<DocumentReference> = {
  encode(message: DocumentReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentName !== "") {
      writer.uint32(10).string(message.documentName);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.snippet !== "") {
      writer.uint32(26).string(message.snippet);
    }
    if (message.documentIsFolder !== false) {
      writer.uint32(32).bool(message.documentIsFolder);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(58).fork()).join();
    }
    if (message.documentIsRetentionFolder !== false) {
      writer.uint32(64).bool(message.documentIsRetentionFolder);
    }
    if (message.documentIsLegalHoldFolder !== false) {
      writer.uint32(72).bool(message.documentIsLegalHoldFolder);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snippet = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.documentIsFolder = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.documentIsRetentionFolder = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.documentIsLegalHoldFolder = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentReference {
    return {
      documentName: isSet(object.documentName) ? globalThis.String(object.documentName) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      snippet: isSet(object.snippet) ? globalThis.String(object.snippet) : "",
      documentIsFolder: isSet(object.documentIsFolder) ? globalThis.Boolean(object.documentIsFolder) : false,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      documentIsRetentionFolder: isSet(object.documentIsRetentionFolder)
        ? globalThis.Boolean(object.documentIsRetentionFolder)
        : false,
      documentIsLegalHoldFolder: isSet(object.documentIsLegalHoldFolder)
        ? globalThis.Boolean(object.documentIsLegalHoldFolder)
        : false,
    };
  },

  toJSON(message: DocumentReference): unknown {
    const obj: any = {};
    if (message.documentName !== "") {
      obj.documentName = message.documentName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.snippet !== "") {
      obj.snippet = message.snippet;
    }
    if (message.documentIsFolder !== false) {
      obj.documentIsFolder = message.documentIsFolder;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.documentIsRetentionFolder !== false) {
      obj.documentIsRetentionFolder = message.documentIsRetentionFolder;
    }
    if (message.documentIsLegalHoldFolder !== false) {
      obj.documentIsLegalHoldFolder = message.documentIsLegalHoldFolder;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentReference>): DocumentReference {
    return DocumentReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentReference>): DocumentReference {
    const message = createBaseDocumentReference();
    message.documentName = object.documentName ?? "";
    message.displayName = object.displayName ?? "";
    message.snippet = object.snippet ?? "";
    message.documentIsFolder = object.documentIsFolder ?? false;
    message.updateTime = object.updateTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.documentIsRetentionFolder = object.documentIsRetentionFolder ?? false;
    message.documentIsLegalHoldFolder = object.documentIsLegalHoldFolder ?? false;
    return message;
  },
};

function createBaseProperty(): Property {
  return {
    name: "",
    integerValues: undefined,
    floatValues: undefined,
    textValues: undefined,
    enumValues: undefined,
    propertyValues: undefined,
    dateTimeValues: undefined,
    mapProperty: undefined,
    timestampValues: undefined,
  };
}

export const Property: MessageFns<Property> = {
  encode(message: Property, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.integerValues !== undefined) {
      IntegerArray.encode(message.integerValues, writer.uint32(18).fork()).join();
    }
    if (message.floatValues !== undefined) {
      FloatArray.encode(message.floatValues, writer.uint32(26).fork()).join();
    }
    if (message.textValues !== undefined) {
      TextArray.encode(message.textValues, writer.uint32(34).fork()).join();
    }
    if (message.enumValues !== undefined) {
      EnumArray.encode(message.enumValues, writer.uint32(42).fork()).join();
    }
    if (message.propertyValues !== undefined) {
      PropertyArray.encode(message.propertyValues, writer.uint32(50).fork()).join();
    }
    if (message.dateTimeValues !== undefined) {
      DateTimeArray.encode(message.dateTimeValues, writer.uint32(58).fork()).join();
    }
    if (message.mapProperty !== undefined) {
      MapProperty.encode(message.mapProperty, writer.uint32(66).fork()).join();
    }
    if (message.timestampValues !== undefined) {
      TimestampArray.encode(message.timestampValues, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Property {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.integerValues = IntegerArray.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.floatValues = FloatArray.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textValues = TextArray.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.enumValues = EnumArray.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.propertyValues = PropertyArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dateTimeValues = DateTimeArray.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.mapProperty = MapProperty.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timestampValues = TimestampArray.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Property {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      integerValues: isSet(object.integerValues) ? IntegerArray.fromJSON(object.integerValues) : undefined,
      floatValues: isSet(object.floatValues) ? FloatArray.fromJSON(object.floatValues) : undefined,
      textValues: isSet(object.textValues) ? TextArray.fromJSON(object.textValues) : undefined,
      enumValues: isSet(object.enumValues) ? EnumArray.fromJSON(object.enumValues) : undefined,
      propertyValues: isSet(object.propertyValues) ? PropertyArray.fromJSON(object.propertyValues) : undefined,
      dateTimeValues: isSet(object.dateTimeValues) ? DateTimeArray.fromJSON(object.dateTimeValues) : undefined,
      mapProperty: isSet(object.mapProperty) ? MapProperty.fromJSON(object.mapProperty) : undefined,
      timestampValues: isSet(object.timestampValues) ? TimestampArray.fromJSON(object.timestampValues) : undefined,
    };
  },

  toJSON(message: Property): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.integerValues !== undefined) {
      obj.integerValues = IntegerArray.toJSON(message.integerValues);
    }
    if (message.floatValues !== undefined) {
      obj.floatValues = FloatArray.toJSON(message.floatValues);
    }
    if (message.textValues !== undefined) {
      obj.textValues = TextArray.toJSON(message.textValues);
    }
    if (message.enumValues !== undefined) {
      obj.enumValues = EnumArray.toJSON(message.enumValues);
    }
    if (message.propertyValues !== undefined) {
      obj.propertyValues = PropertyArray.toJSON(message.propertyValues);
    }
    if (message.dateTimeValues !== undefined) {
      obj.dateTimeValues = DateTimeArray.toJSON(message.dateTimeValues);
    }
    if (message.mapProperty !== undefined) {
      obj.mapProperty = MapProperty.toJSON(message.mapProperty);
    }
    if (message.timestampValues !== undefined) {
      obj.timestampValues = TimestampArray.toJSON(message.timestampValues);
    }
    return obj;
  },

  create(base?: DeepPartial<Property>): Property {
    return Property.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Property>): Property {
    const message = createBaseProperty();
    message.name = object.name ?? "";
    message.integerValues = (object.integerValues !== undefined && object.integerValues !== null)
      ? IntegerArray.fromPartial(object.integerValues)
      : undefined;
    message.floatValues = (object.floatValues !== undefined && object.floatValues !== null)
      ? FloatArray.fromPartial(object.floatValues)
      : undefined;
    message.textValues = (object.textValues !== undefined && object.textValues !== null)
      ? TextArray.fromPartial(object.textValues)
      : undefined;
    message.enumValues = (object.enumValues !== undefined && object.enumValues !== null)
      ? EnumArray.fromPartial(object.enumValues)
      : undefined;
    message.propertyValues = (object.propertyValues !== undefined && object.propertyValues !== null)
      ? PropertyArray.fromPartial(object.propertyValues)
      : undefined;
    message.dateTimeValues = (object.dateTimeValues !== undefined && object.dateTimeValues !== null)
      ? DateTimeArray.fromPartial(object.dateTimeValues)
      : undefined;
    message.mapProperty = (object.mapProperty !== undefined && object.mapProperty !== null)
      ? MapProperty.fromPartial(object.mapProperty)
      : undefined;
    message.timestampValues = (object.timestampValues !== undefined && object.timestampValues !== null)
      ? TimestampArray.fromPartial(object.timestampValues)
      : undefined;
    return message;
  },
};

function createBaseIntegerArray(): IntegerArray {
  return { values: [] };
}

export const IntegerArray: MessageFns<IntegerArray> = {
  encode(message: IntegerArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegerArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegerArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegerArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: IntegerArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IntegerArray>): IntegerArray {
    return IntegerArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntegerArray>): IntegerArray {
    const message = createBaseIntegerArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseFloatArray(): FloatArray {
  return { values: [] };
}

export const FloatArray: MessageFns<FloatArray> = {
  encode(message: FloatArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.float(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.values.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.float());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatArray>): FloatArray {
    return FloatArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatArray>): FloatArray {
    const message = createBaseFloatArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseTextArray(): TextArray {
  return { values: [] };
}

export const TextArray: MessageFns<TextArray> = {
  encode(message: TextArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TextArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<TextArray>): TextArray {
    return TextArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextArray>): TextArray {
    const message = createBaseTextArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseEnumArray(): EnumArray {
  return { values: [] };
}

export const EnumArray: MessageFns<EnumArray> = {
  encode(message: EnumArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EnumArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<EnumArray>): EnumArray {
    return EnumArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumArray>): EnumArray {
    const message = createBaseEnumArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseDateTimeArray(): DateTimeArray {
  return { values: [] };
}

export const DateTimeArray: MessageFns<DateTimeArray> = {
  encode(message: DateTimeArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      DateTime.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateTimeArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateTimeArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(DateTime.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateTimeArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => DateTime.fromJSON(e)) : [],
    };
  },

  toJSON(message: DateTimeArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => DateTime.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DateTimeArray>): DateTimeArray {
    return DateTimeArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateTimeArray>): DateTimeArray {
    const message = createBaseDateTimeArray();
    message.values = object.values?.map((e) => DateTime.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimestampArray(): TimestampArray {
  return { values: [] };
}

export const TimestampArray: MessageFns<TimestampArray> = {
  encode(message: TimestampArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      TimestampValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(TimestampValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => TimestampValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: TimestampArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => TimestampValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampArray>): TimestampArray {
    return TimestampArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampArray>): TimestampArray {
    const message = createBaseTimestampArray();
    message.values = object.values?.map((e) => TimestampValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimestampValue(): TimestampValue {
  return { timestampValue: undefined, textValue: undefined };
}

export const TimestampValue: MessageFns<TimestampValue> = {
  encode(message: TimestampValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestampValue !== undefined) {
      Timestamp.encode(toTimestamp(message.timestampValue), writer.uint32(10).fork()).join();
    }
    if (message.textValue !== undefined) {
      writer.uint32(18).string(message.textValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timestampValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampValue {
    return {
      timestampValue: isSet(object.timestampValue) ? fromJsonTimestamp(object.timestampValue) : undefined,
      textValue: isSet(object.textValue) ? globalThis.String(object.textValue) : undefined,
    };
  },

  toJSON(message: TimestampValue): unknown {
    const obj: any = {};
    if (message.timestampValue !== undefined) {
      obj.timestampValue = message.timestampValue.toISOString();
    }
    if (message.textValue !== undefined) {
      obj.textValue = message.textValue;
    }
    return obj;
  },

  create(base?: DeepPartial<TimestampValue>): TimestampValue {
    return TimestampValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimestampValue>): TimestampValue {
    const message = createBaseTimestampValue();
    message.timestampValue = object.timestampValue ?? undefined;
    message.textValue = object.textValue ?? undefined;
    return message;
  },
};

function createBasePropertyArray(): PropertyArray {
  return { properties: [] };
}

export const PropertyArray: MessageFns<PropertyArray> = {
  encode(message: PropertyArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyArray {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PropertyArray): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyArray>): PropertyArray {
    return PropertyArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyArray>): PropertyArray {
    const message = createBasePropertyArray();
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMapProperty(): MapProperty {
  return { fields: {} };
}

export const MapProperty: MessageFns<MapProperty> = {
  encode(message: MapProperty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fields).forEach(([key, value]) => {
      MapProperty_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapProperty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapProperty_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapProperty {
    return {
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapProperty): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapProperty>): MapProperty {
    return MapProperty.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapProperty>): MapProperty {
    const message = createBaseMapProperty();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapProperty_FieldsEntry(): MapProperty_FieldsEntry {
  return { key: "", value: undefined };
}

export const MapProperty_FieldsEntry: MessageFns<MapProperty_FieldsEntry> = {
  encode(message: MapProperty_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapProperty_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapProperty_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapProperty_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MapProperty_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MapProperty_FieldsEntry>): MapProperty_FieldsEntry {
    return MapProperty_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapProperty_FieldsEntry>): MapProperty_FieldsEntry {
    const message = createBaseMapProperty_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return {
    floatValue: undefined,
    intValue: undefined,
    stringValue: undefined,
    enumValue: undefined,
    datetimeValue: undefined,
    timestampValue: undefined,
    booleanValue: undefined,
  };
}

export const Value: MessageFns<Value> = {
  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.floatValue !== undefined) {
      writer.uint32(13).float(message.floatValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int32(message.intValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.enumValue !== undefined) {
      EnumValue.encode(message.enumValue, writer.uint32(34).fork()).join();
    }
    if (message.datetimeValue !== undefined) {
      DateTime.encode(message.datetimeValue, writer.uint32(42).fork()).join();
    }
    if (message.timestampValue !== undefined) {
      TimestampValue.encode(message.timestampValue, writer.uint32(50).fork()).join();
    }
    if (message.booleanValue !== undefined) {
      writer.uint32(56).bool(message.booleanValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.enumValue = EnumValue.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.datetimeValue = DateTime.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestampValue = TimestampValue.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.booleanValue = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      enumValue: isSet(object.enumValue) ? EnumValue.fromJSON(object.enumValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? DateTime.fromJSON(object.datetimeValue) : undefined,
      timestampValue: isSet(object.timestampValue) ? TimestampValue.fromJSON(object.timestampValue) : undefined,
      booleanValue: isSet(object.booleanValue) ? globalThis.Boolean(object.booleanValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.enumValue !== undefined) {
      obj.enumValue = EnumValue.toJSON(message.enumValue);
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = DateTime.toJSON(message.datetimeValue);
    }
    if (message.timestampValue !== undefined) {
      obj.timestampValue = TimestampValue.toJSON(message.timestampValue);
    }
    if (message.booleanValue !== undefined) {
      obj.booleanValue = message.booleanValue;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.floatValue = object.floatValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.enumValue = (object.enumValue !== undefined && object.enumValue !== null)
      ? EnumValue.fromPartial(object.enumValue)
      : undefined;
    message.datetimeValue = (object.datetimeValue !== undefined && object.datetimeValue !== null)
      ? DateTime.fromPartial(object.datetimeValue)
      : undefined;
    message.timestampValue = (object.timestampValue !== undefined && object.timestampValue !== null)
      ? TimestampValue.fromPartial(object.timestampValue)
      : undefined;
    message.booleanValue = object.booleanValue ?? undefined;
    return message;
  },
};

function createBaseEnumValue(): EnumValue {
  return { value: "" };
}

export const EnumValue: MessageFns<EnumValue> = {
  encode(message: EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: EnumValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EnumValue>): EnumValue {
    return EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumValue>): EnumValue {
    const message = createBaseEnumValue();
    message.value = object.value ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
