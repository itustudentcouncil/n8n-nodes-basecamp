// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/billing/budgets/v1beta1/budget_model.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ListValue } from "../../../../protobuf/struct.js";
import { DateMessage } from "../../../../type/date.js";
import { Money } from "../../../../type/money.js";

export const protobufPackage = "google.cloud.billing.budgets.v1beta1";

/**
 * A `CalendarPeriod` represents the abstract concept of a time period that
 * has a canonical start. Grammatically, "the start of the current
 * `CalendarPeriod`". All calendar times begin at 12 AM US and Canadian
 * Pacific Time (UTC-8).
 */
export enum CalendarPeriod {
  /**
   * CALENDAR_PERIOD_UNSPECIFIED - Calendar period is unset. This is the default if the budget is for a
   * custom time period (CustomPeriod).
   */
  CALENDAR_PERIOD_UNSPECIFIED = 0,
  /**
   * MONTH - A month. Month starts on the first day of each month, such as January 1,
   * February 1, March 1, and so on.
   */
  MONTH = 1,
  /**
   * QUARTER - A quarter. Quarters start on dates January 1, April 1, July 1, and October
   * 1 of each year.
   */
  QUARTER = 2,
  /** YEAR - A year. Year starts on January 1. */
  YEAR = 3,
  UNRECOGNIZED = -1,
}

export function calendarPeriodFromJSON(object: any): CalendarPeriod {
  switch (object) {
    case 0:
    case "CALENDAR_PERIOD_UNSPECIFIED":
      return CalendarPeriod.CALENDAR_PERIOD_UNSPECIFIED;
    case 1:
    case "MONTH":
      return CalendarPeriod.MONTH;
    case 2:
    case "QUARTER":
      return CalendarPeriod.QUARTER;
    case 3:
    case "YEAR":
      return CalendarPeriod.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CalendarPeriod.UNRECOGNIZED;
  }
}

export function calendarPeriodToJSON(object: CalendarPeriod): string {
  switch (object) {
    case CalendarPeriod.CALENDAR_PERIOD_UNSPECIFIED:
      return "CALENDAR_PERIOD_UNSPECIFIED";
    case CalendarPeriod.MONTH:
      return "MONTH";
    case CalendarPeriod.QUARTER:
      return "QUARTER";
    case CalendarPeriod.YEAR:
      return "YEAR";
    case CalendarPeriod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A budget is a plan that describes what you expect to spend on Cloud
 * projects, plus the rules to execute as spend is tracked against that plan,
 * (for example, send an alert when 90% of the target spend is met).
 * The budget time period is configurable, with options such as month (default),
 * quarter, year, or custom time period.
 */
export interface Budget {
  /**
   * Output only. Resource name of the budget.
   * The resource name implies the scope of a budget. Values are of the form
   * `billingAccounts/{billingAccountId}/budgets/{budgetId}`.
   */
  name: string;
  /**
   * User data for display name in UI.
   * Validation: <= 60 chars.
   */
  displayName: string;
  /**
   * Optional. Filters that define which resources are used to compute the
   * actual spend against the budget amount, such as projects, services, and the
   * budget's time period, as well as other filters.
   */
  budgetFilter:
    | Filter
    | undefined;
  /** Required. Budgeted amount. */
  amount:
    | BudgetAmount
    | undefined;
  /**
   * Optional. Rules that trigger alerts (notifications of thresholds
   * being crossed) when spend exceeds the specified percentages of the budget.
   *
   * Optional for `pubsubTopic` notifications.
   *
   * Required if using email notifications.
   */
  thresholdRules: ThresholdRule[];
  /**
   * Optional. Rules to apply to notifications sent based on budget spend and
   * thresholds.
   */
  allUpdatesRule:
    | AllUpdatesRule
    | undefined;
  /**
   * Optional. Etag to validate that the object is unchanged for a
   * read-modify-write operation.
   * An empty etag will cause an update to overwrite other changes.
   */
  etag: string;
}

/** The budgeted amount for each usage period. */
export interface BudgetAmount {
  /**
   * A specified amount to use as the budget.
   * `currency_code` is optional. If specified when creating a budget, it must
   * match the currency of the billing account. If specified when updating a
   * budget, it must match the currency_code of the existing budget.
   * The `currency_code` is provided on output.
   */
  specifiedAmount?:
    | Money
    | undefined;
  /**
   * Use the last period's actual spend as the budget for the present period.
   * LastPeriodAmount can only be set when the budget's time period is a
   * [Filter.calendar_period][google.cloud.billing.budgets.v1beta1.Filter.calendar_period].
   * It cannot be set in combination with
   * [Filter.custom_period][google.cloud.billing.budgets.v1beta1.Filter.custom_period].
   */
  lastPeriodAmount?: LastPeriodAmount | undefined;
}

/**
 * Describes a budget amount targeted to the last
 * [Filter.calendar_period][google.cloud.billing.budgets.v1beta1.Filter.calendar_period]
 * spend. At this time, the amount is automatically 100% of the last calendar
 * period's spend; that is, there are no other options yet.
 * Future configuration options will be described here (for example, configuring
 * a percentage of last period's spend).
 * LastPeriodAmount cannot be set for a budget configured with
 * a
 * [Filter.custom_period][google.cloud.billing.budgets.v1beta1.Filter.custom_period].
 */
export interface LastPeriodAmount {
}

/**
 * ThresholdRule contains the definition of a threshold. Threshold rules define
 * the triggering events used to generate a budget notification email. When a
 * threshold is crossed (spend exceeds the specified percentages of the
 * budget), budget alert emails are sent to the email recipients you specify
 * in the
 * [NotificationsRule](#notificationsrule).
 *
 * Threshold rules also affect the fields included in the
 * [JSON data
 * object](https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications#notification_format)
 * sent to a Pub/Sub topic.
 *
 * Threshold rules are _required_ if using email notifications.
 *
 * Threshold rules are _optional_ if only setting a
 * [`pubsubTopic` NotificationsRule](#NotificationsRule),
 * unless you want your JSON data object to include data about the thresholds
 * you set.
 *
 * For more information, see
 * [set budget threshold rules and
 * actions](https://cloud.google.com/billing/docs/how-to/budgets#budget-actions).
 */
export interface ThresholdRule {
  /**
   * Required. Send an alert when this threshold is exceeded.
   * This is a 1.0-based percentage, so 0.5 = 50%.
   * Validation: non-negative number.
   */
  thresholdPercent: number;
  /**
   * Optional. The type of basis used to determine if spend has passed the
   * threshold. Behavior defaults to CURRENT_SPEND if not set.
   */
  spendBasis: ThresholdRule_Basis;
}

/** The type of basis used to determine if spend has passed the threshold. */
export enum ThresholdRule_Basis {
  /** BASIS_UNSPECIFIED - Unspecified threshold basis. */
  BASIS_UNSPECIFIED = 0,
  /** CURRENT_SPEND - Use current spend as the basis for comparison against the threshold. */
  CURRENT_SPEND = 1,
  /**
   * FORECASTED_SPEND - Use forecasted spend for the period as the basis for comparison against
   * the threshold.
   * FORECASTED_SPEND can only be set when the budget's time period is a
   * [Filter.calendar_period][google.cloud.billing.budgets.v1beta1.Filter.calendar_period].
   * It cannot be set in combination with
   * [Filter.custom_period][google.cloud.billing.budgets.v1beta1.Filter.custom_period].
   */
  FORECASTED_SPEND = 2,
  UNRECOGNIZED = -1,
}

export function thresholdRule_BasisFromJSON(object: any): ThresholdRule_Basis {
  switch (object) {
    case 0:
    case "BASIS_UNSPECIFIED":
      return ThresholdRule_Basis.BASIS_UNSPECIFIED;
    case 1:
    case "CURRENT_SPEND":
      return ThresholdRule_Basis.CURRENT_SPEND;
    case 2:
    case "FORECASTED_SPEND":
      return ThresholdRule_Basis.FORECASTED_SPEND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThresholdRule_Basis.UNRECOGNIZED;
  }
}

export function thresholdRule_BasisToJSON(object: ThresholdRule_Basis): string {
  switch (object) {
    case ThresholdRule_Basis.BASIS_UNSPECIFIED:
      return "BASIS_UNSPECIFIED";
    case ThresholdRule_Basis.CURRENT_SPEND:
      return "CURRENT_SPEND";
    case ThresholdRule_Basis.FORECASTED_SPEND:
      return "FORECASTED_SPEND";
    case ThresholdRule_Basis.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AllUpdatesRule defines notifications that are sent based on budget spend
 * and thresholds.
 */
export interface AllUpdatesRule {
  /**
   * Optional. The name of the Pub/Sub topic where budget related messages will
   * be published, in the form `projects/{project_id}/topics/{topic_id}`.
   * Updates are sent at regular intervals to the topic. The topic needs to be
   * created before the budget is created; see
   * https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications
   * for more details.
   * Caller is expected to have
   * `pubsub.topics.setIamPolicy` permission on the topic when it's set for a
   * budget, otherwise, the API call will fail with PERMISSION_DENIED. See
   * https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications#permissions_required_for_this_task
   * for more details on Pub/Sub roles and permissions.
   */
  pubsubTopic: string;
  /**
   * Optional. Required when
   * [AllUpdatesRule.pubsub_topic][google.cloud.billing.budgets.v1beta1.AllUpdatesRule.pubsub_topic]
   * is set. The schema version of the notification sent to
   * [AllUpdatesRule.pubsub_topic][google.cloud.billing.budgets.v1beta1.AllUpdatesRule.pubsub_topic].
   * Only "1.0" is accepted. It represents the JSON schema as defined in
   * https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications#notification_format.
   */
  schemaVersion: string;
  /**
   * Optional. Targets to send notifications to when a threshold is exceeded.
   * This is in addition to default recipients who have billing account IAM
   * roles. The value is the full REST resource name of a monitoring
   * notification channel with the form
   * `projects/{project_id}/notificationChannels/{channel_id}`. A maximum of 5
   * channels are allowed. See
   * https://cloud.google.com/billing/docs/how-to/budgets-notification-recipients
   * for more details.
   */
  monitoringNotificationChannels: string[];
  /**
   * Optional. When set to true, disables default notifications sent when a
   * threshold is exceeded. Default notifications are sent to those with Billing
   * Account Administrator and Billing Account User IAM roles for the target
   * account.
   */
  disableDefaultIamRecipients: boolean;
  /**
   * Optional. When set to true, and when the budget has a single project
   * configured, notifications will be sent to project level recipients of that
   * project. This field will be ignored if the budget has multiple or no
   * project configured.
   *
   * Currently, project level recipients are the users with `Owner` role on a
   * cloud project.
   */
  enableProjectLevelRecipients: boolean;
}

/** A filter for a budget, limiting the scope of the cost to calculate. */
export interface Filter {
  /**
   * Optional. A set of projects of the form `projects/{project}`,
   * specifying that usage from only this set of projects should be
   * included in the budget. If omitted, the report will include all usage for
   * the billing account, regardless of which project the usage occurred on.
   */
  projects: string[];
  /**
   * Optional. A set of folder and organization names of the form
   * `folders/{folderId}` or `organizations/{organizationId}`, specifying that
   * usage from only this set of folders and organizations should be included in
   * the budget. If omitted, the budget includes all usage that the billing
   * account pays for. If the folder or organization contains projects that are
   * paid for by a different Cloud Billing account, the budget *doesn't* apply
   * to those projects.
   */
  resourceAncestors: string[];
  /**
   * Optional. If
   * [Filter.credit_types_treatment][google.cloud.billing.budgets.v1beta1.Filter.credit_types_treatment]
   * is INCLUDE_SPECIFIED_CREDITS, this is a list of credit types to be
   * subtracted from gross cost to determine the spend for threshold
   * calculations. See [a list of acceptable credit type
   * values](https://cloud.google.com/billing/docs/how-to/export-data-bigquery-tables#credits-type).
   *
   * If
   * [Filter.credit_types_treatment][google.cloud.billing.budgets.v1beta1.Filter.credit_types_treatment]
   * is **not** INCLUDE_SPECIFIED_CREDITS, this field must be empty.
   */
  creditTypes: string[];
  /** Optional. If not set, default behavior is `INCLUDE_ALL_CREDITS`. */
  creditTypesTreatment: Filter_CreditTypesTreatment;
  /**
   * Optional. A set of services of the form `services/{service_id}`,
   * specifying that usage from only this set of services should be
   * included in the budget. If omitted, the report will include usage for
   * all the services.
   * The service names are available through the Catalog API:
   * https://cloud.google.com/billing/v1/how-tos/catalog-api.
   */
  services: string[];
  /**
   * Optional. A set of subaccounts of the form `billingAccounts/{account_id}`,
   * specifying that usage from only this set of subaccounts should be included
   * in the budget. If a subaccount is set to the name of the parent account,
   * usage from the parent account will be included. If omitted, the
   * report will include usage from the parent account and all
   * subaccounts, if they exist.
   */
  subaccounts: string[];
  /**
   * Optional. A single label and value pair specifying that usage from only
   * this set of labeled resources should be included in the budget. If omitted,
   * the report will include all labeled and unlabeled usage.
   *
   * An object containing a single `"key": value` pair. Example: `{ "name":
   * "wrench" }`.
   *
   *  _Currently, multiple entries or multiple values per entry are not
   *  allowed._
   */
  labels: { [key: string]: Array<any> | undefined };
  /**
   * Optional. Specifies to track usage for recurring calendar period.
   * For example, assume that CalendarPeriod.QUARTER is set. The budget will
   * track usage from April 1 to June 30, when the current calendar month is
   * April, May, June. After that, it will track usage from July 1 to
   * September 30 when the current calendar month is July, August, September,
   * so on.
   */
  calendarPeriod?:
    | CalendarPeriod
    | undefined;
  /**
   * Optional. Specifies to track usage from any start date (required) to any
   * end date (optional). This time period is static, it does not recur.
   */
  customPeriod?: CustomPeriod | undefined;
}

/**
 * Specifies how credits are applied when determining the spend for
 * threshold calculations. Budgets track the total cost minus any applicable
 * selected credits.
 * [See the documentation for a list of credit
 * types](https://cloud.google.com/billing/docs/how-to/export-data-bigquery-tables#credits-type).
 */
export enum Filter_CreditTypesTreatment {
  CREDIT_TYPES_TREATMENT_UNSPECIFIED = 0,
  /**
   * INCLUDE_ALL_CREDITS - All types of credit are subtracted from the gross cost to determine the
   * spend for threshold calculations.
   */
  INCLUDE_ALL_CREDITS = 1,
  /**
   * EXCLUDE_ALL_CREDITS - All types of credit are added to the net cost to determine the spend for
   * threshold calculations.
   */
  EXCLUDE_ALL_CREDITS = 2,
  /**
   * INCLUDE_SPECIFIED_CREDITS - [Credit
   * types](https://cloud.google.com/billing/docs/how-to/export-data-bigquery-tables#credits-type)
   * specified in the credit_types field are subtracted from the
   * gross cost to determine the spend for threshold calculations.
   */
  INCLUDE_SPECIFIED_CREDITS = 3,
  UNRECOGNIZED = -1,
}

export function filter_CreditTypesTreatmentFromJSON(object: any): Filter_CreditTypesTreatment {
  switch (object) {
    case 0:
    case "CREDIT_TYPES_TREATMENT_UNSPECIFIED":
      return Filter_CreditTypesTreatment.CREDIT_TYPES_TREATMENT_UNSPECIFIED;
    case 1:
    case "INCLUDE_ALL_CREDITS":
      return Filter_CreditTypesTreatment.INCLUDE_ALL_CREDITS;
    case 2:
    case "EXCLUDE_ALL_CREDITS":
      return Filter_CreditTypesTreatment.EXCLUDE_ALL_CREDITS;
    case 3:
    case "INCLUDE_SPECIFIED_CREDITS":
      return Filter_CreditTypesTreatment.INCLUDE_SPECIFIED_CREDITS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Filter_CreditTypesTreatment.UNRECOGNIZED;
  }
}

export function filter_CreditTypesTreatmentToJSON(object: Filter_CreditTypesTreatment): string {
  switch (object) {
    case Filter_CreditTypesTreatment.CREDIT_TYPES_TREATMENT_UNSPECIFIED:
      return "CREDIT_TYPES_TREATMENT_UNSPECIFIED";
    case Filter_CreditTypesTreatment.INCLUDE_ALL_CREDITS:
      return "INCLUDE_ALL_CREDITS";
    case Filter_CreditTypesTreatment.EXCLUDE_ALL_CREDITS:
      return "EXCLUDE_ALL_CREDITS";
    case Filter_CreditTypesTreatment.INCLUDE_SPECIFIED_CREDITS:
      return "INCLUDE_SPECIFIED_CREDITS";
    case Filter_CreditTypesTreatment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Filter_LabelsEntry {
  key: string;
  value: Array<any> | undefined;
}

/** All date times begin at 12 AM US and Canadian Pacific Time (UTC-8). */
export interface CustomPeriod {
  /** Required. The start date must be after January 1, 2017. */
  startDate:
    | DateMessage
    | undefined;
  /**
   * Optional. The end date of the time period. Budgets with elapsed end date
   * won't be processed. If unset, specifies to track all usage incurred since
   * the start_date.
   */
  endDate: DateMessage | undefined;
}

function createBaseBudget(): Budget {
  return {
    name: "",
    displayName: "",
    budgetFilter: undefined,
    amount: undefined,
    thresholdRules: [],
    allUpdatesRule: undefined,
    etag: "",
  };
}

export const Budget: MessageFns<Budget> = {
  encode(message: Budget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.budgetFilter !== undefined) {
      Filter.encode(message.budgetFilter, writer.uint32(26).fork()).join();
    }
    if (message.amount !== undefined) {
      BudgetAmount.encode(message.amount, writer.uint32(34).fork()).join();
    }
    for (const v of message.thresholdRules) {
      ThresholdRule.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.allUpdatesRule !== undefined) {
      AllUpdatesRule.encode(message.allUpdatesRule, writer.uint32(50).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(58).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Budget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBudget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.budgetFilter = Filter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = BudgetAmount.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.thresholdRules.push(ThresholdRule.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.allUpdatesRule = AllUpdatesRule.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Budget {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      budgetFilter: isSet(object.budgetFilter) ? Filter.fromJSON(object.budgetFilter) : undefined,
      amount: isSet(object.amount) ? BudgetAmount.fromJSON(object.amount) : undefined,
      thresholdRules: globalThis.Array.isArray(object?.thresholdRules)
        ? object.thresholdRules.map((e: any) => ThresholdRule.fromJSON(e))
        : [],
      allUpdatesRule: isSet(object.allUpdatesRule) ? AllUpdatesRule.fromJSON(object.allUpdatesRule) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Budget): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.budgetFilter !== undefined) {
      obj.budgetFilter = Filter.toJSON(message.budgetFilter);
    }
    if (message.amount !== undefined) {
      obj.amount = BudgetAmount.toJSON(message.amount);
    }
    if (message.thresholdRules?.length) {
      obj.thresholdRules = message.thresholdRules.map((e) => ThresholdRule.toJSON(e));
    }
    if (message.allUpdatesRule !== undefined) {
      obj.allUpdatesRule = AllUpdatesRule.toJSON(message.allUpdatesRule);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Budget>): Budget {
    return Budget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Budget>): Budget {
    const message = createBaseBudget();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.budgetFilter = (object.budgetFilter !== undefined && object.budgetFilter !== null)
      ? Filter.fromPartial(object.budgetFilter)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? BudgetAmount.fromPartial(object.amount)
      : undefined;
    message.thresholdRules = object.thresholdRules?.map((e) => ThresholdRule.fromPartial(e)) || [];
    message.allUpdatesRule = (object.allUpdatesRule !== undefined && object.allUpdatesRule !== null)
      ? AllUpdatesRule.fromPartial(object.allUpdatesRule)
      : undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseBudgetAmount(): BudgetAmount {
  return { specifiedAmount: undefined, lastPeriodAmount: undefined };
}

export const BudgetAmount: MessageFns<BudgetAmount> = {
  encode(message: BudgetAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.specifiedAmount !== undefined) {
      Money.encode(message.specifiedAmount, writer.uint32(10).fork()).join();
    }
    if (message.lastPeriodAmount !== undefined) {
      LastPeriodAmount.encode(message.lastPeriodAmount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BudgetAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBudgetAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.specifiedAmount = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastPeriodAmount = LastPeriodAmount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BudgetAmount {
    return {
      specifiedAmount: isSet(object.specifiedAmount) ? Money.fromJSON(object.specifiedAmount) : undefined,
      lastPeriodAmount: isSet(object.lastPeriodAmount) ? LastPeriodAmount.fromJSON(object.lastPeriodAmount) : undefined,
    };
  },

  toJSON(message: BudgetAmount): unknown {
    const obj: any = {};
    if (message.specifiedAmount !== undefined) {
      obj.specifiedAmount = Money.toJSON(message.specifiedAmount);
    }
    if (message.lastPeriodAmount !== undefined) {
      obj.lastPeriodAmount = LastPeriodAmount.toJSON(message.lastPeriodAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<BudgetAmount>): BudgetAmount {
    return BudgetAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BudgetAmount>): BudgetAmount {
    const message = createBaseBudgetAmount();
    message.specifiedAmount = (object.specifiedAmount !== undefined && object.specifiedAmount !== null)
      ? Money.fromPartial(object.specifiedAmount)
      : undefined;
    message.lastPeriodAmount = (object.lastPeriodAmount !== undefined && object.lastPeriodAmount !== null)
      ? LastPeriodAmount.fromPartial(object.lastPeriodAmount)
      : undefined;
    return message;
  },
};

function createBaseLastPeriodAmount(): LastPeriodAmount {
  return {};
}

export const LastPeriodAmount: MessageFns<LastPeriodAmount> = {
  encode(_: LastPeriodAmount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastPeriodAmount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPeriodAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): LastPeriodAmount {
    return {};
  },

  toJSON(_: LastPeriodAmount): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<LastPeriodAmount>): LastPeriodAmount {
    return LastPeriodAmount.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<LastPeriodAmount>): LastPeriodAmount {
    const message = createBaseLastPeriodAmount();
    return message;
  },
};

function createBaseThresholdRule(): ThresholdRule {
  return { thresholdPercent: 0, spendBasis: 0 };
}

export const ThresholdRule: MessageFns<ThresholdRule> = {
  encode(message: ThresholdRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.thresholdPercent !== 0) {
      writer.uint32(9).double(message.thresholdPercent);
    }
    if (message.spendBasis !== 0) {
      writer.uint32(16).int32(message.spendBasis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThresholdRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThresholdRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.thresholdPercent = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.spendBasis = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThresholdRule {
    return {
      thresholdPercent: isSet(object.thresholdPercent) ? globalThis.Number(object.thresholdPercent) : 0,
      spendBasis: isSet(object.spendBasis) ? thresholdRule_BasisFromJSON(object.spendBasis) : 0,
    };
  },

  toJSON(message: ThresholdRule): unknown {
    const obj: any = {};
    if (message.thresholdPercent !== 0) {
      obj.thresholdPercent = message.thresholdPercent;
    }
    if (message.spendBasis !== 0) {
      obj.spendBasis = thresholdRule_BasisToJSON(message.spendBasis);
    }
    return obj;
  },

  create(base?: DeepPartial<ThresholdRule>): ThresholdRule {
    return ThresholdRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThresholdRule>): ThresholdRule {
    const message = createBaseThresholdRule();
    message.thresholdPercent = object.thresholdPercent ?? 0;
    message.spendBasis = object.spendBasis ?? 0;
    return message;
  },
};

function createBaseAllUpdatesRule(): AllUpdatesRule {
  return {
    pubsubTopic: "",
    schemaVersion: "",
    monitoringNotificationChannels: [],
    disableDefaultIamRecipients: false,
    enableProjectLevelRecipients: false,
  };
}

export const AllUpdatesRule: MessageFns<AllUpdatesRule> = {
  encode(message: AllUpdatesRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsubTopic !== "") {
      writer.uint32(10).string(message.pubsubTopic);
    }
    if (message.schemaVersion !== "") {
      writer.uint32(18).string(message.schemaVersion);
    }
    for (const v of message.monitoringNotificationChannels) {
      writer.uint32(26).string(v!);
    }
    if (message.disableDefaultIamRecipients !== false) {
      writer.uint32(32).bool(message.disableDefaultIamRecipients);
    }
    if (message.enableProjectLevelRecipients !== false) {
      writer.uint32(40).bool(message.enableProjectLevelRecipients);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllUpdatesRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUpdatesRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubTopic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.schemaVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.monitoringNotificationChannels.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.disableDefaultIamRecipients = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableProjectLevelRecipients = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUpdatesRule {
    return {
      pubsubTopic: isSet(object.pubsubTopic) ? globalThis.String(object.pubsubTopic) : "",
      schemaVersion: isSet(object.schemaVersion) ? globalThis.String(object.schemaVersion) : "",
      monitoringNotificationChannels: globalThis.Array.isArray(object?.monitoringNotificationChannels)
        ? object.monitoringNotificationChannels.map((e: any) => globalThis.String(e))
        : [],
      disableDefaultIamRecipients: isSet(object.disableDefaultIamRecipients)
        ? globalThis.Boolean(object.disableDefaultIamRecipients)
        : false,
      enableProjectLevelRecipients: isSet(object.enableProjectLevelRecipients)
        ? globalThis.Boolean(object.enableProjectLevelRecipients)
        : false,
    };
  },

  toJSON(message: AllUpdatesRule): unknown {
    const obj: any = {};
    if (message.pubsubTopic !== "") {
      obj.pubsubTopic = message.pubsubTopic;
    }
    if (message.schemaVersion !== "") {
      obj.schemaVersion = message.schemaVersion;
    }
    if (message.monitoringNotificationChannels?.length) {
      obj.monitoringNotificationChannels = message.monitoringNotificationChannels;
    }
    if (message.disableDefaultIamRecipients !== false) {
      obj.disableDefaultIamRecipients = message.disableDefaultIamRecipients;
    }
    if (message.enableProjectLevelRecipients !== false) {
      obj.enableProjectLevelRecipients = message.enableProjectLevelRecipients;
    }
    return obj;
  },

  create(base?: DeepPartial<AllUpdatesRule>): AllUpdatesRule {
    return AllUpdatesRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllUpdatesRule>): AllUpdatesRule {
    const message = createBaseAllUpdatesRule();
    message.pubsubTopic = object.pubsubTopic ?? "";
    message.schemaVersion = object.schemaVersion ?? "";
    message.monitoringNotificationChannels = object.monitoringNotificationChannels?.map((e) => e) || [];
    message.disableDefaultIamRecipients = object.disableDefaultIamRecipients ?? false;
    message.enableProjectLevelRecipients = object.enableProjectLevelRecipients ?? false;
    return message;
  },
};

function createBaseFilter(): Filter {
  return {
    projects: [],
    resourceAncestors: [],
    creditTypes: [],
    creditTypesTreatment: 0,
    services: [],
    subaccounts: [],
    labels: {},
    calendarPeriod: undefined,
    customPeriod: undefined,
  };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.projects) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.resourceAncestors) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.creditTypes) {
      writer.uint32(58).string(v!);
    }
    if (message.creditTypesTreatment !== 0) {
      writer.uint32(32).int32(message.creditTypesTreatment);
    }
    for (const v of message.services) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.subaccounts) {
      writer.uint32(42).string(v!);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      if (value !== undefined) {
        Filter_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
      }
    });
    if (message.calendarPeriod !== undefined) {
      writer.uint32(64).int32(message.calendarPeriod);
    }
    if (message.customPeriod !== undefined) {
      CustomPeriod.encode(message.customPeriod, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projects.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceAncestors.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creditTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.creditTypesTreatment = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.services.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subaccounts.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Filter_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.calendarPeriod = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.customPeriod = CustomPeriod.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      projects: globalThis.Array.isArray(object?.projects) ? object.projects.map((e: any) => globalThis.String(e)) : [],
      resourceAncestors: globalThis.Array.isArray(object?.resourceAncestors)
        ? object.resourceAncestors.map((e: any) => globalThis.String(e))
        : [],
      creditTypes: globalThis.Array.isArray(object?.creditTypes)
        ? object.creditTypes.map((e: any) => globalThis.String(e))
        : [],
      creditTypesTreatment: isSet(object.creditTypesTreatment)
        ? filter_CreditTypesTreatmentFromJSON(object.creditTypesTreatment)
        : 0,
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => globalThis.String(e)) : [],
      subaccounts: globalThis.Array.isArray(object?.subaccounts)
        ? object.subaccounts.map((e: any) => globalThis.String(e))
        : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: Array<any> | undefined }>((acc, [key, value]) => {
          acc[key] = value as Array<any> | undefined;
          return acc;
        }, {})
        : {},
      calendarPeriod: isSet(object.calendarPeriod) ? calendarPeriodFromJSON(object.calendarPeriod) : undefined,
      customPeriod: isSet(object.customPeriod) ? CustomPeriod.fromJSON(object.customPeriod) : undefined,
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.projects?.length) {
      obj.projects = message.projects;
    }
    if (message.resourceAncestors?.length) {
      obj.resourceAncestors = message.resourceAncestors;
    }
    if (message.creditTypes?.length) {
      obj.creditTypes = message.creditTypes;
    }
    if (message.creditTypesTreatment !== 0) {
      obj.creditTypesTreatment = filter_CreditTypesTreatmentToJSON(message.creditTypesTreatment);
    }
    if (message.services?.length) {
      obj.services = message.services;
    }
    if (message.subaccounts?.length) {
      obj.subaccounts = message.subaccounts;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.calendarPeriod !== undefined) {
      obj.calendarPeriod = calendarPeriodToJSON(message.calendarPeriod);
    }
    if (message.customPeriod !== undefined) {
      obj.customPeriod = CustomPeriod.toJSON(message.customPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.projects = object.projects?.map((e) => e) || [];
    message.resourceAncestors = object.resourceAncestors?.map((e) => e) || [];
    message.creditTypes = object.creditTypes?.map((e) => e) || [];
    message.creditTypesTreatment = object.creditTypesTreatment ?? 0;
    message.services = object.services?.map((e) => e) || [];
    message.subaccounts = object.subaccounts?.map((e) => e) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: Array<any> | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.calendarPeriod = object.calendarPeriod ?? undefined;
    message.customPeriod = (object.customPeriod !== undefined && object.customPeriod !== null)
      ? CustomPeriod.fromPartial(object.customPeriod)
      : undefined;
    return message;
  },
};

function createBaseFilter_LabelsEntry(): Filter_LabelsEntry {
  return { key: "", value: undefined };
}

export const Filter_LabelsEntry: MessageFns<Filter_LabelsEntry> = {
  encode(message: Filter_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ListValue.encode(ListValue.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: globalThis.Array.isArray(object.value) ? [...object.value] : undefined,
    };
  },

  toJSON(message: Filter_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Filter_LabelsEntry>): Filter_LabelsEntry {
    return Filter_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter_LabelsEntry>): Filter_LabelsEntry {
    const message = createBaseFilter_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseCustomPeriod(): CustomPeriod {
  return { startDate: undefined, endDate: undefined };
}

export const CustomPeriod: MessageFns<CustomPeriod> = {
  encode(message: CustomPeriod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== undefined) {
      DateMessage.encode(message.startDate, writer.uint32(10).fork()).join();
    }
    if (message.endDate !== undefined) {
      DateMessage.encode(message.endDate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomPeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomPeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomPeriod {
    return {
      startDate: isSet(object.startDate) ? DateMessage.fromJSON(object.startDate) : undefined,
      endDate: isSet(object.endDate) ? DateMessage.fromJSON(object.endDate) : undefined,
    };
  },

  toJSON(message: CustomPeriod): unknown {
    const obj: any = {};
    if (message.startDate !== undefined) {
      obj.startDate = DateMessage.toJSON(message.startDate);
    }
    if (message.endDate !== undefined) {
      obj.endDate = DateMessage.toJSON(message.endDate);
    }
    return obj;
  },

  create(base?: DeepPartial<CustomPeriod>): CustomPeriod {
    return CustomPeriod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomPeriod>): CustomPeriod {
    const message = createBaseCustomPeriod();
    message.startDate = (object.startDate !== undefined && object.startDate !== null)
      ? DateMessage.fromPartial(object.startDate)
      : undefined;
    message.endDate = (object.endDate !== undefined && object.endDate !== null)
      ? DateMessage.fromPartial(object.endDate)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
