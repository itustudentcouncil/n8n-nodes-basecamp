// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datastream/v1alpha1/datastream_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.datastream.v1alpha1";

/**
 * File format in Cloud Storage.
 *
 * @deprecated
 */
export enum GcsFileFormat {
  /** GCS_FILE_FORMAT_UNSPECIFIED - Unspecified Cloud Storage file format. */
  GCS_FILE_FORMAT_UNSPECIFIED = 0,
  /** AVRO - Avro file format */
  AVRO = 1,
  UNRECOGNIZED = -1,
}

export function gcsFileFormatFromJSON(object: any): GcsFileFormat {
  switch (object) {
    case 0:
    case "GCS_FILE_FORMAT_UNSPECIFIED":
      return GcsFileFormat.GCS_FILE_FORMAT_UNSPECIFIED;
    case 1:
    case "AVRO":
      return GcsFileFormat.AVRO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GcsFileFormat.UNRECOGNIZED;
  }
}

export function gcsFileFormatToJSON(object: GcsFileFormat): string {
  switch (object) {
    case GcsFileFormat.GCS_FILE_FORMAT_UNSPECIFIED:
      return "GCS_FILE_FORMAT_UNSPECIFIED";
    case GcsFileFormat.AVRO:
      return "AVRO";
    case GcsFileFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Schema file format. */
export enum SchemaFileFormat {
  /** SCHEMA_FILE_FORMAT_UNSPECIFIED - Unspecified schema file format. */
  SCHEMA_FILE_FORMAT_UNSPECIFIED = 0,
  /** NO_SCHEMA_FILE - Do not attach schema file. */
  NO_SCHEMA_FILE = 1,
  /** AVRO_SCHEMA_FILE - Avro schema format. */
  AVRO_SCHEMA_FILE = 2,
  UNRECOGNIZED = -1,
}

export function schemaFileFormatFromJSON(object: any): SchemaFileFormat {
  switch (object) {
    case 0:
    case "SCHEMA_FILE_FORMAT_UNSPECIFIED":
      return SchemaFileFormat.SCHEMA_FILE_FORMAT_UNSPECIFIED;
    case 1:
    case "NO_SCHEMA_FILE":
      return SchemaFileFormat.NO_SCHEMA_FILE;
    case 2:
    case "AVRO_SCHEMA_FILE":
      return SchemaFileFormat.AVRO_SCHEMA_FILE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SchemaFileFormat.UNRECOGNIZED;
  }
}

export function schemaFileFormatToJSON(object: SchemaFileFormat): string {
  switch (object) {
    case SchemaFileFormat.SCHEMA_FILE_FORMAT_UNSPECIFIED:
      return "SCHEMA_FILE_FORMAT_UNSPECIFIED";
    case SchemaFileFormat.NO_SCHEMA_FILE:
      return "NO_SCHEMA_FILE";
    case SchemaFileFormat.AVRO_SCHEMA_FILE:
      return "AVRO_SCHEMA_FILE";
    case SchemaFileFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Oracle database profile. */
export interface OracleProfile {
  /** Required. Hostname for the Oracle connection. */
  hostname: string;
  /** Port for the Oracle connection, default value is 1521. */
  port: number;
  /** Required. Username for the Oracle connection. */
  username: string;
  /** Required. Password for the Oracle connection. */
  password: string;
  /** Required. Database for the Oracle connection. */
  databaseService: string;
  /** Connection string attributes */
  connectionAttributes: { [key: string]: string };
}

export interface OracleProfile_ConnectionAttributesEntry {
  key: string;
  value: string;
}

/** MySQL database profile. */
export interface MysqlProfile {
  /** Required. Hostname for the MySQL connection. */
  hostname: string;
  /** Port for the MySQL connection, default value is 3306. */
  port: number;
  /** Required. Username for the MySQL connection. */
  username: string;
  /** Required. Input only. Password for the MySQL connection. */
  password: string;
  /** SSL configuration for the MySQL connection. */
  sslConfig: MysqlSslConfig | undefined;
}

/** Cloud Storage bucket profile. */
export interface GcsProfile {
  /**
   * Required. The full project and resource path for Cloud Storage bucket including the
   * name.
   */
  bucketName: string;
  /** The root path inside the Cloud Storage bucket. */
  rootPath: string;
}

/** No connectivity settings. */
export interface NoConnectivitySettings {
}

/** Static IP address connectivity. */
export interface StaticServiceIpConnectivity {
}

/** Forward SSH Tunnel connectivity. */
export interface ForwardSshTunnelConnectivity {
  /** Required. Hostname for the SSH tunnel. */
  hostname: string;
  /** Required. Username for the SSH tunnel. */
  username: string;
  /** Port for the SSH tunnel, default value is 22. */
  port: number;
  /** Input only. SSH password. */
  password?:
    | string
    | undefined;
  /** Input only. SSH private key. */
  privateKey?: string | undefined;
}

/**
 * The VPC Peering configuration is used to create VPC peering between
 * Datastream and the consumer's VPC.
 */
export interface VpcPeeringConfig {
  /** Required. fully qualified name of the VPC Datastream will peer to. */
  vpcName: string;
  /** Required. A free subnet for peering. (CIDR of /29) */
  subnet: string;
}

/**
 * The PrivateConnection resource is used to establish private connectivity
 * between Datastream and a customer's network.
 */
export interface PrivateConnection {
  /** Output only. The resource's name. */
  name: string;
  /** Output only. The create time of the resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time of the resource. */
  updateTime:
    | Date
    | undefined;
  /** Labels. */
  labels: { [key: string]: string };
  /** Required. Display name. */
  displayName: string;
  /** Output only. The state of the Private Connection. */
  state: PrivateConnection_State;
  /** Output only. In case of error, the details of the error in a user-friendly format. */
  error:
    | Error
    | undefined;
  /** VPC Peering Config */
  vpcPeeringConfig: VpcPeeringConfig | undefined;
}

/** Private Connection state. */
export enum PrivateConnection_State {
  STATE_UNSPECIFIED = 0,
  /** CREATING - The private connection is in creation state - creating resources. */
  CREATING = 1,
  /** CREATED - The private connection has been created with all of it's resources. */
  CREATED = 2,
  /** FAILED - The private connection creation has failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function privateConnection_StateFromJSON(object: any): PrivateConnection_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PrivateConnection_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return PrivateConnection_State.CREATING;
    case 2:
    case "CREATED":
      return PrivateConnection_State.CREATED;
    case 3:
    case "FAILED":
      return PrivateConnection_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateConnection_State.UNRECOGNIZED;
  }
}

export function privateConnection_StateToJSON(object: PrivateConnection_State): string {
  switch (object) {
    case PrivateConnection_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PrivateConnection_State.CREATING:
      return "CREATING";
    case PrivateConnection_State.CREATED:
      return "CREATED";
    case PrivateConnection_State.FAILED:
      return "FAILED";
    case PrivateConnection_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PrivateConnection_LabelsEntry {
  key: string;
  value: string;
}

/** Private Connectivity */
export interface PrivateConnectivity {
  privateConnectionName: string;
}

/**
 * The Route resource is the child of the PrivateConnection resource.
 * It used to define a route for a PrivateConnection setup.
 */
export interface Route {
  /** Output only. The resource's name. */
  name: string;
  /** Output only. The create time of the resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time of the resource. */
  updateTime:
    | Date
    | undefined;
  /** Labels. */
  labels: { [key: string]: string };
  /** Required. Display name. */
  displayName: string;
  /** Required. Destination address for connection */
  destinationAddress: string;
  /** Destination port for connection */
  destinationPort: number;
}

export interface Route_LabelsEntry {
  key: string;
  value: string;
}

/** MySQL SSL configuration information. */
export interface MysqlSslConfig {
  /**
   * Input only. PEM-encoded private key associated with the Client Certificate.
   * If this field is used then the 'client_certificate' and the
   * 'ca_certificate' fields are mandatory.
   */
  clientKey: string;
  /** Output only. Indicates whether the client_key field is set. */
  clientKeySet: boolean;
  /**
   * Input only. PEM-encoded certificate that will be used by the replica to
   * authenticate against the source database server. If this field is used
   * then the 'client_key' and the 'ca_certificate' fields are mandatory.
   */
  clientCertificate: string;
  /** Output only. Indicates whether the client_certificate field is set. */
  clientCertificateSet: boolean;
  /**
   * Input only. PEM-encoded certificate of the CA that signed the source database
   * server's certificate.
   */
  caCertificate: string;
  /** Output only. Indicates whether the ca_certificate field is set. */
  caCertificateSet: boolean;
}

export interface ConnectionProfile {
  /** Output only. The resource's name. */
  name: string;
  /** Output only. The create time of the resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update time of the resource. */
  updateTime:
    | Date
    | undefined;
  /** Labels. */
  labels: { [key: string]: string };
  /** Required. Display name. */
  displayName: string;
  /** Oracle ConnectionProfile configuration. */
  oracleProfile?:
    | OracleProfile
    | undefined;
  /** Cloud Storage ConnectionProfile configuration. */
  gcsProfile?:
    | GcsProfile
    | undefined;
  /** MySQL ConnectionProfile configuration. */
  mysqlProfile?:
    | MysqlProfile
    | undefined;
  /** No connectivity option chosen. */
  noConnectivity?:
    | NoConnectivitySettings
    | undefined;
  /** Static Service IP connectivity. */
  staticServiceIpConnectivity?:
    | StaticServiceIpConnectivity
    | undefined;
  /** Forward SSH tunnel connectivity. */
  forwardSshConnectivity?:
    | ForwardSshTunnelConnectivity
    | undefined;
  /** Private connectivity. */
  privateConnectivity?: PrivateConnectivity | undefined;
}

export interface ConnectionProfile_LabelsEntry {
  key: string;
  value: string;
}

/** Oracle Column. */
export interface OracleColumn {
  /** Column name. */
  columnName: string;
  /** The Oracle data type. */
  dataType: string;
  /** Column length. */
  length: number;
  /** Column precision. */
  precision: number;
  /** Column scale. */
  scale: number;
  /** Column encoding. */
  encoding: string;
  /** Whether or not the column represents a primary key. */
  primaryKey: boolean;
  /** Whether or not the column can accept a null value. */
  nullable: boolean;
  /** The ordinal position of the column in the table. */
  ordinalPosition: number;
}

/** Oracle table. */
export interface OracleTable {
  /** Table name. */
  tableName: string;
  /**
   * Oracle columns in the schema.
   * When unspecified as part of inclue/exclude lists, includes/excludes
   * everything.
   */
  oracleColumns: OracleColumn[];
}

/** Oracle schema. */
export interface OracleSchema {
  /** Schema name. */
  schemaName: string;
  /** Tables in the schema. */
  oracleTables: OracleTable[];
}

/** Oracle database structure. */
export interface OracleRdbms {
  /** Oracle schemas/databases in the database server. */
  oracleSchemas: OracleSchema[];
}

/** Oracle data source configuration */
export interface OracleSourceConfig {
  /** Oracle objects to include in the stream. */
  allowlist:
    | OracleRdbms
    | undefined;
  /** Oracle objects to exclude from the stream. */
  rejectlist: OracleRdbms | undefined;
}

/** MySQL Column. */
export interface MysqlColumn {
  /** Column name. */
  columnName: string;
  /**
   * The MySQL data type. Full data types list can be found here:
   * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
   */
  dataType: string;
  /** Column length. */
  length: number;
  /** Column collation. */
  collation: string;
  /** Whether or not the column represents a primary key. */
  primaryKey: boolean;
  /** Whether or not the column can accept a null value. */
  nullable: boolean;
  /** The ordinal position of the column in the table. */
  ordinalPosition: number;
}

/** MySQL table. */
export interface MysqlTable {
  /** Table name. */
  tableName: string;
  /**
   * MySQL columns in the database.
   * When unspecified as part of include/exclude lists, includes/excludes
   * everything.
   */
  mysqlColumns: MysqlColumn[];
}

/** MySQL database. */
export interface MysqlDatabase {
  /** Database name. */
  databaseName: string;
  /** Tables in the database. */
  mysqlTables: MysqlTable[];
}

/** MySQL database structure */
export interface MysqlRdbms {
  /** Mysql databases on the server */
  mysqlDatabases: MysqlDatabase[];
}

/** MySQL source configuration */
export interface MysqlSourceConfig {
  /** MySQL objects to retrieve from the source. */
  allowlist:
    | MysqlRdbms
    | undefined;
  /** MySQL objects to exclude from the stream. */
  rejectlist: MysqlRdbms | undefined;
}

/** The configuration of the stream source. */
export interface SourceConfig {
  /** Required. Source connection profile identifier. */
  sourceConnectionProfileName: string;
  /** Oracle data source configuration */
  oracleSourceConfig?:
    | OracleSourceConfig
    | undefined;
  /** MySQL data source configuration */
  mysqlSourceConfig?: MysqlSourceConfig | undefined;
}

/** AVRO file format configuration. */
export interface AvroFileFormat {
}

/** JSON file format configuration. */
export interface JsonFileFormat {
  /** The schema file format along JSON data files. */
  schemaFileFormat: SchemaFileFormat;
  /** Compression of the loaded JSON file. */
  compression: JsonFileFormat_JsonCompression;
}

/** Json file compression. */
export enum JsonFileFormat_JsonCompression {
  /** JSON_COMPRESSION_UNSPECIFIED - Unspecified json file compression. */
  JSON_COMPRESSION_UNSPECIFIED = 0,
  /** NO_COMPRESSION - Do not compress JSON file. */
  NO_COMPRESSION = 1,
  /** GZIP - Gzip compression. */
  GZIP = 2,
  UNRECOGNIZED = -1,
}

export function jsonFileFormat_JsonCompressionFromJSON(object: any): JsonFileFormat_JsonCompression {
  switch (object) {
    case 0:
    case "JSON_COMPRESSION_UNSPECIFIED":
      return JsonFileFormat_JsonCompression.JSON_COMPRESSION_UNSPECIFIED;
    case 1:
    case "NO_COMPRESSION":
      return JsonFileFormat_JsonCompression.NO_COMPRESSION;
    case 2:
    case "GZIP":
      return JsonFileFormat_JsonCompression.GZIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JsonFileFormat_JsonCompression.UNRECOGNIZED;
  }
}

export function jsonFileFormat_JsonCompressionToJSON(object: JsonFileFormat_JsonCompression): string {
  switch (object) {
    case JsonFileFormat_JsonCompression.JSON_COMPRESSION_UNSPECIFIED:
      return "JSON_COMPRESSION_UNSPECIFIED";
    case JsonFileFormat_JsonCompression.NO_COMPRESSION:
      return "NO_COMPRESSION";
    case JsonFileFormat_JsonCompression.GZIP:
      return "GZIP";
    case JsonFileFormat_JsonCompression.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Google Cloud Storage destination configuration */
export interface GcsDestinationConfig {
  /** Path inside the Cloud Storage bucket to write data to. */
  path: string;
  /**
   * File format that data should be written in.
   * Deprecated field - use file_format instead.
   *
   * @deprecated
   */
  gcsFileFormat: GcsFileFormat;
  /** The maximum file size to be saved in the bucket. */
  fileRotationMb: number;
  /**
   * The maximum duration for which new events are added before a file is
   * closed and a new file is created.
   */
  fileRotationInterval:
    | Duration
    | undefined;
  /** AVRO file format configuration. */
  avroFileFormat?:
    | AvroFileFormat
    | undefined;
  /** JSON file format configuration. */
  jsonFileFormat?: JsonFileFormat | undefined;
}

/** The configuration of the stream destination. */
export interface DestinationConfig {
  /** Required. Destination connection profile identifier. */
  destinationConnectionProfileName: string;
  gcsDestinationConfig?: GcsDestinationConfig | undefined;
}

export interface Stream {
  /** Output only. The stream's name. */
  name: string;
  /** Output only. The creation time of the stream. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update time of the stream. */
  updateTime:
    | Date
    | undefined;
  /** Labels. */
  labels: { [key: string]: string };
  /** Required. Display name. */
  displayName: string;
  /** Required. Source connection profile configuration. */
  sourceConfig:
    | SourceConfig
    | undefined;
  /** Required. Destination connection profile configuration. */
  destinationConfig:
    | DestinationConfig
    | undefined;
  /** The state of the stream. */
  state: Stream_State;
  /**
   * Automatically backfill objects included in the stream source
   * configuration. Specific objects can be excluded.
   */
  backfillAll?:
    | Stream_BackfillAllStrategy
    | undefined;
  /** Do not automatically backfill any objects. */
  backfillNone?:
    | Stream_BackfillNoneStrategy
    | undefined;
  /** Output only. Errors on the Stream. */
  errors: Error[];
}

/** Stream state. */
export enum Stream_State {
  /** STATE_UNSPECIFIED - Unspecified stream state. */
  STATE_UNSPECIFIED = 0,
  /** CREATED - The stream has been created. */
  CREATED = 1,
  /** RUNNING - The stream is running. */
  RUNNING = 2,
  /** PAUSED - The stream is paused. */
  PAUSED = 3,
  /**
   * MAINTENANCE - The stream is in maintenance mode.
   *
   * Updates are rejected on the resource in this state.
   */
  MAINTENANCE = 4,
  /**
   * FAILED - The stream is experiencing an error that is preventing data from being
   * streamed.
   */
  FAILED = 5,
  /** FAILED_PERMANENTLY - The stream has experienced a terminal failure. */
  FAILED_PERMANENTLY = 6,
  /** STARTING - The stream is starting, but not yet running. */
  STARTING = 7,
  /**
   * DRAINING - The Stream is no longer reading new events, but still writing events in
   * the buffer.
   */
  DRAINING = 8,
  UNRECOGNIZED = -1,
}

export function stream_StateFromJSON(object: any): Stream_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Stream_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATED":
      return Stream_State.CREATED;
    case 2:
    case "RUNNING":
      return Stream_State.RUNNING;
    case 3:
    case "PAUSED":
      return Stream_State.PAUSED;
    case 4:
    case "MAINTENANCE":
      return Stream_State.MAINTENANCE;
    case 5:
    case "FAILED":
      return Stream_State.FAILED;
    case 6:
    case "FAILED_PERMANENTLY":
      return Stream_State.FAILED_PERMANENTLY;
    case 7:
    case "STARTING":
      return Stream_State.STARTING;
    case 8:
    case "DRAINING":
      return Stream_State.DRAINING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Stream_State.UNRECOGNIZED;
  }
}

export function stream_StateToJSON(object: Stream_State): string {
  switch (object) {
    case Stream_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Stream_State.CREATED:
      return "CREATED";
    case Stream_State.RUNNING:
      return "RUNNING";
    case Stream_State.PAUSED:
      return "PAUSED";
    case Stream_State.MAINTENANCE:
      return "MAINTENANCE";
    case Stream_State.FAILED:
      return "FAILED";
    case Stream_State.FAILED_PERMANENTLY:
      return "FAILED_PERMANENTLY";
    case Stream_State.STARTING:
      return "STARTING";
    case Stream_State.DRAINING:
      return "DRAINING";
    case Stream_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Backfill strategy to automatically backfill the Stream's objects.
 * Specific objects can be excluded.
 */
export interface Stream_BackfillAllStrategy {
  /** Oracle data source objects to avoid backfilling. */
  oracleExcludedObjects?:
    | OracleRdbms
    | undefined;
  /** MySQL data source objects to avoid backfilling. */
  mysqlExcludedObjects?: MysqlRdbms | undefined;
}

/** Backfill strategy to disable automatic backfill for the Stream's objects. */
export interface Stream_BackfillNoneStrategy {
}

export interface Stream_LabelsEntry {
  key: string;
  value: string;
}

/** Represent a user-facing Error. */
export interface Error {
  /** A title that explains the reason for the error. */
  reason: string;
  /**
   * A unique identifier for this specific error,
   * allowing it to be traced throughout the system in logs and API responses.
   */
  errorUuid: string;
  /** A message containing more information about the error that occurred. */
  message: string;
  /** The time when the error occurred. */
  errorTime:
    | Date
    | undefined;
  /** Additional information about the error. */
  details: { [key: string]: string };
}

export interface Error_DetailsEntry {
  key: string;
  value: string;
}

/** Contains the current validation results. */
export interface ValidationResult {
  /**
   * A list of validations (includes both executed as well as not executed
   * validations).
   */
  validations: Validation[];
}

export interface Validation {
  /** A short description of the validation. */
  description: string;
  /** Validation execution status. */
  status: Validation_Status;
  /** Messages reflecting the validation results. */
  message: ValidationMessage[];
  /** A custom code identifying this validation. */
  code: string;
}

/** Validation execution status. */
export enum Validation_Status {
  /** STATUS_UNSPECIFIED - Unspecified status. */
  STATUS_UNSPECIFIED = 0,
  /** NOT_EXECUTED - Validation did not execute. */
  NOT_EXECUTED = 1,
  /** FAILED - Validation failed. */
  FAILED = 2,
  /** PASSED - Validation passed. */
  PASSED = 3,
  UNRECOGNIZED = -1,
}

export function validation_StatusFromJSON(object: any): Validation_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Validation_Status.STATUS_UNSPECIFIED;
    case 1:
    case "NOT_EXECUTED":
      return Validation_Status.NOT_EXECUTED;
    case 2:
    case "FAILED":
      return Validation_Status.FAILED;
    case 3:
    case "PASSED":
      return Validation_Status.PASSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Validation_Status.UNRECOGNIZED;
  }
}

export function validation_StatusToJSON(object: Validation_Status): string {
  switch (object) {
    case Validation_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Validation_Status.NOT_EXECUTED:
      return "NOT_EXECUTED";
    case Validation_Status.FAILED:
      return "FAILED";
    case Validation_Status.PASSED:
      return "PASSED";
    case Validation_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent user-facing validation result message. */
export interface ValidationMessage {
  /** The result of the validation. */
  message: string;
  /** Message severity level (warning or error). */
  level: ValidationMessage_Level;
  /** Additional metadata related to the result. */
  metadata: { [key: string]: string };
  /** A custom code identifying this specific message. */
  code: string;
}

/** Validation message level. */
export enum ValidationMessage_Level {
  /** LEVEL_UNSPECIFIED - Unspecified level. */
  LEVEL_UNSPECIFIED = 0,
  /** WARNING - Potentially cause issues with the Stream. */
  WARNING = 1,
  /** ERROR - Definitely cause issues with the Stream. */
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function validationMessage_LevelFromJSON(object: any): ValidationMessage_Level {
  switch (object) {
    case 0:
    case "LEVEL_UNSPECIFIED":
      return ValidationMessage_Level.LEVEL_UNSPECIFIED;
    case 1:
    case "WARNING":
      return ValidationMessage_Level.WARNING;
    case 2:
    case "ERROR":
      return ValidationMessage_Level.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ValidationMessage_Level.UNRECOGNIZED;
  }
}

export function validationMessage_LevelToJSON(object: ValidationMessage_Level): string {
  switch (object) {
    case ValidationMessage_Level.LEVEL_UNSPECIFIED:
      return "LEVEL_UNSPECIFIED";
    case ValidationMessage_Level.WARNING:
      return "WARNING";
    case ValidationMessage_Level.ERROR:
      return "ERROR";
    case ValidationMessage_Level.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ValidationMessage_MetadataEntry {
  key: string;
  value: string;
}

function createBaseOracleProfile(): OracleProfile {
  return { hostname: "", port: 0, username: "", password: "", databaseService: "", connectionAttributes: {} };
}

export const OracleProfile: MessageFns<OracleProfile> = {
  encode(message: OracleProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.databaseService !== "") {
      writer.uint32(42).string(message.databaseService);
    }
    Object.entries(message.connectionAttributes).forEach(([key, value]) => {
      OracleProfile_ConnectionAttributesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.databaseService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = OracleProfile_ConnectionAttributesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.connectionAttributes[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleProfile {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      databaseService: isSet(object.databaseService) ? globalThis.String(object.databaseService) : "",
      connectionAttributes: isObject(object.connectionAttributes)
        ? Object.entries(object.connectionAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: OracleProfile): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.databaseService !== "") {
      obj.databaseService = message.databaseService;
    }
    if (message.connectionAttributes) {
      const entries = Object.entries(message.connectionAttributes);
      if (entries.length > 0) {
        obj.connectionAttributes = {};
        entries.forEach(([k, v]) => {
          obj.connectionAttributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<OracleProfile>): OracleProfile {
    return OracleProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleProfile>): OracleProfile {
    const message = createBaseOracleProfile();
    message.hostname = object.hostname ?? "";
    message.port = object.port ?? 0;
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.databaseService = object.databaseService ?? "";
    message.connectionAttributes = Object.entries(object.connectionAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseOracleProfile_ConnectionAttributesEntry(): OracleProfile_ConnectionAttributesEntry {
  return { key: "", value: "" };
}

export const OracleProfile_ConnectionAttributesEntry: MessageFns<OracleProfile_ConnectionAttributesEntry> = {
  encode(message: OracleProfile_ConnectionAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleProfile_ConnectionAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleProfile_ConnectionAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleProfile_ConnectionAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OracleProfile_ConnectionAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OracleProfile_ConnectionAttributesEntry>): OracleProfile_ConnectionAttributesEntry {
    return OracleProfile_ConnectionAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleProfile_ConnectionAttributesEntry>): OracleProfile_ConnectionAttributesEntry {
    const message = createBaseOracleProfile_ConnectionAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMysqlProfile(): MysqlProfile {
  return { hostname: "", port: 0, username: "", password: "", sslConfig: undefined };
}

export const MysqlProfile: MessageFns<MysqlProfile> = {
  encode(message: MysqlProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    if (message.sslConfig !== undefined) {
      MysqlSslConfig.encode(message.sslConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sslConfig = MysqlSslConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlProfile {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      sslConfig: isSet(object.sslConfig) ? MysqlSslConfig.fromJSON(object.sslConfig) : undefined,
    };
  },

  toJSON(message: MysqlProfile): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.sslConfig !== undefined) {
      obj.sslConfig = MysqlSslConfig.toJSON(message.sslConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlProfile>): MysqlProfile {
    return MysqlProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlProfile>): MysqlProfile {
    const message = createBaseMysqlProfile();
    message.hostname = object.hostname ?? "";
    message.port = object.port ?? 0;
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.sslConfig = (object.sslConfig !== undefined && object.sslConfig !== null)
      ? MysqlSslConfig.fromPartial(object.sslConfig)
      : undefined;
    return message;
  },
};

function createBaseGcsProfile(): GcsProfile {
  return { bucketName: "", rootPath: "" };
}

export const GcsProfile: MessageFns<GcsProfile> = {
  encode(message: GcsProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.rootPath !== "") {
      writer.uint32(18).string(message.rootPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rootPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsProfile {
    return {
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : "",
      rootPath: isSet(object.rootPath) ? globalThis.String(object.rootPath) : "",
    };
  },

  toJSON(message: GcsProfile): unknown {
    const obj: any = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.rootPath !== "") {
      obj.rootPath = message.rootPath;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsProfile>): GcsProfile {
    return GcsProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsProfile>): GcsProfile {
    const message = createBaseGcsProfile();
    message.bucketName = object.bucketName ?? "";
    message.rootPath = object.rootPath ?? "";
    return message;
  },
};

function createBaseNoConnectivitySettings(): NoConnectivitySettings {
  return {};
}

export const NoConnectivitySettings: MessageFns<NoConnectivitySettings> = {
  encode(_: NoConnectivitySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NoConnectivitySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoConnectivitySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NoConnectivitySettings {
    return {};
  },

  toJSON(_: NoConnectivitySettings): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<NoConnectivitySettings>): NoConnectivitySettings {
    return NoConnectivitySettings.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<NoConnectivitySettings>): NoConnectivitySettings {
    const message = createBaseNoConnectivitySettings();
    return message;
  },
};

function createBaseStaticServiceIpConnectivity(): StaticServiceIpConnectivity {
  return {};
}

export const StaticServiceIpConnectivity: MessageFns<StaticServiceIpConnectivity> = {
  encode(_: StaticServiceIpConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StaticServiceIpConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStaticServiceIpConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StaticServiceIpConnectivity {
    return {};
  },

  toJSON(_: StaticServiceIpConnectivity): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StaticServiceIpConnectivity>): StaticServiceIpConnectivity {
    return StaticServiceIpConnectivity.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StaticServiceIpConnectivity>): StaticServiceIpConnectivity {
    const message = createBaseStaticServiceIpConnectivity();
    return message;
  },
};

function createBaseForwardSshTunnelConnectivity(): ForwardSshTunnelConnectivity {
  return { hostname: "", username: "", port: 0, password: undefined, privateKey: undefined };
}

export const ForwardSshTunnelConnectivity: MessageFns<ForwardSshTunnelConnectivity> = {
  encode(message: ForwardSshTunnelConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    if (message.password !== undefined) {
      writer.uint32(802).string(message.password);
    }
    if (message.privateKey !== undefined) {
      writer.uint32(810).string(message.privateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardSshTunnelConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardSshTunnelConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.password = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.privateKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardSshTunnelConnectivity {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      privateKey: isSet(object.privateKey) ? globalThis.String(object.privateKey) : undefined,
    };
  },

  toJSON(message: ForwardSshTunnelConnectivity): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.privateKey !== undefined) {
      obj.privateKey = message.privateKey;
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardSshTunnelConnectivity>): ForwardSshTunnelConnectivity {
    return ForwardSshTunnelConnectivity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardSshTunnelConnectivity>): ForwardSshTunnelConnectivity {
    const message = createBaseForwardSshTunnelConnectivity();
    message.hostname = object.hostname ?? "";
    message.username = object.username ?? "";
    message.port = object.port ?? 0;
    message.password = object.password ?? undefined;
    message.privateKey = object.privateKey ?? undefined;
    return message;
  },
};

function createBaseVpcPeeringConfig(): VpcPeeringConfig {
  return { vpcName: "", subnet: "" };
}

export const VpcPeeringConfig: MessageFns<VpcPeeringConfig> = {
  encode(message: VpcPeeringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vpcName !== "") {
      writer.uint32(10).string(message.vpcName);
    }
    if (message.subnet !== "") {
      writer.uint32(18).string(message.subnet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcPeeringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcPeeringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vpcName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcPeeringConfig {
    return {
      vpcName: isSet(object.vpcName) ? globalThis.String(object.vpcName) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
    };
  },

  toJSON(message: VpcPeeringConfig): unknown {
    const obj: any = {};
    if (message.vpcName !== "") {
      obj.vpcName = message.vpcName;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    return obj;
  },

  create(base?: DeepPartial<VpcPeeringConfig>): VpcPeeringConfig {
    return VpcPeeringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcPeeringConfig>): VpcPeeringConfig {
    const message = createBaseVpcPeeringConfig();
    message.vpcName = object.vpcName ?? "";
    message.subnet = object.subnet ?? "";
    return message;
  },
};

function createBasePrivateConnection(): PrivateConnection {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    state: 0,
    error: undefined,
    vpcPeeringConfig: undefined,
  };
}

export const PrivateConnection: MessageFns<PrivateConnection> = {
  encode(message: PrivateConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      PrivateConnection_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(58).fork()).join();
    }
    if (message.vpcPeeringConfig !== undefined) {
      VpcPeeringConfig.encode(message.vpcPeeringConfig, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = PrivateConnection_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.vpcPeeringConfig = VpcPeeringConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? privateConnection_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      vpcPeeringConfig: isSet(object.vpcPeeringConfig) ? VpcPeeringConfig.fromJSON(object.vpcPeeringConfig) : undefined,
    };
  },

  toJSON(message: PrivateConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = privateConnection_StateToJSON(message.state);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.vpcPeeringConfig !== undefined) {
      obj.vpcPeeringConfig = VpcPeeringConfig.toJSON(message.vpcPeeringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateConnection>): PrivateConnection {
    return PrivateConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateConnection>): PrivateConnection {
    const message = createBasePrivateConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.vpcPeeringConfig = (object.vpcPeeringConfig !== undefined && object.vpcPeeringConfig !== null)
      ? VpcPeeringConfig.fromPartial(object.vpcPeeringConfig)
      : undefined;
    return message;
  },
};

function createBasePrivateConnection_LabelsEntry(): PrivateConnection_LabelsEntry {
  return { key: "", value: "" };
}

export const PrivateConnection_LabelsEntry: MessageFns<PrivateConnection_LabelsEntry> = {
  encode(message: PrivateConnection_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateConnection_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateConnection_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateConnection_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PrivateConnection_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateConnection_LabelsEntry>): PrivateConnection_LabelsEntry {
    return PrivateConnection_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateConnection_LabelsEntry>): PrivateConnection_LabelsEntry {
    const message = createBasePrivateConnection_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePrivateConnectivity(): PrivateConnectivity {
  return { privateConnectionName: "" };
}

export const PrivateConnectivity: MessageFns<PrivateConnectivity> = {
  encode(message: PrivateConnectivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateConnectionName !== "") {
      writer.uint32(10).string(message.privateConnectionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateConnectivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateConnectionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateConnectivity {
    return {
      privateConnectionName: isSet(object.privateConnectionName) ? globalThis.String(object.privateConnectionName) : "",
    };
  },

  toJSON(message: PrivateConnectivity): unknown {
    const obj: any = {};
    if (message.privateConnectionName !== "") {
      obj.privateConnectionName = message.privateConnectionName;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateConnectivity>): PrivateConnectivity {
    return PrivateConnectivity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateConnectivity>): PrivateConnectivity {
    const message = createBasePrivateConnectivity();
    message.privateConnectionName = object.privateConnectionName ?? "";
    return message;
  },
};

function createBaseRoute(): Route {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    destinationAddress: "",
    destinationPort: 0,
  };
}

export const Route: MessageFns<Route> = {
  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Route_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.destinationAddress !== "") {
      writer.uint32(50).string(message.destinationAddress);
    }
    if (message.destinationPort !== 0) {
      writer.uint32(56).int32(message.destinationPort);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Route_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.destinationAddress = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.destinationPort = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      destinationAddress: isSet(object.destinationAddress) ? globalThis.String(object.destinationAddress) : "",
      destinationPort: isSet(object.destinationPort) ? globalThis.Number(object.destinationPort) : 0,
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.destinationAddress !== "") {
      obj.destinationAddress = message.destinationAddress;
    }
    if (message.destinationPort !== 0) {
      obj.destinationPort = Math.round(message.destinationPort);
    }
    return obj;
  },

  create(base?: DeepPartial<Route>): Route {
    return Route.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Route>): Route {
    const message = createBaseRoute();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.destinationAddress = object.destinationAddress ?? "";
    message.destinationPort = object.destinationPort ?? 0;
    return message;
  },
};

function createBaseRoute_LabelsEntry(): Route_LabelsEntry {
  return { key: "", value: "" };
}

export const Route_LabelsEntry: MessageFns<Route_LabelsEntry> = {
  encode(message: Route_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Route_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Route_LabelsEntry>): Route_LabelsEntry {
    return Route_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Route_LabelsEntry>): Route_LabelsEntry {
    const message = createBaseRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMysqlSslConfig(): MysqlSslConfig {
  return {
    clientKey: "",
    clientKeySet: false,
    clientCertificate: "",
    clientCertificateSet: false,
    caCertificate: "",
    caCertificateSet: false,
  };
}

export const MysqlSslConfig: MessageFns<MysqlSslConfig> = {
  encode(message: MysqlSslConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientKey !== "") {
      writer.uint32(90).string(message.clientKey);
    }
    if (message.clientKeySet !== false) {
      writer.uint32(96).bool(message.clientKeySet);
    }
    if (message.clientCertificate !== "") {
      writer.uint32(106).string(message.clientCertificate);
    }
    if (message.clientCertificateSet !== false) {
      writer.uint32(112).bool(message.clientCertificateSet);
    }
    if (message.caCertificate !== "") {
      writer.uint32(122).string(message.caCertificate);
    }
    if (message.caCertificateSet !== false) {
      writer.uint32(128).bool(message.caCertificateSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlSslConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlSslConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.clientKey = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.clientKeySet = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.clientCertificate = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.clientCertificateSet = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.caCertificate = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.caCertificateSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlSslConfig {
    return {
      clientKey: isSet(object.clientKey) ? globalThis.String(object.clientKey) : "",
      clientKeySet: isSet(object.clientKeySet) ? globalThis.Boolean(object.clientKeySet) : false,
      clientCertificate: isSet(object.clientCertificate) ? globalThis.String(object.clientCertificate) : "",
      clientCertificateSet: isSet(object.clientCertificateSet)
        ? globalThis.Boolean(object.clientCertificateSet)
        : false,
      caCertificate: isSet(object.caCertificate) ? globalThis.String(object.caCertificate) : "",
      caCertificateSet: isSet(object.caCertificateSet) ? globalThis.Boolean(object.caCertificateSet) : false,
    };
  },

  toJSON(message: MysqlSslConfig): unknown {
    const obj: any = {};
    if (message.clientKey !== "") {
      obj.clientKey = message.clientKey;
    }
    if (message.clientKeySet !== false) {
      obj.clientKeySet = message.clientKeySet;
    }
    if (message.clientCertificate !== "") {
      obj.clientCertificate = message.clientCertificate;
    }
    if (message.clientCertificateSet !== false) {
      obj.clientCertificateSet = message.clientCertificateSet;
    }
    if (message.caCertificate !== "") {
      obj.caCertificate = message.caCertificate;
    }
    if (message.caCertificateSet !== false) {
      obj.caCertificateSet = message.caCertificateSet;
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlSslConfig>): MysqlSslConfig {
    return MysqlSslConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlSslConfig>): MysqlSslConfig {
    const message = createBaseMysqlSslConfig();
    message.clientKey = object.clientKey ?? "";
    message.clientKeySet = object.clientKeySet ?? false;
    message.clientCertificate = object.clientCertificate ?? "";
    message.clientCertificateSet = object.clientCertificateSet ?? false;
    message.caCertificate = object.caCertificate ?? "";
    message.caCertificateSet = object.caCertificateSet ?? false;
    return message;
  },
};

function createBaseConnectionProfile(): ConnectionProfile {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    oracleProfile: undefined,
    gcsProfile: undefined,
    mysqlProfile: undefined,
    noConnectivity: undefined,
    staticServiceIpConnectivity: undefined,
    forwardSshConnectivity: undefined,
    privateConnectivity: undefined,
  };
}

export const ConnectionProfile: MessageFns<ConnectionProfile> = {
  encode(message: ConnectionProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ConnectionProfile_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.oracleProfile !== undefined) {
      OracleProfile.encode(message.oracleProfile, writer.uint32(802).fork()).join();
    }
    if (message.gcsProfile !== undefined) {
      GcsProfile.encode(message.gcsProfile, writer.uint32(810).fork()).join();
    }
    if (message.mysqlProfile !== undefined) {
      MysqlProfile.encode(message.mysqlProfile, writer.uint32(818).fork()).join();
    }
    if (message.noConnectivity !== undefined) {
      NoConnectivitySettings.encode(message.noConnectivity, writer.uint32(1602).fork()).join();
    }
    if (message.staticServiceIpConnectivity !== undefined) {
      StaticServiceIpConnectivity.encode(message.staticServiceIpConnectivity, writer.uint32(1610).fork()).join();
    }
    if (message.forwardSshConnectivity !== undefined) {
      ForwardSshTunnelConnectivity.encode(message.forwardSshConnectivity, writer.uint32(1618).fork()).join();
    }
    if (message.privateConnectivity !== undefined) {
      PrivateConnectivity.encode(message.privateConnectivity, writer.uint32(1626).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = ConnectionProfile_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.oracleProfile = OracleProfile.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.gcsProfile = GcsProfile.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.mysqlProfile = MysqlProfile.decode(reader, reader.uint32());
          continue;
        case 200:
          if (tag !== 1602) {
            break;
          }

          message.noConnectivity = NoConnectivitySettings.decode(reader, reader.uint32());
          continue;
        case 201:
          if (tag !== 1610) {
            break;
          }

          message.staticServiceIpConnectivity = StaticServiceIpConnectivity.decode(reader, reader.uint32());
          continue;
        case 202:
          if (tag !== 1618) {
            break;
          }

          message.forwardSshConnectivity = ForwardSshTunnelConnectivity.decode(reader, reader.uint32());
          continue;
        case 203:
          if (tag !== 1626) {
            break;
          }

          message.privateConnectivity = PrivateConnectivity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfile {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      oracleProfile: isSet(object.oracleProfile) ? OracleProfile.fromJSON(object.oracleProfile) : undefined,
      gcsProfile: isSet(object.gcsProfile) ? GcsProfile.fromJSON(object.gcsProfile) : undefined,
      mysqlProfile: isSet(object.mysqlProfile) ? MysqlProfile.fromJSON(object.mysqlProfile) : undefined,
      noConnectivity: isSet(object.noConnectivity) ? NoConnectivitySettings.fromJSON(object.noConnectivity) : undefined,
      staticServiceIpConnectivity: isSet(object.staticServiceIpConnectivity)
        ? StaticServiceIpConnectivity.fromJSON(object.staticServiceIpConnectivity)
        : undefined,
      forwardSshConnectivity: isSet(object.forwardSshConnectivity)
        ? ForwardSshTunnelConnectivity.fromJSON(object.forwardSshConnectivity)
        : undefined,
      privateConnectivity: isSet(object.privateConnectivity)
        ? PrivateConnectivity.fromJSON(object.privateConnectivity)
        : undefined,
    };
  },

  toJSON(message: ConnectionProfile): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.oracleProfile !== undefined) {
      obj.oracleProfile = OracleProfile.toJSON(message.oracleProfile);
    }
    if (message.gcsProfile !== undefined) {
      obj.gcsProfile = GcsProfile.toJSON(message.gcsProfile);
    }
    if (message.mysqlProfile !== undefined) {
      obj.mysqlProfile = MysqlProfile.toJSON(message.mysqlProfile);
    }
    if (message.noConnectivity !== undefined) {
      obj.noConnectivity = NoConnectivitySettings.toJSON(message.noConnectivity);
    }
    if (message.staticServiceIpConnectivity !== undefined) {
      obj.staticServiceIpConnectivity = StaticServiceIpConnectivity.toJSON(message.staticServiceIpConnectivity);
    }
    if (message.forwardSshConnectivity !== undefined) {
      obj.forwardSshConnectivity = ForwardSshTunnelConnectivity.toJSON(message.forwardSshConnectivity);
    }
    if (message.privateConnectivity !== undefined) {
      obj.privateConnectivity = PrivateConnectivity.toJSON(message.privateConnectivity);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionProfile>): ConnectionProfile {
    return ConnectionProfile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionProfile>): ConnectionProfile {
    const message = createBaseConnectionProfile();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.oracleProfile = (object.oracleProfile !== undefined && object.oracleProfile !== null)
      ? OracleProfile.fromPartial(object.oracleProfile)
      : undefined;
    message.gcsProfile = (object.gcsProfile !== undefined && object.gcsProfile !== null)
      ? GcsProfile.fromPartial(object.gcsProfile)
      : undefined;
    message.mysqlProfile = (object.mysqlProfile !== undefined && object.mysqlProfile !== null)
      ? MysqlProfile.fromPartial(object.mysqlProfile)
      : undefined;
    message.noConnectivity = (object.noConnectivity !== undefined && object.noConnectivity !== null)
      ? NoConnectivitySettings.fromPartial(object.noConnectivity)
      : undefined;
    message.staticServiceIpConnectivity =
      (object.staticServiceIpConnectivity !== undefined && object.staticServiceIpConnectivity !== null)
        ? StaticServiceIpConnectivity.fromPartial(object.staticServiceIpConnectivity)
        : undefined;
    message.forwardSshConnectivity =
      (object.forwardSshConnectivity !== undefined && object.forwardSshConnectivity !== null)
        ? ForwardSshTunnelConnectivity.fromPartial(object.forwardSshConnectivity)
        : undefined;
    message.privateConnectivity = (object.privateConnectivity !== undefined && object.privateConnectivity !== null)
      ? PrivateConnectivity.fromPartial(object.privateConnectivity)
      : undefined;
    return message;
  },
};

function createBaseConnectionProfile_LabelsEntry(): ConnectionProfile_LabelsEntry {
  return { key: "", value: "" };
}

export const ConnectionProfile_LabelsEntry: MessageFns<ConnectionProfile_LabelsEntry> = {
  encode(message: ConnectionProfile_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionProfile_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionProfile_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionProfile_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConnectionProfile_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionProfile_LabelsEntry>): ConnectionProfile_LabelsEntry {
    return ConnectionProfile_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionProfile_LabelsEntry>): ConnectionProfile_LabelsEntry {
    const message = createBaseConnectionProfile_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOracleColumn(): OracleColumn {
  return {
    columnName: "",
    dataType: "",
    length: 0,
    precision: 0,
    scale: 0,
    encoding: "",
    primaryKey: false,
    nullable: false,
    ordinalPosition: 0,
  };
}

export const OracleColumn: MessageFns<OracleColumn> = {
  encode(message: OracleColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.length !== 0) {
      writer.uint32(24).int32(message.length);
    }
    if (message.precision !== 0) {
      writer.uint32(32).int32(message.precision);
    }
    if (message.scale !== 0) {
      writer.uint32(40).int32(message.scale);
    }
    if (message.encoding !== "") {
      writer.uint32(50).string(message.encoding);
    }
    if (message.primaryKey !== false) {
      writer.uint32(56).bool(message.primaryKey);
    }
    if (message.nullable !== false) {
      writer.uint32(64).bool(message.nullable);
    }
    if (message.ordinalPosition !== 0) {
      writer.uint32(72).int32(message.ordinalPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.length = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.precision = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.scale = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.encoding = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.primaryKey = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.ordinalPosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleColumn {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : "",
      primaryKey: isSet(object.primaryKey) ? globalThis.Boolean(object.primaryKey) : false,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      ordinalPosition: isSet(object.ordinalPosition) ? globalThis.Number(object.ordinalPosition) : 0,
    };
  },

  toJSON(message: OracleColumn): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.precision !== 0) {
      obj.precision = Math.round(message.precision);
    }
    if (message.scale !== 0) {
      obj.scale = Math.round(message.scale);
    }
    if (message.encoding !== "") {
      obj.encoding = message.encoding;
    }
    if (message.primaryKey !== false) {
      obj.primaryKey = message.primaryKey;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.ordinalPosition !== 0) {
      obj.ordinalPosition = Math.round(message.ordinalPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<OracleColumn>): OracleColumn {
    return OracleColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleColumn>): OracleColumn {
    const message = createBaseOracleColumn();
    message.columnName = object.columnName ?? "";
    message.dataType = object.dataType ?? "";
    message.length = object.length ?? 0;
    message.precision = object.precision ?? 0;
    message.scale = object.scale ?? 0;
    message.encoding = object.encoding ?? "";
    message.primaryKey = object.primaryKey ?? false;
    message.nullable = object.nullable ?? false;
    message.ordinalPosition = object.ordinalPosition ?? 0;
    return message;
  },
};

function createBaseOracleTable(): OracleTable {
  return { tableName: "", oracleColumns: [] };
}

export const OracleTable: MessageFns<OracleTable> = {
  encode(message: OracleTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    for (const v of message.oracleColumns) {
      OracleColumn.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oracleColumns.push(OracleColumn.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleTable {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      oracleColumns: globalThis.Array.isArray(object?.oracleColumns)
        ? object.oracleColumns.map((e: any) => OracleColumn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OracleTable): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.oracleColumns?.length) {
      obj.oracleColumns = message.oracleColumns.map((e) => OracleColumn.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OracleTable>): OracleTable {
    return OracleTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleTable>): OracleTable {
    const message = createBaseOracleTable();
    message.tableName = object.tableName ?? "";
    message.oracleColumns = object.oracleColumns?.map((e) => OracleColumn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOracleSchema(): OracleSchema {
  return { schemaName: "", oracleTables: [] };
}

export const OracleSchema: MessageFns<OracleSchema> = {
  encode(message: OracleSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaName !== "") {
      writer.uint32(10).string(message.schemaName);
    }
    for (const v of message.oracleTables) {
      OracleTable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.schemaName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oracleTables.push(OracleTable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleSchema {
    return {
      schemaName: isSet(object.schemaName) ? globalThis.String(object.schemaName) : "",
      oracleTables: globalThis.Array.isArray(object?.oracleTables)
        ? object.oracleTables.map((e: any) => OracleTable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OracleSchema): unknown {
    const obj: any = {};
    if (message.schemaName !== "") {
      obj.schemaName = message.schemaName;
    }
    if (message.oracleTables?.length) {
      obj.oracleTables = message.oracleTables.map((e) => OracleTable.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OracleSchema>): OracleSchema {
    return OracleSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleSchema>): OracleSchema {
    const message = createBaseOracleSchema();
    message.schemaName = object.schemaName ?? "";
    message.oracleTables = object.oracleTables?.map((e) => OracleTable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOracleRdbms(): OracleRdbms {
  return { oracleSchemas: [] };
}

export const OracleRdbms: MessageFns<OracleRdbms> = {
  encode(message: OracleRdbms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.oracleSchemas) {
      OracleSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleRdbms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleRdbms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oracleSchemas.push(OracleSchema.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleRdbms {
    return {
      oracleSchemas: globalThis.Array.isArray(object?.oracleSchemas)
        ? object.oracleSchemas.map((e: any) => OracleSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OracleRdbms): unknown {
    const obj: any = {};
    if (message.oracleSchemas?.length) {
      obj.oracleSchemas = message.oracleSchemas.map((e) => OracleSchema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OracleRdbms>): OracleRdbms {
    return OracleRdbms.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleRdbms>): OracleRdbms {
    const message = createBaseOracleRdbms();
    message.oracleSchemas = object.oracleSchemas?.map((e) => OracleSchema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOracleSourceConfig(): OracleSourceConfig {
  return { allowlist: undefined, rejectlist: undefined };
}

export const OracleSourceConfig: MessageFns<OracleSourceConfig> = {
  encode(message: OracleSourceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowlist !== undefined) {
      OracleRdbms.encode(message.allowlist, writer.uint32(10).fork()).join();
    }
    if (message.rejectlist !== undefined) {
      OracleRdbms.encode(message.rejectlist, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OracleSourceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOracleSourceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowlist = OracleRdbms.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rejectlist = OracleRdbms.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OracleSourceConfig {
    return {
      allowlist: isSet(object.allowlist) ? OracleRdbms.fromJSON(object.allowlist) : undefined,
      rejectlist: isSet(object.rejectlist) ? OracleRdbms.fromJSON(object.rejectlist) : undefined,
    };
  },

  toJSON(message: OracleSourceConfig): unknown {
    const obj: any = {};
    if (message.allowlist !== undefined) {
      obj.allowlist = OracleRdbms.toJSON(message.allowlist);
    }
    if (message.rejectlist !== undefined) {
      obj.rejectlist = OracleRdbms.toJSON(message.rejectlist);
    }
    return obj;
  },

  create(base?: DeepPartial<OracleSourceConfig>): OracleSourceConfig {
    return OracleSourceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OracleSourceConfig>): OracleSourceConfig {
    const message = createBaseOracleSourceConfig();
    message.allowlist = (object.allowlist !== undefined && object.allowlist !== null)
      ? OracleRdbms.fromPartial(object.allowlist)
      : undefined;
    message.rejectlist = (object.rejectlist !== undefined && object.rejectlist !== null)
      ? OracleRdbms.fromPartial(object.rejectlist)
      : undefined;
    return message;
  },
};

function createBaseMysqlColumn(): MysqlColumn {
  return {
    columnName: "",
    dataType: "",
    length: 0,
    collation: "",
    primaryKey: false,
    nullable: false,
    ordinalPosition: 0,
  };
}

export const MysqlColumn: MessageFns<MysqlColumn> = {
  encode(message: MysqlColumn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columnName !== "") {
      writer.uint32(10).string(message.columnName);
    }
    if (message.dataType !== "") {
      writer.uint32(18).string(message.dataType);
    }
    if (message.length !== 0) {
      writer.uint32(24).int32(message.length);
    }
    if (message.collation !== "") {
      writer.uint32(34).string(message.collation);
    }
    if (message.primaryKey !== false) {
      writer.uint32(40).bool(message.primaryKey);
    }
    if (message.nullable !== false) {
      writer.uint32(48).bool(message.nullable);
    }
    if (message.ordinalPosition !== 0) {
      writer.uint32(56).int32(message.ordinalPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlColumn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.length = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.collation = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.primaryKey = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ordinalPosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlColumn {
    return {
      columnName: isSet(object.columnName) ? globalThis.String(object.columnName) : "",
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : "",
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      collation: isSet(object.collation) ? globalThis.String(object.collation) : "",
      primaryKey: isSet(object.primaryKey) ? globalThis.Boolean(object.primaryKey) : false,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      ordinalPosition: isSet(object.ordinalPosition) ? globalThis.Number(object.ordinalPosition) : 0,
    };
  },

  toJSON(message: MysqlColumn): unknown {
    const obj: any = {};
    if (message.columnName !== "") {
      obj.columnName = message.columnName;
    }
    if (message.dataType !== "") {
      obj.dataType = message.dataType;
    }
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.collation !== "") {
      obj.collation = message.collation;
    }
    if (message.primaryKey !== false) {
      obj.primaryKey = message.primaryKey;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.ordinalPosition !== 0) {
      obj.ordinalPosition = Math.round(message.ordinalPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlColumn>): MysqlColumn {
    return MysqlColumn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlColumn>): MysqlColumn {
    const message = createBaseMysqlColumn();
    message.columnName = object.columnName ?? "";
    message.dataType = object.dataType ?? "";
    message.length = object.length ?? 0;
    message.collation = object.collation ?? "";
    message.primaryKey = object.primaryKey ?? false;
    message.nullable = object.nullable ?? false;
    message.ordinalPosition = object.ordinalPosition ?? 0;
    return message;
  },
};

function createBaseMysqlTable(): MysqlTable {
  return { tableName: "", mysqlColumns: [] };
}

export const MysqlTable: MessageFns<MysqlTable> = {
  encode(message: MysqlTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tableName !== "") {
      writer.uint32(10).string(message.tableName);
    }
    for (const v of message.mysqlColumns) {
      MysqlColumn.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tableName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mysqlColumns.push(MysqlColumn.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlTable {
    return {
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : "",
      mysqlColumns: globalThis.Array.isArray(object?.mysqlColumns)
        ? object.mysqlColumns.map((e: any) => MysqlColumn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MysqlTable): unknown {
    const obj: any = {};
    if (message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.mysqlColumns?.length) {
      obj.mysqlColumns = message.mysqlColumns.map((e) => MysqlColumn.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlTable>): MysqlTable {
    return MysqlTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlTable>): MysqlTable {
    const message = createBaseMysqlTable();
    message.tableName = object.tableName ?? "";
    message.mysqlColumns = object.mysqlColumns?.map((e) => MysqlColumn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMysqlDatabase(): MysqlDatabase {
  return { databaseName: "", mysqlTables: [] };
}

export const MysqlDatabase: MessageFns<MysqlDatabase> = {
  encode(message: MysqlDatabase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.databaseName !== "") {
      writer.uint32(10).string(message.databaseName);
    }
    for (const v of message.mysqlTables) {
      MysqlTable.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlDatabase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.databaseName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mysqlTables.push(MysqlTable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlDatabase {
    return {
      databaseName: isSet(object.databaseName) ? globalThis.String(object.databaseName) : "",
      mysqlTables: globalThis.Array.isArray(object?.mysqlTables)
        ? object.mysqlTables.map((e: any) => MysqlTable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MysqlDatabase): unknown {
    const obj: any = {};
    if (message.databaseName !== "") {
      obj.databaseName = message.databaseName;
    }
    if (message.mysqlTables?.length) {
      obj.mysqlTables = message.mysqlTables.map((e) => MysqlTable.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlDatabase>): MysqlDatabase {
    return MysqlDatabase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlDatabase>): MysqlDatabase {
    const message = createBaseMysqlDatabase();
    message.databaseName = object.databaseName ?? "";
    message.mysqlTables = object.mysqlTables?.map((e) => MysqlTable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMysqlRdbms(): MysqlRdbms {
  return { mysqlDatabases: [] };
}

export const MysqlRdbms: MessageFns<MysqlRdbms> = {
  encode(message: MysqlRdbms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.mysqlDatabases) {
      MysqlDatabase.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlRdbms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlRdbms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mysqlDatabases.push(MysqlDatabase.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlRdbms {
    return {
      mysqlDatabases: globalThis.Array.isArray(object?.mysqlDatabases)
        ? object.mysqlDatabases.map((e: any) => MysqlDatabase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MysqlRdbms): unknown {
    const obj: any = {};
    if (message.mysqlDatabases?.length) {
      obj.mysqlDatabases = message.mysqlDatabases.map((e) => MysqlDatabase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlRdbms>): MysqlRdbms {
    return MysqlRdbms.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlRdbms>): MysqlRdbms {
    const message = createBaseMysqlRdbms();
    message.mysqlDatabases = object.mysqlDatabases?.map((e) => MysqlDatabase.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMysqlSourceConfig(): MysqlSourceConfig {
  return { allowlist: undefined, rejectlist: undefined };
}

export const MysqlSourceConfig: MessageFns<MysqlSourceConfig> = {
  encode(message: MysqlSourceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowlist !== undefined) {
      MysqlRdbms.encode(message.allowlist, writer.uint32(10).fork()).join();
    }
    if (message.rejectlist !== undefined) {
      MysqlRdbms.encode(message.rejectlist, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MysqlSourceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMysqlSourceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowlist = MysqlRdbms.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rejectlist = MysqlRdbms.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MysqlSourceConfig {
    return {
      allowlist: isSet(object.allowlist) ? MysqlRdbms.fromJSON(object.allowlist) : undefined,
      rejectlist: isSet(object.rejectlist) ? MysqlRdbms.fromJSON(object.rejectlist) : undefined,
    };
  },

  toJSON(message: MysqlSourceConfig): unknown {
    const obj: any = {};
    if (message.allowlist !== undefined) {
      obj.allowlist = MysqlRdbms.toJSON(message.allowlist);
    }
    if (message.rejectlist !== undefined) {
      obj.rejectlist = MysqlRdbms.toJSON(message.rejectlist);
    }
    return obj;
  },

  create(base?: DeepPartial<MysqlSourceConfig>): MysqlSourceConfig {
    return MysqlSourceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MysqlSourceConfig>): MysqlSourceConfig {
    const message = createBaseMysqlSourceConfig();
    message.allowlist = (object.allowlist !== undefined && object.allowlist !== null)
      ? MysqlRdbms.fromPartial(object.allowlist)
      : undefined;
    message.rejectlist = (object.rejectlist !== undefined && object.rejectlist !== null)
      ? MysqlRdbms.fromPartial(object.rejectlist)
      : undefined;
    return message;
  },
};

function createBaseSourceConfig(): SourceConfig {
  return { sourceConnectionProfileName: "", oracleSourceConfig: undefined, mysqlSourceConfig: undefined };
}

export const SourceConfig: MessageFns<SourceConfig> = {
  encode(message: SourceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceConnectionProfileName !== "") {
      writer.uint32(10).string(message.sourceConnectionProfileName);
    }
    if (message.oracleSourceConfig !== undefined) {
      OracleSourceConfig.encode(message.oracleSourceConfig, writer.uint32(802).fork()).join();
    }
    if (message.mysqlSourceConfig !== undefined) {
      MysqlSourceConfig.encode(message.mysqlSourceConfig, writer.uint32(810).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceConnectionProfileName = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.oracleSourceConfig = OracleSourceConfig.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.mysqlSourceConfig = MysqlSourceConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceConfig {
    return {
      sourceConnectionProfileName: isSet(object.sourceConnectionProfileName)
        ? globalThis.String(object.sourceConnectionProfileName)
        : "",
      oracleSourceConfig: isSet(object.oracleSourceConfig)
        ? OracleSourceConfig.fromJSON(object.oracleSourceConfig)
        : undefined,
      mysqlSourceConfig: isSet(object.mysqlSourceConfig)
        ? MysqlSourceConfig.fromJSON(object.mysqlSourceConfig)
        : undefined,
    };
  },

  toJSON(message: SourceConfig): unknown {
    const obj: any = {};
    if (message.sourceConnectionProfileName !== "") {
      obj.sourceConnectionProfileName = message.sourceConnectionProfileName;
    }
    if (message.oracleSourceConfig !== undefined) {
      obj.oracleSourceConfig = OracleSourceConfig.toJSON(message.oracleSourceConfig);
    }
    if (message.mysqlSourceConfig !== undefined) {
      obj.mysqlSourceConfig = MysqlSourceConfig.toJSON(message.mysqlSourceConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SourceConfig>): SourceConfig {
    return SourceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceConfig>): SourceConfig {
    const message = createBaseSourceConfig();
    message.sourceConnectionProfileName = object.sourceConnectionProfileName ?? "";
    message.oracleSourceConfig = (object.oracleSourceConfig !== undefined && object.oracleSourceConfig !== null)
      ? OracleSourceConfig.fromPartial(object.oracleSourceConfig)
      : undefined;
    message.mysqlSourceConfig = (object.mysqlSourceConfig !== undefined && object.mysqlSourceConfig !== null)
      ? MysqlSourceConfig.fromPartial(object.mysqlSourceConfig)
      : undefined;
    return message;
  },
};

function createBaseAvroFileFormat(): AvroFileFormat {
  return {};
}

export const AvroFileFormat: MessageFns<AvroFileFormat> = {
  encode(_: AvroFileFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AvroFileFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvroFileFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AvroFileFormat {
    return {};
  },

  toJSON(_: AvroFileFormat): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AvroFileFormat>): AvroFileFormat {
    return AvroFileFormat.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AvroFileFormat>): AvroFileFormat {
    const message = createBaseAvroFileFormat();
    return message;
  },
};

function createBaseJsonFileFormat(): JsonFileFormat {
  return { schemaFileFormat: 0, compression: 0 };
}

export const JsonFileFormat: MessageFns<JsonFileFormat> = {
  encode(message: JsonFileFormat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schemaFileFormat !== 0) {
      writer.uint32(8).int32(message.schemaFileFormat);
    }
    if (message.compression !== 0) {
      writer.uint32(16).int32(message.compression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonFileFormat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonFileFormat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.schemaFileFormat = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.compression = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonFileFormat {
    return {
      schemaFileFormat: isSet(object.schemaFileFormat) ? schemaFileFormatFromJSON(object.schemaFileFormat) : 0,
      compression: isSet(object.compression) ? jsonFileFormat_JsonCompressionFromJSON(object.compression) : 0,
    };
  },

  toJSON(message: JsonFileFormat): unknown {
    const obj: any = {};
    if (message.schemaFileFormat !== 0) {
      obj.schemaFileFormat = schemaFileFormatToJSON(message.schemaFileFormat);
    }
    if (message.compression !== 0) {
      obj.compression = jsonFileFormat_JsonCompressionToJSON(message.compression);
    }
    return obj;
  },

  create(base?: DeepPartial<JsonFileFormat>): JsonFileFormat {
    return JsonFileFormat.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JsonFileFormat>): JsonFileFormat {
    const message = createBaseJsonFileFormat();
    message.schemaFileFormat = object.schemaFileFormat ?? 0;
    message.compression = object.compression ?? 0;
    return message;
  },
};

function createBaseGcsDestinationConfig(): GcsDestinationConfig {
  return {
    path: "",
    gcsFileFormat: 0,
    fileRotationMb: 0,
    fileRotationInterval: undefined,
    avroFileFormat: undefined,
    jsonFileFormat: undefined,
  };
}

export const GcsDestinationConfig: MessageFns<GcsDestinationConfig> = {
  encode(message: GcsDestinationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.gcsFileFormat !== 0) {
      writer.uint32(16).int32(message.gcsFileFormat);
    }
    if (message.fileRotationMb !== 0) {
      writer.uint32(24).int32(message.fileRotationMb);
    }
    if (message.fileRotationInterval !== undefined) {
      Duration.encode(message.fileRotationInterval, writer.uint32(34).fork()).join();
    }
    if (message.avroFileFormat !== undefined) {
      AvroFileFormat.encode(message.avroFileFormat, writer.uint32(802).fork()).join();
    }
    if (message.jsonFileFormat !== undefined) {
      JsonFileFormat.encode(message.jsonFileFormat, writer.uint32(810).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDestinationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDestinationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gcsFileFormat = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fileRotationMb = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fileRotationInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.avroFileFormat = AvroFileFormat.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.jsonFileFormat = JsonFileFormat.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDestinationConfig {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      gcsFileFormat: isSet(object.gcsFileFormat) ? gcsFileFormatFromJSON(object.gcsFileFormat) : 0,
      fileRotationMb: isSet(object.fileRotationMb) ? globalThis.Number(object.fileRotationMb) : 0,
      fileRotationInterval: isSet(object.fileRotationInterval)
        ? Duration.fromJSON(object.fileRotationInterval)
        : undefined,
      avroFileFormat: isSet(object.avroFileFormat) ? AvroFileFormat.fromJSON(object.avroFileFormat) : undefined,
      jsonFileFormat: isSet(object.jsonFileFormat) ? JsonFileFormat.fromJSON(object.jsonFileFormat) : undefined,
    };
  },

  toJSON(message: GcsDestinationConfig): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.gcsFileFormat !== 0) {
      obj.gcsFileFormat = gcsFileFormatToJSON(message.gcsFileFormat);
    }
    if (message.fileRotationMb !== 0) {
      obj.fileRotationMb = Math.round(message.fileRotationMb);
    }
    if (message.fileRotationInterval !== undefined) {
      obj.fileRotationInterval = Duration.toJSON(message.fileRotationInterval);
    }
    if (message.avroFileFormat !== undefined) {
      obj.avroFileFormat = AvroFileFormat.toJSON(message.avroFileFormat);
    }
    if (message.jsonFileFormat !== undefined) {
      obj.jsonFileFormat = JsonFileFormat.toJSON(message.jsonFileFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDestinationConfig>): GcsDestinationConfig {
    return GcsDestinationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDestinationConfig>): GcsDestinationConfig {
    const message = createBaseGcsDestinationConfig();
    message.path = object.path ?? "";
    message.gcsFileFormat = object.gcsFileFormat ?? 0;
    message.fileRotationMb = object.fileRotationMb ?? 0;
    message.fileRotationInterval = (object.fileRotationInterval !== undefined && object.fileRotationInterval !== null)
      ? Duration.fromPartial(object.fileRotationInterval)
      : undefined;
    message.avroFileFormat = (object.avroFileFormat !== undefined && object.avroFileFormat !== null)
      ? AvroFileFormat.fromPartial(object.avroFileFormat)
      : undefined;
    message.jsonFileFormat = (object.jsonFileFormat !== undefined && object.jsonFileFormat !== null)
      ? JsonFileFormat.fromPartial(object.jsonFileFormat)
      : undefined;
    return message;
  },
};

function createBaseDestinationConfig(): DestinationConfig {
  return { destinationConnectionProfileName: "", gcsDestinationConfig: undefined };
}

export const DestinationConfig: MessageFns<DestinationConfig> = {
  encode(message: DestinationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destinationConnectionProfileName !== "") {
      writer.uint32(10).string(message.destinationConnectionProfileName);
    }
    if (message.gcsDestinationConfig !== undefined) {
      GcsDestinationConfig.encode(message.gcsDestinationConfig, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DestinationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destinationConnectionProfileName = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.gcsDestinationConfig = GcsDestinationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationConfig {
    return {
      destinationConnectionProfileName: isSet(object.destinationConnectionProfileName)
        ? globalThis.String(object.destinationConnectionProfileName)
        : "",
      gcsDestinationConfig: isSet(object.gcsDestinationConfig)
        ? GcsDestinationConfig.fromJSON(object.gcsDestinationConfig)
        : undefined,
    };
  },

  toJSON(message: DestinationConfig): unknown {
    const obj: any = {};
    if (message.destinationConnectionProfileName !== "") {
      obj.destinationConnectionProfileName = message.destinationConnectionProfileName;
    }
    if (message.gcsDestinationConfig !== undefined) {
      obj.gcsDestinationConfig = GcsDestinationConfig.toJSON(message.gcsDestinationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationConfig>): DestinationConfig {
    return DestinationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationConfig>): DestinationConfig {
    const message = createBaseDestinationConfig();
    message.destinationConnectionProfileName = object.destinationConnectionProfileName ?? "";
    message.gcsDestinationConfig = (object.gcsDestinationConfig !== undefined && object.gcsDestinationConfig !== null)
      ? GcsDestinationConfig.fromPartial(object.gcsDestinationConfig)
      : undefined;
    return message;
  },
};

function createBaseStream(): Stream {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    sourceConfig: undefined,
    destinationConfig: undefined,
    state: 0,
    backfillAll: undefined,
    backfillNone: undefined,
    errors: [],
  };
}

export const Stream: MessageFns<Stream> = {
  encode(message: Stream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Stream_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.sourceConfig !== undefined) {
      SourceConfig.encode(message.sourceConfig, writer.uint32(50).fork()).join();
    }
    if (message.destinationConfig !== undefined) {
      DestinationConfig.encode(message.destinationConfig, writer.uint32(58).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.backfillAll !== undefined) {
      Stream_BackfillAllStrategy.encode(message.backfillAll, writer.uint32(810).fork()).join();
    }
    if (message.backfillNone !== undefined) {
      Stream_BackfillNoneStrategy.encode(message.backfillNone, writer.uint32(818).fork()).join();
    }
    for (const v of message.errors) {
      Error.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Stream_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceConfig = SourceConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.destinationConfig = DestinationConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.backfillAll = Stream_BackfillAllStrategy.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.backfillNone = Stream_BackfillNoneStrategy.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errors.push(Error.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceConfig: isSet(object.sourceConfig) ? SourceConfig.fromJSON(object.sourceConfig) : undefined,
      destinationConfig: isSet(object.destinationConfig)
        ? DestinationConfig.fromJSON(object.destinationConfig)
        : undefined,
      state: isSet(object.state) ? stream_StateFromJSON(object.state) : 0,
      backfillAll: isSet(object.backfillAll) ? Stream_BackfillAllStrategy.fromJSON(object.backfillAll) : undefined,
      backfillNone: isSet(object.backfillNone) ? Stream_BackfillNoneStrategy.fromJSON(object.backfillNone) : undefined,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Error.fromJSON(e)) : [],
    };
  },

  toJSON(message: Stream): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceConfig !== undefined) {
      obj.sourceConfig = SourceConfig.toJSON(message.sourceConfig);
    }
    if (message.destinationConfig !== undefined) {
      obj.destinationConfig = DestinationConfig.toJSON(message.destinationConfig);
    }
    if (message.state !== 0) {
      obj.state = stream_StateToJSON(message.state);
    }
    if (message.backfillAll !== undefined) {
      obj.backfillAll = Stream_BackfillAllStrategy.toJSON(message.backfillAll);
    }
    if (message.backfillNone !== undefined) {
      obj.backfillNone = Stream_BackfillNoneStrategy.toJSON(message.backfillNone);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Error.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Stream>): Stream {
    return Stream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stream>): Stream {
    const message = createBaseStream();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.sourceConfig = (object.sourceConfig !== undefined && object.sourceConfig !== null)
      ? SourceConfig.fromPartial(object.sourceConfig)
      : undefined;
    message.destinationConfig = (object.destinationConfig !== undefined && object.destinationConfig !== null)
      ? DestinationConfig.fromPartial(object.destinationConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.backfillAll = (object.backfillAll !== undefined && object.backfillAll !== null)
      ? Stream_BackfillAllStrategy.fromPartial(object.backfillAll)
      : undefined;
    message.backfillNone = (object.backfillNone !== undefined && object.backfillNone !== null)
      ? Stream_BackfillNoneStrategy.fromPartial(object.backfillNone)
      : undefined;
    message.errors = object.errors?.map((e) => Error.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStream_BackfillAllStrategy(): Stream_BackfillAllStrategy {
  return { oracleExcludedObjects: undefined, mysqlExcludedObjects: undefined };
}

export const Stream_BackfillAllStrategy: MessageFns<Stream_BackfillAllStrategy> = {
  encode(message: Stream_BackfillAllStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oracleExcludedObjects !== undefined) {
      OracleRdbms.encode(message.oracleExcludedObjects, writer.uint32(10).fork()).join();
    }
    if (message.mysqlExcludedObjects !== undefined) {
      MysqlRdbms.encode(message.mysqlExcludedObjects, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream_BackfillAllStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream_BackfillAllStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oracleExcludedObjects = OracleRdbms.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mysqlExcludedObjects = MysqlRdbms.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream_BackfillAllStrategy {
    return {
      oracleExcludedObjects: isSet(object.oracleExcludedObjects)
        ? OracleRdbms.fromJSON(object.oracleExcludedObjects)
        : undefined,
      mysqlExcludedObjects: isSet(object.mysqlExcludedObjects)
        ? MysqlRdbms.fromJSON(object.mysqlExcludedObjects)
        : undefined,
    };
  },

  toJSON(message: Stream_BackfillAllStrategy): unknown {
    const obj: any = {};
    if (message.oracleExcludedObjects !== undefined) {
      obj.oracleExcludedObjects = OracleRdbms.toJSON(message.oracleExcludedObjects);
    }
    if (message.mysqlExcludedObjects !== undefined) {
      obj.mysqlExcludedObjects = MysqlRdbms.toJSON(message.mysqlExcludedObjects);
    }
    return obj;
  },

  create(base?: DeepPartial<Stream_BackfillAllStrategy>): Stream_BackfillAllStrategy {
    return Stream_BackfillAllStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stream_BackfillAllStrategy>): Stream_BackfillAllStrategy {
    const message = createBaseStream_BackfillAllStrategy();
    message.oracleExcludedObjects =
      (object.oracleExcludedObjects !== undefined && object.oracleExcludedObjects !== null)
        ? OracleRdbms.fromPartial(object.oracleExcludedObjects)
        : undefined;
    message.mysqlExcludedObjects = (object.mysqlExcludedObjects !== undefined && object.mysqlExcludedObjects !== null)
      ? MysqlRdbms.fromPartial(object.mysqlExcludedObjects)
      : undefined;
    return message;
  },
};

function createBaseStream_BackfillNoneStrategy(): Stream_BackfillNoneStrategy {
  return {};
}

export const Stream_BackfillNoneStrategy: MessageFns<Stream_BackfillNoneStrategy> = {
  encode(_: Stream_BackfillNoneStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream_BackfillNoneStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream_BackfillNoneStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Stream_BackfillNoneStrategy {
    return {};
  },

  toJSON(_: Stream_BackfillNoneStrategy): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Stream_BackfillNoneStrategy>): Stream_BackfillNoneStrategy {
    return Stream_BackfillNoneStrategy.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Stream_BackfillNoneStrategy>): Stream_BackfillNoneStrategy {
    const message = createBaseStream_BackfillNoneStrategy();
    return message;
  },
};

function createBaseStream_LabelsEntry(): Stream_LabelsEntry {
  return { key: "", value: "" };
}

export const Stream_LabelsEntry: MessageFns<Stream_LabelsEntry> = {
  encode(message: Stream_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stream_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStream_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stream_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Stream_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Stream_LabelsEntry>): Stream_LabelsEntry {
    return Stream_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Stream_LabelsEntry>): Stream_LabelsEntry {
    const message = createBaseStream_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseError(): Error {
  return { reason: "", errorUuid: "", message: "", errorTime: undefined, details: {} };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    if (message.errorUuid !== "") {
      writer.uint32(18).string(message.errorUuid);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.errorTime !== undefined) {
      Timestamp.encode(toTimestamp(message.errorTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.details).forEach(([key, value]) => {
      Error_DetailsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorUuid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errorTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Error_DetailsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.details[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      errorUuid: isSet(object.errorUuid) ? globalThis.String(object.errorUuid) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      errorTime: isSet(object.errorTime) ? fromJsonTimestamp(object.errorTime) : undefined,
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.errorUuid !== "") {
      obj.errorUuid = message.errorUuid;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.errorTime !== undefined) {
      obj.errorTime = message.errorTime.toISOString();
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Error>): Error {
    return Error.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Error>): Error {
    const message = createBaseError();
    message.reason = object.reason ?? "";
    message.errorUuid = object.errorUuid ?? "";
    message.message = object.message ?? "";
    message.errorTime = object.errorTime ?? undefined;
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseError_DetailsEntry(): Error_DetailsEntry {
  return { key: "", value: "" };
}

export const Error_DetailsEntry: MessageFns<Error_DetailsEntry> = {
  encode(message: Error_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Error_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Error_DetailsEntry>): Error_DetailsEntry {
    return Error_DetailsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Error_DetailsEntry>): Error_DetailsEntry {
    const message = createBaseError_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseValidationResult(): ValidationResult {
  return { validations: [] };
}

export const ValidationResult: MessageFns<ValidationResult> = {
  encode(message: ValidationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.validations) {
      Validation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validations.push(Validation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationResult {
    return {
      validations: globalThis.Array.isArray(object?.validations)
        ? object.validations.map((e: any) => Validation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidationResult): unknown {
    const obj: any = {};
    if (message.validations?.length) {
      obj.validations = message.validations.map((e) => Validation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationResult>): ValidationResult {
    return ValidationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationResult>): ValidationResult {
    const message = createBaseValidationResult();
    message.validations = object.validations?.map((e) => Validation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidation(): Validation {
  return { description: "", status: 0, message: [], code: "" };
}

export const Validation: MessageFns<Validation> = {
  encode(message: Validation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.message) {
      ValidationMessage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.code !== "") {
      writer.uint32(34).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Validation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message.push(ValidationMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Validation {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      status: isSet(object.status) ? validation_StatusFromJSON(object.status) : 0,
      message: globalThis.Array.isArray(object?.message)
        ? object.message.map((e: any) => ValidationMessage.fromJSON(e))
        : [],
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: Validation): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.status !== 0) {
      obj.status = validation_StatusToJSON(message.status);
    }
    if (message.message?.length) {
      obj.message = message.message.map((e) => ValidationMessage.toJSON(e));
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<Validation>): Validation {
    return Validation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Validation>): Validation {
    const message = createBaseValidation();
    message.description = object.description ?? "";
    message.status = object.status ?? 0;
    message.message = object.message?.map((e) => ValidationMessage.fromPartial(e)) || [];
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseValidationMessage(): ValidationMessage {
  return { message: "", level: 0, metadata: {}, code: "" };
}

export const ValidationMessage: MessageFns<ValidationMessage> = {
  encode(message: ValidationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.level !== 0) {
      writer.uint32(16).int32(message.level);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ValidationMessage_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.code !== "") {
      writer.uint32(34).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ValidationMessage_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationMessage {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      level: isSet(object.level) ? validationMessage_LevelFromJSON(object.level) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: ValidationMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.level !== 0) {
      obj.level = validationMessage_LevelToJSON(message.level);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationMessage>): ValidationMessage {
    return ValidationMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationMessage>): ValidationMessage {
    const message = createBaseValidationMessage();
    message.message = object.message ?? "";
    message.level = object.level ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseValidationMessage_MetadataEntry(): ValidationMessage_MetadataEntry {
  return { key: "", value: "" };
}

export const ValidationMessage_MetadataEntry: MessageFns<ValidationMessage_MetadataEntry> = {
  encode(message: ValidationMessage_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationMessage_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationMessage_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationMessage_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ValidationMessage_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationMessage_MetadataEntry>): ValidationMessage_MetadataEntry {
    return ValidationMessage_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationMessage_MetadataEntry>): ValidationMessage_MetadataEntry {
    const message = createBaseValidationMessage_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
