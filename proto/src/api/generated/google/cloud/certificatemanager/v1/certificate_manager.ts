// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/certificatemanager/v1/certificate_manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CertificateIssuanceConfig,
  CreateCertificateIssuanceConfigRequest,
  DeleteCertificateIssuanceConfigRequest,
  GetCertificateIssuanceConfigRequest,
  ListCertificateIssuanceConfigsRequest,
  ListCertificateIssuanceConfigsResponse,
} from "./certificate_issuance_config.js";
import {
  CreateTrustConfigRequest,
  DeleteTrustConfigRequest,
  GetTrustConfigRequest,
  ListTrustConfigsRequest,
  ListTrustConfigsResponse,
  TrustConfig,
  UpdateTrustConfigRequest,
} from "./trust_config.js";

export const protobufPackage = "google.cloud.certificatemanager.v1";

/** Defines set of serving states associated with a resource. */
export enum ServingState {
  /** SERVING_STATE_UNSPECIFIED - The status is undefined. */
  SERVING_STATE_UNSPECIFIED = 0,
  /** ACTIVE - The configuration is serving. */
  ACTIVE = 1,
  /** PENDING - Update is in progress. Some frontends may serve this configuration. */
  PENDING = 2,
  UNRECOGNIZED = -1,
}

export function servingStateFromJSON(object: any): ServingState {
  switch (object) {
    case 0:
    case "SERVING_STATE_UNSPECIFIED":
      return ServingState.SERVING_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ServingState.ACTIVE;
    case 2:
    case "PENDING":
      return ServingState.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServingState.UNRECOGNIZED;
  }
}

export function servingStateToJSON(object: ServingState): string {
  switch (object) {
    case ServingState.SERVING_STATE_UNSPECIFIED:
      return "SERVING_STATE_UNSPECIFIED";
    case ServingState.ACTIVE:
      return "ACTIVE";
    case ServingState.PENDING:
      return "PENDING";
    case ServingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for the `ListCertificates` method. */
export interface ListCertificatesRequest {
  /**
   * Required. The project and location from which the certificate should be
   * listed, specified in the format `projects/* /locations/*`.
   */
  parent: string;
  /** Maximum number of certificates to return per call. */
  pageSize: number;
  /**
   * The value returned by the last `ListCertificatesResponse`. Indicates that
   * this is a continuation of a prior `ListCertificates` call, and that the
   * system should return the next page of data.
   */
  pageToken: string;
  /** Filter expression to restrict the Certificates returned. */
  filter: string;
  /**
   * A list of Certificate field names used to specify the order of the returned
   * results. The default sorting order is ascending. To specify descending
   * order for a field, add a suffix `" desc"`.
   */
  orderBy: string;
}

/** Response for the `ListCertificates` method. */
export interface ListCertificatesResponse {
  /** A list of certificates for the parent resource. */
  certificates: Certificate[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
  /** A list of locations that could not be reached. */
  unreachable: string[];
}

/** Request for the `GetCertificate` method. */
export interface GetCertificateRequest {
  /**
   * Required. A name of the certificate to describe. Must be in the format
   * `projects/* /locations/* /certificates/*`.
   */
  name: string;
}

/** Request for the `CreateCertificate` method. */
export interface CreateCertificateRequest {
  /**
   * Required. The parent resource of the certificate. Must be in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /** Required. A user-provided name of the certificate. */
  certificateId: string;
  /** Required. A definition of the certificate to create. */
  certificate: Certificate | undefined;
}

/** Request for the `UpdateCertificate` method. */
export interface UpdateCertificateRequest {
  /** Required. A definition of the certificate to update. */
  certificate:
    | Certificate
    | undefined;
  /**
   * Required. The update mask applies to the resource. For the `FieldMask`
   * definition, see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   */
  updateMask: string[] | undefined;
}

/** Request for the `DeleteCertificate` method. */
export interface DeleteCertificateRequest {
  /**
   * Required. A name of the certificate to delete. Must be in the format
   * `projects/* /locations/* /certificates/*`.
   */
  name: string;
}

/** Request for the `ListCertificateMaps` method. */
export interface ListCertificateMapsRequest {
  /**
   * Required. The project and location from which the certificate maps should
   * be listed, specified in the format `projects/* /locations/*`.
   */
  parent: string;
  /** Maximum number of certificate maps to return per call. */
  pageSize: number;
  /**
   * The value returned by the last `ListCertificateMapsResponse`. Indicates
   * that this is a continuation of a prior `ListCertificateMaps` call, and that
   * the system should return the next page of data.
   */
  pageToken: string;
  /** Filter expression to restrict the Certificates Maps returned. */
  filter: string;
  /**
   * A list of Certificate Map field names used to specify the order of the
   * returned results. The default sorting order is ascending. To specify
   * descending order for a field, add a suffix `" desc"`.
   */
  orderBy: string;
}

/** Response for the `ListCertificateMaps` method. */
export interface ListCertificateMapsResponse {
  /** A list of certificate maps for the parent resource. */
  certificateMaps: CertificateMap[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for the `GetCertificateMap` method. */
export interface GetCertificateMapRequest {
  /**
   * Required. A name of the certificate map to describe. Must be in the format
   * `projects/* /locations/* /certificateMaps/*`.
   */
  name: string;
}

/** Request for the `CreateCertificateMap` method. */
export interface CreateCertificateMapRequest {
  /**
   * Required. The parent resource of the certificate map. Must be in the format
   * `projects/* /locations/*`.
   */
  parent: string;
  /** Required. A user-provided name of the certificate map. */
  certificateMapId: string;
  /** Required. A definition of the certificate map to create. */
  certificateMap: CertificateMap | undefined;
}

/** Request for the `UpdateCertificateMap` method. */
export interface UpdateCertificateMapRequest {
  /** Required. A definition of the certificate map to update. */
  certificateMap:
    | CertificateMap
    | undefined;
  /**
   * Required. The update mask applies to the resource. For the `FieldMask`
   * definition, see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   */
  updateMask: string[] | undefined;
}

/** Request for the `DeleteCertificateMap` method. */
export interface DeleteCertificateMapRequest {
  /**
   * Required. A name of the certificate map to delete. Must be in the format
   * `projects/* /locations/* /certificateMaps/*`.
   */
  name: string;
}

/** Request for the `ListCertificateMapEntries` method. */
export interface ListCertificateMapEntriesRequest {
  /**
   * Required. The project, location and certificate map from which the
   * certificate map entries should be listed, specified in the format
   * `projects/* /locations/* /certificateMaps/*`.
   */
  parent: string;
  /**
   * Maximum number of certificate map entries to return. The service may return
   * fewer than this value.
   * If unspecified, at most 50 certificate map entries will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * The value returned by the last `ListCertificateMapEntriesResponse`.
   * Indicates that this is a continuation of a prior
   * `ListCertificateMapEntries` call, and that the system should return the
   * next page of data.
   */
  pageToken: string;
  /** Filter expression to restrict the returned Certificate Map Entries. */
  filter: string;
  /**
   * A list of Certificate Map Entry field names used to specify
   * the order of the returned results. The default sorting order is ascending.
   * To specify descending order for a field, add a suffix `" desc"`.
   */
  orderBy: string;
}

/** Response for the `ListCertificateMapEntries` method. */
export interface ListCertificateMapEntriesResponse {
  /** A list of certificate map entries for the parent resource. */
  certificateMapEntries: CertificateMapEntry[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for the `GetCertificateMapEntry` method. */
export interface GetCertificateMapEntryRequest {
  /**
   * Required. A name of the certificate map entry to describe. Must be in the
   * format `projects/* /locations/* /certificateMaps/* /certificateMapEntries/*`.
   */
  name: string;
}

/** Request for the `CreateCertificateMapEntry` method. */
export interface CreateCertificateMapEntryRequest {
  /**
   * Required. The parent resource of the certificate map entry. Must be in the
   * format `projects/* /locations/* /certificateMaps/*`.
   */
  parent: string;
  /** Required. A user-provided name of the certificate map entry. */
  certificateMapEntryId: string;
  /** Required. A definition of the certificate map entry to create. */
  certificateMapEntry: CertificateMapEntry | undefined;
}

/** Request for the `UpdateCertificateMapEntry` method. */
export interface UpdateCertificateMapEntryRequest {
  /** Required. A definition of the certificate map entry to create map entry. */
  certificateMapEntry:
    | CertificateMapEntry
    | undefined;
  /**
   * Required. The update mask applies to the resource. For the `FieldMask`
   * definition, see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   */
  updateMask: string[] | undefined;
}

/** Request for the `DeleteCertificateMapEntry` method. */
export interface DeleteCertificateMapEntryRequest {
  /**
   * Required. A name of the certificate map entry to delete. Must be in the
   * format `projects/* /locations/* /certificateMaps/* /certificateMapEntries/*`.
   */
  name: string;
}

/** Request for the `ListDnsAuthorizations` method. */
export interface ListDnsAuthorizationsRequest {
  /**
   * Required. The project and location from which the dns authorizations should
   * be listed, specified in the format `projects/* /locations/*`.
   */
  parent: string;
  /** Maximum number of dns authorizations to return per call. */
  pageSize: number;
  /**
   * The value returned by the last `ListDnsAuthorizationsResponse`. Indicates
   * that this is a continuation of a prior `ListDnsAuthorizations` call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
  /** Filter expression to restrict the Dns Authorizations returned. */
  filter: string;
  /**
   * A list of Dns Authorization field names used to specify the order of the
   * returned results. The default sorting order is ascending. To specify
   * descending order for a field, add a suffix `" desc"`.
   */
  orderBy: string;
}

/** Response for the `ListDnsAuthorizations` method. */
export interface ListDnsAuthorizationsResponse {
  /** A list of dns authorizations for the parent resource. */
  dnsAuthorizations: DnsAuthorization[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for the `GetDnsAuthorization` method. */
export interface GetDnsAuthorizationRequest {
  /**
   * Required. A name of the dns authorization to describe. Must be in the
   * format `projects/* /locations/* /dnsAuthorizations/*`.
   */
  name: string;
}

/** Request for the `CreateDnsAuthorization` method. */
export interface CreateDnsAuthorizationRequest {
  /**
   * Required. The parent resource of the dns authorization. Must be in the
   * format `projects/* /locations/*`.
   */
  parent: string;
  /** Required. A user-provided name of the dns authorization. */
  dnsAuthorizationId: string;
  /** Required. A definition of the dns authorization to create. */
  dnsAuthorization: DnsAuthorization | undefined;
}

/** Request for the `UpdateDnsAuthorization` method. */
export interface UpdateDnsAuthorizationRequest {
  /** Required. A definition of the dns authorization to update. */
  dnsAuthorization:
    | DnsAuthorization
    | undefined;
  /**
   * Required. The update mask applies to the resource. For the `FieldMask`
   * definition, see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask.
   */
  updateMask: string[] | undefined;
}

/** Request for the `DeleteDnsAuthorization` method. */
export interface DeleteDnsAuthorizationRequest {
  /**
   * Required. A name of the dns authorization to delete. Must be in the format
   * `projects/* /locations/* /dnsAuthorizations/*`.
   */
  name: string;
}

/** Represents the metadata of the long-running operation. Output only. */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Server-defined resource path for the target of the operation. */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
  /** Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** API version used to start the operation. */
  apiVersion: string;
}

/** Defines TLS certificate. */
export interface Certificate {
  /**
   * A user-defined name of the certificate. Certificate names must be unique
   * globally and match pattern `projects/* /locations/* /certificates/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate. */
  description: string;
  /** Output only. The creation timestamp of a Certificate. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update timestamp of a Certificate. */
  updateTime:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate. */
  labels: { [key: string]: string };
  /** If set, defines data of a self-managed certificate. */
  selfManaged?:
    | Certificate_SelfManagedCertificate
    | undefined;
  /** If set, contains configuration and state of a managed certificate. */
  managed?:
    | Certificate_ManagedCertificate
    | undefined;
  /**
   * Output only. The list of Subject Alternative Names of dnsName type defined
   * in the certificate (see RFC 5280 4.2.1.6). Managed certificates that
   * haven't been provisioned yet have this field populated with a value of the
   * managed.domains field.
   */
  sanDnsnames: string[];
  /** Output only. The PEM-encoded certificate chain. */
  pemCertificate: string;
  /** Output only. The expiry timestamp of a Certificate. */
  expireTime:
    | Date
    | undefined;
  /** Immutable. The scope of the certificate. */
  scope: Certificate_Scope;
}

/** Certificate scope. */
export enum Certificate_Scope {
  /**
   * DEFAULT - Certificates with default scope are served from core Google data centers.
   * If unsure, choose this option.
   */
  DEFAULT = 0,
  /**
   * EDGE_CACHE - Certificates with scope EDGE_CACHE are special-purposed certificates,
   * served from Edge Points of Presence.
   * See https://cloud.google.com/vpc/docs/edge-locations.
   */
  EDGE_CACHE = 1,
  /**
   * ALL_REGIONS - Certificates with ALL_REGIONS scope are served from all Google Cloud
   * regions. See https://cloud.google.com/compute/docs/regions-zones.
   */
  ALL_REGIONS = 2,
  UNRECOGNIZED = -1,
}

export function certificate_ScopeFromJSON(object: any): Certificate_Scope {
  switch (object) {
    case 0:
    case "DEFAULT":
      return Certificate_Scope.DEFAULT;
    case 1:
    case "EDGE_CACHE":
      return Certificate_Scope.EDGE_CACHE;
    case 2:
    case "ALL_REGIONS":
      return Certificate_Scope.ALL_REGIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_Scope.UNRECOGNIZED;
  }
}

export function certificate_ScopeToJSON(object: Certificate_Scope): string {
  switch (object) {
    case Certificate_Scope.DEFAULT:
      return "DEFAULT";
    case Certificate_Scope.EDGE_CACHE:
      return "EDGE_CACHE";
    case Certificate_Scope.ALL_REGIONS:
      return "ALL_REGIONS";
    case Certificate_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Certificate data for a SelfManaged Certificate.
 * SelfManaged Certificates are uploaded by the user. Updating such
 * certificates before they expire remains the user's responsibility.
 */
export interface Certificate_SelfManagedCertificate {
  /**
   * Input only. The PEM-encoded certificate chain.
   * Leaf certificate comes first, followed by intermediate ones if any.
   */
  pemCertificate: string;
  /** Input only. The PEM-encoded private key of the leaf certificate. */
  pemPrivateKey: string;
}

/**
 * Configuration and state of a Managed Certificate.
 * Certificate Manager provisions and renews Managed Certificates
 * automatically, for as long as it's authorized to do so.
 */
export interface Certificate_ManagedCertificate {
  /**
   * Immutable. The domains for which a managed SSL certificate will be
   * generated. Wildcard domains are only supported with DNS challenge
   * resolution.
   */
  domains: string[];
  /**
   * Immutable. Authorizations that will be used for performing domain
   * authorization.
   */
  dnsAuthorizations: string[];
  /**
   * Immutable. The resource name for a
   * [CertificateIssuanceConfig][google.cloud.certificatemanager.v1.CertificateIssuanceConfig]
   * used to configure private PKI certificates in the format
   * `projects/* /locations/* /certificateIssuanceConfigs/*`.
   * If this field is not set, the certificates will instead be publicly
   * signed as documented at
   * https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs#caa.
   */
  issuanceConfig: string;
  /** Output only. State of the managed certificate resource. */
  state: Certificate_ManagedCertificate_State;
  /**
   * Output only. Information about issues with provisioning a Managed
   * Certificate.
   */
  provisioningIssue:
    | Certificate_ManagedCertificate_ProvisioningIssue
    | undefined;
  /**
   * Output only. Detailed state of the latest authorization attempt for each
   * domain specified for managed certificate resource.
   */
  authorizationAttemptInfo: Certificate_ManagedCertificate_AuthorizationAttemptInfo[];
}

/** State of the managed certificate resource. */
export enum Certificate_ManagedCertificate_State {
  /** STATE_UNSPECIFIED - State is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * PROVISIONING - Certificate Manager attempts to provision or renew the certificate.
   * If the process takes longer than expected, consult the
   * `provisioning_issue` field.
   */
  PROVISIONING = 1,
  /**
   * FAILED - Multiple certificate provisioning attempts failed and Certificate
   * Manager gave up. To try again, delete and create a new managed
   * Certificate resource.
   * For details see the `provisioning_issue` field.
   */
  FAILED = 2,
  /**
   * ACTIVE - The certificate management is working, and a certificate has been
   * provisioned.
   */
  ACTIVE = 3,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_StateFromJSON(object: any): Certificate_ManagedCertificate_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Certificate_ManagedCertificate_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Certificate_ManagedCertificate_State.PROVISIONING;
    case 2:
    case "FAILED":
      return Certificate_ManagedCertificate_State.FAILED;
    case 3:
    case "ACTIVE":
      return Certificate_ManagedCertificate_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_State.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_StateToJSON(object: Certificate_ManagedCertificate_State): string {
  switch (object) {
    case Certificate_ManagedCertificate_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Certificate_ManagedCertificate_State.PROVISIONING:
      return "PROVISIONING";
    case Certificate_ManagedCertificate_State.FAILED:
      return "FAILED";
    case Certificate_ManagedCertificate_State.ACTIVE:
      return "ACTIVE";
    case Certificate_ManagedCertificate_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about issues with provisioning a Managed Certificate. */
export interface Certificate_ManagedCertificate_ProvisioningIssue {
  /** Output only. Reason for provisioning failures. */
  reason: Certificate_ManagedCertificate_ProvisioningIssue_Reason;
  /**
   * Output only. Human readable explanation about the issue. Provided to
   * help address the configuration issues. Not guaranteed to be stable. For
   * programmatic access use Reason enum.
   */
  details: string;
}

/** Reason for provisioning failures. */
export enum Certificate_ManagedCertificate_ProvisioningIssue_Reason {
  /** REASON_UNSPECIFIED - Reason is unspecified. */
  REASON_UNSPECIFIED = 0,
  /**
   * AUTHORIZATION_ISSUE - Certificate provisioning failed due to an issue with one or more of
   * the domains on the certificate.
   * For details of which domains failed, consult the
   * `authorization_attempt_info` field.
   */
  AUTHORIZATION_ISSUE = 1,
  /**
   * RATE_LIMITED - Exceeded Certificate Authority quotas or internal rate limits of the
   * system. Provisioning may take longer to complete.
   */
  RATE_LIMITED = 2,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_ProvisioningIssue_ReasonFromJSON(
  object: any,
): Certificate_ManagedCertificate_ProvisioningIssue_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.REASON_UNSPECIFIED;
    case 1:
    case "AUTHORIZATION_ISSUE":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.AUTHORIZATION_ISSUE;
    case 2:
    case "RATE_LIMITED":
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.RATE_LIMITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_ProvisioningIssue_Reason.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_ProvisioningIssue_ReasonToJSON(
  object: Certificate_ManagedCertificate_ProvisioningIssue_Reason,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.AUTHORIZATION_ISSUE:
      return "AUTHORIZATION_ISSUE";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.RATE_LIMITED:
      return "RATE_LIMITED";
    case Certificate_ManagedCertificate_ProvisioningIssue_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * State of the latest attempt to authorize a domain for certificate
 * issuance.
 */
export interface Certificate_ManagedCertificate_AuthorizationAttemptInfo {
  /** Domain name of the authorization attempt. */
  domain: string;
  /** Output only. State of the domain for managed certificate issuance. */
  state: Certificate_ManagedCertificate_AuthorizationAttemptInfo_State;
  /**
   * Output only. Reason for failure of the authorization attempt for the
   * domain.
   */
  failureReason: Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason;
  /**
   * Output only. Human readable explanation for reaching the state.
   * Provided to help address the configuration issues. Not guaranteed to be
   * stable. For programmatic access use FailureReason enum.
   */
  details: string;
}

/** State of the domain for managed certificate issuance. */
export enum Certificate_ManagedCertificate_AuthorizationAttemptInfo_State {
  /** STATE_UNSPECIFIED - State is unspecified. */
  STATE_UNSPECIFIED = 0,
  /**
   * AUTHORIZING - Certificate provisioning for this domain is under way. Google Cloud
   * will attempt to authorize the domain.
   */
  AUTHORIZING = 1,
  /** AUTHORIZED - A managed certificate can be provisioned, no issues for this domain. */
  AUTHORIZED = 6,
  /**
   * FAILED - Attempt to authorize the domain failed. This prevents the Managed
   * Certificate from being issued.
   * See `failure_reason` and `details` fields for more information.
   */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_StateFromJSON(
  object: any,
): Certificate_ManagedCertificate_AuthorizationAttemptInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "AUTHORIZING":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZING;
    case 6:
    case "AUTHORIZED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZED;
    case 7:
    case "FAILED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_StateToJSON(
  object: Certificate_ManagedCertificate_AuthorizationAttemptInfo_State,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZING:
      return "AUTHORIZING";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.AUTHORIZED:
      return "AUTHORIZED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.FAILED:
      return "FAILED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reason for failure of the authorization attempt for the domain. */
export enum Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason {
  /** FAILURE_REASON_UNSPECIFIED - FailureReason is unspecified. */
  FAILURE_REASON_UNSPECIFIED = 0,
  /**
   * CONFIG - There was a problem with the user's DNS or load balancer
   * configuration for this domain.
   */
  CONFIG = 1,
  /**
   * CAA - Certificate issuance forbidden by an explicit CAA record for the
   * domain or a failure to check CAA records for the domain.
   */
  CAA = 2,
  /**
   * RATE_LIMITED - Reached a CA or internal rate-limit for the domain,
   * e.g. for certificates per top-level private domain.
   */
  RATE_LIMITED = 3,
  UNRECOGNIZED = -1,
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonFromJSON(
  object: any,
): Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason {
  switch (object) {
    case 0:
    case "FAILURE_REASON_UNSPECIFIED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.FAILURE_REASON_UNSPECIFIED;
    case 1:
    case "CONFIG":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CONFIG;
    case 2:
    case "CAA":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CAA;
    case 3:
    case "RATE_LIMITED":
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.RATE_LIMITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.UNRECOGNIZED;
  }
}

export function certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonToJSON(
  object: Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason,
): string {
  switch (object) {
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.FAILURE_REASON_UNSPECIFIED:
      return "FAILURE_REASON_UNSPECIFIED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CONFIG:
      return "CONFIG";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.CAA:
      return "CAA";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.RATE_LIMITED:
      return "RATE_LIMITED";
    case Certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Certificate_LabelsEntry {
  key: string;
  value: string;
}

/** Defines a collection of certificate configurations. */
export interface CertificateMap {
  /**
   * A user-defined name of the Certificate Map. Certificate Map names must be
   * unique globally and match pattern
   * `projects/* /locations/* /certificateMaps/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate map. */
  description: string;
  /** Output only. The creation timestamp of a Certificate Map. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update timestamp of a Certificate Map. */
  updateTime:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate Map. */
  labels: { [key: string]: string };
  /**
   * Output only. A list of GCLB targets that use this Certificate Map.
   * A Target Proxy is only present on this list if it's attached to a
   * Forwarding Rule.
   */
  gclbTargets: CertificateMap_GclbTarget[];
}

/** Describes a Target Proxy that uses this Certificate Map. */
export interface CertificateMap_GclbTarget {
  /**
   * Output only. This field returns the resource name in the following
   * format:
   * `//compute.googleapis.com/projects/* /global/targetHttpsProxies/*`.
   */
  targetHttpsProxy?:
    | string
    | undefined;
  /**
   * Output only. This field returns the resource name in the following
   * format:
   * `//compute.googleapis.com/projects/* /global/targetSslProxies/*`.
   */
  targetSslProxy?:
    | string
    | undefined;
  /**
   * Output only. IP configurations for this Target Proxy where the
   * Certificate Map is serving.
   */
  ipConfigs: CertificateMap_GclbTarget_IpConfig[];
}

/** Defines IP configuration where this Certificate Map is serving. */
export interface CertificateMap_GclbTarget_IpConfig {
  /** Output only. An external IP address. */
  ipAddress: string;
  /** Output only. Ports. */
  ports: number[];
}

export interface CertificateMap_LabelsEntry {
  key: string;
  value: string;
}

/** Defines a certificate map entry. */
export interface CertificateMapEntry {
  /**
   * A user-defined name of the Certificate Map Entry. Certificate Map Entry
   * names must be unique globally and match pattern
   * `projects/* /locations/* /certificateMaps/* /certificateMapEntries/*`.
   */
  name: string;
  /** One or more paragraphs of text description of a certificate map entry. */
  description: string;
  /** Output only. The creation timestamp of a Certificate Map Entry. */
  createTime:
    | Date
    | undefined;
  /** Output only. The update timestamp of a Certificate Map Entry. */
  updateTime:
    | Date
    | undefined;
  /** Set of labels associated with a Certificate Map Entry. */
  labels: { [key: string]: string };
  /**
   * A Hostname (FQDN, e.g. `example.com`) or a wildcard hostname expression
   * (`*.example.com`) for a set of hostnames with common suffix. Used as
   * Server Name Indication (SNI) for selecting a proper certificate.
   */
  hostname?:
    | string
    | undefined;
  /** A predefined matcher for particular cases, other than SNI selection. */
  matcher?:
    | CertificateMapEntry_Matcher
    | undefined;
  /**
   * A set of Certificates defines for the given `hostname`. There can be
   * defined up to four certificates in each Certificate Map Entry. Each
   * certificate must match pattern `projects/* /locations/* /certificates/*`.
   */
  certificates: string[];
  /** Output only. A serving state of this Certificate Map Entry. */
  state: ServingState;
}

/**
 * Defines predefined cases other than SNI-hostname match when this
 * configuration should be applied.
 */
export enum CertificateMapEntry_Matcher {
  /** MATCHER_UNSPECIFIED - A matcher has't been recognized. */
  MATCHER_UNSPECIFIED = 0,
  /**
   * PRIMARY - A primary certificate that is served when SNI wasn't specified in the
   * request or SNI couldn't be found in the map.
   */
  PRIMARY = 1,
  UNRECOGNIZED = -1,
}

export function certificateMapEntry_MatcherFromJSON(object: any): CertificateMapEntry_Matcher {
  switch (object) {
    case 0:
    case "MATCHER_UNSPECIFIED":
      return CertificateMapEntry_Matcher.MATCHER_UNSPECIFIED;
    case 1:
    case "PRIMARY":
      return CertificateMapEntry_Matcher.PRIMARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateMapEntry_Matcher.UNRECOGNIZED;
  }
}

export function certificateMapEntry_MatcherToJSON(object: CertificateMapEntry_Matcher): string {
  switch (object) {
    case CertificateMapEntry_Matcher.MATCHER_UNSPECIFIED:
      return "MATCHER_UNSPECIFIED";
    case CertificateMapEntry_Matcher.PRIMARY:
      return "PRIMARY";
    case CertificateMapEntry_Matcher.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CertificateMapEntry_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A DnsAuthorization resource describes a way to perform domain authorization
 * for certificate issuance.
 */
export interface DnsAuthorization {
  /**
   * A user-defined name of the dns authorization. DnsAuthorization names must
   * be unique globally and match pattern
   * `projects/* /locations/* /dnsAuthorizations/*`.
   */
  name: string;
  /** Output only. The creation timestamp of a DnsAuthorization. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update timestamp of a DnsAuthorization. */
  updateTime:
    | Date
    | undefined;
  /** Set of labels associated with a DnsAuthorization. */
  labels: { [key: string]: string };
  /** One or more paragraphs of text description of a DnsAuthorization. */
  description: string;
  /**
   * Required. Immutable. A domain that is being authorized. A DnsAuthorization
   * resource covers a single domain and its wildcard, e.g. authorization for
   * `example.com` can be used to issue certificates for `example.com` and
   * `*.example.com`.
   */
  domain: string;
  /**
   * Output only. DNS Resource Record that needs to be added to DNS
   * configuration.
   */
  dnsResourceRecord:
    | DnsAuthorization_DnsResourceRecord
    | undefined;
  /**
   * Immutable. Type of DnsAuthorization. If unset during resource creation the
   * following default will be used:
   * - in location global: FIXED_RECORD.
   */
  type: DnsAuthorization_Type;
}

/** DnsAuthorization type. */
export enum DnsAuthorization_Type {
  /** TYPE_UNSPECIFIED - Type is unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** FIXED_RECORD - FIXED_RECORD DNS authorization uses DNS-01 validation method. */
  FIXED_RECORD = 1,
  /**
   * PER_PROJECT_RECORD - PER_PROJECT_RECORD DNS authorization allows for independent management
   * of Google-managed certificates with DNS authorization across multiple
   * projects.
   */
  PER_PROJECT_RECORD = 2,
  UNRECOGNIZED = -1,
}

export function dnsAuthorization_TypeFromJSON(object: any): DnsAuthorization_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return DnsAuthorization_Type.TYPE_UNSPECIFIED;
    case 1:
    case "FIXED_RECORD":
      return DnsAuthorization_Type.FIXED_RECORD;
    case 2:
    case "PER_PROJECT_RECORD":
      return DnsAuthorization_Type.PER_PROJECT_RECORD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DnsAuthorization_Type.UNRECOGNIZED;
  }
}

export function dnsAuthorization_TypeToJSON(object: DnsAuthorization_Type): string {
  switch (object) {
    case DnsAuthorization_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case DnsAuthorization_Type.FIXED_RECORD:
      return "FIXED_RECORD";
    case DnsAuthorization_Type.PER_PROJECT_RECORD:
      return "PER_PROJECT_RECORD";
    case DnsAuthorization_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The structure describing the DNS Resource Record that needs to be added
 * to DNS configuration for the authorization to be usable by
 * certificate.
 */
export interface DnsAuthorization_DnsResourceRecord {
  /**
   * Output only. Fully qualified name of the DNS Resource Record.
   * e.g. `_acme-challenge.example.com`
   */
  name: string;
  /**
   * Output only. Type of the DNS Resource Record.
   * Currently always set to "CNAME".
   */
  type: string;
  /** Output only. Data of the DNS Resource Record. */
  data: string;
}

export interface DnsAuthorization_LabelsEntry {
  key: string;
  value: string;
}

function createBaseListCertificatesRequest(): ListCertificatesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCertificatesRequest: MessageFns<ListCertificatesRequest> = {
  encode(message: ListCertificatesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificatesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificatesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificatesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCertificatesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificatesRequest>): ListCertificatesRequest {
    return ListCertificatesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificatesRequest>): ListCertificatesRequest {
    const message = createBaseListCertificatesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCertificatesResponse(): ListCertificatesResponse {
  return { certificates: [], nextPageToken: "", unreachable: [] };
}

export const ListCertificatesResponse: MessageFns<ListCertificatesResponse> = {
  encode(message: ListCertificatesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.certificates) {
      Certificate.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificatesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificatesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificates.push(Certificate.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificatesResponse {
    return {
      certificates: globalThis.Array.isArray(object?.certificates)
        ? object.certificates.map((e: any) => Certificate.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCertificatesResponse): unknown {
    const obj: any = {};
    if (message.certificates?.length) {
      obj.certificates = message.certificates.map((e) => Certificate.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificatesResponse>): ListCertificatesResponse {
    return ListCertificatesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificatesResponse>): ListCertificatesResponse {
    const message = createBaseListCertificatesResponse();
    message.certificates = object.certificates?.map((e) => Certificate.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCertificateRequest(): GetCertificateRequest {
  return { name: "" };
}

export const GetCertificateRequest: MessageFns<GetCertificateRequest> = {
  encode(message: GetCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCertificateRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCertificateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCertificateRequest>): GetCertificateRequest {
    return GetCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCertificateRequest>): GetCertificateRequest {
    const message = createBaseGetCertificateRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateCertificateRequest(): CreateCertificateRequest {
  return { parent: "", certificateId: "", certificate: undefined };
}

export const CreateCertificateRequest: MessageFns<CreateCertificateRequest> = {
  encode(message: CreateCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.certificateId !== "") {
      writer.uint32(18).string(message.certificateId);
    }
    if (message.certificate !== undefined) {
      Certificate.encode(message.certificate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificateId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.certificate = Certificate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCertificateRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      certificateId: isSet(object.certificateId) ? globalThis.String(object.certificateId) : "",
      certificate: isSet(object.certificate) ? Certificate.fromJSON(object.certificate) : undefined,
    };
  },

  toJSON(message: CreateCertificateRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.certificateId !== "") {
      obj.certificateId = message.certificateId;
    }
    if (message.certificate !== undefined) {
      obj.certificate = Certificate.toJSON(message.certificate);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCertificateRequest>): CreateCertificateRequest {
    return CreateCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCertificateRequest>): CreateCertificateRequest {
    const message = createBaseCreateCertificateRequest();
    message.parent = object.parent ?? "";
    message.certificateId = object.certificateId ?? "";
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? Certificate.fromPartial(object.certificate)
      : undefined;
    return message;
  },
};

function createBaseUpdateCertificateRequest(): UpdateCertificateRequest {
  return { certificate: undefined, updateMask: undefined };
}

export const UpdateCertificateRequest: MessageFns<UpdateCertificateRequest> = {
  encode(message: UpdateCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificate !== undefined) {
      Certificate.encode(message.certificate, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificate = Certificate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCertificateRequest {
    return {
      certificate: isSet(object.certificate) ? Certificate.fromJSON(object.certificate) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCertificateRequest): unknown {
    const obj: any = {};
    if (message.certificate !== undefined) {
      obj.certificate = Certificate.toJSON(message.certificate);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCertificateRequest>): UpdateCertificateRequest {
    return UpdateCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCertificateRequest>): UpdateCertificateRequest {
    const message = createBaseUpdateCertificateRequest();
    message.certificate = (object.certificate !== undefined && object.certificate !== null)
      ? Certificate.fromPartial(object.certificate)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCertificateRequest(): DeleteCertificateRequest {
  return { name: "" };
}

export const DeleteCertificateRequest: MessageFns<DeleteCertificateRequest> = {
  encode(message: DeleteCertificateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCertificateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCertificateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCertificateRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCertificateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCertificateRequest>): DeleteCertificateRequest {
    return DeleteCertificateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCertificateRequest>): DeleteCertificateRequest {
    const message = createBaseDeleteCertificateRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListCertificateMapsRequest(): ListCertificateMapsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCertificateMapsRequest: MessageFns<ListCertificateMapsRequest> = {
  encode(message: ListCertificateMapsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificateMapsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificateMapsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificateMapsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCertificateMapsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificateMapsRequest>): ListCertificateMapsRequest {
    return ListCertificateMapsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificateMapsRequest>): ListCertificateMapsRequest {
    const message = createBaseListCertificateMapsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCertificateMapsResponse(): ListCertificateMapsResponse {
  return { certificateMaps: [], nextPageToken: "", unreachable: [] };
}

export const ListCertificateMapsResponse: MessageFns<ListCertificateMapsResponse> = {
  encode(message: ListCertificateMapsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.certificateMaps) {
      CertificateMap.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificateMapsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificateMapsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateMaps.push(CertificateMap.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificateMapsResponse {
    return {
      certificateMaps: globalThis.Array.isArray(object?.certificateMaps)
        ? object.certificateMaps.map((e: any) => CertificateMap.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCertificateMapsResponse): unknown {
    const obj: any = {};
    if (message.certificateMaps?.length) {
      obj.certificateMaps = message.certificateMaps.map((e) => CertificateMap.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificateMapsResponse>): ListCertificateMapsResponse {
    return ListCertificateMapsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificateMapsResponse>): ListCertificateMapsResponse {
    const message = createBaseListCertificateMapsResponse();
    message.certificateMaps = object.certificateMaps?.map((e) => CertificateMap.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCertificateMapRequest(): GetCertificateMapRequest {
  return { name: "" };
}

export const GetCertificateMapRequest: MessageFns<GetCertificateMapRequest> = {
  encode(message: GetCertificateMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCertificateMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCertificateMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCertificateMapRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCertificateMapRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCertificateMapRequest>): GetCertificateMapRequest {
    return GetCertificateMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCertificateMapRequest>): GetCertificateMapRequest {
    const message = createBaseGetCertificateMapRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateCertificateMapRequest(): CreateCertificateMapRequest {
  return { parent: "", certificateMapId: "", certificateMap: undefined };
}

export const CreateCertificateMapRequest: MessageFns<CreateCertificateMapRequest> = {
  encode(message: CreateCertificateMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.certificateMapId !== "") {
      writer.uint32(18).string(message.certificateMapId);
    }
    if (message.certificateMap !== undefined) {
      CertificateMap.encode(message.certificateMap, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCertificateMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCertificateMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificateMapId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.certificateMap = CertificateMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCertificateMapRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      certificateMapId: isSet(object.certificateMapId) ? globalThis.String(object.certificateMapId) : "",
      certificateMap: isSet(object.certificateMap) ? CertificateMap.fromJSON(object.certificateMap) : undefined,
    };
  },

  toJSON(message: CreateCertificateMapRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.certificateMapId !== "") {
      obj.certificateMapId = message.certificateMapId;
    }
    if (message.certificateMap !== undefined) {
      obj.certificateMap = CertificateMap.toJSON(message.certificateMap);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCertificateMapRequest>): CreateCertificateMapRequest {
    return CreateCertificateMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCertificateMapRequest>): CreateCertificateMapRequest {
    const message = createBaseCreateCertificateMapRequest();
    message.parent = object.parent ?? "";
    message.certificateMapId = object.certificateMapId ?? "";
    message.certificateMap = (object.certificateMap !== undefined && object.certificateMap !== null)
      ? CertificateMap.fromPartial(object.certificateMap)
      : undefined;
    return message;
  },
};

function createBaseUpdateCertificateMapRequest(): UpdateCertificateMapRequest {
  return { certificateMap: undefined, updateMask: undefined };
}

export const UpdateCertificateMapRequest: MessageFns<UpdateCertificateMapRequest> = {
  encode(message: UpdateCertificateMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificateMap !== undefined) {
      CertificateMap.encode(message.certificateMap, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCertificateMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCertificateMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateMap = CertificateMap.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCertificateMapRequest {
    return {
      certificateMap: isSet(object.certificateMap) ? CertificateMap.fromJSON(object.certificateMap) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCertificateMapRequest): unknown {
    const obj: any = {};
    if (message.certificateMap !== undefined) {
      obj.certificateMap = CertificateMap.toJSON(message.certificateMap);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCertificateMapRequest>): UpdateCertificateMapRequest {
    return UpdateCertificateMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCertificateMapRequest>): UpdateCertificateMapRequest {
    const message = createBaseUpdateCertificateMapRequest();
    message.certificateMap = (object.certificateMap !== undefined && object.certificateMap !== null)
      ? CertificateMap.fromPartial(object.certificateMap)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCertificateMapRequest(): DeleteCertificateMapRequest {
  return { name: "" };
}

export const DeleteCertificateMapRequest: MessageFns<DeleteCertificateMapRequest> = {
  encode(message: DeleteCertificateMapRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCertificateMapRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCertificateMapRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCertificateMapRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCertificateMapRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCertificateMapRequest>): DeleteCertificateMapRequest {
    return DeleteCertificateMapRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCertificateMapRequest>): DeleteCertificateMapRequest {
    const message = createBaseDeleteCertificateMapRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListCertificateMapEntriesRequest(): ListCertificateMapEntriesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListCertificateMapEntriesRequest: MessageFns<ListCertificateMapEntriesRequest> = {
  encode(message: ListCertificateMapEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificateMapEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificateMapEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificateMapEntriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListCertificateMapEntriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificateMapEntriesRequest>): ListCertificateMapEntriesRequest {
    return ListCertificateMapEntriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificateMapEntriesRequest>): ListCertificateMapEntriesRequest {
    const message = createBaseListCertificateMapEntriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListCertificateMapEntriesResponse(): ListCertificateMapEntriesResponse {
  return { certificateMapEntries: [], nextPageToken: "", unreachable: [] };
}

export const ListCertificateMapEntriesResponse: MessageFns<ListCertificateMapEntriesResponse> = {
  encode(message: ListCertificateMapEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.certificateMapEntries) {
      CertificateMapEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCertificateMapEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCertificateMapEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateMapEntries.push(CertificateMapEntry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCertificateMapEntriesResponse {
    return {
      certificateMapEntries: globalThis.Array.isArray(object?.certificateMapEntries)
        ? object.certificateMapEntries.map((e: any) => CertificateMapEntry.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListCertificateMapEntriesResponse): unknown {
    const obj: any = {};
    if (message.certificateMapEntries?.length) {
      obj.certificateMapEntries = message.certificateMapEntries.map((e) => CertificateMapEntry.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCertificateMapEntriesResponse>): ListCertificateMapEntriesResponse {
    return ListCertificateMapEntriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCertificateMapEntriesResponse>): ListCertificateMapEntriesResponse {
    const message = createBaseListCertificateMapEntriesResponse();
    message.certificateMapEntries = object.certificateMapEntries?.map((e) => CertificateMapEntry.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCertificateMapEntryRequest(): GetCertificateMapEntryRequest {
  return { name: "" };
}

export const GetCertificateMapEntryRequest: MessageFns<GetCertificateMapEntryRequest> = {
  encode(message: GetCertificateMapEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCertificateMapEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCertificateMapEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCertificateMapEntryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCertificateMapEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCertificateMapEntryRequest>): GetCertificateMapEntryRequest {
    return GetCertificateMapEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCertificateMapEntryRequest>): GetCertificateMapEntryRequest {
    const message = createBaseGetCertificateMapEntryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateCertificateMapEntryRequest(): CreateCertificateMapEntryRequest {
  return { parent: "", certificateMapEntryId: "", certificateMapEntry: undefined };
}

export const CreateCertificateMapEntryRequest: MessageFns<CreateCertificateMapEntryRequest> = {
  encode(message: CreateCertificateMapEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.certificateMapEntryId !== "") {
      writer.uint32(18).string(message.certificateMapEntryId);
    }
    if (message.certificateMapEntry !== undefined) {
      CertificateMapEntry.encode(message.certificateMapEntry, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCertificateMapEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCertificateMapEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificateMapEntryId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.certificateMapEntry = CertificateMapEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCertificateMapEntryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      certificateMapEntryId: isSet(object.certificateMapEntryId) ? globalThis.String(object.certificateMapEntryId) : "",
      certificateMapEntry: isSet(object.certificateMapEntry)
        ? CertificateMapEntry.fromJSON(object.certificateMapEntry)
        : undefined,
    };
  },

  toJSON(message: CreateCertificateMapEntryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.certificateMapEntryId !== "") {
      obj.certificateMapEntryId = message.certificateMapEntryId;
    }
    if (message.certificateMapEntry !== undefined) {
      obj.certificateMapEntry = CertificateMapEntry.toJSON(message.certificateMapEntry);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCertificateMapEntryRequest>): CreateCertificateMapEntryRequest {
    return CreateCertificateMapEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCertificateMapEntryRequest>): CreateCertificateMapEntryRequest {
    const message = createBaseCreateCertificateMapEntryRequest();
    message.parent = object.parent ?? "";
    message.certificateMapEntryId = object.certificateMapEntryId ?? "";
    message.certificateMapEntry = (object.certificateMapEntry !== undefined && object.certificateMapEntry !== null)
      ? CertificateMapEntry.fromPartial(object.certificateMapEntry)
      : undefined;
    return message;
  },
};

function createBaseUpdateCertificateMapEntryRequest(): UpdateCertificateMapEntryRequest {
  return { certificateMapEntry: undefined, updateMask: undefined };
}

export const UpdateCertificateMapEntryRequest: MessageFns<UpdateCertificateMapEntryRequest> = {
  encode(message: UpdateCertificateMapEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificateMapEntry !== undefined) {
      CertificateMapEntry.encode(message.certificateMapEntry, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCertificateMapEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCertificateMapEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateMapEntry = CertificateMapEntry.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCertificateMapEntryRequest {
    return {
      certificateMapEntry: isSet(object.certificateMapEntry)
        ? CertificateMapEntry.fromJSON(object.certificateMapEntry)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCertificateMapEntryRequest): unknown {
    const obj: any = {};
    if (message.certificateMapEntry !== undefined) {
      obj.certificateMapEntry = CertificateMapEntry.toJSON(message.certificateMapEntry);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCertificateMapEntryRequest>): UpdateCertificateMapEntryRequest {
    return UpdateCertificateMapEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCertificateMapEntryRequest>): UpdateCertificateMapEntryRequest {
    const message = createBaseUpdateCertificateMapEntryRequest();
    message.certificateMapEntry = (object.certificateMapEntry !== undefined && object.certificateMapEntry !== null)
      ? CertificateMapEntry.fromPartial(object.certificateMapEntry)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCertificateMapEntryRequest(): DeleteCertificateMapEntryRequest {
  return { name: "" };
}

export const DeleteCertificateMapEntryRequest: MessageFns<DeleteCertificateMapEntryRequest> = {
  encode(message: DeleteCertificateMapEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCertificateMapEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCertificateMapEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCertificateMapEntryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteCertificateMapEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCertificateMapEntryRequest>): DeleteCertificateMapEntryRequest {
    return DeleteCertificateMapEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCertificateMapEntryRequest>): DeleteCertificateMapEntryRequest {
    const message = createBaseDeleteCertificateMapEntryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDnsAuthorizationsRequest(): ListDnsAuthorizationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDnsAuthorizationsRequest: MessageFns<ListDnsAuthorizationsRequest> = {
  encode(message: ListDnsAuthorizationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDnsAuthorizationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDnsAuthorizationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDnsAuthorizationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDnsAuthorizationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDnsAuthorizationsRequest>): ListDnsAuthorizationsRequest {
    return ListDnsAuthorizationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDnsAuthorizationsRequest>): ListDnsAuthorizationsRequest {
    const message = createBaseListDnsAuthorizationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListDnsAuthorizationsResponse(): ListDnsAuthorizationsResponse {
  return { dnsAuthorizations: [], nextPageToken: "", unreachable: [] };
}

export const ListDnsAuthorizationsResponse: MessageFns<ListDnsAuthorizationsResponse> = {
  encode(message: ListDnsAuthorizationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dnsAuthorizations) {
      DnsAuthorization.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDnsAuthorizationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDnsAuthorizationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dnsAuthorizations.push(DnsAuthorization.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDnsAuthorizationsResponse {
    return {
      dnsAuthorizations: globalThis.Array.isArray(object?.dnsAuthorizations)
        ? object.dnsAuthorizations.map((e: any) => DnsAuthorization.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDnsAuthorizationsResponse): unknown {
    const obj: any = {};
    if (message.dnsAuthorizations?.length) {
      obj.dnsAuthorizations = message.dnsAuthorizations.map((e) => DnsAuthorization.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDnsAuthorizationsResponse>): ListDnsAuthorizationsResponse {
    return ListDnsAuthorizationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDnsAuthorizationsResponse>): ListDnsAuthorizationsResponse {
    const message = createBaseListDnsAuthorizationsResponse();
    message.dnsAuthorizations = object.dnsAuthorizations?.map((e) => DnsAuthorization.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDnsAuthorizationRequest(): GetDnsAuthorizationRequest {
  return { name: "" };
}

export const GetDnsAuthorizationRequest: MessageFns<GetDnsAuthorizationRequest> = {
  encode(message: GetDnsAuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDnsAuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDnsAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDnsAuthorizationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDnsAuthorizationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDnsAuthorizationRequest>): GetDnsAuthorizationRequest {
    return GetDnsAuthorizationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDnsAuthorizationRequest>): GetDnsAuthorizationRequest {
    const message = createBaseGetDnsAuthorizationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDnsAuthorizationRequest(): CreateDnsAuthorizationRequest {
  return { parent: "", dnsAuthorizationId: "", dnsAuthorization: undefined };
}

export const CreateDnsAuthorizationRequest: MessageFns<CreateDnsAuthorizationRequest> = {
  encode(message: CreateDnsAuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dnsAuthorizationId !== "") {
      writer.uint32(18).string(message.dnsAuthorizationId);
    }
    if (message.dnsAuthorization !== undefined) {
      DnsAuthorization.encode(message.dnsAuthorization, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDnsAuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDnsAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dnsAuthorizationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dnsAuthorization = DnsAuthorization.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDnsAuthorizationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dnsAuthorizationId: isSet(object.dnsAuthorizationId) ? globalThis.String(object.dnsAuthorizationId) : "",
      dnsAuthorization: isSet(object.dnsAuthorization) ? DnsAuthorization.fromJSON(object.dnsAuthorization) : undefined,
    };
  },

  toJSON(message: CreateDnsAuthorizationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dnsAuthorizationId !== "") {
      obj.dnsAuthorizationId = message.dnsAuthorizationId;
    }
    if (message.dnsAuthorization !== undefined) {
      obj.dnsAuthorization = DnsAuthorization.toJSON(message.dnsAuthorization);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDnsAuthorizationRequest>): CreateDnsAuthorizationRequest {
    return CreateDnsAuthorizationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDnsAuthorizationRequest>): CreateDnsAuthorizationRequest {
    const message = createBaseCreateDnsAuthorizationRequest();
    message.parent = object.parent ?? "";
    message.dnsAuthorizationId = object.dnsAuthorizationId ?? "";
    message.dnsAuthorization = (object.dnsAuthorization !== undefined && object.dnsAuthorization !== null)
      ? DnsAuthorization.fromPartial(object.dnsAuthorization)
      : undefined;
    return message;
  },
};

function createBaseUpdateDnsAuthorizationRequest(): UpdateDnsAuthorizationRequest {
  return { dnsAuthorization: undefined, updateMask: undefined };
}

export const UpdateDnsAuthorizationRequest: MessageFns<UpdateDnsAuthorizationRequest> = {
  encode(message: UpdateDnsAuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dnsAuthorization !== undefined) {
      DnsAuthorization.encode(message.dnsAuthorization, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDnsAuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDnsAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dnsAuthorization = DnsAuthorization.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDnsAuthorizationRequest {
    return {
      dnsAuthorization: isSet(object.dnsAuthorization) ? DnsAuthorization.fromJSON(object.dnsAuthorization) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDnsAuthorizationRequest): unknown {
    const obj: any = {};
    if (message.dnsAuthorization !== undefined) {
      obj.dnsAuthorization = DnsAuthorization.toJSON(message.dnsAuthorization);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDnsAuthorizationRequest>): UpdateDnsAuthorizationRequest {
    return UpdateDnsAuthorizationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDnsAuthorizationRequest>): UpdateDnsAuthorizationRequest {
    const message = createBaseUpdateDnsAuthorizationRequest();
    message.dnsAuthorization = (object.dnsAuthorization !== undefined && object.dnsAuthorization !== null)
      ? DnsAuthorization.fromPartial(object.dnsAuthorization)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteDnsAuthorizationRequest(): DeleteDnsAuthorizationRequest {
  return { name: "" };
}

export const DeleteDnsAuthorizationRequest: MessageFns<DeleteDnsAuthorizationRequest> = {
  encode(message: DeleteDnsAuthorizationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDnsAuthorizationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDnsAuthorizationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDnsAuthorizationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDnsAuthorizationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDnsAuthorizationRequest>): DeleteDnsAuthorizationRequest {
    return DeleteDnsAuthorizationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDnsAuthorizationRequest>): DeleteDnsAuthorizationRequest {
    const message = createBaseDeleteDnsAuthorizationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseCertificate(): Certificate {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    selfManaged: undefined,
    managed: undefined,
    sanDnsnames: [],
    pemCertificate: "",
    expireTime: undefined,
    scope: 0,
  };
}

export const Certificate: MessageFns<Certificate> = {
  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Certificate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.selfManaged !== undefined) {
      Certificate_SelfManagedCertificate.encode(message.selfManaged, writer.uint32(42).fork()).join();
    }
    if (message.managed !== undefined) {
      Certificate_ManagedCertificate.encode(message.managed, writer.uint32(90).fork()).join();
    }
    for (const v of message.sanDnsnames) {
      writer.uint32(50).string(v!);
    }
    if (message.pemCertificate !== "") {
      writer.uint32(74).string(message.pemCertificate);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(58).fork()).join();
    }
    if (message.scope !== 0) {
      writer.uint32(96).int32(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Certificate_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.selfManaged = Certificate_SelfManagedCertificate.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.managed = Certificate_ManagedCertificate.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sanDnsnames.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pemCertificate = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      selfManaged: isSet(object.selfManaged)
        ? Certificate_SelfManagedCertificate.fromJSON(object.selfManaged)
        : undefined,
      managed: isSet(object.managed) ? Certificate_ManagedCertificate.fromJSON(object.managed) : undefined,
      sanDnsnames: globalThis.Array.isArray(object?.sanDnsnames)
        ? object.sanDnsnames.map((e: any) => globalThis.String(e))
        : [],
      pemCertificate: isSet(object.pemCertificate) ? globalThis.String(object.pemCertificate) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      scope: isSet(object.scope) ? certificate_ScopeFromJSON(object.scope) : 0,
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.selfManaged !== undefined) {
      obj.selfManaged = Certificate_SelfManagedCertificate.toJSON(message.selfManaged);
    }
    if (message.managed !== undefined) {
      obj.managed = Certificate_ManagedCertificate.toJSON(message.managed);
    }
    if (message.sanDnsnames?.length) {
      obj.sanDnsnames = message.sanDnsnames;
    }
    if (message.pemCertificate !== "") {
      obj.pemCertificate = message.pemCertificate;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.scope !== 0) {
      obj.scope = certificate_ScopeToJSON(message.scope);
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate>): Certificate {
    return Certificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate>): Certificate {
    const message = createBaseCertificate();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.selfManaged = (object.selfManaged !== undefined && object.selfManaged !== null)
      ? Certificate_SelfManagedCertificate.fromPartial(object.selfManaged)
      : undefined;
    message.managed = (object.managed !== undefined && object.managed !== null)
      ? Certificate_ManagedCertificate.fromPartial(object.managed)
      : undefined;
    message.sanDnsnames = object.sanDnsnames?.map((e) => e) || [];
    message.pemCertificate = object.pemCertificate ?? "";
    message.expireTime = object.expireTime ?? undefined;
    message.scope = object.scope ?? 0;
    return message;
  },
};

function createBaseCertificate_SelfManagedCertificate(): Certificate_SelfManagedCertificate {
  return { pemCertificate: "", pemPrivateKey: "" };
}

export const Certificate_SelfManagedCertificate: MessageFns<Certificate_SelfManagedCertificate> = {
  encode(message: Certificate_SelfManagedCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pemCertificate !== "") {
      writer.uint32(10).string(message.pemCertificate);
    }
    if (message.pemPrivateKey !== "") {
      writer.uint32(18).string(message.pemPrivateKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_SelfManagedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_SelfManagedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pemCertificate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pemPrivateKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_SelfManagedCertificate {
    return {
      pemCertificate: isSet(object.pemCertificate) ? globalThis.String(object.pemCertificate) : "",
      pemPrivateKey: isSet(object.pemPrivateKey) ? globalThis.String(object.pemPrivateKey) : "",
    };
  },

  toJSON(message: Certificate_SelfManagedCertificate): unknown {
    const obj: any = {};
    if (message.pemCertificate !== "") {
      obj.pemCertificate = message.pemCertificate;
    }
    if (message.pemPrivateKey !== "") {
      obj.pemPrivateKey = message.pemPrivateKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_SelfManagedCertificate>): Certificate_SelfManagedCertificate {
    return Certificate_SelfManagedCertificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_SelfManagedCertificate>): Certificate_SelfManagedCertificate {
    const message = createBaseCertificate_SelfManagedCertificate();
    message.pemCertificate = object.pemCertificate ?? "";
    message.pemPrivateKey = object.pemPrivateKey ?? "";
    return message;
  },
};

function createBaseCertificate_ManagedCertificate(): Certificate_ManagedCertificate {
  return {
    domains: [],
    dnsAuthorizations: [],
    issuanceConfig: "",
    state: 0,
    provisioningIssue: undefined,
    authorizationAttemptInfo: [],
  };
}

export const Certificate_ManagedCertificate: MessageFns<Certificate_ManagedCertificate> = {
  encode(message: Certificate_ManagedCertificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.domains) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.dnsAuthorizations) {
      writer.uint32(18).string(v!);
    }
    if (message.issuanceConfig !== "") {
      writer.uint32(50).string(message.issuanceConfig);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.provisioningIssue !== undefined) {
      Certificate_ManagedCertificate_ProvisioningIssue.encode(message.provisioningIssue, writer.uint32(26).fork())
        .join();
    }
    for (const v of message.authorizationAttemptInfo) {
      Certificate_ManagedCertificate_AuthorizationAttemptInfo.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domains.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dnsAuthorizations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.issuanceConfig = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provisioningIssue = Certificate_ManagedCertificate_ProvisioningIssue.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationAttemptInfo.push(
            Certificate_ManagedCertificate_AuthorizationAttemptInfo.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate {
    return {
      domains: globalThis.Array.isArray(object?.domains) ? object.domains.map((e: any) => globalThis.String(e)) : [],
      dnsAuthorizations: globalThis.Array.isArray(object?.dnsAuthorizations)
        ? object.dnsAuthorizations.map((e: any) => globalThis.String(e))
        : [],
      issuanceConfig: isSet(object.issuanceConfig) ? globalThis.String(object.issuanceConfig) : "",
      state: isSet(object.state) ? certificate_ManagedCertificate_StateFromJSON(object.state) : 0,
      provisioningIssue: isSet(object.provisioningIssue)
        ? Certificate_ManagedCertificate_ProvisioningIssue.fromJSON(object.provisioningIssue)
        : undefined,
      authorizationAttemptInfo: globalThis.Array.isArray(object?.authorizationAttemptInfo)
        ? object.authorizationAttemptInfo.map((e: any) =>
          Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: Certificate_ManagedCertificate): unknown {
    const obj: any = {};
    if (message.domains?.length) {
      obj.domains = message.domains;
    }
    if (message.dnsAuthorizations?.length) {
      obj.dnsAuthorizations = message.dnsAuthorizations;
    }
    if (message.issuanceConfig !== "") {
      obj.issuanceConfig = message.issuanceConfig;
    }
    if (message.state !== 0) {
      obj.state = certificate_ManagedCertificate_StateToJSON(message.state);
    }
    if (message.provisioningIssue !== undefined) {
      obj.provisioningIssue = Certificate_ManagedCertificate_ProvisioningIssue.toJSON(message.provisioningIssue);
    }
    if (message.authorizationAttemptInfo?.length) {
      obj.authorizationAttemptInfo = message.authorizationAttemptInfo.map((e) =>
        Certificate_ManagedCertificate_AuthorizationAttemptInfo.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_ManagedCertificate>): Certificate_ManagedCertificate {
    return Certificate_ManagedCertificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_ManagedCertificate>): Certificate_ManagedCertificate {
    const message = createBaseCertificate_ManagedCertificate();
    message.domains = object.domains?.map((e) => e) || [];
    message.dnsAuthorizations = object.dnsAuthorizations?.map((e) => e) || [];
    message.issuanceConfig = object.issuanceConfig ?? "";
    message.state = object.state ?? 0;
    message.provisioningIssue = (object.provisioningIssue !== undefined && object.provisioningIssue !== null)
      ? Certificate_ManagedCertificate_ProvisioningIssue.fromPartial(object.provisioningIssue)
      : undefined;
    message.authorizationAttemptInfo =
      object.authorizationAttemptInfo?.map((e) =>
        Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseCertificate_ManagedCertificate_ProvisioningIssue(): Certificate_ManagedCertificate_ProvisioningIssue {
  return { reason: 0, details: "" };
}

export const Certificate_ManagedCertificate_ProvisioningIssue: MessageFns<
  Certificate_ManagedCertificate_ProvisioningIssue
> = {
  encode(
    message: Certificate_ManagedCertificate_ProvisioningIssue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate_ProvisioningIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate_ProvisioningIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate_ProvisioningIssue {
    return {
      reason: isSet(object.reason) ? certificate_ManagedCertificate_ProvisioningIssue_ReasonFromJSON(object.reason) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: Certificate_ManagedCertificate_ProvisioningIssue): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = certificate_ManagedCertificate_ProvisioningIssue_ReasonToJSON(message.reason);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Certificate_ManagedCertificate_ProvisioningIssue>,
  ): Certificate_ManagedCertificate_ProvisioningIssue {
    return Certificate_ManagedCertificate_ProvisioningIssue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Certificate_ManagedCertificate_ProvisioningIssue>,
  ): Certificate_ManagedCertificate_ProvisioningIssue {
    const message = createBaseCertificate_ManagedCertificate_ProvisioningIssue();
    message.reason = object.reason ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo(): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
  return { domain: "", state: 0, failureReason: 0, details: "" };
}

export const Certificate_ManagedCertificate_AuthorizationAttemptInfo: MessageFns<
  Certificate_ManagedCertificate_AuthorizationAttemptInfo
> = {
  encode(
    message: Certificate_ManagedCertificate_AuthorizationAttemptInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.failureReason !== 0) {
      writer.uint32(24).int32(message.failureReason);
    }
    if (message.details !== "") {
      writer.uint32(34).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failureReason = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.details = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      state: isSet(object.state)
        ? certificate_ManagedCertificate_AuthorizationAttemptInfo_StateFromJSON(object.state)
        : 0,
      failureReason: isSet(object.failureReason)
        ? certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonFromJSON(object.failureReason)
        : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: Certificate_ManagedCertificate_AuthorizationAttemptInfo): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.state !== 0) {
      obj.state = certificate_ManagedCertificate_AuthorizationAttemptInfo_StateToJSON(message.state);
    }
    if (message.failureReason !== 0) {
      obj.failureReason = certificate_ManagedCertificate_AuthorizationAttemptInfo_FailureReasonToJSON(
        message.failureReason,
      );
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Certificate_ManagedCertificate_AuthorizationAttemptInfo>,
  ): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    return Certificate_ManagedCertificate_AuthorizationAttemptInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Certificate_ManagedCertificate_AuthorizationAttemptInfo>,
  ): Certificate_ManagedCertificate_AuthorizationAttemptInfo {
    const message = createBaseCertificate_ManagedCertificate_AuthorizationAttemptInfo();
    message.domain = object.domain ?? "";
    message.state = object.state ?? 0;
    message.failureReason = object.failureReason ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseCertificate_LabelsEntry(): Certificate_LabelsEntry {
  return { key: "", value: "" };
}

export const Certificate_LabelsEntry: MessageFns<Certificate_LabelsEntry> = {
  encode(message: Certificate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Certificate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    return Certificate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    const message = createBaseCertificate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateMap(): CertificateMap {
  return { name: "", description: "", createTime: undefined, updateTime: undefined, labels: {}, gclbTargets: [] };
}

export const CertificateMap: MessageFns<CertificateMap> = {
  encode(message: CertificateMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateMap_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.gclbTargets) {
      CertificateMap_GclbTarget.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = CertificateMap_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gclbTargets.push(CertificateMap_GclbTarget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      gclbTargets: globalThis.Array.isArray(object?.gclbTargets)
        ? object.gclbTargets.map((e: any) => CertificateMap_GclbTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateMap): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.gclbTargets?.length) {
      obj.gclbTargets = message.gclbTargets.map((e) => CertificateMap_GclbTarget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMap>): CertificateMap {
    return CertificateMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMap>): CertificateMap {
    const message = createBaseCertificateMap();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.gclbTargets = object.gclbTargets?.map((e) => CertificateMap_GclbTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateMap_GclbTarget(): CertificateMap_GclbTarget {
  return { targetHttpsProxy: undefined, targetSslProxy: undefined, ipConfigs: [] };
}

export const CertificateMap_GclbTarget: MessageFns<CertificateMap_GclbTarget> = {
  encode(message: CertificateMap_GclbTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetHttpsProxy !== undefined) {
      writer.uint32(10).string(message.targetHttpsProxy);
    }
    if (message.targetSslProxy !== undefined) {
      writer.uint32(26).string(message.targetSslProxy);
    }
    for (const v of message.ipConfigs) {
      CertificateMap_GclbTarget_IpConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_GclbTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_GclbTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetHttpsProxy = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetSslProxy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipConfigs.push(CertificateMap_GclbTarget_IpConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_GclbTarget {
    return {
      targetHttpsProxy: isSet(object.targetHttpsProxy) ? globalThis.String(object.targetHttpsProxy) : undefined,
      targetSslProxy: isSet(object.targetSslProxy) ? globalThis.String(object.targetSslProxy) : undefined,
      ipConfigs: globalThis.Array.isArray(object?.ipConfigs)
        ? object.ipConfigs.map((e: any) => CertificateMap_GclbTarget_IpConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateMap_GclbTarget): unknown {
    const obj: any = {};
    if (message.targetHttpsProxy !== undefined) {
      obj.targetHttpsProxy = message.targetHttpsProxy;
    }
    if (message.targetSslProxy !== undefined) {
      obj.targetSslProxy = message.targetSslProxy;
    }
    if (message.ipConfigs?.length) {
      obj.ipConfigs = message.ipConfigs.map((e) => CertificateMap_GclbTarget_IpConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMap_GclbTarget>): CertificateMap_GclbTarget {
    return CertificateMap_GclbTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMap_GclbTarget>): CertificateMap_GclbTarget {
    const message = createBaseCertificateMap_GclbTarget();
    message.targetHttpsProxy = object.targetHttpsProxy ?? undefined;
    message.targetSslProxy = object.targetSslProxy ?? undefined;
    message.ipConfigs = object.ipConfigs?.map((e) => CertificateMap_GclbTarget_IpConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateMap_GclbTarget_IpConfig(): CertificateMap_GclbTarget_IpConfig {
  return { ipAddress: "", ports: [] };
}

export const CertificateMap_GclbTarget_IpConfig: MessageFns<CertificateMap_GclbTarget_IpConfig> = {
  encode(message: CertificateMap_GclbTarget_IpConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    writer.uint32(26).fork();
    for (const v of message.ports) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_GclbTarget_IpConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_GclbTarget_IpConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.ports.push(reader.uint32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ports.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_GclbTarget_IpConfig {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: CertificateMap_GclbTarget_IpConfig): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.ports?.length) {
      obj.ports = message.ports.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMap_GclbTarget_IpConfig>): CertificateMap_GclbTarget_IpConfig {
    return CertificateMap_GclbTarget_IpConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMap_GclbTarget_IpConfig>): CertificateMap_GclbTarget_IpConfig {
    const message = createBaseCertificateMap_GclbTarget_IpConfig();
    message.ipAddress = object.ipAddress ?? "";
    message.ports = object.ports?.map((e) => e) || [];
    return message;
  },
};

function createBaseCertificateMap_LabelsEntry(): CertificateMap_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateMap_LabelsEntry: MessageFns<CertificateMap_LabelsEntry> = {
  encode(message: CertificateMap_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMap_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMap_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMap_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateMap_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMap_LabelsEntry>): CertificateMap_LabelsEntry {
    return CertificateMap_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMap_LabelsEntry>): CertificateMap_LabelsEntry {
    const message = createBaseCertificateMap_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateMapEntry(): CertificateMapEntry {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    hostname: undefined,
    matcher: undefined,
    certificates: [],
    state: 0,
  };
}

export const CertificateMapEntry: MessageFns<CertificateMapEntry> = {
  encode(message: CertificateMapEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateMapEntry_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hostname !== undefined) {
      writer.uint32(42).string(message.hostname);
    }
    if (message.matcher !== undefined) {
      writer.uint32(80).int32(message.matcher);
    }
    for (const v of message.certificates) {
      writer.uint32(58).string(v!);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = CertificateMapEntry_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.matcher = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.certificates.push(reader.string());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      matcher: isSet(object.matcher) ? certificateMapEntry_MatcherFromJSON(object.matcher) : undefined,
      certificates: globalThis.Array.isArray(object?.certificates)
        ? object.certificates.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? servingStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: CertificateMapEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.matcher !== undefined) {
      obj.matcher = certificateMapEntry_MatcherToJSON(message.matcher);
    }
    if (message.certificates?.length) {
      obj.certificates = message.certificates;
    }
    if (message.state !== 0) {
      obj.state = servingStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMapEntry>): CertificateMapEntry {
    return CertificateMapEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMapEntry>): CertificateMapEntry {
    const message = createBaseCertificateMapEntry();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.hostname = object.hostname ?? undefined;
    message.matcher = object.matcher ?? undefined;
    message.certificates = object.certificates?.map((e) => e) || [];
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseCertificateMapEntry_LabelsEntry(): CertificateMapEntry_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateMapEntry_LabelsEntry: MessageFns<CertificateMapEntry_LabelsEntry> = {
  encode(message: CertificateMapEntry_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateMapEntry_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateMapEntry_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateMapEntry_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateMapEntry_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateMapEntry_LabelsEntry>): CertificateMapEntry_LabelsEntry {
    return CertificateMapEntry_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateMapEntry_LabelsEntry>): CertificateMapEntry_LabelsEntry {
    const message = createBaseCertificateMapEntry_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDnsAuthorization(): DnsAuthorization {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    domain: "",
    dnsResourceRecord: undefined,
    type: 0,
  };
}

export const DnsAuthorization: MessageFns<DnsAuthorization> = {
  encode(message: DnsAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DnsAuthorization_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.domain !== "") {
      writer.uint32(50).string(message.domain);
    }
    if (message.dnsResourceRecord !== undefined) {
      DnsAuthorization_DnsResourceRecord.encode(message.dnsResourceRecord, writer.uint32(82).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(88).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = DnsAuthorization_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dnsResourceRecord = DnsAuthorization_DnsResourceRecord.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      dnsResourceRecord: isSet(object.dnsResourceRecord)
        ? DnsAuthorization_DnsResourceRecord.fromJSON(object.dnsResourceRecord)
        : undefined,
      type: isSet(object.type) ? dnsAuthorization_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: DnsAuthorization): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.dnsResourceRecord !== undefined) {
      obj.dnsResourceRecord = DnsAuthorization_DnsResourceRecord.toJSON(message.dnsResourceRecord);
    }
    if (message.type !== 0) {
      obj.type = dnsAuthorization_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<DnsAuthorization>): DnsAuthorization {
    return DnsAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsAuthorization>): DnsAuthorization {
    const message = createBaseDnsAuthorization();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.domain = object.domain ?? "";
    message.dnsResourceRecord = (object.dnsResourceRecord !== undefined && object.dnsResourceRecord !== null)
      ? DnsAuthorization_DnsResourceRecord.fromPartial(object.dnsResourceRecord)
      : undefined;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDnsAuthorization_DnsResourceRecord(): DnsAuthorization_DnsResourceRecord {
  return { name: "", type: "", data: "" };
}

export const DnsAuthorization_DnsResourceRecord: MessageFns<DnsAuthorization_DnsResourceRecord> = {
  encode(message: DnsAuthorization_DnsResourceRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization_DnsResourceRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization_DnsResourceRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization_DnsResourceRecord {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: DnsAuthorization_DnsResourceRecord): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsAuthorization_DnsResourceRecord>): DnsAuthorization_DnsResourceRecord {
    return DnsAuthorization_DnsResourceRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsAuthorization_DnsResourceRecord>): DnsAuthorization_DnsResourceRecord {
    const message = createBaseDnsAuthorization_DnsResourceRecord();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseDnsAuthorization_LabelsEntry(): DnsAuthorization_LabelsEntry {
  return { key: "", value: "" };
}

export const DnsAuthorization_LabelsEntry: MessageFns<DnsAuthorization_LabelsEntry> = {
  encode(message: DnsAuthorization_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsAuthorization_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsAuthorization_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsAuthorization_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DnsAuthorization_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsAuthorization_LabelsEntry>): DnsAuthorization_LabelsEntry {
    return DnsAuthorization_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsAuthorization_LabelsEntry>): DnsAuthorization_LabelsEntry {
    const message = createBaseDnsAuthorization_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

/**
 * API Overview
 *
 * Certificates Manager API allows customers to see and manage all their TLS
 * certificates.
 *
 * Certificates Manager API service provides methods to manage certificates,
 * group them into collections, and create serving configuration that can be
 * easily applied to other Cloud resources e.g. Target Proxies.
 *
 * Data Model
 *
 * The Certificates Manager service exposes the following resources:
 *
 * * `Certificate` that describes a single TLS certificate.
 * * `CertificateMap` that describes a collection of certificates that can be
 * attached to a target resource.
 * * `CertificateMapEntry` that describes a single configuration entry that
 * consists of a SNI and a group of certificates. It's a subresource of
 * CertificateMap.
 *
 * Certificate, CertificateMap and CertificateMapEntry IDs
 * have to fully match the regexp `[a-z0-9-]{1,63}`. In other words,
 * - only lower case letters, digits, and hyphen are allowed
 * - length of the resource ID has to be in [1,63] range.
 *
 * Provides methods to manage Cloud Certificate Manager entities.
 */
export type CertificateManagerDefinition = typeof CertificateManagerDefinition;
export const CertificateManagerDefinition = {
  name: "CertificateManager",
  fullName: "google.cloud.certificatemanager.v1.CertificateManager",
  methods: {
    /** Lists Certificates in a given project and location. */
    listCertificates: {
      name: "ListCertificates",
      requestType: ListCertificatesRequest,
      requestStream: false,
      responseType: ListCertificatesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Certificate. */
    getCertificate: {
      name: "GetCertificate",
      requestType: GetCertificateRequest,
      requestStream: false,
      responseType: Certificate,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Certificate in a given project and location. */
    createCertificate: {
      name: "CreateCertificate",
      requestType: CreateCertificateRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              11,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a Certificate. */
    updateCertificate: {
      name: "UpdateCertificate",
      requestType: UpdateCertificateRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              11,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              50,
              60,
              47,
              118,
              49,
              47,
              123,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Certificate. */
    deleteCertificate: {
      name: "DeleteCertificate",
      requestType: DeleteCertificateRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists CertificateMaps in a given project and location. */
    listCertificateMaps: {
      name: "ListCertificateMaps",
      requestType: ListCertificateMapsRequest,
      requestStream: false,
      responseType: ListCertificateMapsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CertificateMap. */
    getCertificateMap: {
      name: "GetCertificateMap",
      requestType: GetCertificateMapRequest,
      requestStream: false,
      responseType: CertificateMap,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new CertificateMap in a given project and location. */
    createCertificateMap: {
      name: "CreateCertificateMap",
      requestType: CreateCertificateMapRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              15,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a CertificateMap. */
    updateCertificateMap: {
      name: "UpdateCertificateMap",
      requestType: UpdateCertificateMapRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              15,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              50,
              67,
              47,
              118,
              49,
              47,
              123,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a single CertificateMap. A Certificate Map can't be deleted
     * if it contains Certificate Map Entries. Remove all the entries from
     * the map before calling this method.
     */
    deleteCertificateMap: {
      name: "DeleteCertificateMap",
      requestType: DeleteCertificateMapRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists CertificateMapEntries in a given project and location. */
    listCertificateMapEntries: {
      name: "ListCertificateMapEntries",
      requestType: ListCertificateMapEntriesRequest,
      requestStream: false,
      responseType: ListCertificateMapEntriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              77,
              18,
              75,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CertificateMapEntry. */
    getCertificateMapEntry: {
      name: "GetCertificateMapEntry",
      requestType: GetCertificateMapEntryRequest,
      requestStream: false,
      responseType: CertificateMapEntry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              77,
              18,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new CertificateMapEntry in a given project and location. */
    createCertificateMapEntry: {
      name: "CreateCertificateMapEntry",
      requestType: CreateCertificateMapEntryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              19,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              53,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              100,
              58,
              21,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a CertificateMapEntry. */
    updateCertificateMapEntry: {
      name: "UpdateCertificateMapEntry",
      requestType: UpdateCertificateMapEntryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              19,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              122,
              58,
              21,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              50,
              97,
              47,
              118,
              49,
              47,
              123,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              109,
              97,
              112,
              95,
              101,
              110,
              116,
              114,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single CertificateMapEntry. */
    deleteCertificateMapEntry: {
      name: "DeleteCertificateMapEntry",
      requestType: DeleteCertificateMapEntryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              77,
              42,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              77,
              97,
              112,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists DnsAuthorizations in a given project and location. */
    listDnsAuthorizations: {
      name: "ListDnsAuthorizations",
      requestType: ListDnsAuthorizationsRequest,
      requestStream: false,
      responseType: ListDnsAuthorizationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single DnsAuthorization. */
    getDnsAuthorization: {
      name: "GetDnsAuthorization",
      requestType: GetDnsAuthorizationRequest,
      requestStream: false,
      responseType: DnsAuthorization,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new DnsAuthorization in a given project and location. */
    createDnsAuthorization: {
      name: "CreateDnsAuthorization",
      requestType: CreateDnsAuthorizationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              68,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              45,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              44,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              17,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a DnsAuthorization. */
    updateDnsAuthorization: {
      name: "UpdateDnsAuthorization",
      requestType: UpdateDnsAuthorizationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              68,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              29,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              92,
              58,
              17,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              50,
              71,
              47,
              118,
              49,
              47,
              123,
              100,
              110,
              115,
              95,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single DnsAuthorization. */
    deleteDnsAuthorization: {
      name: "DeleteDnsAuthorization",
      requestType: DeleteDnsAuthorizationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists CertificateIssuanceConfigs in a given project and location. */
    listCertificateIssuanceConfigs: {
      name: "ListCertificateIssuanceConfigs",
      requestType: ListCertificateIssuanceConfigsRequest,
      requestStream: false,
      responseType: ListCertificateIssuanceConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              73,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single CertificateIssuanceConfig. */
    getCertificateIssuanceConfig: {
      name: "GetCertificateIssuanceConfig",
      requestType: GetCertificateIssuanceConfigRequest,
      requestStream: false,
      responseType: CertificateIssuanceConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              73,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new CertificateIssuanceConfig in a given project and location. */
    createCertificateIssuanceConfig: {
      name: "CreateCertificateIssuanceConfig",
      requestType: CreateCertificateIssuanceConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              46,
              10,
              25,
              67,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              73,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              65,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              105,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              105,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              93,
              58,
              27,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              95,
              105,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              73,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single CertificateIssuanceConfig. */
    deleteCertificateIssuanceConfig: {
      name: "DeleteCertificateIssuanceConfig",
      requestType: DeleteCertificateIssuanceConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              42,
              62,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              101,
              114,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              101,
              73,
              115,
              115,
              117,
              97,
              110,
              99,
              101,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists TrustConfigs in a given project and location. */
    listTrustConfigs: {
      name: "ListTrustConfigs",
      requestType: ListTrustConfigsRequest,
      requestStream: false,
      responseType: ListTrustConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single TrustConfig. */
    getTrustConfig: {
      name: "GetTrustConfig",
      requestType: GetTrustConfigRequest,
      requestStream: false,
      responseType: TrustConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new TrustConfig in a given project and location. */
    createTrustConfig: {
      name: "CreateTrustConfig",
      requestType: CreateTrustConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              84,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              35,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              12,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a TrustConfig. */
    updateTrustConfig: {
      name: "UpdateTrustConfig",
      requestType: UpdateTrustConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              11,
              84,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              24,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              77,
              58,
              12,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              50,
              61,
              47,
              118,
              49,
              47,
              123,
              116,
              114,
              117,
              115,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single TrustConfig. */
    deleteTrustConfig: {
      name: "DeleteTrustConfig",
      requestType: DeleteTrustConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              114,
              117,
              115,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CertificateManagerServiceImplementation<CallContextExt = {}> {
  /** Lists Certificates in a given project and location. */
  listCertificates(
    request: ListCertificatesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCertificatesResponse>>;
  /** Gets details of a single Certificate. */
  getCertificate(
    request: GetCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Certificate>>;
  /** Creates a new Certificate in a given project and location. */
  createCertificate(
    request: CreateCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a Certificate. */
  updateCertificate(
    request: UpdateCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single Certificate. */
  deleteCertificate(
    request: DeleteCertificateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists CertificateMaps in a given project and location. */
  listCertificateMaps(
    request: ListCertificateMapsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCertificateMapsResponse>>;
  /** Gets details of a single CertificateMap. */
  getCertificateMap(
    request: GetCertificateMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CertificateMap>>;
  /** Creates a new CertificateMap in a given project and location. */
  createCertificateMap(
    request: CreateCertificateMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a CertificateMap. */
  updateCertificateMap(
    request: UpdateCertificateMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a single CertificateMap. A Certificate Map can't be deleted
   * if it contains Certificate Map Entries. Remove all the entries from
   * the map before calling this method.
   */
  deleteCertificateMap(
    request: DeleteCertificateMapRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists CertificateMapEntries in a given project and location. */
  listCertificateMapEntries(
    request: ListCertificateMapEntriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCertificateMapEntriesResponse>>;
  /** Gets details of a single CertificateMapEntry. */
  getCertificateMapEntry(
    request: GetCertificateMapEntryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CertificateMapEntry>>;
  /** Creates a new CertificateMapEntry in a given project and location. */
  createCertificateMapEntry(
    request: CreateCertificateMapEntryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a CertificateMapEntry. */
  updateCertificateMapEntry(
    request: UpdateCertificateMapEntryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single CertificateMapEntry. */
  deleteCertificateMapEntry(
    request: DeleteCertificateMapEntryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists DnsAuthorizations in a given project and location. */
  listDnsAuthorizations(
    request: ListDnsAuthorizationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDnsAuthorizationsResponse>>;
  /** Gets details of a single DnsAuthorization. */
  getDnsAuthorization(
    request: GetDnsAuthorizationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DnsAuthorization>>;
  /** Creates a new DnsAuthorization in a given project and location. */
  createDnsAuthorization(
    request: CreateDnsAuthorizationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a DnsAuthorization. */
  updateDnsAuthorization(
    request: UpdateDnsAuthorizationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single DnsAuthorization. */
  deleteDnsAuthorization(
    request: DeleteDnsAuthorizationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists CertificateIssuanceConfigs in a given project and location. */
  listCertificateIssuanceConfigs(
    request: ListCertificateIssuanceConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCertificateIssuanceConfigsResponse>>;
  /** Gets details of a single CertificateIssuanceConfig. */
  getCertificateIssuanceConfig(
    request: GetCertificateIssuanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CertificateIssuanceConfig>>;
  /** Creates a new CertificateIssuanceConfig in a given project and location. */
  createCertificateIssuanceConfig(
    request: CreateCertificateIssuanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single CertificateIssuanceConfig. */
  deleteCertificateIssuanceConfig(
    request: DeleteCertificateIssuanceConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists TrustConfigs in a given project and location. */
  listTrustConfigs(
    request: ListTrustConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTrustConfigsResponse>>;
  /** Gets details of a single TrustConfig. */
  getTrustConfig(
    request: GetTrustConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TrustConfig>>;
  /** Creates a new TrustConfig in a given project and location. */
  createTrustConfig(
    request: CreateTrustConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a TrustConfig. */
  updateTrustConfig(
    request: UpdateTrustConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single TrustConfig. */
  deleteTrustConfig(
    request: DeleteTrustConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface CertificateManagerClient<CallOptionsExt = {}> {
  /** Lists Certificates in a given project and location. */
  listCertificates(
    request: DeepPartial<ListCertificatesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCertificatesResponse>;
  /** Gets details of a single Certificate. */
  getCertificate(
    request: DeepPartial<GetCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Certificate>;
  /** Creates a new Certificate in a given project and location. */
  createCertificate(
    request: DeepPartial<CreateCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a Certificate. */
  updateCertificate(
    request: DeepPartial<UpdateCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single Certificate. */
  deleteCertificate(
    request: DeepPartial<DeleteCertificateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists CertificateMaps in a given project and location. */
  listCertificateMaps(
    request: DeepPartial<ListCertificateMapsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCertificateMapsResponse>;
  /** Gets details of a single CertificateMap. */
  getCertificateMap(
    request: DeepPartial<GetCertificateMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CertificateMap>;
  /** Creates a new CertificateMap in a given project and location. */
  createCertificateMap(
    request: DeepPartial<CreateCertificateMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a CertificateMap. */
  updateCertificateMap(
    request: DeepPartial<UpdateCertificateMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a single CertificateMap. A Certificate Map can't be deleted
   * if it contains Certificate Map Entries. Remove all the entries from
   * the map before calling this method.
   */
  deleteCertificateMap(
    request: DeepPartial<DeleteCertificateMapRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists CertificateMapEntries in a given project and location. */
  listCertificateMapEntries(
    request: DeepPartial<ListCertificateMapEntriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCertificateMapEntriesResponse>;
  /** Gets details of a single CertificateMapEntry. */
  getCertificateMapEntry(
    request: DeepPartial<GetCertificateMapEntryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CertificateMapEntry>;
  /** Creates a new CertificateMapEntry in a given project and location. */
  createCertificateMapEntry(
    request: DeepPartial<CreateCertificateMapEntryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a CertificateMapEntry. */
  updateCertificateMapEntry(
    request: DeepPartial<UpdateCertificateMapEntryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single CertificateMapEntry. */
  deleteCertificateMapEntry(
    request: DeepPartial<DeleteCertificateMapEntryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists DnsAuthorizations in a given project and location. */
  listDnsAuthorizations(
    request: DeepPartial<ListDnsAuthorizationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDnsAuthorizationsResponse>;
  /** Gets details of a single DnsAuthorization. */
  getDnsAuthorization(
    request: DeepPartial<GetDnsAuthorizationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DnsAuthorization>;
  /** Creates a new DnsAuthorization in a given project and location. */
  createDnsAuthorization(
    request: DeepPartial<CreateDnsAuthorizationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a DnsAuthorization. */
  updateDnsAuthorization(
    request: DeepPartial<UpdateDnsAuthorizationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single DnsAuthorization. */
  deleteDnsAuthorization(
    request: DeepPartial<DeleteDnsAuthorizationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists CertificateIssuanceConfigs in a given project and location. */
  listCertificateIssuanceConfigs(
    request: DeepPartial<ListCertificateIssuanceConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCertificateIssuanceConfigsResponse>;
  /** Gets details of a single CertificateIssuanceConfig. */
  getCertificateIssuanceConfig(
    request: DeepPartial<GetCertificateIssuanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CertificateIssuanceConfig>;
  /** Creates a new CertificateIssuanceConfig in a given project and location. */
  createCertificateIssuanceConfig(
    request: DeepPartial<CreateCertificateIssuanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single CertificateIssuanceConfig. */
  deleteCertificateIssuanceConfig(
    request: DeepPartial<DeleteCertificateIssuanceConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists TrustConfigs in a given project and location. */
  listTrustConfigs(
    request: DeepPartial<ListTrustConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTrustConfigsResponse>;
  /** Gets details of a single TrustConfig. */
  getTrustConfig(
    request: DeepPartial<GetTrustConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TrustConfig>;
  /** Creates a new TrustConfig in a given project and location. */
  createTrustConfig(
    request: DeepPartial<CreateTrustConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a TrustConfig. */
  updateTrustConfig(
    request: DeepPartial<UpdateTrustConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single TrustConfig. */
  deleteTrustConfig(
    request: DeepPartial<DeleteTrustConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
