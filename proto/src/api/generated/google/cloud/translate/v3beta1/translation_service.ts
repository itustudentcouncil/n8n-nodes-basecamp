// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/translate/v3beta1/translation_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.translation.v3beta1";

/**
 * Configures which glossary should be used for a specific target language,
 * and defines options for applying that glossary.
 */
export interface TranslateTextGlossaryConfig {
  /**
   * Required. Specifies the glossary used for this translation. Use
   * this format: projects/* /locations/* /glossaries/*
   */
  glossary: string;
  /**
   * Optional. Indicates match is case-insensitive.
   * Default value is false if missing.
   */
  ignoreCase: boolean;
}

/** The request message for synchronous translation. */
export interface TranslateTextRequest {
  /**
   * Required. The content of the input in string format.
   * We recommend the total content be less than 30k codepoints. The max length
   * of this field is 1024.
   * Use BatchTranslateText for larger text.
   */
  contents: string[];
  /**
   * Optional. The format of the source text, for example, "text/html",
   *  "text/plain". If left blank, the MIME type defaults to "text/html".
   */
  mimeType: string;
  /**
   * Optional. The BCP-47 language code of the input text if
   * known, for example, "en-US" or "sr-Latn". Supported language codes are
   * listed in Language Support. If the source language isn't specified, the API
   * attempts to identify the source language automatically and returns the
   * source language within the response.
   */
  sourceLanguageCode: string;
  /**
   * Required. The BCP-47 language code to use for translation of the input
   * text, set to one of the language codes listed in Language Support.
   */
  targetLanguageCode: string;
  /**
   * Required. Project or location to make a call. Must refer to a caller's
   * project.
   *
   * Format: `projects/{project-number-or-id}` or
   * `projects/{project-number-or-id}/locations/{location-id}`.
   *
   * For global calls, use `projects/{project-number-or-id}/locations/global` or
   * `projects/{project-number-or-id}`.
   *
   * Non-global location is required for requests using AutoML models or
   * custom glossaries.
   *
   * Models and glossaries must be within the same region (have same
   * location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
   */
  parent: string;
  /**
   * Optional. The `model` type requested for this translation.
   *
   * The format depends on model type:
   *
   * - AutoML Translation models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
   *
   * - General (built-in) models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
   *
   * For global (non-regionalized) requests, use `location-id` `global`.
   * For example,
   * `projects/{project-number-or-id}/locations/global/models/general/nmt`.
   *
   * If not provided, the default Google model (NMT) will be used
   */
  model: string;
  /**
   * Optional. Glossary to be applied. The glossary must be
   * within the same region (have the same location-id) as the model, otherwise
   * an INVALID_ARGUMENT (400) error is returned.
   */
  glossaryConfig:
    | TranslateTextGlossaryConfig
    | undefined;
  /**
   * Optional. The labels with user-defined metadata for the request.
   *
   * Label keys and values can be no longer than 63 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * Label values are optional. Label keys must start with a letter.
   *
   * See https://cloud.google.com/translate/docs/labels for more information.
   */
  labels: { [key: string]: string };
}

export interface TranslateTextRequest_LabelsEntry {
  key: string;
  value: string;
}

export interface TranslateTextResponse {
  /**
   * Text translation responses with no glossary applied.
   * This field has the same length as
   * [`contents`][google.cloud.translation.v3beta1.TranslateTextRequest.contents].
   */
  translations: Translation[];
  /**
   * Text translation responses if a glossary is provided in the request.
   * This can be the same as
   * [`translations`][google.cloud.translation.v3beta1.TranslateTextResponse.translations]
   * if no terms apply. This field has the same length as
   * [`contents`][google.cloud.translation.v3beta1.TranslateTextRequest.contents].
   */
  glossaryTranslations: Translation[];
}

/** A single translation response. */
export interface Translation {
  /**
   * Text translated into the target language.
   * If an error occurs during translation, this field might be excluded from
   * the response.
   */
  translatedText: string;
  /**
   * Only present when `model` is present in the request.
   * `model` here is normalized to have project number.
   *
   * For example:
   * If the `model` requested in TranslationTextRequest is
   * `projects/{project-id}/locations/{location-id}/models/general/nmt` then
   * `model` here would be normalized to
   * `projects/{project-number}/locations/{location-id}/models/general/nmt`.
   */
  model: string;
  /**
   * The BCP-47 language code of source text in the initial request, detected
   * automatically, if no source language was passed within the initial
   * request. If the source language was passed, auto-detection of the language
   * does not occur and this field is empty.
   */
  detectedLanguageCode: string;
  /** The `glossary_config` used for this translation. */
  glossaryConfig: TranslateTextGlossaryConfig | undefined;
}

/** The request message for language detection. */
export interface DetectLanguageRequest {
  /**
   * Required. Project or location to make a call. Must refer to a caller's
   * project.
   *
   * Format: `projects/{project-number-or-id}/locations/{location-id}` or
   * `projects/{project-number-or-id}`.
   *
   * For global calls, use `projects/{project-number-or-id}/locations/global` or
   * `projects/{project-number-or-id}`.
   *
   * Only models within the same region (has same location-id) can be used.
   * Otherwise an INVALID_ARGUMENT (400) error is returned.
   */
  parent: string;
  /**
   * Optional. The language detection model to be used.
   *
   * Format:
   * `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/{model-id}`
   *
   * Only one language detection model is currently supported:
   * `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/default`.
   *
   * If not specified, the default model is used.
   */
  model: string;
  /** The content of the input stored as a string. */
  content?:
    | string
    | undefined;
  /**
   * Optional. The format of the source text, for example, "text/html",
   * "text/plain". If left blank, the MIME type defaults to "text/html".
   */
  mimeType: string;
  /**
   * Optional. The labels with user-defined metadata for the request.
   *
   * Label keys and values can be no longer than 63 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * Label values are optional. Label keys must start with a letter.
   *
   * See https://cloud.google.com/translate/docs/labels for more information.
   */
  labels: { [key: string]: string };
}

export interface DetectLanguageRequest_LabelsEntry {
  key: string;
  value: string;
}

/** The response message for language detection. */
export interface DetectedLanguage {
  /**
   * The BCP-47 language code of source content in the request, detected
   * automatically.
   */
  languageCode: string;
  /** The confidence of the detection result for this language. */
  confidence: number;
}

/** The response message for language detection. */
export interface DetectLanguageResponse {
  /**
   * A list of detected languages sorted by detection confidence in descending
   * order. The most probable language first.
   */
  languages: DetectedLanguage[];
}

/** The request message for discovering supported languages. */
export interface GetSupportedLanguagesRequest {
  /**
   * Required. Project or location to make a call. Must refer to a caller's
   * project.
   *
   * Format: `projects/{project-number-or-id}` or
   * `projects/{project-number-or-id}/locations/{location-id}`.
   *
   * For global calls, use `projects/{project-number-or-id}/locations/global` or
   * `projects/{project-number-or-id}`.
   *
   * Non-global location is required for AutoML models.
   *
   * Only models within the same region (have same location-id) can be used,
   * otherwise an INVALID_ARGUMENT (400) error is returned.
   */
  parent: string;
  /**
   * Optional. The language to use to return localized, human readable names
   * of supported languages. If missing, then display names are not returned
   * in a response.
   */
  displayLanguageCode: string;
  /**
   * Optional. Get supported languages of this model.
   *
   * The format depends on model type:
   *
   * - AutoML Translation models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
   *
   * - General (built-in) models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
   *
   * Returns languages supported by the specified model.
   * If missing, we get supported languages of Google general NMT model.
   */
  model: string;
}

/** The response message for discovering supported languages. */
export interface SupportedLanguages {
  /**
   * A list of supported language responses. This list contains an entry
   * for each language the Translation API supports.
   */
  languages: SupportedLanguage[];
}

/**
 * A single supported language response corresponds to information related
 * to one supported language.
 */
export interface SupportedLanguage {
  /**
   * Supported language code, generally consisting of its ISO 639-1
   * identifier, for example, 'en', 'ja'. In certain cases, BCP-47 codes
   * including language and region identifiers are returned (for example,
   * 'zh-TW' and 'zh-CN')
   */
  languageCode: string;
  /**
   * Human readable name of the language localized in the display language
   * specified in the request.
   */
  displayName: string;
  /** Can be used as source language. */
  supportSource: boolean;
  /** Can be used as target language. */
  supportTarget: boolean;
}

/** The Google Cloud Storage location for the input content. */
export interface GcsSource {
  /** Required. Source data URI. For example, `gs://my_bucket/my_object`. */
  inputUri: string;
}

/** Input configuration for BatchTranslateText request. */
export interface InputConfig {
  /**
   * Optional. Can be "text/plain" or "text/html".
   * For `.tsv`, "text/html" is used if mime_type is missing.
   * For `.html`, this field must be "text/html" or empty.
   * For `.txt`, this field must be "text/plain" or empty.
   */
  mimeType: string;
  /**
   * Required. Google Cloud Storage location for the source input.
   * This can be a single file (for example,
   * `gs://translation-test/input.tsv`) or a wildcard (for example,
   * `gs://translation-test/*`). If a file extension is `.tsv`, it can
   * contain either one or two columns. The first column (optional) is the id
   * of the text request. If the first column is missing, we use the row
   * number (0-based) from the input file as the ID in the output file. The
   * second column is the actual text to be
   *  translated. We recommend each row be <= 10K Unicode codepoints,
   * otherwise an error might be returned.
   * Note that the input tsv must be RFC 4180 compliant.
   *
   * You could use https://github.com/Clever/csvlint to check potential
   * formatting errors in your tsv file.
   * csvlint --delimiter='\t' your_input_file.tsv
   *
   * The other supported file extensions are `.txt` or `.html`, which is
   * treated as a single large chunk of text.
   */
  gcsSource?: GcsSource | undefined;
}

/** The Google Cloud Storage location for the output content. */
export interface GcsDestination {
  /**
   * Required. There must be no files under 'output_uri_prefix'.
   * 'output_uri_prefix' must end with "/" and start with "gs://", otherwise an
   * INVALID_ARGUMENT (400) error is returned.
   */
  outputUriPrefix: string;
}

/** Output configuration for BatchTranslateText request. */
export interface OutputConfig {
  /**
   * Google Cloud Storage destination for output content.
   * For every single input file (for example, gs://a/b/c.[extension]), we
   * generate at most 2 * n output files. (n is the # of target_language_codes
   * in the BatchTranslateTextRequest).
   *
   * Output files (tsv) generated are compliant with RFC 4180 except that
   * record delimiters are '\n' instead of '\r\n'. We don't provide any way to
   * change record delimiters.
   *
   * While the input files are being processed, we write/update an index file
   * 'index.csv'  under 'output_uri_prefix' (for example,
   * gs://translation-test/index.csv) The index file is generated/updated as
   * new files are being translated. The format is:
   *
   * input_file,target_language_code,translations_file,errors_file,
   * glossary_translations_file,glossary_errors_file
   *
   * input_file is one file we matched using gcs_source.input_uri.
   * target_language_code is provided in the request.
   * translations_file contains the translations. (details provided below)
   * errors_file contains the errors during processing of the file. (details
   * below). Both translations_file and errors_file could be empty
   * strings if we have no content to output.
   * glossary_translations_file and glossary_errors_file are always empty
   * strings if the input_file is tsv. They could also be empty if we have no
   * content to output.
   *
   * Once a row is present in index.csv, the input/output matching never
   * changes. Callers should also expect all the content in input_file are
   * processed and ready to be consumed (that is, no partial output file is
   * written).
   *
   * Since index.csv will be keeping updated during the process, please make
   * sure there is no custom retention policy applied on the output bucket
   * that may avoid file updating.
   * (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
   *
   * The format of translations_file (for target language code 'trg') is:
   * `gs://translation_test/a_b_c_'trg'_translations.[extension]`
   *
   * If the input file extension is tsv, the output has the following
   * columns:
   * Column 1: ID of the request provided in the input, if it's not
   * provided in the input, then the input row number is used (0-based).
   * Column 2: source sentence.
   * Column 3: translation without applying a glossary. Empty string if there
   * is an error.
   * Column 4 (only present if a glossary is provided in the request):
   * translation after applying the glossary. Empty string if there is an
   * error applying the glossary. Could be same string as column 3 if there is
   * no glossary applied.
   *
   * If input file extension is a txt or html, the translation is directly
   * written to the output file. If glossary is requested, a separate
   * glossary_translations_file has format of
   * `gs://translation_test/a_b_c_'trg'_glossary_translations.[extension]`
   *
   * The format of errors file (for target language code 'trg') is:
   * `gs://translation_test/a_b_c_'trg'_errors.[extension]`
   *
   * If the input file extension is tsv, errors_file contains the following:
   * Column 1: ID of the request provided in the input, if it's not
   * provided in the input, then the input row number is used (0-based).
   * Column 2: source sentence.
   * Column 3: Error detail for the translation. Could be empty.
   * Column 4 (only present if a glossary is provided in the request):
   * Error when applying the glossary.
   *
   * If the input file extension is txt or html, glossary_error_file will be
   * generated that contains error details. glossary_error_file has format of
   * `gs://translation_test/a_b_c_'trg'_glossary_errors.[extension]`
   */
  gcsDestination?: GcsDestination | undefined;
}

/** A document translation request input config. */
export interface DocumentInputConfig {
  /** Document's content represented as a stream of bytes. */
  content?:
    | Buffer
    | undefined;
  /**
   * Google Cloud Storage location. This must be a single file.
   * For example: gs://example_bucket/example_file.pdf
   */
  gcsSource?:
    | GcsSource
    | undefined;
  /**
   * Specifies the input document's mime_type.
   *
   * If not specified it will be determined using the file extension for
   * gcs_source provided files. For a file provided through bytes content the
   * mime_type must be provided.
   * Currently supported mime types are:
   * - application/pdf
   * - application/vnd.openxmlformats-officedocument.wordprocessingml.document
   * - application/vnd.openxmlformats-officedocument.presentationml.presentation
   * - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
   */
  mimeType: string;
}

/** A document translation request output config. */
export interface DocumentOutputConfig {
  /**
   * Optional. Google Cloud Storage destination for the translation output,
   * e.g., `gs://my_bucket/my_directory/`.
   *
   * The destination directory provided does not have to be empty, but the
   * bucket must exist. If a file with the same name as the output file
   * already exists in the destination an error will be returned.
   *
   * For a DocumentInputConfig.contents provided document, the output file
   * will have the name "output_[trg]_translations.[ext]", where
   * - [trg] corresponds to the translated file's language code,
   * - [ext] corresponds to the translated file's extension according to its
   * mime type.
   *
   * For a DocumentInputConfig.gcs_uri provided document, the output file will
   * have a name according to its URI. For example: an input file with URI:
   * `gs://a/b/c.[extension]` stored in a gcs_destination bucket with name
   * "my_bucket" will have an output URI:
   * `gs://my_bucket/a_b_c_[trg]_translations.[ext]`, where
   * - [trg] corresponds to the translated file's language code,
   * - [ext] corresponds to the translated file's extension according to its
   * mime type.
   *
   * If the document was directly provided through the request, then the
   * output document will have the format:
   * `gs://my_bucket/translated_document_[trg]_translations.[ext]`, where
   * - [trg] corresponds to the translated file's language code,
   * - [ext] corresponds to the translated file's extension according to its
   * mime type.
   *
   * If a glossary was provided, then the output URI for the glossary
   * translation will be equal to the default output URI but have
   * `glossary_translations` instead of `translations`. For the previous
   * example, its glossary URI would be:
   * `gs://my_bucket/a_b_c_[trg]_glossary_translations.[ext]`.
   *
   * Thus the max number of output files will be 2 (Translated document,
   * Glossary translated document).
   *
   * Callers should expect no partial outputs. If there is any error during
   * document translation, no output will be stored in the Cloud Storage
   * bucket.
   */
  gcsDestination?:
    | GcsDestination
    | undefined;
  /**
   * Optional. Specifies the translated document's mime_type.
   * If not specified, the translated file's mime type will be the same as the
   * input file's mime type.
   * Currently only support the output mime type to be the same as input mime
   * type.
   * - application/pdf
   * - application/vnd.openxmlformats-officedocument.wordprocessingml.document
   * - application/vnd.openxmlformats-officedocument.presentationml.presentation
   * - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
   */
  mimeType: string;
}

/** A document translation request. */
export interface TranslateDocumentRequest {
  /**
   * Required. Location to make a regional call.
   *
   * Format: `projects/{project-number-or-id}/locations/{location-id}`.
   *
   * For global calls, use `projects/{project-number-or-id}/locations/global`.
   *
   * Non-global location is required for requests using AutoML models or custom
   * glossaries.
   *
   * Models and glossaries must be within the same region (have the same
   * location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
   */
  parent: string;
  /**
   * Optional. The BCP-47 language code of the input document if known, for
   * example, "en-US" or "sr-Latn". Supported language codes are listed in
   * Language Support. If the source language isn't specified, the API attempts
   * to identify the source language automatically and returns the source
   * language within the response. Source language must be specified if the
   * request contains a glossary or a custom model.
   */
  sourceLanguageCode: string;
  /**
   * Required. The BCP-47 language code to use for translation of the input
   * document, set to one of the language codes listed in Language Support.
   */
  targetLanguageCode: string;
  /** Required. Input configurations. */
  documentInputConfig:
    | DocumentInputConfig
    | undefined;
  /**
   * Optional. Output configurations.
   * Defines if the output file should be stored within Cloud Storage as well
   * as the desired output format. If not provided the translated file will
   * only be returned through a byte-stream and its output mime type will be
   * the same as the input file's mime type.
   */
  documentOutputConfig:
    | DocumentOutputConfig
    | undefined;
  /**
   * Optional. The `model` type requested for this translation.
   *
   * The format depends on model type:
   *
   * - AutoML Translation models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
   *
   * - General (built-in) models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
   *
   * If not provided, the default Google model (NMT) will be used for
   * translation.
   */
  model: string;
  /**
   * Optional. Glossary to be applied. The glossary must be within the same
   * region (have the same location-id) as the model, otherwise an
   * INVALID_ARGUMENT (400) error is returned.
   */
  glossaryConfig:
    | TranslateTextGlossaryConfig
    | undefined;
  /**
   * Optional. The labels with user-defined metadata for the request.
   *
   * Label keys and values can be no longer than 63 characters (Unicode
   * codepoints), can only contain lowercase letters, numeric characters,
   * underscores and dashes. International characters are allowed. Label values
   * are optional. Label keys must start with a letter.
   *
   * See https://cloud.google.com/translate/docs/advanced/labels for more
   * information.
   */
  labels: { [key: string]: string };
  /**
   * Optional. This flag is to support user customized attribution.
   * If not provided, the default is `Machine Translated by Google`.
   * Customized attribution should follow rules in
   * https://cloud.google.com/translate/attribution#attribution_and_logos
   */
  customizedAttribution: string;
  /**
   * Optional. is_translate_native_pdf_only field for external customers.
   * If true, the page limit of online native pdf translation is 300 and only
   * native pdf pages will be translated.
   */
  isTranslateNativePdfOnly: boolean;
  /**
   * Optional. If true, use the text removal server to remove the shadow text on
   * background image for native pdf translation.
   * Shadow removal feature can only be enabled when
   * is_translate_native_pdf_only: false && pdf_native_only: false
   */
  enableShadowRemovalNativePdf: boolean;
  /** Optional. If true, enable auto rotation correction in DVS. */
  enableRotationCorrection: boolean;
}

export interface TranslateDocumentRequest_LabelsEntry {
  key: string;
  value: string;
}

/** A translated document message. */
export interface DocumentTranslation {
  /**
   * The array of translated documents. It is expected to be size 1 for now. We
   * may produce multiple translated documents in the future for other type of
   * file formats.
   */
  byteStreamOutputs: Buffer[];
  /** The translated document's mime type. */
  mimeType: string;
  /**
   * The detected language for the input document.
   * If the user did not provide the source language for the input document,
   * this field will have the language code automatically detected. If the
   * source language was passed, auto-detection of the language does not occur
   * and this field is empty.
   */
  detectedLanguageCode: string;
}

/** A translated document response message. */
export interface TranslateDocumentResponse {
  /** Translated document. */
  documentTranslation:
    | DocumentTranslation
    | undefined;
  /**
   * The document's translation output if a glossary is provided in the request.
   * This can be the same as [TranslateDocumentResponse.document_translation]
   * if no glossary terms apply.
   */
  glossaryDocumentTranslation:
    | DocumentTranslation
    | undefined;
  /**
   * Only present when 'model' is present in the request.
   * 'model' is normalized to have a project number.
   *
   * For example:
   * If the 'model' field in TranslateDocumentRequest is:
   * `projects/{project-id}/locations/{location-id}/models/general/nmt` then
   * `model` here would be normalized to
   * `projects/{project-number}/locations/{location-id}/models/general/nmt`.
   */
  model: string;
  /** The `glossary_config` used for this translation. */
  glossaryConfig: TranslateTextGlossaryConfig | undefined;
}

/** The batch translation request. */
export interface BatchTranslateTextRequest {
  /**
   * Required. Location to make a call. Must refer to a caller's project.
   *
   * Format: `projects/{project-number-or-id}/locations/{location-id}`.
   *
   * The `global` location is not supported for batch translation.
   *
   * Only AutoML Translation models or glossaries within the same region (have
   * the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
   * error is returned.
   */
  parent: string;
  /** Required. Source language code. */
  sourceLanguageCode: string;
  /** Required. Specify up to 10 language codes here. */
  targetLanguageCodes: string[];
  /**
   * Optional. The models to use for translation. Map's key is target language
   * code. Map's value is model name. Value can be a built-in general model,
   * or an AutoML Translation model.
   *
   * The value format depends on model type:
   *
   * - AutoML Translation models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
   *
   * - General (built-in) models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
   *
   * If the map is empty or a specific model is
   * not requested for a language pair, then default google model (nmt) is used.
   */
  models: { [key: string]: string };
  /**
   * Required. Input configurations.
   * The total number of files matched should be <= 100.
   * The total content size should be <= 100M Unicode codepoints.
   * The files must use UTF-8 encoding.
   */
  inputConfigs: InputConfig[];
  /**
   * Required. Output configuration.
   * If 2 input configs match to the same file (that is, same input path),
   * we don't generate output for duplicate inputs.
   */
  outputConfig:
    | OutputConfig
    | undefined;
  /**
   * Optional. Glossaries to be applied for translation.
   * It's keyed by target language code.
   */
  glossaries: { [key: string]: TranslateTextGlossaryConfig };
  /**
   * Optional. The labels with user-defined metadata for the request.
   *
   * Label keys and values can be no longer than 63 characters
   * (Unicode codepoints), can only contain lowercase letters, numeric
   * characters, underscores and dashes. International characters are allowed.
   * Label values are optional. Label keys must start with a letter.
   *
   * See https://cloud.google.com/translate/docs/labels for more information.
   */
  labels: { [key: string]: string };
}

export interface BatchTranslateTextRequest_ModelsEntry {
  key: string;
  value: string;
}

export interface BatchTranslateTextRequest_GlossariesEntry {
  key: string;
  value: TranslateTextGlossaryConfig | undefined;
}

export interface BatchTranslateTextRequest_LabelsEntry {
  key: string;
  value: string;
}

/** State metadata for the batch translation operation. */
export interface BatchTranslateMetadata {
  /** The state of the operation. */
  state: BatchTranslateMetadata_State;
  /** Number of successfully translated characters so far (Unicode codepoints). */
  translatedCharacters: Long;
  /**
   * Number of characters that have failed to process so far (Unicode
   * codepoints).
   */
  failedCharacters: Long;
  /**
   * Total number of characters (Unicode codepoints).
   * This is the total number of codepoints from input files times the number of
   * target languages and appears here shortly after the call is submitted.
   */
  totalCharacters: Long;
  /** Time when the operation was submitted. */
  submitTime: Date | undefined;
}

/** State of the job. */
export enum BatchTranslateMetadata_State {
  /** STATE_UNSPECIFIED - Invalid. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - Request is being processed. */
  RUNNING = 1,
  /**
   * SUCCEEDED - The batch is processed, and at least one item was successfully
   * processed.
   */
  SUCCEEDED = 2,
  /** FAILED - The batch is done and no item was successfully processed. */
  FAILED = 3,
  /**
   * CANCELLING - Request is in the process of being canceled after caller invoked
   * longrunning.Operations.CancelOperation on the request id.
   */
  CANCELLING = 4,
  /**
   * CANCELLED - The batch is done after the user has called the
   * longrunning.Operations.CancelOperation. Any records processed before the
   * cancel command are output as specified in the request.
   */
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function batchTranslateMetadata_StateFromJSON(object: any): BatchTranslateMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BatchTranslateMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return BatchTranslateMetadata_State.RUNNING;
    case 2:
    case "SUCCEEDED":
      return BatchTranslateMetadata_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return BatchTranslateMetadata_State.FAILED;
    case 4:
    case "CANCELLING":
      return BatchTranslateMetadata_State.CANCELLING;
    case 5:
    case "CANCELLED":
      return BatchTranslateMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchTranslateMetadata_State.UNRECOGNIZED;
  }
}

export function batchTranslateMetadata_StateToJSON(object: BatchTranslateMetadata_State): string {
  switch (object) {
    case BatchTranslateMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BatchTranslateMetadata_State.RUNNING:
      return "RUNNING";
    case BatchTranslateMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case BatchTranslateMetadata_State.FAILED:
      return "FAILED";
    case BatchTranslateMetadata_State.CANCELLING:
      return "CANCELLING";
    case BatchTranslateMetadata_State.CANCELLED:
      return "CANCELLED";
    case BatchTranslateMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Stored in the
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * field returned by BatchTranslateText if at least one sentence is translated
 * successfully.
 */
export interface BatchTranslateResponse {
  /** Total number of characters (Unicode codepoints). */
  totalCharacters: Long;
  /** Number of successfully translated characters (Unicode codepoints). */
  translatedCharacters: Long;
  /** Number of characters that have failed to process (Unicode codepoints). */
  failedCharacters: Long;
  /** Time when the operation was submitted. */
  submitTime:
    | Date
    | undefined;
  /**
   * The time when the operation is finished and
   * [google.longrunning.Operation.done][google.longrunning.Operation.done] is
   * set to true.
   */
  endTime: Date | undefined;
}

/** Input configuration for glossaries. */
export interface GlossaryInputConfig {
  /**
   * Required. Google Cloud Storage location of glossary data.
   * File format is determined based on the filename extension. API returns
   * [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file
   * formats. Wildcards are not allowed. This must be a single file in one of
   * the following formats:
   *
   * For unidirectional glossaries:
   *
   * - TSV/CSV (`.tsv`/`.csv`): 2 column file, tab- or comma-separated.
   *   The first column is source text. The second column is target text.
   *   The file must not contain headers. That is, the first row is data, not
   *   column names.
   *
   * - TMX (`.tmx`): TMX file with parallel data defining source/target term
   * pairs.
   *
   * For equivalent term sets glossaries:
   *
   * - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms
   *   in multiple languages. See documentation for more information -
   *   [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
   */
  gcsSource?: GcsSource | undefined;
}

/** Represents a glossary built from user provided data. */
export interface Glossary {
  /**
   * Required. The resource name of the glossary. Glossary names have the form
   * `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
   */
  name: string;
  /** Used with unidirectional glossaries. */
  languagePair?:
    | Glossary_LanguageCodePair
    | undefined;
  /** Used with equivalent term set glossaries. */
  languageCodesSet?:
    | Glossary_LanguageCodesSet
    | undefined;
  /**
   * Required. Provides examples to build the glossary from.
   * Total glossary must not exceed 10M Unicode codepoints.
   */
  inputConfig:
    | GlossaryInputConfig
    | undefined;
  /** Output only. The number of entries defined in the glossary. */
  entryCount: number;
  /** Output only. When CreateGlossary was called. */
  submitTime:
    | Date
    | undefined;
  /** Output only. When the glossary creation was finished. */
  endTime: Date | undefined;
}

/** Used with unidirectional glossaries. */
export interface Glossary_LanguageCodePair {
  /**
   * Required. The BCP-47 language code of the input text, for example,
   * "en-US". Expected to be an exact match for GlossaryTerm.language_code.
   */
  sourceLanguageCode: string;
  /**
   * Required. The BCP-47 language code for translation output, for example,
   * "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
   */
  targetLanguageCode: string;
}

/** Used with equivalent term set glossaries. */
export interface Glossary_LanguageCodesSet {
  /**
   * The BCP-47 language code(s) for terms defined in the glossary.
   * All entries are unique. The list contains at least two entries.
   * Expected to be an exact match for GlossaryTerm.language_code.
   */
  languageCodes: string[];
}

/** Request message for CreateGlossary. */
export interface CreateGlossaryRequest {
  /** Required. The project name. */
  parent: string;
  /** Required. The glossary to create. */
  glossary: Glossary | undefined;
}

/** Request message for GetGlossary. */
export interface GetGlossaryRequest {
  /** Required. The name of the glossary to retrieve. */
  name: string;
}

/** Request message for DeleteGlossary. */
export interface DeleteGlossaryRequest {
  /** Required. The name of the glossary to delete. */
  name: string;
}

/** Request message for ListGlossaries. */
export interface ListGlossariesRequest {
  /** Required. The name of the project from which to list all of the glossaries. */
  parent: string;
  /**
   * Optional. Requested page size. The server may return fewer glossaries than
   * requested. If unspecified, the server picks an appropriate default.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   * Typically, this is the value of [ListGlossariesResponse.next_page_token]
   * returned from the previous call to `ListGlossaries` method.
   * The first page is returned if `page_token`is empty or missing.
   */
  pageToken: string;
  /**
   * Optional. Filter specifying constraints of a list operation.
   * Specify the constraint by the format of "key=value", where key must be
   * "src" or "tgt", and the value must be a valid language code.
   * For multiple restrictions, concatenate them by "AND" (uppercase only),
   * such as: "src=en-US AND tgt=zh-CN". Notice that the exact match is used
   * here, which means using 'en-US' and 'en' can lead to different results,
   * which depends on the language code you used when you create the glossary.
   * For the unidirectional glossaries, the "src" and "tgt" add restrictions
   * on the source and target language code separately.
   * For the equivalent term set glossaries, the "src" and/or "tgt" add
   * restrictions on the term set.
   * For example: "src=en-US AND tgt=zh-CN" will only pick the unidirectional
   * glossaries which exactly match the source language code as "en-US" and the
   * target language code "zh-CN", but all equivalent term set glossaries which
   * contain "en-US" and "zh-CN" in their language set will be picked.
   * If missing, no filtering is performed.
   */
  filter: string;
}

/** Response message for ListGlossaries. */
export interface ListGlossariesResponse {
  /** The list of glossaries for a project. */
  glossaries: Glossary[];
  /**
   * A token to retrieve a page of results. Pass this value in the
   * [ListGlossariesRequest.page_token] field in the subsequent call to
   * `ListGlossaries` method to retrieve the next page of results.
   */
  nextPageToken: string;
}

/**
 * Stored in the
 * [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
 * field returned by CreateGlossary.
 */
export interface CreateGlossaryMetadata {
  /** The name of the glossary that is being created. */
  name: string;
  /** The current state of the glossary creation operation. */
  state: CreateGlossaryMetadata_State;
  /** The time when the operation was submitted to the server. */
  submitTime: Date | undefined;
}

/** Enumerates the possible states that the creation request can be in. */
export enum CreateGlossaryMetadata_State {
  /** STATE_UNSPECIFIED - Invalid. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - Request is being processed. */
  RUNNING = 1,
  /** SUCCEEDED - The glossary was successfully created. */
  SUCCEEDED = 2,
  /** FAILED - Failed to create the glossary. */
  FAILED = 3,
  /**
   * CANCELLING - Request is in the process of being canceled after caller invoked
   * longrunning.Operations.CancelOperation on the request id.
   */
  CANCELLING = 4,
  /** CANCELLED - The glossary creation request was successfully canceled. */
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function createGlossaryMetadata_StateFromJSON(object: any): CreateGlossaryMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CreateGlossaryMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return CreateGlossaryMetadata_State.RUNNING;
    case 2:
    case "SUCCEEDED":
      return CreateGlossaryMetadata_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return CreateGlossaryMetadata_State.FAILED;
    case 4:
    case "CANCELLING":
      return CreateGlossaryMetadata_State.CANCELLING;
    case 5:
    case "CANCELLED":
      return CreateGlossaryMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CreateGlossaryMetadata_State.UNRECOGNIZED;
  }
}

export function createGlossaryMetadata_StateToJSON(object: CreateGlossaryMetadata_State): string {
  switch (object) {
    case CreateGlossaryMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CreateGlossaryMetadata_State.RUNNING:
      return "RUNNING";
    case CreateGlossaryMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case CreateGlossaryMetadata_State.FAILED:
      return "FAILED";
    case CreateGlossaryMetadata_State.CANCELLING:
      return "CANCELLING";
    case CreateGlossaryMetadata_State.CANCELLED:
      return "CANCELLED";
    case CreateGlossaryMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Stored in the
 * [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
 * field returned by DeleteGlossary.
 */
export interface DeleteGlossaryMetadata {
  /** The name of the glossary that is being deleted. */
  name: string;
  /** The current state of the glossary deletion operation. */
  state: DeleteGlossaryMetadata_State;
  /** The time when the operation was submitted to the server. */
  submitTime: Date | undefined;
}

/** Enumerates the possible states that the creation request can be in. */
export enum DeleteGlossaryMetadata_State {
  /** STATE_UNSPECIFIED - Invalid. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - Request is being processed. */
  RUNNING = 1,
  /** SUCCEEDED - The glossary was successfully deleted. */
  SUCCEEDED = 2,
  /** FAILED - Failed to delete the glossary. */
  FAILED = 3,
  /**
   * CANCELLING - Request is in the process of being canceled after caller invoked
   * longrunning.Operations.CancelOperation on the request id.
   */
  CANCELLING = 4,
  /** CANCELLED - The glossary deletion request was successfully canceled. */
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function deleteGlossaryMetadata_StateFromJSON(object: any): DeleteGlossaryMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return DeleteGlossaryMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return DeleteGlossaryMetadata_State.RUNNING;
    case 2:
    case "SUCCEEDED":
      return DeleteGlossaryMetadata_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return DeleteGlossaryMetadata_State.FAILED;
    case 4:
    case "CANCELLING":
      return DeleteGlossaryMetadata_State.CANCELLING;
    case 5:
    case "CANCELLED":
      return DeleteGlossaryMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeleteGlossaryMetadata_State.UNRECOGNIZED;
  }
}

export function deleteGlossaryMetadata_StateToJSON(object: DeleteGlossaryMetadata_State): string {
  switch (object) {
    case DeleteGlossaryMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case DeleteGlossaryMetadata_State.RUNNING:
      return "RUNNING";
    case DeleteGlossaryMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case DeleteGlossaryMetadata_State.FAILED:
      return "FAILED";
    case DeleteGlossaryMetadata_State.CANCELLING:
      return "CANCELLING";
    case DeleteGlossaryMetadata_State.CANCELLED:
      return "CANCELLED";
    case DeleteGlossaryMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Stored in the
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * field returned by DeleteGlossary.
 */
export interface DeleteGlossaryResponse {
  /** The name of the deleted glossary. */
  name: string;
  /** The time when the operation was submitted to the server. */
  submitTime:
    | Date
    | undefined;
  /**
   * The time when the glossary deletion is finished and
   * [google.longrunning.Operation.done][google.longrunning.Operation.done] is
   * set to true.
   */
  endTime: Date | undefined;
}

/** The BatchTranslateDocument request. */
export interface BatchTranslateDocumentRequest {
  /**
   * Required. Location to make a regional call.
   *
   * Format: `projects/{project-number-or-id}/locations/{location-id}`.
   *
   * The `global` location is not supported for batch translation.
   *
   * Only AutoML Translation models or glossaries within the same region (have
   * the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
   * error is returned.
   */
  parent: string;
  /**
   * Required. The BCP-47 language code of the input document if known, for
   * example, "en-US" or "sr-Latn". Supported language codes are listed in
   * [Language Support](https://cloud.google.com/translate/docs/languages).
   */
  sourceLanguageCode: string;
  /**
   * Required. The BCP-47 language code to use for translation of the input
   * document. Specify up to 10 language codes here.
   */
  targetLanguageCodes: string[];
  /**
   * Required. Input configurations.
   * The total number of files matched should be <= 100.
   * The total content size to translate should be <= 100M Unicode codepoints.
   * The files must use UTF-8 encoding.
   */
  inputConfigs: BatchDocumentInputConfig[];
  /**
   * Required. Output configuration.
   * If 2 input configs match to the same file (that is, same input path),
   * we don't generate output for duplicate inputs.
   */
  outputConfig:
    | BatchDocumentOutputConfig
    | undefined;
  /**
   * Optional. The models to use for translation. Map's key is target language
   * code. Map's value is the model name. Value can be a built-in general model,
   * or an AutoML Translation model.
   *
   * The value format depends on model type:
   *
   * - AutoML Translation models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
   *
   * - General (built-in) models:
   *   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
   *
   * If the map is empty or a specific model is not requested for a language
   * pair, then default google model (nmt) is used.
   */
  models: { [key: string]: string };
  /** Optional. Glossaries to be applied. It's keyed by target language code. */
  glossaries: { [key: string]: TranslateTextGlossaryConfig };
  /**
   * Optional. File format conversion map to be applied to all input files.
   * Map's key is the original mime_type. Map's value is the target mime_type of
   * translated documents.
   *
   * Supported file format conversion includes:
   * - `application/pdf` to
   *   `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
   *
   * If nothing specified, output files will be in the same format as the
   * original file.
   */
  formatConversions: { [key: string]: string };
  /**
   * Optional. This flag is to support user customized attribution.
   * If not provided, the default is `Machine Translated by Google`.
   * Customized attribution should follow rules in
   * https://cloud.google.com/translate/attribution#attribution_and_logos
   */
  customizedAttribution: string;
  /**
   * Optional. If true, use the text removal server to remove the shadow text on
   * background image for native pdf translation.
   * Shadow removal feature can only be enabled when
   * is_translate_native_pdf_only: false && pdf_native_only: false
   */
  enableShadowRemovalNativePdf: boolean;
  /** Optional. If true, enable auto rotation correction in DVS. */
  enableRotationCorrection: boolean;
}

export interface BatchTranslateDocumentRequest_ModelsEntry {
  key: string;
  value: string;
}

export interface BatchTranslateDocumentRequest_GlossariesEntry {
  key: string;
  value: TranslateTextGlossaryConfig | undefined;
}

export interface BatchTranslateDocumentRequest_FormatConversionsEntry {
  key: string;
  value: string;
}

/** Input configuration for BatchTranslateDocument request. */
export interface BatchDocumentInputConfig {
  /**
   * Google Cloud Storage location for the source input.
   * This can be a single file (for example,
   * `gs://translation-test/input.docx`) or a wildcard (for example,
   * `gs://translation-test/*`).
   *
   * File mime type is determined based on extension. Supported mime type
   * includes:
   * - `pdf`, application/pdf
   * - `docx`,
   * application/vnd.openxmlformats-officedocument.wordprocessingml.document
   * - `pptx`,
   * application/vnd.openxmlformats-officedocument.presentationml.presentation
   * - `xlsx`,
   * application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
   *
   * The max file size to support for `.docx`, `.pptx` and `.xlsx` is 100MB.
   * The max file size to support for `.pdf` is 1GB and the max page limit is
   * 1000 pages.
   * The max file size to support for all input documents is 1GB.
   */
  gcsSource?: GcsSource | undefined;
}

/** Output configuration for BatchTranslateDocument request. */
export interface BatchDocumentOutputConfig {
  /**
   * Google Cloud Storage destination for output content.
   * For every single input document (for example, gs://a/b/c.[extension]), we
   * generate at most 2 * n output files. (n is the # of target_language_codes
   * in the BatchTranslateDocumentRequest).
   *
   * While the input documents are being processed, we write/update an index
   * file `index.csv` under `gcs_destination.output_uri_prefix` (for example,
   * gs://translation_output/index.csv) The index file is generated/updated as
   * new files are being translated. The format is:
   *
   * input_document,target_language_code,translation_output,error_output,
   * glossary_translation_output,glossary_error_output
   *
   * `input_document` is one file we matched using gcs_source.input_uri.
   * `target_language_code` is provided in the request.
   * `translation_output` contains the translations. (details provided below)
   * `error_output` contains the error message during processing of the file.
   * Both translations_file and errors_file could be empty strings if we have
   * no content to output.
   * `glossary_translation_output` and `glossary_error_output` are the
   * translated output/error when we apply glossaries. They could also be
   * empty if we have no content to output.
   *
   * Once a row is present in index.csv, the input/output matching never
   * changes. Callers should also expect all the content in input_file are
   * processed and ready to be consumed (that is, no partial output file is
   * written).
   *
   * Since index.csv will be keeping updated during the process, please make
   * sure there is no custom retention policy applied on the output bucket
   * that may avoid file updating.
   * (https://cloud.google.com/storage/docs/bucket-lock#retention-policy)
   *
   * The naming format of translation output files follows (for target
   * language code [trg]): `translation_output`:
   * `gs://translation_output/a_b_c_[trg]_translation.[extension]`
   * `glossary_translation_output`:
   * `gs://translation_test/a_b_c_[trg]_glossary_translation.[extension]`. The
   * output document will maintain the same file format as the input document.
   *
   * The naming format of error output files follows (for target language code
   * [trg]): `error_output`: `gs://translation_test/a_b_c_[trg]_errors.txt`
   * `glossary_error_output`:
   * `gs://translation_test/a_b_c_[trg]_glossary_translation.txt` The error
   * output is a txt file containing error details.
   */
  gcsDestination?: GcsDestination | undefined;
}

/**
 * Stored in the
 * [google.longrunning.Operation.response][google.longrunning.Operation.response]
 * field returned by BatchTranslateDocument if at least one document is
 * translated successfully.
 */
export interface BatchTranslateDocumentResponse {
  /**
   * Total number of pages to translate in all documents. Documents without
   * clear page definition (such as XLSX) are not counted.
   */
  totalPages: Long;
  /**
   * Number of successfully translated pages in all documents. Documents without
   * clear page definition (such as XLSX) are not counted.
   */
  translatedPages: Long;
  /**
   * Number of pages that failed to process in all documents. Documents without
   * clear page definition (such as XLSX) are not counted.
   */
  failedPages: Long;
  /**
   * Number of billable pages in documents with clear page definition (such as
   * PDF, DOCX, PPTX)
   */
  totalBillablePages: Long;
  /** Total number of characters (Unicode codepoints) in all documents. */
  totalCharacters: Long;
  /**
   * Number of successfully translated characters (Unicode codepoints) in all
   * documents.
   */
  translatedCharacters: Long;
  /**
   * Number of characters that have failed to process (Unicode codepoints) in
   * all documents.
   */
  failedCharacters: Long;
  /**
   * Number of billable characters (Unicode codepoints) in documents without
   * clear page definition, such as XLSX.
   */
  totalBillableCharacters: Long;
  /** Time when the operation was submitted. */
  submitTime:
    | Date
    | undefined;
  /**
   * The time when the operation is finished and
   * [google.longrunning.Operation.done][google.longrunning.Operation.done] is
   * set to true.
   */
  endTime: Date | undefined;
}

/** State metadata for the batch translation operation. */
export interface BatchTranslateDocumentMetadata {
  /** The state of the operation. */
  state: BatchTranslateDocumentMetadata_State;
  /**
   * Total number of pages to translate in all documents so far. Documents
   * without clear page definition (such as XLSX) are not counted.
   */
  totalPages: Long;
  /**
   * Number of successfully translated pages in all documents so far. Documents
   * without clear page definition (such as XLSX) are not counted.
   */
  translatedPages: Long;
  /**
   * Number of pages that failed to process in all documents so far. Documents
   * without clear page definition (such as XLSX) are not counted.
   */
  failedPages: Long;
  /**
   * Number of billable pages in documents with clear page definition (such as
   * PDF, DOCX, PPTX) so far.
   */
  totalBillablePages: Long;
  /** Total number of characters (Unicode codepoints) in all documents so far. */
  totalCharacters: Long;
  /**
   * Number of successfully translated characters (Unicode codepoints) in all
   * documents so far.
   */
  translatedCharacters: Long;
  /**
   * Number of characters that have failed to process (Unicode codepoints) in
   * all documents so far.
   */
  failedCharacters: Long;
  /**
   * Number of billable characters (Unicode codepoints) in documents without
   * clear page definition (such as XLSX) so far.
   */
  totalBillableCharacters: Long;
  /** Time when the operation was submitted. */
  submitTime: Date | undefined;
}

/** State of the job. */
export enum BatchTranslateDocumentMetadata_State {
  /** STATE_UNSPECIFIED - Invalid. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - Request is being processed. */
  RUNNING = 1,
  /** SUCCEEDED - The batch is processed, and at least one item was successfully processed. */
  SUCCEEDED = 2,
  /** FAILED - The batch is done and no item was successfully processed. */
  FAILED = 3,
  /**
   * CANCELLING - Request is in the process of being canceled after caller invoked
   * longrunning.Operations.CancelOperation on the request id.
   */
  CANCELLING = 4,
  /**
   * CANCELLED - The batch is done after the user has called the
   * longrunning.Operations.CancelOperation. Any records processed before the
   * cancel command are output as specified in the request.
   */
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function batchTranslateDocumentMetadata_StateFromJSON(object: any): BatchTranslateDocumentMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BatchTranslateDocumentMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return BatchTranslateDocumentMetadata_State.RUNNING;
    case 2:
    case "SUCCEEDED":
      return BatchTranslateDocumentMetadata_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return BatchTranslateDocumentMetadata_State.FAILED;
    case 4:
    case "CANCELLING":
      return BatchTranslateDocumentMetadata_State.CANCELLING;
    case 5:
    case "CANCELLED":
      return BatchTranslateDocumentMetadata_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BatchTranslateDocumentMetadata_State.UNRECOGNIZED;
  }
}

export function batchTranslateDocumentMetadata_StateToJSON(object: BatchTranslateDocumentMetadata_State): string {
  switch (object) {
    case BatchTranslateDocumentMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BatchTranslateDocumentMetadata_State.RUNNING:
      return "RUNNING";
    case BatchTranslateDocumentMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case BatchTranslateDocumentMetadata_State.FAILED:
      return "FAILED";
    case BatchTranslateDocumentMetadata_State.CANCELLING:
      return "CANCELLING";
    case BatchTranslateDocumentMetadata_State.CANCELLED:
      return "CANCELLED";
    case BatchTranslateDocumentMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseTranslateTextGlossaryConfig(): TranslateTextGlossaryConfig {
  return { glossary: "", ignoreCase: false };
}

export const TranslateTextGlossaryConfig: MessageFns<TranslateTextGlossaryConfig> = {
  encode(message: TranslateTextGlossaryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.glossary !== "") {
      writer.uint32(10).string(message.glossary);
    }
    if (message.ignoreCase !== false) {
      writer.uint32(16).bool(message.ignoreCase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextGlossaryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextGlossaryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.glossary = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ignoreCase = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextGlossaryConfig {
    return {
      glossary: isSet(object.glossary) ? globalThis.String(object.glossary) : "",
      ignoreCase: isSet(object.ignoreCase) ? globalThis.Boolean(object.ignoreCase) : false,
    };
  },

  toJSON(message: TranslateTextGlossaryConfig): unknown {
    const obj: any = {};
    if (message.glossary !== "") {
      obj.glossary = message.glossary;
    }
    if (message.ignoreCase !== false) {
      obj.ignoreCase = message.ignoreCase;
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateTextGlossaryConfig>): TranslateTextGlossaryConfig {
    return TranslateTextGlossaryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateTextGlossaryConfig>): TranslateTextGlossaryConfig {
    const message = createBaseTranslateTextGlossaryConfig();
    message.glossary = object.glossary ?? "";
    message.ignoreCase = object.ignoreCase ?? false;
    return message;
  },
};

function createBaseTranslateTextRequest(): TranslateTextRequest {
  return {
    contents: [],
    mimeType: "",
    sourceLanguageCode: "",
    targetLanguageCode: "",
    parent: "",
    model: "",
    glossaryConfig: undefined,
    labels: {},
  };
}

export const TranslateTextRequest: MessageFns<TranslateTextRequest> = {
  encode(message: TranslateTextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.contents) {
      writer.uint32(10).string(v!);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(34).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(42).string(message.targetLanguageCode);
    }
    if (message.parent !== "") {
      writer.uint32(66).string(message.parent);
    }
    if (message.model !== "") {
      writer.uint32(50).string(message.model);
    }
    if (message.glossaryConfig !== undefined) {
      TranslateTextGlossaryConfig.encode(message.glossaryConfig, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TranslateTextRequest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contents.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.model = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.glossaryConfig = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = TranslateTextRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextRequest {
    return {
      contents: globalThis.Array.isArray(object?.contents) ? object.contents.map((e: any) => globalThis.String(e)) : [],
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      glossaryConfig: isSet(object.glossaryConfig)
        ? TranslateTextGlossaryConfig.fromJSON(object.glossaryConfig)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TranslateTextRequest): unknown {
    const obj: any = {};
    if (message.contents?.length) {
      obj.contents = message.contents;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.glossaryConfig !== undefined) {
      obj.glossaryConfig = TranslateTextGlossaryConfig.toJSON(message.glossaryConfig);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateTextRequest>): TranslateTextRequest {
    return TranslateTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateTextRequest>): TranslateTextRequest {
    const message = createBaseTranslateTextRequest();
    message.contents = object.contents?.map((e) => e) || [];
    message.mimeType = object.mimeType ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.parent = object.parent ?? "";
    message.model = object.model ?? "";
    message.glossaryConfig = (object.glossaryConfig !== undefined && object.glossaryConfig !== null)
      ? TranslateTextGlossaryConfig.fromPartial(object.glossaryConfig)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTranslateTextRequest_LabelsEntry(): TranslateTextRequest_LabelsEntry {
  return { key: "", value: "" };
}

export const TranslateTextRequest_LabelsEntry: MessageFns<TranslateTextRequest_LabelsEntry> = {
  encode(message: TranslateTextRequest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TranslateTextRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateTextRequest_LabelsEntry>): TranslateTextRequest_LabelsEntry {
    return TranslateTextRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateTextRequest_LabelsEntry>): TranslateTextRequest_LabelsEntry {
    const message = createBaseTranslateTextRequest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTranslateTextResponse(): TranslateTextResponse {
  return { translations: [], glossaryTranslations: [] };
}

export const TranslateTextResponse: MessageFns<TranslateTextResponse> = {
  encode(message: TranslateTextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.translations) {
      Translation.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.glossaryTranslations) {
      Translation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateTextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translations.push(Translation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.glossaryTranslations.push(Translation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateTextResponse {
    return {
      translations: globalThis.Array.isArray(object?.translations)
        ? object.translations.map((e: any) => Translation.fromJSON(e))
        : [],
      glossaryTranslations: globalThis.Array.isArray(object?.glossaryTranslations)
        ? object.glossaryTranslations.map((e: any) => Translation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TranslateTextResponse): unknown {
    const obj: any = {};
    if (message.translations?.length) {
      obj.translations = message.translations.map((e) => Translation.toJSON(e));
    }
    if (message.glossaryTranslations?.length) {
      obj.glossaryTranslations = message.glossaryTranslations.map((e) => Translation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateTextResponse>): TranslateTextResponse {
    return TranslateTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateTextResponse>): TranslateTextResponse {
    const message = createBaseTranslateTextResponse();
    message.translations = object.translations?.map((e) => Translation.fromPartial(e)) || [];
    message.glossaryTranslations = object.glossaryTranslations?.map((e) => Translation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTranslation(): Translation {
  return { translatedText: "", model: "", detectedLanguageCode: "", glossaryConfig: undefined };
}

export const Translation: MessageFns<Translation> = {
  encode(message: Translation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.translatedText !== "") {
      writer.uint32(10).string(message.translatedText);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    if (message.detectedLanguageCode !== "") {
      writer.uint32(34).string(message.detectedLanguageCode);
    }
    if (message.glossaryConfig !== undefined) {
      TranslateTextGlossaryConfig.encode(message.glossaryConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Translation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translatedText = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.glossaryConfig = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Translation {
    return {
      translatedText: isSet(object.translatedText) ? globalThis.String(object.translatedText) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      detectedLanguageCode: isSet(object.detectedLanguageCode) ? globalThis.String(object.detectedLanguageCode) : "",
      glossaryConfig: isSet(object.glossaryConfig)
        ? TranslateTextGlossaryConfig.fromJSON(object.glossaryConfig)
        : undefined,
    };
  },

  toJSON(message: Translation): unknown {
    const obj: any = {};
    if (message.translatedText !== "") {
      obj.translatedText = message.translatedText;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.detectedLanguageCode !== "") {
      obj.detectedLanguageCode = message.detectedLanguageCode;
    }
    if (message.glossaryConfig !== undefined) {
      obj.glossaryConfig = TranslateTextGlossaryConfig.toJSON(message.glossaryConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Translation>): Translation {
    return Translation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Translation>): Translation {
    const message = createBaseTranslation();
    message.translatedText = object.translatedText ?? "";
    message.model = object.model ?? "";
    message.detectedLanguageCode = object.detectedLanguageCode ?? "";
    message.glossaryConfig = (object.glossaryConfig !== undefined && object.glossaryConfig !== null)
      ? TranslateTextGlossaryConfig.fromPartial(object.glossaryConfig)
      : undefined;
    return message;
  },
};

function createBaseDetectLanguageRequest(): DetectLanguageRequest {
  return { parent: "", model: "", content: undefined, mimeType: "", labels: {} };
}

export const DetectLanguageRequest: MessageFns<DetectLanguageRequest> = {
  encode(message: DetectLanguageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    if (message.model !== "") {
      writer.uint32(34).string(message.model);
    }
    if (message.content !== undefined) {
      writer.uint32(10).string(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DetectLanguageRequest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectLanguageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectLanguageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = DetectLanguageRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectLanguageRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DetectLanguageRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.content !== undefined) {
      obj.content = message.content;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DetectLanguageRequest>): DetectLanguageRequest {
    return DetectLanguageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectLanguageRequest>): DetectLanguageRequest {
    const message = createBaseDetectLanguageRequest();
    message.parent = object.parent ?? "";
    message.model = object.model ?? "";
    message.content = object.content ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDetectLanguageRequest_LabelsEntry(): DetectLanguageRequest_LabelsEntry {
  return { key: "", value: "" };
}

export const DetectLanguageRequest_LabelsEntry: MessageFns<DetectLanguageRequest_LabelsEntry> = {
  encode(message: DetectLanguageRequest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectLanguageRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectLanguageRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectLanguageRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DetectLanguageRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DetectLanguageRequest_LabelsEntry>): DetectLanguageRequest_LabelsEntry {
    return DetectLanguageRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectLanguageRequest_LabelsEntry>): DetectLanguageRequest_LabelsEntry {
    const message = createBaseDetectLanguageRequest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDetectedLanguage(): DetectedLanguage {
  return { languageCode: "", confidence: 0 };
}

export const DetectedLanguage: MessageFns<DetectedLanguage> = {
  encode(message: DetectedLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectedLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectedLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectedLanguage {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: DetectedLanguage): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<DetectedLanguage>): DetectedLanguage {
    return DetectedLanguage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectedLanguage>): DetectedLanguage {
    const message = createBaseDetectedLanguage();
    message.languageCode = object.languageCode ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseDetectLanguageResponse(): DetectLanguageResponse {
  return { languages: [] };
}

export const DetectLanguageResponse: MessageFns<DetectLanguageResponse> = {
  encode(message: DetectLanguageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languages) {
      DetectedLanguage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetectLanguageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetectLanguageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languages.push(DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetectLanguageResponse {
    return {
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DetectLanguageResponse): unknown {
    const obj: any = {};
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) => DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DetectLanguageResponse>): DetectLanguageResponse {
    return DetectLanguageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetectLanguageResponse>): DetectLanguageResponse {
    const message = createBaseDetectLanguageResponse();
    message.languages = object.languages?.map((e) => DetectedLanguage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSupportedLanguagesRequest(): GetSupportedLanguagesRequest {
  return { parent: "", displayLanguageCode: "", model: "" };
}

export const GetSupportedLanguagesRequest: MessageFns<GetSupportedLanguagesRequest> = {
  encode(message: GetSupportedLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.displayLanguageCode !== "") {
      writer.uint32(10).string(message.displayLanguageCode);
    }
    if (message.model !== "") {
      writer.uint32(18).string(message.model);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSupportedLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSupportedLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayLanguageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSupportedLanguagesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      displayLanguageCode: isSet(object.displayLanguageCode) ? globalThis.String(object.displayLanguageCode) : "",
      model: isSet(object.model) ? globalThis.String(object.model) : "",
    };
  },

  toJSON(message: GetSupportedLanguagesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.displayLanguageCode !== "") {
      obj.displayLanguageCode = message.displayLanguageCode;
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSupportedLanguagesRequest>): GetSupportedLanguagesRequest {
    return GetSupportedLanguagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSupportedLanguagesRequest>): GetSupportedLanguagesRequest {
    const message = createBaseGetSupportedLanguagesRequest();
    message.parent = object.parent ?? "";
    message.displayLanguageCode = object.displayLanguageCode ?? "";
    message.model = object.model ?? "";
    return message;
  },
};

function createBaseSupportedLanguages(): SupportedLanguages {
  return { languages: [] };
}

export const SupportedLanguages: MessageFns<SupportedLanguages> = {
  encode(message: SupportedLanguages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languages) {
      SupportedLanguage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupportedLanguages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedLanguages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languages.push(SupportedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedLanguages {
    return {
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => SupportedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SupportedLanguages): unknown {
    const obj: any = {};
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) => SupportedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SupportedLanguages>): SupportedLanguages {
    return SupportedLanguages.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupportedLanguages>): SupportedLanguages {
    const message = createBaseSupportedLanguages();
    message.languages = object.languages?.map((e) => SupportedLanguage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSupportedLanguage(): SupportedLanguage {
  return { languageCode: "", displayName: "", supportSource: false, supportTarget: false };
}

export const SupportedLanguage: MessageFns<SupportedLanguage> = {
  encode(message: SupportedLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.supportSource !== false) {
      writer.uint32(24).bool(message.supportSource);
    }
    if (message.supportTarget !== false) {
      writer.uint32(32).bool(message.supportTarget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SupportedLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSupportedLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.supportSource = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.supportTarget = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SupportedLanguage {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      supportSource: isSet(object.supportSource) ? globalThis.Boolean(object.supportSource) : false,
      supportTarget: isSet(object.supportTarget) ? globalThis.Boolean(object.supportTarget) : false,
    };
  },

  toJSON(message: SupportedLanguage): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.supportSource !== false) {
      obj.supportSource = message.supportSource;
    }
    if (message.supportTarget !== false) {
      obj.supportTarget = message.supportTarget;
    }
    return obj;
  },

  create(base?: DeepPartial<SupportedLanguage>): SupportedLanguage {
    return SupportedLanguage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SupportedLanguage>): SupportedLanguage {
    const message = createBaseSupportedLanguage();
    message.languageCode = object.languageCode ?? "";
    message.displayName = object.displayName ?? "";
    message.supportSource = object.supportSource ?? false;
    message.supportTarget = object.supportTarget ?? false;
    return message;
  },
};

function createBaseGcsSource(): GcsSource {
  return { inputUri: "" };
}

export const GcsSource: MessageFns<GcsSource> = {
  encode(message: GcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputUri !== "") {
      writer.uint32(10).string(message.inputUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsSource {
    return { inputUri: isSet(object.inputUri) ? globalThis.String(object.inputUri) : "" };
  },

  toJSON(message: GcsSource): unknown {
    const obj: any = {};
    if (message.inputUri !== "") {
      obj.inputUri = message.inputUri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsSource>): GcsSource {
    return GcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsSource>): GcsSource {
    const message = createBaseGcsSource();
    message.inputUri = object.inputUri ?? "";
    return message;
  },
};

function createBaseInputConfig(): InputConfig {
  return { mimeType: "", gcsSource: undefined };
}

export const InputConfig: MessageFns<InputConfig> = {
  encode(message: InputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputConfig {
    return {
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
    };
  },

  toJSON(message: InputConfig): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<InputConfig>): InputConfig {
    return InputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputConfig>): InputConfig {
    const message = createBaseInputConfig();
    message.mimeType = object.mimeType ?? "";
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    return message;
  },
};

function createBaseGcsDestination(): GcsDestination {
  return { outputUriPrefix: "" };
}

export const GcsDestination: MessageFns<GcsDestination> = {
  encode(message: GcsDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputUriPrefix !== "") {
      writer.uint32(10).string(message.outputUriPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputUriPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDestination {
    return { outputUriPrefix: isSet(object.outputUriPrefix) ? globalThis.String(object.outputUriPrefix) : "" };
  },

  toJSON(message: GcsDestination): unknown {
    const obj: any = {};
    if (message.outputUriPrefix !== "") {
      obj.outputUriPrefix = message.outputUriPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDestination>): GcsDestination {
    return GcsDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDestination>): GcsDestination {
    const message = createBaseGcsDestination();
    message.outputUriPrefix = object.outputUriPrefix ?? "";
    return message;
  },
};

function createBaseOutputConfig(): OutputConfig {
  return { gcsDestination: undefined };
}

export const OutputConfig: MessageFns<OutputConfig> = {
  encode(message: OutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsDestination.fromJSON(object.gcsDestination) : undefined,
    };
  },

  toJSON(message: OutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsDestination.toJSON(message.gcsDestination);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputConfig>): OutputConfig {
    return OutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputConfig>): OutputConfig {
    const message = createBaseOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsDestination.fromPartial(object.gcsDestination)
      : undefined;
    return message;
  },
};

function createBaseDocumentInputConfig(): DocumentInputConfig {
  return { content: undefined, gcsSource: undefined, mimeType: "" };
}

export const DocumentInputConfig: MessageFns<DocumentInputConfig> = {
  encode(message: DocumentInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(18).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentInputConfig {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: DocumentInputConfig): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentInputConfig>): DocumentInputConfig {
    return DocumentInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentInputConfig>): DocumentInputConfig {
    const message = createBaseDocumentInputConfig();
    message.content = object.content ?? undefined;
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseDocumentOutputConfig(): DocumentOutputConfig {
  return { gcsDestination: undefined, mimeType: "" };
}

export const DocumentOutputConfig: MessageFns<DocumentOutputConfig> = {
  encode(message: DocumentOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentOutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsDestination.fromJSON(object.gcsDestination) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: DocumentOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsDestination.toJSON(message.gcsDestination);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentOutputConfig>): DocumentOutputConfig {
    return DocumentOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentOutputConfig>): DocumentOutputConfig {
    const message = createBaseDocumentOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsDestination.fromPartial(object.gcsDestination)
      : undefined;
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseTranslateDocumentRequest(): TranslateDocumentRequest {
  return {
    parent: "",
    sourceLanguageCode: "",
    targetLanguageCode: "",
    documentInputConfig: undefined,
    documentOutputConfig: undefined,
    model: "",
    glossaryConfig: undefined,
    labels: {},
    customizedAttribution: "",
    isTranslateNativePdfOnly: false,
    enableShadowRemovalNativePdf: false,
    enableRotationCorrection: false,
  };
}

export const TranslateDocumentRequest: MessageFns<TranslateDocumentRequest> = {
  encode(message: TranslateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(18).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(26).string(message.targetLanguageCode);
    }
    if (message.documentInputConfig !== undefined) {
      DocumentInputConfig.encode(message.documentInputConfig, writer.uint32(34).fork()).join();
    }
    if (message.documentOutputConfig !== undefined) {
      DocumentOutputConfig.encode(message.documentOutputConfig, writer.uint32(42).fork()).join();
    }
    if (message.model !== "") {
      writer.uint32(50).string(message.model);
    }
    if (message.glossaryConfig !== undefined) {
      TranslateTextGlossaryConfig.encode(message.glossaryConfig, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      TranslateDocumentRequest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.customizedAttribution !== "") {
      writer.uint32(82).string(message.customizedAttribution);
    }
    if (message.isTranslateNativePdfOnly !== false) {
      writer.uint32(88).bool(message.isTranslateNativePdfOnly);
    }
    if (message.enableShadowRemovalNativePdf !== false) {
      writer.uint32(96).bool(message.enableShadowRemovalNativePdf);
    }
    if (message.enableRotationCorrection !== false) {
      writer.uint32(104).bool(message.enableRotationCorrection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentInputConfig = DocumentInputConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.documentOutputConfig = DocumentOutputConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.model = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.glossaryConfig = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = TranslateDocumentRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.customizedAttribution = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isTranslateNativePdfOnly = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableShadowRemovalNativePdf = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.enableRotationCorrection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateDocumentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      documentInputConfig: isSet(object.documentInputConfig)
        ? DocumentInputConfig.fromJSON(object.documentInputConfig)
        : undefined,
      documentOutputConfig: isSet(object.documentOutputConfig)
        ? DocumentOutputConfig.fromJSON(object.documentOutputConfig)
        : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      glossaryConfig: isSet(object.glossaryConfig)
        ? TranslateTextGlossaryConfig.fromJSON(object.glossaryConfig)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      customizedAttribution: isSet(object.customizedAttribution) ? globalThis.String(object.customizedAttribution) : "",
      isTranslateNativePdfOnly: isSet(object.isTranslateNativePdfOnly)
        ? globalThis.Boolean(object.isTranslateNativePdfOnly)
        : false,
      enableShadowRemovalNativePdf: isSet(object.enableShadowRemovalNativePdf)
        ? globalThis.Boolean(object.enableShadowRemovalNativePdf)
        : false,
      enableRotationCorrection: isSet(object.enableRotationCorrection)
        ? globalThis.Boolean(object.enableRotationCorrection)
        : false,
    };
  },

  toJSON(message: TranslateDocumentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.documentInputConfig !== undefined) {
      obj.documentInputConfig = DocumentInputConfig.toJSON(message.documentInputConfig);
    }
    if (message.documentOutputConfig !== undefined) {
      obj.documentOutputConfig = DocumentOutputConfig.toJSON(message.documentOutputConfig);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.glossaryConfig !== undefined) {
      obj.glossaryConfig = TranslateTextGlossaryConfig.toJSON(message.glossaryConfig);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.customizedAttribution !== "") {
      obj.customizedAttribution = message.customizedAttribution;
    }
    if (message.isTranslateNativePdfOnly !== false) {
      obj.isTranslateNativePdfOnly = message.isTranslateNativePdfOnly;
    }
    if (message.enableShadowRemovalNativePdf !== false) {
      obj.enableShadowRemovalNativePdf = message.enableShadowRemovalNativePdf;
    }
    if (message.enableRotationCorrection !== false) {
      obj.enableRotationCorrection = message.enableRotationCorrection;
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateDocumentRequest>): TranslateDocumentRequest {
    return TranslateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateDocumentRequest>): TranslateDocumentRequest {
    const message = createBaseTranslateDocumentRequest();
    message.parent = object.parent ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.documentInputConfig = (object.documentInputConfig !== undefined && object.documentInputConfig !== null)
      ? DocumentInputConfig.fromPartial(object.documentInputConfig)
      : undefined;
    message.documentOutputConfig = (object.documentOutputConfig !== undefined && object.documentOutputConfig !== null)
      ? DocumentOutputConfig.fromPartial(object.documentOutputConfig)
      : undefined;
    message.model = object.model ?? "";
    message.glossaryConfig = (object.glossaryConfig !== undefined && object.glossaryConfig !== null)
      ? TranslateTextGlossaryConfig.fromPartial(object.glossaryConfig)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.customizedAttribution = object.customizedAttribution ?? "";
    message.isTranslateNativePdfOnly = object.isTranslateNativePdfOnly ?? false;
    message.enableShadowRemovalNativePdf = object.enableShadowRemovalNativePdf ?? false;
    message.enableRotationCorrection = object.enableRotationCorrection ?? false;
    return message;
  },
};

function createBaseTranslateDocumentRequest_LabelsEntry(): TranslateDocumentRequest_LabelsEntry {
  return { key: "", value: "" };
}

export const TranslateDocumentRequest_LabelsEntry: MessageFns<TranslateDocumentRequest_LabelsEntry> = {
  encode(message: TranslateDocumentRequest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateDocumentRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateDocumentRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateDocumentRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TranslateDocumentRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateDocumentRequest_LabelsEntry>): TranslateDocumentRequest_LabelsEntry {
    return TranslateDocumentRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateDocumentRequest_LabelsEntry>): TranslateDocumentRequest_LabelsEntry {
    const message = createBaseTranslateDocumentRequest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDocumentTranslation(): DocumentTranslation {
  return { byteStreamOutputs: [], mimeType: "", detectedLanguageCode: "" };
}

export const DocumentTranslation: MessageFns<DocumentTranslation> = {
  encode(message: DocumentTranslation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.byteStreamOutputs) {
      writer.uint32(10).bytes(v!);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.detectedLanguageCode !== "") {
      writer.uint32(26).string(message.detectedLanguageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentTranslation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentTranslation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.byteStreamOutputs.push(Buffer.from(reader.bytes()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedLanguageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentTranslation {
    return {
      byteStreamOutputs: globalThis.Array.isArray(object?.byteStreamOutputs)
        ? object.byteStreamOutputs.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      detectedLanguageCode: isSet(object.detectedLanguageCode) ? globalThis.String(object.detectedLanguageCode) : "",
    };
  },

  toJSON(message: DocumentTranslation): unknown {
    const obj: any = {};
    if (message.byteStreamOutputs?.length) {
      obj.byteStreamOutputs = message.byteStreamOutputs.map((e) => base64FromBytes(e));
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.detectedLanguageCode !== "") {
      obj.detectedLanguageCode = message.detectedLanguageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentTranslation>): DocumentTranslation {
    return DocumentTranslation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentTranslation>): DocumentTranslation {
    const message = createBaseDocumentTranslation();
    message.byteStreamOutputs = object.byteStreamOutputs?.map((e) => e) || [];
    message.mimeType = object.mimeType ?? "";
    message.detectedLanguageCode = object.detectedLanguageCode ?? "";
    return message;
  },
};

function createBaseTranslateDocumentResponse(): TranslateDocumentResponse {
  return {
    documentTranslation: undefined,
    glossaryDocumentTranslation: undefined,
    model: "",
    glossaryConfig: undefined,
  };
}

export const TranslateDocumentResponse: MessageFns<TranslateDocumentResponse> = {
  encode(message: TranslateDocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.documentTranslation !== undefined) {
      DocumentTranslation.encode(message.documentTranslation, writer.uint32(10).fork()).join();
    }
    if (message.glossaryDocumentTranslation !== undefined) {
      DocumentTranslation.encode(message.glossaryDocumentTranslation, writer.uint32(18).fork()).join();
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    if (message.glossaryConfig !== undefined) {
      TranslateTextGlossaryConfig.encode(message.glossaryConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranslateDocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranslateDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentTranslation = DocumentTranslation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.glossaryDocumentTranslation = DocumentTranslation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.glossaryConfig = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranslateDocumentResponse {
    return {
      documentTranslation: isSet(object.documentTranslation)
        ? DocumentTranslation.fromJSON(object.documentTranslation)
        : undefined,
      glossaryDocumentTranslation: isSet(object.glossaryDocumentTranslation)
        ? DocumentTranslation.fromJSON(object.glossaryDocumentTranslation)
        : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      glossaryConfig: isSet(object.glossaryConfig)
        ? TranslateTextGlossaryConfig.fromJSON(object.glossaryConfig)
        : undefined,
    };
  },

  toJSON(message: TranslateDocumentResponse): unknown {
    const obj: any = {};
    if (message.documentTranslation !== undefined) {
      obj.documentTranslation = DocumentTranslation.toJSON(message.documentTranslation);
    }
    if (message.glossaryDocumentTranslation !== undefined) {
      obj.glossaryDocumentTranslation = DocumentTranslation.toJSON(message.glossaryDocumentTranslation);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.glossaryConfig !== undefined) {
      obj.glossaryConfig = TranslateTextGlossaryConfig.toJSON(message.glossaryConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<TranslateDocumentResponse>): TranslateDocumentResponse {
    return TranslateDocumentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranslateDocumentResponse>): TranslateDocumentResponse {
    const message = createBaseTranslateDocumentResponse();
    message.documentTranslation = (object.documentTranslation !== undefined && object.documentTranslation !== null)
      ? DocumentTranslation.fromPartial(object.documentTranslation)
      : undefined;
    message.glossaryDocumentTranslation =
      (object.glossaryDocumentTranslation !== undefined && object.glossaryDocumentTranslation !== null)
        ? DocumentTranslation.fromPartial(object.glossaryDocumentTranslation)
        : undefined;
    message.model = object.model ?? "";
    message.glossaryConfig = (object.glossaryConfig !== undefined && object.glossaryConfig !== null)
      ? TranslateTextGlossaryConfig.fromPartial(object.glossaryConfig)
      : undefined;
    return message;
  },
};

function createBaseBatchTranslateTextRequest(): BatchTranslateTextRequest {
  return {
    parent: "",
    sourceLanguageCode: "",
    targetLanguageCodes: [],
    models: {},
    inputConfigs: [],
    outputConfig: undefined,
    glossaries: {},
    labels: {},
  };
}

export const BatchTranslateTextRequest: MessageFns<BatchTranslateTextRequest> = {
  encode(message: BatchTranslateTextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(18).string(message.sourceLanguageCode);
    }
    for (const v of message.targetLanguageCodes) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.models).forEach(([key, value]) => {
      BatchTranslateTextRequest_ModelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.inputConfigs) {
      InputConfig.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(50).fork()).join();
    }
    Object.entries(message.glossaries).forEach(([key, value]) => {
      BatchTranslateTextRequest_GlossariesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.labels).forEach(([key, value]) => {
      BatchTranslateTextRequest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateTextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetLanguageCodes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BatchTranslateTextRequest_ModelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.models[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputConfigs.push(InputConfig.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = BatchTranslateTextRequest_GlossariesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.glossaries[entry7.key] = entry7.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = BatchTranslateTextRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateTextRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCodes: globalThis.Array.isArray(object?.targetLanguageCodes)
        ? object.targetLanguageCodes.map((e: any) => globalThis.String(e))
        : [],
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      inputConfigs: globalThis.Array.isArray(object?.inputConfigs)
        ? object.inputConfigs.map((e: any) => InputConfig.fromJSON(e))
        : [],
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
      glossaries: isObject(object.glossaries)
        ? Object.entries(object.glossaries).reduce<{ [key: string]: TranslateTextGlossaryConfig }>(
          (acc, [key, value]) => {
            acc[key] = TranslateTextGlossaryConfig.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BatchTranslateTextRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCodes?.length) {
      obj.targetLanguageCodes = message.targetLanguageCodes;
    }
    if (message.models) {
      const entries = Object.entries(message.models);
      if (entries.length > 0) {
        obj.models = {};
        entries.forEach(([k, v]) => {
          obj.models[k] = v;
        });
      }
    }
    if (message.inputConfigs?.length) {
      obj.inputConfigs = message.inputConfigs.map((e) => InputConfig.toJSON(e));
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    if (message.glossaries) {
      const entries = Object.entries(message.glossaries);
      if (entries.length > 0) {
        obj.glossaries = {};
        entries.forEach(([k, v]) => {
          obj.glossaries[k] = TranslateTextGlossaryConfig.toJSON(v);
        });
      }
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateTextRequest>): BatchTranslateTextRequest {
    return BatchTranslateTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateTextRequest>): BatchTranslateTextRequest {
    const message = createBaseBatchTranslateTextRequest();
    message.parent = object.parent ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCodes = object.targetLanguageCodes?.map((e) => e) || [];
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.inputConfigs = object.inputConfigs?.map((e) => InputConfig.fromPartial(e)) || [];
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.glossaries = Object.entries(object.glossaries ?? {}).reduce<{ [key: string]: TranslateTextGlossaryConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TranslateTextGlossaryConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBatchTranslateTextRequest_ModelsEntry(): BatchTranslateTextRequest_ModelsEntry {
  return { key: "", value: "" };
}

export const BatchTranslateTextRequest_ModelsEntry: MessageFns<BatchTranslateTextRequest_ModelsEntry> = {
  encode(message: BatchTranslateTextRequest_ModelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateTextRequest_ModelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateTextRequest_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateTextRequest_ModelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchTranslateTextRequest_ModelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateTextRequest_ModelsEntry>): BatchTranslateTextRequest_ModelsEntry {
    return BatchTranslateTextRequest_ModelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateTextRequest_ModelsEntry>): BatchTranslateTextRequest_ModelsEntry {
    const message = createBaseBatchTranslateTextRequest_ModelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBatchTranslateTextRequest_GlossariesEntry(): BatchTranslateTextRequest_GlossariesEntry {
  return { key: "", value: undefined };
}

export const BatchTranslateTextRequest_GlossariesEntry: MessageFns<BatchTranslateTextRequest_GlossariesEntry> = {
  encode(message: BatchTranslateTextRequest_GlossariesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TranslateTextGlossaryConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateTextRequest_GlossariesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateTextRequest_GlossariesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateTextRequest_GlossariesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TranslateTextGlossaryConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BatchTranslateTextRequest_GlossariesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TranslateTextGlossaryConfig.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateTextRequest_GlossariesEntry>): BatchTranslateTextRequest_GlossariesEntry {
    return BatchTranslateTextRequest_GlossariesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchTranslateTextRequest_GlossariesEntry>,
  ): BatchTranslateTextRequest_GlossariesEntry {
    const message = createBaseBatchTranslateTextRequest_GlossariesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TranslateTextGlossaryConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBatchTranslateTextRequest_LabelsEntry(): BatchTranslateTextRequest_LabelsEntry {
  return { key: "", value: "" };
}

export const BatchTranslateTextRequest_LabelsEntry: MessageFns<BatchTranslateTextRequest_LabelsEntry> = {
  encode(message: BatchTranslateTextRequest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateTextRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateTextRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateTextRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchTranslateTextRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateTextRequest_LabelsEntry>): BatchTranslateTextRequest_LabelsEntry {
    return BatchTranslateTextRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateTextRequest_LabelsEntry>): BatchTranslateTextRequest_LabelsEntry {
    const message = createBaseBatchTranslateTextRequest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBatchTranslateMetadata(): BatchTranslateMetadata {
  return {
    state: 0,
    translatedCharacters: Long.ZERO,
    failedCharacters: Long.ZERO,
    totalCharacters: Long.ZERO,
    submitTime: undefined,
  };
}

export const BatchTranslateMetadata: MessageFns<BatchTranslateMetadata> = {
  encode(message: BatchTranslateMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.translatedCharacters.toString());
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.failedCharacters.toString());
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalCharacters.toString());
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.translatedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateMetadata {
    return {
      state: isSet(object.state) ? batchTranslateMetadata_StateFromJSON(object.state) : 0,
      translatedCharacters: isSet(object.translatedCharacters)
        ? Long.fromValue(object.translatedCharacters)
        : Long.ZERO,
      failedCharacters: isSet(object.failedCharacters) ? Long.fromValue(object.failedCharacters) : Long.ZERO,
      totalCharacters: isSet(object.totalCharacters) ? Long.fromValue(object.totalCharacters) : Long.ZERO,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
    };
  },

  toJSON(message: BatchTranslateMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = batchTranslateMetadata_StateToJSON(message.state);
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      obj.translatedCharacters = (message.translatedCharacters || Long.ZERO).toString();
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      obj.failedCharacters = (message.failedCharacters || Long.ZERO).toString();
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      obj.totalCharacters = (message.totalCharacters || Long.ZERO).toString();
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateMetadata>): BatchTranslateMetadata {
    return BatchTranslateMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateMetadata>): BatchTranslateMetadata {
    const message = createBaseBatchTranslateMetadata();
    message.state = object.state ?? 0;
    message.translatedCharacters = (object.translatedCharacters !== undefined && object.translatedCharacters !== null)
      ? Long.fromValue(object.translatedCharacters)
      : Long.ZERO;
    message.failedCharacters = (object.failedCharacters !== undefined && object.failedCharacters !== null)
      ? Long.fromValue(object.failedCharacters)
      : Long.ZERO;
    message.totalCharacters = (object.totalCharacters !== undefined && object.totalCharacters !== null)
      ? Long.fromValue(object.totalCharacters)
      : Long.ZERO;
    message.submitTime = object.submitTime ?? undefined;
    return message;
  },
};

function createBaseBatchTranslateResponse(): BatchTranslateResponse {
  return {
    totalCharacters: Long.ZERO,
    translatedCharacters: Long.ZERO,
    failedCharacters: Long.ZERO,
    submitTime: undefined,
    endTime: undefined,
  };
}

export const BatchTranslateResponse: MessageFns<BatchTranslateResponse> = {
  encode(message: BatchTranslateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalCharacters.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalCharacters.toString());
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.translatedCharacters.toString());
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.failedCharacters.toString());
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.translatedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateResponse {
    return {
      totalCharacters: isSet(object.totalCharacters) ? Long.fromValue(object.totalCharacters) : Long.ZERO,
      translatedCharacters: isSet(object.translatedCharacters)
        ? Long.fromValue(object.translatedCharacters)
        : Long.ZERO,
      failedCharacters: isSet(object.failedCharacters) ? Long.fromValue(object.failedCharacters) : Long.ZERO,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: BatchTranslateResponse): unknown {
    const obj: any = {};
    if (!message.totalCharacters.equals(Long.ZERO)) {
      obj.totalCharacters = (message.totalCharacters || Long.ZERO).toString();
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      obj.translatedCharacters = (message.translatedCharacters || Long.ZERO).toString();
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      obj.failedCharacters = (message.failedCharacters || Long.ZERO).toString();
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateResponse>): BatchTranslateResponse {
    return BatchTranslateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateResponse>): BatchTranslateResponse {
    const message = createBaseBatchTranslateResponse();
    message.totalCharacters = (object.totalCharacters !== undefined && object.totalCharacters !== null)
      ? Long.fromValue(object.totalCharacters)
      : Long.ZERO;
    message.translatedCharacters = (object.translatedCharacters !== undefined && object.translatedCharacters !== null)
      ? Long.fromValue(object.translatedCharacters)
      : Long.ZERO;
    message.failedCharacters = (object.failedCharacters !== undefined && object.failedCharacters !== null)
      ? Long.fromValue(object.failedCharacters)
      : Long.ZERO;
    message.submitTime = object.submitTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseGlossaryInputConfig(): GlossaryInputConfig {
  return { gcsSource: undefined };
}

export const GlossaryInputConfig: MessageFns<GlossaryInputConfig> = {
  encode(message: GlossaryInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlossaryInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlossaryInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlossaryInputConfig {
    return { gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined };
  },

  toJSON(message: GlossaryInputConfig): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<GlossaryInputConfig>): GlossaryInputConfig {
    return GlossaryInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GlossaryInputConfig>): GlossaryInputConfig {
    const message = createBaseGlossaryInputConfig();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    return message;
  },
};

function createBaseGlossary(): Glossary {
  return {
    name: "",
    languagePair: undefined,
    languageCodesSet: undefined,
    inputConfig: undefined,
    entryCount: 0,
    submitTime: undefined,
    endTime: undefined,
  };
}

export const Glossary: MessageFns<Glossary> = {
  encode(message: Glossary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.languagePair !== undefined) {
      Glossary_LanguageCodePair.encode(message.languagePair, writer.uint32(26).fork()).join();
    }
    if (message.languageCodesSet !== undefined) {
      Glossary_LanguageCodesSet.encode(message.languageCodesSet, writer.uint32(34).fork()).join();
    }
    if (message.inputConfig !== undefined) {
      GlossaryInputConfig.encode(message.inputConfig, writer.uint32(42).fork()).join();
    }
    if (message.entryCount !== 0) {
      writer.uint32(48).int32(message.entryCount);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(58).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Glossary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlossary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languagePair = Glossary_LanguageCodePair.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCodesSet = Glossary_LanguageCodesSet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputConfig = GlossaryInputConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.entryCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Glossary {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      languagePair: isSet(object.languagePair) ? Glossary_LanguageCodePair.fromJSON(object.languagePair) : undefined,
      languageCodesSet: isSet(object.languageCodesSet)
        ? Glossary_LanguageCodesSet.fromJSON(object.languageCodesSet)
        : undefined,
      inputConfig: isSet(object.inputConfig) ? GlossaryInputConfig.fromJSON(object.inputConfig) : undefined,
      entryCount: isSet(object.entryCount) ? globalThis.Number(object.entryCount) : 0,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Glossary): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.languagePair !== undefined) {
      obj.languagePair = Glossary_LanguageCodePair.toJSON(message.languagePair);
    }
    if (message.languageCodesSet !== undefined) {
      obj.languageCodesSet = Glossary_LanguageCodesSet.toJSON(message.languageCodesSet);
    }
    if (message.inputConfig !== undefined) {
      obj.inputConfig = GlossaryInputConfig.toJSON(message.inputConfig);
    }
    if (message.entryCount !== 0) {
      obj.entryCount = Math.round(message.entryCount);
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Glossary>): Glossary {
    return Glossary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Glossary>): Glossary {
    const message = createBaseGlossary();
    message.name = object.name ?? "";
    message.languagePair = (object.languagePair !== undefined && object.languagePair !== null)
      ? Glossary_LanguageCodePair.fromPartial(object.languagePair)
      : undefined;
    message.languageCodesSet = (object.languageCodesSet !== undefined && object.languageCodesSet !== null)
      ? Glossary_LanguageCodesSet.fromPartial(object.languageCodesSet)
      : undefined;
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? GlossaryInputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.entryCount = object.entryCount ?? 0;
    message.submitTime = object.submitTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseGlossary_LanguageCodePair(): Glossary_LanguageCodePair {
  return { sourceLanguageCode: "", targetLanguageCode: "" };
}

export const Glossary_LanguageCodePair: MessageFns<Glossary_LanguageCodePair> = {
  encode(message: Glossary_LanguageCodePair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceLanguageCode !== "") {
      writer.uint32(10).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(18).string(message.targetLanguageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Glossary_LanguageCodePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlossary_LanguageCodePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Glossary_LanguageCodePair {
    return {
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
    };
  },

  toJSON(message: Glossary_LanguageCodePair): unknown {
    const obj: any = {};
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Glossary_LanguageCodePair>): Glossary_LanguageCodePair {
    return Glossary_LanguageCodePair.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Glossary_LanguageCodePair>): Glossary_LanguageCodePair {
    const message = createBaseGlossary_LanguageCodePair();
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    return message;
  },
};

function createBaseGlossary_LanguageCodesSet(): Glossary_LanguageCodesSet {
  return { languageCodes: [] };
}

export const Glossary_LanguageCodesSet: MessageFns<Glossary_LanguageCodesSet> = {
  encode(message: Glossary_LanguageCodesSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languageCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Glossary_LanguageCodesSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlossary_LanguageCodesSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Glossary_LanguageCodesSet {
    return {
      languageCodes: globalThis.Array.isArray(object?.languageCodes)
        ? object.languageCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Glossary_LanguageCodesSet): unknown {
    const obj: any = {};
    if (message.languageCodes?.length) {
      obj.languageCodes = message.languageCodes;
    }
    return obj;
  },

  create(base?: DeepPartial<Glossary_LanguageCodesSet>): Glossary_LanguageCodesSet {
    return Glossary_LanguageCodesSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Glossary_LanguageCodesSet>): Glossary_LanguageCodesSet {
    const message = createBaseGlossary_LanguageCodesSet();
    message.languageCodes = object.languageCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateGlossaryRequest(): CreateGlossaryRequest {
  return { parent: "", glossary: undefined };
}

export const CreateGlossaryRequest: MessageFns<CreateGlossaryRequest> = {
  encode(message: CreateGlossaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.glossary !== undefined) {
      Glossary.encode(message.glossary, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGlossaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGlossaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.glossary = Glossary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGlossaryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      glossary: isSet(object.glossary) ? Glossary.fromJSON(object.glossary) : undefined,
    };
  },

  toJSON(message: CreateGlossaryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.glossary !== undefined) {
      obj.glossary = Glossary.toJSON(message.glossary);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGlossaryRequest>): CreateGlossaryRequest {
    return CreateGlossaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGlossaryRequest>): CreateGlossaryRequest {
    const message = createBaseCreateGlossaryRequest();
    message.parent = object.parent ?? "";
    message.glossary = (object.glossary !== undefined && object.glossary !== null)
      ? Glossary.fromPartial(object.glossary)
      : undefined;
    return message;
  },
};

function createBaseGetGlossaryRequest(): GetGlossaryRequest {
  return { name: "" };
}

export const GetGlossaryRequest: MessageFns<GetGlossaryRequest> = {
  encode(message: GetGlossaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlossaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlossaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlossaryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGlossaryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGlossaryRequest>): GetGlossaryRequest {
    return GetGlossaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGlossaryRequest>): GetGlossaryRequest {
    const message = createBaseGetGlossaryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteGlossaryRequest(): DeleteGlossaryRequest {
  return { name: "" };
}

export const DeleteGlossaryRequest: MessageFns<DeleteGlossaryRequest> = {
  encode(message: DeleteGlossaryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGlossaryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGlossaryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGlossaryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteGlossaryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGlossaryRequest>): DeleteGlossaryRequest {
    return DeleteGlossaryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGlossaryRequest>): DeleteGlossaryRequest {
    const message = createBaseDeleteGlossaryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListGlossariesRequest(): ListGlossariesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListGlossariesRequest: MessageFns<ListGlossariesRequest> = {
  encode(message: ListGlossariesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGlossariesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGlossariesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGlossariesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListGlossariesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGlossariesRequest>): ListGlossariesRequest {
    return ListGlossariesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGlossariesRequest>): ListGlossariesRequest {
    const message = createBaseListGlossariesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListGlossariesResponse(): ListGlossariesResponse {
  return { glossaries: [], nextPageToken: "" };
}

export const ListGlossariesResponse: MessageFns<ListGlossariesResponse> = {
  encode(message: ListGlossariesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.glossaries) {
      Glossary.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGlossariesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGlossariesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.glossaries.push(Glossary.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGlossariesResponse {
    return {
      glossaries: globalThis.Array.isArray(object?.glossaries)
        ? object.glossaries.map((e: any) => Glossary.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListGlossariesResponse): unknown {
    const obj: any = {};
    if (message.glossaries?.length) {
      obj.glossaries = message.glossaries.map((e) => Glossary.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGlossariesResponse>): ListGlossariesResponse {
    return ListGlossariesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGlossariesResponse>): ListGlossariesResponse {
    const message = createBaseListGlossariesResponse();
    message.glossaries = object.glossaries?.map((e) => Glossary.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateGlossaryMetadata(): CreateGlossaryMetadata {
  return { name: "", state: 0, submitTime: undefined };
}

export const CreateGlossaryMetadata: MessageFns<CreateGlossaryMetadata> = {
  encode(message: CreateGlossaryMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGlossaryMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGlossaryMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGlossaryMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? createGlossaryMetadata_StateFromJSON(object.state) : 0,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
    };
  },

  toJSON(message: CreateGlossaryMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = createGlossaryMetadata_StateToJSON(message.state);
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGlossaryMetadata>): CreateGlossaryMetadata {
    return CreateGlossaryMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGlossaryMetadata>): CreateGlossaryMetadata {
    const message = createBaseCreateGlossaryMetadata();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.submitTime = object.submitTime ?? undefined;
    return message;
  },
};

function createBaseDeleteGlossaryMetadata(): DeleteGlossaryMetadata {
  return { name: "", state: 0, submitTime: undefined };
}

export const DeleteGlossaryMetadata: MessageFns<DeleteGlossaryMetadata> = {
  encode(message: DeleteGlossaryMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGlossaryMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGlossaryMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGlossaryMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? deleteGlossaryMetadata_StateFromJSON(object.state) : 0,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
    };
  },

  toJSON(message: DeleteGlossaryMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = deleteGlossaryMetadata_StateToJSON(message.state);
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGlossaryMetadata>): DeleteGlossaryMetadata {
    return DeleteGlossaryMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGlossaryMetadata>): DeleteGlossaryMetadata {
    const message = createBaseDeleteGlossaryMetadata();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.submitTime = object.submitTime ?? undefined;
    return message;
  },
};

function createBaseDeleteGlossaryResponse(): DeleteGlossaryResponse {
  return { name: "", submitTime: undefined, endTime: undefined };
}

export const DeleteGlossaryResponse: MessageFns<DeleteGlossaryResponse> = {
  encode(message: DeleteGlossaryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGlossaryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGlossaryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGlossaryResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: DeleteGlossaryResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGlossaryResponse>): DeleteGlossaryResponse {
    return DeleteGlossaryResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGlossaryResponse>): DeleteGlossaryResponse {
    const message = createBaseDeleteGlossaryResponse();
    message.name = object.name ?? "";
    message.submitTime = object.submitTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseBatchTranslateDocumentRequest(): BatchTranslateDocumentRequest {
  return {
    parent: "",
    sourceLanguageCode: "",
    targetLanguageCodes: [],
    inputConfigs: [],
    outputConfig: undefined,
    models: {},
    glossaries: {},
    formatConversions: {},
    customizedAttribution: "",
    enableShadowRemovalNativePdf: false,
    enableRotationCorrection: false,
  };
}

export const BatchTranslateDocumentRequest: MessageFns<BatchTranslateDocumentRequest> = {
  encode(message: BatchTranslateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(18).string(message.sourceLanguageCode);
    }
    for (const v of message.targetLanguageCodes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.inputConfigs) {
      BatchDocumentInputConfig.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      BatchDocumentOutputConfig.encode(message.outputConfig, writer.uint32(42).fork()).join();
    }
    Object.entries(message.models).forEach(([key, value]) => {
      BatchTranslateDocumentRequest_ModelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.glossaries).forEach(([key, value]) => {
      BatchTranslateDocumentRequest_GlossariesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    Object.entries(message.formatConversions).forEach(([key, value]) => {
      BatchTranslateDocumentRequest_FormatConversionsEntry.encode({ key: key as any, value }, writer.uint32(66).fork())
        .join();
    });
    if (message.customizedAttribution !== "") {
      writer.uint32(82).string(message.customizedAttribution);
    }
    if (message.enableShadowRemovalNativePdf !== false) {
      writer.uint32(88).bool(message.enableShadowRemovalNativePdf);
    }
    if (message.enableRotationCorrection !== false) {
      writer.uint32(96).bool(message.enableRotationCorrection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetLanguageCodes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputConfigs.push(BatchDocumentInputConfig.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.outputConfig = BatchDocumentOutputConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = BatchTranslateDocumentRequest_ModelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.models[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = BatchTranslateDocumentRequest_GlossariesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.glossaries[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = BatchTranslateDocumentRequest_FormatConversionsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.formatConversions[entry8.key] = entry8.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.customizedAttribution = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableShadowRemovalNativePdf = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableRotationCorrection = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateDocumentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCodes: globalThis.Array.isArray(object?.targetLanguageCodes)
        ? object.targetLanguageCodes.map((e: any) => globalThis.String(e))
        : [],
      inputConfigs: globalThis.Array.isArray(object?.inputConfigs)
        ? object.inputConfigs.map((e: any) => BatchDocumentInputConfig.fromJSON(e))
        : [],
      outputConfig: isSet(object.outputConfig) ? BatchDocumentOutputConfig.fromJSON(object.outputConfig) : undefined,
      models: isObject(object.models)
        ? Object.entries(object.models).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      glossaries: isObject(object.glossaries)
        ? Object.entries(object.glossaries).reduce<{ [key: string]: TranslateTextGlossaryConfig }>(
          (acc, [key, value]) => {
            acc[key] = TranslateTextGlossaryConfig.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      formatConversions: isObject(object.formatConversions)
        ? Object.entries(object.formatConversions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      customizedAttribution: isSet(object.customizedAttribution) ? globalThis.String(object.customizedAttribution) : "",
      enableShadowRemovalNativePdf: isSet(object.enableShadowRemovalNativePdf)
        ? globalThis.Boolean(object.enableShadowRemovalNativePdf)
        : false,
      enableRotationCorrection: isSet(object.enableRotationCorrection)
        ? globalThis.Boolean(object.enableRotationCorrection)
        : false,
    };
  },

  toJSON(message: BatchTranslateDocumentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCodes?.length) {
      obj.targetLanguageCodes = message.targetLanguageCodes;
    }
    if (message.inputConfigs?.length) {
      obj.inputConfigs = message.inputConfigs.map((e) => BatchDocumentInputConfig.toJSON(e));
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = BatchDocumentOutputConfig.toJSON(message.outputConfig);
    }
    if (message.models) {
      const entries = Object.entries(message.models);
      if (entries.length > 0) {
        obj.models = {};
        entries.forEach(([k, v]) => {
          obj.models[k] = v;
        });
      }
    }
    if (message.glossaries) {
      const entries = Object.entries(message.glossaries);
      if (entries.length > 0) {
        obj.glossaries = {};
        entries.forEach(([k, v]) => {
          obj.glossaries[k] = TranslateTextGlossaryConfig.toJSON(v);
        });
      }
    }
    if (message.formatConversions) {
      const entries = Object.entries(message.formatConversions);
      if (entries.length > 0) {
        obj.formatConversions = {};
        entries.forEach(([k, v]) => {
          obj.formatConversions[k] = v;
        });
      }
    }
    if (message.customizedAttribution !== "") {
      obj.customizedAttribution = message.customizedAttribution;
    }
    if (message.enableShadowRemovalNativePdf !== false) {
      obj.enableShadowRemovalNativePdf = message.enableShadowRemovalNativePdf;
    }
    if (message.enableRotationCorrection !== false) {
      obj.enableRotationCorrection = message.enableRotationCorrection;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateDocumentRequest>): BatchTranslateDocumentRequest {
    return BatchTranslateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateDocumentRequest>): BatchTranslateDocumentRequest {
    const message = createBaseBatchTranslateDocumentRequest();
    message.parent = object.parent ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCodes = object.targetLanguageCodes?.map((e) => e) || [];
    message.inputConfigs = object.inputConfigs?.map((e) => BatchDocumentInputConfig.fromPartial(e)) || [];
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? BatchDocumentOutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.models = Object.entries(object.models ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.glossaries = Object.entries(object.glossaries ?? {}).reduce<{ [key: string]: TranslateTextGlossaryConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TranslateTextGlossaryConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.formatConversions = Object.entries(object.formatConversions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.customizedAttribution = object.customizedAttribution ?? "";
    message.enableShadowRemovalNativePdf = object.enableShadowRemovalNativePdf ?? false;
    message.enableRotationCorrection = object.enableRotationCorrection ?? false;
    return message;
  },
};

function createBaseBatchTranslateDocumentRequest_ModelsEntry(): BatchTranslateDocumentRequest_ModelsEntry {
  return { key: "", value: "" };
}

export const BatchTranslateDocumentRequest_ModelsEntry: MessageFns<BatchTranslateDocumentRequest_ModelsEntry> = {
  encode(message: BatchTranslateDocumentRequest_ModelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentRequest_ModelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateDocumentRequest_ModelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateDocumentRequest_ModelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchTranslateDocumentRequest_ModelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateDocumentRequest_ModelsEntry>): BatchTranslateDocumentRequest_ModelsEntry {
    return BatchTranslateDocumentRequest_ModelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchTranslateDocumentRequest_ModelsEntry>,
  ): BatchTranslateDocumentRequest_ModelsEntry {
    const message = createBaseBatchTranslateDocumentRequest_ModelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBatchTranslateDocumentRequest_GlossariesEntry(): BatchTranslateDocumentRequest_GlossariesEntry {
  return { key: "", value: undefined };
}

export const BatchTranslateDocumentRequest_GlossariesEntry: MessageFns<BatchTranslateDocumentRequest_GlossariesEntry> =
  {
    encode(
      message: BatchTranslateDocumentRequest_GlossariesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        TranslateTextGlossaryConfig.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentRequest_GlossariesEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBatchTranslateDocumentRequest_GlossariesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = TranslateTextGlossaryConfig.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BatchTranslateDocumentRequest_GlossariesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? TranslateTextGlossaryConfig.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: BatchTranslateDocumentRequest_GlossariesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = TranslateTextGlossaryConfig.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<BatchTranslateDocumentRequest_GlossariesEntry>,
    ): BatchTranslateDocumentRequest_GlossariesEntry {
      return BatchTranslateDocumentRequest_GlossariesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<BatchTranslateDocumentRequest_GlossariesEntry>,
    ): BatchTranslateDocumentRequest_GlossariesEntry {
      const message = createBaseBatchTranslateDocumentRequest_GlossariesEntry();
      message.key = object.key ?? "";
      message.value = (object.value !== undefined && object.value !== null)
        ? TranslateTextGlossaryConfig.fromPartial(object.value)
        : undefined;
      return message;
    },
  };

function createBaseBatchTranslateDocumentRequest_FormatConversionsEntry(): BatchTranslateDocumentRequest_FormatConversionsEntry {
  return { key: "", value: "" };
}

export const BatchTranslateDocumentRequest_FormatConversionsEntry: MessageFns<
  BatchTranslateDocumentRequest_FormatConversionsEntry
> = {
  encode(
    message: BatchTranslateDocumentRequest_FormatConversionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentRequest_FormatConversionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateDocumentRequest_FormatConversionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateDocumentRequest_FormatConversionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BatchTranslateDocumentRequest_FormatConversionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchTranslateDocumentRequest_FormatConversionsEntry>,
  ): BatchTranslateDocumentRequest_FormatConversionsEntry {
    return BatchTranslateDocumentRequest_FormatConversionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchTranslateDocumentRequest_FormatConversionsEntry>,
  ): BatchTranslateDocumentRequest_FormatConversionsEntry {
    const message = createBaseBatchTranslateDocumentRequest_FormatConversionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBatchDocumentInputConfig(): BatchDocumentInputConfig {
  return { gcsSource: undefined };
}

export const BatchDocumentInputConfig: MessageFns<BatchDocumentInputConfig> = {
  encode(message: BatchDocumentInputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDocumentInputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDocumentInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDocumentInputConfig {
    return { gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined };
  },

  toJSON(message: BatchDocumentInputConfig): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDocumentInputConfig>): BatchDocumentInputConfig {
    return BatchDocumentInputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDocumentInputConfig>): BatchDocumentInputConfig {
    const message = createBaseBatchDocumentInputConfig();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    return message;
  },
};

function createBaseBatchDocumentOutputConfig(): BatchDocumentOutputConfig {
  return { gcsDestination: undefined };
}

export const BatchDocumentOutputConfig: MessageFns<BatchDocumentOutputConfig> = {
  encode(message: BatchDocumentOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDocumentOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDocumentOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDocumentOutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsDestination.fromJSON(object.gcsDestination) : undefined,
    };
  },

  toJSON(message: BatchDocumentOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsDestination.toJSON(message.gcsDestination);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDocumentOutputConfig>): BatchDocumentOutputConfig {
    return BatchDocumentOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDocumentOutputConfig>): BatchDocumentOutputConfig {
    const message = createBaseBatchDocumentOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsDestination.fromPartial(object.gcsDestination)
      : undefined;
    return message;
  },
};

function createBaseBatchTranslateDocumentResponse(): BatchTranslateDocumentResponse {
  return {
    totalPages: Long.ZERO,
    translatedPages: Long.ZERO,
    failedPages: Long.ZERO,
    totalBillablePages: Long.ZERO,
    totalCharacters: Long.ZERO,
    translatedCharacters: Long.ZERO,
    failedCharacters: Long.ZERO,
    totalBillableCharacters: Long.ZERO,
    submitTime: undefined,
    endTime: undefined,
  };
}

export const BatchTranslateDocumentResponse: MessageFns<BatchTranslateDocumentResponse> = {
  encode(message: BatchTranslateDocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalPages.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalPages.toString());
    }
    if (!message.translatedPages.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.translatedPages.toString());
    }
    if (!message.failedPages.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.failedPages.toString());
    }
    if (!message.totalBillablePages.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalBillablePages.toString());
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalCharacters.toString());
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.translatedCharacters.toString());
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.failedCharacters.toString());
    }
    if (!message.totalBillableCharacters.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.totalBillableCharacters.toString());
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(74).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalPages = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.translatedPages = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedPages = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalBillablePages = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.translatedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.failedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.totalBillableCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateDocumentResponse {
    return {
      totalPages: isSet(object.totalPages) ? Long.fromValue(object.totalPages) : Long.ZERO,
      translatedPages: isSet(object.translatedPages) ? Long.fromValue(object.translatedPages) : Long.ZERO,
      failedPages: isSet(object.failedPages) ? Long.fromValue(object.failedPages) : Long.ZERO,
      totalBillablePages: isSet(object.totalBillablePages) ? Long.fromValue(object.totalBillablePages) : Long.ZERO,
      totalCharacters: isSet(object.totalCharacters) ? Long.fromValue(object.totalCharacters) : Long.ZERO,
      translatedCharacters: isSet(object.translatedCharacters)
        ? Long.fromValue(object.translatedCharacters)
        : Long.ZERO,
      failedCharacters: isSet(object.failedCharacters) ? Long.fromValue(object.failedCharacters) : Long.ZERO,
      totalBillableCharacters: isSet(object.totalBillableCharacters)
        ? Long.fromValue(object.totalBillableCharacters)
        : Long.ZERO,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: BatchTranslateDocumentResponse): unknown {
    const obj: any = {};
    if (!message.totalPages.equals(Long.ZERO)) {
      obj.totalPages = (message.totalPages || Long.ZERO).toString();
    }
    if (!message.translatedPages.equals(Long.ZERO)) {
      obj.translatedPages = (message.translatedPages || Long.ZERO).toString();
    }
    if (!message.failedPages.equals(Long.ZERO)) {
      obj.failedPages = (message.failedPages || Long.ZERO).toString();
    }
    if (!message.totalBillablePages.equals(Long.ZERO)) {
      obj.totalBillablePages = (message.totalBillablePages || Long.ZERO).toString();
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      obj.totalCharacters = (message.totalCharacters || Long.ZERO).toString();
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      obj.translatedCharacters = (message.translatedCharacters || Long.ZERO).toString();
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      obj.failedCharacters = (message.failedCharacters || Long.ZERO).toString();
    }
    if (!message.totalBillableCharacters.equals(Long.ZERO)) {
      obj.totalBillableCharacters = (message.totalBillableCharacters || Long.ZERO).toString();
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateDocumentResponse>): BatchTranslateDocumentResponse {
    return BatchTranslateDocumentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateDocumentResponse>): BatchTranslateDocumentResponse {
    const message = createBaseBatchTranslateDocumentResponse();
    message.totalPages = (object.totalPages !== undefined && object.totalPages !== null)
      ? Long.fromValue(object.totalPages)
      : Long.ZERO;
    message.translatedPages = (object.translatedPages !== undefined && object.translatedPages !== null)
      ? Long.fromValue(object.translatedPages)
      : Long.ZERO;
    message.failedPages = (object.failedPages !== undefined && object.failedPages !== null)
      ? Long.fromValue(object.failedPages)
      : Long.ZERO;
    message.totalBillablePages = (object.totalBillablePages !== undefined && object.totalBillablePages !== null)
      ? Long.fromValue(object.totalBillablePages)
      : Long.ZERO;
    message.totalCharacters = (object.totalCharacters !== undefined && object.totalCharacters !== null)
      ? Long.fromValue(object.totalCharacters)
      : Long.ZERO;
    message.translatedCharacters = (object.translatedCharacters !== undefined && object.translatedCharacters !== null)
      ? Long.fromValue(object.translatedCharacters)
      : Long.ZERO;
    message.failedCharacters = (object.failedCharacters !== undefined && object.failedCharacters !== null)
      ? Long.fromValue(object.failedCharacters)
      : Long.ZERO;
    message.totalBillableCharacters =
      (object.totalBillableCharacters !== undefined && object.totalBillableCharacters !== null)
        ? Long.fromValue(object.totalBillableCharacters)
        : Long.ZERO;
    message.submitTime = object.submitTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseBatchTranslateDocumentMetadata(): BatchTranslateDocumentMetadata {
  return {
    state: 0,
    totalPages: Long.ZERO,
    translatedPages: Long.ZERO,
    failedPages: Long.ZERO,
    totalBillablePages: Long.ZERO,
    totalCharacters: Long.ZERO,
    translatedCharacters: Long.ZERO,
    failedCharacters: Long.ZERO,
    totalBillableCharacters: Long.ZERO,
    submitTime: undefined,
  };
}

export const BatchTranslateDocumentMetadata: MessageFns<BatchTranslateDocumentMetadata> = {
  encode(message: BatchTranslateDocumentMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (!message.totalPages.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalPages.toString());
    }
    if (!message.translatedPages.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.translatedPages.toString());
    }
    if (!message.failedPages.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.failedPages.toString());
    }
    if (!message.totalBillablePages.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalBillablePages.toString());
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.totalCharacters.toString());
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.translatedCharacters.toString());
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.failedCharacters.toString());
    }
    if (!message.totalBillableCharacters.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.totalBillableCharacters.toString());
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchTranslateDocumentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchTranslateDocumentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalPages = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.translatedPages = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failedPages = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalBillablePages = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.translatedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.failedCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalBillableCharacters = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchTranslateDocumentMetadata {
    return {
      state: isSet(object.state) ? batchTranslateDocumentMetadata_StateFromJSON(object.state) : 0,
      totalPages: isSet(object.totalPages) ? Long.fromValue(object.totalPages) : Long.ZERO,
      translatedPages: isSet(object.translatedPages) ? Long.fromValue(object.translatedPages) : Long.ZERO,
      failedPages: isSet(object.failedPages) ? Long.fromValue(object.failedPages) : Long.ZERO,
      totalBillablePages: isSet(object.totalBillablePages) ? Long.fromValue(object.totalBillablePages) : Long.ZERO,
      totalCharacters: isSet(object.totalCharacters) ? Long.fromValue(object.totalCharacters) : Long.ZERO,
      translatedCharacters: isSet(object.translatedCharacters)
        ? Long.fromValue(object.translatedCharacters)
        : Long.ZERO,
      failedCharacters: isSet(object.failedCharacters) ? Long.fromValue(object.failedCharacters) : Long.ZERO,
      totalBillableCharacters: isSet(object.totalBillableCharacters)
        ? Long.fromValue(object.totalBillableCharacters)
        : Long.ZERO,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
    };
  },

  toJSON(message: BatchTranslateDocumentMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = batchTranslateDocumentMetadata_StateToJSON(message.state);
    }
    if (!message.totalPages.equals(Long.ZERO)) {
      obj.totalPages = (message.totalPages || Long.ZERO).toString();
    }
    if (!message.translatedPages.equals(Long.ZERO)) {
      obj.translatedPages = (message.translatedPages || Long.ZERO).toString();
    }
    if (!message.failedPages.equals(Long.ZERO)) {
      obj.failedPages = (message.failedPages || Long.ZERO).toString();
    }
    if (!message.totalBillablePages.equals(Long.ZERO)) {
      obj.totalBillablePages = (message.totalBillablePages || Long.ZERO).toString();
    }
    if (!message.totalCharacters.equals(Long.ZERO)) {
      obj.totalCharacters = (message.totalCharacters || Long.ZERO).toString();
    }
    if (!message.translatedCharacters.equals(Long.ZERO)) {
      obj.translatedCharacters = (message.translatedCharacters || Long.ZERO).toString();
    }
    if (!message.failedCharacters.equals(Long.ZERO)) {
      obj.failedCharacters = (message.failedCharacters || Long.ZERO).toString();
    }
    if (!message.totalBillableCharacters.equals(Long.ZERO)) {
      obj.totalBillableCharacters = (message.totalBillableCharacters || Long.ZERO).toString();
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BatchTranslateDocumentMetadata>): BatchTranslateDocumentMetadata {
    return BatchTranslateDocumentMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchTranslateDocumentMetadata>): BatchTranslateDocumentMetadata {
    const message = createBaseBatchTranslateDocumentMetadata();
    message.state = object.state ?? 0;
    message.totalPages = (object.totalPages !== undefined && object.totalPages !== null)
      ? Long.fromValue(object.totalPages)
      : Long.ZERO;
    message.translatedPages = (object.translatedPages !== undefined && object.translatedPages !== null)
      ? Long.fromValue(object.translatedPages)
      : Long.ZERO;
    message.failedPages = (object.failedPages !== undefined && object.failedPages !== null)
      ? Long.fromValue(object.failedPages)
      : Long.ZERO;
    message.totalBillablePages = (object.totalBillablePages !== undefined && object.totalBillablePages !== null)
      ? Long.fromValue(object.totalBillablePages)
      : Long.ZERO;
    message.totalCharacters = (object.totalCharacters !== undefined && object.totalCharacters !== null)
      ? Long.fromValue(object.totalCharacters)
      : Long.ZERO;
    message.translatedCharacters = (object.translatedCharacters !== undefined && object.translatedCharacters !== null)
      ? Long.fromValue(object.translatedCharacters)
      : Long.ZERO;
    message.failedCharacters = (object.failedCharacters !== undefined && object.failedCharacters !== null)
      ? Long.fromValue(object.failedCharacters)
      : Long.ZERO;
    message.totalBillableCharacters =
      (object.totalBillableCharacters !== undefined && object.totalBillableCharacters !== null)
        ? Long.fromValue(object.totalBillableCharacters)
        : Long.ZERO;
    message.submitTime = object.submitTime ?? undefined;
    return message;
  },
};

/** Provides natural language translation operations. */
export type TranslationServiceDefinition = typeof TranslationServiceDefinition;
export const TranslationServiceDefinition = {
  name: "TranslationService",
  fullName: "google.cloud.translation.v3beta1.TranslationService",
  methods: {
    /** Translates input text and returns translated text. */
    translateText: {
      name: "TranslateText",
      requestType: TranslateTextRequest,
      requestStream: false,
      responseType: TranslateTextResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              108,
              58,
              1,
              42,
              90,
              47,
              58,
              1,
              42,
              34,
              42,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              84,
              101,
              120,
              116,
              34,
              54,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              84,
              101,
              120,
              116,
            ]),
          ],
        },
      },
    },
    /** Detects the language of text within a request. */
    detectLanguage: {
      name: "DetectLanguage",
      requestType: DetectLanguageRequest,
      requestStream: false,
      responseType: DetectLanguageResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              109,
              111,
              100,
              101,
              108,
              44,
              109,
              105,
              109,
              101,
              95,
              116,
              121,
              112,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              110,
              58,
              1,
              42,
              90,
              48,
              58,
              1,
              42,
              34,
              43,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              116,
              101,
              99,
              116,
              76,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              34,
              55,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              100,
              101,
              116,
              101,
              99,
              116,
              76,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /** Returns a list of supported languages for translation. */
    getSupportedLanguages: {
      name: "GetSupportedLanguages",
      requestType: GetSupportedLanguagesRequest,
      requestStream: false,
      responseType: SupportedLanguages,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              34,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              105,
              115,
              112,
              108,
              97,
              121,
              95,
              108,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              95,
              99,
              111,
              100,
              101,
              44,
              109,
              111,
              100,
              101,
              108,
            ]),
          ],
          578365826: [
            Buffer.from([
              112,
              90,
              49,
              18,
              47,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              112,
              112,
              111,
              114,
              116,
              101,
              100,
              76,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              115,
              18,
              59,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              112,
              112,
              111,
              114,
              116,
              101,
              100,
              76,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Translates documents in synchronous mode. */
    translateDocument: {
      name: "TranslateDocument",
      requestType: TranslateDocumentRequest,
      requestStream: false,
      responseType: TranslateDocumentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              116,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Translates a large volume of text in asynchronous batch mode.
     * This function provides real-time output as the inputs are being processed.
     * If caller cancels a request, the partial results (for an input file, it's
     * all or nothing) may still be available on the specified output location.
     *
     * This call returns immediately and you can
     * use google.longrunning.Operation.name to poll the status of the call.
     */
    batchTranslateText: {
      name: "BatchTranslateText",
      requestType: BatchTranslateTextRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              22,
              66,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              66,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              84,
              101,
              120,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Translates a large volume of document in asynchronous batch mode.
     * This function provides real-time output as the inputs are being processed.
     * If caller cancels a request, the partial results (for an input file, it's
     * all or nothing) may still be available on the specified output location.
     *
     * This call returns immediately and you can use
     * google.longrunning.Operation.name to poll the status of the call.
     */
    batchTranslateDocument: {
      name: "BatchTranslateDocument",
      requestType: BatchTranslateDocumentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              64,
              10,
              30,
              66,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              30,
              66,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              77,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              111,
              117,
              114,
              99,
              101,
              95,
              108,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              95,
              99,
              111,
              100,
              101,
              44,
              116,
              97,
              114,
              103,
              101,
              116,
              95,
              108,
              97,
              110,
              103,
              117,
              97,
              103,
              101,
              95,
              99,
              111,
              100,
              101,
              115,
              44,
              105,
              110,
              112,
              117,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              115,
              44,
              111,
              117,
              116,
              112,
              117,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              98,
              97,
              116,
              99,
              104,
              84,
              114,
              97,
              110,
              115,
              108,
              97,
              116,
              101,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a glossary and returns the long-running operation. Returns
     * NOT_FOUND, if the project doesn't exist.
     */
    createGlossary: {
      name: "CreateGlossary",
      requestType: CreateGlossaryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              8,
              71,
              108,
              111,
              115,
              115,
              97,
              114,
              121,
              18,
              22,
              67,
              114,
              101,
              97,
              116,
              101,
              71,
              108,
              111,
              115,
              115,
              97,
              114,
              121,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 103, 108, 111, 115, 115, 97, 114, 121])],
          578365826: [
            Buffer.from([
              63,
              58,
              8,
              103,
              108,
              111,
              115,
              115,
              97,
              114,
              121,
              34,
              51,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              108,
              111,
              115,
              115,
              97,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists glossaries in a project. Returns NOT_FOUND, if the project doesn't
     * exist.
     */
    listGlossaries: {
      name: "ListGlossaries",
      requestType: ListGlossariesRequest,
      requestStream: false,
      responseType: ListGlossariesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 102, 105, 108, 116, 101, 114])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              108,
              111,
              115,
              115,
              97,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a glossary. Returns NOT_FOUND, if the glossary doesn't
     * exist.
     */
    getGlossary: {
      name: "GetGlossary",
      requestType: GetGlossaryRequest,
      requestStream: false,
      responseType: Glossary,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              108,
              111,
              115,
              115,
              97,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a glossary, or cancels glossary construction
     * if the glossary isn't created yet.
     * Returns NOT_FOUND, if the glossary doesn't exist.
     */
    deleteGlossary: {
      name: "DeleteGlossary",
      requestType: DeleteGlossaryRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              48,
              10,
              22,
              68,
              101,
              108,
              101,
              116,
              101,
              71,
              108,
              111,
              115,
              115,
              97,
              114,
              121,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              22,
              68,
              101,
              108,
              101,
              116,
              101,
              71,
              108,
              111,
              115,
              115,
              97,
              114,
              121,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              51,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              108,
              111,
              115,
              115,
              97,
              114,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TranslationServiceImplementation<CallContextExt = {}> {
  /** Translates input text and returns translated text. */
  translateText(
    request: TranslateTextRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TranslateTextResponse>>;
  /** Detects the language of text within a request. */
  detectLanguage(
    request: DetectLanguageRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DetectLanguageResponse>>;
  /** Returns a list of supported languages for translation. */
  getSupportedLanguages(
    request: GetSupportedLanguagesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SupportedLanguages>>;
  /** Translates documents in synchronous mode. */
  translateDocument(
    request: TranslateDocumentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TranslateDocumentResponse>>;
  /**
   * Translates a large volume of text in asynchronous batch mode.
   * This function provides real-time output as the inputs are being processed.
   * If caller cancels a request, the partial results (for an input file, it's
   * all or nothing) may still be available on the specified output location.
   *
   * This call returns immediately and you can
   * use google.longrunning.Operation.name to poll the status of the call.
   */
  batchTranslateText(
    request: BatchTranslateTextRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Translates a large volume of document in asynchronous batch mode.
   * This function provides real-time output as the inputs are being processed.
   * If caller cancels a request, the partial results (for an input file, it's
   * all or nothing) may still be available on the specified output location.
   *
   * This call returns immediately and you can use
   * google.longrunning.Operation.name to poll the status of the call.
   */
  batchTranslateDocument(
    request: BatchTranslateDocumentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Creates a glossary and returns the long-running operation. Returns
   * NOT_FOUND, if the project doesn't exist.
   */
  createGlossary(
    request: CreateGlossaryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists glossaries in a project. Returns NOT_FOUND, if the project doesn't
   * exist.
   */
  listGlossaries(
    request: ListGlossariesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGlossariesResponse>>;
  /**
   * Gets a glossary. Returns NOT_FOUND, if the glossary doesn't
   * exist.
   */
  getGlossary(request: GetGlossaryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Glossary>>;
  /**
   * Deletes a glossary, or cancels glossary construction
   * if the glossary isn't created yet.
   * Returns NOT_FOUND, if the glossary doesn't exist.
   */
  deleteGlossary(
    request: DeleteGlossaryRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface TranslationServiceClient<CallOptionsExt = {}> {
  /** Translates input text and returns translated text. */
  translateText(
    request: DeepPartial<TranslateTextRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TranslateTextResponse>;
  /** Detects the language of text within a request. */
  detectLanguage(
    request: DeepPartial<DetectLanguageRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DetectLanguageResponse>;
  /** Returns a list of supported languages for translation. */
  getSupportedLanguages(
    request: DeepPartial<GetSupportedLanguagesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SupportedLanguages>;
  /** Translates documents in synchronous mode. */
  translateDocument(
    request: DeepPartial<TranslateDocumentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TranslateDocumentResponse>;
  /**
   * Translates a large volume of text in asynchronous batch mode.
   * This function provides real-time output as the inputs are being processed.
   * If caller cancels a request, the partial results (for an input file, it's
   * all or nothing) may still be available on the specified output location.
   *
   * This call returns immediately and you can
   * use google.longrunning.Operation.name to poll the status of the call.
   */
  batchTranslateText(
    request: DeepPartial<BatchTranslateTextRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Translates a large volume of document in asynchronous batch mode.
   * This function provides real-time output as the inputs are being processed.
   * If caller cancels a request, the partial results (for an input file, it's
   * all or nothing) may still be available on the specified output location.
   *
   * This call returns immediately and you can use
   * google.longrunning.Operation.name to poll the status of the call.
   */
  batchTranslateDocument(
    request: DeepPartial<BatchTranslateDocumentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Creates a glossary and returns the long-running operation. Returns
   * NOT_FOUND, if the project doesn't exist.
   */
  createGlossary(
    request: DeepPartial<CreateGlossaryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists glossaries in a project. Returns NOT_FOUND, if the project doesn't
   * exist.
   */
  listGlossaries(
    request: DeepPartial<ListGlossariesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGlossariesResponse>;
  /**
   * Gets a glossary. Returns NOT_FOUND, if the glossary doesn't
   * exist.
   */
  getGlossary(request: DeepPartial<GetGlossaryRequest>, options?: CallOptions & CallOptionsExt): Promise<Glossary>;
  /**
   * Deletes a glossary, or cancels glossary construction
   * if the glossary isn't created yet.
   * Returns NOT_FOUND, if the glossary doesn't exist.
   */
  deleteGlossary(
    request: DeepPartial<DeleteGlossaryRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
