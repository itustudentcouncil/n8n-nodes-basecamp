// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/translate/v3/adaptive_mt.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { FileInputSource, GcsInputSource } from "./common.js";

export const protobufPackage = "google.cloud.translation.v3";

/** An Adaptive MT Dataset. */
export interface AdaptiveMtDataset {
  /**
   * Required. The resource name of the dataset, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset_id}`
   */
  name: string;
  /**
   * The name of the dataset to show in the interface. The name can be
   * up to 32 characters long and can consist only of ASCII Latin letters A-Z
   * and a-z, underscores (_), and ASCII digits 0-9.
   */
  displayName: string;
  /** The BCP-47 language code of the source language. */
  sourceLanguageCode: string;
  /** The BCP-47 language code of the target language. */
  targetLanguageCode: string;
  /** The number of examples in the dataset. */
  exampleCount: number;
  /** Output only. Timestamp when this dataset was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this dataset was last updated. */
  updateTime: Date | undefined;
}

/** Request message for creating an AdaptiveMtDataset. */
export interface CreateAdaptiveMtDatasetRequest {
  /**
   * Required. Name of the parent project. In form of
   * `projects/{project-number-or-id}/locations/{location-id}`
   */
  parent: string;
  /** Required. The AdaptiveMtDataset to be created. */
  adaptiveMtDataset: AdaptiveMtDataset | undefined;
}

/** Request message for deleting an AdaptiveMtDataset. */
export interface DeleteAdaptiveMtDatasetRequest {
  /**
   * Required. Name of the dataset. In the form of
   * `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
   */
  name: string;
}

/** Request message for getting an Adaptive MT dataset. */
export interface GetAdaptiveMtDatasetRequest {
  /**
   * Required. Name of the dataset. In the form of
   * `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
   */
  name: string;
}

/**
 * Request message for listing all Adaptive MT datasets that the requestor has
 * access to.
 */
export interface ListAdaptiveMtDatasetsRequest {
  /**
   * Required. The resource name of the project from which to list the Adaptive
   * MT datasets. `projects/{project-number-or-id}/locations/{location-id}`
   */
  parent: string;
  /**
   * Optional. Requested page size. The server may return fewer results than
   * requested. If unspecified, the server picks an appropriate default.
   */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   * Typically, this is the value of
   * ListAdaptiveMtDatasetsResponse.next_page_token returned from the
   * previous call to `ListAdaptiveMtDatasets` method. The first page is
   * returned if `page_token`is empty or missing.
   */
  pageToken: string;
  /**
   * Optional. An expression for filtering the results of the request.
   * Filter is not supported yet.
   */
  filter: string;
}

/** A list of AdaptiveMtDatasets. */
export interface ListAdaptiveMtDatasetsResponse {
  /** Output only. A list of Adaptive MT datasets. */
  adaptiveMtDatasets: AdaptiveMtDataset[];
  /**
   * Optional. A token to retrieve a page of results. Pass this value in the
   * [ListAdaptiveMtDatasetsRequest.page_token] field in the subsequent call to
   * `ListAdaptiveMtDatasets` method to retrieve the next page of results.
   */
  nextPageToken: string;
}

/** The request for sending an AdaptiveMt translation query. */
export interface AdaptiveMtTranslateRequest {
  /**
   * Required. Location to make a regional call.
   *
   * Format: `projects/{project-number-or-id}/locations/{location-id}`.
   */
  parent: string;
  /**
   * Required. The resource name for the dataset to use for adaptive MT.
   * `projects/{project}/locations/{location-id}/adaptiveMtDatasets/{dataset}`
   */
  dataset: string;
  /** Required. The content of the input in string format. */
  content: string[];
  /** Configuration for caller provided reference sentences. */
  referenceSentenceConfig?:
    | AdaptiveMtTranslateRequest_ReferenceSentenceConfig
    | undefined;
  /**
   * Optional. Glossary to be applied. The glossary must be
   * within the same region (have the same location-id) as the model, otherwise
   * an INVALID_ARGUMENT (400) error is returned.
   */
  glossaryConfig?: AdaptiveMtTranslateRequest_GlossaryConfig | undefined;
}

/** A pair of sentences used as reference in source and target languages. */
export interface AdaptiveMtTranslateRequest_ReferenceSentencePair {
  /** Source sentence in the sentence pair. */
  sourceSentence: string;
  /** Target sentence in the sentence pair. */
  targetSentence: string;
}

/** A list of reference sentence pairs. */
export interface AdaptiveMtTranslateRequest_ReferenceSentencePairList {
  /** Reference sentence pairs. */
  referenceSentencePairs: AdaptiveMtTranslateRequest_ReferenceSentencePair[];
}

/** Message of caller-provided reference configuration. */
export interface AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
  /**
   * Reference sentences pair lists. Each list will be used as the references
   * to translate the sentence under "content" field at the corresponding
   * index. Length of the list is required to be equal to the length of
   * "content" field.
   */
  referenceSentencePairLists: AdaptiveMtTranslateRequest_ReferenceSentencePairList[];
  /** Source language code. */
  sourceLanguageCode: string;
  /** Target language code. */
  targetLanguageCode: string;
}

/**
 * Configures which glossary is used for a specific target language and
 * defines
 * options for applying that glossary.
 */
export interface AdaptiveMtTranslateRequest_GlossaryConfig {
  /**
   * Required. The `glossary` to be applied for this translation.
   *
   * The format depends on the glossary:
   *
   * - User-provided custom glossary:
   *   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
   */
  glossary: string;
  /**
   * Optional. Indicates match is case insensitive. The default value is
   * `false` if missing.
   */
  ignoreCase: boolean;
}

/** An AdaptiveMt translation. */
export interface AdaptiveMtTranslation {
  /** Output only. The translated text. */
  translatedText: string;
}

/** An AdaptiveMtTranslate response. */
export interface AdaptiveMtTranslateResponse {
  /** Output only. The translation. */
  translations: AdaptiveMtTranslation[];
  /** Output only. The translation's language code. */
  languageCode: string;
  /**
   * Text translation response if a glossary is provided in the request. This
   * could be the same as 'translation' above if no terms apply.
   */
  glossaryTranslations: AdaptiveMtTranslation[];
}

/** An AdaptiveMtFile. */
export interface AdaptiveMtFile {
  /**
   * Required. The resource name of the file, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
   */
  name: string;
  /** The file's display name. */
  displayName: string;
  /** The number of entries that the file contains. */
  entryCount: number;
  /** Output only. Timestamp when this file was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this file was last updated. */
  updateTime: Date | undefined;
}

/** The request for getting an AdaptiveMtFile. */
export interface GetAdaptiveMtFileRequest {
  /**
   * Required. The resource name of the file, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
   */
  name: string;
}

/** The request for deleting an AdaptiveMt file. */
export interface DeleteAdaptiveMtFileRequest {
  /**
   * Required. The resource name of the file to delete, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
   */
  name: string;
}

/** The request for importing an AdaptiveMt file along with its sentences. */
export interface ImportAdaptiveMtFileRequest {
  /**
   * Required. The resource name of the file, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}`
   */
  parent: string;
  /** Inline file source. */
  fileInputSource?:
    | FileInputSource
    | undefined;
  /** Google Cloud Storage file source. */
  gcsInputSource?: GcsInputSource | undefined;
}

/** The response for importing an AdaptiveMtFile */
export interface ImportAdaptiveMtFileResponse {
  /** Output only. The Adaptive MT file that was imported. */
  adaptiveMtFile: AdaptiveMtFile | undefined;
}

/** The request to list all AdaptiveMt files under a given dataset. */
export interface ListAdaptiveMtFilesRequest {
  /**
   * Required. The resource name of the project from which to list the Adaptive
   * MT files.
   * `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
   */
  parent: string;
  /** Optional. */
  pageSize: number;
  /**
   * Optional. A token identifying a page of results the server should return.
   * Typically, this is the value of
   * ListAdaptiveMtFilesResponse.next_page_token returned from the
   * previous call to `ListAdaptiveMtFiles` method. The first page is
   * returned if `page_token`is empty or missing.
   */
  pageToken: string;
}

/** The response for listing all AdaptiveMt files under a given dataset. */
export interface ListAdaptiveMtFilesResponse {
  /** Output only. The Adaptive MT files. */
  adaptiveMtFiles: AdaptiveMtFile[];
  /**
   * Optional. A token to retrieve a page of results. Pass this value in the
   * ListAdaptiveMtFilesRequest.page_token field in the subsequent call to
   * `ListAdaptiveMtFiles` method to retrieve the next page of results.
   */
  nextPageToken: string;
}

/** An AdaptiveMt sentence entry. */
export interface AdaptiveMtSentence {
  /**
   * Required. The resource name of the file, in form of
   * `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}/adaptiveMtSentences/{sentence}`
   */
  name: string;
  /** Required. The source sentence. */
  sourceSentence: string;
  /** Required. The target sentence. */
  targetSentence: string;
  /** Output only. Timestamp when this sentence was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when this sentence was last updated. */
  updateTime: Date | undefined;
}

/** The request for listing Adaptive MT sentences from a Dataset/File. */
export interface ListAdaptiveMtSentencesRequest {
  /**
   * Required. The resource name of the project from which to list the Adaptive
   * MT files. The following format lists all sentences under a file.
   * `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
   * The following format lists all sentences within a dataset.
   * `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
   */
  parent: string;
  pageSize: number;
  /**
   * A token identifying a page of results the server should return.
   * Typically, this is the value of
   * ListAdaptiveMtSentencesRequest.next_page_token returned from the
   * previous call to `ListTranslationMemories` method. The first page is
   * returned if `page_token` is empty or missing.
   */
  pageToken: string;
}

/** List AdaptiveMt sentences response. */
export interface ListAdaptiveMtSentencesResponse {
  /** Output only. The list of AdaptiveMtSentences. */
  adaptiveMtSentences: AdaptiveMtSentence[];
  /** Optional. */
  nextPageToken: string;
}

function createBaseAdaptiveMtDataset(): AdaptiveMtDataset {
  return {
    name: "",
    displayName: "",
    sourceLanguageCode: "",
    targetLanguageCode: "",
    exampleCount: 0,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const AdaptiveMtDataset: MessageFns<AdaptiveMtDataset> = {
  encode(message: AdaptiveMtDataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(26).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(34).string(message.targetLanguageCode);
    }
    if (message.exampleCount !== 0) {
      writer.uint32(40).int32(message.exampleCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtDataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.exampleCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtDataset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
      exampleCount: isSet(object.exampleCount) ? globalThis.Number(object.exampleCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: AdaptiveMtDataset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    if (message.exampleCount !== 0) {
      obj.exampleCount = Math.round(message.exampleCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtDataset>): AdaptiveMtDataset {
    return AdaptiveMtDataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtDataset>): AdaptiveMtDataset {
    const message = createBaseAdaptiveMtDataset();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    message.exampleCount = object.exampleCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseCreateAdaptiveMtDatasetRequest(): CreateAdaptiveMtDatasetRequest {
  return { parent: "", adaptiveMtDataset: undefined };
}

export const CreateAdaptiveMtDatasetRequest: MessageFns<CreateAdaptiveMtDatasetRequest> = {
  encode(message: CreateAdaptiveMtDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.adaptiveMtDataset !== undefined) {
      AdaptiveMtDataset.encode(message.adaptiveMtDataset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAdaptiveMtDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAdaptiveMtDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.adaptiveMtDataset = AdaptiveMtDataset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAdaptiveMtDatasetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      adaptiveMtDataset: isSet(object.adaptiveMtDataset)
        ? AdaptiveMtDataset.fromJSON(object.adaptiveMtDataset)
        : undefined,
    };
  },

  toJSON(message: CreateAdaptiveMtDatasetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.adaptiveMtDataset !== undefined) {
      obj.adaptiveMtDataset = AdaptiveMtDataset.toJSON(message.adaptiveMtDataset);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAdaptiveMtDatasetRequest>): CreateAdaptiveMtDatasetRequest {
    return CreateAdaptiveMtDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAdaptiveMtDatasetRequest>): CreateAdaptiveMtDatasetRequest {
    const message = createBaseCreateAdaptiveMtDatasetRequest();
    message.parent = object.parent ?? "";
    message.adaptiveMtDataset = (object.adaptiveMtDataset !== undefined && object.adaptiveMtDataset !== null)
      ? AdaptiveMtDataset.fromPartial(object.adaptiveMtDataset)
      : undefined;
    return message;
  },
};

function createBaseDeleteAdaptiveMtDatasetRequest(): DeleteAdaptiveMtDatasetRequest {
  return { name: "" };
}

export const DeleteAdaptiveMtDatasetRequest: MessageFns<DeleteAdaptiveMtDatasetRequest> = {
  encode(message: DeleteAdaptiveMtDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAdaptiveMtDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAdaptiveMtDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAdaptiveMtDatasetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAdaptiveMtDatasetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAdaptiveMtDatasetRequest>): DeleteAdaptiveMtDatasetRequest {
    return DeleteAdaptiveMtDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAdaptiveMtDatasetRequest>): DeleteAdaptiveMtDatasetRequest {
    const message = createBaseDeleteAdaptiveMtDatasetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetAdaptiveMtDatasetRequest(): GetAdaptiveMtDatasetRequest {
  return { name: "" };
}

export const GetAdaptiveMtDatasetRequest: MessageFns<GetAdaptiveMtDatasetRequest> = {
  encode(message: GetAdaptiveMtDatasetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdaptiveMtDatasetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdaptiveMtDatasetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdaptiveMtDatasetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAdaptiveMtDatasetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAdaptiveMtDatasetRequest>): GetAdaptiveMtDatasetRequest {
    return GetAdaptiveMtDatasetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAdaptiveMtDatasetRequest>): GetAdaptiveMtDatasetRequest {
    const message = createBaseGetAdaptiveMtDatasetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAdaptiveMtDatasetsRequest(): ListAdaptiveMtDatasetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListAdaptiveMtDatasetsRequest: MessageFns<ListAdaptiveMtDatasetsRequest> = {
  encode(message: ListAdaptiveMtDatasetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtDatasetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtDatasetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtDatasetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAdaptiveMtDatasetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtDatasetsRequest>): ListAdaptiveMtDatasetsRequest {
    return ListAdaptiveMtDatasetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtDatasetsRequest>): ListAdaptiveMtDatasetsRequest {
    const message = createBaseListAdaptiveMtDatasetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAdaptiveMtDatasetsResponse(): ListAdaptiveMtDatasetsResponse {
  return { adaptiveMtDatasets: [], nextPageToken: "" };
}

export const ListAdaptiveMtDatasetsResponse: MessageFns<ListAdaptiveMtDatasetsResponse> = {
  encode(message: ListAdaptiveMtDatasetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adaptiveMtDatasets) {
      AdaptiveMtDataset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtDatasetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtDatasetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adaptiveMtDatasets.push(AdaptiveMtDataset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtDatasetsResponse {
    return {
      adaptiveMtDatasets: globalThis.Array.isArray(object?.adaptiveMtDatasets)
        ? object.adaptiveMtDatasets.map((e: any) => AdaptiveMtDataset.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAdaptiveMtDatasetsResponse): unknown {
    const obj: any = {};
    if (message.adaptiveMtDatasets?.length) {
      obj.adaptiveMtDatasets = message.adaptiveMtDatasets.map((e) => AdaptiveMtDataset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtDatasetsResponse>): ListAdaptiveMtDatasetsResponse {
    return ListAdaptiveMtDatasetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtDatasetsResponse>): ListAdaptiveMtDatasetsResponse {
    const message = createBaseListAdaptiveMtDatasetsResponse();
    message.adaptiveMtDatasets = object.adaptiveMtDatasets?.map((e) => AdaptiveMtDataset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAdaptiveMtTranslateRequest(): AdaptiveMtTranslateRequest {
  return { parent: "", dataset: "", content: [], referenceSentenceConfig: undefined, glossaryConfig: undefined };
}

export const AdaptiveMtTranslateRequest: MessageFns<AdaptiveMtTranslateRequest> = {
  encode(message: AdaptiveMtTranslateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataset !== "") {
      writer.uint32(18).string(message.dataset);
    }
    for (const v of message.content) {
      writer.uint32(26).string(v!);
    }
    if (message.referenceSentenceConfig !== undefined) {
      AdaptiveMtTranslateRequest_ReferenceSentenceConfig.encode(
        message.referenceSentenceConfig,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.glossaryConfig !== undefined) {
      AdaptiveMtTranslateRequest_GlossaryConfig.encode(message.glossaryConfig, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referenceSentenceConfig = AdaptiveMtTranslateRequest_ReferenceSentenceConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.glossaryConfig = AdaptiveMtTranslateRequest_GlossaryConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      content: globalThis.Array.isArray(object?.content) ? object.content.map((e: any) => globalThis.String(e)) : [],
      referenceSentenceConfig: isSet(object.referenceSentenceConfig)
        ? AdaptiveMtTranslateRequest_ReferenceSentenceConfig.fromJSON(object.referenceSentenceConfig)
        : undefined,
      glossaryConfig: isSet(object.glossaryConfig)
        ? AdaptiveMtTranslateRequest_GlossaryConfig.fromJSON(object.glossaryConfig)
        : undefined,
    };
  },

  toJSON(message: AdaptiveMtTranslateRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.content?.length) {
      obj.content = message.content;
    }
    if (message.referenceSentenceConfig !== undefined) {
      obj.referenceSentenceConfig = AdaptiveMtTranslateRequest_ReferenceSentenceConfig.toJSON(
        message.referenceSentenceConfig,
      );
    }
    if (message.glossaryConfig !== undefined) {
      obj.glossaryConfig = AdaptiveMtTranslateRequest_GlossaryConfig.toJSON(message.glossaryConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtTranslateRequest>): AdaptiveMtTranslateRequest {
    return AdaptiveMtTranslateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtTranslateRequest>): AdaptiveMtTranslateRequest {
    const message = createBaseAdaptiveMtTranslateRequest();
    message.parent = object.parent ?? "";
    message.dataset = object.dataset ?? "";
    message.content = object.content?.map((e) => e) || [];
    message.referenceSentenceConfig =
      (object.referenceSentenceConfig !== undefined && object.referenceSentenceConfig !== null)
        ? AdaptiveMtTranslateRequest_ReferenceSentenceConfig.fromPartial(object.referenceSentenceConfig)
        : undefined;
    message.glossaryConfig = (object.glossaryConfig !== undefined && object.glossaryConfig !== null)
      ? AdaptiveMtTranslateRequest_GlossaryConfig.fromPartial(object.glossaryConfig)
      : undefined;
    return message;
  },
};

function createBaseAdaptiveMtTranslateRequest_ReferenceSentencePair(): AdaptiveMtTranslateRequest_ReferenceSentencePair {
  return { sourceSentence: "", targetSentence: "" };
}

export const AdaptiveMtTranslateRequest_ReferenceSentencePair: MessageFns<
  AdaptiveMtTranslateRequest_ReferenceSentencePair
> = {
  encode(
    message: AdaptiveMtTranslateRequest_ReferenceSentencePair,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceSentence !== "") {
      writer.uint32(10).string(message.sourceSentence);
    }
    if (message.targetSentence !== "") {
      writer.uint32(18).string(message.targetSentence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateRequest_ReferenceSentencePair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentencePair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceSentence = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetSentence = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateRequest_ReferenceSentencePair {
    return {
      sourceSentence: isSet(object.sourceSentence) ? globalThis.String(object.sourceSentence) : "",
      targetSentence: isSet(object.targetSentence) ? globalThis.String(object.targetSentence) : "",
    };
  },

  toJSON(message: AdaptiveMtTranslateRequest_ReferenceSentencePair): unknown {
    const obj: any = {};
    if (message.sourceSentence !== "") {
      obj.sourceSentence = message.sourceSentence;
    }
    if (message.targetSentence !== "") {
      obj.targetSentence = message.targetSentence;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentencePair>,
  ): AdaptiveMtTranslateRequest_ReferenceSentencePair {
    return AdaptiveMtTranslateRequest_ReferenceSentencePair.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentencePair>,
  ): AdaptiveMtTranslateRequest_ReferenceSentencePair {
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentencePair();
    message.sourceSentence = object.sourceSentence ?? "";
    message.targetSentence = object.targetSentence ?? "";
    return message;
  },
};

function createBaseAdaptiveMtTranslateRequest_ReferenceSentencePairList(): AdaptiveMtTranslateRequest_ReferenceSentencePairList {
  return { referenceSentencePairs: [] };
}

export const AdaptiveMtTranslateRequest_ReferenceSentencePairList: MessageFns<
  AdaptiveMtTranslateRequest_ReferenceSentencePairList
> = {
  encode(
    message: AdaptiveMtTranslateRequest_ReferenceSentencePairList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.referenceSentencePairs) {
      AdaptiveMtTranslateRequest_ReferenceSentencePair.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateRequest_ReferenceSentencePairList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentencePairList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceSentencePairs.push(
            AdaptiveMtTranslateRequest_ReferenceSentencePair.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateRequest_ReferenceSentencePairList {
    return {
      referenceSentencePairs: globalThis.Array.isArray(object?.referenceSentencePairs)
        ? object.referenceSentencePairs.map((e: any) => AdaptiveMtTranslateRequest_ReferenceSentencePair.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdaptiveMtTranslateRequest_ReferenceSentencePairList): unknown {
    const obj: any = {};
    if (message.referenceSentencePairs?.length) {
      obj.referenceSentencePairs = message.referenceSentencePairs.map((e) =>
        AdaptiveMtTranslateRequest_ReferenceSentencePair.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentencePairList>,
  ): AdaptiveMtTranslateRequest_ReferenceSentencePairList {
    return AdaptiveMtTranslateRequest_ReferenceSentencePairList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentencePairList>,
  ): AdaptiveMtTranslateRequest_ReferenceSentencePairList {
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentencePairList();
    message.referenceSentencePairs =
      object.referenceSentencePairs?.map((e) => AdaptiveMtTranslateRequest_ReferenceSentencePair.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdaptiveMtTranslateRequest_ReferenceSentenceConfig(): AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
  return { referenceSentencePairLists: [], sourceLanguageCode: "", targetLanguageCode: "" };
}

export const AdaptiveMtTranslateRequest_ReferenceSentenceConfig: MessageFns<
  AdaptiveMtTranslateRequest_ReferenceSentenceConfig
> = {
  encode(
    message: AdaptiveMtTranslateRequest_ReferenceSentenceConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.referenceSentencePairLists) {
      AdaptiveMtTranslateRequest_ReferenceSentencePairList.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.sourceLanguageCode !== "") {
      writer.uint32(18).string(message.sourceLanguageCode);
    }
    if (message.targetLanguageCode !== "") {
      writer.uint32(26).string(message.targetLanguageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentenceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceSentencePairLists.push(
            AdaptiveMtTranslateRequest_ReferenceSentencePairList.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceLanguageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetLanguageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
    return {
      referenceSentencePairLists: globalThis.Array.isArray(object?.referenceSentencePairLists)
        ? object.referenceSentencePairLists.map((e: any) =>
          AdaptiveMtTranslateRequest_ReferenceSentencePairList.fromJSON(e)
        )
        : [],
      sourceLanguageCode: isSet(object.sourceLanguageCode) ? globalThis.String(object.sourceLanguageCode) : "",
      targetLanguageCode: isSet(object.targetLanguageCode) ? globalThis.String(object.targetLanguageCode) : "",
    };
  },

  toJSON(message: AdaptiveMtTranslateRequest_ReferenceSentenceConfig): unknown {
    const obj: any = {};
    if (message.referenceSentencePairLists?.length) {
      obj.referenceSentencePairLists = message.referenceSentencePairLists.map((e) =>
        AdaptiveMtTranslateRequest_ReferenceSentencePairList.toJSON(e)
      );
    }
    if (message.sourceLanguageCode !== "") {
      obj.sourceLanguageCode = message.sourceLanguageCode;
    }
    if (message.targetLanguageCode !== "") {
      obj.targetLanguageCode = message.targetLanguageCode;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentenceConfig>,
  ): AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
    return AdaptiveMtTranslateRequest_ReferenceSentenceConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AdaptiveMtTranslateRequest_ReferenceSentenceConfig>,
  ): AdaptiveMtTranslateRequest_ReferenceSentenceConfig {
    const message = createBaseAdaptiveMtTranslateRequest_ReferenceSentenceConfig();
    message.referenceSentencePairLists =
      object.referenceSentencePairLists?.map((e) =>
        AdaptiveMtTranslateRequest_ReferenceSentencePairList.fromPartial(e)
      ) || [];
    message.sourceLanguageCode = object.sourceLanguageCode ?? "";
    message.targetLanguageCode = object.targetLanguageCode ?? "";
    return message;
  },
};

function createBaseAdaptiveMtTranslateRequest_GlossaryConfig(): AdaptiveMtTranslateRequest_GlossaryConfig {
  return { glossary: "", ignoreCase: false };
}

export const AdaptiveMtTranslateRequest_GlossaryConfig: MessageFns<AdaptiveMtTranslateRequest_GlossaryConfig> = {
  encode(message: AdaptiveMtTranslateRequest_GlossaryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.glossary !== "") {
      writer.uint32(10).string(message.glossary);
    }
    if (message.ignoreCase !== false) {
      writer.uint32(16).bool(message.ignoreCase);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateRequest_GlossaryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateRequest_GlossaryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.glossary = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ignoreCase = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateRequest_GlossaryConfig {
    return {
      glossary: isSet(object.glossary) ? globalThis.String(object.glossary) : "",
      ignoreCase: isSet(object.ignoreCase) ? globalThis.Boolean(object.ignoreCase) : false,
    };
  },

  toJSON(message: AdaptiveMtTranslateRequest_GlossaryConfig): unknown {
    const obj: any = {};
    if (message.glossary !== "") {
      obj.glossary = message.glossary;
    }
    if (message.ignoreCase !== false) {
      obj.ignoreCase = message.ignoreCase;
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtTranslateRequest_GlossaryConfig>): AdaptiveMtTranslateRequest_GlossaryConfig {
    return AdaptiveMtTranslateRequest_GlossaryConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AdaptiveMtTranslateRequest_GlossaryConfig>,
  ): AdaptiveMtTranslateRequest_GlossaryConfig {
    const message = createBaseAdaptiveMtTranslateRequest_GlossaryConfig();
    message.glossary = object.glossary ?? "";
    message.ignoreCase = object.ignoreCase ?? false;
    return message;
  },
};

function createBaseAdaptiveMtTranslation(): AdaptiveMtTranslation {
  return { translatedText: "" };
}

export const AdaptiveMtTranslation: MessageFns<AdaptiveMtTranslation> = {
  encode(message: AdaptiveMtTranslation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.translatedText !== "") {
      writer.uint32(10).string(message.translatedText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translatedText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslation {
    return { translatedText: isSet(object.translatedText) ? globalThis.String(object.translatedText) : "" };
  },

  toJSON(message: AdaptiveMtTranslation): unknown {
    const obj: any = {};
    if (message.translatedText !== "") {
      obj.translatedText = message.translatedText;
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtTranslation>): AdaptiveMtTranslation {
    return AdaptiveMtTranslation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtTranslation>): AdaptiveMtTranslation {
    const message = createBaseAdaptiveMtTranslation();
    message.translatedText = object.translatedText ?? "";
    return message;
  },
};

function createBaseAdaptiveMtTranslateResponse(): AdaptiveMtTranslateResponse {
  return { translations: [], languageCode: "", glossaryTranslations: [] };
}

export const AdaptiveMtTranslateResponse: MessageFns<AdaptiveMtTranslateResponse> = {
  encode(message: AdaptiveMtTranslateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.translations) {
      AdaptiveMtTranslation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    for (const v of message.glossaryTranslations) {
      AdaptiveMtTranslation.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtTranslateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtTranslateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.translations.push(AdaptiveMtTranslation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.glossaryTranslations.push(AdaptiveMtTranslation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtTranslateResponse {
    return {
      translations: globalThis.Array.isArray(object?.translations)
        ? object.translations.map((e: any) => AdaptiveMtTranslation.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      glossaryTranslations: globalThis.Array.isArray(object?.glossaryTranslations)
        ? object.glossaryTranslations.map((e: any) => AdaptiveMtTranslation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdaptiveMtTranslateResponse): unknown {
    const obj: any = {};
    if (message.translations?.length) {
      obj.translations = message.translations.map((e) => AdaptiveMtTranslation.toJSON(e));
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.glossaryTranslations?.length) {
      obj.glossaryTranslations = message.glossaryTranslations.map((e) => AdaptiveMtTranslation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtTranslateResponse>): AdaptiveMtTranslateResponse {
    return AdaptiveMtTranslateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtTranslateResponse>): AdaptiveMtTranslateResponse {
    const message = createBaseAdaptiveMtTranslateResponse();
    message.translations = object.translations?.map((e) => AdaptiveMtTranslation.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    message.glossaryTranslations = object.glossaryTranslations?.map((e) => AdaptiveMtTranslation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAdaptiveMtFile(): AdaptiveMtFile {
  return { name: "", displayName: "", entryCount: 0, createTime: undefined, updateTime: undefined };
}

export const AdaptiveMtFile: MessageFns<AdaptiveMtFile> = {
  encode(message: AdaptiveMtFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.entryCount !== 0) {
      writer.uint32(24).int32(message.entryCount);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entryCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtFile {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      entryCount: isSet(object.entryCount) ? globalThis.Number(object.entryCount) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: AdaptiveMtFile): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.entryCount !== 0) {
      obj.entryCount = Math.round(message.entryCount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtFile>): AdaptiveMtFile {
    return AdaptiveMtFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtFile>): AdaptiveMtFile {
    const message = createBaseAdaptiveMtFile();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.entryCount = object.entryCount ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseGetAdaptiveMtFileRequest(): GetAdaptiveMtFileRequest {
  return { name: "" };
}

export const GetAdaptiveMtFileRequest: MessageFns<GetAdaptiveMtFileRequest> = {
  encode(message: GetAdaptiveMtFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAdaptiveMtFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAdaptiveMtFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAdaptiveMtFileRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAdaptiveMtFileRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAdaptiveMtFileRequest>): GetAdaptiveMtFileRequest {
    return GetAdaptiveMtFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAdaptiveMtFileRequest>): GetAdaptiveMtFileRequest {
    const message = createBaseGetAdaptiveMtFileRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteAdaptiveMtFileRequest(): DeleteAdaptiveMtFileRequest {
  return { name: "" };
}

export const DeleteAdaptiveMtFileRequest: MessageFns<DeleteAdaptiveMtFileRequest> = {
  encode(message: DeleteAdaptiveMtFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAdaptiveMtFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAdaptiveMtFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAdaptiveMtFileRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAdaptiveMtFileRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAdaptiveMtFileRequest>): DeleteAdaptiveMtFileRequest {
    return DeleteAdaptiveMtFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAdaptiveMtFileRequest>): DeleteAdaptiveMtFileRequest {
    const message = createBaseDeleteAdaptiveMtFileRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseImportAdaptiveMtFileRequest(): ImportAdaptiveMtFileRequest {
  return { parent: "", fileInputSource: undefined, gcsInputSource: undefined };
}

export const ImportAdaptiveMtFileRequest: MessageFns<ImportAdaptiveMtFileRequest> = {
  encode(message: ImportAdaptiveMtFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.fileInputSource !== undefined) {
      FileInputSource.encode(message.fileInputSource, writer.uint32(18).fork()).join();
    }
    if (message.gcsInputSource !== undefined) {
      GcsInputSource.encode(message.gcsInputSource, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAdaptiveMtFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAdaptiveMtFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileInputSource = FileInputSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcsInputSource = GcsInputSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAdaptiveMtFileRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      fileInputSource: isSet(object.fileInputSource) ? FileInputSource.fromJSON(object.fileInputSource) : undefined,
      gcsInputSource: isSet(object.gcsInputSource) ? GcsInputSource.fromJSON(object.gcsInputSource) : undefined,
    };
  },

  toJSON(message: ImportAdaptiveMtFileRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.fileInputSource !== undefined) {
      obj.fileInputSource = FileInputSource.toJSON(message.fileInputSource);
    }
    if (message.gcsInputSource !== undefined) {
      obj.gcsInputSource = GcsInputSource.toJSON(message.gcsInputSource);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAdaptiveMtFileRequest>): ImportAdaptiveMtFileRequest {
    return ImportAdaptiveMtFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAdaptiveMtFileRequest>): ImportAdaptiveMtFileRequest {
    const message = createBaseImportAdaptiveMtFileRequest();
    message.parent = object.parent ?? "";
    message.fileInputSource = (object.fileInputSource !== undefined && object.fileInputSource !== null)
      ? FileInputSource.fromPartial(object.fileInputSource)
      : undefined;
    message.gcsInputSource = (object.gcsInputSource !== undefined && object.gcsInputSource !== null)
      ? GcsInputSource.fromPartial(object.gcsInputSource)
      : undefined;
    return message;
  },
};

function createBaseImportAdaptiveMtFileResponse(): ImportAdaptiveMtFileResponse {
  return { adaptiveMtFile: undefined };
}

export const ImportAdaptiveMtFileResponse: MessageFns<ImportAdaptiveMtFileResponse> = {
  encode(message: ImportAdaptiveMtFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adaptiveMtFile !== undefined) {
      AdaptiveMtFile.encode(message.adaptiveMtFile, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAdaptiveMtFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAdaptiveMtFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adaptiveMtFile = AdaptiveMtFile.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAdaptiveMtFileResponse {
    return {
      adaptiveMtFile: isSet(object.adaptiveMtFile) ? AdaptiveMtFile.fromJSON(object.adaptiveMtFile) : undefined,
    };
  },

  toJSON(message: ImportAdaptiveMtFileResponse): unknown {
    const obj: any = {};
    if (message.adaptiveMtFile !== undefined) {
      obj.adaptiveMtFile = AdaptiveMtFile.toJSON(message.adaptiveMtFile);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAdaptiveMtFileResponse>): ImportAdaptiveMtFileResponse {
    return ImportAdaptiveMtFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAdaptiveMtFileResponse>): ImportAdaptiveMtFileResponse {
    const message = createBaseImportAdaptiveMtFileResponse();
    message.adaptiveMtFile = (object.adaptiveMtFile !== undefined && object.adaptiveMtFile !== null)
      ? AdaptiveMtFile.fromPartial(object.adaptiveMtFile)
      : undefined;
    return message;
  },
};

function createBaseListAdaptiveMtFilesRequest(): ListAdaptiveMtFilesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAdaptiveMtFilesRequest: MessageFns<ListAdaptiveMtFilesRequest> = {
  encode(message: ListAdaptiveMtFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtFilesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAdaptiveMtFilesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtFilesRequest>): ListAdaptiveMtFilesRequest {
    return ListAdaptiveMtFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtFilesRequest>): ListAdaptiveMtFilesRequest {
    const message = createBaseListAdaptiveMtFilesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAdaptiveMtFilesResponse(): ListAdaptiveMtFilesResponse {
  return { adaptiveMtFiles: [], nextPageToken: "" };
}

export const ListAdaptiveMtFilesResponse: MessageFns<ListAdaptiveMtFilesResponse> = {
  encode(message: ListAdaptiveMtFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adaptiveMtFiles) {
      AdaptiveMtFile.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adaptiveMtFiles.push(AdaptiveMtFile.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtFilesResponse {
    return {
      adaptiveMtFiles: globalThis.Array.isArray(object?.adaptiveMtFiles)
        ? object.adaptiveMtFiles.map((e: any) => AdaptiveMtFile.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAdaptiveMtFilesResponse): unknown {
    const obj: any = {};
    if (message.adaptiveMtFiles?.length) {
      obj.adaptiveMtFiles = message.adaptiveMtFiles.map((e) => AdaptiveMtFile.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtFilesResponse>): ListAdaptiveMtFilesResponse {
    return ListAdaptiveMtFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtFilesResponse>): ListAdaptiveMtFilesResponse {
    const message = createBaseListAdaptiveMtFilesResponse();
    message.adaptiveMtFiles = object.adaptiveMtFiles?.map((e) => AdaptiveMtFile.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseAdaptiveMtSentence(): AdaptiveMtSentence {
  return { name: "", sourceSentence: "", targetSentence: "", createTime: undefined, updateTime: undefined };
}

export const AdaptiveMtSentence: MessageFns<AdaptiveMtSentence> = {
  encode(message: AdaptiveMtSentence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sourceSentence !== "") {
      writer.uint32(18).string(message.sourceSentence);
    }
    if (message.targetSentence !== "") {
      writer.uint32(26).string(message.targetSentence);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdaptiveMtSentence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdaptiveMtSentence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceSentence = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetSentence = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdaptiveMtSentence {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceSentence: isSet(object.sourceSentence) ? globalThis.String(object.sourceSentence) : "",
      targetSentence: isSet(object.targetSentence) ? globalThis.String(object.targetSentence) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: AdaptiveMtSentence): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceSentence !== "") {
      obj.sourceSentence = message.sourceSentence;
    }
    if (message.targetSentence !== "") {
      obj.targetSentence = message.targetSentence;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AdaptiveMtSentence>): AdaptiveMtSentence {
    return AdaptiveMtSentence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdaptiveMtSentence>): AdaptiveMtSentence {
    const message = createBaseAdaptiveMtSentence();
    message.name = object.name ?? "";
    message.sourceSentence = object.sourceSentence ?? "";
    message.targetSentence = object.targetSentence ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseListAdaptiveMtSentencesRequest(): ListAdaptiveMtSentencesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAdaptiveMtSentencesRequest: MessageFns<ListAdaptiveMtSentencesRequest> = {
  encode(message: ListAdaptiveMtSentencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtSentencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtSentencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtSentencesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAdaptiveMtSentencesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtSentencesRequest>): ListAdaptiveMtSentencesRequest {
    return ListAdaptiveMtSentencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtSentencesRequest>): ListAdaptiveMtSentencesRequest {
    const message = createBaseListAdaptiveMtSentencesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAdaptiveMtSentencesResponse(): ListAdaptiveMtSentencesResponse {
  return { adaptiveMtSentences: [], nextPageToken: "" };
}

export const ListAdaptiveMtSentencesResponse: MessageFns<ListAdaptiveMtSentencesResponse> = {
  encode(message: ListAdaptiveMtSentencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.adaptiveMtSentences) {
      AdaptiveMtSentence.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAdaptiveMtSentencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAdaptiveMtSentencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adaptiveMtSentences.push(AdaptiveMtSentence.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAdaptiveMtSentencesResponse {
    return {
      adaptiveMtSentences: globalThis.Array.isArray(object?.adaptiveMtSentences)
        ? object.adaptiveMtSentences.map((e: any) => AdaptiveMtSentence.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAdaptiveMtSentencesResponse): unknown {
    const obj: any = {};
    if (message.adaptiveMtSentences?.length) {
      obj.adaptiveMtSentences = message.adaptiveMtSentences.map((e) => AdaptiveMtSentence.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAdaptiveMtSentencesResponse>): ListAdaptiveMtSentencesResponse {
    return ListAdaptiveMtSentencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAdaptiveMtSentencesResponse>): ListAdaptiveMtSentencesResponse {
    const message = createBaseListAdaptiveMtSentencesResponse();
    message.adaptiveMtSentences = object.adaptiveMtSentences?.map((e) => AdaptiveMtSentence.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
