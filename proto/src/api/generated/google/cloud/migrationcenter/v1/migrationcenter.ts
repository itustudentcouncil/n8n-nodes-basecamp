// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/migrationcenter/v1/migrationcenter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.cloud.migrationcenter.v1";

/**
 * Specifies the types of asset views that provide complete or partial details
 * of an asset.
 */
export enum AssetView {
  /**
   * ASSET_VIEW_UNSPECIFIED - The asset view is not specified. The API displays the basic view by
   * default.
   */
  ASSET_VIEW_UNSPECIFIED = 0,
  /** ASSET_VIEW_BASIC - The asset view includes only basic metadata of the asset. */
  ASSET_VIEW_BASIC = 1,
  /** ASSET_VIEW_FULL - The asset view includes all the metadata of an asset and performance data. */
  ASSET_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function assetViewFromJSON(object: any): AssetView {
  switch (object) {
    case 0:
    case "ASSET_VIEW_UNSPECIFIED":
      return AssetView.ASSET_VIEW_UNSPECIFIED;
    case 1:
    case "ASSET_VIEW_BASIC":
      return AssetView.ASSET_VIEW_BASIC;
    case 2:
    case "ASSET_VIEW_FULL":
      return AssetView.ASSET_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetView.UNRECOGNIZED;
  }
}

export function assetViewToJSON(object: AssetView): string {
  switch (object) {
    case AssetView.ASSET_VIEW_UNSPECIFIED:
      return "ASSET_VIEW_UNSPECIFIED";
    case AssetView.ASSET_VIEW_BASIC:
      return "ASSET_VIEW_BASIC";
    case AssetView.ASSET_VIEW_FULL:
      return "ASSET_VIEW_FULL";
    case AssetView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Known categories of operating systems. */
export enum OperatingSystemFamily {
  OS_FAMILY_UNKNOWN = 0,
  /** OS_FAMILY_WINDOWS - Microsoft Windows Server and Desktop. */
  OS_FAMILY_WINDOWS = 1,
  /** OS_FAMILY_LINUX - Various Linux flavors. */
  OS_FAMILY_LINUX = 2,
  /** OS_FAMILY_UNIX - Non-Linux Unix flavors. */
  OS_FAMILY_UNIX = 3,
  UNRECOGNIZED = -1,
}

export function operatingSystemFamilyFromJSON(object: any): OperatingSystemFamily {
  switch (object) {
    case 0:
    case "OS_FAMILY_UNKNOWN":
      return OperatingSystemFamily.OS_FAMILY_UNKNOWN;
    case 1:
    case "OS_FAMILY_WINDOWS":
      return OperatingSystemFamily.OS_FAMILY_WINDOWS;
    case 2:
    case "OS_FAMILY_LINUX":
      return OperatingSystemFamily.OS_FAMILY_LINUX;
    case 3:
    case "OS_FAMILY_UNIX":
      return OperatingSystemFamily.OS_FAMILY_UNIX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperatingSystemFamily.UNRECOGNIZED;
  }
}

export function operatingSystemFamilyToJSON(object: OperatingSystemFamily): string {
  switch (object) {
    case OperatingSystemFamily.OS_FAMILY_UNKNOWN:
      return "OS_FAMILY_UNKNOWN";
    case OperatingSystemFamily.OS_FAMILY_WINDOWS:
      return "OS_FAMILY_WINDOWS";
    case OperatingSystemFamily.OS_FAMILY_LINUX:
      return "OS_FAMILY_LINUX";
    case OperatingSystemFamily.OS_FAMILY_UNIX:
      return "OS_FAMILY_UNIX";
    case OperatingSystemFamily.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the data formats supported by Migration Center. */
export enum ImportJobFormat {
  /** IMPORT_JOB_FORMAT_UNSPECIFIED - Default value. */
  IMPORT_JOB_FORMAT_UNSPECIFIED = 0,
  /** IMPORT_JOB_FORMAT_RVTOOLS_XLSX - RVTools format (XLSX). */
  IMPORT_JOB_FORMAT_RVTOOLS_XLSX = 1,
  /** IMPORT_JOB_FORMAT_RVTOOLS_CSV - RVTools format (CSV). */
  IMPORT_JOB_FORMAT_RVTOOLS_CSV = 2,
  /**
   * IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV - CSV format exported from AWS using the
   * [AWS collection
   * script][https://github.com/GoogleCloudPlatform/aws-to-stratozone-export].
   */
  IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV = 4,
  /**
   * IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV - CSV format exported from Azure using the
   * [Azure collection
   * script][https://github.com/GoogleCloudPlatform/azure-to-stratozone-export].
   */
  IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV = 5,
  /**
   * IMPORT_JOB_FORMAT_STRATOZONE_CSV - CSV format created manually and following the StratoZone format. For more
   * information, see [Manually create and upload data
   * tables][https://cloud.google.com/migrate/stratozone/docs/import-data-portal].
   */
  IMPORT_JOB_FORMAT_STRATOZONE_CSV = 6,
  UNRECOGNIZED = -1,
}

export function importJobFormatFromJSON(object: any): ImportJobFormat {
  switch (object) {
    case 0:
    case "IMPORT_JOB_FORMAT_UNSPECIFIED":
      return ImportJobFormat.IMPORT_JOB_FORMAT_UNSPECIFIED;
    case 1:
    case "IMPORT_JOB_FORMAT_RVTOOLS_XLSX":
      return ImportJobFormat.IMPORT_JOB_FORMAT_RVTOOLS_XLSX;
    case 2:
    case "IMPORT_JOB_FORMAT_RVTOOLS_CSV":
      return ImportJobFormat.IMPORT_JOB_FORMAT_RVTOOLS_CSV;
    case 4:
    case "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV":
      return ImportJobFormat.IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV;
    case 5:
    case "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV":
      return ImportJobFormat.IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV;
    case 6:
    case "IMPORT_JOB_FORMAT_STRATOZONE_CSV":
      return ImportJobFormat.IMPORT_JOB_FORMAT_STRATOZONE_CSV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportJobFormat.UNRECOGNIZED;
  }
}

export function importJobFormatToJSON(object: ImportJobFormat): string {
  switch (object) {
    case ImportJobFormat.IMPORT_JOB_FORMAT_UNSPECIFIED:
      return "IMPORT_JOB_FORMAT_UNSPECIFIED";
    case ImportJobFormat.IMPORT_JOB_FORMAT_RVTOOLS_XLSX:
      return "IMPORT_JOB_FORMAT_RVTOOLS_XLSX";
    case ImportJobFormat.IMPORT_JOB_FORMAT_RVTOOLS_CSV:
      return "IMPORT_JOB_FORMAT_RVTOOLS_CSV";
    case ImportJobFormat.IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV:
      return "IMPORT_JOB_FORMAT_EXPORTED_AWS_CSV";
    case ImportJobFormat.IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV:
      return "IMPORT_JOB_FORMAT_EXPORTED_AZURE_CSV";
    case ImportJobFormat.IMPORT_JOB_FORMAT_STRATOZONE_CSV:
      return "IMPORT_JOB_FORMAT_STRATOZONE_CSV";
    case ImportJobFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the types of import job views that provide complete or partial
 * details of an import job.
 */
export enum ImportJobView {
  /**
   * IMPORT_JOB_VIEW_UNSPECIFIED - The import job view is not specified. The API displays the basic view by
   * default.
   */
  IMPORT_JOB_VIEW_UNSPECIFIED = 0,
  /**
   * IMPORT_JOB_VIEW_BASIC - The import job view includes basic metadata of an import job.
   * This view does not include payload information.
   */
  IMPORT_JOB_VIEW_BASIC = 1,
  /** IMPORT_JOB_VIEW_FULL - The import job view includes all metadata of an import job. */
  IMPORT_JOB_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function importJobViewFromJSON(object: any): ImportJobView {
  switch (object) {
    case 0:
    case "IMPORT_JOB_VIEW_UNSPECIFIED":
      return ImportJobView.IMPORT_JOB_VIEW_UNSPECIFIED;
    case 1:
    case "IMPORT_JOB_VIEW_BASIC":
      return ImportJobView.IMPORT_JOB_VIEW_BASIC;
    case 2:
    case "IMPORT_JOB_VIEW_FULL":
      return ImportJobView.IMPORT_JOB_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportJobView.UNRECOGNIZED;
  }
}

export function importJobViewToJSON(object: ImportJobView): string {
  switch (object) {
    case ImportJobView.IMPORT_JOB_VIEW_UNSPECIFIED:
      return "IMPORT_JOB_VIEW_UNSPECIFIED";
    case ImportJobView.IMPORT_JOB_VIEW_BASIC:
      return "IMPORT_JOB_VIEW_BASIC";
    case ImportJobView.IMPORT_JOB_VIEW_FULL:
      return "IMPORT_JOB_VIEW_FULL";
    case ImportJobView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ErrorFrameView can be specified in ErrorFrames List and Get requests to
 * control the level of details that is returned for the original frame.
 */
export enum ErrorFrameView {
  /** ERROR_FRAME_VIEW_UNSPECIFIED - Value is unset. The system will fallback to the default value. */
  ERROR_FRAME_VIEW_UNSPECIFIED = 0,
  /** ERROR_FRAME_VIEW_BASIC - Include basic frame data, but not the full contents. */
  ERROR_FRAME_VIEW_BASIC = 1,
  /** ERROR_FRAME_VIEW_FULL - Include everything. */
  ERROR_FRAME_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function errorFrameViewFromJSON(object: any): ErrorFrameView {
  switch (object) {
    case 0:
    case "ERROR_FRAME_VIEW_UNSPECIFIED":
      return ErrorFrameView.ERROR_FRAME_VIEW_UNSPECIFIED;
    case 1:
    case "ERROR_FRAME_VIEW_BASIC":
      return ErrorFrameView.ERROR_FRAME_VIEW_BASIC;
    case 2:
    case "ERROR_FRAME_VIEW_FULL":
      return ErrorFrameView.ERROR_FRAME_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorFrameView.UNRECOGNIZED;
  }
}

export function errorFrameViewToJSON(object: ErrorFrameView): string {
  switch (object) {
    case ErrorFrameView.ERROR_FRAME_VIEW_UNSPECIFIED:
      return "ERROR_FRAME_VIEW_UNSPECIFIED";
    case ErrorFrameView.ERROR_FRAME_VIEW_BASIC:
      return "ERROR_FRAME_VIEW_BASIC";
    case ErrorFrameView.ERROR_FRAME_VIEW_FULL:
      return "ERROR_FRAME_VIEW_FULL";
    case ErrorFrameView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The persistent disk (PD) types of Compute Engine virtual machines. */
export enum PersistentDiskType {
  /**
   * PERSISTENT_DISK_TYPE_UNSPECIFIED - Unspecified (default value).
   * Selecting this value allows the system to use any disk type according
   * to reported usage. This a good value to start with.
   */
  PERSISTENT_DISK_TYPE_UNSPECIFIED = 0,
  /** PERSISTENT_DISK_TYPE_STANDARD - Standard HDD Persistent Disk. */
  PERSISTENT_DISK_TYPE_STANDARD = 1,
  /** PERSISTENT_DISK_TYPE_BALANCED - Balanced Persistent Disk. */
  PERSISTENT_DISK_TYPE_BALANCED = 2,
  /** PERSISTENT_DISK_TYPE_SSD - SSD Persistent Disk. */
  PERSISTENT_DISK_TYPE_SSD = 3,
  UNRECOGNIZED = -1,
}

export function persistentDiskTypeFromJSON(object: any): PersistentDiskType {
  switch (object) {
    case 0:
    case "PERSISTENT_DISK_TYPE_UNSPECIFIED":
      return PersistentDiskType.PERSISTENT_DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PERSISTENT_DISK_TYPE_STANDARD":
      return PersistentDiskType.PERSISTENT_DISK_TYPE_STANDARD;
    case 2:
    case "PERSISTENT_DISK_TYPE_BALANCED":
      return PersistentDiskType.PERSISTENT_DISK_TYPE_BALANCED;
    case 3:
    case "PERSISTENT_DISK_TYPE_SSD":
      return PersistentDiskType.PERSISTENT_DISK_TYPE_SSD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PersistentDiskType.UNRECOGNIZED;
  }
}

export function persistentDiskTypeToJSON(object: PersistentDiskType): string {
  switch (object) {
    case PersistentDiskType.PERSISTENT_DISK_TYPE_UNSPECIFIED:
      return "PERSISTENT_DISK_TYPE_UNSPECIFIED";
    case PersistentDiskType.PERSISTENT_DISK_TYPE_STANDARD:
      return "PERSISTENT_DISK_TYPE_STANDARD";
    case PersistentDiskType.PERSISTENT_DISK_TYPE_BALANCED:
      return "PERSISTENT_DISK_TYPE_BALANCED";
    case PersistentDiskType.PERSISTENT_DISK_TYPE_SSD:
      return "PERSISTENT_DISK_TYPE_SSD";
    case PersistentDiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The License type for premium images (RHEL, RHEL for SAP, SLES, SLES for SAP,
 * Windows Server).
 */
export enum LicenseType {
  /** LICENSE_TYPE_UNSPECIFIED - Unspecified (default value). */
  LICENSE_TYPE_UNSPECIFIED = 0,
  /**
   * LICENSE_TYPE_DEFAULT - Default Google Cloud licensing plan. Licensing is charged per usage.
   * This a good value to start with.
   */
  LICENSE_TYPE_DEFAULT = 1,
  /** LICENSE_TYPE_BRING_YOUR_OWN_LICENSE - Bring-your-own-license (BYOL) plan. User provides the OS license. */
  LICENSE_TYPE_BRING_YOUR_OWN_LICENSE = 2,
  UNRECOGNIZED = -1,
}

export function licenseTypeFromJSON(object: any): LicenseType {
  switch (object) {
    case 0:
    case "LICENSE_TYPE_UNSPECIFIED":
      return LicenseType.LICENSE_TYPE_UNSPECIFIED;
    case 1:
    case "LICENSE_TYPE_DEFAULT":
      return LicenseType.LICENSE_TYPE_DEFAULT;
    case 2:
    case "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE":
      return LicenseType.LICENSE_TYPE_BRING_YOUR_OWN_LICENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LicenseType.UNRECOGNIZED;
  }
}

export function licenseTypeToJSON(object: LicenseType): string {
  switch (object) {
    case LicenseType.LICENSE_TYPE_UNSPECIFIED:
      return "LICENSE_TYPE_UNSPECIFIED";
    case LicenseType.LICENSE_TYPE_DEFAULT:
      return "LICENSE_TYPE_DEFAULT";
    case LicenseType.LICENSE_TYPE_BRING_YOUR_OWN_LICENSE:
      return "LICENSE_TYPE_BRING_YOUR_OWN_LICENSE";
    case LicenseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The sizing optimization strategy preferences of a virtual machine. This
 * strategy, in addition to actual usage data of the virtual machine, can help
 * determine the recommended shape on the target platform.
 */
export enum SizingOptimizationStrategy {
  /** SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED - Unspecified (default value). */
  SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED = 0,
  /**
   * SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE - No optimization applied. Virtual machine sizing matches as closely as
   * possible the machine shape on the source site, not considering any actual
   * performance data.
   */
  SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE = 1,
  /**
   * SIZING_OPTIMIZATION_STRATEGY_MODERATE - Virtual machine sizing will match the reported usage and shape, with some
   * slack. This a good value to start with.
   */
  SIZING_OPTIMIZATION_STRATEGY_MODERATE = 2,
  /**
   * SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE - Virtual machine sizing will match the reported usage, with little slack.
   * Using this option can help reduce costs.
   */
  SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE = 3,
  UNRECOGNIZED = -1,
}

export function sizingOptimizationStrategyFromJSON(object: any): SizingOptimizationStrategy {
  switch (object) {
    case 0:
    case "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED":
      return SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED;
    case 1:
    case "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE":
      return SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE;
    case 2:
    case "SIZING_OPTIMIZATION_STRATEGY_MODERATE":
      return SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_MODERATE;
    case 3:
    case "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE":
      return SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SizingOptimizationStrategy.UNRECOGNIZED;
  }
}

export function sizingOptimizationStrategyToJSON(object: SizingOptimizationStrategy): string {
  switch (object) {
    case SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED:
      return "SIZING_OPTIMIZATION_STRATEGY_UNSPECIFIED";
    case SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE:
      return "SIZING_OPTIMIZATION_STRATEGY_SAME_AS_SOURCE";
    case SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_MODERATE:
      return "SIZING_OPTIMIZATION_STRATEGY_MODERATE";
    case SizingOptimizationStrategy.SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE:
      return "SIZING_OPTIMIZATION_STRATEGY_AGGRESSIVE";
    case SizingOptimizationStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The plan of commitments for VM resource-based committed use discount (CUD). */
export enum CommitmentPlan {
  /** COMMITMENT_PLAN_UNSPECIFIED - Unspecified commitment plan. */
  COMMITMENT_PLAN_UNSPECIFIED = 0,
  /** COMMITMENT_PLAN_NONE - No commitment plan. */
  COMMITMENT_PLAN_NONE = 1,
  /** COMMITMENT_PLAN_ONE_YEAR - 1 year commitment. */
  COMMITMENT_PLAN_ONE_YEAR = 2,
  /** COMMITMENT_PLAN_THREE_YEARS - 3 years commitment. */
  COMMITMENT_PLAN_THREE_YEARS = 3,
  UNRECOGNIZED = -1,
}

export function commitmentPlanFromJSON(object: any): CommitmentPlan {
  switch (object) {
    case 0:
    case "COMMITMENT_PLAN_UNSPECIFIED":
      return CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED;
    case 1:
    case "COMMITMENT_PLAN_NONE":
      return CommitmentPlan.COMMITMENT_PLAN_NONE;
    case 2:
    case "COMMITMENT_PLAN_ONE_YEAR":
      return CommitmentPlan.COMMITMENT_PLAN_ONE_YEAR;
    case 3:
    case "COMMITMENT_PLAN_THREE_YEARS":
      return CommitmentPlan.COMMITMENT_PLAN_THREE_YEARS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommitmentPlan.UNRECOGNIZED;
  }
}

export function commitmentPlanToJSON(object: CommitmentPlan): string {
  switch (object) {
    case CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED:
      return "COMMITMENT_PLAN_UNSPECIFIED";
    case CommitmentPlan.COMMITMENT_PLAN_NONE:
      return "COMMITMENT_PLAN_NONE";
    case CommitmentPlan.COMMITMENT_PLAN_ONE_YEAR:
      return "COMMITMENT_PLAN_ONE_YEAR";
    case CommitmentPlan.COMMITMENT_PLAN_THREE_YEARS:
      return "COMMITMENT_PLAN_THREE_YEARS";
    case CommitmentPlan.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The preference for a specific Google Cloud product platform. */
export enum ComputeMigrationTargetProduct {
  /** COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED - Unspecified (default value). */
  COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED = 0,
  /** COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE - Prefer to migrate to Google Cloud Compute Engine. */
  COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE = 1,
  /** COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE - Prefer to migrate to Google Cloud VMware Engine. */
  COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE = 2,
  /** COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY - Prefer to migrate to Google Cloud Sole Tenant Nodes. */
  COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY = 3,
  UNRECOGNIZED = -1,
}

export function computeMigrationTargetProductFromJSON(object: any): ComputeMigrationTargetProduct {
  switch (object) {
    case 0:
    case "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED":
      return ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED;
    case 1:
    case "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE":
      return ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE;
    case 2:
    case "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE":
      return ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE;
    case 3:
    case "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY":
      return ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeMigrationTargetProduct.UNRECOGNIZED;
  }
}

export function computeMigrationTargetProductToJSON(object: ComputeMigrationTargetProduct): string {
  switch (object) {
    case ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED:
      return "COMPUTE_MIGRATION_TARGET_PRODUCT_UNSPECIFIED";
    case ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE:
      return "COMPUTE_MIGRATION_TARGET_PRODUCT_COMPUTE_ENGINE";
    case ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE:
      return "COMPUTE_MIGRATION_TARGET_PRODUCT_VMWARE_ENGINE";
    case ComputeMigrationTargetProduct.COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY:
      return "COMPUTE_MIGRATION_TARGET_PRODUCT_SOLE_TENANCY";
    case ComputeMigrationTargetProduct.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the types of views that provide complete or partial details
 * of a Report.
 */
export enum ReportView {
  /**
   * REPORT_VIEW_UNSPECIFIED - The report view is not specified. The API displays the basic view by
   * default.
   */
  REPORT_VIEW_UNSPECIFIED = 0,
  /**
   * REPORT_VIEW_BASIC - The report view includes only basic metadata of the Report. Useful for
   * list views.
   */
  REPORT_VIEW_BASIC = 1,
  /**
   * REPORT_VIEW_FULL - The report view includes all the metadata of the Report. Useful for
   * preview.
   */
  REPORT_VIEW_FULL = 2,
  /**
   * REPORT_VIEW_STANDARD - The report view includes the standard metadata of an report. Useful for
   * detail view.
   */
  REPORT_VIEW_STANDARD = 3,
  UNRECOGNIZED = -1,
}

export function reportViewFromJSON(object: any): ReportView {
  switch (object) {
    case 0:
    case "REPORT_VIEW_UNSPECIFIED":
      return ReportView.REPORT_VIEW_UNSPECIFIED;
    case 1:
    case "REPORT_VIEW_BASIC":
      return ReportView.REPORT_VIEW_BASIC;
    case 2:
    case "REPORT_VIEW_FULL":
      return ReportView.REPORT_VIEW_FULL;
    case 3:
    case "REPORT_VIEW_STANDARD":
      return ReportView.REPORT_VIEW_STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportView.UNRECOGNIZED;
  }
}

export function reportViewToJSON(object: ReportView): string {
  switch (object) {
    case ReportView.REPORT_VIEW_UNSPECIFIED:
      return "REPORT_VIEW_UNSPECIFIED";
    case ReportView.REPORT_VIEW_BASIC:
      return "REPORT_VIEW_BASIC";
    case ReportView.REPORT_VIEW_FULL:
      return "REPORT_VIEW_FULL";
    case ReportView.REPORT_VIEW_STANDARD:
      return "REPORT_VIEW_STANDARD";
    case ReportView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An asset represents a resource in your environment. Asset types include
 * virtual machines and databases.
 */
export interface Asset {
  /** Output only. The full name of the asset. */
  name: string;
  /** Output only. The timestamp when the asset was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the asset was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Generic asset attributes. */
  attributes: { [key: string]: string };
  /**
   * Output only. Asset information specific for virtual and physical
   * machines.
   */
  machineDetails?:
    | MachineDetails
    | undefined;
  /** Output only. The list of insights associated with the asset. */
  insightList:
    | InsightList
    | undefined;
  /** Output only. Performance data for the asset. */
  performanceData:
    | AssetPerformanceData
    | undefined;
  /** Output only. The list of sources contributing to the asset. */
  sources: string[];
  /** Output only. The list of groups that the asset is assigned to. */
  assignedGroups: string[];
}

export interface Asset_LabelsEntry {
  key: string;
  value: string;
}

export interface Asset_AttributesEntry {
  key: string;
  value: string;
}

/** The preferences that apply to all assets in a given context. */
export interface PreferenceSet {
  /** Output only. Name of the preference set. */
  name: string;
  /** Output only. The timestamp when the preference set was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the preference set was last updated. */
  updateTime:
    | Date
    | undefined;
  /** User-friendly display name. Maximum length is 63 characters. */
  displayName: string;
  /** A description of the preference set. */
  description: string;
  /** A set of preferences that applies to all virtual machines in the context. */
  virtualMachinePreferences: VirtualMachinePreferences | undefined;
}

/** A resource that represents the background job that imports asset frames. */
export interface ImportJob {
  /** Output only. The full name of the import job. */
  name: string;
  /** User-friendly display name. Maximum length is 63 characters. */
  displayName: string;
  /** Output only. The timestamp when the import job was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the import job was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the import job was completed. */
  completeTime:
    | Date
    | undefined;
  /** Output only. The state of the import job. */
  state: ImportJob_ImportJobState;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Required. Reference to a source. */
  assetSource: string;
  /** Output only. The report with the validation results of the import job. */
  validationReport?:
    | ValidationReport
    | undefined;
  /** Output only. The report with the results of running the import job. */
  executionReport?: ExecutionReport | undefined;
}

/** Enumerates possible states of an import job. */
export enum ImportJob_ImportJobState {
  /** IMPORT_JOB_STATE_UNSPECIFIED - Default value. */
  IMPORT_JOB_STATE_UNSPECIFIED = 0,
  /** IMPORT_JOB_STATE_PENDING - The import job is pending. */
  IMPORT_JOB_STATE_PENDING = 1,
  /** IMPORT_JOB_STATE_RUNNING - The processing of the import job is ongoing. */
  IMPORT_JOB_STATE_RUNNING = 2,
  /** IMPORT_JOB_STATE_COMPLETED - The import job processing has completed. */
  IMPORT_JOB_STATE_COMPLETED = 3,
  /** IMPORT_JOB_STATE_FAILED - The import job failed to be processed. */
  IMPORT_JOB_STATE_FAILED = 4,
  /** IMPORT_JOB_STATE_VALIDATING - The import job is being validated. */
  IMPORT_JOB_STATE_VALIDATING = 5,
  /** IMPORT_JOB_STATE_FAILED_VALIDATION - The import job contains blocking errors. */
  IMPORT_JOB_STATE_FAILED_VALIDATION = 6,
  /** IMPORT_JOB_STATE_READY - The validation of the job completed with no blocking errors. */
  IMPORT_JOB_STATE_READY = 7,
  UNRECOGNIZED = -1,
}

export function importJob_ImportJobStateFromJSON(object: any): ImportJob_ImportJobState {
  switch (object) {
    case 0:
    case "IMPORT_JOB_STATE_UNSPECIFIED":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_UNSPECIFIED;
    case 1:
    case "IMPORT_JOB_STATE_PENDING":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_PENDING;
    case 2:
    case "IMPORT_JOB_STATE_RUNNING":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_RUNNING;
    case 3:
    case "IMPORT_JOB_STATE_COMPLETED":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_COMPLETED;
    case 4:
    case "IMPORT_JOB_STATE_FAILED":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_FAILED;
    case 5:
    case "IMPORT_JOB_STATE_VALIDATING":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_VALIDATING;
    case 6:
    case "IMPORT_JOB_STATE_FAILED_VALIDATION":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_FAILED_VALIDATION;
    case 7:
    case "IMPORT_JOB_STATE_READY":
      return ImportJob_ImportJobState.IMPORT_JOB_STATE_READY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportJob_ImportJobState.UNRECOGNIZED;
  }
}

export function importJob_ImportJobStateToJSON(object: ImportJob_ImportJobState): string {
  switch (object) {
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_UNSPECIFIED:
      return "IMPORT_JOB_STATE_UNSPECIFIED";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_PENDING:
      return "IMPORT_JOB_STATE_PENDING";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_RUNNING:
      return "IMPORT_JOB_STATE_RUNNING";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_COMPLETED:
      return "IMPORT_JOB_STATE_COMPLETED";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_FAILED:
      return "IMPORT_JOB_STATE_FAILED";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_VALIDATING:
      return "IMPORT_JOB_STATE_VALIDATING";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_FAILED_VALIDATION:
      return "IMPORT_JOB_STATE_FAILED_VALIDATION";
    case ImportJob_ImportJobState.IMPORT_JOB_STATE_READY:
      return "IMPORT_JOB_STATE_READY";
    case ImportJob_ImportJobState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ImportJob_LabelsEntry {
  key: string;
  value: string;
}

/** A resource that represents a payload file in an import job. */
export interface ImportDataFile {
  /** Output only. The name of the file. */
  name: string;
  /** User-friendly display name. Maximum length is 63 characters. */
  displayName: string;
  /** Required. The payload format. */
  format: ImportJobFormat;
  /** Output only. The timestamp when the file was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The state of the import data file. */
  state: ImportDataFile_State;
  /** Information about a file that is uploaded to a storage service. */
  uploadFileInfo?: UploadFileInfo | undefined;
}

/** Enumerates possible states of an import data file. */
export enum ImportDataFile_State {
  /** STATE_UNSPECIFIED - Default value. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The data file is being created. */
  CREATING = 1,
  /** ACTIVE - The data file completed initialization. */
  ACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function importDataFile_StateFromJSON(object: any): ImportDataFile_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ImportDataFile_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return ImportDataFile_State.CREATING;
    case 2:
    case "ACTIVE":
      return ImportDataFile_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportDataFile_State.UNRECOGNIZED;
  }
}

export function importDataFile_StateToJSON(object: ImportDataFile_State): string {
  switch (object) {
    case ImportDataFile_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ImportDataFile_State.CREATING:
      return "CREATING";
    case ImportDataFile_State.ACTIVE:
      return "ACTIVE";
    case ImportDataFile_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A resource that represents an asset group.
 * The purpose of an asset group is to bundle a set of assets that have
 * something in common, while allowing users to add annotations to the group.
 * An asset can belong to multiple groups.
 */
export interface Group {
  /** Output only. The name of the group. */
  name: string;
  /** Output only. The timestamp when the group was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the group was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** User-friendly display name. */
  displayName: string;
  /** The description of the resource. */
  description: string;
}

export interface Group_LabelsEntry {
  key: string;
  value: string;
}

/** Message representing a frame which failed to be processed due to an error. */
export interface ErrorFrame {
  /** Output only. The identifier of the ErrorFrame. */
  name: string;
  /** Output only. All the violations that were detected for the frame. */
  violations: FrameViolationEntry[];
  /** Output only. The frame that was originally reported. */
  originalFrame:
    | AssetFrame
    | undefined;
  /** Output only. Frame ingestion time. */
  ingestionTime: Date | undefined;
}

/**
 * Source represents an object from which asset information is
 * streamed to Migration Center.
 */
export interface Source {
  /** Output only. The full name of the source. */
  name: string;
  /** Output only. The timestamp when the source was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the source was last updated. */
  updateTime:
    | Date
    | undefined;
  /** User-friendly display name. */
  displayName: string;
  /** Free-text description. */
  description: string;
  /** Data source type. */
  type: Source_SourceType;
  /**
   * The information confidence of the source.
   * The higher the value, the higher the confidence.
   */
  priority: number;
  /** If `true`, the source is managed by other service(s). */
  managed: boolean;
  /** Output only. Number of frames that are still being processed. */
  pendingFrameCount: number;
  /**
   * Output only. The number of frames that were reported by the source and
   * contained errors.
   */
  errorFrameCount: number;
  /** Output only. The state of the source. */
  state: Source_State;
}

export enum Source_SourceType {
  /** SOURCE_TYPE_UNKNOWN - Unspecified */
  SOURCE_TYPE_UNKNOWN = 0,
  /** SOURCE_TYPE_UPLOAD - Manually uploaded file (e.g. CSV) */
  SOURCE_TYPE_UPLOAD = 1,
  /** SOURCE_TYPE_GUEST_OS_SCAN - Guest-level info */
  SOURCE_TYPE_GUEST_OS_SCAN = 2,
  /** SOURCE_TYPE_INVENTORY_SCAN - Inventory-level scan */
  SOURCE_TYPE_INVENTORY_SCAN = 3,
  /** SOURCE_TYPE_CUSTOM - Third-party owned sources. */
  SOURCE_TYPE_CUSTOM = 4,
  UNRECOGNIZED = -1,
}

export function source_SourceTypeFromJSON(object: any): Source_SourceType {
  switch (object) {
    case 0:
    case "SOURCE_TYPE_UNKNOWN":
      return Source_SourceType.SOURCE_TYPE_UNKNOWN;
    case 1:
    case "SOURCE_TYPE_UPLOAD":
      return Source_SourceType.SOURCE_TYPE_UPLOAD;
    case 2:
    case "SOURCE_TYPE_GUEST_OS_SCAN":
      return Source_SourceType.SOURCE_TYPE_GUEST_OS_SCAN;
    case 3:
    case "SOURCE_TYPE_INVENTORY_SCAN":
      return Source_SourceType.SOURCE_TYPE_INVENTORY_SCAN;
    case 4:
    case "SOURCE_TYPE_CUSTOM":
      return Source_SourceType.SOURCE_TYPE_CUSTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Source_SourceType.UNRECOGNIZED;
  }
}

export function source_SourceTypeToJSON(object: Source_SourceType): string {
  switch (object) {
    case Source_SourceType.SOURCE_TYPE_UNKNOWN:
      return "SOURCE_TYPE_UNKNOWN";
    case Source_SourceType.SOURCE_TYPE_UPLOAD:
      return "SOURCE_TYPE_UPLOAD";
    case Source_SourceType.SOURCE_TYPE_GUEST_OS_SCAN:
      return "SOURCE_TYPE_GUEST_OS_SCAN";
    case Source_SourceType.SOURCE_TYPE_INVENTORY_SCAN:
      return "SOURCE_TYPE_INVENTORY_SCAN";
    case Source_SourceType.SOURCE_TYPE_CUSTOM:
      return "SOURCE_TYPE_CUSTOM";
    case Source_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumerates possible states of a source. */
export enum Source_State {
  /** STATE_UNSPECIFIED - Unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The source is active and ready to be used. */
  ACTIVE = 1,
  /** DELETING - In the process of being deleted. */
  DELETING = 2,
  /**
   * INVALID - Source is in an invalid state. Asset frames reported to it will be
   * ignored.
   */
  INVALID = 3,
  UNRECOGNIZED = -1,
}

export function source_StateFromJSON(object: any): Source_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Source_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Source_State.ACTIVE;
    case 2:
    case "DELETING":
      return Source_State.DELETING;
    case 3:
    case "INVALID":
      return Source_State.INVALID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Source_State.UNRECOGNIZED;
  }
}

export function source_StateToJSON(object: Source_State): string {
  switch (object) {
    case Source_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Source_State.ACTIVE:
      return "ACTIVE";
    case Source_State.DELETING:
      return "DELETING";
    case Source_State.INVALID:
      return "INVALID";
    case Source_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The groups and associated preference sets on which
 * we can generate reports.
 */
export interface ReportConfig {
  /** Output only. Name of resource. */
  name: string;
  /** Output only. The timestamp when the resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was last updated. */
  updateTime:
    | Date
    | undefined;
  /** User-friendly display name. Maximum length is 63 characters. */
  displayName: string;
  /** Free-text description. */
  description: string;
  /** Required. Collection of combinations of groups and preference sets. */
  groupPreferencesetAssignments: ReportConfig_GroupPreferenceSetAssignment[];
}

/** Represents a combination of a group with a preference set. */
export interface ReportConfig_GroupPreferenceSetAssignment {
  /** Required. Name of the group. */
  group: string;
  /** Required. Name of the Preference Set. */
  preferenceSet: string;
}

/** Report represents a point-in-time rendering of the ReportConfig results. */
export interface Report {
  /** Output only. Name of resource. */
  name: string;
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** User-friendly display name. Maximum length is 63 characters. */
  displayName: string;
  /** Free-text description. */
  description: string;
  /** Report type. */
  type: Report_Type;
  /** Report creation state. */
  state: Report_State;
  /** Output only. Summary view of the Report. */
  summary: ReportSummary | undefined;
}

/** Report type. */
export enum Report_Type {
  /** TYPE_UNSPECIFIED - Default Report type. */
  TYPE_UNSPECIFIED = 0,
  /** TOTAL_COST_OF_OWNERSHIP - Total cost of ownership Report type. */
  TOTAL_COST_OF_OWNERSHIP = 1,
  UNRECOGNIZED = -1,
}

export function report_TypeFromJSON(object: any): Report_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Report_Type.TYPE_UNSPECIFIED;
    case 1:
    case "TOTAL_COST_OF_OWNERSHIP":
      return Report_Type.TOTAL_COST_OF_OWNERSHIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Report_Type.UNRECOGNIZED;
  }
}

export function report_TypeToJSON(object: Report_Type): string {
  switch (object) {
    case Report_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Report_Type.TOTAL_COST_OF_OWNERSHIP:
      return "TOTAL_COST_OF_OWNERSHIP";
    case Report_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Report creation state. */
export enum Report_State {
  /** STATE_UNSPECIFIED - Default Report creation state. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - Creating Report. */
  PENDING = 1,
  /** SUCCEEDED - Successfully created Report. */
  SUCCEEDED = 2,
  /** FAILED - Failed to create Report. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function report_StateFromJSON(object: any): Report_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Report_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Report_State.PENDING;
    case 2:
    case "SUCCEEDED":
      return Report_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return Report_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Report_State.UNRECOGNIZED;
  }
}

export function report_StateToJSON(object: Report_State): string {
  switch (object) {
    case Report_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Report_State.PENDING:
      return "PENDING";
    case Report_State.SUCCEEDED:
      return "SUCCEEDED";
    case Report_State.FAILED:
      return "FAILED";
    case Report_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** Message for requesting a list of assets. */
export interface ListAssetsRequest {
  /** Required. Parent value for `ListAssetsRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
  /** View of the assets. Defaults to BASIC. */
  view: AssetView;
}

/** Response message for listing assets. */
export interface ListAssetsResponse {
  /** A list of assets. */
  assets: Asset[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Asset. */
export interface GetAssetRequest {
  /** Required. Name of the resource. */
  name: string;
  /** View of the assets. Defaults to BASIC. */
  view: AssetView;
}

/** A request to update an asset. */
export interface UpdateAssetRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Asset` resource by the update.
   * The values specified in the `update_mask` field are relative to the
   * resource, not the full request.
   * A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  asset:
    | Asset
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to update a list of assets. */
export interface BatchUpdateAssetsRequest {
  /** Required. Parent value for batch asset update. */
  parent: string;
  /**
   * Required. The request message specifying the resources to update.
   * A maximum of 1000 assets can be modified in a batch.
   */
  requests: UpdateAssetRequest[];
}

/** Response for updating a list of assets. */
export interface BatchUpdateAssetsResponse {
  /**
   * Update asset content.
   * The content only includes values after field mask being applied.
   */
  assets: Asset[];
}

/** A request to delete an asset. */
export interface DeleteAssetRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete a list of  asset. */
export interface BatchDeleteAssetsRequest {
  /** Required. Parent value for batch asset delete. */
  parent: string;
  /**
   * Required. The IDs of the assets to delete.
   * A maximum of 1000 assets can be deleted in a batch.
   * Format: projects/{project}/locations/{location}/assets/{name}.
   */
  names: string[];
  /**
   * Optional. When this value is set to `true` the request is a no-op for
   * non-existing assets. See https://google.aip.dev/135#delete-if-existing for
   * additional details. Default value is `false`.
   */
  allowMissing: boolean;
}

/** A request to report a set of asset frames. */
export interface ReportAssetFramesRequest {
  /** Required. Parent of the resource. */
  parent: string;
  /** Collection of frames data. */
  frames:
    | Frames
    | undefined;
  /** Required. Reference to a source. */
  source: string;
}

/** A response to a call to `ReportAssetFrame`. */
export interface ReportAssetFramesResponse {
}

/** A request to aggregate one or more values. */
export interface AggregateAssetsValuesRequest {
  /** Required. Parent value for `AggregateAssetsValuesRequest`. */
  parent: string;
  /**
   * Array of aggregations to perform.
   * Up to 25 aggregations can be defined.
   */
  aggregations: Aggregation[];
  /** The aggregation will be performed on assets that match the provided filter. */
  filter: string;
}

/** A response to a request to aggregated assets values. */
export interface AggregateAssetsValuesResponse {
  /** The aggregation results. */
  results: AggregationResult[];
}

/** A request to create an import job. */
export interface CreateImportJobRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. ID of the import job. */
  importJobId: string;
  /** Required. The resource being created. */
  importJob:
    | ImportJob
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to list import jobs. */
export interface ListImportJobsRequest {
  /** Required. Parent value for `ListImportJobsRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
  /**
   * Optional. The level of details of each import job.
   * Default value is BASIC.
   */
  view: ImportJobView;
}

/** A response for listing import jobs. */
export interface ListImportJobsResponse {
  /** The list of import jobs. */
  importJobs: ImportJob[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to get an import job. */
export interface GetImportJobRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. The level of details of the import job.
   * Default value is FULL.
   */
  view: ImportJobView;
}

/** A request to delete an import job. */
export interface DeleteImportJobRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to `true`, any `ImportDataFiles` of this job will also be
   * deleted If set to `false`, the request only works if the job has no data
   * files.
   */
  force: boolean;
}

/** A request to update an import job. */
export interface UpdateImportJobRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Asset` resource by the update.
   * The values specified in the `update_mask` field are relative to the
   * resource, not the full request.
   * A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  importJob:
    | ImportJob
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to validate an import job. */
export interface ValidateImportJobRequest {
  /** Required. The name of the import job to validate. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to run an import job. */
export interface RunImportJobRequest {
  /** Required. The name of the import job to run. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to get an import data file. */
export interface GetImportDataFileRequest {
  /** Required. Name of the ImportDataFile. */
  name: string;
}

/** A request to list import data files of an import job. */
export interface ListImportDataFilesRequest {
  /** Required. Name of the parent of the `ImportDataFiles` resource. */
  parent: string;
  /**
   * The maximum number of data files to return. The service may return
   * fewer than this value. If unspecified, at most 500 data files will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListImportDataFiles` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListImportDataFiles`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** Response for listing payload files of an import job. */
export interface ListImportDataFilesResponse {
  /** The list of import data files. */
  importDataFiles: ImportDataFile[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to create an `ImportDataFile` resource. */
export interface CreateImportDataFileRequest {
  /** Required. Name of the parent of the ImportDataFile. */
  parent: string;
  /** Required. The ID of the new data file. */
  importDataFileId: string;
  /** Required. The resource being created. */
  importDataFile:
    | ImportDataFile
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete an `ImportDataFile` resource. */
export interface DeleteImportDataFileRequest {
  /** Required. Name of the ImportDataFile to delete. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to list groups. */
export interface ListGroupsRequest {
  /** Required. Parent value for `ListGroupsRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** A response for listing groups. */
export interface ListGroupsResponse {
  /** The list of Group */
  groups: Group[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to get a group. */
export interface GetGroupRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** A request to create a group. */
export interface CreateGroupRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. User specified ID for the group. It will become the last
   * component of the group name. The ID must be unique within the project, must
   * conform with RFC-1034, is restricted to lower-cased letters, and has a
   * maximum length of 63 characters. The ID must match the regular expression:
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  groupId: string;
  /** Required. The group resource being created. */
  group:
    | Group
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to update a group. */
export interface UpdateGroupRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Group` resource by the update.
   * The values specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The group resource being updated. */
  group:
    | Group
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete a group. */
export interface DeleteGroupRequest {
  /** Required. Name of the group resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to add assets to a group. */
export interface AddAssetsToGroupRequest {
  /** Required. Group reference. */
  group: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Required. List of assets to be added.
   * The maximum number of assets that can be added in a single request is
   * 1000.
   */
  assets:
    | AssetList
    | undefined;
  /**
   * Optional. When this value is set to `false` and one of the given assets is
   * already an existing member of the group, the operation fails with an
   * `Already Exists` error. When set to `true` this situation is silently
   * ignored by the server.
   *
   * Default value is `false`.
   */
  allowExisting: boolean;
}

/** A request to remove assets from a group. */
export interface RemoveAssetsFromGroupRequest {
  /** Required. Group reference. */
  group: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Required. List of assets to be removed.
   * The maximum number of assets that can be removed in a single request is
   * 1000.
   */
  assets:
    | AssetList
    | undefined;
  /**
   * Optional. When this value is set to `false` and one of the given assets is
   * not an existing member of the group, the operation fails with a `Not Found`
   * error. When set to `true` this situation is silently ignored by the server.
   *
   * Default value is `false`.
   */
  allowMissing: boolean;
}

/** A request to list error frames for a source. */
export interface ListErrorFramesRequest {
  /** Required. Parent value (the source) for `ListErrorFramesRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /**
   * Optional. An optional view mode to control the level of details of each
   * error frame. The default is a BASIC frame view.
   */
  view: ErrorFrameView;
}

/** A response for listing error frames. */
export interface ListErrorFramesResponse {
  /** The list of error frames. */
  errorFrames: ErrorFrame[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

export interface GetErrorFrameRequest {
  /**
   * Required. The name of the frame to retrieve.
   * Format:
   * projects/{project}/locations/{location}/sources/{source}/errorFrames/{error_frame}
   */
  name: string;
  /**
   * Optional. An optional view mode to control the level of details for the
   * frame. The default is a basic frame view.
   */
  view: ErrorFrameView;
}

/** A request for a list of sources. */
export interface ListSourcesRequest {
  /** Required. Parent value for `ListSourcesRequest`. */
  parent: string;
  /**
   * Requested page size. The server may return fewer items than requested.
   * If unspecified, the server will pick an appropriate default value.
   */
  pageSize: number;
  /** A token identifying a page of results that the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** Response message for listing sources. */
export interface ListSourcesResponse {
  /** The list of sources. */
  sources: Source[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to get a source. */
export interface GetSourceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** A request to create a source. */
export interface CreateSourceRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. User specified ID for the source. It will become the last
   * component of the source name. The ID must be unique within the project,
   * must conform with RFC-1034, is restricted to lower-cased letters, and has a
   * maximum length of 63 characters. The ID must match the regular expression:
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  sourceId: string;
  /** Required. The resource being created. */
  source:
    | Source
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to update a source. */
export interface UpdateSourceRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Source` resource by the update.
   * The values specified in the `update_mask` field are relative to the
   * resource, not the full request.
   * A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  source:
    | Source
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete a source. */
export interface DeleteSourceRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request for listing preference sets. */
export interface ListPreferenceSetsRequest {
  /** Required. Parent value for `ListPreferenceSetsRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, at most 500 preference sets will be returned.
   * The maximum value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** Response message for listing preference sets. */
export interface ListPreferenceSetsResponse {
  /** The list of PreferenceSets */
  preferenceSets: PreferenceSet[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to get a preference set. */
export interface GetPreferenceSetRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** A request to create a preference set. */
export interface CreatePreferenceSetRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. User specified ID for the preference set. It will become the last
   * component of the preference set name. The ID must be unique within the
   * project, must conform with RFC-1034, is restricted to lower-cased letters,
   * and has a maximum length of 63 characters. The ID must match the regular
   * expression
   * `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   */
  preferenceSetId: string;
  /** Required. The preference set resource being created. */
  preferenceSet:
    | PreferenceSet
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to update a preference set. */
export interface UpdatePreferenceSetRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `PreferenceSet` resource by the update.
   * The values specified in the `update_mask` field are relative to the
   * resource, not the full request.
   * A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The preference set resource being updated. */
  preferenceSet:
    | PreferenceSet
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete a preference set. */
export interface DeletePreferenceSetRequest {
  /** Required. Name of the group resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to get the settings. */
export interface GetSettingsRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** A request to update the settings. */
export interface UpdateSettingsRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Settings` resource by the update.
   * The values specified in the `update_mask` field are relative to the
   * resource, not the full request.
   * A field will be overwritten if it is in the mask.
   * A single * value in the mask lets you to overwrite all fields.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The project settings resource being updated. */
  settings:
    | Settings
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to create a `ReportConfig` resource. */
export interface CreateReportConfigRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. User specified ID for the report config. It will become the last
   * component of the report config name. The ID must be unique within the
   * project, must conform with RFC-1034, is restricted to lower-cased letters,
   * and has a maximum length of 63 characters. The ID must match the regular
   * expression: [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
   */
  reportConfigId: string;
  /** Required. The report config set resource being created. */
  reportConfig:
    | ReportConfig
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to delete a ReportConfig. */
export interface DeleteReportConfigRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to `true`, any child `Reports` of this entity will also be
   * deleted. If set to `false`, the request only works if the resource has no
   * children.
   */
  force: boolean;
}

/** A request to get a Report. */
export interface GetReportRequest {
  /** Required. Name of the resource. */
  name: string;
  /** Determines what information to retrieve for the Report. */
  view: ReportView;
}

/** A request for a list of Reports. */
export interface ListReportsRequest {
  /** Required. Parent value for `ListReportsRequest`. */
  parent: string;
  /**
   * Requested page size. The server may return fewer items than requested.
   * If unspecified, the server will pick an appropriate default value.
   */
  pageSize: number;
  /** A token identifying a page of results that the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
  /** Determines what information to retrieve for each Report. */
  view: ReportView;
}

/** Response message for listing Reports. */
export interface ListReportsResponse {
  /** The list of Reports. */
  reports: Report[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A request to delete a Report. */
export interface DeleteReportRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** A request to get a `ReportConfig` resource. */
export interface GetReportConfigRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** A request to get a list of `ReportConfig` resources. */
export interface ListReportConfigsRequest {
  /** Required. Parent value for `ListReportConfigsRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Field to sort by. See https://google.aip.dev/132#ordering for more details. */
  orderBy: string;
}

/** Response message for listing report configs. */
export interface ListReportConfigsResponse {
  /** A list of report configs. */
  reportConfigs: ReportConfig[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for creating a Report. */
export interface CreateReportRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. User specified id for the report. It will become the last
   * component of the report name. The id must be unique within the project,
   * must conform with RFC-1034, is restricted to lower-cased letters, and has a
   * maximum length of 63 characters. The id must match the regular expression:
   * [a-z]([a-z0-9-]{0,61}[a-z0-9])?.
   */
  reportId: string;
  /** Required. The report resource being created. */
  report:
    | Report
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Collection of frame data. */
export interface Frames {
  /** A repeated field of asset data. */
  framesData: AssetFrame[];
}

/** Contains data reported from an inventory source on an asset. */
export interface AssetFrame {
  /** Asset information specific for virtual machines. */
  machineDetails?:
    | MachineDetails
    | undefined;
  /** The time the data was reported. */
  reportTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Generic asset attributes. */
  attributes: { [key: string]: string };
  /**
   * Asset performance data samples.
   * Samples that are from more than 40 days ago or after tomorrow are ignored.
   */
  performanceSamples: PerformanceSample[];
  /**
   * Optional. Trace token is optionally provided to assist with debugging and
   * traceability.
   */
  traceToken: string;
}

export interface AssetFrame_LabelsEntry {
  key: string;
  value: string;
}

export interface AssetFrame_AttributesEntry {
  key: string;
  value: string;
}

/** Details of a machine. */
export interface MachineDetails {
  /** Machine unique identifier. */
  uuid: string;
  /** Machine name. */
  machineName: string;
  /** Machine creation time. */
  createTime:
    | Date
    | undefined;
  /** Number of CPU cores in the machine. Must be non-negative. */
  coreCount: number;
  /** The amount of memory in the machine. Must be non-negative. */
  memoryMb: number;
  /** Power state of the machine. */
  powerState: MachineDetails_PowerState;
  /** Architecture details (vendor, CPU architecture). */
  architecture:
    | MachineArchitectureDetails
    | undefined;
  /** Guest OS information. */
  guestOs:
    | GuestOsDetails
    | undefined;
  /** Network details. */
  network:
    | MachineNetworkDetails
    | undefined;
  /** Disk details. */
  disks:
    | MachineDiskDetails
    | undefined;
  /** Platform specific information. */
  platform: PlatformDetails | undefined;
}

/** Machine power state. */
export enum MachineDetails_PowerState {
  /** POWER_STATE_UNSPECIFIED - Power state is unknown. */
  POWER_STATE_UNSPECIFIED = 0,
  /**
   * PENDING - The machine is preparing to enter the ACTIVE state. An instance may enter
   * the PENDING state when it launches for the first time, or when it is
   * started after being in the SUSPENDED state.
   */
  PENDING = 1,
  /** ACTIVE - The machine is active. */
  ACTIVE = 2,
  /** SUSPENDING - The machine is being turned off. */
  SUSPENDING = 3,
  /** SUSPENDED - The machine is off. */
  SUSPENDED = 4,
  /** DELETING - The machine is being deleted from the hosting platform. */
  DELETING = 5,
  /** DELETED - The machine is deleted from the hosting platform. */
  DELETED = 6,
  UNRECOGNIZED = -1,
}

export function machineDetails_PowerStateFromJSON(object: any): MachineDetails_PowerState {
  switch (object) {
    case 0:
    case "POWER_STATE_UNSPECIFIED":
      return MachineDetails_PowerState.POWER_STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return MachineDetails_PowerState.PENDING;
    case 2:
    case "ACTIVE":
      return MachineDetails_PowerState.ACTIVE;
    case 3:
    case "SUSPENDING":
      return MachineDetails_PowerState.SUSPENDING;
    case 4:
    case "SUSPENDED":
      return MachineDetails_PowerState.SUSPENDED;
    case 5:
    case "DELETING":
      return MachineDetails_PowerState.DELETING;
    case 6:
    case "DELETED":
      return MachineDetails_PowerState.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MachineDetails_PowerState.UNRECOGNIZED;
  }
}

export function machineDetails_PowerStateToJSON(object: MachineDetails_PowerState): string {
  switch (object) {
    case MachineDetails_PowerState.POWER_STATE_UNSPECIFIED:
      return "POWER_STATE_UNSPECIFIED";
    case MachineDetails_PowerState.PENDING:
      return "PENDING";
    case MachineDetails_PowerState.ACTIVE:
      return "ACTIVE";
    case MachineDetails_PowerState.SUSPENDING:
      return "SUSPENDING";
    case MachineDetails_PowerState.SUSPENDED:
      return "SUSPENDED";
    case MachineDetails_PowerState.DELETING:
      return "DELETING";
    case MachineDetails_PowerState.DELETED:
      return "DELETED";
    case MachineDetails_PowerState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the machine architecture. */
export interface MachineArchitectureDetails {
  /** CPU architecture, e.g., "x64-based PC", "x86_64", "i686" etc. */
  cpuArchitecture: string;
  /** CPU name, e.g., "Intel Xeon E5-2690", "AMD EPYC 7571" etc. */
  cpuName: string;
  /** Hardware vendor. */
  vendor: string;
  /** Number of CPU threads allocated to the machine. */
  cpuThreadCount: number;
  /** Number of processor sockets allocated to the machine. */
  cpuSocketCount: number;
  /** BIOS Details. */
  bios:
    | BiosDetails
    | undefined;
  /** Firmware type. */
  firmwareType: MachineArchitectureDetails_FirmwareType;
  /** CPU hyper-threading support. */
  hyperthreading: MachineArchitectureDetails_CpuHyperThreading;
}

/** Firmware type. */
export enum MachineArchitectureDetails_FirmwareType {
  /** FIRMWARE_TYPE_UNSPECIFIED - Unspecified or unknown. */
  FIRMWARE_TYPE_UNSPECIFIED = 0,
  /** BIOS - BIOS firmware. */
  BIOS = 1,
  /** EFI - EFI firmware. */
  EFI = 2,
  UNRECOGNIZED = -1,
}

export function machineArchitectureDetails_FirmwareTypeFromJSON(object: any): MachineArchitectureDetails_FirmwareType {
  switch (object) {
    case 0:
    case "FIRMWARE_TYPE_UNSPECIFIED":
      return MachineArchitectureDetails_FirmwareType.FIRMWARE_TYPE_UNSPECIFIED;
    case 1:
    case "BIOS":
      return MachineArchitectureDetails_FirmwareType.BIOS;
    case 2:
    case "EFI":
      return MachineArchitectureDetails_FirmwareType.EFI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MachineArchitectureDetails_FirmwareType.UNRECOGNIZED;
  }
}

export function machineArchitectureDetails_FirmwareTypeToJSON(object: MachineArchitectureDetails_FirmwareType): string {
  switch (object) {
    case MachineArchitectureDetails_FirmwareType.FIRMWARE_TYPE_UNSPECIFIED:
      return "FIRMWARE_TYPE_UNSPECIFIED";
    case MachineArchitectureDetails_FirmwareType.BIOS:
      return "BIOS";
    case MachineArchitectureDetails_FirmwareType.EFI:
      return "EFI";
    case MachineArchitectureDetails_FirmwareType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CPU hyper-threading support. */
export enum MachineArchitectureDetails_CpuHyperThreading {
  /** CPU_HYPER_THREADING_UNSPECIFIED - Unspecified or unknown. */
  CPU_HYPER_THREADING_UNSPECIFIED = 0,
  /** DISABLED - Hyper-threading is disabled. */
  DISABLED = 1,
  /** ENABLED - Hyper-threading is enabled. */
  ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function machineArchitectureDetails_CpuHyperThreadingFromJSON(
  object: any,
): MachineArchitectureDetails_CpuHyperThreading {
  switch (object) {
    case 0:
    case "CPU_HYPER_THREADING_UNSPECIFIED":
      return MachineArchitectureDetails_CpuHyperThreading.CPU_HYPER_THREADING_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return MachineArchitectureDetails_CpuHyperThreading.DISABLED;
    case 2:
    case "ENABLED":
      return MachineArchitectureDetails_CpuHyperThreading.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MachineArchitectureDetails_CpuHyperThreading.UNRECOGNIZED;
  }
}

export function machineArchitectureDetails_CpuHyperThreadingToJSON(
  object: MachineArchitectureDetails_CpuHyperThreading,
): string {
  switch (object) {
    case MachineArchitectureDetails_CpuHyperThreading.CPU_HYPER_THREADING_UNSPECIFIED:
      return "CPU_HYPER_THREADING_UNSPECIFIED";
    case MachineArchitectureDetails_CpuHyperThreading.DISABLED:
      return "DISABLED";
    case MachineArchitectureDetails_CpuHyperThreading.ENABLED:
      return "ENABLED";
    case MachineArchitectureDetails_CpuHyperThreading.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about the BIOS. */
export interface BiosDetails {
  /**
   * BIOS name.
   * This fields is deprecated. Please use the `id` field instead.
   *
   * @deprecated
   */
  biosName: string;
  /** BIOS ID. */
  id: string;
  /** BIOS manufacturer. */
  manufacturer: string;
  /** BIOS version. */
  version: string;
  /** BIOS release date. */
  releaseDate:
    | DateMessage
    | undefined;
  /** SMBIOS UUID. */
  smbiosUuid: string;
}

/** Details of network adapters and settings. */
export interface MachineNetworkDetails {
  /** The primary IP address of the machine. */
  primaryIpAddress: string;
  /** The public IP address of the machine. */
  publicIpAddress: string;
  /**
   * MAC address of the machine.
   * This property is used to uniqly identify the machine.
   */
  primaryMacAddress: string;
  /** List of network adapters. */
  adapters: NetworkAdapterList | undefined;
}

/** List of network adapters. */
export interface NetworkAdapterList {
  /** Network adapter entries. */
  entries: NetworkAdapterDetails[];
}

/** Details of network adapter. */
export interface NetworkAdapterDetails {
  /** Network adapter type (e.g. VMXNET3). */
  adapterType: string;
  /** MAC address. */
  macAddress: string;
  /** NetworkAddressList */
  addresses: NetworkAddressList | undefined;
}

/** List of allocated/assigned network addresses. */
export interface NetworkAddressList {
  /** Network address entries. */
  entries: NetworkAddress[];
}

/** Details of network address. */
export interface NetworkAddress {
  /** Assigned or configured IP Address. */
  ipAddress: string;
  /** Subnet mask. */
  subnetMask: string;
  /** Broadcast address. */
  bcast: string;
  /** Fully qualified domain name. */
  fqdn: string;
  /** Whether DHCP is used to assign addresses. */
  assignment: NetworkAddress_AddressAssignment;
}

/** Network address assignment. */
export enum NetworkAddress_AddressAssignment {
  /** ADDRESS_ASSIGNMENT_UNSPECIFIED - Unknown (default value). */
  ADDRESS_ASSIGNMENT_UNSPECIFIED = 0,
  /** ADDRESS_ASSIGNMENT_STATIC - Staticly assigned IP. */
  ADDRESS_ASSIGNMENT_STATIC = 1,
  /** ADDRESS_ASSIGNMENT_DHCP - Dynamically assigned IP (DHCP). */
  ADDRESS_ASSIGNMENT_DHCP = 2,
  UNRECOGNIZED = -1,
}

export function networkAddress_AddressAssignmentFromJSON(object: any): NetworkAddress_AddressAssignment {
  switch (object) {
    case 0:
    case "ADDRESS_ASSIGNMENT_UNSPECIFIED":
      return NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_UNSPECIFIED;
    case 1:
    case "ADDRESS_ASSIGNMENT_STATIC":
      return NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_STATIC;
    case 2:
    case "ADDRESS_ASSIGNMENT_DHCP":
      return NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_DHCP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkAddress_AddressAssignment.UNRECOGNIZED;
  }
}

export function networkAddress_AddressAssignmentToJSON(object: NetworkAddress_AddressAssignment): string {
  switch (object) {
    case NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_UNSPECIFIED:
      return "ADDRESS_ASSIGNMENT_UNSPECIFIED";
    case NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_STATIC:
      return "ADDRESS_ASSIGNMENT_STATIC";
    case NetworkAddress_AddressAssignment.ADDRESS_ASSIGNMENT_DHCP:
      return "ADDRESS_ASSIGNMENT_DHCP";
    case NetworkAddress_AddressAssignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of machine disks. */
export interface MachineDiskDetails {
  /** Disk total Capacity. */
  totalCapacityBytes: Long;
  /** Total disk free space. */
  totalFreeBytes: Long;
  /** List of disks. */
  disks: DiskEntryList | undefined;
}

/** VM disks. */
export interface DiskEntryList {
  /** Disk entries. */
  entries: DiskEntry[];
}

/** Single disk entry. */
export interface DiskEntry {
  /** Disk capacity. */
  capacityBytes: Long;
  /** Disk free space. */
  freeBytes: Long;
  /** Disk label. */
  diskLabel: string;
  /** Disk label type (e.g. BIOS/GPT) */
  diskLabelType: string;
  /** Disks interface type. */
  interfaceType: DiskEntry_InterfaceType;
  /** Partition layout. */
  partitions:
    | DiskPartitionList
    | undefined;
  /** Disk hardware address (e.g. 0:1 for SCSI). */
  hwAddress: string;
  /** VMware disk details. */
  vmware?: VmwareDiskConfig | undefined;
}

/** Disks interface type. */
export enum DiskEntry_InterfaceType {
  /** INTERFACE_TYPE_UNSPECIFIED - Interface type unknown or unspecified. */
  INTERFACE_TYPE_UNSPECIFIED = 0,
  /** IDE - IDE interface type. */
  IDE = 1,
  /** SATA - SATA interface type. */
  SATA = 2,
  /** SAS - SAS interface type. */
  SAS = 3,
  /** SCSI - SCSI interface type. */
  SCSI = 4,
  /** NVME - NVME interface type. */
  NVME = 5,
  /** FC - FC interface type. */
  FC = 6,
  /** ISCSI - iSCSI interface type. */
  ISCSI = 7,
  UNRECOGNIZED = -1,
}

export function diskEntry_InterfaceTypeFromJSON(object: any): DiskEntry_InterfaceType {
  switch (object) {
    case 0:
    case "INTERFACE_TYPE_UNSPECIFIED":
      return DiskEntry_InterfaceType.INTERFACE_TYPE_UNSPECIFIED;
    case 1:
    case "IDE":
      return DiskEntry_InterfaceType.IDE;
    case 2:
    case "SATA":
      return DiskEntry_InterfaceType.SATA;
    case 3:
    case "SAS":
      return DiskEntry_InterfaceType.SAS;
    case 4:
    case "SCSI":
      return DiskEntry_InterfaceType.SCSI;
    case 5:
    case "NVME":
      return DiskEntry_InterfaceType.NVME;
    case 6:
    case "FC":
      return DiskEntry_InterfaceType.FC;
    case 7:
    case "ISCSI":
      return DiskEntry_InterfaceType.ISCSI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskEntry_InterfaceType.UNRECOGNIZED;
  }
}

export function diskEntry_InterfaceTypeToJSON(object: DiskEntry_InterfaceType): string {
  switch (object) {
    case DiskEntry_InterfaceType.INTERFACE_TYPE_UNSPECIFIED:
      return "INTERFACE_TYPE_UNSPECIFIED";
    case DiskEntry_InterfaceType.IDE:
      return "IDE";
    case DiskEntry_InterfaceType.SATA:
      return "SATA";
    case DiskEntry_InterfaceType.SAS:
      return "SAS";
    case DiskEntry_InterfaceType.SCSI:
      return "SCSI";
    case DiskEntry_InterfaceType.NVME:
      return "NVME";
    case DiskEntry_InterfaceType.FC:
      return "FC";
    case DiskEntry_InterfaceType.ISCSI:
      return "ISCSI";
    case DiskEntry_InterfaceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Disk partition list. */
export interface DiskPartitionList {
  /** Partition entries. */
  entries: DiskPartition[];
}

/** Disk Partition details. */
export interface DiskPartition {
  /** Partition type. */
  type: string;
  /** Partition file system. */
  fileSystem: string;
  /** Mount pount (Linux/Windows) or drive letter (Windows). */
  mountPoint: string;
  /** Partition capacity. */
  capacityBytes: Long;
  /** Partition free space. */
  freeBytes: Long;
  /** Partition UUID. */
  uuid: string;
  /** Sub-partitions. */
  subPartitions: DiskPartitionList | undefined;
}

/** VMware disk config details. */
export interface VmwareDiskConfig {
  /** VMDK backing type. */
  backingType: VmwareDiskConfig_BackingType;
  /** Is VMDK shared with other VMs. */
  shared: boolean;
  /** VMDK disk mode. */
  vmdkMode: VmwareDiskConfig_VmdkMode;
  /** RDM compatibility mode. */
  rdmCompatibility: VmwareDiskConfig_RdmCompatibility;
}

/** VMDK backing type possible values. */
export enum VmwareDiskConfig_BackingType {
  /** BACKING_TYPE_UNSPECIFIED - Default value. */
  BACKING_TYPE_UNSPECIFIED = 0,
  /** BACKING_TYPE_FLAT_V1 - Flat v1. */
  BACKING_TYPE_FLAT_V1 = 1,
  /** BACKING_TYPE_FLAT_V2 - Flat v2. */
  BACKING_TYPE_FLAT_V2 = 2,
  /** BACKING_TYPE_PMEM - Persistent memory, also known as Non-Volatile Memory (NVM). */
  BACKING_TYPE_PMEM = 3,
  /** BACKING_TYPE_RDM_V1 - Raw Disk Memory v1. */
  BACKING_TYPE_RDM_V1 = 4,
  /** BACKING_TYPE_RDM_V2 - Raw Disk Memory v2. */
  BACKING_TYPE_RDM_V2 = 5,
  /** BACKING_TYPE_SESPARSE - SEsparse is a snapshot format introduced in vSphere 5.5 for large disks. */
  BACKING_TYPE_SESPARSE = 6,
  /** BACKING_TYPE_SESPARSE_V1 - SEsparse v1. */
  BACKING_TYPE_SESPARSE_V1 = 7,
  /** BACKING_TYPE_SESPARSE_V2 - SEsparse v1. */
  BACKING_TYPE_SESPARSE_V2 = 8,
  UNRECOGNIZED = -1,
}

export function vmwareDiskConfig_BackingTypeFromJSON(object: any): VmwareDiskConfig_BackingType {
  switch (object) {
    case 0:
    case "BACKING_TYPE_UNSPECIFIED":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_UNSPECIFIED;
    case 1:
    case "BACKING_TYPE_FLAT_V1":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_FLAT_V1;
    case 2:
    case "BACKING_TYPE_FLAT_V2":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_FLAT_V2;
    case 3:
    case "BACKING_TYPE_PMEM":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_PMEM;
    case 4:
    case "BACKING_TYPE_RDM_V1":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_RDM_V1;
    case 5:
    case "BACKING_TYPE_RDM_V2":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_RDM_V2;
    case 6:
    case "BACKING_TYPE_SESPARSE":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE;
    case 7:
    case "BACKING_TYPE_SESPARSE_V1":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE_V1;
    case 8:
    case "BACKING_TYPE_SESPARSE_V2":
      return VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareDiskConfig_BackingType.UNRECOGNIZED;
  }
}

export function vmwareDiskConfig_BackingTypeToJSON(object: VmwareDiskConfig_BackingType): string {
  switch (object) {
    case VmwareDiskConfig_BackingType.BACKING_TYPE_UNSPECIFIED:
      return "BACKING_TYPE_UNSPECIFIED";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_FLAT_V1:
      return "BACKING_TYPE_FLAT_V1";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_FLAT_V2:
      return "BACKING_TYPE_FLAT_V2";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_PMEM:
      return "BACKING_TYPE_PMEM";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_RDM_V1:
      return "BACKING_TYPE_RDM_V1";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_RDM_V2:
      return "BACKING_TYPE_RDM_V2";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE:
      return "BACKING_TYPE_SESPARSE";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE_V1:
      return "BACKING_TYPE_SESPARSE_V1";
    case VmwareDiskConfig_BackingType.BACKING_TYPE_SESPARSE_V2:
      return "BACKING_TYPE_SESPARSE_V2";
    case VmwareDiskConfig_BackingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VMDK disk mode. */
export enum VmwareDiskConfig_VmdkMode {
  /** VMDK_MODE_UNSPECIFIED - VMDK disk mode unspecified or unknown. */
  VMDK_MODE_UNSPECIFIED = 0,
  /** DEPENDENT - Dependent disk mode. */
  DEPENDENT = 1,
  /** INDEPENDENT_PERSISTENT - Independent - Persistent disk mode. */
  INDEPENDENT_PERSISTENT = 2,
  /** INDEPENDENT_NONPERSISTENT - Independent - Nonpersistent disk mode. */
  INDEPENDENT_NONPERSISTENT = 3,
  UNRECOGNIZED = -1,
}

export function vmwareDiskConfig_VmdkModeFromJSON(object: any): VmwareDiskConfig_VmdkMode {
  switch (object) {
    case 0:
    case "VMDK_MODE_UNSPECIFIED":
      return VmwareDiskConfig_VmdkMode.VMDK_MODE_UNSPECIFIED;
    case 1:
    case "DEPENDENT":
      return VmwareDiskConfig_VmdkMode.DEPENDENT;
    case 2:
    case "INDEPENDENT_PERSISTENT":
      return VmwareDiskConfig_VmdkMode.INDEPENDENT_PERSISTENT;
    case 3:
    case "INDEPENDENT_NONPERSISTENT":
      return VmwareDiskConfig_VmdkMode.INDEPENDENT_NONPERSISTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareDiskConfig_VmdkMode.UNRECOGNIZED;
  }
}

export function vmwareDiskConfig_VmdkModeToJSON(object: VmwareDiskConfig_VmdkMode): string {
  switch (object) {
    case VmwareDiskConfig_VmdkMode.VMDK_MODE_UNSPECIFIED:
      return "VMDK_MODE_UNSPECIFIED";
    case VmwareDiskConfig_VmdkMode.DEPENDENT:
      return "DEPENDENT";
    case VmwareDiskConfig_VmdkMode.INDEPENDENT_PERSISTENT:
      return "INDEPENDENT_PERSISTENT";
    case VmwareDiskConfig_VmdkMode.INDEPENDENT_NONPERSISTENT:
      return "INDEPENDENT_NONPERSISTENT";
    case VmwareDiskConfig_VmdkMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RDM compatibility mode. */
export enum VmwareDiskConfig_RdmCompatibility {
  /** RDM_COMPATIBILITY_UNSPECIFIED - Compatibility mode unspecified or unknown. */
  RDM_COMPATIBILITY_UNSPECIFIED = 0,
  /** PHYSICAL_COMPATIBILITY - Physical compatibility mode. */
  PHYSICAL_COMPATIBILITY = 1,
  /** VIRTUAL_COMPATIBILITY - Virtual compatibility mode. */
  VIRTUAL_COMPATIBILITY = 2,
  UNRECOGNIZED = -1,
}

export function vmwareDiskConfig_RdmCompatibilityFromJSON(object: any): VmwareDiskConfig_RdmCompatibility {
  switch (object) {
    case 0:
    case "RDM_COMPATIBILITY_UNSPECIFIED":
      return VmwareDiskConfig_RdmCompatibility.RDM_COMPATIBILITY_UNSPECIFIED;
    case 1:
    case "PHYSICAL_COMPATIBILITY":
      return VmwareDiskConfig_RdmCompatibility.PHYSICAL_COMPATIBILITY;
    case 2:
    case "VIRTUAL_COMPATIBILITY":
      return VmwareDiskConfig_RdmCompatibility.VIRTUAL_COMPATIBILITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareDiskConfig_RdmCompatibility.UNRECOGNIZED;
  }
}

export function vmwareDiskConfig_RdmCompatibilityToJSON(object: VmwareDiskConfig_RdmCompatibility): string {
  switch (object) {
    case VmwareDiskConfig_RdmCompatibility.RDM_COMPATIBILITY_UNSPECIFIED:
      return "RDM_COMPATIBILITY_UNSPECIFIED";
    case VmwareDiskConfig_RdmCompatibility.PHYSICAL_COMPATIBILITY:
      return "PHYSICAL_COMPATIBILITY";
    case VmwareDiskConfig_RdmCompatibility.VIRTUAL_COMPATIBILITY:
      return "VIRTUAL_COMPATIBILITY";
    case VmwareDiskConfig_RdmCompatibility.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information from Guest-level collections. */
export interface GuestOsDetails {
  /** The name of the operating system. */
  osName: string;
  /** What family the OS belong to, if known. */
  family: OperatingSystemFamily;
  /** The version of the operating system. */
  version: string;
  /** OS and app configuration. */
  config:
    | GuestConfigDetails
    | undefined;
  /** Runtime information. */
  runtime: GuestRuntimeDetails | undefined;
}

/** Guest OS config information. */
export interface GuestConfigDetails {
  /** OS issue (typically /etc/issue in Linux). */
  issue: string;
  /** Mount list (Linux fstab). */
  fstab:
    | FstabEntryList
    | undefined;
  /** Hosts file (/etc/hosts). */
  hosts:
    | HostsEntryList
    | undefined;
  /** NFS exports. */
  nfsExports:
    | NfsExportList
    | undefined;
  /** Security-Enhanced Linux (SELinux) mode. */
  selinuxMode: GuestConfigDetails_SeLinuxMode;
}

/** Security-Enhanced Linux (SELinux) mode. */
export enum GuestConfigDetails_SeLinuxMode {
  /** SE_LINUX_MODE_UNSPECIFIED - SELinux mode unknown or unspecified. */
  SE_LINUX_MODE_UNSPECIFIED = 0,
  /** SE_LINUX_MODE_DISABLED - SELinux is disabled. */
  SE_LINUX_MODE_DISABLED = 1,
  /** SE_LINUX_MODE_PERMISSIVE - SELinux permissive mode. */
  SE_LINUX_MODE_PERMISSIVE = 2,
  /** SE_LINUX_MODE_ENFORCING - SELinux enforcing mode. */
  SE_LINUX_MODE_ENFORCING = 3,
  UNRECOGNIZED = -1,
}

export function guestConfigDetails_SeLinuxModeFromJSON(object: any): GuestConfigDetails_SeLinuxMode {
  switch (object) {
    case 0:
    case "SE_LINUX_MODE_UNSPECIFIED":
      return GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_UNSPECIFIED;
    case 1:
    case "SE_LINUX_MODE_DISABLED":
      return GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_DISABLED;
    case 2:
    case "SE_LINUX_MODE_PERMISSIVE":
      return GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_PERMISSIVE;
    case 3:
    case "SE_LINUX_MODE_ENFORCING":
      return GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_ENFORCING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GuestConfigDetails_SeLinuxMode.UNRECOGNIZED;
  }
}

export function guestConfigDetails_SeLinuxModeToJSON(object: GuestConfigDetails_SeLinuxMode): string {
  switch (object) {
    case GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_UNSPECIFIED:
      return "SE_LINUX_MODE_UNSPECIFIED";
    case GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_DISABLED:
      return "SE_LINUX_MODE_DISABLED";
    case GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_PERMISSIVE:
      return "SE_LINUX_MODE_PERMISSIVE";
    case GuestConfigDetails_SeLinuxMode.SE_LINUX_MODE_ENFORCING:
      return "SE_LINUX_MODE_ENFORCING";
    case GuestConfigDetails_SeLinuxMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Fstab content. */
export interface FstabEntryList {
  /** Fstab entries. */
  entries: FstabEntry[];
}

/** Single fstab entry. */
export interface FstabEntry {
  /** The block special device or remote filesystem to be mounted. */
  spec: string;
  /** The mount point for the filesystem. */
  file: string;
  /** The type of the filesystem. */
  vfstype: string;
  /** Mount options associated with the filesystem. */
  mntops: string;
  /** Used by dump to determine which filesystems need to be dumped. */
  freq: number;
  /**
   * Used by the fsck(8) program to determine the order in which filesystem
   * checks are done at reboot time.
   */
  passno: number;
}

/** Hosts content. */
export interface HostsEntryList {
  /** Hosts entries. */
  entries: HostsEntry[];
}

/** Single /etc/hosts entry. */
export interface HostsEntry {
  /** IP (raw, IPv4/6 agnostic). */
  ip: string;
  /** List of host names / aliases. */
  hostNames: string[];
}

/** NFS exports. */
export interface NfsExportList {
  /** NFS export entries. */
  entries: NfsExport[];
}

/** NFS export. */
export interface NfsExport {
  /** The directory being exported. */
  exportDirectory: string;
  /** The hosts or networks to which the export is being shared. */
  hosts: string[];
}

/** Guest OS runtime information. */
export interface GuestRuntimeDetails {
  /** Running background services. */
  services:
    | RunningServiceList
    | undefined;
  /** Running processes. */
  processes:
    | RunningProcessList
    | undefined;
  /** Runtime network information (connections, ports). */
  network:
    | RuntimeNetworkInfo
    | undefined;
  /** Last time the OS was booted. */
  lastBootTime:
    | Date
    | undefined;
  /** Domain, e.g. c.stratozone-development.internal. */
  domain: string;
  /** Machine name. */
  machineName: string;
  /** Installed applications information. */
  installedApps:
    | GuestInstalledApplicationList
    | undefined;
  /** Open files information. */
  openFileList: OpenFileList | undefined;
}

/** List of running guest OS services. */
export interface RunningServiceList {
  /** Running service entries. */
  entries: RunningService[];
}

/** Guest OS running service details. */
export interface RunningService {
  /** Service name. */
  serviceName: string;
  /** Service state (OS-agnostic). */
  state: RunningService_State;
  /** Service start mode (OS-agnostic). */
  startMode: RunningService_StartMode;
  /** Service binary path. */
  exePath: string;
  /** Service command line. */
  cmdline: string;
  /** Service pid. */
  pid: Long;
}

/** Service state (OS-agnostic). */
export enum RunningService_State {
  /** STATE_UNSPECIFIED - Service state unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - Service is active. */
  ACTIVE = 1,
  /** PAUSED - Service is paused. */
  PAUSED = 2,
  /** STOPPED - Service is stopped. */
  STOPPED = 3,
  UNRECOGNIZED = -1,
}

export function runningService_StateFromJSON(object: any): RunningService_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return RunningService_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return RunningService_State.ACTIVE;
    case 2:
    case "PAUSED":
      return RunningService_State.PAUSED;
    case 3:
    case "STOPPED":
      return RunningService_State.STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunningService_State.UNRECOGNIZED;
  }
}

export function runningService_StateToJSON(object: RunningService_State): string {
  switch (object) {
    case RunningService_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case RunningService_State.ACTIVE:
      return "ACTIVE";
    case RunningService_State.PAUSED:
      return "PAUSED";
    case RunningService_State.STOPPED:
      return "STOPPED";
    case RunningService_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Service start mode (OS-agnostic). */
export enum RunningService_StartMode {
  /** START_MODE_UNSPECIFIED - Start mode unspecified. */
  START_MODE_UNSPECIFIED = 0,
  /** BOOT - The service is a device driver started by the system loader. */
  BOOT = 1,
  /** SYSTEM - The service is a device driver started by the IOInitSystem function. */
  SYSTEM = 2,
  /** AUTO - The service is started by the operating system, at system start-up */
  AUTO = 3,
  /** MANUAL - The service is started only manually, by a user. */
  MANUAL = 4,
  /** DISABLED - The service is disabled. */
  DISABLED = 5,
  UNRECOGNIZED = -1,
}

export function runningService_StartModeFromJSON(object: any): RunningService_StartMode {
  switch (object) {
    case 0:
    case "START_MODE_UNSPECIFIED":
      return RunningService_StartMode.START_MODE_UNSPECIFIED;
    case 1:
    case "BOOT":
      return RunningService_StartMode.BOOT;
    case 2:
    case "SYSTEM":
      return RunningService_StartMode.SYSTEM;
    case 3:
    case "AUTO":
      return RunningService_StartMode.AUTO;
    case 4:
    case "MANUAL":
      return RunningService_StartMode.MANUAL;
    case 5:
    case "DISABLED":
      return RunningService_StartMode.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunningService_StartMode.UNRECOGNIZED;
  }
}

export function runningService_StartModeToJSON(object: RunningService_StartMode): string {
  switch (object) {
    case RunningService_StartMode.START_MODE_UNSPECIFIED:
      return "START_MODE_UNSPECIFIED";
    case RunningService_StartMode.BOOT:
      return "BOOT";
    case RunningService_StartMode.SYSTEM:
      return "SYSTEM";
    case RunningService_StartMode.AUTO:
      return "AUTO";
    case RunningService_StartMode.MANUAL:
      return "MANUAL";
    case RunningService_StartMode.DISABLED:
      return "DISABLED";
    case RunningService_StartMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** List of running guest OS processes. */
export interface RunningProcessList {
  /** Running process entries. */
  entries: RunningProcess[];
}

/** Guest OS running process details. */
export interface RunningProcess {
  /** Process ID. */
  pid: Long;
  /** Process binary path. */
  exePath: string;
  /** Process full command line. */
  cmdline: string;
  /** User running the process. */
  user: string;
  /** Process extended attributes. */
  attributes: { [key: string]: string };
}

export interface RunningProcess_AttributesEntry {
  key: string;
  value: string;
}

/** Runtime networking information. */
export interface RuntimeNetworkInfo {
  /** Time of the last network scan. */
  scanTime:
    | Date
    | undefined;
  /** Network connections. */
  connections: NetworkConnectionList | undefined;
}

/** Network connection list. */
export interface NetworkConnectionList {
  /** Network connection entries. */
  entries: NetworkConnection[];
}

export interface NetworkConnection {
  /** Connection protocol (e.g. TCP/UDP). */
  protocol: string;
  /** Local IP address. */
  localIpAddress: string;
  /** Local port. */
  localPort: number;
  /** Remote IP address. */
  remoteIpAddress: string;
  /** Remote port. */
  remotePort: number;
  /** Network connection state. */
  state: NetworkConnection_State;
  /** Process ID. */
  pid: Long;
  /** Process or service name. */
  processName: string;
}

/** Network connection state. */
export enum NetworkConnection_State {
  /** STATE_UNSPECIFIED - Connection state is unknown or unspecified. */
  STATE_UNSPECIFIED = 0,
  /** OPENING - The connection is being opened. */
  OPENING = 1,
  /** OPEN - The connection is open. */
  OPEN = 2,
  /** LISTEN - Listening for incoming connections. */
  LISTEN = 3,
  /** CLOSING - The connection is being closed. */
  CLOSING = 4,
  /** CLOSED - The connection is closed. */
  CLOSED = 5,
  UNRECOGNIZED = -1,
}

export function networkConnection_StateFromJSON(object: any): NetworkConnection_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return NetworkConnection_State.STATE_UNSPECIFIED;
    case 1:
    case "OPENING":
      return NetworkConnection_State.OPENING;
    case 2:
    case "OPEN":
      return NetworkConnection_State.OPEN;
    case 3:
    case "LISTEN":
      return NetworkConnection_State.LISTEN;
    case 4:
    case "CLOSING":
      return NetworkConnection_State.CLOSING;
    case 5:
    case "CLOSED":
      return NetworkConnection_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConnection_State.UNRECOGNIZED;
  }
}

export function networkConnection_StateToJSON(object: NetworkConnection_State): string {
  switch (object) {
    case NetworkConnection_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case NetworkConnection_State.OPENING:
      return "OPENING";
    case NetworkConnection_State.OPEN:
      return "OPEN";
    case NetworkConnection_State.LISTEN:
      return "LISTEN";
    case NetworkConnection_State.CLOSING:
      return "CLOSING";
    case NetworkConnection_State.CLOSED:
      return "CLOSED";
    case NetworkConnection_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Guest installed application list. */
export interface GuestInstalledApplicationList {
  /** Application entries. */
  entries: GuestInstalledApplication[];
}

/** Guest installed application information. */
export interface GuestInstalledApplication {
  /** Installed application name. */
  applicationName: string;
  /** Installed application vendor. */
  vendor: string;
  /** The time when the application was installed. */
  installTime:
    | Date
    | undefined;
  /** Source path. */
  path: string;
  /** Installed application version. */
  version: string;
}

/** Open file list. */
export interface OpenFileList {
  /** Open file details entries. */
  entries: OpenFileDetails[];
}

/** Open file Information. */
export interface OpenFileDetails {
  /** Opened file command. */
  command: string;
  /** Opened file user. */
  user: string;
  /** Opened file file type. */
  fileType: string;
  /** Opened file file path. */
  filePath: string;
}

/** Information about the platform. */
export interface PlatformDetails {
  /** VMware specific details. */
  vmwareDetails?:
    | VmwarePlatformDetails
    | undefined;
  /** AWS EC2 specific details. */
  awsEc2Details?:
    | AwsEc2PlatformDetails
    | undefined;
  /** Azure VM specific details. */
  azureVmDetails?:
    | AzureVmPlatformDetails
    | undefined;
  /** Generic platform details. */
  genericDetails?:
    | GenericPlatformDetails
    | undefined;
  /** Physical machines platform details. */
  physicalDetails?: PhysicalPlatformDetails | undefined;
}

/** VMware specific details. */
export interface VmwarePlatformDetails {
  /** vCenter version. */
  vcenterVersion: string;
  /** ESX version. */
  esxVersion: string;
  /**
   * VMware os enum -
   * https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html.
   */
  osid: string;
  /** Folder name in vCenter where asset resides. */
  vcenterFolder: string;
  /** vCenter URI used in collection. */
  vcenterUri: string;
  /** vCenter VM ID. */
  vcenterVmId: string;
}

/** AWS EC2 specific details. */
export interface AwsEc2PlatformDetails {
  /** AWS platform's machine type label. */
  machineTypeLabel: string;
  /** The location of the machine in the AWS format. */
  location: string;
}

/** Azure VM specific details. */
export interface AzureVmPlatformDetails {
  /** Azure platform's machine type label. */
  machineTypeLabel: string;
  /** The location of the machine in the Azure format. */
  location: string;
  /** Azure platform's provisioning state. */
  provisioningState: string;
}

/** Generic platform details. */
export interface GenericPlatformDetails {
  /**
   * Free text representation of the machine location.
   * The format of this field should not be relied on. Different VMs in the same
   * location may have different string values for this field.
   */
  location: string;
}

/** Platform specific details for Physical Machines. */
export interface PhysicalPlatformDetails {
  /**
   * Free text representation of the machine location.
   * The format of this field should not be relied on. Different machines in the
   * same location may have different string values for this field.
   */
  location: string;
}

/** Memory usage sample. */
export interface MemoryUsageSample {
  /** Percentage of system memory utilized. Must be in the interval [0, 100]. */
  utilizedPercentage: number;
}

/** CPU usage sample. */
export interface CpuUsageSample {
  /**
   * Percentage of total CPU capacity utilized. Must be in the interval [0,
   * 100]. On most systems can be calculated using 100 - idle percentage.
   */
  utilizedPercentage: number;
}

/** Network usage sample. Values are across all network interfaces. */
export interface NetworkUsageSample {
  /**
   * Average network ingress in B/s sampled over a short window.
   * Must be non-negative.
   */
  averageIngressBps: number;
  /**
   * Average network egress in B/s sampled over a short window.
   * Must be non-negative.
   */
  averageEgressBps: number;
}

/** Disk usage sample. Values are across all disks. */
export interface DiskUsageSample {
  /** Average IOPS sampled over a short window. Must be non-negative. */
  averageIops: number;
}

/** Performance data sample. */
export interface PerformanceSample {
  /**
   * Time the sample was collected.
   * If omitted, the frame report time will be used.
   */
  sampleTime:
    | Date
    | undefined;
  /** Memory usage sample. */
  memory:
    | MemoryUsageSample
    | undefined;
  /** CPU usage sample. */
  cpu:
    | CpuUsageSample
    | undefined;
  /** Network usage sample. */
  network:
    | NetworkUsageSample
    | undefined;
  /** Disk usage sample. */
  disk: DiskUsageSample | undefined;
}

/** Performance data for an asset. */
export interface AssetPerformanceData {
  /**
   * Daily resource usage aggregations.
   * Contains all of the data available for an asset, up to the last 420 days.
   * Aggregations are sorted from oldest to most recent.
   */
  dailyResourceUsageAggregations: DailyResourceUsageAggregation[];
}

/** Usage data aggregation for a single day. */
export interface DailyResourceUsageAggregation {
  /** Aggregation date. Day boundaries are at midnight UTC. */
  date:
    | DateMessage
    | undefined;
  /** CPU usage. */
  cpu:
    | DailyResourceUsageAggregation_CPU
    | undefined;
  /** Memory usage. */
  memory:
    | DailyResourceUsageAggregation_Memory
    | undefined;
  /** Network usage. */
  network:
    | DailyResourceUsageAggregation_Network
    | undefined;
  /** Disk usage. */
  disk: DailyResourceUsageAggregation_Disk | undefined;
}

/** Statistical aggregation of samples for a single resource usage. */
export interface DailyResourceUsageAggregation_Stats {
  /** Average usage value. */
  average: number;
  /** Median usage value. */
  median: number;
  /** 95th percentile usage value. */
  ninteyFifthPercentile: number;
  /** Peak usage value. */
  peak: number;
}

/** Statistical aggregation of CPU usage. */
export interface DailyResourceUsageAggregation_CPU {
  /** CPU utilization percentage. */
  utilizationPercentage: DailyResourceUsageAggregation_Stats | undefined;
}

/** Statistical aggregation of memory usage. */
export interface DailyResourceUsageAggregation_Memory {
  /** Memory utilization percentage. */
  utilizationPercentage: DailyResourceUsageAggregation_Stats | undefined;
}

/** Statistical aggregation of network usage. */
export interface DailyResourceUsageAggregation_Network {
  /** Network ingress in B/s. */
  ingressBps:
    | DailyResourceUsageAggregation_Stats
    | undefined;
  /** Network egress in B/s. */
  egressBps: DailyResourceUsageAggregation_Stats | undefined;
}

/** Statistical aggregation of disk usage. */
export interface DailyResourceUsageAggregation_Disk {
  /** Disk I/O operations per second. */
  iops: DailyResourceUsageAggregation_Stats | undefined;
}

/** Message containing insights list. */
export interface InsightList {
  /** Output only. Insights of the list. */
  insights: Insight[];
  /** Output only. Update timestamp. */
  updateTime: Date | undefined;
}

/** An insight about an asset. */
export interface Insight {
  /** Output only. An insight about potential migrations for an asset. */
  migrationInsight?:
    | MigrationInsight
    | undefined;
  /** Output only. A generic insight about an asset */
  genericInsight?: GenericInsight | undefined;
}

/** A generic insight about an asset. */
export interface GenericInsight {
  /**
   * Output only. Represents a globally unique message id for
   * this insight, can be used for localization purposes, in case message_code
   * is not yet known by the client use default_message instead.
   */
  messageId: Long;
  /**
   * Output only. In case message_code is not yet known by the client
   * default_message will be the message to be used instead.
   */
  defaultMessage: string;
  /**
   * Output only. Additional information about the insight, each entry can be a
   * logical entry and must make sense if it is displayed with line breaks
   * between each entry. Text can contain md style links.
   */
  additionalInformation: string[];
}

/** An insight about potential migrations for an asset. */
export interface MigrationInsight {
  /**
   * Output only. Description of how well the asset this insight is associated
   * with fits the proposed migration.
   */
  fit:
    | FitDescriptor
    | undefined;
  /** Output only. A Google Compute Engine target. */
  computeEngineTarget?: ComputeEngineMigrationTarget | undefined;
}

/** Compute engine migration target. */
export interface ComputeEngineMigrationTarget {
  /** Description of the suggested shape for the migration target. */
  shape: ComputeEngineShapeDescriptor | undefined;
}

/** Compute Engine target shape descriptor. */
export interface ComputeEngineShapeDescriptor {
  /** Memory in mebibytes. */
  memoryMb: number;
  /** Number of physical cores. */
  physicalCoreCount: number;
  /** Number of logical cores. */
  logicalCoreCount: number;
  /** Compute Engine machine series. */
  series: string;
  /** Compute Engine machine type. */
  machineType: string;
  /** Compute Engine storage. Never empty. */
  storage: ComputeStorageDescriptor[];
}

/** Compute Engine storage option descriptor. */
export interface ComputeStorageDescriptor {
  /** Disk type backing the storage. */
  type: PersistentDiskType;
  /** Disk size in GiB. */
  sizeGb: number;
}

/** Describes the fit level of an asset for migration to a specific target. */
export interface FitDescriptor {
  /** Fit level. */
  fitLevel: FitDescriptor_FitLevel;
}

/** Fit level. */
export enum FitDescriptor_FitLevel {
  /** FIT_LEVEL_UNSPECIFIED - Not enough information. */
  FIT_LEVEL_UNSPECIFIED = 0,
  /** FIT - Fit. */
  FIT = 1,
  /** NO_FIT - No Fit. */
  NO_FIT = 2,
  /** REQUIRES_EFFORT - Fit with effort. */
  REQUIRES_EFFORT = 3,
  UNRECOGNIZED = -1,
}

export function fitDescriptor_FitLevelFromJSON(object: any): FitDescriptor_FitLevel {
  switch (object) {
    case 0:
    case "FIT_LEVEL_UNSPECIFIED":
      return FitDescriptor_FitLevel.FIT_LEVEL_UNSPECIFIED;
    case 1:
    case "FIT":
      return FitDescriptor_FitLevel.FIT;
    case 2:
    case "NO_FIT":
      return FitDescriptor_FitLevel.NO_FIT;
    case 3:
    case "REQUIRES_EFFORT":
      return FitDescriptor_FitLevel.REQUIRES_EFFORT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FitDescriptor_FitLevel.UNRECOGNIZED;
  }
}

export function fitDescriptor_FitLevelToJSON(object: FitDescriptor_FitLevel): string {
  switch (object) {
    case FitDescriptor_FitLevel.FIT_LEVEL_UNSPECIFIED:
      return "FIT_LEVEL_UNSPECIFIED";
    case FitDescriptor_FitLevel.FIT:
      return "FIT";
    case FitDescriptor_FitLevel.NO_FIT:
      return "NO_FIT";
    case FitDescriptor_FitLevel.REQUIRES_EFFORT:
      return "REQUIRES_EFFORT";
    case FitDescriptor_FitLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Message describing an aggregation. The message includes the aggregation type,
 * parameters, and the field on which to perform the aggregation.
 */
export interface Aggregation {
  /** The name of the field on which to aggregate. */
  field: string;
  /** Count the number of matching objects. */
  count?:
    | Aggregation_Count
    | undefined;
  /** Sum over a numeric field. */
  sum?:
    | Aggregation_Sum
    | undefined;
  /** Creates a bucketed histogram of field values. */
  histogram?:
    | Aggregation_Histogram
    | undefined;
  /** Creates a frequency distribution of all field values. */
  frequency?: Aggregation_Frequency | undefined;
}

/** Object count. */
export interface Aggregation_Count {
}

/** Sum of field values. */
export interface Aggregation_Sum {
}

/** Histogram of bucketed assets counts by field value. */
export interface Aggregation_Histogram {
  /**
   * Lower bounds of buckets.
   * The response will contain `n+1` buckets for `n` bounds.
   * The first bucket will count all assets for which the field value is
   * smaller than the first bound.
   * Subsequent buckets will count assets for which the field value is
   * greater or equal to a lower bound and smaller than the next one.
   * The last bucket will count assets for which the field value is greater or
   * equal to the final lower bound.
   * You can define up to 20 lower bounds.
   */
  lowerBounds: number[];
}

/** Frequency distribution of all field values. */
export interface Aggregation_Frequency {
}

/** Message describing a result of an aggregation. */
export interface AggregationResult {
  field: string;
  count?: AggregationResult_Count | undefined;
  sum?: AggregationResult_Sum | undefined;
  histogram?: AggregationResult_Histogram | undefined;
  frequency?: AggregationResult_Frequency | undefined;
}

/** The result of a count aggregation. */
export interface AggregationResult_Count {
  value: Long;
}

/** The result of a sum aggregation. */
export interface AggregationResult_Sum {
  value: number;
}

/** The result of a bucketed histogram aggregation. */
export interface AggregationResult_Histogram {
  /**
   * Buckets in the histogram.
   * There will be `n+1` buckets matching `n` lower bounds in the request.
   * The first bucket will be from -infinity to the first bound.
   * Subsequent buckets will be between one bound and the next.
   * The final bucket will be from the final bound to infinity.
   */
  buckets: AggregationResult_Histogram_Bucket[];
}

/**
 * A histogram bucket with a lower and upper bound, and a count of items
 * with a field value between those bounds.
 * The lower bound is inclusive and the upper bound is exclusive.
 * Lower bound may be -infinity and upper bound may be infinity.
 */
export interface AggregationResult_Histogram_Bucket {
  /** Lower bound - inclusive. */
  lowerBound: number;
  /** Upper bound - exclusive. */
  upperBound: number;
  /** Count of items in the bucket. */
  count: Long;
}

/** The result of a frequency distribution aggregation. */
export interface AggregationResult_Frequency {
  values: { [key: string]: Long };
}

export interface AggregationResult_Frequency_ValuesEntry {
  key: string;
  value: Long;
}

/** A resource that aggregates the validation errors found in an import job file. */
export interface FileValidationReport {
  /** The name of the file. */
  fileName: string;
  /** Partial list of rows that encountered validation error. */
  rowErrors: ImportRowError[];
  /**
   * Flag indicating that processing was aborted due to maximum number of
   * errors.
   */
  partialReport: boolean;
  /** List of file level errors. */
  fileErrors: ImportError[];
}

/** A resource that aggregates errors across import job files. */
export interface ValidationReport {
  /** List of errors found in files. */
  fileValidations: FileValidationReport[];
  /** List of job level errors. */
  jobErrors: ImportError[];
}

/** A resource that reports result of the import job execution. */
export interface ExecutionReport {
  /** Total number of asset frames reported for the import job. */
  framesReported: number;
  /** Validation errors encountered during the execution of the import job. */
  executionErrors:
    | ValidationReport
    | undefined;
  /** Output only. Total number of rows in the import job. */
  totalRowsCount: number;
}

/**
 * A resource that reports the errors encountered while processing an
 * import job.
 */
export interface ImportError {
  /** The error information. */
  errorDetails: string;
  /** The severity of the error. */
  severity: ImportError_Severity;
}

/** Enumerate possible error severity. */
export enum ImportError_Severity {
  SEVERITY_UNSPECIFIED = 0,
  ERROR = 1,
  WARNING = 2,
  INFO = 3,
  UNRECOGNIZED = -1,
}

export function importError_SeverityFromJSON(object: any): ImportError_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return ImportError_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "ERROR":
      return ImportError_Severity.ERROR;
    case 2:
    case "WARNING":
      return ImportError_Severity.WARNING;
    case 3:
    case "INFO":
      return ImportError_Severity.INFO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImportError_Severity.UNRECOGNIZED;
  }
}

export function importError_SeverityToJSON(object: ImportError_Severity): string {
  switch (object) {
    case ImportError_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case ImportError_Severity.ERROR:
      return "ERROR";
    case ImportError_Severity.WARNING:
      return "WARNING";
    case ImportError_Severity.INFO:
      return "INFO";
    case ImportError_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A resource that reports the import job errors at row level. */
export interface ImportRowError {
  /**
   * The row number where the error was detected.
   *
   * @deprecated
   */
  rowNumber: number;
  /** The name of the VM in the row. */
  vmName: string;
  /** The VM UUID. */
  vmUuid: string;
  /** The list of errors detected in the row. */
  errors: ImportError[];
}

/** A resource that contains a URI to which a data file can be uploaded. */
export interface UploadFileInfo {
  /** Output only. Upload URI for the file. */
  signedUri: string;
  /** Output only. The headers that were used to sign the URI. */
  headers: { [key: string]: string };
  /** Output only. Expiration time of the upload URI. */
  uriExpirationTime: Date | undefined;
}

export interface UploadFileInfo_HeadersEntry {
  key: string;
  value: string;
}

/** Lists the asset IDs of all assets. */
export interface AssetList {
  /** Required. A list of asset IDs */
  assetIds: string[];
}

/**
 * A resource that contains a single violation of a reported `AssetFrame`
 * resource.
 */
export interface FrameViolationEntry {
  /** The field of the original frame where the violation occurred. */
  field: string;
  /** A message describing the violation. */
  violation: string;
}

/**
 * VirtualMachinePreferences enables you to create sets of assumptions, for
 * example, a geographical location and pricing track, for your migrated virtual
 * machines. The set of preferences influence recommendations for migrating
 * virtual machine assets.
 */
export interface VirtualMachinePreferences {
  /**
   * Target product for assets using this preference set.
   * Specify either target product or business goal, but
   * not both.
   */
  targetProduct: ComputeMigrationTargetProduct;
  /**
   * Region preferences for assets using this preference set.
   * If you are unsure which value to set, the migration service API region is
   * often a good value to start with.
   */
  regionPreferences:
    | RegionPreferences
    | undefined;
  /**
   * Commitment plan to consider when calculating costs for virtual machine
   * insights and recommendations.
   * If you are unsure which value to set, a 3 year commitment plan is often a
   * good value to start with.
   */
  commitmentPlan: CommitmentPlan;
  /**
   * Sizing optimization strategy specifies the preferred strategy used when
   * extrapolating usage data to calculate insights and recommendations for a
   * virtual machine.
   * If you are unsure which value to set, a moderate sizing optimization
   * strategy is often a good value to start with.
   */
  sizingOptimizationStrategy: SizingOptimizationStrategy;
  /**
   * Compute Engine preferences concern insights and recommendations for Compute
   * Engine target.
   */
  computeEnginePreferences:
    | ComputeEnginePreferences
    | undefined;
  /**
   * Preferences concerning insights and recommendations for
   * Google Cloud VMware Engine.
   */
  vmwareEnginePreferences:
    | VmwareEnginePreferences
    | undefined;
  /** Preferences concerning Sole Tenant nodes and virtual machines. */
  soleTenancyPreferences: SoleTenancyPreferences | undefined;
}

/** The user preferences relating to Compute Engine target platform. */
export interface ComputeEnginePreferences {
  /** Preferences concerning the machine types to consider on Compute Engine. */
  machinePreferences:
    | MachinePreferences
    | undefined;
  /**
   * License type to consider when calculating costs for virtual machine
   * insights and recommendations. If unspecified, costs are calculated
   * based on the default licensing plan.
   */
  licenseType: LicenseType;
}

/**
 * The type of machines to consider when calculating virtual machine migration
 * insights and recommendations.
 * Not all machine types are available in all zones and regions.
 */
export interface MachinePreferences {
  /**
   * Compute Engine machine series to consider for insights and recommendations.
   * If empty, no restriction is applied on the machine series.
   */
  allowedMachineSeries: MachineSeries[];
}

/** A Compute Engine machine series. */
export interface MachineSeries {
  /**
   * Code to identify a Compute Engine machine series. Consult
   * https://cloud.google.com/compute/docs/machine-resource#machine_type_comparison
   * for more details on the available series.
   */
  code: string;
}

/** The user preferences relating to Google Cloud VMware Engine target platform. */
export interface VmwareEnginePreferences {
  /**
   * CPU overcommit ratio.
   * Acceptable values are between 1.0 and 8.0, with 0.1 increment.
   */
  cpuOvercommitRatio: number;
  /**
   * Memory overcommit ratio.
   * Acceptable values are 1.0, 1.25, 1.5, 1.75 and 2.0.
   */
  memoryOvercommitRatio: number;
  /**
   * The Deduplication and Compression ratio is based on the logical (Used
   * Before) space required to store data before applying deduplication and
   * compression, in relation to the physical (Used After) space required after
   * applying deduplication and compression. Specifically, the ratio is the Used
   * Before space divided by the Used After space. For example, if the Used
   * Before space is 3 GB, but the physical Used After space is 1 GB, the
   * deduplication and compression ratio is 3x. Acceptable values are
   * between 1.0 and 4.0.
   */
  storageDeduplicationCompressionRatio: number;
  /**
   * Commitment plan to consider when calculating costs for virtual machine
   * insights and recommendations.
   * If you are unsure which value to set, a 3 year commitment plan is often a
   * good value to start with.
   */
  commitmentPlan: VmwareEnginePreferences_CommitmentPlan;
}

/** Type of committed use discount. */
export enum VmwareEnginePreferences_CommitmentPlan {
  /** COMMITMENT_PLAN_UNSPECIFIED - Unspecified commitment plan. */
  COMMITMENT_PLAN_UNSPECIFIED = 0,
  /** ON_DEMAND - No commitment plan (on-demand usage). */
  ON_DEMAND = 1,
  /** COMMITMENT_1_YEAR_MONTHLY_PAYMENTS - 1 year commitment (monthly payments). */
  COMMITMENT_1_YEAR_MONTHLY_PAYMENTS = 2,
  /** COMMITMENT_3_YEAR_MONTHLY_PAYMENTS - 3 year commitment (monthly payments). */
  COMMITMENT_3_YEAR_MONTHLY_PAYMENTS = 3,
  /** COMMITMENT_1_YEAR_UPFRONT_PAYMENT - 1 year commitment (upfront payment). */
  COMMITMENT_1_YEAR_UPFRONT_PAYMENT = 4,
  /** COMMITMENT_3_YEAR_UPFRONT_PAYMENT - 3 years commitment (upfront payment). */
  COMMITMENT_3_YEAR_UPFRONT_PAYMENT = 5,
  UNRECOGNIZED = -1,
}

export function vmwareEnginePreferences_CommitmentPlanFromJSON(object: any): VmwareEnginePreferences_CommitmentPlan {
  switch (object) {
    case 0:
    case "COMMITMENT_PLAN_UNSPECIFIED":
      return VmwareEnginePreferences_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED;
    case 1:
    case "ON_DEMAND":
      return VmwareEnginePreferences_CommitmentPlan.ON_DEMAND;
    case 2:
    case "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS":
      return VmwareEnginePreferences_CommitmentPlan.COMMITMENT_1_YEAR_MONTHLY_PAYMENTS;
    case 3:
    case "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS":
      return VmwareEnginePreferences_CommitmentPlan.COMMITMENT_3_YEAR_MONTHLY_PAYMENTS;
    case 4:
    case "COMMITMENT_1_YEAR_UPFRONT_PAYMENT":
      return VmwareEnginePreferences_CommitmentPlan.COMMITMENT_1_YEAR_UPFRONT_PAYMENT;
    case 5:
    case "COMMITMENT_3_YEAR_UPFRONT_PAYMENT":
      return VmwareEnginePreferences_CommitmentPlan.COMMITMENT_3_YEAR_UPFRONT_PAYMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareEnginePreferences_CommitmentPlan.UNRECOGNIZED;
  }
}

export function vmwareEnginePreferences_CommitmentPlanToJSON(object: VmwareEnginePreferences_CommitmentPlan): string {
  switch (object) {
    case VmwareEnginePreferences_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED:
      return "COMMITMENT_PLAN_UNSPECIFIED";
    case VmwareEnginePreferences_CommitmentPlan.ON_DEMAND:
      return "ON_DEMAND";
    case VmwareEnginePreferences_CommitmentPlan.COMMITMENT_1_YEAR_MONTHLY_PAYMENTS:
      return "COMMITMENT_1_YEAR_MONTHLY_PAYMENTS";
    case VmwareEnginePreferences_CommitmentPlan.COMMITMENT_3_YEAR_MONTHLY_PAYMENTS:
      return "COMMITMENT_3_YEAR_MONTHLY_PAYMENTS";
    case VmwareEnginePreferences_CommitmentPlan.COMMITMENT_1_YEAR_UPFRONT_PAYMENT:
      return "COMMITMENT_1_YEAR_UPFRONT_PAYMENT";
    case VmwareEnginePreferences_CommitmentPlan.COMMITMENT_3_YEAR_UPFRONT_PAYMENT:
      return "COMMITMENT_3_YEAR_UPFRONT_PAYMENT";
    case VmwareEnginePreferences_CommitmentPlan.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Preferences concerning Sole Tenancy nodes and VMs. */
export interface SoleTenancyPreferences {
  /**
   * CPU overcommit ratio.
   * Acceptable values are between 1.0 and 2.0 inclusive.
   */
  cpuOvercommitRatio: number;
  /** Sole Tenancy nodes maintenance policy. */
  hostMaintenancePolicy: SoleTenancyPreferences_HostMaintenancePolicy;
  /**
   * Commitment plan to consider when calculating costs for virtual machine
   * insights and recommendations.
   * If you are unsure which value to set, a 3 year commitment plan is often a
   * good value to start with.
   */
  commitmentPlan: SoleTenancyPreferences_CommitmentPlan;
  /**
   * A list of sole tenant node types.
   * An empty list means that all possible node types will be considered.
   */
  nodeTypes: SoleTenantNodeType[];
}

/** Sole Tenancy nodes maintenance policy. */
export enum SoleTenancyPreferences_HostMaintenancePolicy {
  /** HOST_MAINTENANCE_POLICY_UNSPECIFIED - Unspecified host maintenance policy. */
  HOST_MAINTENANCE_POLICY_UNSPECIFIED = 0,
  /** HOST_MAINTENANCE_POLICY_DEFAULT - Default host maintenance policy. */
  HOST_MAINTENANCE_POLICY_DEFAULT = 1,
  /** HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE - Restart in place host maintenance policy. */
  HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE = 2,
  /** HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP - Migrate within node group host maintenance policy. */
  HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP = 3,
  UNRECOGNIZED = -1,
}

export function soleTenancyPreferences_HostMaintenancePolicyFromJSON(
  object: any,
): SoleTenancyPreferences_HostMaintenancePolicy {
  switch (object) {
    case 0:
    case "HOST_MAINTENANCE_POLICY_UNSPECIFIED":
      return SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_UNSPECIFIED;
    case 1:
    case "HOST_MAINTENANCE_POLICY_DEFAULT":
      return SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_DEFAULT;
    case 2:
    case "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE":
      return SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE;
    case 3:
    case "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP":
      return SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoleTenancyPreferences_HostMaintenancePolicy.UNRECOGNIZED;
  }
}

export function soleTenancyPreferences_HostMaintenancePolicyToJSON(
  object: SoleTenancyPreferences_HostMaintenancePolicy,
): string {
  switch (object) {
    case SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_UNSPECIFIED:
      return "HOST_MAINTENANCE_POLICY_UNSPECIFIED";
    case SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_DEFAULT:
      return "HOST_MAINTENANCE_POLICY_DEFAULT";
    case SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE:
      return "HOST_MAINTENANCE_POLICY_RESTART_IN_PLACE";
    case SoleTenancyPreferences_HostMaintenancePolicy.HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP:
      return "HOST_MAINTENANCE_POLICY_MIGRATE_WITHIN_NODE_GROUP";
    case SoleTenancyPreferences_HostMaintenancePolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of committed use discount. */
export enum SoleTenancyPreferences_CommitmentPlan {
  /** COMMITMENT_PLAN_UNSPECIFIED - Unspecified commitment plan. */
  COMMITMENT_PLAN_UNSPECIFIED = 0,
  /** ON_DEMAND - No commitment plan (on-demand usage). */
  ON_DEMAND = 1,
  /** COMMITMENT_1_YEAR - 1 year commitment. */
  COMMITMENT_1_YEAR = 2,
  /** COMMITMENT_3_YEAR - 3 years commitment. */
  COMMITMENT_3_YEAR = 3,
  UNRECOGNIZED = -1,
}

export function soleTenancyPreferences_CommitmentPlanFromJSON(object: any): SoleTenancyPreferences_CommitmentPlan {
  switch (object) {
    case 0:
    case "COMMITMENT_PLAN_UNSPECIFIED":
      return SoleTenancyPreferences_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED;
    case 1:
    case "ON_DEMAND":
      return SoleTenancyPreferences_CommitmentPlan.ON_DEMAND;
    case 2:
    case "COMMITMENT_1_YEAR":
      return SoleTenancyPreferences_CommitmentPlan.COMMITMENT_1_YEAR;
    case 3:
    case "COMMITMENT_3_YEAR":
      return SoleTenancyPreferences_CommitmentPlan.COMMITMENT_3_YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoleTenancyPreferences_CommitmentPlan.UNRECOGNIZED;
  }
}

export function soleTenancyPreferences_CommitmentPlanToJSON(object: SoleTenancyPreferences_CommitmentPlan): string {
  switch (object) {
    case SoleTenancyPreferences_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED:
      return "COMMITMENT_PLAN_UNSPECIFIED";
    case SoleTenancyPreferences_CommitmentPlan.ON_DEMAND:
      return "ON_DEMAND";
    case SoleTenancyPreferences_CommitmentPlan.COMMITMENT_1_YEAR:
      return "COMMITMENT_1_YEAR";
    case SoleTenancyPreferences_CommitmentPlan.COMMITMENT_3_YEAR:
      return "COMMITMENT_3_YEAR";
    case SoleTenancyPreferences_CommitmentPlan.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Sole Tenant node type. */
export interface SoleTenantNodeType {
  /**
   * Name of the Sole Tenant node. Consult
   * https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes
   */
  nodeName: string;
}

/** The user preferences relating to target regions. */
export interface RegionPreferences {
  /**
   * A list of preferred regions,
   * ordered by the most preferred region first.
   * Set only valid Google Cloud region names.
   * See https://cloud.google.com/compute/docs/regions-zones
   * for available regions.
   */
  preferredRegions: string[];
}

/** Describes the Migration Center settings related to the project. */
export interface Settings {
  /** Output only. The name of the resource. */
  name: string;
  /** The preference set used by default for a project. */
  preferenceSet: string;
}

/**
 * Describes the Summary view of a Report, which contains aggregated values
 * for all the groups and preference sets included in this Report.
 */
export interface ReportSummary {
  /** Aggregate statistics for all the assets across all the groups. */
  allAssetsStats:
    | ReportSummary_AssetAggregateStats
    | undefined;
  /** Findings for each Group included in this report. */
  groupFindings: ReportSummary_GroupFinding[];
}

/** Describes a collection of data points rendered as a Chart. */
export interface ReportSummary_ChartData {
  /**
   * Each data point in the chart is represented as a name-value pair
   * with the name being the x-axis label, and the value being the y-axis
   * value.
   */
  dataPoints: ReportSummary_ChartData_DataPoint[];
}

/** Describes a single data point in the Chart. */
export interface ReportSummary_ChartData_DataPoint {
  /** The X-axis label for this data point. */
  label: string;
  /** The Y-axis value for this data point. */
  value: number;
}

/**
 * Utilization Chart is a specific type of visualization which displays
 * a metric classified into "Used" and "Free" buckets.
 */
export interface ReportSummary_UtilizationChartData {
  /** Aggregate value which falls into the "Used" bucket. */
  used: Long;
  /** Aggregate value which falls into the "Free" bucket. */
  free: Long;
}

/**
 * A Histogram Chart shows a distribution of values into buckets, showing
 * a count of values which fall into a bucket.
 */
export interface ReportSummary_HistogramChartData {
  /**
   * Buckets in the histogram.
   * There will be `n+1` buckets matching `n` lower bounds in the request.
   * The first bucket will be from -infinity to the first bound.
   * Subsequent buckets will be between one bound and the next.
   * The final bucket will be from the final bound to infinity.
   */
  buckets: ReportSummary_HistogramChartData_Bucket[];
}

/**
 * A histogram bucket with a lower and upper bound, and a count of items
 * with a field value between those bounds.
 * The lower bound is inclusive and the upper bound is exclusive.
 * Lower bound may be -infinity and upper bound may be infinity.
 */
export interface ReportSummary_HistogramChartData_Bucket {
  /** Lower bound - inclusive. */
  lowerBound: Long;
  /** Upper bound - exclusive. */
  upperBound: Long;
  /** Count of items in the bucket. */
  count: Long;
}

/** Aggregate statistics for a collection of assets. */
export interface ReportSummary_AssetAggregateStats {
  /** Sum of the memory in bytes of all the assets in this collection. */
  totalMemoryBytes: Long;
  /** Sum of persistent storage in bytes of all the assets in this collection. */
  totalStorageBytes: Long;
  /** Sum of the CPU core count of all the assets in this collection. */
  totalCores: Long;
  /** Count of the number of unique assets in this collection. */
  totalAssets: Long;
  /** Total memory split into Used/Free buckets. */
  memoryUtilizationChart:
    | ReportSummary_UtilizationChartData
    | undefined;
  /** Total memory split into Used/Free buckets. */
  storageUtilizationChart:
    | ReportSummary_UtilizationChartData
    | undefined;
  /** Count of assets grouped by Operating System families. */
  operatingSystem:
    | ReportSummary_ChartData
    | undefined;
  /** Histogram showing a distribution of CPU core counts. */
  coreCountHistogram:
    | ReportSummary_HistogramChartData
    | undefined;
  /** Histogram showing a distribution of memory sizes. */
  memoryBytesHistogram:
    | ReportSummary_HistogramChartData
    | undefined;
  /** Histogram showing a distribution of memory sizes. */
  storageBytesHistogram: ReportSummary_HistogramChartData | undefined;
}

/**
 * Represents a data point tracking the count of assets allocated for a
 * specific Machine Series.
 */
export interface ReportSummary_MachineSeriesAllocation {
  /** The Machine Series (e.g. "E2", "N2") */
  machineSeries:
    | MachineSeries
    | undefined;
  /** Count of assets allocated to this machine series. */
  allocatedAssetCount: Long;
}

/** A set of findings that applies to assets destined for Compute Engine. */
export interface ReportSummary_ComputeEngineFinding {
  /** Set of regions in which the assets were allocated. */
  allocatedRegions: string[];
  /** Count of assets which were allocated. */
  allocatedAssetCount: Long;
  /** Distribution of assets based on the Machine Series. */
  machineSeriesAllocations: ReportSummary_MachineSeriesAllocation[];
  /** Set of disk types allocated to assets. */
  allocatedDiskTypes: PersistentDiskType[];
}

/** A set of findings that applies to assets destined for VMWare Engine. */
export interface ReportSummary_VmwareEngineFinding {
  /** Set of regions in which the assets were allocated */
  allocatedRegions: string[];
  /** Count of assets which are allocated */
  allocatedAssetCount: Long;
  /** Set of per-nodetype allocation records */
  nodeAllocations: ReportSummary_VmwareNodeAllocation[];
}

/** Represents assets allocated to a specific VMWare Node type. */
export interface ReportSummary_VmwareNodeAllocation {
  /** VMWare node type, e.g. "ve1-standard-72" */
  vmwareNode:
    | ReportSummary_VmwareNode
    | undefined;
  /** Count of this node type to be provisioned */
  nodeCount: Long;
  /** Count of assets allocated to these nodes */
  allocatedAssetCount: Long;
}

/** A VMWare Engine Node */
export interface ReportSummary_VmwareNode {
  /**
   * Code to identify VMware Engine node series, e.g. "ve1-standard-72". Based
   * on the displayName of
   * cloud.google.com/vmware-engine/docs/reference/rest/v1/projects.locations.nodeTypes
   */
  code: string;
}

/** A set of findings that applies to assets destined for Sole-Tenant nodes. */
export interface ReportSummary_SoleTenantFinding {
  /** Set of regions in which the assets are allocated */
  allocatedRegions: string[];
  /** Count of assets which are allocated */
  allocatedAssetCount: Long;
  /** Set of per-nodetype allocation records */
  nodeAllocations: ReportSummary_SoleTenantNodeAllocation[];
}

/** Represents the assets allocated to a specific Sole-Tenant node type. */
export interface ReportSummary_SoleTenantNodeAllocation {
  /** Sole Tenant node type, e.g. "m3-node-128-3904" */
  node:
    | SoleTenantNodeType
    | undefined;
  /** Count of this node type to be provisioned */
  nodeCount: Long;
  /** Count of assets allocated to these nodes */
  allocatedAssetCount: Long;
}

/** Summary Findings for a specific Group/PreferenceSet combination. */
export interface ReportSummary_GroupPreferenceSetFinding {
  /** Display Name of the Preference Set */
  displayName: string;
  /** Description for the Preference Set. */
  description: string;
  /** A set of preferences that applies to all machines in the context. */
  machinePreferences:
    | VirtualMachinePreferences
    | undefined;
  /** Total monthly cost for this preference set. */
  monthlyCostTotal:
    | Money
    | undefined;
  /** Compute monthly cost for this preference set. */
  monthlyCostCompute:
    | Money
    | undefined;
  /** Licensing monthly cost for this preference set. */
  monthlyCostOsLicense:
    | Money
    | undefined;
  /** Network Egress monthly cost for this preference set. */
  monthlyCostNetworkEgress:
    | Money
    | undefined;
  /** Storage monthly cost for this preference set. */
  monthlyCostStorage:
    | Money
    | undefined;
  /** Miscellaneous monthly cost for this preference set. */
  monthlyCostOther:
    | Money
    | undefined;
  /** A set of findings that applies to Compute Engine machines in the input. */
  computeEngineFinding:
    | ReportSummary_ComputeEngineFinding
    | undefined;
  /** A set of findings that applies to VMWare machines in the input. */
  vmwareEngineFinding:
    | ReportSummary_VmwareEngineFinding
    | undefined;
  /** A set of findings that applies to Sole-Tenant machines in the input. */
  soleTenantFinding: ReportSummary_SoleTenantFinding | undefined;
}

/** Summary Findings for a specific Group. */
export interface ReportSummary_GroupFinding {
  /** Display Name for the Group. */
  displayName: string;
  /** Description for the Group. */
  description: string;
  /** Summary statistics for all the assets in this group. */
  assetAggregateStats:
    | ReportSummary_AssetAggregateStats
    | undefined;
  /**
   * This field is deprecated, do not rely on it having a value.
   *
   * @deprecated
   */
  overlappingAssetCount: Long;
  /** Findings for each of the PreferenceSets for this group. */
  preferenceSetFindings: ReportSummary_GroupPreferenceSetFinding[];
}

function createBaseAsset(): Asset {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    attributes: {},
    machineDetails: undefined,
    insightList: undefined,
    performanceData: undefined,
    sources: [],
    assignedGroups: [],
  };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Asset_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    Object.entries(message.attributes).forEach(([key, value]) => {
      Asset_AttributesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.machineDetails !== undefined) {
      MachineDetails.encode(message.machineDetails, writer.uint32(50).fork()).join();
    }
    if (message.insightList !== undefined) {
      InsightList.encode(message.insightList, writer.uint32(162).fork()).join();
    }
    if (message.performanceData !== undefined) {
      AssetPerformanceData.encode(message.performanceData, writer.uint32(170).fork()).join();
    }
    for (const v of message.sources) {
      writer.uint32(178).string(v!);
    }
    for (const v of message.assignedGroups) {
      writer.uint32(186).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Asset_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Asset_AttributesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.attributes[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.machineDetails = MachineDetails.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.insightList = InsightList.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.performanceData = AssetPerformanceData.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.sources.push(reader.string());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.assignedGroups.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      machineDetails: isSet(object.machineDetails) ? MachineDetails.fromJSON(object.machineDetails) : undefined,
      insightList: isSet(object.insightList) ? InsightList.fromJSON(object.insightList) : undefined,
      performanceData: isSet(object.performanceData)
        ? AssetPerformanceData.fromJSON(object.performanceData)
        : undefined,
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => globalThis.String(e)) : [],
      assignedGroups: globalThis.Array.isArray(object?.assignedGroups)
        ? object.assignedGroups.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.machineDetails !== undefined) {
      obj.machineDetails = MachineDetails.toJSON(message.machineDetails);
    }
    if (message.insightList !== undefined) {
      obj.insightList = InsightList.toJSON(message.insightList);
    }
    if (message.performanceData !== undefined) {
      obj.performanceData = AssetPerformanceData.toJSON(message.performanceData);
    }
    if (message.sources?.length) {
      obj.sources = message.sources;
    }
    if (message.assignedGroups?.length) {
      obj.assignedGroups = message.assignedGroups;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.machineDetails = (object.machineDetails !== undefined && object.machineDetails !== null)
      ? MachineDetails.fromPartial(object.machineDetails)
      : undefined;
    message.insightList = (object.insightList !== undefined && object.insightList !== null)
      ? InsightList.fromPartial(object.insightList)
      : undefined;
    message.performanceData = (object.performanceData !== undefined && object.performanceData !== null)
      ? AssetPerformanceData.fromPartial(object.performanceData)
      : undefined;
    message.sources = object.sources?.map((e) => e) || [];
    message.assignedGroups = object.assignedGroups?.map((e) => e) || [];
    return message;
  },
};

function createBaseAsset_LabelsEntry(): Asset_LabelsEntry {
  return { key: "", value: "" };
}

export const Asset_LabelsEntry: MessageFns<Asset_LabelsEntry> = {
  encode(message: Asset_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Asset_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_LabelsEntry>): Asset_LabelsEntry {
    return Asset_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_LabelsEntry>): Asset_LabelsEntry {
    const message = createBaseAsset_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAsset_AttributesEntry(): Asset_AttributesEntry {
  return { key: "", value: "" };
}

export const Asset_AttributesEntry: MessageFns<Asset_AttributesEntry> = {
  encode(message: Asset_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Asset_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_AttributesEntry>): Asset_AttributesEntry {
    return Asset_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_AttributesEntry>): Asset_AttributesEntry {
    const message = createBaseAsset_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePreferenceSet(): PreferenceSet {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
    description: "",
    virtualMachinePreferences: undefined,
  };
}

export const PreferenceSet: MessageFns<PreferenceSet> = {
  encode(message: PreferenceSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.virtualMachinePreferences !== undefined) {
      VirtualMachinePreferences.encode(message.virtualMachinePreferences, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferenceSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferenceSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.virtualMachinePreferences = VirtualMachinePreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreferenceSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      virtualMachinePreferences: isSet(object.virtualMachinePreferences)
        ? VirtualMachinePreferences.fromJSON(object.virtualMachinePreferences)
        : undefined,
    };
  },

  toJSON(message: PreferenceSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.virtualMachinePreferences !== undefined) {
      obj.virtualMachinePreferences = VirtualMachinePreferences.toJSON(message.virtualMachinePreferences);
    }
    return obj;
  },

  create(base?: DeepPartial<PreferenceSet>): PreferenceSet {
    return PreferenceSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreferenceSet>): PreferenceSet {
    const message = createBasePreferenceSet();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.virtualMachinePreferences =
      (object.virtualMachinePreferences !== undefined && object.virtualMachinePreferences !== null)
        ? VirtualMachinePreferences.fromPartial(object.virtualMachinePreferences)
        : undefined;
    return message;
  },
};

function createBaseImportJob(): ImportJob {
  return {
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    completeTime: undefined,
    state: 0,
    labels: {},
    assetSource: "",
    validationReport: undefined,
    executionReport: undefined,
  };
}

export const ImportJob: MessageFns<ImportJob> = {
  encode(message: ImportJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.completeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completeTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ImportJob_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.assetSource !== "") {
      writer.uint32(66).string(message.assetSource);
    }
    if (message.validationReport !== undefined) {
      ValidationReport.encode(message.validationReport, writer.uint32(82).fork()).join();
    }
    if (message.executionReport !== undefined) {
      ExecutionReport.encode(message.executionReport, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.completeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ImportJob_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.assetSource = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.validationReport = ValidationReport.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.executionReport = ExecutionReport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      completeTime: isSet(object.completeTime) ? fromJsonTimestamp(object.completeTime) : undefined,
      state: isSet(object.state) ? importJob_ImportJobStateFromJSON(object.state) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      assetSource: isSet(object.assetSource) ? globalThis.String(object.assetSource) : "",
      validationReport: isSet(object.validationReport) ? ValidationReport.fromJSON(object.validationReport) : undefined,
      executionReport: isSet(object.executionReport) ? ExecutionReport.fromJSON(object.executionReport) : undefined,
    };
  },

  toJSON(message: ImportJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.completeTime !== undefined) {
      obj.completeTime = message.completeTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = importJob_ImportJobStateToJSON(message.state);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.assetSource !== "") {
      obj.assetSource = message.assetSource;
    }
    if (message.validationReport !== undefined) {
      obj.validationReport = ValidationReport.toJSON(message.validationReport);
    }
    if (message.executionReport !== undefined) {
      obj.executionReport = ExecutionReport.toJSON(message.executionReport);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportJob>): ImportJob {
    return ImportJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportJob>): ImportJob {
    const message = createBaseImportJob();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.completeTime = object.completeTime ?? undefined;
    message.state = object.state ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.assetSource = object.assetSource ?? "";
    message.validationReport = (object.validationReport !== undefined && object.validationReport !== null)
      ? ValidationReport.fromPartial(object.validationReport)
      : undefined;
    message.executionReport = (object.executionReport !== undefined && object.executionReport !== null)
      ? ExecutionReport.fromPartial(object.executionReport)
      : undefined;
    return message;
  },
};

function createBaseImportJob_LabelsEntry(): ImportJob_LabelsEntry {
  return { key: "", value: "" };
}

export const ImportJob_LabelsEntry: MessageFns<ImportJob_LabelsEntry> = {
  encode(message: ImportJob_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportJob_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportJob_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ImportJob_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportJob_LabelsEntry>): ImportJob_LabelsEntry {
    return ImportJob_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportJob_LabelsEntry>): ImportJob_LabelsEntry {
    const message = createBaseImportJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseImportDataFile(): ImportDataFile {
  return { name: "", displayName: "", format: 0, createTime: undefined, state: 0, uploadFileInfo: undefined };
}

export const ImportDataFile: MessageFns<ImportDataFile> = {
  encode(message: ImportDataFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.format !== 0) {
      writer.uint32(16).int32(message.format);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.uploadFileInfo !== undefined) {
      UploadFileInfo.encode(message.uploadFileInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDataFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDataFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uploadFileInfo = UploadFileInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDataFile {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      format: isSet(object.format) ? importJobFormatFromJSON(object.format) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      state: isSet(object.state) ? importDataFile_StateFromJSON(object.state) : 0,
      uploadFileInfo: isSet(object.uploadFileInfo) ? UploadFileInfo.fromJSON(object.uploadFileInfo) : undefined,
    };
  },

  toJSON(message: ImportDataFile): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.format !== 0) {
      obj.format = importJobFormatToJSON(message.format);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = importDataFile_StateToJSON(message.state);
    }
    if (message.uploadFileInfo !== undefined) {
      obj.uploadFileInfo = UploadFileInfo.toJSON(message.uploadFileInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDataFile>): ImportDataFile {
    return ImportDataFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDataFile>): ImportDataFile {
    const message = createBaseImportDataFile();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.format = object.format ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    message.uploadFileInfo = (object.uploadFileInfo !== undefined && object.uploadFileInfo !== null)
      ? UploadFileInfo.fromPartial(object.uploadFileInfo)
      : undefined;
    return message;
  },
};

function createBaseGroup(): Group {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, displayName: "", description: "" };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Group_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Group_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Group>): Group {
    return Group.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Group>): Group {
    const message = createBaseGroup();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGroup_LabelsEntry(): Group_LabelsEntry {
  return { key: "", value: "" };
}

export const Group_LabelsEntry: MessageFns<Group_LabelsEntry> = {
  encode(message: Group_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Group_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Group_LabelsEntry>): Group_LabelsEntry {
    return Group_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Group_LabelsEntry>): Group_LabelsEntry {
    const message = createBaseGroup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseErrorFrame(): ErrorFrame {
  return { name: "", violations: [], originalFrame: undefined, ingestionTime: undefined };
}

export const ErrorFrame: MessageFns<ErrorFrame> = {
  encode(message: ErrorFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.violations) {
      FrameViolationEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.originalFrame !== undefined) {
      AssetFrame.encode(message.originalFrame, writer.uint32(26).fork()).join();
    }
    if (message.ingestionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.ingestionTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.violations.push(FrameViolationEntry.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.originalFrame = AssetFrame.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ingestionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorFrame {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      violations: globalThis.Array.isArray(object?.violations)
        ? object.violations.map((e: any) => FrameViolationEntry.fromJSON(e))
        : [],
      originalFrame: isSet(object.originalFrame) ? AssetFrame.fromJSON(object.originalFrame) : undefined,
      ingestionTime: isSet(object.ingestionTime) ? fromJsonTimestamp(object.ingestionTime) : undefined,
    };
  },

  toJSON(message: ErrorFrame): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.violations?.length) {
      obj.violations = message.violations.map((e) => FrameViolationEntry.toJSON(e));
    }
    if (message.originalFrame !== undefined) {
      obj.originalFrame = AssetFrame.toJSON(message.originalFrame);
    }
    if (message.ingestionTime !== undefined) {
      obj.ingestionTime = message.ingestionTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorFrame>): ErrorFrame {
    return ErrorFrame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorFrame>): ErrorFrame {
    const message = createBaseErrorFrame();
    message.name = object.name ?? "";
    message.violations = object.violations?.map((e) => FrameViolationEntry.fromPartial(e)) || [];
    message.originalFrame = (object.originalFrame !== undefined && object.originalFrame !== null)
      ? AssetFrame.fromPartial(object.originalFrame)
      : undefined;
    message.ingestionTime = object.ingestionTime ?? undefined;
    return message;
  },
};

function createBaseSource(): Source {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
    description: "",
    type: 0,
    priority: 0,
    managed: false,
    pendingFrameCount: 0,
    errorFrameCount: 0,
    state: 0,
  };
}

export const Source: MessageFns<Source> = {
  encode(message: Source, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.priority !== 0) {
      writer.uint32(56).int32(message.priority);
    }
    if (message.managed !== false) {
      writer.uint32(64).bool(message.managed);
    }
    if (message.pendingFrameCount !== 0) {
      writer.uint32(72).int32(message.pendingFrameCount);
    }
    if (message.errorFrameCount !== 0) {
      writer.uint32(80).int32(message.errorFrameCount);
    }
    if (message.state !== 0) {
      writer.uint32(88).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.managed = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pendingFrameCount = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.errorFrameCount = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? source_SourceTypeFromJSON(object.type) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      managed: isSet(object.managed) ? globalThis.Boolean(object.managed) : false,
      pendingFrameCount: isSet(object.pendingFrameCount) ? globalThis.Number(object.pendingFrameCount) : 0,
      errorFrameCount: isSet(object.errorFrameCount) ? globalThis.Number(object.errorFrameCount) : 0,
      state: isSet(object.state) ? source_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = source_SourceTypeToJSON(message.type);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.managed !== false) {
      obj.managed = message.managed;
    }
    if (message.pendingFrameCount !== 0) {
      obj.pendingFrameCount = Math.round(message.pendingFrameCount);
    }
    if (message.errorFrameCount !== 0) {
      obj.errorFrameCount = Math.round(message.errorFrameCount);
    }
    if (message.state !== 0) {
      obj.state = source_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Source>): Source {
    return Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Source>): Source {
    const message = createBaseSource();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.priority = object.priority ?? 0;
    message.managed = object.managed ?? false;
    message.pendingFrameCount = object.pendingFrameCount ?? 0;
    message.errorFrameCount = object.errorFrameCount ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseReportConfig(): ReportConfig {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
    description: "",
    groupPreferencesetAssignments: [],
  };
}

export const ReportConfig: MessageFns<ReportConfig> = {
  encode(message: ReportConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.groupPreferencesetAssignments) {
      ReportConfig_GroupPreferenceSetAssignment.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.groupPreferencesetAssignments.push(
            ReportConfig_GroupPreferenceSetAssignment.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      groupPreferencesetAssignments: globalThis.Array.isArray(object?.groupPreferencesetAssignments)
        ? object.groupPreferencesetAssignments.map((e: any) => ReportConfig_GroupPreferenceSetAssignment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.groupPreferencesetAssignments?.length) {
      obj.groupPreferencesetAssignments = message.groupPreferencesetAssignments.map((e) =>
        ReportConfig_GroupPreferenceSetAssignment.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ReportConfig>): ReportConfig {
    return ReportConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportConfig>): ReportConfig {
    const message = createBaseReportConfig();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.groupPreferencesetAssignments =
      object.groupPreferencesetAssignments?.map((e) => ReportConfig_GroupPreferenceSetAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportConfig_GroupPreferenceSetAssignment(): ReportConfig_GroupPreferenceSetAssignment {
  return { group: "", preferenceSet: "" };
}

export const ReportConfig_GroupPreferenceSetAssignment: MessageFns<ReportConfig_GroupPreferenceSetAssignment> = {
  encode(message: ReportConfig_GroupPreferenceSetAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.preferenceSet !== "") {
      writer.uint32(18).string(message.preferenceSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportConfig_GroupPreferenceSetAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportConfig_GroupPreferenceSetAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferenceSet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportConfig_GroupPreferenceSetAssignment {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      preferenceSet: isSet(object.preferenceSet) ? globalThis.String(object.preferenceSet) : "",
    };
  },

  toJSON(message: ReportConfig_GroupPreferenceSetAssignment): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.preferenceSet !== "") {
      obj.preferenceSet = message.preferenceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportConfig_GroupPreferenceSetAssignment>): ReportConfig_GroupPreferenceSetAssignment {
    return ReportConfig_GroupPreferenceSetAssignment.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ReportConfig_GroupPreferenceSetAssignment>,
  ): ReportConfig_GroupPreferenceSetAssignment {
    const message = createBaseReportConfig_GroupPreferenceSetAssignment();
    message.group = object.group ?? "";
    message.preferenceSet = object.preferenceSet ?? "";
    return message;
  },
};

function createBaseReport(): Report {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    displayName: "",
    description: "",
    type: 0,
    state: 0,
    summary: undefined,
  };
}

export const Report: MessageFns<Report> = {
  encode(message: Report, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.summary !== undefined) {
      ReportSummary.encode(message.summary, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.summary = ReportSummary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? report_TypeFromJSON(object.type) : 0,
      state: isSet(object.state) ? report_StateFromJSON(object.state) : 0,
      summary: isSet(object.summary) ? ReportSummary.fromJSON(object.summary) : undefined,
    };
  },

  toJSON(message: Report): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = report_TypeToJSON(message.type);
    }
    if (message.state !== 0) {
      obj.state = report_StateToJSON(message.state);
    }
    if (message.summary !== undefined) {
      obj.summary = ReportSummary.toJSON(message.summary);
    }
    return obj;
  },

  create(base?: DeepPartial<Report>): Report {
    return Report.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Report>): Report {
    const message = createBaseReport();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.state = object.state ?? 0;
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? ReportSummary.fromPartial(object.summary)
      : undefined;
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? assetViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = assetViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [], nextPageToken: "", unreachable: [] };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAssetRequest(): GetAssetRequest {
  return { name: "", view: 0 };
}

export const GetAssetRequest: MessageFns<GetAssetRequest> = {
  encode(message: GetAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? assetViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = assetViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetRequest>): GetAssetRequest {
    return GetAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetRequest>): GetAssetRequest {
    const message = createBaseGetAssetRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseUpdateAssetRequest(): UpdateAssetRequest {
  return { updateMask: undefined, asset: undefined, requestId: "" };
}

export const UpdateAssetRequest: MessageFns<UpdateAssetRequest> = {
  encode(message: UpdateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAssetRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateAssetRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    return UpdateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAssetRequest>): UpdateAssetRequest {
    const message = createBaseUpdateAssetRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseBatchUpdateAssetsRequest(): BatchUpdateAssetsRequest {
  return { parent: "", requests: [] };
}

export const BatchUpdateAssetsRequest: MessageFns<BatchUpdateAssetsRequest> = {
  encode(message: BatchUpdateAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      UpdateAssetRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(UpdateAssetRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateAssetRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateAssetRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateAssetsRequest>): BatchUpdateAssetsRequest {
    return BatchUpdateAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateAssetsRequest>): BatchUpdateAssetsRequest {
    const message = createBaseBatchUpdateAssetsRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => UpdateAssetRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateAssetsResponse(): BatchUpdateAssetsResponse {
  return { assets: [] };
}

export const BatchUpdateAssetsResponse: MessageFns<BatchUpdateAssetsResponse> = {
  encode(message: BatchUpdateAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateAssetsResponse {
    return { assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [] };
  },

  toJSON(message: BatchUpdateAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateAssetsResponse>): BatchUpdateAssetsResponse {
    return BatchUpdateAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateAssetsResponse>): BatchUpdateAssetsResponse {
    const message = createBaseBatchUpdateAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteAssetRequest(): DeleteAssetRequest {
  return { name: "", requestId: "" };
}

export const DeleteAssetRequest: MessageFns<DeleteAssetRequest> = {
  encode(message: DeleteAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    return DeleteAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    const message = createBaseDeleteAssetRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseBatchDeleteAssetsRequest(): BatchDeleteAssetsRequest {
  return { parent: "", names: [], allowMissing: false };
}

export const BatchDeleteAssetsRequest: MessageFns<BatchDeleteAssetsRequest> = {
  encode(message: BatchDeleteAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: BatchDeleteAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteAssetsRequest>): BatchDeleteAssetsRequest {
    return BatchDeleteAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteAssetsRequest>): BatchDeleteAssetsRequest {
    const message = createBaseBatchDeleteAssetsRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseReportAssetFramesRequest(): ReportAssetFramesRequest {
  return { parent: "", frames: undefined, source: "" };
}

export const ReportAssetFramesRequest: MessageFns<ReportAssetFramesRequest> = {
  encode(message: ReportAssetFramesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.frames !== undefined) {
      Frames.encode(message.frames, writer.uint32(18).fork()).join();
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportAssetFramesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportAssetFramesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.frames = Frames.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportAssetFramesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      frames: isSet(object.frames) ? Frames.fromJSON(object.frames) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: ReportAssetFramesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.frames !== undefined) {
      obj.frames = Frames.toJSON(message.frames);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportAssetFramesRequest>): ReportAssetFramesRequest {
    return ReportAssetFramesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportAssetFramesRequest>): ReportAssetFramesRequest {
    const message = createBaseReportAssetFramesRequest();
    message.parent = object.parent ?? "";
    message.frames = (object.frames !== undefined && object.frames !== null)
      ? Frames.fromPartial(object.frames)
      : undefined;
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseReportAssetFramesResponse(): ReportAssetFramesResponse {
  return {};
}

export const ReportAssetFramesResponse: MessageFns<ReportAssetFramesResponse> = {
  encode(_: ReportAssetFramesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportAssetFramesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportAssetFramesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReportAssetFramesResponse {
    return {};
  },

  toJSON(_: ReportAssetFramesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReportAssetFramesResponse>): ReportAssetFramesResponse {
    return ReportAssetFramesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReportAssetFramesResponse>): ReportAssetFramesResponse {
    const message = createBaseReportAssetFramesResponse();
    return message;
  },
};

function createBaseAggregateAssetsValuesRequest(): AggregateAssetsValuesRequest {
  return { parent: "", aggregations: [], filter: "" };
}

export const AggregateAssetsValuesRequest: MessageFns<AggregateAssetsValuesRequest> = {
  encode(message: AggregateAssetsValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.aggregations) {
      Aggregation.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateAssetsValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateAssetsValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aggregations.push(Aggregation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateAssetsValuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => Aggregation.fromJSON(e))
        : [],
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: AggregateAssetsValuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => Aggregation.toJSON(e));
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateAssetsValuesRequest>): AggregateAssetsValuesRequest {
    return AggregateAssetsValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateAssetsValuesRequest>): AggregateAssetsValuesRequest {
    const message = createBaseAggregateAssetsValuesRequest();
    message.parent = object.parent ?? "";
    message.aggregations = object.aggregations?.map((e) => Aggregation.fromPartial(e)) || [];
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseAggregateAssetsValuesResponse(): AggregateAssetsValuesResponse {
  return { results: [] };
}

export const AggregateAssetsValuesResponse: MessageFns<AggregateAssetsValuesResponse> = {
  encode(message: AggregateAssetsValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      AggregationResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregateAssetsValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateAssetsValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(AggregationResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateAssetsValuesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => AggregationResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateAssetsValuesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => AggregationResult.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateAssetsValuesResponse>): AggregateAssetsValuesResponse {
    return AggregateAssetsValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateAssetsValuesResponse>): AggregateAssetsValuesResponse {
    const message = createBaseAggregateAssetsValuesResponse();
    message.results = object.results?.map((e) => AggregationResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateImportJobRequest(): CreateImportJobRequest {
  return { parent: "", importJobId: "", importJob: undefined, requestId: "" };
}

export const CreateImportJobRequest: MessageFns<CreateImportJobRequest> = {
  encode(message: CreateImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.importJobId !== "") {
      writer.uint32(18).string(message.importJobId);
    }
    if (message.importJob !== undefined) {
      ImportJob.encode(message.importJob, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importJobId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.importJob = ImportJob.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImportJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      importJobId: isSet(object.importJobId) ? globalThis.String(object.importJobId) : "",
      importJob: isSet(object.importJob) ? ImportJob.fromJSON(object.importJob) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateImportJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.importJobId !== "") {
      obj.importJobId = message.importJobId;
    }
    if (message.importJob !== undefined) {
      obj.importJob = ImportJob.toJSON(message.importJob);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateImportJobRequest>): CreateImportJobRequest {
    return CreateImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateImportJobRequest>): CreateImportJobRequest {
    const message = createBaseCreateImportJobRequest();
    message.parent = object.parent ?? "";
    message.importJobId = object.importJobId ?? "";
    message.importJob = (object.importJob !== undefined && object.importJob !== null)
      ? ImportJob.fromPartial(object.importJob)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListImportJobsRequest(): ListImportJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListImportJobsRequest: MessageFns<ListImportJobsRequest> = {
  encode(message: ListImportJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? importJobViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListImportJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = importJobViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportJobsRequest>): ListImportJobsRequest {
    return ListImportJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportJobsRequest>): ListImportJobsRequest {
    const message = createBaseListImportJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListImportJobsResponse(): ListImportJobsResponse {
  return { importJobs: [], nextPageToken: "", unreachable: [] };
}

export const ListImportJobsResponse: MessageFns<ListImportJobsResponse> = {
  encode(message: ListImportJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.importJobs) {
      ImportJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.importJobs.push(ImportJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportJobsResponse {
    return {
      importJobs: globalThis.Array.isArray(object?.importJobs)
        ? object.importJobs.map((e: any) => ImportJob.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListImportJobsResponse): unknown {
    const obj: any = {};
    if (message.importJobs?.length) {
      obj.importJobs = message.importJobs.map((e) => ImportJob.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportJobsResponse>): ListImportJobsResponse {
    return ListImportJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportJobsResponse>): ListImportJobsResponse {
    const message = createBaseListImportJobsResponse();
    message.importJobs = object.importJobs?.map((e) => ImportJob.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetImportJobRequest(): GetImportJobRequest {
  return { name: "", view: 0 };
}

export const GetImportJobRequest: MessageFns<GetImportJobRequest> = {
  encode(message: GetImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? importJobViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetImportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = importJobViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportJobRequest>): GetImportJobRequest {
    return GetImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportJobRequest>): GetImportJobRequest {
    const message = createBaseGetImportJobRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseDeleteImportJobRequest(): DeleteImportJobRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteImportJobRequest: MessageFns<DeleteImportJobRequest> = {
  encode(message: DeleteImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteImportJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteImportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteImportJobRequest>): DeleteImportJobRequest {
    return DeleteImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteImportJobRequest>): DeleteImportJobRequest {
    const message = createBaseDeleteImportJobRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUpdateImportJobRequest(): UpdateImportJobRequest {
  return { updateMask: undefined, importJob: undefined, requestId: "" };
}

export const UpdateImportJobRequest: MessageFns<UpdateImportJobRequest> = {
  encode(message: UpdateImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.importJob !== undefined) {
      ImportJob.encode(message.importJob, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importJob = ImportJob.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateImportJobRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      importJob: isSet(object.importJob) ? ImportJob.fromJSON(object.importJob) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateImportJobRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.importJob !== undefined) {
      obj.importJob = ImportJob.toJSON(message.importJob);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateImportJobRequest>): UpdateImportJobRequest {
    return UpdateImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateImportJobRequest>): UpdateImportJobRequest {
    const message = createBaseUpdateImportJobRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.importJob = (object.importJob !== undefined && object.importJob !== null)
      ? ImportJob.fromPartial(object.importJob)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseValidateImportJobRequest(): ValidateImportJobRequest {
  return { name: "", requestId: "" };
}

export const ValidateImportJobRequest: MessageFns<ValidateImportJobRequest> = {
  encode(message: ValidateImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateImportJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ValidateImportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateImportJobRequest>): ValidateImportJobRequest {
    return ValidateImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateImportJobRequest>): ValidateImportJobRequest {
    const message = createBaseValidateImportJobRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRunImportJobRequest(): RunImportJobRequest {
  return { name: "", requestId: "" };
}

export const RunImportJobRequest: MessageFns<RunImportJobRequest> = {
  encode(message: RunImportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunImportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunImportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunImportJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RunImportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RunImportJobRequest>): RunImportJobRequest {
    return RunImportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunImportJobRequest>): RunImportJobRequest {
    const message = createBaseRunImportJobRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetImportDataFileRequest(): GetImportDataFileRequest {
  return { name: "" };
}

export const GetImportDataFileRequest: MessageFns<GetImportDataFileRequest> = {
  encode(message: GetImportDataFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetImportDataFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetImportDataFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetImportDataFileRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetImportDataFileRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetImportDataFileRequest>): GetImportDataFileRequest {
    return GetImportDataFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetImportDataFileRequest>): GetImportDataFileRequest {
    const message = createBaseGetImportDataFileRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListImportDataFilesRequest(): ListImportDataFilesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListImportDataFilesRequest: MessageFns<ListImportDataFilesRequest> = {
  encode(message: ListImportDataFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportDataFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportDataFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportDataFilesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListImportDataFilesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportDataFilesRequest>): ListImportDataFilesRequest {
    return ListImportDataFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportDataFilesRequest>): ListImportDataFilesRequest {
    const message = createBaseListImportDataFilesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListImportDataFilesResponse(): ListImportDataFilesResponse {
  return { importDataFiles: [], nextPageToken: "", unreachable: [] };
}

export const ListImportDataFilesResponse: MessageFns<ListImportDataFilesResponse> = {
  encode(message: ListImportDataFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.importDataFiles) {
      ImportDataFile.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListImportDataFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListImportDataFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.importDataFiles.push(ImportDataFile.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListImportDataFilesResponse {
    return {
      importDataFiles: globalThis.Array.isArray(object?.importDataFiles)
        ? object.importDataFiles.map((e: any) => ImportDataFile.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListImportDataFilesResponse): unknown {
    const obj: any = {};
    if (message.importDataFiles?.length) {
      obj.importDataFiles = message.importDataFiles.map((e) => ImportDataFile.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListImportDataFilesResponse>): ListImportDataFilesResponse {
    return ListImportDataFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListImportDataFilesResponse>): ListImportDataFilesResponse {
    const message = createBaseListImportDataFilesResponse();
    message.importDataFiles = object.importDataFiles?.map((e) => ImportDataFile.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateImportDataFileRequest(): CreateImportDataFileRequest {
  return { parent: "", importDataFileId: "", importDataFile: undefined, requestId: "" };
}

export const CreateImportDataFileRequest: MessageFns<CreateImportDataFileRequest> = {
  encode(message: CreateImportDataFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.importDataFileId !== "") {
      writer.uint32(18).string(message.importDataFileId);
    }
    if (message.importDataFile !== undefined) {
      ImportDataFile.encode(message.importDataFile, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateImportDataFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateImportDataFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importDataFileId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.importDataFile = ImportDataFile.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateImportDataFileRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      importDataFileId: isSet(object.importDataFileId) ? globalThis.String(object.importDataFileId) : "",
      importDataFile: isSet(object.importDataFile) ? ImportDataFile.fromJSON(object.importDataFile) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateImportDataFileRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.importDataFileId !== "") {
      obj.importDataFileId = message.importDataFileId;
    }
    if (message.importDataFile !== undefined) {
      obj.importDataFile = ImportDataFile.toJSON(message.importDataFile);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateImportDataFileRequest>): CreateImportDataFileRequest {
    return CreateImportDataFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateImportDataFileRequest>): CreateImportDataFileRequest {
    const message = createBaseCreateImportDataFileRequest();
    message.parent = object.parent ?? "";
    message.importDataFileId = object.importDataFileId ?? "";
    message.importDataFile = (object.importDataFile !== undefined && object.importDataFile !== null)
      ? ImportDataFile.fromPartial(object.importDataFile)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteImportDataFileRequest(): DeleteImportDataFileRequest {
  return { name: "", requestId: "" };
}

export const DeleteImportDataFileRequest: MessageFns<DeleteImportDataFileRequest> = {
  encode(message: DeleteImportDataFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteImportDataFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteImportDataFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteImportDataFileRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteImportDataFileRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteImportDataFileRequest>): DeleteImportDataFileRequest {
    return DeleteImportDataFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteImportDataFileRequest>): DeleteImportDataFileRequest {
    const message = createBaseDeleteImportDataFileRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListGroupsRequest(): ListGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListGroupsRequest: MessageFns<ListGroupsRequest> = {
  encode(message: ListGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    return ListGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    const message = createBaseListGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListGroupsResponse(): ListGroupsResponse {
  return { groups: [], nextPageToken: "", unreachable: [] };
}

export const ListGroupsResponse: MessageFns<ListGroupsResponse> = {
  encode(message: ListGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsResponse {
    return {
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListGroupsResponse): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    return ListGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    const message = createBaseListGroupsResponse();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetGroupRequest(): GetGroupRequest {
  return { name: "" };
}

export const GetGroupRequest: MessageFns<GetGroupRequest> = {
  encode(message: GetGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGroupRequest>): GetGroupRequest {
    return GetGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGroupRequest>): GetGroupRequest {
    const message = createBaseGetGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { parent: "", groupId: "", group: undefined, requestId: "" };
}

export const CreateGroupRequest: MessageFns<CreateGroupRequest> = {
  encode(message: CreateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.parent = object.parent ?? "";
    message.groupId = object.groupId ?? "";
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateGroupRequest(): UpdateGroupRequest {
  return { updateMask: undefined, group: undefined, requestId: "" };
}

export const UpdateGroupRequest: MessageFns<UpdateGroupRequest> = {
  encode(message: UpdateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGroupRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateGroupRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    return UpdateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    const message = createBaseUpdateGroupRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteGroupRequest(): DeleteGroupRequest {
  return { name: "", requestId: "" };
}

export const DeleteGroupRequest: MessageFns<DeleteGroupRequest> = {
  encode(message: DeleteGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    return DeleteGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    const message = createBaseDeleteGroupRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseAddAssetsToGroupRequest(): AddAssetsToGroupRequest {
  return { group: "", requestId: "", assets: undefined, allowExisting: false };
}

export const AddAssetsToGroupRequest: MessageFns<AddAssetsToGroupRequest> = {
  encode(message: AddAssetsToGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.assets !== undefined) {
      AssetList.encode(message.assets, writer.uint32(26).fork()).join();
    }
    if (message.allowExisting !== false) {
      writer.uint32(32).bool(message.allowExisting);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddAssetsToGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddAssetsToGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assets = AssetList.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowExisting = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddAssetsToGroupRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      assets: isSet(object.assets) ? AssetList.fromJSON(object.assets) : undefined,
      allowExisting: isSet(object.allowExisting) ? globalThis.Boolean(object.allowExisting) : false,
    };
  },

  toJSON(message: AddAssetsToGroupRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.assets !== undefined) {
      obj.assets = AssetList.toJSON(message.assets);
    }
    if (message.allowExisting !== false) {
      obj.allowExisting = message.allowExisting;
    }
    return obj;
  },

  create(base?: DeepPartial<AddAssetsToGroupRequest>): AddAssetsToGroupRequest {
    return AddAssetsToGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddAssetsToGroupRequest>): AddAssetsToGroupRequest {
    const message = createBaseAddAssetsToGroupRequest();
    message.group = object.group ?? "";
    message.requestId = object.requestId ?? "";
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? AssetList.fromPartial(object.assets)
      : undefined;
    message.allowExisting = object.allowExisting ?? false;
    return message;
  },
};

function createBaseRemoveAssetsFromGroupRequest(): RemoveAssetsFromGroupRequest {
  return { group: "", requestId: "", assets: undefined, allowMissing: false };
}

export const RemoveAssetsFromGroupRequest: MessageFns<RemoveAssetsFromGroupRequest> = {
  encode(message: RemoveAssetsFromGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.assets !== undefined) {
      AssetList.encode(message.assets, writer.uint32(26).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveAssetsFromGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveAssetsFromGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assets = AssetList.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveAssetsFromGroupRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      assets: isSet(object.assets) ? AssetList.fromJSON(object.assets) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: RemoveAssetsFromGroupRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.assets !== undefined) {
      obj.assets = AssetList.toJSON(message.assets);
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveAssetsFromGroupRequest>): RemoveAssetsFromGroupRequest {
    return RemoveAssetsFromGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveAssetsFromGroupRequest>): RemoveAssetsFromGroupRequest {
    const message = createBaseRemoveAssetsFromGroupRequest();
    message.group = object.group ?? "";
    message.requestId = object.requestId ?? "";
    message.assets = (object.assets !== undefined && object.assets !== null)
      ? AssetList.fromPartial(object.assets)
      : undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseListErrorFramesRequest(): ListErrorFramesRequest {
  return { parent: "", pageSize: 0, pageToken: "", view: 0 };
}

export const ListErrorFramesRequest: MessageFns<ListErrorFramesRequest> = {
  encode(message: ListErrorFramesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.view !== 0) {
      writer.uint32(32).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListErrorFramesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListErrorFramesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListErrorFramesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      view: isSet(object.view) ? errorFrameViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListErrorFramesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.view !== 0) {
      obj.view = errorFrameViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListErrorFramesRequest>): ListErrorFramesRequest {
    return ListErrorFramesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListErrorFramesRequest>): ListErrorFramesRequest {
    const message = createBaseListErrorFramesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListErrorFramesResponse(): ListErrorFramesResponse {
  return { errorFrames: [], nextPageToken: "", unreachable: [] };
}

export const ListErrorFramesResponse: MessageFns<ListErrorFramesResponse> = {
  encode(message: ListErrorFramesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errorFrames) {
      ErrorFrame.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListErrorFramesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListErrorFramesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorFrames.push(ErrorFrame.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListErrorFramesResponse {
    return {
      errorFrames: globalThis.Array.isArray(object?.errorFrames)
        ? object.errorFrames.map((e: any) => ErrorFrame.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListErrorFramesResponse): unknown {
    const obj: any = {};
    if (message.errorFrames?.length) {
      obj.errorFrames = message.errorFrames.map((e) => ErrorFrame.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListErrorFramesResponse>): ListErrorFramesResponse {
    return ListErrorFramesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListErrorFramesResponse>): ListErrorFramesResponse {
    const message = createBaseListErrorFramesResponse();
    message.errorFrames = object.errorFrames?.map((e) => ErrorFrame.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetErrorFrameRequest(): GetErrorFrameRequest {
  return { name: "", view: 0 };
}

export const GetErrorFrameRequest: MessageFns<GetErrorFrameRequest> = {
  encode(message: GetErrorFrameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetErrorFrameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetErrorFrameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetErrorFrameRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? errorFrameViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetErrorFrameRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = errorFrameViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetErrorFrameRequest>): GetErrorFrameRequest {
    return GetErrorFrameRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetErrorFrameRequest>): GetErrorFrameRequest {
    const message = createBaseGetErrorFrameRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListSourcesRequest(): ListSourcesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSourcesRequest: MessageFns<ListSourcesRequest> = {
  encode(message: ListSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    return ListSourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesRequest>): ListSourcesRequest {
    const message = createBaseListSourcesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSourcesResponse(): ListSourcesResponse {
  return { sources: [], nextPageToken: "", unreachable: [] };
}

export const ListSourcesResponse: MessageFns<ListSourcesResponse> = {
  encode(message: ListSourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sources) {
      Source.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sources.push(Source.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSourcesResponse {
    return {
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => Source.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListSourcesResponse): unknown {
    const obj: any = {};
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => Source.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    return ListSourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSourcesResponse>): ListSourcesResponse {
    const message = createBaseListSourcesResponse();
    message.sources = object.sources?.map((e) => Source.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSourceRequest(): GetSourceRequest {
  return { name: "" };
}

export const GetSourceRequest: MessageFns<GetSourceRequest> = {
  encode(message: GetSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSourceRequest>): GetSourceRequest {
    return GetSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSourceRequest>): GetSourceRequest {
    const message = createBaseGetSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateSourceRequest(): CreateSourceRequest {
  return { parent: "", sourceId: "", source: undefined, requestId: "" };
}

export const CreateSourceRequest: MessageFns<CreateSourceRequest> = {
  encode(message: CreateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.sourceId !== "") {
      writer.uint32(18).string(message.sourceId);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSourceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateSourceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    return CreateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSourceRequest>): CreateSourceRequest {
    const message = createBaseCreateSourceRequest();
    message.parent = object.parent ?? "";
    message.sourceId = object.sourceId ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateSourceRequest(): UpdateSourceRequest {
  return { updateMask: undefined, source: undefined, requestId: "" };
}

export const UpdateSourceRequest: MessageFns<UpdateSourceRequest> = {
  encode(message: UpdateSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSourceRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateSourceRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    return UpdateSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSourceRequest>): UpdateSourceRequest {
    const message = createBaseUpdateSourceRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteSourceRequest(): DeleteSourceRequest {
  return { name: "", requestId: "" };
}

export const DeleteSourceRequest: MessageFns<DeleteSourceRequest> = {
  encode(message: DeleteSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSourceRequest>): DeleteSourceRequest {
    return DeleteSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSourceRequest>): DeleteSourceRequest {
    const message = createBaseDeleteSourceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListPreferenceSetsRequest(): ListPreferenceSetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", orderBy: "" };
}

export const ListPreferenceSetsRequest: MessageFns<ListPreferenceSetsRequest> = {
  encode(message: ListPreferenceSetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceSetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceSetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceSetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPreferenceSetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPreferenceSetsRequest>): ListPreferenceSetsRequest {
    return ListPreferenceSetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPreferenceSetsRequest>): ListPreferenceSetsRequest {
    const message = createBaseListPreferenceSetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPreferenceSetsResponse(): ListPreferenceSetsResponse {
  return { preferenceSets: [], nextPageToken: "", unreachable: [] };
}

export const ListPreferenceSetsResponse: MessageFns<ListPreferenceSetsResponse> = {
  encode(message: ListPreferenceSetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.preferenceSets) {
      PreferenceSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPreferenceSetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPreferenceSetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preferenceSets.push(PreferenceSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPreferenceSetsResponse {
    return {
      preferenceSets: globalThis.Array.isArray(object?.preferenceSets)
        ? object.preferenceSets.map((e: any) => PreferenceSet.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListPreferenceSetsResponse): unknown {
    const obj: any = {};
    if (message.preferenceSets?.length) {
      obj.preferenceSets = message.preferenceSets.map((e) => PreferenceSet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPreferenceSetsResponse>): ListPreferenceSetsResponse {
    return ListPreferenceSetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPreferenceSetsResponse>): ListPreferenceSetsResponse {
    const message = createBaseListPreferenceSetsResponse();
    message.preferenceSets = object.preferenceSets?.map((e) => PreferenceSet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPreferenceSetRequest(): GetPreferenceSetRequest {
  return { name: "" };
}

export const GetPreferenceSetRequest: MessageFns<GetPreferenceSetRequest> = {
  encode(message: GetPreferenceSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPreferenceSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPreferenceSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPreferenceSetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPreferenceSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPreferenceSetRequest>): GetPreferenceSetRequest {
    return GetPreferenceSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPreferenceSetRequest>): GetPreferenceSetRequest {
    const message = createBaseGetPreferenceSetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreatePreferenceSetRequest(): CreatePreferenceSetRequest {
  return { parent: "", preferenceSetId: "", preferenceSet: undefined, requestId: "" };
}

export const CreatePreferenceSetRequest: MessageFns<CreatePreferenceSetRequest> = {
  encode(message: CreatePreferenceSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.preferenceSetId !== "") {
      writer.uint32(18).string(message.preferenceSetId);
    }
    if (message.preferenceSet !== undefined) {
      PreferenceSet.encode(message.preferenceSet, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePreferenceSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePreferenceSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferenceSetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.preferenceSet = PreferenceSet.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePreferenceSetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      preferenceSetId: isSet(object.preferenceSetId) ? globalThis.String(object.preferenceSetId) : "",
      preferenceSet: isSet(object.preferenceSet) ? PreferenceSet.fromJSON(object.preferenceSet) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreatePreferenceSetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.preferenceSetId !== "") {
      obj.preferenceSetId = message.preferenceSetId;
    }
    if (message.preferenceSet !== undefined) {
      obj.preferenceSet = PreferenceSet.toJSON(message.preferenceSet);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePreferenceSetRequest>): CreatePreferenceSetRequest {
    return CreatePreferenceSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePreferenceSetRequest>): CreatePreferenceSetRequest {
    const message = createBaseCreatePreferenceSetRequest();
    message.parent = object.parent ?? "";
    message.preferenceSetId = object.preferenceSetId ?? "";
    message.preferenceSet = (object.preferenceSet !== undefined && object.preferenceSet !== null)
      ? PreferenceSet.fromPartial(object.preferenceSet)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdatePreferenceSetRequest(): UpdatePreferenceSetRequest {
  return { updateMask: undefined, preferenceSet: undefined, requestId: "" };
}

export const UpdatePreferenceSetRequest: MessageFns<UpdatePreferenceSetRequest> = {
  encode(message: UpdatePreferenceSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.preferenceSet !== undefined) {
      PreferenceSet.encode(message.preferenceSet, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePreferenceSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePreferenceSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferenceSet = PreferenceSet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePreferenceSetRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      preferenceSet: isSet(object.preferenceSet) ? PreferenceSet.fromJSON(object.preferenceSet) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdatePreferenceSetRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.preferenceSet !== undefined) {
      obj.preferenceSet = PreferenceSet.toJSON(message.preferenceSet);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePreferenceSetRequest>): UpdatePreferenceSetRequest {
    return UpdatePreferenceSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePreferenceSetRequest>): UpdatePreferenceSetRequest {
    const message = createBaseUpdatePreferenceSetRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.preferenceSet = (object.preferenceSet !== undefined && object.preferenceSet !== null)
      ? PreferenceSet.fromPartial(object.preferenceSet)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeletePreferenceSetRequest(): DeletePreferenceSetRequest {
  return { name: "", requestId: "" };
}

export const DeletePreferenceSetRequest: MessageFns<DeletePreferenceSetRequest> = {
  encode(message: DeletePreferenceSetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePreferenceSetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePreferenceSetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePreferenceSetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeletePreferenceSetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePreferenceSetRequest>): DeletePreferenceSetRequest {
    return DeletePreferenceSetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePreferenceSetRequest>): DeletePreferenceSetRequest {
    const message = createBaseDeletePreferenceSetRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetSettingsRequest(): GetSettingsRequest {
  return { name: "" };
}

export const GetSettingsRequest: MessageFns<GetSettingsRequest> = {
  encode(message: GetSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSettingsRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSettingsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    return GetSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSettingsRequest>): GetSettingsRequest {
    const message = createBaseGetSettingsRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
  return { updateMask: undefined, settings: undefined, requestId: "" };
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
  encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingsRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateSettingsRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    return UpdateSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSettingsRequest>): UpdateSettingsRequest {
    const message = createBaseUpdateSettingsRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateReportConfigRequest(): CreateReportConfigRequest {
  return { parent: "", reportConfigId: "", reportConfig: undefined, requestId: "" };
}

export const CreateReportConfigRequest: MessageFns<CreateReportConfigRequest> = {
  encode(message: CreateReportConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reportConfigId !== "") {
      writer.uint32(18).string(message.reportConfigId);
    }
    if (message.reportConfig !== undefined) {
      ReportConfig.encode(message.reportConfig, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReportConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReportConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportConfigId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reportConfig = ReportConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReportConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reportConfigId: isSet(object.reportConfigId) ? globalThis.String(object.reportConfigId) : "",
      reportConfig: isSet(object.reportConfig) ? ReportConfig.fromJSON(object.reportConfig) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateReportConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reportConfigId !== "") {
      obj.reportConfigId = message.reportConfigId;
    }
    if (message.reportConfig !== undefined) {
      obj.reportConfig = ReportConfig.toJSON(message.reportConfig);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReportConfigRequest>): CreateReportConfigRequest {
    return CreateReportConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReportConfigRequest>): CreateReportConfigRequest {
    const message = createBaseCreateReportConfigRequest();
    message.parent = object.parent ?? "";
    message.reportConfigId = object.reportConfigId ?? "";
    message.reportConfig = (object.reportConfig !== undefined && object.reportConfig !== null)
      ? ReportConfig.fromPartial(object.reportConfig)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteReportConfigRequest(): DeleteReportConfigRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteReportConfigRequest: MessageFns<DeleteReportConfigRequest> = {
  encode(message: DeleteReportConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReportConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReportConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReportConfigRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteReportConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReportConfigRequest>): DeleteReportConfigRequest {
    return DeleteReportConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReportConfigRequest>): DeleteReportConfigRequest {
    const message = createBaseDeleteReportConfigRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseGetReportRequest(): GetReportRequest {
  return { name: "", view: 0 };
}

export const GetReportRequest: MessageFns<GetReportRequest> = {
  encode(message: GetReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? reportViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetReportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = reportViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReportRequest>): GetReportRequest {
    return GetReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReportRequest>): GetReportRequest {
    const message = createBaseGetReportRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListReportsRequest(): ListReportsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListReportsRequest: MessageFns<ListReportsRequest> = {
  encode(message: ListReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? reportViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListReportsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = reportViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportsRequest>): ListReportsRequest {
    return ListReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportsRequest>): ListReportsRequest {
    const message = createBaseListReportsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListReportsResponse(): ListReportsResponse {
  return { reports: [], nextPageToken: "", unreachable: [] };
}

export const ListReportsResponse: MessageFns<ListReportsResponse> = {
  encode(message: ListReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reports) {
      Report.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reports.push(Report.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsResponse {
    return {
      reports: globalThis.Array.isArray(object?.reports) ? object.reports.map((e: any) => Report.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListReportsResponse): unknown {
    const obj: any = {};
    if (message.reports?.length) {
      obj.reports = message.reports.map((e) => Report.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportsResponse>): ListReportsResponse {
    return ListReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportsResponse>): ListReportsResponse {
    const message = createBaseListReportsResponse();
    message.reports = object.reports?.map((e) => Report.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteReportRequest(): DeleteReportRequest {
  return { name: "", requestId: "" };
}

export const DeleteReportRequest: MessageFns<DeleteReportRequest> = {
  encode(message: DeleteReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReportRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteReportRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReportRequest>): DeleteReportRequest {
    return DeleteReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReportRequest>): DeleteReportRequest {
    const message = createBaseDeleteReportRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetReportConfigRequest(): GetReportConfigRequest {
  return { name: "" };
}

export const GetReportConfigRequest: MessageFns<GetReportConfigRequest> = {
  encode(message: GetReportConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReportConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReportConfigRequest>): GetReportConfigRequest {
    return GetReportConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReportConfigRequest>): GetReportConfigRequest {
    const message = createBaseGetReportConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListReportConfigsRequest(): ListReportConfigsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListReportConfigsRequest: MessageFns<ListReportConfigsRequest> = {
  encode(message: ListReportConfigsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportConfigsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportConfigsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportConfigsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListReportConfigsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportConfigsRequest>): ListReportConfigsRequest {
    return ListReportConfigsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportConfigsRequest>): ListReportConfigsRequest {
    const message = createBaseListReportConfigsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListReportConfigsResponse(): ListReportConfigsResponse {
  return { reportConfigs: [], nextPageToken: "", unreachable: [] };
}

export const ListReportConfigsResponse: MessageFns<ListReportConfigsResponse> = {
  encode(message: ListReportConfigsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reportConfigs) {
      ReportConfig.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportConfigsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportConfigsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reportConfigs.push(ReportConfig.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportConfigsResponse {
    return {
      reportConfigs: globalThis.Array.isArray(object?.reportConfigs)
        ? object.reportConfigs.map((e: any) => ReportConfig.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListReportConfigsResponse): unknown {
    const obj: any = {};
    if (message.reportConfigs?.length) {
      obj.reportConfigs = message.reportConfigs.map((e) => ReportConfig.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportConfigsResponse>): ListReportConfigsResponse {
    return ListReportConfigsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportConfigsResponse>): ListReportConfigsResponse {
    const message = createBaseListReportConfigsResponse();
    message.reportConfigs = object.reportConfigs?.map((e) => ReportConfig.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateReportRequest(): CreateReportRequest {
  return { parent: "", reportId: "", report: undefined, requestId: "" };
}

export const CreateReportRequest: MessageFns<CreateReportRequest> = {
  encode(message: CreateReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reportId !== "") {
      writer.uint32(18).string(message.reportId);
    }
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReportRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reportId: isSet(object.reportId) ? globalThis.String(object.reportId) : "",
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateReportRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reportId !== "") {
      obj.reportId = message.reportId;
    }
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReportRequest>): CreateReportRequest {
    return CreateReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReportRequest>): CreateReportRequest {
    const message = createBaseCreateReportRequest();
    message.parent = object.parent ?? "";
    message.reportId = object.reportId ?? "";
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseFrames(): Frames {
  return { framesData: [] };
}

export const Frames: MessageFns<Frames> = {
  encode(message: Frames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.framesData) {
      AssetFrame.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Frames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.framesData.push(AssetFrame.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Frames {
    return {
      framesData: globalThis.Array.isArray(object?.framesData)
        ? object.framesData.map((e: any) => AssetFrame.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Frames): unknown {
    const obj: any = {};
    if (message.framesData?.length) {
      obj.framesData = message.framesData.map((e) => AssetFrame.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Frames>): Frames {
    return Frames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Frames>): Frames {
    const message = createBaseFrames();
    message.framesData = object.framesData?.map((e) => AssetFrame.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssetFrame(): AssetFrame {
  return {
    machineDetails: undefined,
    reportTime: undefined,
    labels: {},
    attributes: {},
    performanceSamples: [],
    traceToken: "",
  };
}

export const AssetFrame: MessageFns<AssetFrame> = {
  encode(message: AssetFrame, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineDetails !== undefined) {
      MachineDetails.encode(message.machineDetails, writer.uint32(10).fork()).join();
    }
    if (message.reportTime !== undefined) {
      Timestamp.encode(toTimestamp(message.reportTime), writer.uint32(82).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      AssetFrame_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    Object.entries(message.attributes).forEach(([key, value]) => {
      AssetFrame_AttributesEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    for (const v of message.performanceSamples) {
      PerformanceSample.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.traceToken !== "") {
      writer.uint32(114).string(message.traceToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetFrame {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineDetails = MachineDetails.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.reportTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = AssetFrame_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = AssetFrame_AttributesEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.attributes[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.performanceSamples.push(PerformanceSample.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.traceToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetFrame {
    return {
      machineDetails: isSet(object.machineDetails) ? MachineDetails.fromJSON(object.machineDetails) : undefined,
      reportTime: isSet(object.reportTime) ? fromJsonTimestamp(object.reportTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      performanceSamples: globalThis.Array.isArray(object?.performanceSamples)
        ? object.performanceSamples.map((e: any) => PerformanceSample.fromJSON(e))
        : [],
      traceToken: isSet(object.traceToken) ? globalThis.String(object.traceToken) : "",
    };
  },

  toJSON(message: AssetFrame): unknown {
    const obj: any = {};
    if (message.machineDetails !== undefined) {
      obj.machineDetails = MachineDetails.toJSON(message.machineDetails);
    }
    if (message.reportTime !== undefined) {
      obj.reportTime = message.reportTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.performanceSamples?.length) {
      obj.performanceSamples = message.performanceSamples.map((e) => PerformanceSample.toJSON(e));
    }
    if (message.traceToken !== "") {
      obj.traceToken = message.traceToken;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetFrame>): AssetFrame {
    return AssetFrame.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetFrame>): AssetFrame {
    const message = createBaseAssetFrame();
    message.machineDetails = (object.machineDetails !== undefined && object.machineDetails !== null)
      ? MachineDetails.fromPartial(object.machineDetails)
      : undefined;
    message.reportTime = object.reportTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.performanceSamples = object.performanceSamples?.map((e) => PerformanceSample.fromPartial(e)) || [];
    message.traceToken = object.traceToken ?? "";
    return message;
  },
};

function createBaseAssetFrame_LabelsEntry(): AssetFrame_LabelsEntry {
  return { key: "", value: "" };
}

export const AssetFrame_LabelsEntry: MessageFns<AssetFrame_LabelsEntry> = {
  encode(message: AssetFrame_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetFrame_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetFrame_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetFrame_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssetFrame_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetFrame_LabelsEntry>): AssetFrame_LabelsEntry {
    return AssetFrame_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetFrame_LabelsEntry>): AssetFrame_LabelsEntry {
    const message = createBaseAssetFrame_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAssetFrame_AttributesEntry(): AssetFrame_AttributesEntry {
  return { key: "", value: "" };
}

export const AssetFrame_AttributesEntry: MessageFns<AssetFrame_AttributesEntry> = {
  encode(message: AssetFrame_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetFrame_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetFrame_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetFrame_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssetFrame_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetFrame_AttributesEntry>): AssetFrame_AttributesEntry {
    return AssetFrame_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetFrame_AttributesEntry>): AssetFrame_AttributesEntry {
    const message = createBaseAssetFrame_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMachineDetails(): MachineDetails {
  return {
    uuid: "",
    machineName: "",
    createTime: undefined,
    coreCount: 0,
    memoryMb: 0,
    powerState: 0,
    architecture: undefined,
    guestOs: undefined,
    network: undefined,
    disks: undefined,
    platform: undefined,
  };
}

export const MachineDetails: MessageFns<MachineDetails> = {
  encode(message: MachineDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.machineName !== "") {
      writer.uint32(18).string(message.machineName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.coreCount !== 0) {
      writer.uint32(32).int32(message.coreCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(40).int32(message.memoryMb);
    }
    if (message.powerState !== 0) {
      writer.uint32(48).int32(message.powerState);
    }
    if (message.architecture !== undefined) {
      MachineArchitectureDetails.encode(message.architecture, writer.uint32(58).fork()).join();
    }
    if (message.guestOs !== undefined) {
      GuestOsDetails.encode(message.guestOs, writer.uint32(66).fork()).join();
    }
    if (message.network !== undefined) {
      MachineNetworkDetails.encode(message.network, writer.uint32(74).fork()).join();
    }
    if (message.disks !== undefined) {
      MachineDiskDetails.encode(message.disks, writer.uint32(82).fork()).join();
    }
    if (message.platform !== undefined) {
      PlatformDetails.encode(message.platform, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.machineName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.coreCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.powerState = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.architecture = MachineArchitectureDetails.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.guestOs = GuestOsDetails.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.network = MachineNetworkDetails.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.disks = MachineDiskDetails.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.platform = PlatformDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineDetails {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      machineName: isSet(object.machineName) ? globalThis.String(object.machineName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      coreCount: isSet(object.coreCount) ? globalThis.Number(object.coreCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      powerState: isSet(object.powerState) ? machineDetails_PowerStateFromJSON(object.powerState) : 0,
      architecture: isSet(object.architecture) ? MachineArchitectureDetails.fromJSON(object.architecture) : undefined,
      guestOs: isSet(object.guestOs) ? GuestOsDetails.fromJSON(object.guestOs) : undefined,
      network: isSet(object.network) ? MachineNetworkDetails.fromJSON(object.network) : undefined,
      disks: isSet(object.disks) ? MachineDiskDetails.fromJSON(object.disks) : undefined,
      platform: isSet(object.platform) ? PlatformDetails.fromJSON(object.platform) : undefined,
    };
  },

  toJSON(message: MachineDetails): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.coreCount !== 0) {
      obj.coreCount = Math.round(message.coreCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.powerState !== 0) {
      obj.powerState = machineDetails_PowerStateToJSON(message.powerState);
    }
    if (message.architecture !== undefined) {
      obj.architecture = MachineArchitectureDetails.toJSON(message.architecture);
    }
    if (message.guestOs !== undefined) {
      obj.guestOs = GuestOsDetails.toJSON(message.guestOs);
    }
    if (message.network !== undefined) {
      obj.network = MachineNetworkDetails.toJSON(message.network);
    }
    if (message.disks !== undefined) {
      obj.disks = MachineDiskDetails.toJSON(message.disks);
    }
    if (message.platform !== undefined) {
      obj.platform = PlatformDetails.toJSON(message.platform);
    }
    return obj;
  },

  create(base?: DeepPartial<MachineDetails>): MachineDetails {
    return MachineDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineDetails>): MachineDetails {
    const message = createBaseMachineDetails();
    message.uuid = object.uuid ?? "";
    message.machineName = object.machineName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.coreCount = object.coreCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.powerState = object.powerState ?? 0;
    message.architecture = (object.architecture !== undefined && object.architecture !== null)
      ? MachineArchitectureDetails.fromPartial(object.architecture)
      : undefined;
    message.guestOs = (object.guestOs !== undefined && object.guestOs !== null)
      ? GuestOsDetails.fromPartial(object.guestOs)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? MachineNetworkDetails.fromPartial(object.network)
      : undefined;
    message.disks = (object.disks !== undefined && object.disks !== null)
      ? MachineDiskDetails.fromPartial(object.disks)
      : undefined;
    message.platform = (object.platform !== undefined && object.platform !== null)
      ? PlatformDetails.fromPartial(object.platform)
      : undefined;
    return message;
  },
};

function createBaseMachineArchitectureDetails(): MachineArchitectureDetails {
  return {
    cpuArchitecture: "",
    cpuName: "",
    vendor: "",
    cpuThreadCount: 0,
    cpuSocketCount: 0,
    bios: undefined,
    firmwareType: 0,
    hyperthreading: 0,
  };
}

export const MachineArchitectureDetails: MessageFns<MachineArchitectureDetails> = {
  encode(message: MachineArchitectureDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuArchitecture !== "") {
      writer.uint32(10).string(message.cpuArchitecture);
    }
    if (message.cpuName !== "") {
      writer.uint32(18).string(message.cpuName);
    }
    if (message.vendor !== "") {
      writer.uint32(26).string(message.vendor);
    }
    if (message.cpuThreadCount !== 0) {
      writer.uint32(32).int32(message.cpuThreadCount);
    }
    if (message.cpuSocketCount !== 0) {
      writer.uint32(40).int32(message.cpuSocketCount);
    }
    if (message.bios !== undefined) {
      BiosDetails.encode(message.bios, writer.uint32(50).fork()).join();
    }
    if (message.firmwareType !== 0) {
      writer.uint32(56).int32(message.firmwareType);
    }
    if (message.hyperthreading !== 0) {
      writer.uint32(64).int32(message.hyperthreading);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineArchitectureDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineArchitectureDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpuArchitecture = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpuName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vendor = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cpuThreadCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.cpuSocketCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bios = BiosDetails.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.firmwareType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.hyperthreading = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineArchitectureDetails {
    return {
      cpuArchitecture: isSet(object.cpuArchitecture) ? globalThis.String(object.cpuArchitecture) : "",
      cpuName: isSet(object.cpuName) ? globalThis.String(object.cpuName) : "",
      vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : "",
      cpuThreadCount: isSet(object.cpuThreadCount) ? globalThis.Number(object.cpuThreadCount) : 0,
      cpuSocketCount: isSet(object.cpuSocketCount) ? globalThis.Number(object.cpuSocketCount) : 0,
      bios: isSet(object.bios) ? BiosDetails.fromJSON(object.bios) : undefined,
      firmwareType: isSet(object.firmwareType)
        ? machineArchitectureDetails_FirmwareTypeFromJSON(object.firmwareType)
        : 0,
      hyperthreading: isSet(object.hyperthreading)
        ? machineArchitectureDetails_CpuHyperThreadingFromJSON(object.hyperthreading)
        : 0,
    };
  },

  toJSON(message: MachineArchitectureDetails): unknown {
    const obj: any = {};
    if (message.cpuArchitecture !== "") {
      obj.cpuArchitecture = message.cpuArchitecture;
    }
    if (message.cpuName !== "") {
      obj.cpuName = message.cpuName;
    }
    if (message.vendor !== "") {
      obj.vendor = message.vendor;
    }
    if (message.cpuThreadCount !== 0) {
      obj.cpuThreadCount = Math.round(message.cpuThreadCount);
    }
    if (message.cpuSocketCount !== 0) {
      obj.cpuSocketCount = Math.round(message.cpuSocketCount);
    }
    if (message.bios !== undefined) {
      obj.bios = BiosDetails.toJSON(message.bios);
    }
    if (message.firmwareType !== 0) {
      obj.firmwareType = machineArchitectureDetails_FirmwareTypeToJSON(message.firmwareType);
    }
    if (message.hyperthreading !== 0) {
      obj.hyperthreading = machineArchitectureDetails_CpuHyperThreadingToJSON(message.hyperthreading);
    }
    return obj;
  },

  create(base?: DeepPartial<MachineArchitectureDetails>): MachineArchitectureDetails {
    return MachineArchitectureDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineArchitectureDetails>): MachineArchitectureDetails {
    const message = createBaseMachineArchitectureDetails();
    message.cpuArchitecture = object.cpuArchitecture ?? "";
    message.cpuName = object.cpuName ?? "";
    message.vendor = object.vendor ?? "";
    message.cpuThreadCount = object.cpuThreadCount ?? 0;
    message.cpuSocketCount = object.cpuSocketCount ?? 0;
    message.bios = (object.bios !== undefined && object.bios !== null)
      ? BiosDetails.fromPartial(object.bios)
      : undefined;
    message.firmwareType = object.firmwareType ?? 0;
    message.hyperthreading = object.hyperthreading ?? 0;
    return message;
  },
};

function createBaseBiosDetails(): BiosDetails {
  return { biosName: "", id: "", manufacturer: "", version: "", releaseDate: undefined, smbiosUuid: "" };
}

export const BiosDetails: MessageFns<BiosDetails> = {
  encode(message: BiosDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.biosName !== "") {
      writer.uint32(10).string(message.biosName);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.manufacturer !== "") {
      writer.uint32(26).string(message.manufacturer);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.releaseDate !== undefined) {
      DateMessage.encode(message.releaseDate, writer.uint32(42).fork()).join();
    }
    if (message.smbiosUuid !== "") {
      writer.uint32(50).string(message.smbiosUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BiosDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBiosDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.biosName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.manufacturer = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.releaseDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.smbiosUuid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BiosDetails {
    return {
      biosName: isSet(object.biosName) ? globalThis.String(object.biosName) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      manufacturer: isSet(object.manufacturer) ? globalThis.String(object.manufacturer) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      releaseDate: isSet(object.releaseDate) ? DateMessage.fromJSON(object.releaseDate) : undefined,
      smbiosUuid: isSet(object.smbiosUuid) ? globalThis.String(object.smbiosUuid) : "",
    };
  },

  toJSON(message: BiosDetails): unknown {
    const obj: any = {};
    if (message.biosName !== "") {
      obj.biosName = message.biosName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.manufacturer !== "") {
      obj.manufacturer = message.manufacturer;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.releaseDate !== undefined) {
      obj.releaseDate = DateMessage.toJSON(message.releaseDate);
    }
    if (message.smbiosUuid !== "") {
      obj.smbiosUuid = message.smbiosUuid;
    }
    return obj;
  },

  create(base?: DeepPartial<BiosDetails>): BiosDetails {
    return BiosDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BiosDetails>): BiosDetails {
    const message = createBaseBiosDetails();
    message.biosName = object.biosName ?? "";
    message.id = object.id ?? "";
    message.manufacturer = object.manufacturer ?? "";
    message.version = object.version ?? "";
    message.releaseDate = (object.releaseDate !== undefined && object.releaseDate !== null)
      ? DateMessage.fromPartial(object.releaseDate)
      : undefined;
    message.smbiosUuid = object.smbiosUuid ?? "";
    return message;
  },
};

function createBaseMachineNetworkDetails(): MachineNetworkDetails {
  return { primaryIpAddress: "", publicIpAddress: "", primaryMacAddress: "", adapters: undefined };
}

export const MachineNetworkDetails: MessageFns<MachineNetworkDetails> = {
  encode(message: MachineNetworkDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryIpAddress !== "") {
      writer.uint32(10).string(message.primaryIpAddress);
    }
    if (message.publicIpAddress !== "") {
      writer.uint32(18).string(message.publicIpAddress);
    }
    if (message.primaryMacAddress !== "") {
      writer.uint32(26).string(message.primaryMacAddress);
    }
    if (message.adapters !== undefined) {
      NetworkAdapterList.encode(message.adapters, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineNetworkDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineNetworkDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryIpAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicIpAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.primaryMacAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.adapters = NetworkAdapterList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineNetworkDetails {
    return {
      primaryIpAddress: isSet(object.primaryIpAddress) ? globalThis.String(object.primaryIpAddress) : "",
      publicIpAddress: isSet(object.publicIpAddress) ? globalThis.String(object.publicIpAddress) : "",
      primaryMacAddress: isSet(object.primaryMacAddress) ? globalThis.String(object.primaryMacAddress) : "",
      adapters: isSet(object.adapters) ? NetworkAdapterList.fromJSON(object.adapters) : undefined,
    };
  },

  toJSON(message: MachineNetworkDetails): unknown {
    const obj: any = {};
    if (message.primaryIpAddress !== "") {
      obj.primaryIpAddress = message.primaryIpAddress;
    }
    if (message.publicIpAddress !== "") {
      obj.publicIpAddress = message.publicIpAddress;
    }
    if (message.primaryMacAddress !== "") {
      obj.primaryMacAddress = message.primaryMacAddress;
    }
    if (message.adapters !== undefined) {
      obj.adapters = NetworkAdapterList.toJSON(message.adapters);
    }
    return obj;
  },

  create(base?: DeepPartial<MachineNetworkDetails>): MachineNetworkDetails {
    return MachineNetworkDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineNetworkDetails>): MachineNetworkDetails {
    const message = createBaseMachineNetworkDetails();
    message.primaryIpAddress = object.primaryIpAddress ?? "";
    message.publicIpAddress = object.publicIpAddress ?? "";
    message.primaryMacAddress = object.primaryMacAddress ?? "";
    message.adapters = (object.adapters !== undefined && object.adapters !== null)
      ? NetworkAdapterList.fromPartial(object.adapters)
      : undefined;
    return message;
  },
};

function createBaseNetworkAdapterList(): NetworkAdapterList {
  return { entries: [] };
}

export const NetworkAdapterList: MessageFns<NetworkAdapterList> = {
  encode(message: NetworkAdapterList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NetworkAdapterDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAdapterList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAdapterList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(NetworkAdapterDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAdapterList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => NetworkAdapterDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkAdapterList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => NetworkAdapterDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkAdapterList>): NetworkAdapterList {
    return NetworkAdapterList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkAdapterList>): NetworkAdapterList {
    const message = createBaseNetworkAdapterList();
    message.entries = object.entries?.map((e) => NetworkAdapterDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkAdapterDetails(): NetworkAdapterDetails {
  return { adapterType: "", macAddress: "", addresses: undefined };
}

export const NetworkAdapterDetails: MessageFns<NetworkAdapterDetails> = {
  encode(message: NetworkAdapterDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adapterType !== "") {
      writer.uint32(10).string(message.adapterType);
    }
    if (message.macAddress !== "") {
      writer.uint32(18).string(message.macAddress);
    }
    if (message.addresses !== undefined) {
      NetworkAddressList.encode(message.addresses, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAdapterDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAdapterDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adapterType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.macAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addresses = NetworkAddressList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAdapterDetails {
    return {
      adapterType: isSet(object.adapterType) ? globalThis.String(object.adapterType) : "",
      macAddress: isSet(object.macAddress) ? globalThis.String(object.macAddress) : "",
      addresses: isSet(object.addresses) ? NetworkAddressList.fromJSON(object.addresses) : undefined,
    };
  },

  toJSON(message: NetworkAdapterDetails): unknown {
    const obj: any = {};
    if (message.adapterType !== "") {
      obj.adapterType = message.adapterType;
    }
    if (message.macAddress !== "") {
      obj.macAddress = message.macAddress;
    }
    if (message.addresses !== undefined) {
      obj.addresses = NetworkAddressList.toJSON(message.addresses);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkAdapterDetails>): NetworkAdapterDetails {
    return NetworkAdapterDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkAdapterDetails>): NetworkAdapterDetails {
    const message = createBaseNetworkAdapterDetails();
    message.adapterType = object.adapterType ?? "";
    message.macAddress = object.macAddress ?? "";
    message.addresses = (object.addresses !== undefined && object.addresses !== null)
      ? NetworkAddressList.fromPartial(object.addresses)
      : undefined;
    return message;
  },
};

function createBaseNetworkAddressList(): NetworkAddressList {
  return { entries: [] };
}

export const NetworkAddressList: MessageFns<NetworkAddressList> = {
  encode(message: NetworkAddressList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NetworkAddress.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAddressList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAddressList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(NetworkAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAddressList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => NetworkAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkAddressList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => NetworkAddress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkAddressList>): NetworkAddressList {
    return NetworkAddressList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkAddressList>): NetworkAddressList {
    const message = createBaseNetworkAddressList();
    message.entries = object.entries?.map((e) => NetworkAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkAddress(): NetworkAddress {
  return { ipAddress: "", subnetMask: "", bcast: "", fqdn: "", assignment: 0 };
}

export const NetworkAddress: MessageFns<NetworkAddress> = {
  encode(message: NetworkAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.subnetMask !== "") {
      writer.uint32(18).string(message.subnetMask);
    }
    if (message.bcast !== "") {
      writer.uint32(26).string(message.bcast);
    }
    if (message.fqdn !== "") {
      writer.uint32(34).string(message.fqdn);
    }
    if (message.assignment !== 0) {
      writer.uint32(40).int32(message.assignment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetMask = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bcast = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fqdn = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.assignment = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAddress {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      subnetMask: isSet(object.subnetMask) ? globalThis.String(object.subnetMask) : "",
      bcast: isSet(object.bcast) ? globalThis.String(object.bcast) : "",
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
      assignment: isSet(object.assignment) ? networkAddress_AddressAssignmentFromJSON(object.assignment) : 0,
    };
  },

  toJSON(message: NetworkAddress): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.subnetMask !== "") {
      obj.subnetMask = message.subnetMask;
    }
    if (message.bcast !== "") {
      obj.bcast = message.bcast;
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    if (message.assignment !== 0) {
      obj.assignment = networkAddress_AddressAssignmentToJSON(message.assignment);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkAddress>): NetworkAddress {
    return NetworkAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkAddress>): NetworkAddress {
    const message = createBaseNetworkAddress();
    message.ipAddress = object.ipAddress ?? "";
    message.subnetMask = object.subnetMask ?? "";
    message.bcast = object.bcast ?? "";
    message.fqdn = object.fqdn ?? "";
    message.assignment = object.assignment ?? 0;
    return message;
  },
};

function createBaseMachineDiskDetails(): MachineDiskDetails {
  return { totalCapacityBytes: Long.ZERO, totalFreeBytes: Long.ZERO, disks: undefined };
}

export const MachineDiskDetails: MessageFns<MachineDiskDetails> = {
  encode(message: MachineDiskDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalCapacityBytes.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalCapacityBytes.toString());
    }
    if (!message.totalFreeBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalFreeBytes.toString());
    }
    if (message.disks !== undefined) {
      DiskEntryList.encode(message.disks, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineDiskDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineDiskDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalCapacityBytes = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalFreeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.disks = DiskEntryList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineDiskDetails {
    return {
      totalCapacityBytes: isSet(object.totalCapacityBytes) ? Long.fromValue(object.totalCapacityBytes) : Long.ZERO,
      totalFreeBytes: isSet(object.totalFreeBytes) ? Long.fromValue(object.totalFreeBytes) : Long.ZERO,
      disks: isSet(object.disks) ? DiskEntryList.fromJSON(object.disks) : undefined,
    };
  },

  toJSON(message: MachineDiskDetails): unknown {
    const obj: any = {};
    if (!message.totalCapacityBytes.equals(Long.ZERO)) {
      obj.totalCapacityBytes = (message.totalCapacityBytes || Long.ZERO).toString();
    }
    if (!message.totalFreeBytes.equals(Long.ZERO)) {
      obj.totalFreeBytes = (message.totalFreeBytes || Long.ZERO).toString();
    }
    if (message.disks !== undefined) {
      obj.disks = DiskEntryList.toJSON(message.disks);
    }
    return obj;
  },

  create(base?: DeepPartial<MachineDiskDetails>): MachineDiskDetails {
    return MachineDiskDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineDiskDetails>): MachineDiskDetails {
    const message = createBaseMachineDiskDetails();
    message.totalCapacityBytes = (object.totalCapacityBytes !== undefined && object.totalCapacityBytes !== null)
      ? Long.fromValue(object.totalCapacityBytes)
      : Long.ZERO;
    message.totalFreeBytes = (object.totalFreeBytes !== undefined && object.totalFreeBytes !== null)
      ? Long.fromValue(object.totalFreeBytes)
      : Long.ZERO;
    message.disks = (object.disks !== undefined && object.disks !== null)
      ? DiskEntryList.fromPartial(object.disks)
      : undefined;
    return message;
  },
};

function createBaseDiskEntryList(): DiskEntryList {
  return { entries: [] };
}

export const DiskEntryList: MessageFns<DiskEntryList> = {
  encode(message: DiskEntryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      DiskEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskEntryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskEntryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(DiskEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskEntryList {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => DiskEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: DiskEntryList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => DiskEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DiskEntryList>): DiskEntryList {
    return DiskEntryList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskEntryList>): DiskEntryList {
    const message = createBaseDiskEntryList();
    message.entries = object.entries?.map((e) => DiskEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiskEntry(): DiskEntry {
  return {
    capacityBytes: Long.ZERO,
    freeBytes: Long.ZERO,
    diskLabel: "",
    diskLabelType: "",
    interfaceType: 0,
    partitions: undefined,
    hwAddress: "",
    vmware: undefined,
  };
}

export const DiskEntry: MessageFns<DiskEntry> = {
  encode(message: DiskEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.capacityBytes.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.capacityBytes.toString());
    }
    if (!message.freeBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.freeBytes.toString());
    }
    if (message.diskLabel !== "") {
      writer.uint32(26).string(message.diskLabel);
    }
    if (message.diskLabelType !== "") {
      writer.uint32(34).string(message.diskLabelType);
    }
    if (message.interfaceType !== 0) {
      writer.uint32(40).int32(message.interfaceType);
    }
    if (message.partitions !== undefined) {
      DiskPartitionList.encode(message.partitions, writer.uint32(50).fork()).join();
    }
    if (message.hwAddress !== "") {
      writer.uint32(58).string(message.hwAddress);
    }
    if (message.vmware !== undefined) {
      VmwareDiskConfig.encode(message.vmware, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.capacityBytes = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.freeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.diskLabel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.diskLabelType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.interfaceType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.partitions = DiskPartitionList.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hwAddress = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.vmware = VmwareDiskConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskEntry {
    return {
      capacityBytes: isSet(object.capacityBytes) ? Long.fromValue(object.capacityBytes) : Long.ZERO,
      freeBytes: isSet(object.freeBytes) ? Long.fromValue(object.freeBytes) : Long.ZERO,
      diskLabel: isSet(object.diskLabel) ? globalThis.String(object.diskLabel) : "",
      diskLabelType: isSet(object.diskLabelType) ? globalThis.String(object.diskLabelType) : "",
      interfaceType: isSet(object.interfaceType) ? diskEntry_InterfaceTypeFromJSON(object.interfaceType) : 0,
      partitions: isSet(object.partitions) ? DiskPartitionList.fromJSON(object.partitions) : undefined,
      hwAddress: isSet(object.hwAddress) ? globalThis.String(object.hwAddress) : "",
      vmware: isSet(object.vmware) ? VmwareDiskConfig.fromJSON(object.vmware) : undefined,
    };
  },

  toJSON(message: DiskEntry): unknown {
    const obj: any = {};
    if (!message.capacityBytes.equals(Long.ZERO)) {
      obj.capacityBytes = (message.capacityBytes || Long.ZERO).toString();
    }
    if (!message.freeBytes.equals(Long.ZERO)) {
      obj.freeBytes = (message.freeBytes || Long.ZERO).toString();
    }
    if (message.diskLabel !== "") {
      obj.diskLabel = message.diskLabel;
    }
    if (message.diskLabelType !== "") {
      obj.diskLabelType = message.diskLabelType;
    }
    if (message.interfaceType !== 0) {
      obj.interfaceType = diskEntry_InterfaceTypeToJSON(message.interfaceType);
    }
    if (message.partitions !== undefined) {
      obj.partitions = DiskPartitionList.toJSON(message.partitions);
    }
    if (message.hwAddress !== "") {
      obj.hwAddress = message.hwAddress;
    }
    if (message.vmware !== undefined) {
      obj.vmware = VmwareDiskConfig.toJSON(message.vmware);
    }
    return obj;
  },

  create(base?: DeepPartial<DiskEntry>): DiskEntry {
    return DiskEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskEntry>): DiskEntry {
    const message = createBaseDiskEntry();
    message.capacityBytes = (object.capacityBytes !== undefined && object.capacityBytes !== null)
      ? Long.fromValue(object.capacityBytes)
      : Long.ZERO;
    message.freeBytes = (object.freeBytes !== undefined && object.freeBytes !== null)
      ? Long.fromValue(object.freeBytes)
      : Long.ZERO;
    message.diskLabel = object.diskLabel ?? "";
    message.diskLabelType = object.diskLabelType ?? "";
    message.interfaceType = object.interfaceType ?? 0;
    message.partitions = (object.partitions !== undefined && object.partitions !== null)
      ? DiskPartitionList.fromPartial(object.partitions)
      : undefined;
    message.hwAddress = object.hwAddress ?? "";
    message.vmware = (object.vmware !== undefined && object.vmware !== null)
      ? VmwareDiskConfig.fromPartial(object.vmware)
      : undefined;
    return message;
  },
};

function createBaseDiskPartitionList(): DiskPartitionList {
  return { entries: [] };
}

export const DiskPartitionList: MessageFns<DiskPartitionList> = {
  encode(message: DiskPartitionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      DiskPartition.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskPartitionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskPartitionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(DiskPartition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskPartitionList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => DiskPartition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DiskPartitionList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => DiskPartition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DiskPartitionList>): DiskPartitionList {
    return DiskPartitionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskPartitionList>): DiskPartitionList {
    const message = createBaseDiskPartitionList();
    message.entries = object.entries?.map((e) => DiskPartition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiskPartition(): DiskPartition {
  return {
    type: "",
    fileSystem: "",
    mountPoint: "",
    capacityBytes: Long.ZERO,
    freeBytes: Long.ZERO,
    uuid: "",
    subPartitions: undefined,
  };
}

export const DiskPartition: MessageFns<DiskPartition> = {
  encode(message: DiskPartition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.fileSystem !== "") {
      writer.uint32(18).string(message.fileSystem);
    }
    if (message.mountPoint !== "") {
      writer.uint32(26).string(message.mountPoint);
    }
    if (!message.capacityBytes.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.capacityBytes.toString());
    }
    if (!message.freeBytes.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.freeBytes.toString());
    }
    if (message.uuid !== "") {
      writer.uint32(50).string(message.uuid);
    }
    if (message.subPartitions !== undefined) {
      DiskPartitionList.encode(message.subPartitions, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskPartition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskPartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileSystem = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mountPoint = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.capacityBytes = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.freeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subPartitions = DiskPartitionList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskPartition {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      fileSystem: isSet(object.fileSystem) ? globalThis.String(object.fileSystem) : "",
      mountPoint: isSet(object.mountPoint) ? globalThis.String(object.mountPoint) : "",
      capacityBytes: isSet(object.capacityBytes) ? Long.fromValue(object.capacityBytes) : Long.ZERO,
      freeBytes: isSet(object.freeBytes) ? Long.fromValue(object.freeBytes) : Long.ZERO,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      subPartitions: isSet(object.subPartitions) ? DiskPartitionList.fromJSON(object.subPartitions) : undefined,
    };
  },

  toJSON(message: DiskPartition): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.fileSystem !== "") {
      obj.fileSystem = message.fileSystem;
    }
    if (message.mountPoint !== "") {
      obj.mountPoint = message.mountPoint;
    }
    if (!message.capacityBytes.equals(Long.ZERO)) {
      obj.capacityBytes = (message.capacityBytes || Long.ZERO).toString();
    }
    if (!message.freeBytes.equals(Long.ZERO)) {
      obj.freeBytes = (message.freeBytes || Long.ZERO).toString();
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.subPartitions !== undefined) {
      obj.subPartitions = DiskPartitionList.toJSON(message.subPartitions);
    }
    return obj;
  },

  create(base?: DeepPartial<DiskPartition>): DiskPartition {
    return DiskPartition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskPartition>): DiskPartition {
    const message = createBaseDiskPartition();
    message.type = object.type ?? "";
    message.fileSystem = object.fileSystem ?? "";
    message.mountPoint = object.mountPoint ?? "";
    message.capacityBytes = (object.capacityBytes !== undefined && object.capacityBytes !== null)
      ? Long.fromValue(object.capacityBytes)
      : Long.ZERO;
    message.freeBytes = (object.freeBytes !== undefined && object.freeBytes !== null)
      ? Long.fromValue(object.freeBytes)
      : Long.ZERO;
    message.uuid = object.uuid ?? "";
    message.subPartitions = (object.subPartitions !== undefined && object.subPartitions !== null)
      ? DiskPartitionList.fromPartial(object.subPartitions)
      : undefined;
    return message;
  },
};

function createBaseVmwareDiskConfig(): VmwareDiskConfig {
  return { backingType: 0, shared: false, vmdkMode: 0, rdmCompatibility: 0 };
}

export const VmwareDiskConfig: MessageFns<VmwareDiskConfig> = {
  encode(message: VmwareDiskConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backingType !== 0) {
      writer.uint32(8).int32(message.backingType);
    }
    if (message.shared !== false) {
      writer.uint32(16).bool(message.shared);
    }
    if (message.vmdkMode !== 0) {
      writer.uint32(24).int32(message.vmdkMode);
    }
    if (message.rdmCompatibility !== 0) {
      writer.uint32(32).int32(message.rdmCompatibility);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareDiskConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareDiskConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.backingType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.shared = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.vmdkMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rdmCompatibility = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareDiskConfig {
    return {
      backingType: isSet(object.backingType) ? vmwareDiskConfig_BackingTypeFromJSON(object.backingType) : 0,
      shared: isSet(object.shared) ? globalThis.Boolean(object.shared) : false,
      vmdkMode: isSet(object.vmdkMode) ? vmwareDiskConfig_VmdkModeFromJSON(object.vmdkMode) : 0,
      rdmCompatibility: isSet(object.rdmCompatibility)
        ? vmwareDiskConfig_RdmCompatibilityFromJSON(object.rdmCompatibility)
        : 0,
    };
  },

  toJSON(message: VmwareDiskConfig): unknown {
    const obj: any = {};
    if (message.backingType !== 0) {
      obj.backingType = vmwareDiskConfig_BackingTypeToJSON(message.backingType);
    }
    if (message.shared !== false) {
      obj.shared = message.shared;
    }
    if (message.vmdkMode !== 0) {
      obj.vmdkMode = vmwareDiskConfig_VmdkModeToJSON(message.vmdkMode);
    }
    if (message.rdmCompatibility !== 0) {
      obj.rdmCompatibility = vmwareDiskConfig_RdmCompatibilityToJSON(message.rdmCompatibility);
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareDiskConfig>): VmwareDiskConfig {
    return VmwareDiskConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareDiskConfig>): VmwareDiskConfig {
    const message = createBaseVmwareDiskConfig();
    message.backingType = object.backingType ?? 0;
    message.shared = object.shared ?? false;
    message.vmdkMode = object.vmdkMode ?? 0;
    message.rdmCompatibility = object.rdmCompatibility ?? 0;
    return message;
  },
};

function createBaseGuestOsDetails(): GuestOsDetails {
  return { osName: "", family: 0, version: "", config: undefined, runtime: undefined };
}

export const GuestOsDetails: MessageFns<GuestOsDetails> = {
  encode(message: GuestOsDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.osName !== "") {
      writer.uint32(10).string(message.osName);
    }
    if (message.family !== 0) {
      writer.uint32(16).int32(message.family);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.config !== undefined) {
      GuestConfigDetails.encode(message.config, writer.uint32(34).fork()).join();
    }
    if (message.runtime !== undefined) {
      GuestRuntimeDetails.encode(message.runtime, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestOsDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestOsDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.family = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.config = GuestConfigDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.runtime = GuestRuntimeDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestOsDetails {
    return {
      osName: isSet(object.osName) ? globalThis.String(object.osName) : "",
      family: isSet(object.family) ? operatingSystemFamilyFromJSON(object.family) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      config: isSet(object.config) ? GuestConfigDetails.fromJSON(object.config) : undefined,
      runtime: isSet(object.runtime) ? GuestRuntimeDetails.fromJSON(object.runtime) : undefined,
    };
  },

  toJSON(message: GuestOsDetails): unknown {
    const obj: any = {};
    if (message.osName !== "") {
      obj.osName = message.osName;
    }
    if (message.family !== 0) {
      obj.family = operatingSystemFamilyToJSON(message.family);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.config !== undefined) {
      obj.config = GuestConfigDetails.toJSON(message.config);
    }
    if (message.runtime !== undefined) {
      obj.runtime = GuestRuntimeDetails.toJSON(message.runtime);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestOsDetails>): GuestOsDetails {
    return GuestOsDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestOsDetails>): GuestOsDetails {
    const message = createBaseGuestOsDetails();
    message.osName = object.osName ?? "";
    message.family = object.family ?? 0;
    message.version = object.version ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? GuestConfigDetails.fromPartial(object.config)
      : undefined;
    message.runtime = (object.runtime !== undefined && object.runtime !== null)
      ? GuestRuntimeDetails.fromPartial(object.runtime)
      : undefined;
    return message;
  },
};

function createBaseGuestConfigDetails(): GuestConfigDetails {
  return { issue: "", fstab: undefined, hosts: undefined, nfsExports: undefined, selinuxMode: 0 };
}

export const GuestConfigDetails: MessageFns<GuestConfigDetails> = {
  encode(message: GuestConfigDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== "") {
      writer.uint32(10).string(message.issue);
    }
    if (message.fstab !== undefined) {
      FstabEntryList.encode(message.fstab, writer.uint32(18).fork()).join();
    }
    if (message.hosts !== undefined) {
      HostsEntryList.encode(message.hosts, writer.uint32(26).fork()).join();
    }
    if (message.nfsExports !== undefined) {
      NfsExportList.encode(message.nfsExports, writer.uint32(34).fork()).join();
    }
    if (message.selinuxMode !== 0) {
      writer.uint32(40).int32(message.selinuxMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestConfigDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestConfigDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fstab = FstabEntryList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hosts = HostsEntryList.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nfsExports = NfsExportList.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.selinuxMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestConfigDetails {
    return {
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      fstab: isSet(object.fstab) ? FstabEntryList.fromJSON(object.fstab) : undefined,
      hosts: isSet(object.hosts) ? HostsEntryList.fromJSON(object.hosts) : undefined,
      nfsExports: isSet(object.nfsExports) ? NfsExportList.fromJSON(object.nfsExports) : undefined,
      selinuxMode: isSet(object.selinuxMode) ? guestConfigDetails_SeLinuxModeFromJSON(object.selinuxMode) : 0,
    };
  },

  toJSON(message: GuestConfigDetails): unknown {
    const obj: any = {};
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.fstab !== undefined) {
      obj.fstab = FstabEntryList.toJSON(message.fstab);
    }
    if (message.hosts !== undefined) {
      obj.hosts = HostsEntryList.toJSON(message.hosts);
    }
    if (message.nfsExports !== undefined) {
      obj.nfsExports = NfsExportList.toJSON(message.nfsExports);
    }
    if (message.selinuxMode !== 0) {
      obj.selinuxMode = guestConfigDetails_SeLinuxModeToJSON(message.selinuxMode);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestConfigDetails>): GuestConfigDetails {
    return GuestConfigDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestConfigDetails>): GuestConfigDetails {
    const message = createBaseGuestConfigDetails();
    message.issue = object.issue ?? "";
    message.fstab = (object.fstab !== undefined && object.fstab !== null)
      ? FstabEntryList.fromPartial(object.fstab)
      : undefined;
    message.hosts = (object.hosts !== undefined && object.hosts !== null)
      ? HostsEntryList.fromPartial(object.hosts)
      : undefined;
    message.nfsExports = (object.nfsExports !== undefined && object.nfsExports !== null)
      ? NfsExportList.fromPartial(object.nfsExports)
      : undefined;
    message.selinuxMode = object.selinuxMode ?? 0;
    return message;
  },
};

function createBaseFstabEntryList(): FstabEntryList {
  return { entries: [] };
}

export const FstabEntryList: MessageFns<FstabEntryList> = {
  encode(message: FstabEntryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      FstabEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FstabEntryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFstabEntryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(FstabEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FstabEntryList {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => FstabEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: FstabEntryList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => FstabEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FstabEntryList>): FstabEntryList {
    return FstabEntryList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FstabEntryList>): FstabEntryList {
    const message = createBaseFstabEntryList();
    message.entries = object.entries?.map((e) => FstabEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFstabEntry(): FstabEntry {
  return { spec: "", file: "", vfstype: "", mntops: "", freq: 0, passno: 0 };
}

export const FstabEntry: MessageFns<FstabEntry> = {
  encode(message: FstabEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spec !== "") {
      writer.uint32(10).string(message.spec);
    }
    if (message.file !== "") {
      writer.uint32(18).string(message.file);
    }
    if (message.vfstype !== "") {
      writer.uint32(26).string(message.vfstype);
    }
    if (message.mntops !== "") {
      writer.uint32(34).string(message.mntops);
    }
    if (message.freq !== 0) {
      writer.uint32(40).int32(message.freq);
    }
    if (message.passno !== 0) {
      writer.uint32(48).int32(message.passno);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FstabEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFstabEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spec = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.file = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vfstype = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mntops = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.freq = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.passno = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FstabEntry {
    return {
      spec: isSet(object.spec) ? globalThis.String(object.spec) : "",
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      vfstype: isSet(object.vfstype) ? globalThis.String(object.vfstype) : "",
      mntops: isSet(object.mntops) ? globalThis.String(object.mntops) : "",
      freq: isSet(object.freq) ? globalThis.Number(object.freq) : 0,
      passno: isSet(object.passno) ? globalThis.Number(object.passno) : 0,
    };
  },

  toJSON(message: FstabEntry): unknown {
    const obj: any = {};
    if (message.spec !== "") {
      obj.spec = message.spec;
    }
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.vfstype !== "") {
      obj.vfstype = message.vfstype;
    }
    if (message.mntops !== "") {
      obj.mntops = message.mntops;
    }
    if (message.freq !== 0) {
      obj.freq = Math.round(message.freq);
    }
    if (message.passno !== 0) {
      obj.passno = Math.round(message.passno);
    }
    return obj;
  },

  create(base?: DeepPartial<FstabEntry>): FstabEntry {
    return FstabEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FstabEntry>): FstabEntry {
    const message = createBaseFstabEntry();
    message.spec = object.spec ?? "";
    message.file = object.file ?? "";
    message.vfstype = object.vfstype ?? "";
    message.mntops = object.mntops ?? "";
    message.freq = object.freq ?? 0;
    message.passno = object.passno ?? 0;
    return message;
  },
};

function createBaseHostsEntryList(): HostsEntryList {
  return { entries: [] };
}

export const HostsEntryList: MessageFns<HostsEntryList> = {
  encode(message: HostsEntryList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      HostsEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostsEntryList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostsEntryList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(HostsEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostsEntryList {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => HostsEntry.fromJSON(e)) : [],
    };
  },

  toJSON(message: HostsEntryList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => HostsEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HostsEntryList>): HostsEntryList {
    return HostsEntryList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostsEntryList>): HostsEntryList {
    const message = createBaseHostsEntryList();
    message.entries = object.entries?.map((e) => HostsEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHostsEntry(): HostsEntry {
  return { ip: "", hostNames: [] };
}

export const HostsEntry: MessageFns<HostsEntry> = {
  encode(message: HostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ip !== "") {
      writer.uint32(10).string(message.ip);
    }
    for (const v of message.hostNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostsEntry {
    return {
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      hostNames: globalThis.Array.isArray(object?.hostNames)
        ? object.hostNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: HostsEntry): unknown {
    const obj: any = {};
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.hostNames?.length) {
      obj.hostNames = message.hostNames;
    }
    return obj;
  },

  create(base?: DeepPartial<HostsEntry>): HostsEntry {
    return HostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HostsEntry>): HostsEntry {
    const message = createBaseHostsEntry();
    message.ip = object.ip ?? "";
    message.hostNames = object.hostNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseNfsExportList(): NfsExportList {
  return { entries: [] };
}

export const NfsExportList: MessageFns<NfsExportList> = {
  encode(message: NfsExportList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NfsExport.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NfsExportList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNfsExportList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(NfsExport.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NfsExportList {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => NfsExport.fromJSON(e)) : [],
    };
  },

  toJSON(message: NfsExportList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => NfsExport.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NfsExportList>): NfsExportList {
    return NfsExportList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NfsExportList>): NfsExportList {
    const message = createBaseNfsExportList();
    message.entries = object.entries?.map((e) => NfsExport.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNfsExport(): NfsExport {
  return { exportDirectory: "", hosts: [] };
}

export const NfsExport: MessageFns<NfsExport> = {
  encode(message: NfsExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exportDirectory !== "") {
      writer.uint32(10).string(message.exportDirectory);
    }
    for (const v of message.hosts) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NfsExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNfsExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exportDirectory = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hosts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NfsExport {
    return {
      exportDirectory: isSet(object.exportDirectory) ? globalThis.String(object.exportDirectory) : "",
      hosts: globalThis.Array.isArray(object?.hosts) ? object.hosts.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NfsExport): unknown {
    const obj: any = {};
    if (message.exportDirectory !== "") {
      obj.exportDirectory = message.exportDirectory;
    }
    if (message.hosts?.length) {
      obj.hosts = message.hosts;
    }
    return obj;
  },

  create(base?: DeepPartial<NfsExport>): NfsExport {
    return NfsExport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NfsExport>): NfsExport {
    const message = createBaseNfsExport();
    message.exportDirectory = object.exportDirectory ?? "";
    message.hosts = object.hosts?.map((e) => e) || [];
    return message;
  },
};

function createBaseGuestRuntimeDetails(): GuestRuntimeDetails {
  return {
    services: undefined,
    processes: undefined,
    network: undefined,
    lastBootTime: undefined,
    domain: "",
    machineName: "",
    installedApps: undefined,
    openFileList: undefined,
  };
}

export const GuestRuntimeDetails: MessageFns<GuestRuntimeDetails> = {
  encode(message: GuestRuntimeDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.services !== undefined) {
      RunningServiceList.encode(message.services, writer.uint32(10).fork()).join();
    }
    if (message.processes !== undefined) {
      RunningProcessList.encode(message.processes, writer.uint32(18).fork()).join();
    }
    if (message.network !== undefined) {
      RuntimeNetworkInfo.encode(message.network, writer.uint32(26).fork()).join();
    }
    if (message.lastBootTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastBootTime), writer.uint32(34).fork()).join();
    }
    if (message.domain !== "") {
      writer.uint32(42).string(message.domain);
    }
    if (message.machineName !== "") {
      writer.uint32(50).string(message.machineName);
    }
    if (message.installedApps !== undefined) {
      GuestInstalledApplicationList.encode(message.installedApps, writer.uint32(58).fork()).join();
    }
    if (message.openFileList !== undefined) {
      OpenFileList.encode(message.openFileList, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestRuntimeDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestRuntimeDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.services = RunningServiceList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.processes = RunningProcessList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = RuntimeNetworkInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastBootTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.machineName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.installedApps = GuestInstalledApplicationList.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.openFileList = OpenFileList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestRuntimeDetails {
    return {
      services: isSet(object.services) ? RunningServiceList.fromJSON(object.services) : undefined,
      processes: isSet(object.processes) ? RunningProcessList.fromJSON(object.processes) : undefined,
      network: isSet(object.network) ? RuntimeNetworkInfo.fromJSON(object.network) : undefined,
      lastBootTime: isSet(object.lastBootTime) ? fromJsonTimestamp(object.lastBootTime) : undefined,
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      machineName: isSet(object.machineName) ? globalThis.String(object.machineName) : "",
      installedApps: isSet(object.installedApps)
        ? GuestInstalledApplicationList.fromJSON(object.installedApps)
        : undefined,
      openFileList: isSet(object.openFileList) ? OpenFileList.fromJSON(object.openFileList) : undefined,
    };
  },

  toJSON(message: GuestRuntimeDetails): unknown {
    const obj: any = {};
    if (message.services !== undefined) {
      obj.services = RunningServiceList.toJSON(message.services);
    }
    if (message.processes !== undefined) {
      obj.processes = RunningProcessList.toJSON(message.processes);
    }
    if (message.network !== undefined) {
      obj.network = RuntimeNetworkInfo.toJSON(message.network);
    }
    if (message.lastBootTime !== undefined) {
      obj.lastBootTime = message.lastBootTime.toISOString();
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.machineName !== "") {
      obj.machineName = message.machineName;
    }
    if (message.installedApps !== undefined) {
      obj.installedApps = GuestInstalledApplicationList.toJSON(message.installedApps);
    }
    if (message.openFileList !== undefined) {
      obj.openFileList = OpenFileList.toJSON(message.openFileList);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestRuntimeDetails>): GuestRuntimeDetails {
    return GuestRuntimeDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestRuntimeDetails>): GuestRuntimeDetails {
    const message = createBaseGuestRuntimeDetails();
    message.services = (object.services !== undefined && object.services !== null)
      ? RunningServiceList.fromPartial(object.services)
      : undefined;
    message.processes = (object.processes !== undefined && object.processes !== null)
      ? RunningProcessList.fromPartial(object.processes)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? RuntimeNetworkInfo.fromPartial(object.network)
      : undefined;
    message.lastBootTime = object.lastBootTime ?? undefined;
    message.domain = object.domain ?? "";
    message.machineName = object.machineName ?? "";
    message.installedApps = (object.installedApps !== undefined && object.installedApps !== null)
      ? GuestInstalledApplicationList.fromPartial(object.installedApps)
      : undefined;
    message.openFileList = (object.openFileList !== undefined && object.openFileList !== null)
      ? OpenFileList.fromPartial(object.openFileList)
      : undefined;
    return message;
  },
};

function createBaseRunningServiceList(): RunningServiceList {
  return { entries: [] };
}

export const RunningServiceList: MessageFns<RunningServiceList> = {
  encode(message: RunningServiceList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      RunningService.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunningServiceList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunningServiceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(RunningService.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunningServiceList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => RunningService.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunningServiceList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => RunningService.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunningServiceList>): RunningServiceList {
    return RunningServiceList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunningServiceList>): RunningServiceList {
    const message = createBaseRunningServiceList();
    message.entries = object.entries?.map((e) => RunningService.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunningService(): RunningService {
  return { serviceName: "", state: 0, startMode: 0, exePath: "", cmdline: "", pid: Long.ZERO };
}

export const RunningService: MessageFns<RunningService> = {
  encode(message: RunningService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.startMode !== 0) {
      writer.uint32(24).int32(message.startMode);
    }
    if (message.exePath !== "") {
      writer.uint32(34).string(message.exePath);
    }
    if (message.cmdline !== "") {
      writer.uint32(42).string(message.cmdline);
    }
    if (!message.pid.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.pid.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunningService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunningService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.startMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exePath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cmdline = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pid = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunningService {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      state: isSet(object.state) ? runningService_StateFromJSON(object.state) : 0,
      startMode: isSet(object.startMode) ? runningService_StartModeFromJSON(object.startMode) : 0,
      exePath: isSet(object.exePath) ? globalThis.String(object.exePath) : "",
      cmdline: isSet(object.cmdline) ? globalThis.String(object.cmdline) : "",
      pid: isSet(object.pid) ? Long.fromValue(object.pid) : Long.ZERO,
    };
  },

  toJSON(message: RunningService): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.state !== 0) {
      obj.state = runningService_StateToJSON(message.state);
    }
    if (message.startMode !== 0) {
      obj.startMode = runningService_StartModeToJSON(message.startMode);
    }
    if (message.exePath !== "") {
      obj.exePath = message.exePath;
    }
    if (message.cmdline !== "") {
      obj.cmdline = message.cmdline;
    }
    if (!message.pid.equals(Long.ZERO)) {
      obj.pid = (message.pid || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<RunningService>): RunningService {
    return RunningService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunningService>): RunningService {
    const message = createBaseRunningService();
    message.serviceName = object.serviceName ?? "";
    message.state = object.state ?? 0;
    message.startMode = object.startMode ?? 0;
    message.exePath = object.exePath ?? "";
    message.cmdline = object.cmdline ?? "";
    message.pid = (object.pid !== undefined && object.pid !== null) ? Long.fromValue(object.pid) : Long.ZERO;
    return message;
  },
};

function createBaseRunningProcessList(): RunningProcessList {
  return { entries: [] };
}

export const RunningProcessList: MessageFns<RunningProcessList> = {
  encode(message: RunningProcessList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      RunningProcess.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunningProcessList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunningProcessList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(RunningProcess.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunningProcessList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => RunningProcess.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RunningProcessList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => RunningProcess.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RunningProcessList>): RunningProcessList {
    return RunningProcessList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunningProcessList>): RunningProcessList {
    const message = createBaseRunningProcessList();
    message.entries = object.entries?.map((e) => RunningProcess.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunningProcess(): RunningProcess {
  return { pid: Long.ZERO, exePath: "", cmdline: "", user: "", attributes: {} };
}

export const RunningProcess: MessageFns<RunningProcess> = {
  encode(message: RunningProcess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.pid.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.pid.toString());
    }
    if (message.exePath !== "") {
      writer.uint32(18).string(message.exePath);
    }
    if (message.cmdline !== "") {
      writer.uint32(26).string(message.cmdline);
    }
    if (message.user !== "") {
      writer.uint32(34).string(message.user);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      RunningProcess_AttributesEntry.encode({ key: key as any, value }, writer.uint32(802).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunningProcess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunningProcess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pid = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cmdline = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          const entry100 = RunningProcess_AttributesEntry.decode(reader, reader.uint32());
          if (entry100.value !== undefined) {
            message.attributes[entry100.key] = entry100.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunningProcess {
    return {
      pid: isSet(object.pid) ? Long.fromValue(object.pid) : Long.ZERO,
      exePath: isSet(object.exePath) ? globalThis.String(object.exePath) : "",
      cmdline: isSet(object.cmdline) ? globalThis.String(object.cmdline) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RunningProcess): unknown {
    const obj: any = {};
    if (!message.pid.equals(Long.ZERO)) {
      obj.pid = (message.pid || Long.ZERO).toString();
    }
    if (message.exePath !== "") {
      obj.exePath = message.exePath;
    }
    if (message.cmdline !== "") {
      obj.cmdline = message.cmdline;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RunningProcess>): RunningProcess {
    return RunningProcess.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunningProcess>): RunningProcess {
    const message = createBaseRunningProcess();
    message.pid = (object.pid !== undefined && object.pid !== null) ? Long.fromValue(object.pid) : Long.ZERO;
    message.exePath = object.exePath ?? "";
    message.cmdline = object.cmdline ?? "";
    message.user = object.user ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRunningProcess_AttributesEntry(): RunningProcess_AttributesEntry {
  return { key: "", value: "" };
}

export const RunningProcess_AttributesEntry: MessageFns<RunningProcess_AttributesEntry> = {
  encode(message: RunningProcess_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunningProcess_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunningProcess_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunningProcess_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RunningProcess_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RunningProcess_AttributesEntry>): RunningProcess_AttributesEntry {
    return RunningProcess_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunningProcess_AttributesEntry>): RunningProcess_AttributesEntry {
    const message = createBaseRunningProcess_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRuntimeNetworkInfo(): RuntimeNetworkInfo {
  return { scanTime: undefined, connections: undefined };
}

export const RuntimeNetworkInfo: MessageFns<RuntimeNetworkInfo> = {
  encode(message: RuntimeNetworkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scanTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scanTime), writer.uint32(10).fork()).join();
    }
    if (message.connections !== undefined) {
      NetworkConnectionList.encode(message.connections, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeNetworkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeNetworkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scanTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connections = NetworkConnectionList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeNetworkInfo {
    return {
      scanTime: isSet(object.scanTime) ? fromJsonTimestamp(object.scanTime) : undefined,
      connections: isSet(object.connections) ? NetworkConnectionList.fromJSON(object.connections) : undefined,
    };
  },

  toJSON(message: RuntimeNetworkInfo): unknown {
    const obj: any = {};
    if (message.scanTime !== undefined) {
      obj.scanTime = message.scanTime.toISOString();
    }
    if (message.connections !== undefined) {
      obj.connections = NetworkConnectionList.toJSON(message.connections);
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeNetworkInfo>): RuntimeNetworkInfo {
    return RuntimeNetworkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeNetworkInfo>): RuntimeNetworkInfo {
    const message = createBaseRuntimeNetworkInfo();
    message.scanTime = object.scanTime ?? undefined;
    message.connections = (object.connections !== undefined && object.connections !== null)
      ? NetworkConnectionList.fromPartial(object.connections)
      : undefined;
    return message;
  },
};

function createBaseNetworkConnectionList(): NetworkConnectionList {
  return { entries: [] };
}

export const NetworkConnectionList: MessageFns<NetworkConnectionList> = {
  encode(message: NetworkConnectionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      NetworkConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConnectionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConnectionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(NetworkConnection.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConnectionList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => NetworkConnection.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NetworkConnectionList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => NetworkConnection.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConnectionList>): NetworkConnectionList {
    return NetworkConnectionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConnectionList>): NetworkConnectionList {
    const message = createBaseNetworkConnectionList();
    message.entries = object.entries?.map((e) => NetworkConnection.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkConnection(): NetworkConnection {
  return {
    protocol: "",
    localIpAddress: "",
    localPort: 0,
    remoteIpAddress: "",
    remotePort: 0,
    state: 0,
    pid: Long.ZERO,
    processName: "",
  };
}

export const NetworkConnection: MessageFns<NetworkConnection> = {
  encode(message: NetworkConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== "") {
      writer.uint32(10).string(message.protocol);
    }
    if (message.localIpAddress !== "") {
      writer.uint32(18).string(message.localIpAddress);
    }
    if (message.localPort !== 0) {
      writer.uint32(24).int32(message.localPort);
    }
    if (message.remoteIpAddress !== "") {
      writer.uint32(34).string(message.remoteIpAddress);
    }
    if (message.remotePort !== 0) {
      writer.uint32(40).int32(message.remotePort);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (!message.pid.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.pid.toString());
    }
    if (message.processName !== "") {
      writer.uint32(66).string(message.processName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localIpAddress = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.localPort = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.remoteIpAddress = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.remotePort = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pid = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.processName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConnection {
    return {
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      localIpAddress: isSet(object.localIpAddress) ? globalThis.String(object.localIpAddress) : "",
      localPort: isSet(object.localPort) ? globalThis.Number(object.localPort) : 0,
      remoteIpAddress: isSet(object.remoteIpAddress) ? globalThis.String(object.remoteIpAddress) : "",
      remotePort: isSet(object.remotePort) ? globalThis.Number(object.remotePort) : 0,
      state: isSet(object.state) ? networkConnection_StateFromJSON(object.state) : 0,
      pid: isSet(object.pid) ? Long.fromValue(object.pid) : Long.ZERO,
      processName: isSet(object.processName) ? globalThis.String(object.processName) : "",
    };
  },

  toJSON(message: NetworkConnection): unknown {
    const obj: any = {};
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.localIpAddress !== "") {
      obj.localIpAddress = message.localIpAddress;
    }
    if (message.localPort !== 0) {
      obj.localPort = Math.round(message.localPort);
    }
    if (message.remoteIpAddress !== "") {
      obj.remoteIpAddress = message.remoteIpAddress;
    }
    if (message.remotePort !== 0) {
      obj.remotePort = Math.round(message.remotePort);
    }
    if (message.state !== 0) {
      obj.state = networkConnection_StateToJSON(message.state);
    }
    if (!message.pid.equals(Long.ZERO)) {
      obj.pid = (message.pid || Long.ZERO).toString();
    }
    if (message.processName !== "") {
      obj.processName = message.processName;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConnection>): NetworkConnection {
    return NetworkConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConnection>): NetworkConnection {
    const message = createBaseNetworkConnection();
    message.protocol = object.protocol ?? "";
    message.localIpAddress = object.localIpAddress ?? "";
    message.localPort = object.localPort ?? 0;
    message.remoteIpAddress = object.remoteIpAddress ?? "";
    message.remotePort = object.remotePort ?? 0;
    message.state = object.state ?? 0;
    message.pid = (object.pid !== undefined && object.pid !== null) ? Long.fromValue(object.pid) : Long.ZERO;
    message.processName = object.processName ?? "";
    return message;
  },
};

function createBaseGuestInstalledApplicationList(): GuestInstalledApplicationList {
  return { entries: [] };
}

export const GuestInstalledApplicationList: MessageFns<GuestInstalledApplicationList> = {
  encode(message: GuestInstalledApplicationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      GuestInstalledApplication.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestInstalledApplicationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestInstalledApplicationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(GuestInstalledApplication.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestInstalledApplicationList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => GuestInstalledApplication.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GuestInstalledApplicationList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => GuestInstalledApplication.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GuestInstalledApplicationList>): GuestInstalledApplicationList {
    return GuestInstalledApplicationList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestInstalledApplicationList>): GuestInstalledApplicationList {
    const message = createBaseGuestInstalledApplicationList();
    message.entries = object.entries?.map((e) => GuestInstalledApplication.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGuestInstalledApplication(): GuestInstalledApplication {
  return { applicationName: "", vendor: "", installTime: undefined, path: "", version: "" };
}

export const GuestInstalledApplication: MessageFns<GuestInstalledApplication> = {
  encode(message: GuestInstalledApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationName !== "") {
      writer.uint32(10).string(message.applicationName);
    }
    if (message.vendor !== "") {
      writer.uint32(18).string(message.vendor);
    }
    if (message.installTime !== undefined) {
      Timestamp.encode(toTimestamp(message.installTime), writer.uint32(26).fork()).join();
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestInstalledApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestInstalledApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vendor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.installTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestInstalledApplication {
    return {
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : "",
      vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : "",
      installTime: isSet(object.installTime) ? fromJsonTimestamp(object.installTime) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: GuestInstalledApplication): unknown {
    const obj: any = {};
    if (message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.vendor !== "") {
      obj.vendor = message.vendor;
    }
    if (message.installTime !== undefined) {
      obj.installTime = message.installTime.toISOString();
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<GuestInstalledApplication>): GuestInstalledApplication {
    return GuestInstalledApplication.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestInstalledApplication>): GuestInstalledApplication {
    const message = createBaseGuestInstalledApplication();
    message.applicationName = object.applicationName ?? "";
    message.vendor = object.vendor ?? "";
    message.installTime = object.installTime ?? undefined;
    message.path = object.path ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseOpenFileList(): OpenFileList {
  return { entries: [] };
}

export const OpenFileList: MessageFns<OpenFileList> = {
  encode(message: OpenFileList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      OpenFileDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenFileList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenFileList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(OpenFileDetails.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenFileList {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => OpenFileDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OpenFileList): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => OpenFileDetails.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OpenFileList>): OpenFileList {
    return OpenFileList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenFileList>): OpenFileList {
    const message = createBaseOpenFileList();
    message.entries = object.entries?.map((e) => OpenFileDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOpenFileDetails(): OpenFileDetails {
  return { command: "", user: "", fileType: "", filePath: "" };
}

export const OpenFileDetails: MessageFns<OpenFileDetails> = {
  encode(message: OpenFileDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.user !== "") {
      writer.uint32(18).string(message.user);
    }
    if (message.fileType !== "") {
      writer.uint32(26).string(message.fileType);
    }
    if (message.filePath !== "") {
      writer.uint32(34).string(message.filePath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenFileDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenFileDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fileType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenFileDetails {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      fileType: isSet(object.fileType) ? globalThis.String(object.fileType) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
    };
  },

  toJSON(message: OpenFileDetails): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.fileType !== "") {
      obj.fileType = message.fileType;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create(base?: DeepPartial<OpenFileDetails>): OpenFileDetails {
    return OpenFileDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenFileDetails>): OpenFileDetails {
    const message = createBaseOpenFileDetails();
    message.command = object.command ?? "";
    message.user = object.user ?? "";
    message.fileType = object.fileType ?? "";
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBasePlatformDetails(): PlatformDetails {
  return {
    vmwareDetails: undefined,
    awsEc2Details: undefined,
    azureVmDetails: undefined,
    genericDetails: undefined,
    physicalDetails: undefined,
  };
}

export const PlatformDetails: MessageFns<PlatformDetails> = {
  encode(message: PlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmwareDetails !== undefined) {
      VmwarePlatformDetails.encode(message.vmwareDetails, writer.uint32(10).fork()).join();
    }
    if (message.awsEc2Details !== undefined) {
      AwsEc2PlatformDetails.encode(message.awsEc2Details, writer.uint32(18).fork()).join();
    }
    if (message.azureVmDetails !== undefined) {
      AzureVmPlatformDetails.encode(message.azureVmDetails, writer.uint32(26).fork()).join();
    }
    if (message.genericDetails !== undefined) {
      GenericPlatformDetails.encode(message.genericDetails, writer.uint32(34).fork()).join();
    }
    if (message.physicalDetails !== undefined) {
      PhysicalPlatformDetails.encode(message.physicalDetails, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareDetails = VmwarePlatformDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.awsEc2Details = AwsEc2PlatformDetails.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.azureVmDetails = AzureVmPlatformDetails.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.genericDetails = GenericPlatformDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.physicalDetails = PhysicalPlatformDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformDetails {
    return {
      vmwareDetails: isSet(object.vmwareDetails) ? VmwarePlatformDetails.fromJSON(object.vmwareDetails) : undefined,
      awsEc2Details: isSet(object.awsEc2Details) ? AwsEc2PlatformDetails.fromJSON(object.awsEc2Details) : undefined,
      azureVmDetails: isSet(object.azureVmDetails) ? AzureVmPlatformDetails.fromJSON(object.azureVmDetails) : undefined,
      genericDetails: isSet(object.genericDetails) ? GenericPlatformDetails.fromJSON(object.genericDetails) : undefined,
      physicalDetails: isSet(object.physicalDetails)
        ? PhysicalPlatformDetails.fromJSON(object.physicalDetails)
        : undefined,
    };
  },

  toJSON(message: PlatformDetails): unknown {
    const obj: any = {};
    if (message.vmwareDetails !== undefined) {
      obj.vmwareDetails = VmwarePlatformDetails.toJSON(message.vmwareDetails);
    }
    if (message.awsEc2Details !== undefined) {
      obj.awsEc2Details = AwsEc2PlatformDetails.toJSON(message.awsEc2Details);
    }
    if (message.azureVmDetails !== undefined) {
      obj.azureVmDetails = AzureVmPlatformDetails.toJSON(message.azureVmDetails);
    }
    if (message.genericDetails !== undefined) {
      obj.genericDetails = GenericPlatformDetails.toJSON(message.genericDetails);
    }
    if (message.physicalDetails !== undefined) {
      obj.physicalDetails = PhysicalPlatformDetails.toJSON(message.physicalDetails);
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformDetails>): PlatformDetails {
    return PlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformDetails>): PlatformDetails {
    const message = createBasePlatformDetails();
    message.vmwareDetails = (object.vmwareDetails !== undefined && object.vmwareDetails !== null)
      ? VmwarePlatformDetails.fromPartial(object.vmwareDetails)
      : undefined;
    message.awsEc2Details = (object.awsEc2Details !== undefined && object.awsEc2Details !== null)
      ? AwsEc2PlatformDetails.fromPartial(object.awsEc2Details)
      : undefined;
    message.azureVmDetails = (object.azureVmDetails !== undefined && object.azureVmDetails !== null)
      ? AzureVmPlatformDetails.fromPartial(object.azureVmDetails)
      : undefined;
    message.genericDetails = (object.genericDetails !== undefined && object.genericDetails !== null)
      ? GenericPlatformDetails.fromPartial(object.genericDetails)
      : undefined;
    message.physicalDetails = (object.physicalDetails !== undefined && object.physicalDetails !== null)
      ? PhysicalPlatformDetails.fromPartial(object.physicalDetails)
      : undefined;
    return message;
  },
};

function createBaseVmwarePlatformDetails(): VmwarePlatformDetails {
  return { vcenterVersion: "", esxVersion: "", osid: "", vcenterFolder: "", vcenterUri: "", vcenterVmId: "" };
}

export const VmwarePlatformDetails: MessageFns<VmwarePlatformDetails> = {
  encode(message: VmwarePlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vcenterVersion !== "") {
      writer.uint32(10).string(message.vcenterVersion);
    }
    if (message.esxVersion !== "") {
      writer.uint32(18).string(message.esxVersion);
    }
    if (message.osid !== "") {
      writer.uint32(26).string(message.osid);
    }
    if (message.vcenterFolder !== "") {
      writer.uint32(34).string(message.vcenterFolder);
    }
    if (message.vcenterUri !== "") {
      writer.uint32(42).string(message.vcenterUri);
    }
    if (message.vcenterVmId !== "") {
      writer.uint32(50).string(message.vcenterVmId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwarePlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwarePlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vcenterVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.esxVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vcenterFolder = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vcenterUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vcenterVmId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwarePlatformDetails {
    return {
      vcenterVersion: isSet(object.vcenterVersion) ? globalThis.String(object.vcenterVersion) : "",
      esxVersion: isSet(object.esxVersion) ? globalThis.String(object.esxVersion) : "",
      osid: isSet(object.osid) ? globalThis.String(object.osid) : "",
      vcenterFolder: isSet(object.vcenterFolder) ? globalThis.String(object.vcenterFolder) : "",
      vcenterUri: isSet(object.vcenterUri) ? globalThis.String(object.vcenterUri) : "",
      vcenterVmId: isSet(object.vcenterVmId) ? globalThis.String(object.vcenterVmId) : "",
    };
  },

  toJSON(message: VmwarePlatformDetails): unknown {
    const obj: any = {};
    if (message.vcenterVersion !== "") {
      obj.vcenterVersion = message.vcenterVersion;
    }
    if (message.esxVersion !== "") {
      obj.esxVersion = message.esxVersion;
    }
    if (message.osid !== "") {
      obj.osid = message.osid;
    }
    if (message.vcenterFolder !== "") {
      obj.vcenterFolder = message.vcenterFolder;
    }
    if (message.vcenterUri !== "") {
      obj.vcenterUri = message.vcenterUri;
    }
    if (message.vcenterVmId !== "") {
      obj.vcenterVmId = message.vcenterVmId;
    }
    return obj;
  },

  create(base?: DeepPartial<VmwarePlatformDetails>): VmwarePlatformDetails {
    return VmwarePlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwarePlatformDetails>): VmwarePlatformDetails {
    const message = createBaseVmwarePlatformDetails();
    message.vcenterVersion = object.vcenterVersion ?? "";
    message.esxVersion = object.esxVersion ?? "";
    message.osid = object.osid ?? "";
    message.vcenterFolder = object.vcenterFolder ?? "";
    message.vcenterUri = object.vcenterUri ?? "";
    message.vcenterVmId = object.vcenterVmId ?? "";
    return message;
  },
};

function createBaseAwsEc2PlatformDetails(): AwsEc2PlatformDetails {
  return { machineTypeLabel: "", location: "" };
}

export const AwsEc2PlatformDetails: MessageFns<AwsEc2PlatformDetails> = {
  encode(message: AwsEc2PlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineTypeLabel !== "") {
      writer.uint32(10).string(message.machineTypeLabel);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsEc2PlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsEc2PlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineTypeLabel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsEc2PlatformDetails {
    return {
      machineTypeLabel: isSet(object.machineTypeLabel) ? globalThis.String(object.machineTypeLabel) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: AwsEc2PlatformDetails): unknown {
    const obj: any = {};
    if (message.machineTypeLabel !== "") {
      obj.machineTypeLabel = message.machineTypeLabel;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<AwsEc2PlatformDetails>): AwsEc2PlatformDetails {
    return AwsEc2PlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AwsEc2PlatformDetails>): AwsEc2PlatformDetails {
    const message = createBaseAwsEc2PlatformDetails();
    message.machineTypeLabel = object.machineTypeLabel ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseAzureVmPlatformDetails(): AzureVmPlatformDetails {
  return { machineTypeLabel: "", location: "", provisioningState: "" };
}

export const AzureVmPlatformDetails: MessageFns<AzureVmPlatformDetails> = {
  encode(message: AzureVmPlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineTypeLabel !== "") {
      writer.uint32(10).string(message.machineTypeLabel);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.provisioningState !== "") {
      writer.uint32(26).string(message.provisioningState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AzureVmPlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAzureVmPlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineTypeLabel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provisioningState = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AzureVmPlatformDetails {
    return {
      machineTypeLabel: isSet(object.machineTypeLabel) ? globalThis.String(object.machineTypeLabel) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      provisioningState: isSet(object.provisioningState) ? globalThis.String(object.provisioningState) : "",
    };
  },

  toJSON(message: AzureVmPlatformDetails): unknown {
    const obj: any = {};
    if (message.machineTypeLabel !== "") {
      obj.machineTypeLabel = message.machineTypeLabel;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.provisioningState !== "") {
      obj.provisioningState = message.provisioningState;
    }
    return obj;
  },

  create(base?: DeepPartial<AzureVmPlatformDetails>): AzureVmPlatformDetails {
    return AzureVmPlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AzureVmPlatformDetails>): AzureVmPlatformDetails {
    const message = createBaseAzureVmPlatformDetails();
    message.machineTypeLabel = object.machineTypeLabel ?? "";
    message.location = object.location ?? "";
    message.provisioningState = object.provisioningState ?? "";
    return message;
  },
};

function createBaseGenericPlatformDetails(): GenericPlatformDetails {
  return { location: "" };
}

export const GenericPlatformDetails: MessageFns<GenericPlatformDetails> = {
  encode(message: GenericPlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericPlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericPlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericPlatformDetails {
    return { location: isSet(object.location) ? globalThis.String(object.location) : "" };
  },

  toJSON(message: GenericPlatformDetails): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<GenericPlatformDetails>): GenericPlatformDetails {
    return GenericPlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericPlatformDetails>): GenericPlatformDetails {
    const message = createBaseGenericPlatformDetails();
    message.location = object.location ?? "";
    return message;
  },
};

function createBasePhysicalPlatformDetails(): PhysicalPlatformDetails {
  return { location: "" };
}

export const PhysicalPlatformDetails: MessageFns<PhysicalPlatformDetails> = {
  encode(message: PhysicalPlatformDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhysicalPlatformDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhysicalPlatformDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhysicalPlatformDetails {
    return { location: isSet(object.location) ? globalThis.String(object.location) : "" };
  },

  toJSON(message: PhysicalPlatformDetails): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<PhysicalPlatformDetails>): PhysicalPlatformDetails {
    return PhysicalPlatformDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhysicalPlatformDetails>): PhysicalPlatformDetails {
    const message = createBasePhysicalPlatformDetails();
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseMemoryUsageSample(): MemoryUsageSample {
  return { utilizedPercentage: 0 };
}

export const MemoryUsageSample: MessageFns<MemoryUsageSample> = {
  encode(message: MemoryUsageSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilizedPercentage !== 0) {
      writer.uint32(13).float(message.utilizedPercentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryUsageSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryUsageSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.utilizedPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryUsageSample {
    return { utilizedPercentage: isSet(object.utilizedPercentage) ? globalThis.Number(object.utilizedPercentage) : 0 };
  },

  toJSON(message: MemoryUsageSample): unknown {
    const obj: any = {};
    if (message.utilizedPercentage !== 0) {
      obj.utilizedPercentage = message.utilizedPercentage;
    }
    return obj;
  },

  create(base?: DeepPartial<MemoryUsageSample>): MemoryUsageSample {
    return MemoryUsageSample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MemoryUsageSample>): MemoryUsageSample {
    const message = createBaseMemoryUsageSample();
    message.utilizedPercentage = object.utilizedPercentage ?? 0;
    return message;
  },
};

function createBaseCpuUsageSample(): CpuUsageSample {
  return { utilizedPercentage: 0 };
}

export const CpuUsageSample: MessageFns<CpuUsageSample> = {
  encode(message: CpuUsageSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilizedPercentage !== 0) {
      writer.uint32(13).float(message.utilizedPercentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CpuUsageSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCpuUsageSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.utilizedPercentage = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CpuUsageSample {
    return { utilizedPercentage: isSet(object.utilizedPercentage) ? globalThis.Number(object.utilizedPercentage) : 0 };
  },

  toJSON(message: CpuUsageSample): unknown {
    const obj: any = {};
    if (message.utilizedPercentage !== 0) {
      obj.utilizedPercentage = message.utilizedPercentage;
    }
    return obj;
  },

  create(base?: DeepPartial<CpuUsageSample>): CpuUsageSample {
    return CpuUsageSample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CpuUsageSample>): CpuUsageSample {
    const message = createBaseCpuUsageSample();
    message.utilizedPercentage = object.utilizedPercentage ?? 0;
    return message;
  },
};

function createBaseNetworkUsageSample(): NetworkUsageSample {
  return { averageIngressBps: 0, averageEgressBps: 0 };
}

export const NetworkUsageSample: MessageFns<NetworkUsageSample> = {
  encode(message: NetworkUsageSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.averageIngressBps !== 0) {
      writer.uint32(13).float(message.averageIngressBps);
    }
    if (message.averageEgressBps !== 0) {
      writer.uint32(21).float(message.averageEgressBps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkUsageSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkUsageSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.averageIngressBps = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.averageEgressBps = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkUsageSample {
    return {
      averageIngressBps: isSet(object.averageIngressBps) ? globalThis.Number(object.averageIngressBps) : 0,
      averageEgressBps: isSet(object.averageEgressBps) ? globalThis.Number(object.averageEgressBps) : 0,
    };
  },

  toJSON(message: NetworkUsageSample): unknown {
    const obj: any = {};
    if (message.averageIngressBps !== 0) {
      obj.averageIngressBps = message.averageIngressBps;
    }
    if (message.averageEgressBps !== 0) {
      obj.averageEgressBps = message.averageEgressBps;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkUsageSample>): NetworkUsageSample {
    return NetworkUsageSample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkUsageSample>): NetworkUsageSample {
    const message = createBaseNetworkUsageSample();
    message.averageIngressBps = object.averageIngressBps ?? 0;
    message.averageEgressBps = object.averageEgressBps ?? 0;
    return message;
  },
};

function createBaseDiskUsageSample(): DiskUsageSample {
  return { averageIops: 0 };
}

export const DiskUsageSample: MessageFns<DiskUsageSample> = {
  encode(message: DiskUsageSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.averageIops !== 0) {
      writer.uint32(13).float(message.averageIops);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskUsageSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskUsageSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.averageIops = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskUsageSample {
    return { averageIops: isSet(object.averageIops) ? globalThis.Number(object.averageIops) : 0 };
  },

  toJSON(message: DiskUsageSample): unknown {
    const obj: any = {};
    if (message.averageIops !== 0) {
      obj.averageIops = message.averageIops;
    }
    return obj;
  },

  create(base?: DeepPartial<DiskUsageSample>): DiskUsageSample {
    return DiskUsageSample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskUsageSample>): DiskUsageSample {
    const message = createBaseDiskUsageSample();
    message.averageIops = object.averageIops ?? 0;
    return message;
  },
};

function createBasePerformanceSample(): PerformanceSample {
  return { sampleTime: undefined, memory: undefined, cpu: undefined, network: undefined, disk: undefined };
}

export const PerformanceSample: MessageFns<PerformanceSample> = {
  encode(message: PerformanceSample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sampleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.sampleTime), writer.uint32(10).fork()).join();
    }
    if (message.memory !== undefined) {
      MemoryUsageSample.encode(message.memory, writer.uint32(18).fork()).join();
    }
    if (message.cpu !== undefined) {
      CpuUsageSample.encode(message.cpu, writer.uint32(26).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkUsageSample.encode(message.network, writer.uint32(34).fork()).join();
    }
    if (message.disk !== undefined) {
      DiskUsageSample.encode(message.disk, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PerformanceSample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePerformanceSample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sampleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memory = MemoryUsageSample.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cpu = CpuUsageSample.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = NetworkUsageSample.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.disk = DiskUsageSample.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PerformanceSample {
    return {
      sampleTime: isSet(object.sampleTime) ? fromJsonTimestamp(object.sampleTime) : undefined,
      memory: isSet(object.memory) ? MemoryUsageSample.fromJSON(object.memory) : undefined,
      cpu: isSet(object.cpu) ? CpuUsageSample.fromJSON(object.cpu) : undefined,
      network: isSet(object.network) ? NetworkUsageSample.fromJSON(object.network) : undefined,
      disk: isSet(object.disk) ? DiskUsageSample.fromJSON(object.disk) : undefined,
    };
  },

  toJSON(message: PerformanceSample): unknown {
    const obj: any = {};
    if (message.sampleTime !== undefined) {
      obj.sampleTime = message.sampleTime.toISOString();
    }
    if (message.memory !== undefined) {
      obj.memory = MemoryUsageSample.toJSON(message.memory);
    }
    if (message.cpu !== undefined) {
      obj.cpu = CpuUsageSample.toJSON(message.cpu);
    }
    if (message.network !== undefined) {
      obj.network = NetworkUsageSample.toJSON(message.network);
    }
    if (message.disk !== undefined) {
      obj.disk = DiskUsageSample.toJSON(message.disk);
    }
    return obj;
  },

  create(base?: DeepPartial<PerformanceSample>): PerformanceSample {
    return PerformanceSample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PerformanceSample>): PerformanceSample {
    const message = createBasePerformanceSample();
    message.sampleTime = object.sampleTime ?? undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? MemoryUsageSample.fromPartial(object.memory)
      : undefined;
    message.cpu = (object.cpu !== undefined && object.cpu !== null)
      ? CpuUsageSample.fromPartial(object.cpu)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkUsageSample.fromPartial(object.network)
      : undefined;
    message.disk = (object.disk !== undefined && object.disk !== null)
      ? DiskUsageSample.fromPartial(object.disk)
      : undefined;
    return message;
  },
};

function createBaseAssetPerformanceData(): AssetPerformanceData {
  return { dailyResourceUsageAggregations: [] };
}

export const AssetPerformanceData: MessageFns<AssetPerformanceData> = {
  encode(message: AssetPerformanceData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dailyResourceUsageAggregations) {
      DailyResourceUsageAggregation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetPerformanceData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetPerformanceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dailyResourceUsageAggregations.push(DailyResourceUsageAggregation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetPerformanceData {
    return {
      dailyResourceUsageAggregations: globalThis.Array.isArray(object?.dailyResourceUsageAggregations)
        ? object.dailyResourceUsageAggregations.map((e: any) => DailyResourceUsageAggregation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AssetPerformanceData): unknown {
    const obj: any = {};
    if (message.dailyResourceUsageAggregations?.length) {
      obj.dailyResourceUsageAggregations = message.dailyResourceUsageAggregations.map((e) =>
        DailyResourceUsageAggregation.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AssetPerformanceData>): AssetPerformanceData {
    return AssetPerformanceData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetPerformanceData>): AssetPerformanceData {
    const message = createBaseAssetPerformanceData();
    message.dailyResourceUsageAggregations =
      object.dailyResourceUsageAggregations?.map((e) => DailyResourceUsageAggregation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDailyResourceUsageAggregation(): DailyResourceUsageAggregation {
  return { date: undefined, cpu: undefined, memory: undefined, network: undefined, disk: undefined };
}

export const DailyResourceUsageAggregation: MessageFns<DailyResourceUsageAggregation> = {
  encode(message: DailyResourceUsageAggregation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== undefined) {
      DateMessage.encode(message.date, writer.uint32(10).fork()).join();
    }
    if (message.cpu !== undefined) {
      DailyResourceUsageAggregation_CPU.encode(message.cpu, writer.uint32(18).fork()).join();
    }
    if (message.memory !== undefined) {
      DailyResourceUsageAggregation_Memory.encode(message.memory, writer.uint32(26).fork()).join();
    }
    if (message.network !== undefined) {
      DailyResourceUsageAggregation_Network.encode(message.network, writer.uint32(34).fork()).join();
    }
    if (message.disk !== undefined) {
      DailyResourceUsageAggregation_Disk.encode(message.disk, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.date = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpu = DailyResourceUsageAggregation_CPU.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.memory = DailyResourceUsageAggregation_Memory.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = DailyResourceUsageAggregation_Network.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.disk = DailyResourceUsageAggregation_Disk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation {
    return {
      date: isSet(object.date) ? DateMessage.fromJSON(object.date) : undefined,
      cpu: isSet(object.cpu) ? DailyResourceUsageAggregation_CPU.fromJSON(object.cpu) : undefined,
      memory: isSet(object.memory) ? DailyResourceUsageAggregation_Memory.fromJSON(object.memory) : undefined,
      network: isSet(object.network) ? DailyResourceUsageAggregation_Network.fromJSON(object.network) : undefined,
      disk: isSet(object.disk) ? DailyResourceUsageAggregation_Disk.fromJSON(object.disk) : undefined,
    };
  },

  toJSON(message: DailyResourceUsageAggregation): unknown {
    const obj: any = {};
    if (message.date !== undefined) {
      obj.date = DateMessage.toJSON(message.date);
    }
    if (message.cpu !== undefined) {
      obj.cpu = DailyResourceUsageAggregation_CPU.toJSON(message.cpu);
    }
    if (message.memory !== undefined) {
      obj.memory = DailyResourceUsageAggregation_Memory.toJSON(message.memory);
    }
    if (message.network !== undefined) {
      obj.network = DailyResourceUsageAggregation_Network.toJSON(message.network);
    }
    if (message.disk !== undefined) {
      obj.disk = DailyResourceUsageAggregation_Disk.toJSON(message.disk);
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation>): DailyResourceUsageAggregation {
    return DailyResourceUsageAggregation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation>): DailyResourceUsageAggregation {
    const message = createBaseDailyResourceUsageAggregation();
    message.date = (object.date !== undefined && object.date !== null)
      ? DateMessage.fromPartial(object.date)
      : undefined;
    message.cpu = (object.cpu !== undefined && object.cpu !== null)
      ? DailyResourceUsageAggregation_CPU.fromPartial(object.cpu)
      : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? DailyResourceUsageAggregation_Memory.fromPartial(object.memory)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? DailyResourceUsageAggregation_Network.fromPartial(object.network)
      : undefined;
    message.disk = (object.disk !== undefined && object.disk !== null)
      ? DailyResourceUsageAggregation_Disk.fromPartial(object.disk)
      : undefined;
    return message;
  },
};

function createBaseDailyResourceUsageAggregation_Stats(): DailyResourceUsageAggregation_Stats {
  return { average: 0, median: 0, ninteyFifthPercentile: 0, peak: 0 };
}

export const DailyResourceUsageAggregation_Stats: MessageFns<DailyResourceUsageAggregation_Stats> = {
  encode(message: DailyResourceUsageAggregation_Stats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.average !== 0) {
      writer.uint32(13).float(message.average);
    }
    if (message.median !== 0) {
      writer.uint32(21).float(message.median);
    }
    if (message.ninteyFifthPercentile !== 0) {
      writer.uint32(29).float(message.ninteyFifthPercentile);
    }
    if (message.peak !== 0) {
      writer.uint32(37).float(message.peak);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation_Stats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation_Stats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.average = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.median = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.ninteyFifthPercentile = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.peak = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation_Stats {
    return {
      average: isSet(object.average) ? globalThis.Number(object.average) : 0,
      median: isSet(object.median) ? globalThis.Number(object.median) : 0,
      ninteyFifthPercentile: isSet(object.ninteyFifthPercentile) ? globalThis.Number(object.ninteyFifthPercentile) : 0,
      peak: isSet(object.peak) ? globalThis.Number(object.peak) : 0,
    };
  },

  toJSON(message: DailyResourceUsageAggregation_Stats): unknown {
    const obj: any = {};
    if (message.average !== 0) {
      obj.average = message.average;
    }
    if (message.median !== 0) {
      obj.median = message.median;
    }
    if (message.ninteyFifthPercentile !== 0) {
      obj.ninteyFifthPercentile = message.ninteyFifthPercentile;
    }
    if (message.peak !== 0) {
      obj.peak = message.peak;
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation_Stats>): DailyResourceUsageAggregation_Stats {
    return DailyResourceUsageAggregation_Stats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation_Stats>): DailyResourceUsageAggregation_Stats {
    const message = createBaseDailyResourceUsageAggregation_Stats();
    message.average = object.average ?? 0;
    message.median = object.median ?? 0;
    message.ninteyFifthPercentile = object.ninteyFifthPercentile ?? 0;
    message.peak = object.peak ?? 0;
    return message;
  },
};

function createBaseDailyResourceUsageAggregation_CPU(): DailyResourceUsageAggregation_CPU {
  return { utilizationPercentage: undefined };
}

export const DailyResourceUsageAggregation_CPU: MessageFns<DailyResourceUsageAggregation_CPU> = {
  encode(message: DailyResourceUsageAggregation_CPU, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilizationPercentage !== undefined) {
      DailyResourceUsageAggregation_Stats.encode(message.utilizationPercentage, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation_CPU {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation_CPU();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.utilizationPercentage = DailyResourceUsageAggregation_Stats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation_CPU {
    return {
      utilizationPercentage: isSet(object.utilizationPercentage)
        ? DailyResourceUsageAggregation_Stats.fromJSON(object.utilizationPercentage)
        : undefined,
    };
  },

  toJSON(message: DailyResourceUsageAggregation_CPU): unknown {
    const obj: any = {};
    if (message.utilizationPercentage !== undefined) {
      obj.utilizationPercentage = DailyResourceUsageAggregation_Stats.toJSON(message.utilizationPercentage);
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation_CPU>): DailyResourceUsageAggregation_CPU {
    return DailyResourceUsageAggregation_CPU.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation_CPU>): DailyResourceUsageAggregation_CPU {
    const message = createBaseDailyResourceUsageAggregation_CPU();
    message.utilizationPercentage =
      (object.utilizationPercentage !== undefined && object.utilizationPercentage !== null)
        ? DailyResourceUsageAggregation_Stats.fromPartial(object.utilizationPercentage)
        : undefined;
    return message;
  },
};

function createBaseDailyResourceUsageAggregation_Memory(): DailyResourceUsageAggregation_Memory {
  return { utilizationPercentage: undefined };
}

export const DailyResourceUsageAggregation_Memory: MessageFns<DailyResourceUsageAggregation_Memory> = {
  encode(message: DailyResourceUsageAggregation_Memory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.utilizationPercentage !== undefined) {
      DailyResourceUsageAggregation_Stats.encode(message.utilizationPercentage, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation_Memory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation_Memory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.utilizationPercentage = DailyResourceUsageAggregation_Stats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation_Memory {
    return {
      utilizationPercentage: isSet(object.utilizationPercentage)
        ? DailyResourceUsageAggregation_Stats.fromJSON(object.utilizationPercentage)
        : undefined,
    };
  },

  toJSON(message: DailyResourceUsageAggregation_Memory): unknown {
    const obj: any = {};
    if (message.utilizationPercentage !== undefined) {
      obj.utilizationPercentage = DailyResourceUsageAggregation_Stats.toJSON(message.utilizationPercentage);
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation_Memory>): DailyResourceUsageAggregation_Memory {
    return DailyResourceUsageAggregation_Memory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation_Memory>): DailyResourceUsageAggregation_Memory {
    const message = createBaseDailyResourceUsageAggregation_Memory();
    message.utilizationPercentage =
      (object.utilizationPercentage !== undefined && object.utilizationPercentage !== null)
        ? DailyResourceUsageAggregation_Stats.fromPartial(object.utilizationPercentage)
        : undefined;
    return message;
  },
};

function createBaseDailyResourceUsageAggregation_Network(): DailyResourceUsageAggregation_Network {
  return { ingressBps: undefined, egressBps: undefined };
}

export const DailyResourceUsageAggregation_Network: MessageFns<DailyResourceUsageAggregation_Network> = {
  encode(message: DailyResourceUsageAggregation_Network, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ingressBps !== undefined) {
      DailyResourceUsageAggregation_Stats.encode(message.ingressBps, writer.uint32(10).fork()).join();
    }
    if (message.egressBps !== undefined) {
      DailyResourceUsageAggregation_Stats.encode(message.egressBps, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation_Network {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation_Network();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingressBps = DailyResourceUsageAggregation_Stats.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.egressBps = DailyResourceUsageAggregation_Stats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation_Network {
    return {
      ingressBps: isSet(object.ingressBps)
        ? DailyResourceUsageAggregation_Stats.fromJSON(object.ingressBps)
        : undefined,
      egressBps: isSet(object.egressBps) ? DailyResourceUsageAggregation_Stats.fromJSON(object.egressBps) : undefined,
    };
  },

  toJSON(message: DailyResourceUsageAggregation_Network): unknown {
    const obj: any = {};
    if (message.ingressBps !== undefined) {
      obj.ingressBps = DailyResourceUsageAggregation_Stats.toJSON(message.ingressBps);
    }
    if (message.egressBps !== undefined) {
      obj.egressBps = DailyResourceUsageAggregation_Stats.toJSON(message.egressBps);
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation_Network>): DailyResourceUsageAggregation_Network {
    return DailyResourceUsageAggregation_Network.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation_Network>): DailyResourceUsageAggregation_Network {
    const message = createBaseDailyResourceUsageAggregation_Network();
    message.ingressBps = (object.ingressBps !== undefined && object.ingressBps !== null)
      ? DailyResourceUsageAggregation_Stats.fromPartial(object.ingressBps)
      : undefined;
    message.egressBps = (object.egressBps !== undefined && object.egressBps !== null)
      ? DailyResourceUsageAggregation_Stats.fromPartial(object.egressBps)
      : undefined;
    return message;
  },
};

function createBaseDailyResourceUsageAggregation_Disk(): DailyResourceUsageAggregation_Disk {
  return { iops: undefined };
}

export const DailyResourceUsageAggregation_Disk: MessageFns<DailyResourceUsageAggregation_Disk> = {
  encode(message: DailyResourceUsageAggregation_Disk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iops !== undefined) {
      DailyResourceUsageAggregation_Stats.encode(message.iops, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyResourceUsageAggregation_Disk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyResourceUsageAggregation_Disk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iops = DailyResourceUsageAggregation_Stats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyResourceUsageAggregation_Disk {
    return { iops: isSet(object.iops) ? DailyResourceUsageAggregation_Stats.fromJSON(object.iops) : undefined };
  },

  toJSON(message: DailyResourceUsageAggregation_Disk): unknown {
    const obj: any = {};
    if (message.iops !== undefined) {
      obj.iops = DailyResourceUsageAggregation_Stats.toJSON(message.iops);
    }
    return obj;
  },

  create(base?: DeepPartial<DailyResourceUsageAggregation_Disk>): DailyResourceUsageAggregation_Disk {
    return DailyResourceUsageAggregation_Disk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyResourceUsageAggregation_Disk>): DailyResourceUsageAggregation_Disk {
    const message = createBaseDailyResourceUsageAggregation_Disk();
    message.iops = (object.iops !== undefined && object.iops !== null)
      ? DailyResourceUsageAggregation_Stats.fromPartial(object.iops)
      : undefined;
    return message;
  },
};

function createBaseInsightList(): InsightList {
  return { insights: [], updateTime: undefined };
}

export const InsightList: MessageFns<InsightList> = {
  encode(message: InsightList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.insights) {
      Insight.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsightList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsightList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.insights.push(Insight.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsightList {
    return {
      insights: globalThis.Array.isArray(object?.insights) ? object.insights.map((e: any) => Insight.fromJSON(e)) : [],
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: InsightList): unknown {
    const obj: any = {};
    if (message.insights?.length) {
      obj.insights = message.insights.map((e) => Insight.toJSON(e));
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<InsightList>): InsightList {
    return InsightList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsightList>): InsightList {
    const message = createBaseInsightList();
    message.insights = object.insights?.map((e) => Insight.fromPartial(e)) || [];
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseInsight(): Insight {
  return { migrationInsight: undefined, genericInsight: undefined };
}

export const Insight: MessageFns<Insight> = {
  encode(message: Insight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.migrationInsight !== undefined) {
      MigrationInsight.encode(message.migrationInsight, writer.uint32(10).fork()).join();
    }
    if (message.genericInsight !== undefined) {
      GenericInsight.encode(message.genericInsight, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Insight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.migrationInsight = MigrationInsight.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.genericInsight = GenericInsight.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Insight {
    return {
      migrationInsight: isSet(object.migrationInsight) ? MigrationInsight.fromJSON(object.migrationInsight) : undefined,
      genericInsight: isSet(object.genericInsight) ? GenericInsight.fromJSON(object.genericInsight) : undefined,
    };
  },

  toJSON(message: Insight): unknown {
    const obj: any = {};
    if (message.migrationInsight !== undefined) {
      obj.migrationInsight = MigrationInsight.toJSON(message.migrationInsight);
    }
    if (message.genericInsight !== undefined) {
      obj.genericInsight = GenericInsight.toJSON(message.genericInsight);
    }
    return obj;
  },

  create(base?: DeepPartial<Insight>): Insight {
    return Insight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Insight>): Insight {
    const message = createBaseInsight();
    message.migrationInsight = (object.migrationInsight !== undefined && object.migrationInsight !== null)
      ? MigrationInsight.fromPartial(object.migrationInsight)
      : undefined;
    message.genericInsight = (object.genericInsight !== undefined && object.genericInsight !== null)
      ? GenericInsight.fromPartial(object.genericInsight)
      : undefined;
    return message;
  },
};

function createBaseGenericInsight(): GenericInsight {
  return { messageId: Long.ZERO, defaultMessage: "", additionalInformation: [] };
}

export const GenericInsight: MessageFns<GenericInsight> = {
  encode(message: GenericInsight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.messageId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.messageId.toString());
    }
    if (message.defaultMessage !== "") {
      writer.uint32(18).string(message.defaultMessage);
    }
    for (const v of message.additionalInformation) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericInsight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericInsight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalInformation.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericInsight {
    return {
      messageId: isSet(object.messageId) ? Long.fromValue(object.messageId) : Long.ZERO,
      defaultMessage: isSet(object.defaultMessage) ? globalThis.String(object.defaultMessage) : "",
      additionalInformation: globalThis.Array.isArray(object?.additionalInformation)
        ? object.additionalInformation.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GenericInsight): unknown {
    const obj: any = {};
    if (!message.messageId.equals(Long.ZERO)) {
      obj.messageId = (message.messageId || Long.ZERO).toString();
    }
    if (message.defaultMessage !== "") {
      obj.defaultMessage = message.defaultMessage;
    }
    if (message.additionalInformation?.length) {
      obj.additionalInformation = message.additionalInformation;
    }
    return obj;
  },

  create(base?: DeepPartial<GenericInsight>): GenericInsight {
    return GenericInsight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericInsight>): GenericInsight {
    const message = createBaseGenericInsight();
    message.messageId = (object.messageId !== undefined && object.messageId !== null)
      ? Long.fromValue(object.messageId)
      : Long.ZERO;
    message.defaultMessage = object.defaultMessage ?? "";
    message.additionalInformation = object.additionalInformation?.map((e) => e) || [];
    return message;
  },
};

function createBaseMigrationInsight(): MigrationInsight {
  return { fit: undefined, computeEngineTarget: undefined };
}

export const MigrationInsight: MessageFns<MigrationInsight> = {
  encode(message: MigrationInsight, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fit !== undefined) {
      FitDescriptor.encode(message.fit, writer.uint32(10).fork()).join();
    }
    if (message.computeEngineTarget !== undefined) {
      ComputeEngineMigrationTarget.encode(message.computeEngineTarget, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MigrationInsight {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMigrationInsight();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fit = FitDescriptor.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.computeEngineTarget = ComputeEngineMigrationTarget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MigrationInsight {
    return {
      fit: isSet(object.fit) ? FitDescriptor.fromJSON(object.fit) : undefined,
      computeEngineTarget: isSet(object.computeEngineTarget)
        ? ComputeEngineMigrationTarget.fromJSON(object.computeEngineTarget)
        : undefined,
    };
  },

  toJSON(message: MigrationInsight): unknown {
    const obj: any = {};
    if (message.fit !== undefined) {
      obj.fit = FitDescriptor.toJSON(message.fit);
    }
    if (message.computeEngineTarget !== undefined) {
      obj.computeEngineTarget = ComputeEngineMigrationTarget.toJSON(message.computeEngineTarget);
    }
    return obj;
  },

  create(base?: DeepPartial<MigrationInsight>): MigrationInsight {
    return MigrationInsight.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MigrationInsight>): MigrationInsight {
    const message = createBaseMigrationInsight();
    message.fit = (object.fit !== undefined && object.fit !== null) ? FitDescriptor.fromPartial(object.fit) : undefined;
    message.computeEngineTarget = (object.computeEngineTarget !== undefined && object.computeEngineTarget !== null)
      ? ComputeEngineMigrationTarget.fromPartial(object.computeEngineTarget)
      : undefined;
    return message;
  },
};

function createBaseComputeEngineMigrationTarget(): ComputeEngineMigrationTarget {
  return { shape: undefined };
}

export const ComputeEngineMigrationTarget: MessageFns<ComputeEngineMigrationTarget> = {
  encode(message: ComputeEngineMigrationTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shape !== undefined) {
      ComputeEngineShapeDescriptor.encode(message.shape, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineMigrationTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineMigrationTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shape = ComputeEngineShapeDescriptor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineMigrationTarget {
    return { shape: isSet(object.shape) ? ComputeEngineShapeDescriptor.fromJSON(object.shape) : undefined };
  },

  toJSON(message: ComputeEngineMigrationTarget): unknown {
    const obj: any = {};
    if (message.shape !== undefined) {
      obj.shape = ComputeEngineShapeDescriptor.toJSON(message.shape);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineMigrationTarget>): ComputeEngineMigrationTarget {
    return ComputeEngineMigrationTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineMigrationTarget>): ComputeEngineMigrationTarget {
    const message = createBaseComputeEngineMigrationTarget();
    message.shape = (object.shape !== undefined && object.shape !== null)
      ? ComputeEngineShapeDescriptor.fromPartial(object.shape)
      : undefined;
    return message;
  },
};

function createBaseComputeEngineShapeDescriptor(): ComputeEngineShapeDescriptor {
  return { memoryMb: 0, physicalCoreCount: 0, logicalCoreCount: 0, series: "", machineType: "", storage: [] };
}

export const ComputeEngineShapeDescriptor: MessageFns<ComputeEngineShapeDescriptor> = {
  encode(message: ComputeEngineShapeDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memoryMb !== 0) {
      writer.uint32(8).int32(message.memoryMb);
    }
    if (message.physicalCoreCount !== 0) {
      writer.uint32(16).int32(message.physicalCoreCount);
    }
    if (message.logicalCoreCount !== 0) {
      writer.uint32(24).int32(message.logicalCoreCount);
    }
    if (message.series !== "") {
      writer.uint32(34).string(message.series);
    }
    if (message.machineType !== "") {
      writer.uint32(42).string(message.machineType);
    }
    for (const v of message.storage) {
      ComputeStorageDescriptor.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEngineShapeDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEngineShapeDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.physicalCoreCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.logicalCoreCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.series = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.storage.push(ComputeStorageDescriptor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEngineShapeDescriptor {
    return {
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      physicalCoreCount: isSet(object.physicalCoreCount) ? globalThis.Number(object.physicalCoreCount) : 0,
      logicalCoreCount: isSet(object.logicalCoreCount) ? globalThis.Number(object.logicalCoreCount) : 0,
      series: isSet(object.series) ? globalThis.String(object.series) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      storage: globalThis.Array.isArray(object?.storage)
        ? object.storage.map((e: any) => ComputeStorageDescriptor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComputeEngineShapeDescriptor): unknown {
    const obj: any = {};
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.physicalCoreCount !== 0) {
      obj.physicalCoreCount = Math.round(message.physicalCoreCount);
    }
    if (message.logicalCoreCount !== 0) {
      obj.logicalCoreCount = Math.round(message.logicalCoreCount);
    }
    if (message.series !== "") {
      obj.series = message.series;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.storage?.length) {
      obj.storage = message.storage.map((e) => ComputeStorageDescriptor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEngineShapeDescriptor>): ComputeEngineShapeDescriptor {
    return ComputeEngineShapeDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEngineShapeDescriptor>): ComputeEngineShapeDescriptor {
    const message = createBaseComputeEngineShapeDescriptor();
    message.memoryMb = object.memoryMb ?? 0;
    message.physicalCoreCount = object.physicalCoreCount ?? 0;
    message.logicalCoreCount = object.logicalCoreCount ?? 0;
    message.series = object.series ?? "";
    message.machineType = object.machineType ?? "";
    message.storage = object.storage?.map((e) => ComputeStorageDescriptor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComputeStorageDescriptor(): ComputeStorageDescriptor {
  return { type: 0, sizeGb: 0 };
}

export const ComputeStorageDescriptor: MessageFns<ComputeStorageDescriptor> = {
  encode(message: ComputeStorageDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.sizeGb !== 0) {
      writer.uint32(16).int32(message.sizeGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeStorageDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeStorageDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sizeGb = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeStorageDescriptor {
    return {
      type: isSet(object.type) ? persistentDiskTypeFromJSON(object.type) : 0,
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
    };
  },

  toJSON(message: ComputeStorageDescriptor): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = persistentDiskTypeToJSON(message.type);
    }
    if (message.sizeGb !== 0) {
      obj.sizeGb = Math.round(message.sizeGb);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeStorageDescriptor>): ComputeStorageDescriptor {
    return ComputeStorageDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeStorageDescriptor>): ComputeStorageDescriptor {
    const message = createBaseComputeStorageDescriptor();
    message.type = object.type ?? 0;
    message.sizeGb = object.sizeGb ?? 0;
    return message;
  },
};

function createBaseFitDescriptor(): FitDescriptor {
  return { fitLevel: 0 };
}

export const FitDescriptor: MessageFns<FitDescriptor> = {
  encode(message: FitDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fitLevel !== 0) {
      writer.uint32(8).int32(message.fitLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FitDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFitDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fitLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FitDescriptor {
    return { fitLevel: isSet(object.fitLevel) ? fitDescriptor_FitLevelFromJSON(object.fitLevel) : 0 };
  },

  toJSON(message: FitDescriptor): unknown {
    const obj: any = {};
    if (message.fitLevel !== 0) {
      obj.fitLevel = fitDescriptor_FitLevelToJSON(message.fitLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<FitDescriptor>): FitDescriptor {
    return FitDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FitDescriptor>): FitDescriptor {
    const message = createBaseFitDescriptor();
    message.fitLevel = object.fitLevel ?? 0;
    return message;
  },
};

function createBaseAggregation(): Aggregation {
  return { field: "", count: undefined, sum: undefined, histogram: undefined, frequency: undefined };
}

export const Aggregation: MessageFns<Aggregation> = {
  encode(message: Aggregation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.count !== undefined) {
      Aggregation_Count.encode(message.count, writer.uint32(18).fork()).join();
    }
    if (message.sum !== undefined) {
      Aggregation_Sum.encode(message.sum, writer.uint32(26).fork()).join();
    }
    if (message.histogram !== undefined) {
      Aggregation_Histogram.encode(message.histogram, writer.uint32(34).fork()).join();
    }
    if (message.frequency !== undefined) {
      Aggregation_Frequency.encode(message.frequency, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aggregation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.count = Aggregation_Count.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sum = Aggregation_Sum.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.histogram = Aggregation_Histogram.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.frequency = Aggregation_Frequency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Aggregation {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      count: isSet(object.count) ? Aggregation_Count.fromJSON(object.count) : undefined,
      sum: isSet(object.sum) ? Aggregation_Sum.fromJSON(object.sum) : undefined,
      histogram: isSet(object.histogram) ? Aggregation_Histogram.fromJSON(object.histogram) : undefined,
      frequency: isSet(object.frequency) ? Aggregation_Frequency.fromJSON(object.frequency) : undefined,
    };
  },

  toJSON(message: Aggregation): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.count !== undefined) {
      obj.count = Aggregation_Count.toJSON(message.count);
    }
    if (message.sum !== undefined) {
      obj.sum = Aggregation_Sum.toJSON(message.sum);
    }
    if (message.histogram !== undefined) {
      obj.histogram = Aggregation_Histogram.toJSON(message.histogram);
    }
    if (message.frequency !== undefined) {
      obj.frequency = Aggregation_Frequency.toJSON(message.frequency);
    }
    return obj;
  },

  create(base?: DeepPartial<Aggregation>): Aggregation {
    return Aggregation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Aggregation>): Aggregation {
    const message = createBaseAggregation();
    message.field = object.field ?? "";
    message.count = (object.count !== undefined && object.count !== null)
      ? Aggregation_Count.fromPartial(object.count)
      : undefined;
    message.sum = (object.sum !== undefined && object.sum !== null)
      ? Aggregation_Sum.fromPartial(object.sum)
      : undefined;
    message.histogram = (object.histogram !== undefined && object.histogram !== null)
      ? Aggregation_Histogram.fromPartial(object.histogram)
      : undefined;
    message.frequency = (object.frequency !== undefined && object.frequency !== null)
      ? Aggregation_Frequency.fromPartial(object.frequency)
      : undefined;
    return message;
  },
};

function createBaseAggregation_Count(): Aggregation_Count {
  return {};
}

export const Aggregation_Count: MessageFns<Aggregation_Count> = {
  encode(_: Aggregation_Count, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aggregation_Count {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregation_Count();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Aggregation_Count {
    return {};
  },

  toJSON(_: Aggregation_Count): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Aggregation_Count>): Aggregation_Count {
    return Aggregation_Count.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Aggregation_Count>): Aggregation_Count {
    const message = createBaseAggregation_Count();
    return message;
  },
};

function createBaseAggregation_Sum(): Aggregation_Sum {
  return {};
}

export const Aggregation_Sum: MessageFns<Aggregation_Sum> = {
  encode(_: Aggregation_Sum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aggregation_Sum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregation_Sum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Aggregation_Sum {
    return {};
  },

  toJSON(_: Aggregation_Sum): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Aggregation_Sum>): Aggregation_Sum {
    return Aggregation_Sum.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Aggregation_Sum>): Aggregation_Sum {
    const message = createBaseAggregation_Sum();
    return message;
  },
};

function createBaseAggregation_Histogram(): Aggregation_Histogram {
  return { lowerBounds: [] };
}

export const Aggregation_Histogram: MessageFns<Aggregation_Histogram> = {
  encode(message: Aggregation_Histogram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.lowerBounds) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aggregation_Histogram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregation_Histogram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.lowerBounds.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lowerBounds.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Aggregation_Histogram {
    return {
      lowerBounds: globalThis.Array.isArray(object?.lowerBounds)
        ? object.lowerBounds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Aggregation_Histogram): unknown {
    const obj: any = {};
    if (message.lowerBounds?.length) {
      obj.lowerBounds = message.lowerBounds;
    }
    return obj;
  },

  create(base?: DeepPartial<Aggregation_Histogram>): Aggregation_Histogram {
    return Aggregation_Histogram.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Aggregation_Histogram>): Aggregation_Histogram {
    const message = createBaseAggregation_Histogram();
    message.lowerBounds = object.lowerBounds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAggregation_Frequency(): Aggregation_Frequency {
  return {};
}

export const Aggregation_Frequency: MessageFns<Aggregation_Frequency> = {
  encode(_: Aggregation_Frequency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aggregation_Frequency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregation_Frequency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Aggregation_Frequency {
    return {};
  },

  toJSON(_: Aggregation_Frequency): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Aggregation_Frequency>): Aggregation_Frequency {
    return Aggregation_Frequency.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Aggregation_Frequency>): Aggregation_Frequency {
    const message = createBaseAggregation_Frequency();
    return message;
  },
};

function createBaseAggregationResult(): AggregationResult {
  return { field: "", count: undefined, sum: undefined, histogram: undefined, frequency: undefined };
}

export const AggregationResult: MessageFns<AggregationResult> = {
  encode(message: AggregationResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.count !== undefined) {
      AggregationResult_Count.encode(message.count, writer.uint32(18).fork()).join();
    }
    if (message.sum !== undefined) {
      AggregationResult_Sum.encode(message.sum, writer.uint32(26).fork()).join();
    }
    if (message.histogram !== undefined) {
      AggregationResult_Histogram.encode(message.histogram, writer.uint32(34).fork()).join();
    }
    if (message.frequency !== undefined) {
      AggregationResult_Frequency.encode(message.frequency, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.count = AggregationResult_Count.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sum = AggregationResult_Sum.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.histogram = AggregationResult_Histogram.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.frequency = AggregationResult_Frequency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      count: isSet(object.count) ? AggregationResult_Count.fromJSON(object.count) : undefined,
      sum: isSet(object.sum) ? AggregationResult_Sum.fromJSON(object.sum) : undefined,
      histogram: isSet(object.histogram) ? AggregationResult_Histogram.fromJSON(object.histogram) : undefined,
      frequency: isSet(object.frequency) ? AggregationResult_Frequency.fromJSON(object.frequency) : undefined,
    };
  },

  toJSON(message: AggregationResult): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.count !== undefined) {
      obj.count = AggregationResult_Count.toJSON(message.count);
    }
    if (message.sum !== undefined) {
      obj.sum = AggregationResult_Sum.toJSON(message.sum);
    }
    if (message.histogram !== undefined) {
      obj.histogram = AggregationResult_Histogram.toJSON(message.histogram);
    }
    if (message.frequency !== undefined) {
      obj.frequency = AggregationResult_Frequency.toJSON(message.frequency);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult>): AggregationResult {
    return AggregationResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult>): AggregationResult {
    const message = createBaseAggregationResult();
    message.field = object.field ?? "";
    message.count = (object.count !== undefined && object.count !== null)
      ? AggregationResult_Count.fromPartial(object.count)
      : undefined;
    message.sum = (object.sum !== undefined && object.sum !== null)
      ? AggregationResult_Sum.fromPartial(object.sum)
      : undefined;
    message.histogram = (object.histogram !== undefined && object.histogram !== null)
      ? AggregationResult_Histogram.fromPartial(object.histogram)
      : undefined;
    message.frequency = (object.frequency !== undefined && object.frequency !== null)
      ? AggregationResult_Frequency.fromPartial(object.frequency)
      : undefined;
    return message;
  },
};

function createBaseAggregationResult_Count(): AggregationResult_Count {
  return { value: Long.ZERO };
}

export const AggregationResult_Count: MessageFns<AggregationResult_Count> = {
  encode(message: AggregationResult_Count, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Count {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Count();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Count {
    return { value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO };
  },

  toJSON(message: AggregationResult_Count): unknown {
    const obj: any = {};
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Count>): AggregationResult_Count {
    return AggregationResult_Count.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Count>): AggregationResult_Count {
    const message = createBaseAggregationResult_Count();
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseAggregationResult_Sum(): AggregationResult_Sum {
  return { value: 0 };
}

export const AggregationResult_Sum: MessageFns<AggregationResult_Sum> = {
  encode(message: AggregationResult_Sum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Sum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Sum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Sum {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: AggregationResult_Sum): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Sum>): AggregationResult_Sum {
    return AggregationResult_Sum.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Sum>): AggregationResult_Sum {
    const message = createBaseAggregationResult_Sum();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAggregationResult_Histogram(): AggregationResult_Histogram {
  return { buckets: [] };
}

export const AggregationResult_Histogram: MessageFns<AggregationResult_Histogram> = {
  encode(message: AggregationResult_Histogram, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.buckets) {
      AggregationResult_Histogram_Bucket.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Histogram {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Histogram();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buckets.push(AggregationResult_Histogram_Bucket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Histogram {
    return {
      buckets: globalThis.Array.isArray(object?.buckets)
        ? object.buckets.map((e: any) => AggregationResult_Histogram_Bucket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregationResult_Histogram): unknown {
    const obj: any = {};
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => AggregationResult_Histogram_Bucket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Histogram>): AggregationResult_Histogram {
    return AggregationResult_Histogram.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Histogram>): AggregationResult_Histogram {
    const message = createBaseAggregationResult_Histogram();
    message.buckets = object.buckets?.map((e) => AggregationResult_Histogram_Bucket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAggregationResult_Histogram_Bucket(): AggregationResult_Histogram_Bucket {
  return { lowerBound: 0, upperBound: 0, count: Long.ZERO };
}

export const AggregationResult_Histogram_Bucket: MessageFns<AggregationResult_Histogram_Bucket> = {
  encode(message: AggregationResult_Histogram_Bucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerBound !== 0) {
      writer.uint32(9).double(message.lowerBound);
    }
    if (message.upperBound !== 0) {
      writer.uint32(17).double(message.upperBound);
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Histogram_Bucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Histogram_Bucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.lowerBound = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.upperBound = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Histogram_Bucket {
    return {
      lowerBound: isSet(object.lowerBound) ? globalThis.Number(object.lowerBound) : 0,
      upperBound: isSet(object.upperBound) ? globalThis.Number(object.upperBound) : 0,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: AggregationResult_Histogram_Bucket): unknown {
    const obj: any = {};
    if (message.lowerBound !== 0) {
      obj.lowerBound = message.lowerBound;
    }
    if (message.upperBound !== 0) {
      obj.upperBound = message.upperBound;
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Histogram_Bucket>): AggregationResult_Histogram_Bucket {
    return AggregationResult_Histogram_Bucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Histogram_Bucket>): AggregationResult_Histogram_Bucket {
    const message = createBaseAggregationResult_Histogram_Bucket();
    message.lowerBound = object.lowerBound ?? 0;
    message.upperBound = object.upperBound ?? 0;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseAggregationResult_Frequency(): AggregationResult_Frequency {
  return { values: {} };
}

export const AggregationResult_Frequency: MessageFns<AggregationResult_Frequency> = {
  encode(message: AggregationResult_Frequency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.values).forEach(([key, value]) => {
      AggregationResult_Frequency_ValuesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Frequency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Frequency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AggregationResult_Frequency_ValuesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.values[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Frequency {
    return {
      values: isObject(object.values)
        ? Object.entries(object.values).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AggregationResult_Frequency): unknown {
    const obj: any = {};
    if (message.values) {
      const entries = Object.entries(message.values);
      if (entries.length > 0) {
        obj.values = {};
        entries.forEach(([k, v]) => {
          obj.values[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Frequency>): AggregationResult_Frequency {
    return AggregationResult_Frequency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Frequency>): AggregationResult_Frequency {
    const message = createBaseAggregationResult_Frequency();
    message.values = Object.entries(object.values ?? {}).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAggregationResult_Frequency_ValuesEntry(): AggregationResult_Frequency_ValuesEntry {
  return { key: "", value: Long.ZERO };
}

export const AggregationResult_Frequency_ValuesEntry: MessageFns<AggregationResult_Frequency_ValuesEntry> = {
  encode(message: AggregationResult_Frequency_ValuesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationResult_Frequency_ValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationResult_Frequency_ValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationResult_Frequency_ValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: AggregationResult_Frequency_ValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationResult_Frequency_ValuesEntry>): AggregationResult_Frequency_ValuesEntry {
    return AggregationResult_Frequency_ValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationResult_Frequency_ValuesEntry>): AggregationResult_Frequency_ValuesEntry {
    const message = createBaseAggregationResult_Frequency_ValuesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseFileValidationReport(): FileValidationReport {
  return { fileName: "", rowErrors: [], partialReport: false, fileErrors: [] };
}

export const FileValidationReport: MessageFns<FileValidationReport> = {
  encode(message: FileValidationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    for (const v of message.rowErrors) {
      ImportRowError.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.partialReport !== false) {
      writer.uint32(24).bool(message.partialReport);
    }
    for (const v of message.fileErrors) {
      ImportError.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileValidationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileValidationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rowErrors.push(ImportRowError.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.partialReport = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fileErrors.push(ImportError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileValidationReport {
    return {
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      rowErrors: globalThis.Array.isArray(object?.rowErrors)
        ? object.rowErrors.map((e: any) => ImportRowError.fromJSON(e))
        : [],
      partialReport: isSet(object.partialReport) ? globalThis.Boolean(object.partialReport) : false,
      fileErrors: globalThis.Array.isArray(object?.fileErrors)
        ? object.fileErrors.map((e: any) => ImportError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FileValidationReport): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.rowErrors?.length) {
      obj.rowErrors = message.rowErrors.map((e) => ImportRowError.toJSON(e));
    }
    if (message.partialReport !== false) {
      obj.partialReport = message.partialReport;
    }
    if (message.fileErrors?.length) {
      obj.fileErrors = message.fileErrors.map((e) => ImportError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FileValidationReport>): FileValidationReport {
    return FileValidationReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileValidationReport>): FileValidationReport {
    const message = createBaseFileValidationReport();
    message.fileName = object.fileName ?? "";
    message.rowErrors = object.rowErrors?.map((e) => ImportRowError.fromPartial(e)) || [];
    message.partialReport = object.partialReport ?? false;
    message.fileErrors = object.fileErrors?.map((e) => ImportError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseValidationReport(): ValidationReport {
  return { fileValidations: [], jobErrors: [] };
}

export const ValidationReport: MessageFns<ValidationReport> = {
  encode(message: ValidationReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileValidations) {
      FileValidationReport.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.jobErrors) {
      ImportError.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidationReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidationReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileValidations.push(FileValidationReport.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jobErrors.push(ImportError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidationReport {
    return {
      fileValidations: globalThis.Array.isArray(object?.fileValidations)
        ? object.fileValidations.map((e: any) => FileValidationReport.fromJSON(e))
        : [],
      jobErrors: globalThis.Array.isArray(object?.jobErrors)
        ? object.jobErrors.map((e: any) => ImportError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ValidationReport): unknown {
    const obj: any = {};
    if (message.fileValidations?.length) {
      obj.fileValidations = message.fileValidations.map((e) => FileValidationReport.toJSON(e));
    }
    if (message.jobErrors?.length) {
      obj.jobErrors = message.jobErrors.map((e) => ImportError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ValidationReport>): ValidationReport {
    return ValidationReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidationReport>): ValidationReport {
    const message = createBaseValidationReport();
    message.fileValidations = object.fileValidations?.map((e) => FileValidationReport.fromPartial(e)) || [];
    message.jobErrors = object.jobErrors?.map((e) => ImportError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionReport(): ExecutionReport {
  return { framesReported: 0, executionErrors: undefined, totalRowsCount: 0 };
}

export const ExecutionReport: MessageFns<ExecutionReport> = {
  encode(message: ExecutionReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.framesReported !== 0) {
      writer.uint32(8).int32(message.framesReported);
    }
    if (message.executionErrors !== undefined) {
      ValidationReport.encode(message.executionErrors, writer.uint32(18).fork()).join();
    }
    if (message.totalRowsCount !== 0) {
      writer.uint32(24).int32(message.totalRowsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.framesReported = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.executionErrors = ValidationReport.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalRowsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionReport {
    return {
      framesReported: isSet(object.framesReported) ? globalThis.Number(object.framesReported) : 0,
      executionErrors: isSet(object.executionErrors) ? ValidationReport.fromJSON(object.executionErrors) : undefined,
      totalRowsCount: isSet(object.totalRowsCount) ? globalThis.Number(object.totalRowsCount) : 0,
    };
  },

  toJSON(message: ExecutionReport): unknown {
    const obj: any = {};
    if (message.framesReported !== 0) {
      obj.framesReported = Math.round(message.framesReported);
    }
    if (message.executionErrors !== undefined) {
      obj.executionErrors = ValidationReport.toJSON(message.executionErrors);
    }
    if (message.totalRowsCount !== 0) {
      obj.totalRowsCount = Math.round(message.totalRowsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionReport>): ExecutionReport {
    return ExecutionReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionReport>): ExecutionReport {
    const message = createBaseExecutionReport();
    message.framesReported = object.framesReported ?? 0;
    message.executionErrors = (object.executionErrors !== undefined && object.executionErrors !== null)
      ? ValidationReport.fromPartial(object.executionErrors)
      : undefined;
    message.totalRowsCount = object.totalRowsCount ?? 0;
    return message;
  },
};

function createBaseImportError(): ImportError {
  return { errorDetails: "", severity: 0 };
}

export const ImportError: MessageFns<ImportError> = {
  encode(message: ImportError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorDetails !== "") {
      writer.uint32(10).string(message.errorDetails);
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorDetails = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportError {
    return {
      errorDetails: isSet(object.errorDetails) ? globalThis.String(object.errorDetails) : "",
      severity: isSet(object.severity) ? importError_SeverityFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: ImportError): unknown {
    const obj: any = {};
    if (message.errorDetails !== "") {
      obj.errorDetails = message.errorDetails;
    }
    if (message.severity !== 0) {
      obj.severity = importError_SeverityToJSON(message.severity);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportError>): ImportError {
    return ImportError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportError>): ImportError {
    const message = createBaseImportError();
    message.errorDetails = object.errorDetails ?? "";
    message.severity = object.severity ?? 0;
    return message;
  },
};

function createBaseImportRowError(): ImportRowError {
  return { rowNumber: 0, vmName: "", vmUuid: "", errors: [] };
}

export const ImportRowError: MessageFns<ImportRowError> = {
  encode(message: ImportRowError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rowNumber !== 0) {
      writer.uint32(8).int32(message.rowNumber);
    }
    if (message.vmName !== "") {
      writer.uint32(18).string(message.vmName);
    }
    if (message.vmUuid !== "") {
      writer.uint32(26).string(message.vmUuid);
    }
    for (const v of message.errors) {
      ImportError.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportRowError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportRowError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rowNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vmName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vmUuid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.errors.push(ImportError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportRowError {
    return {
      rowNumber: isSet(object.rowNumber) ? globalThis.Number(object.rowNumber) : 0,
      vmName: isSet(object.vmName) ? globalThis.String(object.vmName) : "",
      vmUuid: isSet(object.vmUuid) ? globalThis.String(object.vmUuid) : "",
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ImportError.fromJSON(e)) : [],
    };
  },

  toJSON(message: ImportRowError): unknown {
    const obj: any = {};
    if (message.rowNumber !== 0) {
      obj.rowNumber = Math.round(message.rowNumber);
    }
    if (message.vmName !== "") {
      obj.vmName = message.vmName;
    }
    if (message.vmUuid !== "") {
      obj.vmUuid = message.vmUuid;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ImportError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ImportRowError>): ImportRowError {
    return ImportRowError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportRowError>): ImportRowError {
    const message = createBaseImportRowError();
    message.rowNumber = object.rowNumber ?? 0;
    message.vmName = object.vmName ?? "";
    message.vmUuid = object.vmUuid ?? "";
    message.errors = object.errors?.map((e) => ImportError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadFileInfo(): UploadFileInfo {
  return { signedUri: "", headers: {}, uriExpirationTime: undefined };
}

export const UploadFileInfo: MessageFns<UploadFileInfo> = {
  encode(message: UploadFileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signedUri !== "") {
      writer.uint32(10).string(message.signedUri);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      UploadFileInfo_HeadersEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.uriExpirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.uriExpirationTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadFileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signedUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = UploadFileInfo_HeadersEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.headers[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uriExpirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadFileInfo {
    return {
      signedUri: isSet(object.signedUri) ? globalThis.String(object.signedUri) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      uriExpirationTime: isSet(object.uriExpirationTime) ? fromJsonTimestamp(object.uriExpirationTime) : undefined,
    };
  },

  toJSON(message: UploadFileInfo): unknown {
    const obj: any = {};
    if (message.signedUri !== "") {
      obj.signedUri = message.signedUri;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.uriExpirationTime !== undefined) {
      obj.uriExpirationTime = message.uriExpirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<UploadFileInfo>): UploadFileInfo {
    return UploadFileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadFileInfo>): UploadFileInfo {
    const message = createBaseUploadFileInfo();
    message.signedUri = object.signedUri ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.uriExpirationTime = object.uriExpirationTime ?? undefined;
    return message;
  },
};

function createBaseUploadFileInfo_HeadersEntry(): UploadFileInfo_HeadersEntry {
  return { key: "", value: "" };
}

export const UploadFileInfo_HeadersEntry: MessageFns<UploadFileInfo_HeadersEntry> = {
  encode(message: UploadFileInfo_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadFileInfo_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadFileInfo_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadFileInfo_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UploadFileInfo_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UploadFileInfo_HeadersEntry>): UploadFileInfo_HeadersEntry {
    return UploadFileInfo_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UploadFileInfo_HeadersEntry>): UploadFileInfo_HeadersEntry {
    const message = createBaseUploadFileInfo_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAssetList(): AssetList {
  return { assetIds: [] };
}

export const AssetList: MessageFns<AssetList> = {
  encode(message: AssetList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assetIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssetList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetList {
    return {
      assetIds: globalThis.Array.isArray(object?.assetIds) ? object.assetIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AssetList): unknown {
    const obj: any = {};
    if (message.assetIds?.length) {
      obj.assetIds = message.assetIds;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetList>): AssetList {
    return AssetList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetList>): AssetList {
    const message = createBaseAssetList();
    message.assetIds = object.assetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFrameViolationEntry(): FrameViolationEntry {
  return { field: "", violation: "" };
}

export const FrameViolationEntry: MessageFns<FrameViolationEntry> = {
  encode(message: FrameViolationEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.violation !== "") {
      writer.uint32(18).string(message.violation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrameViolationEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrameViolationEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.violation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrameViolationEntry {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      violation: isSet(object.violation) ? globalThis.String(object.violation) : "",
    };
  },

  toJSON(message: FrameViolationEntry): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.violation !== "") {
      obj.violation = message.violation;
    }
    return obj;
  },

  create(base?: DeepPartial<FrameViolationEntry>): FrameViolationEntry {
    return FrameViolationEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FrameViolationEntry>): FrameViolationEntry {
    const message = createBaseFrameViolationEntry();
    message.field = object.field ?? "";
    message.violation = object.violation ?? "";
    return message;
  },
};

function createBaseVirtualMachinePreferences(): VirtualMachinePreferences {
  return {
    targetProduct: 0,
    regionPreferences: undefined,
    commitmentPlan: 0,
    sizingOptimizationStrategy: 0,
    computeEnginePreferences: undefined,
    vmwareEnginePreferences: undefined,
    soleTenancyPreferences: undefined,
  };
}

export const VirtualMachinePreferences: MessageFns<VirtualMachinePreferences> = {
  encode(message: VirtualMachinePreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetProduct !== 0) {
      writer.uint32(16).int32(message.targetProduct);
    }
    if (message.regionPreferences !== undefined) {
      RegionPreferences.encode(message.regionPreferences, writer.uint32(26).fork()).join();
    }
    if (message.commitmentPlan !== 0) {
      writer.uint32(32).int32(message.commitmentPlan);
    }
    if (message.sizingOptimizationStrategy !== 0) {
      writer.uint32(40).int32(message.sizingOptimizationStrategy);
    }
    if (message.computeEnginePreferences !== undefined) {
      ComputeEnginePreferences.encode(message.computeEnginePreferences, writer.uint32(50).fork()).join();
    }
    if (message.vmwareEnginePreferences !== undefined) {
      VmwareEnginePreferences.encode(message.vmwareEnginePreferences, writer.uint32(58).fork()).join();
    }
    if (message.soleTenancyPreferences !== undefined) {
      SoleTenancyPreferences.encode(message.soleTenancyPreferences, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualMachinePreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualMachinePreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetProduct = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regionPreferences = RegionPreferences.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.commitmentPlan = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sizingOptimizationStrategy = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.computeEnginePreferences = ComputeEnginePreferences.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vmwareEnginePreferences = VmwareEnginePreferences.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.soleTenancyPreferences = SoleTenancyPreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualMachinePreferences {
    return {
      targetProduct: isSet(object.targetProduct) ? computeMigrationTargetProductFromJSON(object.targetProduct) : 0,
      regionPreferences: isSet(object.regionPreferences)
        ? RegionPreferences.fromJSON(object.regionPreferences)
        : undefined,
      commitmentPlan: isSet(object.commitmentPlan) ? commitmentPlanFromJSON(object.commitmentPlan) : 0,
      sizingOptimizationStrategy: isSet(object.sizingOptimizationStrategy)
        ? sizingOptimizationStrategyFromJSON(object.sizingOptimizationStrategy)
        : 0,
      computeEnginePreferences: isSet(object.computeEnginePreferences)
        ? ComputeEnginePreferences.fromJSON(object.computeEnginePreferences)
        : undefined,
      vmwareEnginePreferences: isSet(object.vmwareEnginePreferences)
        ? VmwareEnginePreferences.fromJSON(object.vmwareEnginePreferences)
        : undefined,
      soleTenancyPreferences: isSet(object.soleTenancyPreferences)
        ? SoleTenancyPreferences.fromJSON(object.soleTenancyPreferences)
        : undefined,
    };
  },

  toJSON(message: VirtualMachinePreferences): unknown {
    const obj: any = {};
    if (message.targetProduct !== 0) {
      obj.targetProduct = computeMigrationTargetProductToJSON(message.targetProduct);
    }
    if (message.regionPreferences !== undefined) {
      obj.regionPreferences = RegionPreferences.toJSON(message.regionPreferences);
    }
    if (message.commitmentPlan !== 0) {
      obj.commitmentPlan = commitmentPlanToJSON(message.commitmentPlan);
    }
    if (message.sizingOptimizationStrategy !== 0) {
      obj.sizingOptimizationStrategy = sizingOptimizationStrategyToJSON(message.sizingOptimizationStrategy);
    }
    if (message.computeEnginePreferences !== undefined) {
      obj.computeEnginePreferences = ComputeEnginePreferences.toJSON(message.computeEnginePreferences);
    }
    if (message.vmwareEnginePreferences !== undefined) {
      obj.vmwareEnginePreferences = VmwareEnginePreferences.toJSON(message.vmwareEnginePreferences);
    }
    if (message.soleTenancyPreferences !== undefined) {
      obj.soleTenancyPreferences = SoleTenancyPreferences.toJSON(message.soleTenancyPreferences);
    }
    return obj;
  },

  create(base?: DeepPartial<VirtualMachinePreferences>): VirtualMachinePreferences {
    return VirtualMachinePreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VirtualMachinePreferences>): VirtualMachinePreferences {
    const message = createBaseVirtualMachinePreferences();
    message.targetProduct = object.targetProduct ?? 0;
    message.regionPreferences = (object.regionPreferences !== undefined && object.regionPreferences !== null)
      ? RegionPreferences.fromPartial(object.regionPreferences)
      : undefined;
    message.commitmentPlan = object.commitmentPlan ?? 0;
    message.sizingOptimizationStrategy = object.sizingOptimizationStrategy ?? 0;
    message.computeEnginePreferences =
      (object.computeEnginePreferences !== undefined && object.computeEnginePreferences !== null)
        ? ComputeEnginePreferences.fromPartial(object.computeEnginePreferences)
        : undefined;
    message.vmwareEnginePreferences =
      (object.vmwareEnginePreferences !== undefined && object.vmwareEnginePreferences !== null)
        ? VmwareEnginePreferences.fromPartial(object.vmwareEnginePreferences)
        : undefined;
    message.soleTenancyPreferences =
      (object.soleTenancyPreferences !== undefined && object.soleTenancyPreferences !== null)
        ? SoleTenancyPreferences.fromPartial(object.soleTenancyPreferences)
        : undefined;
    return message;
  },
};

function createBaseComputeEnginePreferences(): ComputeEnginePreferences {
  return { machinePreferences: undefined, licenseType: 0 };
}

export const ComputeEnginePreferences: MessageFns<ComputeEnginePreferences> = {
  encode(message: ComputeEnginePreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machinePreferences !== undefined) {
      MachinePreferences.encode(message.machinePreferences, writer.uint32(18).fork()).join();
    }
    if (message.licenseType !== 0) {
      writer.uint32(24).int32(message.licenseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeEnginePreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeEnginePreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.machinePreferences = MachinePreferences.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.licenseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeEnginePreferences {
    return {
      machinePreferences: isSet(object.machinePreferences)
        ? MachinePreferences.fromJSON(object.machinePreferences)
        : undefined,
      licenseType: isSet(object.licenseType) ? licenseTypeFromJSON(object.licenseType) : 0,
    };
  },

  toJSON(message: ComputeEnginePreferences): unknown {
    const obj: any = {};
    if (message.machinePreferences !== undefined) {
      obj.machinePreferences = MachinePreferences.toJSON(message.machinePreferences);
    }
    if (message.licenseType !== 0) {
      obj.licenseType = licenseTypeToJSON(message.licenseType);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeEnginePreferences>): ComputeEnginePreferences {
    return ComputeEnginePreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeEnginePreferences>): ComputeEnginePreferences {
    const message = createBaseComputeEnginePreferences();
    message.machinePreferences = (object.machinePreferences !== undefined && object.machinePreferences !== null)
      ? MachinePreferences.fromPartial(object.machinePreferences)
      : undefined;
    message.licenseType = object.licenseType ?? 0;
    return message;
  },
};

function createBaseMachinePreferences(): MachinePreferences {
  return { allowedMachineSeries: [] };
}

export const MachinePreferences: MessageFns<MachinePreferences> = {
  encode(message: MachinePreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedMachineSeries) {
      MachineSeries.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachinePreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachinePreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedMachineSeries.push(MachineSeries.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachinePreferences {
    return {
      allowedMachineSeries: globalThis.Array.isArray(object?.allowedMachineSeries)
        ? object.allowedMachineSeries.map((e: any) => MachineSeries.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MachinePreferences): unknown {
    const obj: any = {};
    if (message.allowedMachineSeries?.length) {
      obj.allowedMachineSeries = message.allowedMachineSeries.map((e) => MachineSeries.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MachinePreferences>): MachinePreferences {
    return MachinePreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachinePreferences>): MachinePreferences {
    const message = createBaseMachinePreferences();
    message.allowedMachineSeries = object.allowedMachineSeries?.map((e) => MachineSeries.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMachineSeries(): MachineSeries {
  return { code: "" };
}

export const MachineSeries: MessageFns<MachineSeries> = {
  encode(message: MachineSeries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MachineSeries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachineSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MachineSeries {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: MachineSeries): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<MachineSeries>): MachineSeries {
    return MachineSeries.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MachineSeries>): MachineSeries {
    const message = createBaseMachineSeries();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseVmwareEnginePreferences(): VmwareEnginePreferences {
  return {
    cpuOvercommitRatio: 0,
    memoryOvercommitRatio: 0,
    storageDeduplicationCompressionRatio: 0,
    commitmentPlan: 0,
  };
}

export const VmwareEnginePreferences: MessageFns<VmwareEnginePreferences> = {
  encode(message: VmwareEnginePreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuOvercommitRatio !== 0) {
      writer.uint32(9).double(message.cpuOvercommitRatio);
    }
    if (message.memoryOvercommitRatio !== 0) {
      writer.uint32(17).double(message.memoryOvercommitRatio);
    }
    if (message.storageDeduplicationCompressionRatio !== 0) {
      writer.uint32(25).double(message.storageDeduplicationCompressionRatio);
    }
    if (message.commitmentPlan !== 0) {
      writer.uint32(32).int32(message.commitmentPlan);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareEnginePreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareEnginePreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.cpuOvercommitRatio = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.memoryOvercommitRatio = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.storageDeduplicationCompressionRatio = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.commitmentPlan = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareEnginePreferences {
    return {
      cpuOvercommitRatio: isSet(object.cpuOvercommitRatio) ? globalThis.Number(object.cpuOvercommitRatio) : 0,
      memoryOvercommitRatio: isSet(object.memoryOvercommitRatio) ? globalThis.Number(object.memoryOvercommitRatio) : 0,
      storageDeduplicationCompressionRatio: isSet(object.storageDeduplicationCompressionRatio)
        ? globalThis.Number(object.storageDeduplicationCompressionRatio)
        : 0,
      commitmentPlan: isSet(object.commitmentPlan)
        ? vmwareEnginePreferences_CommitmentPlanFromJSON(object.commitmentPlan)
        : 0,
    };
  },

  toJSON(message: VmwareEnginePreferences): unknown {
    const obj: any = {};
    if (message.cpuOvercommitRatio !== 0) {
      obj.cpuOvercommitRatio = message.cpuOvercommitRatio;
    }
    if (message.memoryOvercommitRatio !== 0) {
      obj.memoryOvercommitRatio = message.memoryOvercommitRatio;
    }
    if (message.storageDeduplicationCompressionRatio !== 0) {
      obj.storageDeduplicationCompressionRatio = message.storageDeduplicationCompressionRatio;
    }
    if (message.commitmentPlan !== 0) {
      obj.commitmentPlan = vmwareEnginePreferences_CommitmentPlanToJSON(message.commitmentPlan);
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareEnginePreferences>): VmwareEnginePreferences {
    return VmwareEnginePreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareEnginePreferences>): VmwareEnginePreferences {
    const message = createBaseVmwareEnginePreferences();
    message.cpuOvercommitRatio = object.cpuOvercommitRatio ?? 0;
    message.memoryOvercommitRatio = object.memoryOvercommitRatio ?? 0;
    message.storageDeduplicationCompressionRatio = object.storageDeduplicationCompressionRatio ?? 0;
    message.commitmentPlan = object.commitmentPlan ?? 0;
    return message;
  },
};

function createBaseSoleTenancyPreferences(): SoleTenancyPreferences {
  return { cpuOvercommitRatio: 0, hostMaintenancePolicy: 0, commitmentPlan: 0, nodeTypes: [] };
}

export const SoleTenancyPreferences: MessageFns<SoleTenancyPreferences> = {
  encode(message: SoleTenancyPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuOvercommitRatio !== 0) {
      writer.uint32(9).double(message.cpuOvercommitRatio);
    }
    if (message.hostMaintenancePolicy !== 0) {
      writer.uint32(16).int32(message.hostMaintenancePolicy);
    }
    if (message.commitmentPlan !== 0) {
      writer.uint32(24).int32(message.commitmentPlan);
    }
    for (const v of message.nodeTypes) {
      SoleTenantNodeType.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoleTenancyPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoleTenancyPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.cpuOvercommitRatio = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hostMaintenancePolicy = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.commitmentPlan = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeTypes.push(SoleTenantNodeType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoleTenancyPreferences {
    return {
      cpuOvercommitRatio: isSet(object.cpuOvercommitRatio) ? globalThis.Number(object.cpuOvercommitRatio) : 0,
      hostMaintenancePolicy: isSet(object.hostMaintenancePolicy)
        ? soleTenancyPreferences_HostMaintenancePolicyFromJSON(object.hostMaintenancePolicy)
        : 0,
      commitmentPlan: isSet(object.commitmentPlan)
        ? soleTenancyPreferences_CommitmentPlanFromJSON(object.commitmentPlan)
        : 0,
      nodeTypes: globalThis.Array.isArray(object?.nodeTypes)
        ? object.nodeTypes.map((e: any) => SoleTenantNodeType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SoleTenancyPreferences): unknown {
    const obj: any = {};
    if (message.cpuOvercommitRatio !== 0) {
      obj.cpuOvercommitRatio = message.cpuOvercommitRatio;
    }
    if (message.hostMaintenancePolicy !== 0) {
      obj.hostMaintenancePolicy = soleTenancyPreferences_HostMaintenancePolicyToJSON(message.hostMaintenancePolicy);
    }
    if (message.commitmentPlan !== 0) {
      obj.commitmentPlan = soleTenancyPreferences_CommitmentPlanToJSON(message.commitmentPlan);
    }
    if (message.nodeTypes?.length) {
      obj.nodeTypes = message.nodeTypes.map((e) => SoleTenantNodeType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoleTenancyPreferences>): SoleTenancyPreferences {
    return SoleTenancyPreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoleTenancyPreferences>): SoleTenancyPreferences {
    const message = createBaseSoleTenancyPreferences();
    message.cpuOvercommitRatio = object.cpuOvercommitRatio ?? 0;
    message.hostMaintenancePolicy = object.hostMaintenancePolicy ?? 0;
    message.commitmentPlan = object.commitmentPlan ?? 0;
    message.nodeTypes = object.nodeTypes?.map((e) => SoleTenantNodeType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSoleTenantNodeType(): SoleTenantNodeType {
  return { nodeName: "" };
}

export const SoleTenantNodeType: MessageFns<SoleTenantNodeType> = {
  encode(message: SoleTenantNodeType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeName !== "") {
      writer.uint32(10).string(message.nodeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoleTenantNodeType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoleTenantNodeType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoleTenantNodeType {
    return { nodeName: isSet(object.nodeName) ? globalThis.String(object.nodeName) : "" };
  },

  toJSON(message: SoleTenantNodeType): unknown {
    const obj: any = {};
    if (message.nodeName !== "") {
      obj.nodeName = message.nodeName;
    }
    return obj;
  },

  create(base?: DeepPartial<SoleTenantNodeType>): SoleTenantNodeType {
    return SoleTenantNodeType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoleTenantNodeType>): SoleTenantNodeType {
    const message = createBaseSoleTenantNodeType();
    message.nodeName = object.nodeName ?? "";
    return message;
  },
};

function createBaseRegionPreferences(): RegionPreferences {
  return { preferredRegions: [] };
}

export const RegionPreferences: MessageFns<RegionPreferences> = {
  encode(message: RegionPreferences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.preferredRegions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegionPreferences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionPreferences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preferredRegions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegionPreferences {
    return {
      preferredRegions: globalThis.Array.isArray(object?.preferredRegions)
        ? object.preferredRegions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RegionPreferences): unknown {
    const obj: any = {};
    if (message.preferredRegions?.length) {
      obj.preferredRegions = message.preferredRegions;
    }
    return obj;
  },

  create(base?: DeepPartial<RegionPreferences>): RegionPreferences {
    return RegionPreferences.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegionPreferences>): RegionPreferences {
    const message = createBaseRegionPreferences();
    message.preferredRegions = object.preferredRegions?.map((e) => e) || [];
    return message;
  },
};

function createBaseSettings(): Settings {
  return { name: "", preferenceSet: "" };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.preferenceSet !== "") {
      writer.uint32(18).string(message.preferenceSet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.preferenceSet = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      preferenceSet: isSet(object.preferenceSet) ? globalThis.String(object.preferenceSet) : "",
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.preferenceSet !== "") {
      obj.preferenceSet = message.preferenceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.name = object.name ?? "";
    message.preferenceSet = object.preferenceSet ?? "";
    return message;
  },
};

function createBaseReportSummary(): ReportSummary {
  return { allAssetsStats: undefined, groupFindings: [] };
}

export const ReportSummary: MessageFns<ReportSummary> = {
  encode(message: ReportSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allAssetsStats !== undefined) {
      ReportSummary_AssetAggregateStats.encode(message.allAssetsStats, writer.uint32(10).fork()).join();
    }
    for (const v of message.groupFindings) {
      ReportSummary_GroupFinding.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allAssetsStats = ReportSummary_AssetAggregateStats.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupFindings.push(ReportSummary_GroupFinding.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary {
    return {
      allAssetsStats: isSet(object.allAssetsStats)
        ? ReportSummary_AssetAggregateStats.fromJSON(object.allAssetsStats)
        : undefined,
      groupFindings: globalThis.Array.isArray(object?.groupFindings)
        ? object.groupFindings.map((e: any) => ReportSummary_GroupFinding.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary): unknown {
    const obj: any = {};
    if (message.allAssetsStats !== undefined) {
      obj.allAssetsStats = ReportSummary_AssetAggregateStats.toJSON(message.allAssetsStats);
    }
    if (message.groupFindings?.length) {
      obj.groupFindings = message.groupFindings.map((e) => ReportSummary_GroupFinding.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary>): ReportSummary {
    return ReportSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary>): ReportSummary {
    const message = createBaseReportSummary();
    message.allAssetsStats = (object.allAssetsStats !== undefined && object.allAssetsStats !== null)
      ? ReportSummary_AssetAggregateStats.fromPartial(object.allAssetsStats)
      : undefined;
    message.groupFindings = object.groupFindings?.map((e) => ReportSummary_GroupFinding.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportSummary_ChartData(): ReportSummary_ChartData {
  return { dataPoints: [] };
}

export const ReportSummary_ChartData: MessageFns<ReportSummary_ChartData> = {
  encode(message: ReportSummary_ChartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataPoints) {
      ReportSummary_ChartData_DataPoint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_ChartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_ChartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataPoints.push(ReportSummary_ChartData_DataPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_ChartData {
    return {
      dataPoints: globalThis.Array.isArray(object?.dataPoints)
        ? object.dataPoints.map((e: any) => ReportSummary_ChartData_DataPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_ChartData): unknown {
    const obj: any = {};
    if (message.dataPoints?.length) {
      obj.dataPoints = message.dataPoints.map((e) => ReportSummary_ChartData_DataPoint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_ChartData>): ReportSummary_ChartData {
    return ReportSummary_ChartData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_ChartData>): ReportSummary_ChartData {
    const message = createBaseReportSummary_ChartData();
    message.dataPoints = object.dataPoints?.map((e) => ReportSummary_ChartData_DataPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportSummary_ChartData_DataPoint(): ReportSummary_ChartData_DataPoint {
  return { label: "", value: 0 };
}

export const ReportSummary_ChartData_DataPoint: MessageFns<ReportSummary_ChartData_DataPoint> = {
  encode(message: ReportSummary_ChartData_DataPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_ChartData_DataPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_ChartData_DataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_ChartData_DataPoint {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ReportSummary_ChartData_DataPoint): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_ChartData_DataPoint>): ReportSummary_ChartData_DataPoint {
    return ReportSummary_ChartData_DataPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_ChartData_DataPoint>): ReportSummary_ChartData_DataPoint {
    const message = createBaseReportSummary_ChartData_DataPoint();
    message.label = object.label ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseReportSummary_UtilizationChartData(): ReportSummary_UtilizationChartData {
  return { used: Long.ZERO, free: Long.ZERO };
}

export const ReportSummary_UtilizationChartData: MessageFns<ReportSummary_UtilizationChartData> = {
  encode(message: ReportSummary_UtilizationChartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.used.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.used.toString());
    }
    if (!message.free.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.free.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_UtilizationChartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_UtilizationChartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.used = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.free = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_UtilizationChartData {
    return {
      used: isSet(object.used) ? Long.fromValue(object.used) : Long.ZERO,
      free: isSet(object.free) ? Long.fromValue(object.free) : Long.ZERO,
    };
  },

  toJSON(message: ReportSummary_UtilizationChartData): unknown {
    const obj: any = {};
    if (!message.used.equals(Long.ZERO)) {
      obj.used = (message.used || Long.ZERO).toString();
    }
    if (!message.free.equals(Long.ZERO)) {
      obj.free = (message.free || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_UtilizationChartData>): ReportSummary_UtilizationChartData {
    return ReportSummary_UtilizationChartData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_UtilizationChartData>): ReportSummary_UtilizationChartData {
    const message = createBaseReportSummary_UtilizationChartData();
    message.used = (object.used !== undefined && object.used !== null) ? Long.fromValue(object.used) : Long.ZERO;
    message.free = (object.free !== undefined && object.free !== null) ? Long.fromValue(object.free) : Long.ZERO;
    return message;
  },
};

function createBaseReportSummary_HistogramChartData(): ReportSummary_HistogramChartData {
  return { buckets: [] };
}

export const ReportSummary_HistogramChartData: MessageFns<ReportSummary_HistogramChartData> = {
  encode(message: ReportSummary_HistogramChartData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.buckets) {
      ReportSummary_HistogramChartData_Bucket.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_HistogramChartData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_HistogramChartData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buckets.push(ReportSummary_HistogramChartData_Bucket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_HistogramChartData {
    return {
      buckets: globalThis.Array.isArray(object?.buckets)
        ? object.buckets.map((e: any) => ReportSummary_HistogramChartData_Bucket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_HistogramChartData): unknown {
    const obj: any = {};
    if (message.buckets?.length) {
      obj.buckets = message.buckets.map((e) => ReportSummary_HistogramChartData_Bucket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_HistogramChartData>): ReportSummary_HistogramChartData {
    return ReportSummary_HistogramChartData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_HistogramChartData>): ReportSummary_HistogramChartData {
    const message = createBaseReportSummary_HistogramChartData();
    message.buckets = object.buckets?.map((e) => ReportSummary_HistogramChartData_Bucket.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportSummary_HistogramChartData_Bucket(): ReportSummary_HistogramChartData_Bucket {
  return { lowerBound: Long.ZERO, upperBound: Long.ZERO, count: Long.ZERO };
}

export const ReportSummary_HistogramChartData_Bucket: MessageFns<ReportSummary_HistogramChartData_Bucket> = {
  encode(message: ReportSummary_HistogramChartData_Bucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.lowerBound.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.lowerBound.toString());
    }
    if (!message.upperBound.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.upperBound.toString());
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_HistogramChartData_Bucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_HistogramChartData_Bucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lowerBound = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.upperBound = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_HistogramChartData_Bucket {
    return {
      lowerBound: isSet(object.lowerBound) ? Long.fromValue(object.lowerBound) : Long.ZERO,
      upperBound: isSet(object.upperBound) ? Long.fromValue(object.upperBound) : Long.ZERO,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
    };
  },

  toJSON(message: ReportSummary_HistogramChartData_Bucket): unknown {
    const obj: any = {};
    if (!message.lowerBound.equals(Long.ZERO)) {
      obj.lowerBound = (message.lowerBound || Long.ZERO).toString();
    }
    if (!message.upperBound.equals(Long.ZERO)) {
      obj.upperBound = (message.upperBound || Long.ZERO).toString();
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_HistogramChartData_Bucket>): ReportSummary_HistogramChartData_Bucket {
    return ReportSummary_HistogramChartData_Bucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_HistogramChartData_Bucket>): ReportSummary_HistogramChartData_Bucket {
    const message = createBaseReportSummary_HistogramChartData_Bucket();
    message.lowerBound = (object.lowerBound !== undefined && object.lowerBound !== null)
      ? Long.fromValue(object.lowerBound)
      : Long.ZERO;
    message.upperBound = (object.upperBound !== undefined && object.upperBound !== null)
      ? Long.fromValue(object.upperBound)
      : Long.ZERO;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    return message;
  },
};

function createBaseReportSummary_AssetAggregateStats(): ReportSummary_AssetAggregateStats {
  return {
    totalMemoryBytes: Long.ZERO,
    totalStorageBytes: Long.ZERO,
    totalCores: Long.ZERO,
    totalAssets: Long.ZERO,
    memoryUtilizationChart: undefined,
    storageUtilizationChart: undefined,
    operatingSystem: undefined,
    coreCountHistogram: undefined,
    memoryBytesHistogram: undefined,
    storageBytesHistogram: undefined,
  };
}

export const ReportSummary_AssetAggregateStats: MessageFns<ReportSummary_AssetAggregateStats> = {
  encode(message: ReportSummary_AssetAggregateStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalMemoryBytes.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalMemoryBytes.toString());
    }
    if (!message.totalStorageBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalStorageBytes.toString());
    }
    if (!message.totalCores.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalCores.toString());
    }
    if (!message.totalAssets.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalAssets.toString());
    }
    if (message.memoryUtilizationChart !== undefined) {
      ReportSummary_UtilizationChartData.encode(message.memoryUtilizationChart, writer.uint32(42).fork()).join();
    }
    if (message.storageUtilizationChart !== undefined) {
      ReportSummary_UtilizationChartData.encode(message.storageUtilizationChart, writer.uint32(50).fork()).join();
    }
    if (message.operatingSystem !== undefined) {
      ReportSummary_ChartData.encode(message.operatingSystem, writer.uint32(58).fork()).join();
    }
    if (message.coreCountHistogram !== undefined) {
      ReportSummary_HistogramChartData.encode(message.coreCountHistogram, writer.uint32(66).fork()).join();
    }
    if (message.memoryBytesHistogram !== undefined) {
      ReportSummary_HistogramChartData.encode(message.memoryBytesHistogram, writer.uint32(74).fork()).join();
    }
    if (message.storageBytesHistogram !== undefined) {
      ReportSummary_HistogramChartData.encode(message.storageBytesHistogram, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_AssetAggregateStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_AssetAggregateStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalMemoryBytes = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalStorageBytes = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCores = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalAssets = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.memoryUtilizationChart = ReportSummary_UtilizationChartData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.storageUtilizationChart = ReportSummary_UtilizationChartData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.operatingSystem = ReportSummary_ChartData.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.coreCountHistogram = ReportSummary_HistogramChartData.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.memoryBytesHistogram = ReportSummary_HistogramChartData.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.storageBytesHistogram = ReportSummary_HistogramChartData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_AssetAggregateStats {
    return {
      totalMemoryBytes: isSet(object.totalMemoryBytes) ? Long.fromValue(object.totalMemoryBytes) : Long.ZERO,
      totalStorageBytes: isSet(object.totalStorageBytes) ? Long.fromValue(object.totalStorageBytes) : Long.ZERO,
      totalCores: isSet(object.totalCores) ? Long.fromValue(object.totalCores) : Long.ZERO,
      totalAssets: isSet(object.totalAssets) ? Long.fromValue(object.totalAssets) : Long.ZERO,
      memoryUtilizationChart: isSet(object.memoryUtilizationChart)
        ? ReportSummary_UtilizationChartData.fromJSON(object.memoryUtilizationChart)
        : undefined,
      storageUtilizationChart: isSet(object.storageUtilizationChart)
        ? ReportSummary_UtilizationChartData.fromJSON(object.storageUtilizationChart)
        : undefined,
      operatingSystem: isSet(object.operatingSystem)
        ? ReportSummary_ChartData.fromJSON(object.operatingSystem)
        : undefined,
      coreCountHistogram: isSet(object.coreCountHistogram)
        ? ReportSummary_HistogramChartData.fromJSON(object.coreCountHistogram)
        : undefined,
      memoryBytesHistogram: isSet(object.memoryBytesHistogram)
        ? ReportSummary_HistogramChartData.fromJSON(object.memoryBytesHistogram)
        : undefined,
      storageBytesHistogram: isSet(object.storageBytesHistogram)
        ? ReportSummary_HistogramChartData.fromJSON(object.storageBytesHistogram)
        : undefined,
    };
  },

  toJSON(message: ReportSummary_AssetAggregateStats): unknown {
    const obj: any = {};
    if (!message.totalMemoryBytes.equals(Long.ZERO)) {
      obj.totalMemoryBytes = (message.totalMemoryBytes || Long.ZERO).toString();
    }
    if (!message.totalStorageBytes.equals(Long.ZERO)) {
      obj.totalStorageBytes = (message.totalStorageBytes || Long.ZERO).toString();
    }
    if (!message.totalCores.equals(Long.ZERO)) {
      obj.totalCores = (message.totalCores || Long.ZERO).toString();
    }
    if (!message.totalAssets.equals(Long.ZERO)) {
      obj.totalAssets = (message.totalAssets || Long.ZERO).toString();
    }
    if (message.memoryUtilizationChart !== undefined) {
      obj.memoryUtilizationChart = ReportSummary_UtilizationChartData.toJSON(message.memoryUtilizationChart);
    }
    if (message.storageUtilizationChart !== undefined) {
      obj.storageUtilizationChart = ReportSummary_UtilizationChartData.toJSON(message.storageUtilizationChart);
    }
    if (message.operatingSystem !== undefined) {
      obj.operatingSystem = ReportSummary_ChartData.toJSON(message.operatingSystem);
    }
    if (message.coreCountHistogram !== undefined) {
      obj.coreCountHistogram = ReportSummary_HistogramChartData.toJSON(message.coreCountHistogram);
    }
    if (message.memoryBytesHistogram !== undefined) {
      obj.memoryBytesHistogram = ReportSummary_HistogramChartData.toJSON(message.memoryBytesHistogram);
    }
    if (message.storageBytesHistogram !== undefined) {
      obj.storageBytesHistogram = ReportSummary_HistogramChartData.toJSON(message.storageBytesHistogram);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_AssetAggregateStats>): ReportSummary_AssetAggregateStats {
    return ReportSummary_AssetAggregateStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_AssetAggregateStats>): ReportSummary_AssetAggregateStats {
    const message = createBaseReportSummary_AssetAggregateStats();
    message.totalMemoryBytes = (object.totalMemoryBytes !== undefined && object.totalMemoryBytes !== null)
      ? Long.fromValue(object.totalMemoryBytes)
      : Long.ZERO;
    message.totalStorageBytes = (object.totalStorageBytes !== undefined && object.totalStorageBytes !== null)
      ? Long.fromValue(object.totalStorageBytes)
      : Long.ZERO;
    message.totalCores = (object.totalCores !== undefined && object.totalCores !== null)
      ? Long.fromValue(object.totalCores)
      : Long.ZERO;
    message.totalAssets = (object.totalAssets !== undefined && object.totalAssets !== null)
      ? Long.fromValue(object.totalAssets)
      : Long.ZERO;
    message.memoryUtilizationChart =
      (object.memoryUtilizationChart !== undefined && object.memoryUtilizationChart !== null)
        ? ReportSummary_UtilizationChartData.fromPartial(object.memoryUtilizationChart)
        : undefined;
    message.storageUtilizationChart =
      (object.storageUtilizationChart !== undefined && object.storageUtilizationChart !== null)
        ? ReportSummary_UtilizationChartData.fromPartial(object.storageUtilizationChart)
        : undefined;
    message.operatingSystem = (object.operatingSystem !== undefined && object.operatingSystem !== null)
      ? ReportSummary_ChartData.fromPartial(object.operatingSystem)
      : undefined;
    message.coreCountHistogram = (object.coreCountHistogram !== undefined && object.coreCountHistogram !== null)
      ? ReportSummary_HistogramChartData.fromPartial(object.coreCountHistogram)
      : undefined;
    message.memoryBytesHistogram = (object.memoryBytesHistogram !== undefined && object.memoryBytesHistogram !== null)
      ? ReportSummary_HistogramChartData.fromPartial(object.memoryBytesHistogram)
      : undefined;
    message.storageBytesHistogram =
      (object.storageBytesHistogram !== undefined && object.storageBytesHistogram !== null)
        ? ReportSummary_HistogramChartData.fromPartial(object.storageBytesHistogram)
        : undefined;
    return message;
  },
};

function createBaseReportSummary_MachineSeriesAllocation(): ReportSummary_MachineSeriesAllocation {
  return { machineSeries: undefined, allocatedAssetCount: Long.ZERO };
}

export const ReportSummary_MachineSeriesAllocation: MessageFns<ReportSummary_MachineSeriesAllocation> = {
  encode(message: ReportSummary_MachineSeriesAllocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineSeries !== undefined) {
      MachineSeries.encode(message.machineSeries, writer.uint32(10).fork()).join();
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.allocatedAssetCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_MachineSeriesAllocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_MachineSeriesAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineSeries = MachineSeries.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_MachineSeriesAllocation {
    return {
      machineSeries: isSet(object.machineSeries) ? MachineSeries.fromJSON(object.machineSeries) : undefined,
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
    };
  },

  toJSON(message: ReportSummary_MachineSeriesAllocation): unknown {
    const obj: any = {};
    if (message.machineSeries !== undefined) {
      obj.machineSeries = MachineSeries.toJSON(message.machineSeries);
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_MachineSeriesAllocation>): ReportSummary_MachineSeriesAllocation {
    return ReportSummary_MachineSeriesAllocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_MachineSeriesAllocation>): ReportSummary_MachineSeriesAllocation {
    const message = createBaseReportSummary_MachineSeriesAllocation();
    message.machineSeries = (object.machineSeries !== undefined && object.machineSeries !== null)
      ? MachineSeries.fromPartial(object.machineSeries)
      : undefined;
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseReportSummary_ComputeEngineFinding(): ReportSummary_ComputeEngineFinding {
  return { allocatedRegions: [], allocatedAssetCount: Long.ZERO, machineSeriesAllocations: [], allocatedDiskTypes: [] };
}

export const ReportSummary_ComputeEngineFinding: MessageFns<ReportSummary_ComputeEngineFinding> = {
  encode(message: ReportSummary_ComputeEngineFinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allocatedRegions) {
      writer.uint32(10).string(v!);
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.allocatedAssetCount.toString());
    }
    for (const v of message.machineSeriesAllocations) {
      ReportSummary_MachineSeriesAllocation.encode(v!, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.allocatedDiskTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_ComputeEngineFinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_ComputeEngineFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allocatedRegions.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machineSeriesAllocations.push(ReportSummary_MachineSeriesAllocation.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 32) {
            message.allocatedDiskTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allocatedDiskTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_ComputeEngineFinding {
    return {
      allocatedRegions: globalThis.Array.isArray(object?.allocatedRegions)
        ? object.allocatedRegions.map((e: any) => globalThis.String(e))
        : [],
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
      machineSeriesAllocations: globalThis.Array.isArray(object?.machineSeriesAllocations)
        ? object.machineSeriesAllocations.map((e: any) => ReportSummary_MachineSeriesAllocation.fromJSON(e))
        : [],
      allocatedDiskTypes: globalThis.Array.isArray(object?.allocatedDiskTypes)
        ? object.allocatedDiskTypes.map((e: any) => persistentDiskTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_ComputeEngineFinding): unknown {
    const obj: any = {};
    if (message.allocatedRegions?.length) {
      obj.allocatedRegions = message.allocatedRegions;
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    if (message.machineSeriesAllocations?.length) {
      obj.machineSeriesAllocations = message.machineSeriesAllocations.map((e) =>
        ReportSummary_MachineSeriesAllocation.toJSON(e)
      );
    }
    if (message.allocatedDiskTypes?.length) {
      obj.allocatedDiskTypes = message.allocatedDiskTypes.map((e) => persistentDiskTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_ComputeEngineFinding>): ReportSummary_ComputeEngineFinding {
    return ReportSummary_ComputeEngineFinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_ComputeEngineFinding>): ReportSummary_ComputeEngineFinding {
    const message = createBaseReportSummary_ComputeEngineFinding();
    message.allocatedRegions = object.allocatedRegions?.map((e) => e) || [];
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    message.machineSeriesAllocations =
      object.machineSeriesAllocations?.map((e) => ReportSummary_MachineSeriesAllocation.fromPartial(e)) || [];
    message.allocatedDiskTypes = object.allocatedDiskTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseReportSummary_VmwareEngineFinding(): ReportSummary_VmwareEngineFinding {
  return { allocatedRegions: [], allocatedAssetCount: Long.ZERO, nodeAllocations: [] };
}

export const ReportSummary_VmwareEngineFinding: MessageFns<ReportSummary_VmwareEngineFinding> = {
  encode(message: ReportSummary_VmwareEngineFinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allocatedRegions) {
      writer.uint32(10).string(v!);
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.allocatedAssetCount.toString());
    }
    for (const v of message.nodeAllocations) {
      ReportSummary_VmwareNodeAllocation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_VmwareEngineFinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_VmwareEngineFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allocatedRegions.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeAllocations.push(ReportSummary_VmwareNodeAllocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_VmwareEngineFinding {
    return {
      allocatedRegions: globalThis.Array.isArray(object?.allocatedRegions)
        ? object.allocatedRegions.map((e: any) => globalThis.String(e))
        : [],
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
      nodeAllocations: globalThis.Array.isArray(object?.nodeAllocations)
        ? object.nodeAllocations.map((e: any) => ReportSummary_VmwareNodeAllocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_VmwareEngineFinding): unknown {
    const obj: any = {};
    if (message.allocatedRegions?.length) {
      obj.allocatedRegions = message.allocatedRegions;
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    if (message.nodeAllocations?.length) {
      obj.nodeAllocations = message.nodeAllocations.map((e) => ReportSummary_VmwareNodeAllocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_VmwareEngineFinding>): ReportSummary_VmwareEngineFinding {
    return ReportSummary_VmwareEngineFinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_VmwareEngineFinding>): ReportSummary_VmwareEngineFinding {
    const message = createBaseReportSummary_VmwareEngineFinding();
    message.allocatedRegions = object.allocatedRegions?.map((e) => e) || [];
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    message.nodeAllocations = object.nodeAllocations?.map((e) => ReportSummary_VmwareNodeAllocation.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseReportSummary_VmwareNodeAllocation(): ReportSummary_VmwareNodeAllocation {
  return { vmwareNode: undefined, nodeCount: Long.ZERO, allocatedAssetCount: Long.ZERO };
}

export const ReportSummary_VmwareNodeAllocation: MessageFns<ReportSummary_VmwareNodeAllocation> = {
  encode(message: ReportSummary_VmwareNodeAllocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmwareNode !== undefined) {
      ReportSummary_VmwareNode.encode(message.vmwareNode, writer.uint32(10).fork()).join();
    }
    if (!message.nodeCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.nodeCount.toString());
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.allocatedAssetCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_VmwareNodeAllocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_VmwareNodeAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareNode = ReportSummary_VmwareNode.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_VmwareNodeAllocation {
    return {
      vmwareNode: isSet(object.vmwareNode) ? ReportSummary_VmwareNode.fromJSON(object.vmwareNode) : undefined,
      nodeCount: isSet(object.nodeCount) ? Long.fromValue(object.nodeCount) : Long.ZERO,
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
    };
  },

  toJSON(message: ReportSummary_VmwareNodeAllocation): unknown {
    const obj: any = {};
    if (message.vmwareNode !== undefined) {
      obj.vmwareNode = ReportSummary_VmwareNode.toJSON(message.vmwareNode);
    }
    if (!message.nodeCount.equals(Long.ZERO)) {
      obj.nodeCount = (message.nodeCount || Long.ZERO).toString();
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_VmwareNodeAllocation>): ReportSummary_VmwareNodeAllocation {
    return ReportSummary_VmwareNodeAllocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_VmwareNodeAllocation>): ReportSummary_VmwareNodeAllocation {
    const message = createBaseReportSummary_VmwareNodeAllocation();
    message.vmwareNode = (object.vmwareNode !== undefined && object.vmwareNode !== null)
      ? ReportSummary_VmwareNode.fromPartial(object.vmwareNode)
      : undefined;
    message.nodeCount = (object.nodeCount !== undefined && object.nodeCount !== null)
      ? Long.fromValue(object.nodeCount)
      : Long.ZERO;
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseReportSummary_VmwareNode(): ReportSummary_VmwareNode {
  return { code: "" };
}

export const ReportSummary_VmwareNode: MessageFns<ReportSummary_VmwareNode> = {
  encode(message: ReportSummary_VmwareNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_VmwareNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_VmwareNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_VmwareNode {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: ReportSummary_VmwareNode): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_VmwareNode>): ReportSummary_VmwareNode {
    return ReportSummary_VmwareNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_VmwareNode>): ReportSummary_VmwareNode {
    const message = createBaseReportSummary_VmwareNode();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseReportSummary_SoleTenantFinding(): ReportSummary_SoleTenantFinding {
  return { allocatedRegions: [], allocatedAssetCount: Long.ZERO, nodeAllocations: [] };
}

export const ReportSummary_SoleTenantFinding: MessageFns<ReportSummary_SoleTenantFinding> = {
  encode(message: ReportSummary_SoleTenantFinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allocatedRegions) {
      writer.uint32(10).string(v!);
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.allocatedAssetCount.toString());
    }
    for (const v of message.nodeAllocations) {
      ReportSummary_SoleTenantNodeAllocation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_SoleTenantFinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_SoleTenantFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allocatedRegions.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeAllocations.push(ReportSummary_SoleTenantNodeAllocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_SoleTenantFinding {
    return {
      allocatedRegions: globalThis.Array.isArray(object?.allocatedRegions)
        ? object.allocatedRegions.map((e: any) => globalThis.String(e))
        : [],
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
      nodeAllocations: globalThis.Array.isArray(object?.nodeAllocations)
        ? object.nodeAllocations.map((e: any) => ReportSummary_SoleTenantNodeAllocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_SoleTenantFinding): unknown {
    const obj: any = {};
    if (message.allocatedRegions?.length) {
      obj.allocatedRegions = message.allocatedRegions;
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    if (message.nodeAllocations?.length) {
      obj.nodeAllocations = message.nodeAllocations.map((e) => ReportSummary_SoleTenantNodeAllocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_SoleTenantFinding>): ReportSummary_SoleTenantFinding {
    return ReportSummary_SoleTenantFinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_SoleTenantFinding>): ReportSummary_SoleTenantFinding {
    const message = createBaseReportSummary_SoleTenantFinding();
    message.allocatedRegions = object.allocatedRegions?.map((e) => e) || [];
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    message.nodeAllocations =
      object.nodeAllocations?.map((e) => ReportSummary_SoleTenantNodeAllocation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReportSummary_SoleTenantNodeAllocation(): ReportSummary_SoleTenantNodeAllocation {
  return { node: undefined, nodeCount: Long.ZERO, allocatedAssetCount: Long.ZERO };
}

export const ReportSummary_SoleTenantNodeAllocation: MessageFns<ReportSummary_SoleTenantNodeAllocation> = {
  encode(message: ReportSummary_SoleTenantNodeAllocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.node !== undefined) {
      SoleTenantNodeType.encode(message.node, writer.uint32(10).fork()).join();
    }
    if (!message.nodeCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.nodeCount.toString());
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.allocatedAssetCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_SoleTenantNodeAllocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_SoleTenantNodeAllocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.node = SoleTenantNodeType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allocatedAssetCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_SoleTenantNodeAllocation {
    return {
      node: isSet(object.node) ? SoleTenantNodeType.fromJSON(object.node) : undefined,
      nodeCount: isSet(object.nodeCount) ? Long.fromValue(object.nodeCount) : Long.ZERO,
      allocatedAssetCount: isSet(object.allocatedAssetCount) ? Long.fromValue(object.allocatedAssetCount) : Long.ZERO,
    };
  },

  toJSON(message: ReportSummary_SoleTenantNodeAllocation): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = SoleTenantNodeType.toJSON(message.node);
    }
    if (!message.nodeCount.equals(Long.ZERO)) {
      obj.nodeCount = (message.nodeCount || Long.ZERO).toString();
    }
    if (!message.allocatedAssetCount.equals(Long.ZERO)) {
      obj.allocatedAssetCount = (message.allocatedAssetCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_SoleTenantNodeAllocation>): ReportSummary_SoleTenantNodeAllocation {
    return ReportSummary_SoleTenantNodeAllocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_SoleTenantNodeAllocation>): ReportSummary_SoleTenantNodeAllocation {
    const message = createBaseReportSummary_SoleTenantNodeAllocation();
    message.node = (object.node !== undefined && object.node !== null)
      ? SoleTenantNodeType.fromPartial(object.node)
      : undefined;
    message.nodeCount = (object.nodeCount !== undefined && object.nodeCount !== null)
      ? Long.fromValue(object.nodeCount)
      : Long.ZERO;
    message.allocatedAssetCount = (object.allocatedAssetCount !== undefined && object.allocatedAssetCount !== null)
      ? Long.fromValue(object.allocatedAssetCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseReportSummary_GroupPreferenceSetFinding(): ReportSummary_GroupPreferenceSetFinding {
  return {
    displayName: "",
    description: "",
    machinePreferences: undefined,
    monthlyCostTotal: undefined,
    monthlyCostCompute: undefined,
    monthlyCostOsLicense: undefined,
    monthlyCostNetworkEgress: undefined,
    monthlyCostStorage: undefined,
    monthlyCostOther: undefined,
    computeEngineFinding: undefined,
    vmwareEngineFinding: undefined,
    soleTenantFinding: undefined,
  };
}

export const ReportSummary_GroupPreferenceSetFinding: MessageFns<ReportSummary_GroupPreferenceSetFinding> = {
  encode(message: ReportSummary_GroupPreferenceSetFinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.machinePreferences !== undefined) {
      VirtualMachinePreferences.encode(message.machinePreferences, writer.uint32(26).fork()).join();
    }
    if (message.monthlyCostTotal !== undefined) {
      Money.encode(message.monthlyCostTotal, writer.uint32(34).fork()).join();
    }
    if (message.monthlyCostCompute !== undefined) {
      Money.encode(message.monthlyCostCompute, writer.uint32(42).fork()).join();
    }
    if (message.monthlyCostOsLicense !== undefined) {
      Money.encode(message.monthlyCostOsLicense, writer.uint32(50).fork()).join();
    }
    if (message.monthlyCostNetworkEgress !== undefined) {
      Money.encode(message.monthlyCostNetworkEgress, writer.uint32(58).fork()).join();
    }
    if (message.monthlyCostStorage !== undefined) {
      Money.encode(message.monthlyCostStorage, writer.uint32(66).fork()).join();
    }
    if (message.monthlyCostOther !== undefined) {
      Money.encode(message.monthlyCostOther, writer.uint32(74).fork()).join();
    }
    if (message.computeEngineFinding !== undefined) {
      ReportSummary_ComputeEngineFinding.encode(message.computeEngineFinding, writer.uint32(82).fork()).join();
    }
    if (message.vmwareEngineFinding !== undefined) {
      ReportSummary_VmwareEngineFinding.encode(message.vmwareEngineFinding, writer.uint32(90).fork()).join();
    }
    if (message.soleTenantFinding !== undefined) {
      ReportSummary_SoleTenantFinding.encode(message.soleTenantFinding, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_GroupPreferenceSetFinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_GroupPreferenceSetFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machinePreferences = VirtualMachinePreferences.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monthlyCostTotal = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.monthlyCostCompute = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.monthlyCostOsLicense = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.monthlyCostNetworkEgress = Money.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.monthlyCostStorage = Money.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.monthlyCostOther = Money.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.computeEngineFinding = ReportSummary_ComputeEngineFinding.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.vmwareEngineFinding = ReportSummary_VmwareEngineFinding.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.soleTenantFinding = ReportSummary_SoleTenantFinding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_GroupPreferenceSetFinding {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      machinePreferences: isSet(object.machinePreferences)
        ? VirtualMachinePreferences.fromJSON(object.machinePreferences)
        : undefined,
      monthlyCostTotal: isSet(object.monthlyCostTotal) ? Money.fromJSON(object.monthlyCostTotal) : undefined,
      monthlyCostCompute: isSet(object.monthlyCostCompute) ? Money.fromJSON(object.monthlyCostCompute) : undefined,
      monthlyCostOsLicense: isSet(object.monthlyCostOsLicense)
        ? Money.fromJSON(object.monthlyCostOsLicense)
        : undefined,
      monthlyCostNetworkEgress: isSet(object.monthlyCostNetworkEgress)
        ? Money.fromJSON(object.monthlyCostNetworkEgress)
        : undefined,
      monthlyCostStorage: isSet(object.monthlyCostStorage) ? Money.fromJSON(object.monthlyCostStorage) : undefined,
      monthlyCostOther: isSet(object.monthlyCostOther) ? Money.fromJSON(object.monthlyCostOther) : undefined,
      computeEngineFinding: isSet(object.computeEngineFinding)
        ? ReportSummary_ComputeEngineFinding.fromJSON(object.computeEngineFinding)
        : undefined,
      vmwareEngineFinding: isSet(object.vmwareEngineFinding)
        ? ReportSummary_VmwareEngineFinding.fromJSON(object.vmwareEngineFinding)
        : undefined,
      soleTenantFinding: isSet(object.soleTenantFinding)
        ? ReportSummary_SoleTenantFinding.fromJSON(object.soleTenantFinding)
        : undefined,
    };
  },

  toJSON(message: ReportSummary_GroupPreferenceSetFinding): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.machinePreferences !== undefined) {
      obj.machinePreferences = VirtualMachinePreferences.toJSON(message.machinePreferences);
    }
    if (message.monthlyCostTotal !== undefined) {
      obj.monthlyCostTotal = Money.toJSON(message.monthlyCostTotal);
    }
    if (message.monthlyCostCompute !== undefined) {
      obj.monthlyCostCompute = Money.toJSON(message.monthlyCostCompute);
    }
    if (message.monthlyCostOsLicense !== undefined) {
      obj.monthlyCostOsLicense = Money.toJSON(message.monthlyCostOsLicense);
    }
    if (message.monthlyCostNetworkEgress !== undefined) {
      obj.monthlyCostNetworkEgress = Money.toJSON(message.monthlyCostNetworkEgress);
    }
    if (message.monthlyCostStorage !== undefined) {
      obj.monthlyCostStorage = Money.toJSON(message.monthlyCostStorage);
    }
    if (message.monthlyCostOther !== undefined) {
      obj.monthlyCostOther = Money.toJSON(message.monthlyCostOther);
    }
    if (message.computeEngineFinding !== undefined) {
      obj.computeEngineFinding = ReportSummary_ComputeEngineFinding.toJSON(message.computeEngineFinding);
    }
    if (message.vmwareEngineFinding !== undefined) {
      obj.vmwareEngineFinding = ReportSummary_VmwareEngineFinding.toJSON(message.vmwareEngineFinding);
    }
    if (message.soleTenantFinding !== undefined) {
      obj.soleTenantFinding = ReportSummary_SoleTenantFinding.toJSON(message.soleTenantFinding);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_GroupPreferenceSetFinding>): ReportSummary_GroupPreferenceSetFinding {
    return ReportSummary_GroupPreferenceSetFinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_GroupPreferenceSetFinding>): ReportSummary_GroupPreferenceSetFinding {
    const message = createBaseReportSummary_GroupPreferenceSetFinding();
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.machinePreferences = (object.machinePreferences !== undefined && object.machinePreferences !== null)
      ? VirtualMachinePreferences.fromPartial(object.machinePreferences)
      : undefined;
    message.monthlyCostTotal = (object.monthlyCostTotal !== undefined && object.monthlyCostTotal !== null)
      ? Money.fromPartial(object.monthlyCostTotal)
      : undefined;
    message.monthlyCostCompute = (object.monthlyCostCompute !== undefined && object.monthlyCostCompute !== null)
      ? Money.fromPartial(object.monthlyCostCompute)
      : undefined;
    message.monthlyCostOsLicense = (object.monthlyCostOsLicense !== undefined && object.monthlyCostOsLicense !== null)
      ? Money.fromPartial(object.monthlyCostOsLicense)
      : undefined;
    message.monthlyCostNetworkEgress =
      (object.monthlyCostNetworkEgress !== undefined && object.monthlyCostNetworkEgress !== null)
        ? Money.fromPartial(object.monthlyCostNetworkEgress)
        : undefined;
    message.monthlyCostStorage = (object.monthlyCostStorage !== undefined && object.monthlyCostStorage !== null)
      ? Money.fromPartial(object.monthlyCostStorage)
      : undefined;
    message.monthlyCostOther = (object.monthlyCostOther !== undefined && object.monthlyCostOther !== null)
      ? Money.fromPartial(object.monthlyCostOther)
      : undefined;
    message.computeEngineFinding = (object.computeEngineFinding !== undefined && object.computeEngineFinding !== null)
      ? ReportSummary_ComputeEngineFinding.fromPartial(object.computeEngineFinding)
      : undefined;
    message.vmwareEngineFinding = (object.vmwareEngineFinding !== undefined && object.vmwareEngineFinding !== null)
      ? ReportSummary_VmwareEngineFinding.fromPartial(object.vmwareEngineFinding)
      : undefined;
    message.soleTenantFinding = (object.soleTenantFinding !== undefined && object.soleTenantFinding !== null)
      ? ReportSummary_SoleTenantFinding.fromPartial(object.soleTenantFinding)
      : undefined;
    return message;
  },
};

function createBaseReportSummary_GroupFinding(): ReportSummary_GroupFinding {
  return {
    displayName: "",
    description: "",
    assetAggregateStats: undefined,
    overlappingAssetCount: Long.ZERO,
    preferenceSetFindings: [],
  };
}

export const ReportSummary_GroupFinding: MessageFns<ReportSummary_GroupFinding> = {
  encode(message: ReportSummary_GroupFinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.assetAggregateStats !== undefined) {
      ReportSummary_AssetAggregateStats.encode(message.assetAggregateStats, writer.uint32(26).fork()).join();
    }
    if (!message.overlappingAssetCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.overlappingAssetCount.toString());
    }
    for (const v of message.preferenceSetFindings) {
      ReportSummary_GroupPreferenceSetFinding.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportSummary_GroupFinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportSummary_GroupFinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetAggregateStats = ReportSummary_AssetAggregateStats.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.overlappingAssetCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.preferenceSetFindings.push(ReportSummary_GroupPreferenceSetFinding.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportSummary_GroupFinding {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      assetAggregateStats: isSet(object.assetAggregateStats)
        ? ReportSummary_AssetAggregateStats.fromJSON(object.assetAggregateStats)
        : undefined,
      overlappingAssetCount: isSet(object.overlappingAssetCount)
        ? Long.fromValue(object.overlappingAssetCount)
        : Long.ZERO,
      preferenceSetFindings: globalThis.Array.isArray(object?.preferenceSetFindings)
        ? object.preferenceSetFindings.map((e: any) => ReportSummary_GroupPreferenceSetFinding.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReportSummary_GroupFinding): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.assetAggregateStats !== undefined) {
      obj.assetAggregateStats = ReportSummary_AssetAggregateStats.toJSON(message.assetAggregateStats);
    }
    if (!message.overlappingAssetCount.equals(Long.ZERO)) {
      obj.overlappingAssetCount = (message.overlappingAssetCount || Long.ZERO).toString();
    }
    if (message.preferenceSetFindings?.length) {
      obj.preferenceSetFindings = message.preferenceSetFindings.map((e) =>
        ReportSummary_GroupPreferenceSetFinding.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ReportSummary_GroupFinding>): ReportSummary_GroupFinding {
    return ReportSummary_GroupFinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportSummary_GroupFinding>): ReportSummary_GroupFinding {
    const message = createBaseReportSummary_GroupFinding();
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.assetAggregateStats = (object.assetAggregateStats !== undefined && object.assetAggregateStats !== null)
      ? ReportSummary_AssetAggregateStats.fromPartial(object.assetAggregateStats)
      : undefined;
    message.overlappingAssetCount =
      (object.overlappingAssetCount !== undefined && object.overlappingAssetCount !== null)
        ? Long.fromValue(object.overlappingAssetCount)
        : Long.ZERO;
    message.preferenceSetFindings =
      object.preferenceSetFindings?.map((e) => ReportSummary_GroupPreferenceSetFinding.fromPartial(e)) || [];
    return message;
  },
};

/** Service describing handlers for resources. */
export type MigrationCenterDefinition = typeof MigrationCenterDefinition;
export const MigrationCenterDefinition = {
  name: "MigrationCenter",
  fullName: "google.cloud.migrationcenter.v1.MigrationCenter",
  methods: {
    /** Lists all the assets in a given project and location. */
    listAssets: {
      name: "ListAssets",
      requestType: ListAssetsRequest,
      requestStream: false,
      responseType: ListAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of an asset. */
    getAsset: {
      name: "GetAsset",
      requestType: GetAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of an asset. */
    updateAsset: {
      name: "UpdateAsset",
      requestType: UpdateAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 97, 115, 115, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              50,
              48,
              47,
              118,
              49,
              47,
              123,
              97,
              115,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a list of assets. */
    batchUpdateAssets: {
      name: "BatchUpdateAssets",
      requestType: BatchUpdateAssetsRequest,
      requestStream: false,
      responseType: BatchUpdateAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 114, 101, 113, 117, 101, 115, 116, 115])],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Deletes an asset. */
    deleteAsset: {
      name: "DeleteAsset",
      requestType: DeleteAssetRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes list of Assets. */
    batchDeleteAssets: {
      name: "BatchDeleteAssets",
      requestType: BatchDeleteAssetsRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 110, 97, 109, 101, 115])],
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Reports a set of frames. */
    reportAssetFrames: {
      name: "ReportAssetFrames",
      requestType: ReportAssetFramesRequest,
      requestStream: false,
      responseType: ReportAssetFramesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              70,
              58,
              6,
              102,
              114,
              97,
              109,
              101,
              115,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              114,
              101,
              112,
              111,
              114,
              116,
              65,
              115,
              115,
              101,
              116,
              70,
              114,
              97,
              109,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Aggregates the requested fields based on provided function. */
    aggregateAssetsValues: {
      name: "AggregateAssetsValues",
      requestType: AggregateAssetsValuesRequest,
      requestStream: false,
      responseType: AggregateAssetsValuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              58,
              97,
              103,
              103,
              114,
              101,
              103,
              97,
              116,
              101,
              86,
              97,
              108,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates an import job. */
    createImportJob: {
      name: "CreateImportJob",
      requestType: CreateImportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              73,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              10,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all import jobs. */
    listImportJobs: {
      name: "ListImportJobs",
      requestType: ListImportJobsRequest,
      requestStream: false,
      responseType: ListImportJobsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of an import job. */
    getImportJob: {
      name: "GetImportJob",
      requestType: GetImportJobRequest,
      requestStream: false,
      responseType: ImportJob,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes an import job. */
    deleteImportJob: {
      name: "DeleteImportJob",
      requestType: DeleteImportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates an import job. */
    updateImportJob: {
      name: "UpdateImportJob",
      requestType: UpdateImportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              73,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              22,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              10,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              50,
              57,
              47,
              118,
              49,
              47,
              123,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Validates an import job. */
    validateImportJob: {
      name: "ValidateImportJob",
      requestType: ValidateImportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              58,
              1,
              42,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Runs an import job. */
    runImportJob: {
      name: "RunImportJob",
      requestType: RunImportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
    /** Gets an import data file. */
    getImportDataFile: {
      name: "GetImportDataFile",
      requestType: GetImportDataFileRequest,
      requestStream: false,
      responseType: ImportDataFile,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              68,
              97,
              116,
              97,
              70,
              105,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** List import data files. */
    listImportDataFiles: {
      name: "ListImportDataFiles",
      requestType: ListImportDataFilesRequest,
      requestStream: false,
      responseType: ListImportDataFilesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              68,
              97,
              116,
              97,
              70,
              105,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates an import data file. */
    createImportDataFile: {
      name: "CreateImportDataFile",
      requestType: CreateImportDataFileRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              73,
              109,
              112,
              111,
              114,
              116,
              68,
              97,
              116,
              97,
              70,
              105,
              108,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              43,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              100,
              97,
              116,
              97,
              95,
              102,
              105,
              108,
              101,
              44,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              100,
              97,
              116,
              97,
              95,
              102,
              105,
              108,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              16,
              105,
              109,
              112,
              111,
              114,
              116,
              95,
              100,
              97,
              116,
              97,
              95,
              102,
              105,
              108,
              101,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              68,
              97,
              116,
              97,
              70,
              105,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Delete an import data file. */
    deleteImportDataFile: {
      name: "DeleteImportDataFile",
      requestType: DeleteImportDataFileRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              66,
              42,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              47,
              105,
              109,
              112,
              111,
              114,
              116,
              68,
              97,
              116,
              97,
              70,
              105,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all groups in a given project and location. */
    listGroups: {
      name: "ListGroups",
      requestType: ListGroupsRequest,
      requestStream: false,
      responseType: ListGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a group. */
    getGroup: {
      name: "GetGroup",
      requestType: GetGroupRequest,
      requestStream: false,
      responseType: Group,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new group in a given project and location. */
    createGroup: {
      name: "CreateGroup",
      requestType: CreateGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              103,
              114,
              111,
              117,
              112,
              44,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a group. */
    updateGroup: {
      name: "UpdateGroup",
      requestType: UpdateGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 103, 114, 111, 117, 112, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              50,
              48,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a group. */
    deleteGroup: {
      name: "DeleteGroup",
      requestType: DeleteGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Adds assets to a group. */
    addAssetsToGroup: {
      name: "AddAssetsToGroup",
      requestType: AddAssetsToGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([5, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              58,
              97,
              100,
              100,
              65,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Removes assets from a group. */
    removeAssetsFromGroup: {
      name: "RemoveAssetsFromGroup",
      requestType: RemoveAssetsFromGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([5, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
              65,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all error frames in a given source and location. */
    listErrorFrames: {
      name: "ListErrorFrames",
      requestType: ListErrorFramesRequest,
      requestStream: false,
      responseType: ListErrorFramesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              101,
              114,
              114,
              111,
              114,
              70,
              114,
              97,
              109,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of an error frame. */
    getErrorFrame: {
      name: "GetErrorFrame",
      requestType: GetErrorFrameRequest,
      requestStream: false,
      responseType: ErrorFrame,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              47,
              101,
              114,
              114,
              111,
              114,
              70,
              114,
              97,
              109,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all the sources in a given project and location. */
    listSources: {
      name: "ListSources",
      requestType: ListSourcesRequest,
      requestStream: false,
      responseType: ListSourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a source. */
    getSource: {
      name: "GetSource",
      requestType: GetSourceRequest,
      requestStream: false,
      responseType: Source,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new source in a given project and location. */
    createSource: {
      name: "CreateSource",
      requestType: CreateSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              115,
              111,
              117,
              114,
              99,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a source. */
    updateSource: {
      name: "UpdateSource",
      requestType: UpdateSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 115, 111, 117, 114, 99, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              6,
              115,
              111,
              117,
              114,
              99,
              101,
              50,
              50,
              47,
              118,
              49,
              47,
              123,
              115,
              111,
              117,
              114,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a source. */
    deleteSource: {
      name: "DeleteSource",
      requestType: DeleteSourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all the preference sets in a given project and location. */
    listPreferenceSets: {
      name: "ListPreferenceSets",
      requestType: ListPreferenceSetsRequest,
      requestStream: false,
      responseType: ListPreferenceSetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a preference set. */
    getPreferenceSet: {
      name: "GetPreferenceSet",
      requestType: GetPreferenceSetRequest,
      requestStream: false,
      responseType: PreferenceSet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new preference set in a given project and location. */
    createPreferenceSet: {
      name: "CreatePreferenceSet",
      requestType: CreatePreferenceSetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              80,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              44,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              14,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a preference set. */
    updatePreferenceSet: {
      name: "UpdatePreferenceSet",
      requestType: UpdatePreferenceSetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              80,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              14,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              50,
              65,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              95,
              115,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a preference set. */
    deletePreferenceSet: {
      name: "DeletePreferenceSet",
      requestType: DeletePreferenceSetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              101,
              102,
              101,
              114,
              101,
              110,
              99,
              101,
              83,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets the details of regional settings. */
    getSettings: {
      name: "GetSettings",
      requestType: GetSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the regional-level project settings. */
    updateSettings: {
      name: "UpdateSettings",
      requestType: UpdateSettingsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              29,
              10,
              8,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              20,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              51,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a report configuration. */
    createReportConfig: {
      name: "CreateReportConfig",
      requestType: CreateReportConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              37,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              44,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              13,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
              34,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single ReportConfig. */
    getReportConfig: {
      name: "GetReportConfig",
      requestType: GetReportConfigRequest,
      requestStream: false,
      responseType: ReportConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists ReportConfigs in a given project and location. */
    listReportConfigs: {
      name: "ListReportConfigs",
      requestType: ListReportConfigsRequest,
      requestStream: false,
      responseType: ListReportConfigsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a ReportConfig. */
    deleteReportConfig: {
      name: "DeleteReportConfig",
      requestType: DeleteReportConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              42,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a report. */
    createReport: {
      name: "CreateReport",
      requestType: CreateReportRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              82,
              101,
              112,
              111,
              114,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              112,
              111,
              114,
              116,
              44,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              6,
              114,
              101,
              112,
              111,
              114,
              116,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Report. */
    getReport: {
      name: "GetReport",
      requestType: GetReportRequest,
      requestStream: false,
      responseType: Report,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Reports in a given ReportConfig. */
    listReports: {
      name: "ListReports",
      requestType: ListReportsRequest,
      requestStream: false,
      responseType: ListReportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a Report. */
    deleteReport: {
      name: "DeleteReport",
      requestType: DeleteReportRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              42,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface MigrationCenterServiceImplementation<CallContextExt = {}> {
  /** Lists all the assets in a given project and location. */
  listAssets(
    request: ListAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssetsResponse>>;
  /** Gets the details of an asset. */
  getAsset(request: GetAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Updates the parameters of an asset. */
  updateAsset(request: UpdateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Updates the parameters of a list of assets. */
  batchUpdateAssets(
    request: BatchUpdateAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchUpdateAssetsResponse>>;
  /** Deletes an asset. */
  deleteAsset(request: DeleteAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes list of Assets. */
  batchDeleteAssets(
    request: BatchDeleteAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Reports a set of frames. */
  reportAssetFrames(
    request: ReportAssetFramesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReportAssetFramesResponse>>;
  /** Aggregates the requested fields based on provided function. */
  aggregateAssetsValues(
    request: AggregateAssetsValuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AggregateAssetsValuesResponse>>;
  /** Creates an import job. */
  createImportJob(
    request: CreateImportJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists all import jobs. */
  listImportJobs(
    request: ListImportJobsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListImportJobsResponse>>;
  /** Gets the details of an import job. */
  getImportJob(request: GetImportJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ImportJob>>;
  /** Deletes an import job. */
  deleteImportJob(
    request: DeleteImportJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates an import job. */
  updateImportJob(
    request: UpdateImportJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Validates an import job. */
  validateImportJob(
    request: ValidateImportJobRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Runs an import job. */
  runImportJob(request: RunImportJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets an import data file. */
  getImportDataFile(
    request: GetImportDataFileRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ImportDataFile>>;
  /** List import data files. */
  listImportDataFiles(
    request: ListImportDataFilesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListImportDataFilesResponse>>;
  /** Creates an import data file. */
  createImportDataFile(
    request: CreateImportDataFileRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Delete an import data file. */
  deleteImportDataFile(
    request: DeleteImportDataFileRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists all groups in a given project and location. */
  listGroups(
    request: ListGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGroupsResponse>>;
  /** Gets the details of a group. */
  getGroup(request: GetGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Group>>;
  /** Creates a new group in a given project and location. */
  createGroup(request: CreateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a group. */
  updateGroup(request: UpdateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a group. */
  deleteGroup(request: DeleteGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Adds assets to a group. */
  addAssetsToGroup(
    request: AddAssetsToGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Removes assets from a group. */
  removeAssetsFromGroup(
    request: RemoveAssetsFromGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists all error frames in a given source and location. */
  listErrorFrames(
    request: ListErrorFramesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListErrorFramesResponse>>;
  /** Gets the details of an error frame. */
  getErrorFrame(request: GetErrorFrameRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ErrorFrame>>;
  /** Lists all the sources in a given project and location. */
  listSources(
    request: ListSourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSourcesResponse>>;
  /** Gets the details of a source. */
  getSource(request: GetSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Source>>;
  /** Creates a new source in a given project and location. */
  createSource(request: CreateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a source. */
  updateSource(request: UpdateSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a source. */
  deleteSource(request: DeleteSourceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists all the preference sets in a given project and location. */
  listPreferenceSets(
    request: ListPreferenceSetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPreferenceSetsResponse>>;
  /** Gets the details of a preference set. */
  getPreferenceSet(
    request: GetPreferenceSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PreferenceSet>>;
  /** Creates a new preference set in a given project and location. */
  createPreferenceSet(
    request: CreatePreferenceSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a preference set. */
  updatePreferenceSet(
    request: UpdatePreferenceSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a preference set. */
  deletePreferenceSet(
    request: DeletePreferenceSetRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets the details of regional settings. */
  getSettings(request: GetSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
  /** Updates the regional-level project settings. */
  updateSettings(
    request: UpdateSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a report configuration. */
  createReportConfig(
    request: CreateReportConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets details of a single ReportConfig. */
  getReportConfig(
    request: GetReportConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ReportConfig>>;
  /** Lists ReportConfigs in a given project and location. */
  listReportConfigs(
    request: ListReportConfigsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReportConfigsResponse>>;
  /** Deletes a ReportConfig. */
  deleteReportConfig(
    request: DeleteReportConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a report. */
  createReport(request: CreateReportRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Gets details of a single Report. */
  getReport(request: GetReportRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Report>>;
  /** Lists Reports in a given ReportConfig. */
  listReports(
    request: ListReportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReportsResponse>>;
  /** Deletes a Report. */
  deleteReport(request: DeleteReportRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface MigrationCenterClient<CallOptionsExt = {}> {
  /** Lists all the assets in a given project and location. */
  listAssets(
    request: DeepPartial<ListAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssetsResponse>;
  /** Gets the details of an asset. */
  getAsset(request: DeepPartial<GetAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Updates the parameters of an asset. */
  updateAsset(request: DeepPartial<UpdateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Updates the parameters of a list of assets. */
  batchUpdateAssets(
    request: DeepPartial<BatchUpdateAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchUpdateAssetsResponse>;
  /** Deletes an asset. */
  deleteAsset(request: DeepPartial<DeleteAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes list of Assets. */
  batchDeleteAssets(
    request: DeepPartial<BatchDeleteAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Reports a set of frames. */
  reportAssetFrames(
    request: DeepPartial<ReportAssetFramesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReportAssetFramesResponse>;
  /** Aggregates the requested fields based on provided function. */
  aggregateAssetsValues(
    request: DeepPartial<AggregateAssetsValuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AggregateAssetsValuesResponse>;
  /** Creates an import job. */
  createImportJob(
    request: DeepPartial<CreateImportJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists all import jobs. */
  listImportJobs(
    request: DeepPartial<ListImportJobsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListImportJobsResponse>;
  /** Gets the details of an import job. */
  getImportJob(request: DeepPartial<GetImportJobRequest>, options?: CallOptions & CallOptionsExt): Promise<ImportJob>;
  /** Deletes an import job. */
  deleteImportJob(
    request: DeepPartial<DeleteImportJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates an import job. */
  updateImportJob(
    request: DeepPartial<UpdateImportJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Validates an import job. */
  validateImportJob(
    request: DeepPartial<ValidateImportJobRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Runs an import job. */
  runImportJob(request: DeepPartial<RunImportJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets an import data file. */
  getImportDataFile(
    request: DeepPartial<GetImportDataFileRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ImportDataFile>;
  /** List import data files. */
  listImportDataFiles(
    request: DeepPartial<ListImportDataFilesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListImportDataFilesResponse>;
  /** Creates an import data file. */
  createImportDataFile(
    request: DeepPartial<CreateImportDataFileRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Delete an import data file. */
  deleteImportDataFile(
    request: DeepPartial<DeleteImportDataFileRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists all groups in a given project and location. */
  listGroups(
    request: DeepPartial<ListGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGroupsResponse>;
  /** Gets the details of a group. */
  getGroup(request: DeepPartial<GetGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Group>;
  /** Creates a new group in a given project and location. */
  createGroup(request: DeepPartial<CreateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a group. */
  updateGroup(request: DeepPartial<UpdateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a group. */
  deleteGroup(request: DeepPartial<DeleteGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Adds assets to a group. */
  addAssetsToGroup(
    request: DeepPartial<AddAssetsToGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Removes assets from a group. */
  removeAssetsFromGroup(
    request: DeepPartial<RemoveAssetsFromGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists all error frames in a given source and location. */
  listErrorFrames(
    request: DeepPartial<ListErrorFramesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListErrorFramesResponse>;
  /** Gets the details of an error frame. */
  getErrorFrame(
    request: DeepPartial<GetErrorFrameRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ErrorFrame>;
  /** Lists all the sources in a given project and location. */
  listSources(
    request: DeepPartial<ListSourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSourcesResponse>;
  /** Gets the details of a source. */
  getSource(request: DeepPartial<GetSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Source>;
  /** Creates a new source in a given project and location. */
  createSource(request: DeepPartial<CreateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a source. */
  updateSource(request: DeepPartial<UpdateSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a source. */
  deleteSource(request: DeepPartial<DeleteSourceRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists all the preference sets in a given project and location. */
  listPreferenceSets(
    request: DeepPartial<ListPreferenceSetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPreferenceSetsResponse>;
  /** Gets the details of a preference set. */
  getPreferenceSet(
    request: DeepPartial<GetPreferenceSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PreferenceSet>;
  /** Creates a new preference set in a given project and location. */
  createPreferenceSet(
    request: DeepPartial<CreatePreferenceSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a preference set. */
  updatePreferenceSet(
    request: DeepPartial<UpdatePreferenceSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a preference set. */
  deletePreferenceSet(
    request: DeepPartial<DeletePreferenceSetRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets the details of regional settings. */
  getSettings(request: DeepPartial<GetSettingsRequest>, options?: CallOptions & CallOptionsExt): Promise<Settings>;
  /** Updates the regional-level project settings. */
  updateSettings(
    request: DeepPartial<UpdateSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a report configuration. */
  createReportConfig(
    request: DeepPartial<CreateReportConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets details of a single ReportConfig. */
  getReportConfig(
    request: DeepPartial<GetReportConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReportConfig>;
  /** Lists ReportConfigs in a given project and location. */
  listReportConfigs(
    request: DeepPartial<ListReportConfigsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReportConfigsResponse>;
  /** Deletes a ReportConfig. */
  deleteReportConfig(
    request: DeepPartial<DeleteReportConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a report. */
  createReport(request: DeepPartial<CreateReportRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Gets details of a single Report. */
  getReport(request: DeepPartial<GetReportRequest>, options?: CallOptions & CallOptionsExt): Promise<Report>;
  /** Lists Reports in a given ReportConfig. */
  listReports(
    request: DeepPartial<ListReportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReportsResponse>;
  /** Deletes a Report. */
  deleteReport(request: DeepPartial<DeleteReportRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
