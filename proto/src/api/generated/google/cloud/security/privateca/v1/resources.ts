// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/security/privateca/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Expr } from "../../../../type/expr.js";

export const protobufPackage = "google.cloud.security.privateca.v1";

/**
 * A [RevocationReason][google.cloud.security.privateca.v1.RevocationReason]
 * indicates whether a
 * [Certificate][google.cloud.security.privateca.v1.Certificate] has been
 * revoked, and the reason for revocation. These correspond to standard
 * revocation reasons from RFC 5280. Note that the enum labels and values in
 * this definition are not the same ASN.1 values defined in RFC 5280. These
 * values will be translated to the correct ASN.1 values when a CRL is created.
 */
export enum RevocationReason {
  /**
   * REVOCATION_REASON_UNSPECIFIED - Default unspecified value. This value does indicate that a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] has been
   * revoked, but that a reason has not been recorded.
   */
  REVOCATION_REASON_UNSPECIFIED = 0,
  /**
   * KEY_COMPROMISE - Key material for this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] may have
   * leaked.
   */
  KEY_COMPROMISE = 1,
  /**
   * CERTIFICATE_AUTHORITY_COMPROMISE - The key material for a certificate authority in the issuing path may have
   * leaked.
   */
  CERTIFICATE_AUTHORITY_COMPROMISE = 2,
  /**
   * AFFILIATION_CHANGED - The subject or other attributes in this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] have changed.
   */
  AFFILIATION_CHANGED = 3,
  /**
   * SUPERSEDED - This [Certificate][google.cloud.security.privateca.v1.Certificate] has been
   * superseded.
   */
  SUPERSEDED = 4,
  /**
   * CESSATION_OF_OPERATION - This [Certificate][google.cloud.security.privateca.v1.Certificate] or
   * entities in the issuing path have ceased to operate.
   */
  CESSATION_OF_OPERATION = 5,
  /**
   * CERTIFICATE_HOLD - This [Certificate][google.cloud.security.privateca.v1.Certificate] should
   * not be considered valid, it is expected that it may become valid in the
   * future.
   */
  CERTIFICATE_HOLD = 6,
  /**
   * PRIVILEGE_WITHDRAWN - This [Certificate][google.cloud.security.privateca.v1.Certificate] no
   * longer has permission to assert the listed attributes.
   */
  PRIVILEGE_WITHDRAWN = 7,
  /**
   * ATTRIBUTE_AUTHORITY_COMPROMISE - The authority which determines appropriate attributes for a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] may have been
   * compromised.
   */
  ATTRIBUTE_AUTHORITY_COMPROMISE = 8,
  UNRECOGNIZED = -1,
}

export function revocationReasonFromJSON(object: any): RevocationReason {
  switch (object) {
    case 0:
    case "REVOCATION_REASON_UNSPECIFIED":
      return RevocationReason.REVOCATION_REASON_UNSPECIFIED;
    case 1:
    case "KEY_COMPROMISE":
      return RevocationReason.KEY_COMPROMISE;
    case 2:
    case "CERTIFICATE_AUTHORITY_COMPROMISE":
      return RevocationReason.CERTIFICATE_AUTHORITY_COMPROMISE;
    case 3:
    case "AFFILIATION_CHANGED":
      return RevocationReason.AFFILIATION_CHANGED;
    case 4:
    case "SUPERSEDED":
      return RevocationReason.SUPERSEDED;
    case 5:
    case "CESSATION_OF_OPERATION":
      return RevocationReason.CESSATION_OF_OPERATION;
    case 6:
    case "CERTIFICATE_HOLD":
      return RevocationReason.CERTIFICATE_HOLD;
    case 7:
    case "PRIVILEGE_WITHDRAWN":
      return RevocationReason.PRIVILEGE_WITHDRAWN;
    case 8:
    case "ATTRIBUTE_AUTHORITY_COMPROMISE":
      return RevocationReason.ATTRIBUTE_AUTHORITY_COMPROMISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RevocationReason.UNRECOGNIZED;
  }
}

export function revocationReasonToJSON(object: RevocationReason): string {
  switch (object) {
    case RevocationReason.REVOCATION_REASON_UNSPECIFIED:
      return "REVOCATION_REASON_UNSPECIFIED";
    case RevocationReason.KEY_COMPROMISE:
      return "KEY_COMPROMISE";
    case RevocationReason.CERTIFICATE_AUTHORITY_COMPROMISE:
      return "CERTIFICATE_AUTHORITY_COMPROMISE";
    case RevocationReason.AFFILIATION_CHANGED:
      return "AFFILIATION_CHANGED";
    case RevocationReason.SUPERSEDED:
      return "SUPERSEDED";
    case RevocationReason.CESSATION_OF_OPERATION:
      return "CESSATION_OF_OPERATION";
    case RevocationReason.CERTIFICATE_HOLD:
      return "CERTIFICATE_HOLD";
    case RevocationReason.PRIVILEGE_WITHDRAWN:
      return "PRIVILEGE_WITHDRAWN";
    case RevocationReason.ATTRIBUTE_AUTHORITY_COMPROMISE:
      return "ATTRIBUTE_AUTHORITY_COMPROMISE";
    case RevocationReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes the way in which a
 * [Certificate][google.cloud.security.privateca.v1.Certificate]'s
 * [Subject][google.cloud.security.privateca.v1.Subject] and/or
 * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will be
 * resolved.
 */
export enum SubjectRequestMode {
  /** SUBJECT_REQUEST_MODE_UNSPECIFIED - Not specified. */
  SUBJECT_REQUEST_MODE_UNSPECIFIED = 0,
  /**
   * DEFAULT - The default mode used in most cases. Indicates that the certificate's
   * [Subject][google.cloud.security.privateca.v1.Subject] and/or
   * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] are
   * specified in the certificate request. This mode requires the caller to have
   * the `privateca.certificates.create` permission.
   */
  DEFAULT = 1,
  /**
   * REFLECTED_SPIFFE - A mode reserved for special cases. Indicates that the certificate should
   * have one SPIFFE
   * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] set
   * by the service based on the caller's identity. This mode will ignore any
   * explicitly specified [Subject][google.cloud.security.privateca.v1.Subject]
   * and/or
   * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] in
   * the certificate request. This mode requires the caller to have the
   * `privateca.certificates.createForSelf` permission.
   */
  REFLECTED_SPIFFE = 2,
  UNRECOGNIZED = -1,
}

export function subjectRequestModeFromJSON(object: any): SubjectRequestMode {
  switch (object) {
    case 0:
    case "SUBJECT_REQUEST_MODE_UNSPECIFIED":
      return SubjectRequestMode.SUBJECT_REQUEST_MODE_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return SubjectRequestMode.DEFAULT;
    case 2:
    case "REFLECTED_SPIFFE":
      return SubjectRequestMode.REFLECTED_SPIFFE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubjectRequestMode.UNRECOGNIZED;
  }
}

export function subjectRequestModeToJSON(object: SubjectRequestMode): string {
  switch (object) {
    case SubjectRequestMode.SUBJECT_REQUEST_MODE_UNSPECIFIED:
      return "SUBJECT_REQUEST_MODE_UNSPECIFIED";
    case SubjectRequestMode.DEFAULT:
      return "DEFAULT";
    case SubjectRequestMode.REFLECTED_SPIFFE:
      return "REFLECTED_SPIFFE";
    case SubjectRequestMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * represents an individual Certificate Authority. A
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * can be used to create
 * [Certificates][google.cloud.security.privateca.v1.Certificate].
 */
export interface CertificateAuthority {
  /**
   * Output only. The resource name for this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * in the format `projects/* /locations/* /caPools/* /certificateAuthorities/*`.
   */
  name: string;
  /**
   * Required. Immutable. The
   * [Type][google.cloud.security.privateca.v1.CertificateAuthority.Type] of
   * this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
   */
  type: CertificateAuthority_Type;
  /**
   * Required. Immutable. The config used to create a self-signed X.509
   * certificate or CSR.
   */
  config:
    | CertificateConfig
    | undefined;
  /**
   * Required. Immutable. The desired lifetime of the CA certificate. Used to
   * create the "not_before_time" and "not_after_time" fields inside an X.509
   * certificate.
   */
  lifetime:
    | Duration
    | undefined;
  /**
   * Required. Immutable. Used when issuing certificates for this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
   * If this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * is a self-signed CertificateAuthority, this key is also used to sign the
   * self-signed CA certificate. Otherwise, it is used to sign a CSR.
   */
  keySpec:
    | CertificateAuthority_KeyVersionSpec
    | undefined;
  /**
   * Optional. If this is a subordinate
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
   * this field will be set with the subordinate configuration, which describes
   * its issuers. This may be updated, but this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * must continue to validate.
   */
  subordinateConfig:
    | SubordinateConfig
    | undefined;
  /**
   * Output only. The
   * [CaPool.Tier][google.cloud.security.privateca.v1.CaPool.Tier] of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool] that includes this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
   */
  tier: CaPool_Tier;
  /**
   * Output only. The
   * [State][google.cloud.security.privateca.v1.CertificateAuthority.State] for
   * this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
   */
  state: CertificateAuthority_State;
  /**
   * Output only. This
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * certificate chain, including the current
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * certificate. Ordered such that the root issuer is the final element
   * (consistent with RFC 5246). For a self-signed CA, this will only list the
   * current
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * certificate.
   */
  pemCaCertificates: string[];
  /**
   * Output only. A structured description of this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CA certificate and its issuers. Ordered as self-to-root.
   */
  caCertificateDescriptions: CertificateDescription[];
  /**
   * Immutable. The name of a Cloud Storage bucket where this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * will publish content, such as the CA certificate and CRLs. This must be a
   * bucket name, without any prefixes (such as `gs://`) or suffixes (such as
   * `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
   * would simply specify `my-bucket`. If not specified, a managed bucket will
   * be created.
   */
  gcsBucket: string;
  /**
   * Output only. URLs for accessing content published by this CA, such as the
   * CA certificate and CRLs.
   */
  accessUrls:
    | CertificateAuthority_AccessUrls
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * was last updated.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * was soft deleted, if it is in the
   * [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]
   * state.
   */
  deleteTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * will be permanently purged, if it is in the
   * [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]
   * state.
   */
  expireTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/**
 * The type of a
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
 * indicating its issuing chain.
 */
export enum CertificateAuthority_Type {
  /** TYPE_UNSPECIFIED - Not specified. */
  TYPE_UNSPECIFIED = 0,
  /** SELF_SIGNED - Self-signed CA. */
  SELF_SIGNED = 1,
  /**
   * SUBORDINATE - Subordinate CA. Could be issued by a Private CA
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * or an unmanaged CA.
   */
  SUBORDINATE = 2,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_TypeFromJSON(object: any): CertificateAuthority_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return CertificateAuthority_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SELF_SIGNED":
      return CertificateAuthority_Type.SELF_SIGNED;
    case 2:
    case "SUBORDINATE":
      return CertificateAuthority_Type.SUBORDINATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_Type.UNRECOGNIZED;
  }
}

export function certificateAuthority_TypeToJSON(object: CertificateAuthority_Type): string {
  switch (object) {
    case CertificateAuthority_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case CertificateAuthority_Type.SELF_SIGNED:
      return "SELF_SIGNED";
    case CertificateAuthority_Type.SUBORDINATE:
      return "SUBORDINATE";
    case CertificateAuthority_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The state of a
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
 * indicating if it can be used.
 */
export enum CertificateAuthority_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /**
   * ENABLED - Certificates can be issued from this CA. CRLs will be generated for this
   * CA. The CA will be part of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
   * will be used to issue certificates from the
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  ENABLED = 1,
  /**
   * DISABLED - Certificates cannot be issued from this CA. CRLs will still be generated.
   * The CA will be part of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but
   * will not be used to issue certificates from the
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  DISABLED = 2,
  /**
   * STAGED - Certificates can be issued from this CA. CRLs will be generated for this
   * CA. The CA will be part of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but
   * will not be used to issue certificates from the
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  STAGED = 3,
  /**
   * AWAITING_USER_ACTIVATION - Certificates cannot be issued from this CA. CRLs will not be generated.
   * The CA will not be part of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
   * will not be used to issue certificates from the
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  AWAITING_USER_ACTIVATION = 4,
  /**
   * DELETED - Certificates cannot be issued from this CA. CRLs will not be generated.
   * The CA may still be recovered by calling
   * [CertificateAuthorityService.UndeleteCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority]
   * before
   * [expire_time][google.cloud.security.privateca.v1.CertificateAuthority.expire_time].
   * The CA will not be part of the
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
   * will not be used to issue certificates from the
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  DELETED = 5,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_StateFromJSON(object: any): CertificateAuthority_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CertificateAuthority_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return CertificateAuthority_State.ENABLED;
    case 2:
    case "DISABLED":
      return CertificateAuthority_State.DISABLED;
    case 3:
    case "STAGED":
      return CertificateAuthority_State.STAGED;
    case 4:
    case "AWAITING_USER_ACTIVATION":
      return CertificateAuthority_State.AWAITING_USER_ACTIVATION;
    case 5:
    case "DELETED":
      return CertificateAuthority_State.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_State.UNRECOGNIZED;
  }
}

export function certificateAuthority_StateToJSON(object: CertificateAuthority_State): string {
  switch (object) {
    case CertificateAuthority_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CertificateAuthority_State.ENABLED:
      return "ENABLED";
    case CertificateAuthority_State.DISABLED:
      return "DISABLED";
    case CertificateAuthority_State.STAGED:
      return "STAGED";
    case CertificateAuthority_State.AWAITING_USER_ACTIVATION:
      return "AWAITING_USER_ACTIVATION";
    case CertificateAuthority_State.DELETED:
      return "DELETED";
    case CertificateAuthority_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The algorithm of a Cloud KMS CryptoKeyVersion of a
 * [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
 * [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
 * `ASYMMETRIC_SIGN`. These values correspond to the
 * [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
 * values. For RSA signing algorithms, the PSS algorithms should be preferred,
 * use PKCS1 algorithms if required for compatibility. For further
 * recommendations, see
 * https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations.
 */
export enum CertificateAuthority_SignHashAlgorithm {
  /** SIGN_HASH_ALGORITHM_UNSPECIFIED - Not specified. */
  SIGN_HASH_ALGORITHM_UNSPECIFIED = 0,
  /** RSA_PSS_2048_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256 */
  RSA_PSS_2048_SHA256 = 1,
  /** RSA_PSS_3072_SHA256 - maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256 */
  RSA_PSS_3072_SHA256 = 2,
  /** RSA_PSS_4096_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256 */
  RSA_PSS_4096_SHA256 = 3,
  /** RSA_PKCS1_2048_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256 */
  RSA_PKCS1_2048_SHA256 = 6,
  /** RSA_PKCS1_3072_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256 */
  RSA_PKCS1_3072_SHA256 = 7,
  /** RSA_PKCS1_4096_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256 */
  RSA_PKCS1_4096_SHA256 = 8,
  /** EC_P256_SHA256 - maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256 */
  EC_P256_SHA256 = 4,
  /** EC_P384_SHA384 - maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384 */
  EC_P384_SHA384 = 5,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_SignHashAlgorithmFromJSON(object: any): CertificateAuthority_SignHashAlgorithm {
  switch (object) {
    case 0:
    case "SIGN_HASH_ALGORITHM_UNSPECIFIED":
      return CertificateAuthority_SignHashAlgorithm.SIGN_HASH_ALGORITHM_UNSPECIFIED;
    case 1:
    case "RSA_PSS_2048_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_2048_SHA256;
    case 2:
    case "RSA_PSS_3072_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_3072_SHA256;
    case 3:
    case "RSA_PSS_4096_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_4096_SHA256;
    case 6:
    case "RSA_PKCS1_2048_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_2048_SHA256;
    case 7:
    case "RSA_PKCS1_3072_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_3072_SHA256;
    case 8:
    case "RSA_PKCS1_4096_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_4096_SHA256;
    case 4:
    case "EC_P256_SHA256":
      return CertificateAuthority_SignHashAlgorithm.EC_P256_SHA256;
    case 5:
    case "EC_P384_SHA384":
      return CertificateAuthority_SignHashAlgorithm.EC_P384_SHA384;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_SignHashAlgorithm.UNRECOGNIZED;
  }
}

export function certificateAuthority_SignHashAlgorithmToJSON(object: CertificateAuthority_SignHashAlgorithm): string {
  switch (object) {
    case CertificateAuthority_SignHashAlgorithm.SIGN_HASH_ALGORITHM_UNSPECIFIED:
      return "SIGN_HASH_ALGORITHM_UNSPECIFIED";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_2048_SHA256:
      return "RSA_PSS_2048_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_3072_SHA256:
      return "RSA_PSS_3072_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_4096_SHA256:
      return "RSA_PSS_4096_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_2048_SHA256:
      return "RSA_PKCS1_2048_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_3072_SHA256:
      return "RSA_PKCS1_3072_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_4096_SHA256:
      return "RSA_PKCS1_4096_SHA256";
    case CertificateAuthority_SignHashAlgorithm.EC_P256_SHA256:
      return "EC_P256_SHA256";
    case CertificateAuthority_SignHashAlgorithm.EC_P384_SHA384:
      return "EC_P384_SHA384";
    case CertificateAuthority_SignHashAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * URLs where a
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * will publish content.
 */
export interface CertificateAuthority_AccessUrls {
  /**
   * The URL where this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CA certificate is published. This will only be set for CAs that have been
   * activated.
   */
  caCertificateAccessUrl: string;
  /**
   * The URLs where this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CRLs are published. This will only be set for CAs that have been
   * activated.
   */
  crlAccessUrls: string[];
}

/**
 * A Cloud KMS key configuration that a
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * will use.
 */
export interface CertificateAuthority_KeyVersionSpec {
  /**
   * The resource name for an existing Cloud KMS CryptoKeyVersion in the
   * format
   * `projects/* /locations/* /keyRings/* /cryptoKeys/* /cryptoKeyVersions/*`.
   * This option enables full flexibility in the key's capabilities and
   * properties.
   */
  cloudKmsKeyVersion?:
    | string
    | undefined;
  /**
   * The algorithm to use for creating a managed Cloud KMS key for a for a
   * simplified experience. All managed keys will be have their
   * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
   */
  algorithm?: CertificateAuthority_SignHashAlgorithm | undefined;
}

export interface CertificateAuthority_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [CaPool][google.cloud.security.privateca.v1.CaPool] represents a group of
 * [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority]
 * that form a trust anchor. A
 * [CaPool][google.cloud.security.privateca.v1.CaPool] can be used to manage
 * issuance policies for one or more
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * resources and to rotate CA certificates in and out of the trust anchor.
 */
export interface CaPool {
  /**
   * Output only. The resource name for this
   * [CaPool][google.cloud.security.privateca.v1.CaPool] in the format
   * `projects/* /locations/* /caPools/*`.
   */
  name: string;
  /**
   * Required. Immutable. The
   * [Tier][google.cloud.security.privateca.v1.CaPool.Tier] of this
   * [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  tier: CaPool_Tier;
  /**
   * Optional. The
   * [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
   * to control how
   * [Certificates][google.cloud.security.privateca.v1.Certificate] will be
   * issued from this [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  issuancePolicy:
    | CaPool_IssuancePolicy
    | undefined;
  /**
   * Optional. The
   * [PublishingOptions][google.cloud.security.privateca.v1.CaPool.PublishingOptions]
   * to follow when issuing
   * [Certificates][google.cloud.security.privateca.v1.Certificate] from any
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * in this [CaPool][google.cloud.security.privateca.v1.CaPool].
   */
  publishingOptions:
    | CaPool_PublishingOptions
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/**
 * The tier of a [CaPool][google.cloud.security.privateca.v1.CaPool],
 * indicating its supported functionality and/or billing SKU.
 */
export enum CaPool_Tier {
  /** TIER_UNSPECIFIED - Not specified. */
  TIER_UNSPECIFIED = 0,
  /** ENTERPRISE - Enterprise tier. */
  ENTERPRISE = 1,
  /** DEVOPS - DevOps tier. */
  DEVOPS = 2,
  UNRECOGNIZED = -1,
}

export function caPool_TierFromJSON(object: any): CaPool_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return CaPool_Tier.TIER_UNSPECIFIED;
    case 1:
    case "ENTERPRISE":
      return CaPool_Tier.ENTERPRISE;
    case 2:
    case "DEVOPS":
      return CaPool_Tier.DEVOPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaPool_Tier.UNRECOGNIZED;
  }
}

export function caPool_TierToJSON(object: CaPool_Tier): string {
  switch (object) {
    case CaPool_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case CaPool_Tier.ENTERPRISE:
      return "ENTERPRISE";
    case CaPool_Tier.DEVOPS:
      return "DEVOPS";
    case CaPool_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Options relating to the publication of each
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
 * CA certificate and CRLs and their inclusion as extensions in issued
 * [Certificates][google.cloud.security.privateca.v1.Certificate]. The options
 * set here apply to certificates issued by any
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
 * in the [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export interface CaPool_PublishingOptions {
  /**
   * Optional. When true, publishes each
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CA certificate and includes its URL in the "Authority Information Access"
   * X.509 extension in all issued
   * [Certificates][google.cloud.security.privateca.v1.Certificate]. If this
   * is false, the CA certificate will not be published and the corresponding
   * X.509 extension will not be written in issued certificates.
   */
  publishCaCert: boolean;
  /**
   * Optional. When true, publishes each
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CRL and includes its URL in the "CRL Distribution Points" X.509 extension
   * in all issued
   * [Certificates][google.cloud.security.privateca.v1.Certificate]. If this
   * is false, CRLs will not be published and the corresponding X.509
   * extension will not be written in issued certificates. CRLs will expire 7
   * days from their creation. However, we will rebuild daily. CRLs are also
   * rebuilt shortly after a certificate is revoked.
   */
  publishCrl: boolean;
  /**
   * Optional. Specifies the encoding format of each
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * resource's CA certificate and CRLs. If this is omitted, CA certificates
   * and CRLs will be published in PEM.
   */
  encodingFormat: CaPool_PublishingOptions_EncodingFormat;
}

/** Supported encoding formats for publishing. */
export enum CaPool_PublishingOptions_EncodingFormat {
  /** ENCODING_FORMAT_UNSPECIFIED - Not specified. By default, PEM format will be used. */
  ENCODING_FORMAT_UNSPECIFIED = 0,
  /**
   * PEM - The
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CA certificate and CRLs will be published in PEM format.
   */
  PEM = 1,
  /**
   * DER - The
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
   * CA certificate and CRLs will be published in DER format.
   */
  DER = 2,
  UNRECOGNIZED = -1,
}

export function caPool_PublishingOptions_EncodingFormatFromJSON(object: any): CaPool_PublishingOptions_EncodingFormat {
  switch (object) {
    case 0:
    case "ENCODING_FORMAT_UNSPECIFIED":
      return CaPool_PublishingOptions_EncodingFormat.ENCODING_FORMAT_UNSPECIFIED;
    case 1:
    case "PEM":
      return CaPool_PublishingOptions_EncodingFormat.PEM;
    case 2:
    case "DER":
      return CaPool_PublishingOptions_EncodingFormat.DER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaPool_PublishingOptions_EncodingFormat.UNRECOGNIZED;
  }
}

export function caPool_PublishingOptions_EncodingFormatToJSON(object: CaPool_PublishingOptions_EncodingFormat): string {
  switch (object) {
    case CaPool_PublishingOptions_EncodingFormat.ENCODING_FORMAT_UNSPECIFIED:
      return "ENCODING_FORMAT_UNSPECIFIED";
    case CaPool_PublishingOptions_EncodingFormat.PEM:
      return "PEM";
    case CaPool_PublishingOptions_EncodingFormat.DER:
      return "DER";
    case CaPool_PublishingOptions_EncodingFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines controls over all certificate issuance within a
 * [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export interface CaPool_IssuancePolicy {
  /**
   * Optional. If any
   * [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]
   * is specified, then the certificate request's public key must match one of
   * the key types listed here. Otherwise, any key may be used.
   */
  allowedKeyTypes: CaPool_IssuancePolicy_AllowedKeyType[];
  /**
   * Optional. The maximum lifetime allowed for issued
   * [Certificates][google.cloud.security.privateca.v1.Certificate]. Note that
   * if the issuing
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * expires before a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] resource's
   * requested maximum_lifetime, the effective lifetime will be explicitly
   * truncated to match it.
   */
  maximumLifetime:
    | Duration
    | undefined;
  /**
   * Optional. If specified, then only methods allowed in the
   * [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]
   * may be used to issue
   * [Certificates][google.cloud.security.privateca.v1.Certificate].
   */
  allowedIssuanceModes:
    | CaPool_IssuancePolicy_IssuanceModes
    | undefined;
  /**
   * Optional. A set of X.509 values that will be applied to all certificates
   * issued through this [CaPool][google.cloud.security.privateca.v1.CaPool].
   * If a certificate request includes conflicting values for the same
   * properties, they will be overwritten by the values defined here. If a
   * certificate request uses a
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * that defines conflicting
   * [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]
   * for the same properties, the certificate issuance request will fail.
   */
  baselineValues:
    | X509Parameters
    | undefined;
  /**
   * Optional. Describes constraints on identities that may appear in
   * [Certificates][google.cloud.security.privateca.v1.Certificate] issued
   * through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If this
   * is omitted, then this [CaPool][google.cloud.security.privateca.v1.CaPool]
   * will not add restrictions on a certificate's identity.
   */
  identityConstraints:
    | CertificateIdentityConstraints
    | undefined;
  /**
   * Optional. Describes the set of X.509 extensions that may appear in a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] issued
   * through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If a
   * certificate request sets extensions that don't appear in the
   * [passthrough_extensions][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.passthrough_extensions],
   * those extensions will be dropped. If a certificate request uses a
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * with
   * [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]
   * that don't appear here, the certificate issuance request will fail. If
   * this is omitted, then this
   * [CaPool][google.cloud.security.privateca.v1.CaPool] will not add
   * restrictions on a certificate's X.509 extensions. These constraints do
   * not apply to X.509 extensions set in this
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s
   * [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values].
   */
  passthroughExtensions: CertificateExtensionConstraints | undefined;
}

/**
 * Describes a "type" of key that may be used in a
 * [Certificate][google.cloud.security.privateca.v1.Certificate] issued from
 * a [CaPool][google.cloud.security.privateca.v1.CaPool]. Note that a single
 * [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]
 * may refer to either a fully-qualified key algorithm, such as RSA 4096, or
 * a family of key algorithms, such as any RSA key.
 */
export interface CaPool_IssuancePolicy_AllowedKeyType {
  /** Represents an allowed RSA key type. */
  rsa?:
    | CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType
    | undefined;
  /** Represents an allowed Elliptic Curve key type. */
  ellipticCurve?: CaPool_IssuancePolicy_AllowedKeyType_EcKeyType | undefined;
}

/**
 * Describes an RSA key that may be used in a
 * [Certificate][google.cloud.security.privateca.v1.Certificate] issued
 * from a [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export interface CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
  /**
   * Optional. The minimum allowed RSA modulus size (inclusive), in bits.
   * If this is not set, or if set to zero, the service-level min RSA
   * modulus size will continue to apply.
   */
  minModulusSize: Long;
  /**
   * Optional. The maximum allowed RSA modulus size (inclusive), in bits.
   * If this is not set, or if set to zero, the service will not enforce
   * an explicit upper bound on RSA modulus sizes.
   */
  maxModulusSize: Long;
}

/**
 * Describes an Elliptic Curve key that may be used in a
 * [Certificate][google.cloud.security.privateca.v1.Certificate] issued
 * from a [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export interface CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
  /**
   * Optional. A signature algorithm that must be used. If this is
   * omitted, any EC-based signature algorithm will be allowed.
   */
  signatureAlgorithm: CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm;
}

/**
 * Describes an elliptic curve-based signature algorithm that may be
 * used in a
 * [Certificate][google.cloud.security.privateca.v1.Certificate] issued
 * from a [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export enum CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm {
  /** EC_SIGNATURE_ALGORITHM_UNSPECIFIED - Not specified. Signifies that any signature algorithm may be used. */
  EC_SIGNATURE_ALGORITHM_UNSPECIFIED = 0,
  /**
   * ECDSA_P256 - Refers to the Elliptic Curve Digital Signature Algorithm over the
   * NIST P-256 curve.
   */
  ECDSA_P256 = 1,
  /**
   * ECDSA_P384 - Refers to the Elliptic Curve Digital Signature Algorithm over the
   * NIST P-384 curve.
   */
  ECDSA_P384 = 2,
  /**
   * EDDSA_25519 - Refers to the Edwards-curve Digital Signature Algorithm over curve
   * 25519, as described in RFC 8410.
   */
  EDDSA_25519 = 3,
  UNRECOGNIZED = -1,
}

export function caPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithmFromJSON(
  object: any,
): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm {
  switch (object) {
    case 0:
    case "EC_SIGNATURE_ALGORITHM_UNSPECIFIED":
      return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.EC_SIGNATURE_ALGORITHM_UNSPECIFIED;
    case 1:
    case "ECDSA_P256":
      return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.ECDSA_P256;
    case 2:
    case "ECDSA_P384":
      return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.ECDSA_P384;
    case 3:
    case "EDDSA_25519":
      return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.EDDSA_25519;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.UNRECOGNIZED;
  }
}

export function caPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithmToJSON(
  object: CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm,
): string {
  switch (object) {
    case CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.EC_SIGNATURE_ALGORITHM_UNSPECIFIED:
      return "EC_SIGNATURE_ALGORITHM_UNSPECIFIED";
    case CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.ECDSA_P256:
      return "ECDSA_P256";
    case CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.ECDSA_P384:
      return "ECDSA_P384";
    case CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.EDDSA_25519:
      return "EDDSA_25519";
    case CaPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]
 * specifies the allowed ways in which
 * [Certificates][google.cloud.security.privateca.v1.Certificate] may be
 * requested from this [CaPool][google.cloud.security.privateca.v1.CaPool].
 */
export interface CaPool_IssuancePolicy_IssuanceModes {
  /**
   * Optional. When true, allows callers to create
   * [Certificates][google.cloud.security.privateca.v1.Certificate] by
   * specifying a CSR.
   */
  allowCsrBasedIssuance: boolean;
  /**
   * Optional. When true, allows callers to create
   * [Certificates][google.cloud.security.privateca.v1.Certificate] by
   * specifying a
   * [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig].
   */
  allowConfigBasedIssuance: boolean;
}

export interface CaPool_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A
 * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
 * corresponds to a signed X.509 certificate Revocation List (CRL). A CRL
 * contains the serial numbers of certificates that should no longer be trusted.
 */
export interface CertificateRevocationList {
  /**
   * Output only. The resource name for this
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
   * in the format `projects/* /locations/* /caPools/*certificateAuthorities/* /
   *    certificateRevocationLists/*`.
   */
  name: string;
  /** Output only. The CRL sequence number that appears in pem_crl. */
  sequenceNumber: Long;
  /** Output only. The revoked serial numbers that appear in pem_crl. */
  revokedCertificates: CertificateRevocationList_RevokedCertificate[];
  /** Output only. The PEM-encoded X.509 CRL. */
  pemCrl: string;
  /** Output only. The location where 'pem_crl' can be accessed. */
  accessUrl: string;
  /**
   * Output only. The
   * [State][google.cloud.security.privateca.v1.CertificateRevocationList.State]
   * for this
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList].
   */
  state: CertificateRevocationList_State;
  /**
   * Output only. The time at which this
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
   * was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
   * was updated.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The revision ID of this
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList].
   * A new revision is committed whenever a new CRL is published. The format is
   * an 8-character hexadecimal string.
   */
  revisionId: string;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/**
 * The state of a
 * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList],
 * indicating if it is current.
 */
export enum CertificateRevocationList_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - The
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
   * is up to date.
   */
  ACTIVE = 1,
  /**
   * SUPERSEDED - The
   * [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
   * is no longer current.
   */
  SUPERSEDED = 2,
  UNRECOGNIZED = -1,
}

export function certificateRevocationList_StateFromJSON(object: any): CertificateRevocationList_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CertificateRevocationList_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return CertificateRevocationList_State.ACTIVE;
    case 2:
    case "SUPERSEDED":
      return CertificateRevocationList_State.SUPERSEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateRevocationList_State.UNRECOGNIZED;
  }
}

export function certificateRevocationList_StateToJSON(object: CertificateRevocationList_State): string {
  switch (object) {
    case CertificateRevocationList_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CertificateRevocationList_State.ACTIVE:
      return "ACTIVE";
    case CertificateRevocationList_State.SUPERSEDED:
      return "SUPERSEDED";
    case CertificateRevocationList_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes a revoked
 * [Certificate][google.cloud.security.privateca.v1.Certificate].
 */
export interface CertificateRevocationList_RevokedCertificate {
  /**
   * The resource name for the
   * [Certificate][google.cloud.security.privateca.v1.Certificate] in the
   * format `projects/* /locations/* /caPools/* /certificates/*`.
   */
  certificate: string;
  /**
   * The serial number of the
   * [Certificate][google.cloud.security.privateca.v1.Certificate].
   */
  hexSerialNumber: string;
  /**
   * The reason the
   * [Certificate][google.cloud.security.privateca.v1.Certificate] was
   * revoked.
   */
  revocationReason: RevocationReason;
}

export interface CertificateRevocationList_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [Certificate][google.cloud.security.privateca.v1.Certificate] corresponds
 * to a signed X.509 certificate issued by a
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
 */
export interface Certificate {
  /**
   * Output only. The resource name for this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] in the format
   * `projects/* /locations/* /caPools/* /certificates/*`.
   */
  name: string;
  /** Immutable. A pem-encoded X.509 certificate signing request (CSR). */
  pemCsr?:
    | string
    | undefined;
  /**
   * Immutable. A description of the certificate and key that does not require
   * X.509 or ASN.1.
   */
  config?:
    | CertificateConfig
    | undefined;
  /**
   * Output only. The resource name of the issuing
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * in the format `projects/* /locations/* /caPools/* /certificateAuthorities/*`.
   */
  issuerCertificateAuthority: string;
  /**
   * Required. Immutable. The desired lifetime of a certificate. Used to create
   * the "not_before_time" and "not_after_time" fields inside an X.509
   * certificate. Note that the lifetime may be truncated if it would extend
   * past the life of any certificate authority in the issuing chain.
   */
  lifetime:
    | Duration
    | undefined;
  /**
   * Immutable. The resource name for a
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * used to issue this certificate, in the format
   * `projects/* /locations/* /certificateTemplates/*`.
   * If this is specified, the caller must have the necessary permission to
   * use this template. If this is omitted, no template will be used.
   * This template must be in the same location as the
   * [Certificate][google.cloud.security.privateca.v1.Certificate].
   */
  certificateTemplate: string;
  /**
   * Immutable. Specifies how the
   * [Certificate][google.cloud.security.privateca.v1.Certificate]'s identity
   * fields are to be decided. If this is omitted, the `DEFAULT` subject mode
   * will be used.
   */
  subjectMode: SubjectRequestMode;
  /**
   * Output only. Details regarding the revocation of this
   * [Certificate][google.cloud.security.privateca.v1.Certificate]. This
   * [Certificate][google.cloud.security.privateca.v1.Certificate] is considered
   * revoked if and only if this field is present.
   */
  revocationDetails:
    | Certificate_RevocationDetails
    | undefined;
  /** Output only. The pem-encoded, signed X.509 certificate. */
  pemCertificate: string;
  /** Output only. A structured description of the issued X.509 certificate. */
  certificateDescription:
    | CertificateDescription
    | undefined;
  /**
   * Output only. The chain that may be used to verify the X.509 certificate.
   * Expected to be in issuer-to-root order according to RFC 5246.
   */
  pemCertificateChain: string[];
  /**
   * Output only. The time at which this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] was updated.
   */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/**
 * Describes fields that are relavent to the revocation of a
 * [Certificate][google.cloud.security.privateca.v1.Certificate].
 */
export interface Certificate_RevocationDetails {
  /**
   * Indicates why a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] was
   * revoked.
   */
  revocationState: RevocationReason;
  /**
   * The time at which this
   * [Certificate][google.cloud.security.privateca.v1.Certificate] was
   * revoked.
   */
  revocationTime: Date | undefined;
}

export interface Certificate_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A
 * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
 * refers to a managed template for certificate issuance.
 */
export interface CertificateTemplate {
  /**
   * Output only. The resource name for this
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * in the format `projects/* /locations/* /certificateTemplates/*`.
   */
  name: string;
  /**
   * Optional. The maximum lifetime allowed for issued
   * [Certificates][google.cloud.security.privateca.v1.Certificate] that use
   * this template. If the issuing
   * [CaPool][google.cloud.security.privateca.v1.CaPool] resource's
   * [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
   * specifies a
   * [maximum_lifetime][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.maximum_lifetime]
   * the minimum of the two durations will be the maximum lifetime for issued
   * [Certificates][google.cloud.security.privateca.v1.Certificate]. Note that
   * if the issuing
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * expires before a
   * [Certificate][google.cloud.security.privateca.v1.Certificate]'s requested
   * maximum_lifetime, the effective lifetime will be explicitly truncated
   *  to match it.
   */
  maximumLifetime:
    | Duration
    | undefined;
  /**
   * Optional. A set of X.509 values that will be applied to all issued
   * certificates that use this template. If the certificate request includes
   * conflicting values for the same properties, they will be overwritten by the
   * values defined here. If the issuing
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s
   * [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
   * defines conflicting
   * [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]
   * for the same properties, the certificate issuance request will fail.
   */
  predefinedValues:
    | X509Parameters
    | undefined;
  /**
   * Optional. Describes constraints on identities that may be appear in
   * [Certificates][google.cloud.security.privateca.v1.Certificate] issued using
   * this template. If this is omitted, then this template will not add
   * restrictions on a certificate's identity.
   */
  identityConstraints:
    | CertificateIdentityConstraints
    | undefined;
  /**
   * Optional. Describes the set of X.509 extensions that may appear in a
   * [Certificate][google.cloud.security.privateca.v1.Certificate] issued using
   * this
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate].
   * If a certificate request sets extensions that don't appear in the
   * [passthrough_extensions][google.cloud.security.privateca.v1.CertificateTemplate.passthrough_extensions],
   * those extensions will be dropped. If the issuing
   * [CaPool][google.cloud.security.privateca.v1.CaPool]'s
   * [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
   * defines
   * [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]
   * that don't appear here, the certificate issuance request will fail. If this
   * is omitted, then this template will not add restrictions on a certificate's
   * X.509 extensions. These constraints do not apply to X.509 extensions set in
   * this
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]'s
   * [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values].
   */
  passthroughExtensions:
    | CertificateExtensionConstraints
    | undefined;
  /**
   * Optional. A human-readable description of scenarios this template is
   * intended for.
   */
  description: string;
  /**
   * Output only. The time at which this
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * was created.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this
   * [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
   * was updated.
   */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

export interface CertificateTemplate_LabelsEntry {
  key: string;
  value: string;
}

/**
 * An [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] is
 * used to describe certain fields of an X.509 certificate, such as the key
 * usage fields, fields specific to CA certificates, certificate policy
 * extensions and custom extensions.
 */
export interface X509Parameters {
  /**
   * Optional. Indicates the intended use for keys that correspond to a
   * certificate.
   */
  keyUsage:
    | KeyUsage
    | undefined;
  /**
   * Optional. Describes options in this
   * [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] that
   * are relevant in a CA certificate.
   */
  caOptions:
    | X509Parameters_CaOptions
    | undefined;
  /**
   * Optional. Describes the X.509 certificate policy object identifiers, per
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
   */
  policyIds: ObjectId[];
  /**
   * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint
   * addresses that appear in the "Authority Information Access" extension in
   * the certificate.
   */
  aiaOcspServers: string[];
  /** Optional. Describes the X.509 name constraints extension. */
  nameConstraints:
    | X509Parameters_NameConstraints
    | undefined;
  /** Optional. Describes custom X.509 extensions. */
  additionalExtensions: X509Extension[];
}

/** Describes values that are relevant in a CA certificate. */
export interface X509Parameters_CaOptions {
  /**
   * Optional. Refers to the "CA" X.509 extension, which is a boolean value.
   * When this value is missing, the extension will be omitted from the CA
   * certificate.
   */
  isCa?:
    | boolean
    | undefined;
  /**
   * Optional. Refers to the path length restriction X.509 extension. For a CA
   * certificate, this value describes the depth of subordinate CA
   * certificates that are allowed.
   * If this value is less than 0, the request will fail.
   * If this value is missing, the max path length will be omitted from the
   * CA certificate.
   */
  maxIssuerPathLength?: number | undefined;
}

/**
 * Describes the X.509 name constraints extension, per
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.10
 */
export interface X509Parameters_NameConstraints {
  /** Indicates whether or not the name constraints are marked critical. */
  critical: boolean;
  /**
   * Contains permitted DNS names. Any DNS name that can be
   * constructed by simply adding zero or more labels to
   * the left-hand side of the name satisfies the name constraint.
   * For example, `example.com`, `www.example.com`, `www.sub.example.com`
   * would satisfy `example.com` while `example1.com` does not.
   */
  permittedDnsNames: string[];
  /**
   * Contains excluded DNS names. Any DNS name that can be
   * constructed by simply adding zero or more labels to
   * the left-hand side of the name satisfies the name constraint.
   * For example, `example.com`, `www.example.com`, `www.sub.example.com`
   * would satisfy `example.com` while `example1.com` does not.
   */
  excludedDnsNames: string[];
  /**
   * Contains the permitted IP ranges. For IPv4 addresses, the ranges
   * are expressed using CIDR notation as specified in RFC 4632.
   * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
   * addresses.
   */
  permittedIpRanges: string[];
  /**
   * Contains the excluded IP ranges. For IPv4 addresses, the ranges
   * are expressed using CIDR notation as specified in RFC 4632.
   * For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
   * addresses.
   */
  excludedIpRanges: string[];
  /**
   * Contains the permitted email addresses. The value can be a particular
   * email address, a hostname to indicate all email addresses on that host or
   * a domain with a leading period (e.g. `.example.com`) to indicate
   * all email addresses in that domain.
   */
  permittedEmailAddresses: string[];
  /**
   * Contains the excluded email addresses. The value can be a particular
   * email address, a hostname to indicate all email addresses on that host or
   * a domain with a leading period (e.g. `.example.com`) to indicate
   * all email addresses in that domain.
   */
  excludedEmailAddresses: string[];
  /**
   * Contains the permitted URIs that apply to the host part of the name.
   * The value can be a hostname or a domain with a
   * leading period (like `.example.com`)
   */
  permittedUris: string[];
  /**
   * Contains the excluded URIs that apply to the host part of the name.
   * The value can be a hostname or a domain with a
   * leading period (like `.example.com`)
   */
  excludedUris: string[];
}

/**
 * Describes a subordinate CA's issuers. This is either a resource name to a
 * known issuing
 * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
 * or a PEM issuer certificate chain.
 */
export interface SubordinateConfig {
  /**
   * Required. This can refer to a
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * that was used to create a subordinate
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
   * This field is used for information and usability purposes only. The
   * resource name is in the format
   * `projects/* /locations/* /caPools/* /certificateAuthorities/*`.
   */
  certificateAuthority?:
    | string
    | undefined;
  /**
   * Required. Contains the PEM certificate chain for the issuers of this
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
   * but not pem certificate for this CA itself.
   */
  pemIssuerChain?: SubordinateConfig_SubordinateConfigChain | undefined;
}

/**
 * This message describes a subordinate CA's issuer certificate chain. This
 * wrapper exists for compatibility reasons.
 */
export interface SubordinateConfig_SubordinateConfigChain {
  /** Required. Expected to be in leaf-to-root order according to RFC 5246. */
  pemCertificates: string[];
}

/**
 * A [PublicKey][google.cloud.security.privateca.v1.PublicKey] describes a
 * public key.
 */
export interface PublicKey {
  /**
   * Required. A public key. The padding and encoding
   * must match with the `KeyFormat` value specified for the `format` field.
   */
  key: Buffer;
  /** Required. The format of the public key. */
  format: PublicKey_KeyFormat;
}

/**
 * Types of public keys formats that are supported. Currently, only `PEM`
 * format is supported.
 */
export enum PublicKey_KeyFormat {
  /** KEY_FORMAT_UNSPECIFIED - Default unspecified value. */
  KEY_FORMAT_UNSPECIFIED = 0,
  /**
   * PEM - The key is PEM-encoded as defined in [RFC
   * 7468](https://tools.ietf.org/html/rfc7468). It can be any of the
   * following: a PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
   * structure, an RFC 5280
   * [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
   * or a PEM-encoded X.509 certificate signing request (CSR). If a
   * [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
   * is specified, it can contain a A PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
   * or a NIST P-256/secp256r1/prime256v1 or P-384 key. If a CSR is specified,
   * it will used solely for the purpose of extracting the public key. When
   * generated by the service, it will always be an RFC 5280
   * [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
   * structure containing an algorithm identifier and a key.
   */
  PEM = 1,
  UNRECOGNIZED = -1,
}

export function publicKey_KeyFormatFromJSON(object: any): PublicKey_KeyFormat {
  switch (object) {
    case 0:
    case "KEY_FORMAT_UNSPECIFIED":
      return PublicKey_KeyFormat.KEY_FORMAT_UNSPECIFIED;
    case 1:
    case "PEM":
      return PublicKey_KeyFormat.PEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PublicKey_KeyFormat.UNRECOGNIZED;
  }
}

export function publicKey_KeyFormatToJSON(object: PublicKey_KeyFormat): string {
  switch (object) {
    case PublicKey_KeyFormat.KEY_FORMAT_UNSPECIFIED:
      return "KEY_FORMAT_UNSPECIFIED";
    case PublicKey_KeyFormat.PEM:
      return "PEM";
    case PublicKey_KeyFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig]
 * describes an X.509 certificate or CSR that is to be created, as an
 * alternative to using ASN.1.
 */
export interface CertificateConfig {
  /**
   * Required. Specifies some of the values in a certificate that are related to
   * the subject.
   */
  subjectConfig:
    | CertificateConfig_SubjectConfig
    | undefined;
  /**
   * Required. Describes how some of the technical X.509 fields in a certificate
   * should be populated.
   */
  x509Config:
    | X509Parameters
    | undefined;
  /**
   * Optional. The public key that corresponds to this config. This is, for
   * example, used when issuing
   * [Certificates][google.cloud.security.privateca.v1.Certificate], but not
   * when creating a self-signed
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * or
   * [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
   * CSR.
   */
  publicKey:
    | PublicKey
    | undefined;
  /**
   * Optional. When specified this provides a custom SKI to be used in the
   * certificate. This should only be used to maintain a SKI of an existing CA
   * originally created outside CA service, which was not generated using method
   * (1) described in RFC 5280 section 4.2.1.2.
   */
  subjectKeyId: CertificateConfig_KeyId | undefined;
}

/**
 * These values are used to create the distinguished name and subject
 * alternative name fields in an X.509 certificate.
 */
export interface CertificateConfig_SubjectConfig {
  /**
   * Optional. Contains distinguished name fields such as the common name,
   * location and organization.
   */
  subject:
    | Subject
    | undefined;
  /** Optional. The subject alternative name fields. */
  subjectAltName: SubjectAltNames | undefined;
}

/**
 * A KeyId identifies a specific public key, usually by hashing the public
 * key.
 */
export interface CertificateConfig_KeyId {
  /**
   * Required. The value of this KeyId encoded in lowercase hexadecimal. This
   * is most likely the 160 bit SHA-1 hash of the public key.
   */
  keyId: string;
}

/**
 * A
 * [CertificateDescription][google.cloud.security.privateca.v1.CertificateDescription]
 * describes an X.509 certificate or CSR that has been issued, as an alternative
 * to using ASN.1 / X.509.
 */
export interface CertificateDescription {
  /**
   * Describes some of the values in a certificate that are related to the
   * subject and lifetime.
   */
  subjectDescription:
    | CertificateDescription_SubjectDescription
    | undefined;
  /** Describes some of the technical X.509 fields in a certificate. */
  x509Description:
    | X509Parameters
    | undefined;
  /** The public key that corresponds to an issued certificate. */
  publicKey:
    | PublicKey
    | undefined;
  /**
   * Provides a means of identifiying certificates that contain a particular
   * public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
   */
  subjectKeyId:
    | CertificateDescription_KeyId
    | undefined;
  /**
   * Identifies the subject_key_id of the parent certificate, per
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.1
   */
  authorityKeyId:
    | CertificateDescription_KeyId
    | undefined;
  /**
   * Describes a list of locations to obtain CRL information, i.e.
   * the DistributionPoint.fullName described by
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.13
   */
  crlDistributionPoints: string[];
  /**
   * Describes lists of issuer CA certificate URLs that appear in the
   * "Authority Information Access" extension in the certificate.
   */
  aiaIssuingCertificateUrls: string[];
  /** The hash of the x.509 certificate. */
  certFingerprint: CertificateDescription_CertificateFingerprint | undefined;
}

/**
 * These values describe fields in an issued X.509 certificate such as the
 * distinguished name, subject alternative names, serial number, and lifetime.
 */
export interface CertificateDescription_SubjectDescription {
  /**
   * Contains distinguished name fields such as the common name, location and
   * / organization.
   */
  subject:
    | Subject
    | undefined;
  /** The subject alternative name fields. */
  subjectAltName:
    | SubjectAltNames
    | undefined;
  /** The serial number encoded in lowercase hexadecimal. */
  hexSerialNumber: string;
  /** For convenience, the actual lifetime of an issued certificate. */
  lifetime:
    | Duration
    | undefined;
  /** The time at which the certificate becomes valid. */
  notBeforeTime:
    | Date
    | undefined;
  /**
   * The time after which the certificate is expired.
   * Per RFC 5280, the validity period for a certificate is the period of time
   * from not_before_time through not_after_time, inclusive.
   * Corresponds to 'not_before_time' + 'lifetime' - 1 second.
   */
  notAfterTime: Date | undefined;
}

/**
 * A KeyId identifies a specific public key, usually by hashing the public
 * key.
 */
export interface CertificateDescription_KeyId {
  /**
   * Optional. The value of this KeyId encoded in lowercase hexadecimal. This
   * is most likely the 160 bit SHA-1 hash of the public key.
   */
  keyId: string;
}

/** A group of fingerprints for the x509 certificate. */
export interface CertificateDescription_CertificateFingerprint {
  /** The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate. */
  sha256Hash: string;
}

/**
 * An [ObjectId][google.cloud.security.privateca.v1.ObjectId] specifies an
 * object identifier (OID). These provide context and describe types in ASN.1
 * messages.
 */
export interface ObjectId {
  /**
   * Required. The parts of an OID path. The most significant parts of the path
   * come first.
   */
  objectIdPath: number[];
}

/**
 * An [X509Extension][google.cloud.security.privateca.v1.X509Extension]
 * specifies an X.509 extension, which may be used in different parts of X.509
 * objects like certificates, CSRs, and CRLs.
 */
export interface X509Extension {
  /** Required. The OID for this X.509 extension. */
  objectId:
    | ObjectId
    | undefined;
  /**
   * Optional. Indicates whether or not this extension is critical (i.e., if the
   * client does not know how to handle this extension, the client should
   * consider this to be an error).
   */
  critical: boolean;
  /** Required. The value of this X.509 extension. */
  value: Buffer;
}

/**
 * A [KeyUsage][google.cloud.security.privateca.v1.KeyUsage] describes key usage
 * values that may appear in an X.509 certificate.
 */
export interface KeyUsage {
  /** Describes high-level ways in which a key may be used. */
  baseKeyUsage:
    | KeyUsage_KeyUsageOptions
    | undefined;
  /** Detailed scenarios in which a key may be used. */
  extendedKeyUsage:
    | KeyUsage_ExtendedKeyUsageOptions
    | undefined;
  /**
   * Used to describe extended key usages that are not listed in the
   * [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]
   * message.
   */
  unknownExtendedKeyUsages: ObjectId[];
}

/**
 * [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.KeyUsageOptions]
 * corresponds to the key usage values described in
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
 */
export interface KeyUsage_KeyUsageOptions {
  /** The key may be used for digital signatures. */
  digitalSignature: boolean;
  /**
   * The key may be used for cryptographic commitments. Note that this may
   * also be referred to as "non-repudiation".
   */
  contentCommitment: boolean;
  /** The key may be used to encipher other keys. */
  keyEncipherment: boolean;
  /** The key may be used to encipher data. */
  dataEncipherment: boolean;
  /** The key may be used in a key agreement protocol. */
  keyAgreement: boolean;
  /** The key may be used to sign certificates. */
  certSign: boolean;
  /** The key may be used sign certificate revocation lists. */
  crlSign: boolean;
  /** The key may be used to encipher only. */
  encipherOnly: boolean;
  /** The key may be used to decipher only. */
  decipherOnly: boolean;
}

/**
 * [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]
 * has fields that correspond to certain common OIDs that could be specified
 * as an extended key usage value.
 */
export interface KeyUsage_ExtendedKeyUsageOptions {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
   * server authentication", though regularly used for non-WWW TLS.
   */
  serverAuth: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
   * client authentication", though regularly used for non-WWW TLS.
   */
  clientAuth: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
   * downloadable executable code client authentication".
   */
  codeSigning: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
   * protection".
   */
  emailProtection: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
   * the hash of an object to a time".
   */
  timeStamping: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
   * OCSP responses".
   */
  ocspSigning: boolean;
}

/**
 * [Subject][google.cloud.security.privateca.v1.Subject] describes parts of a
 * distinguished name that, in turn, describes the subject of the certificate.
 */
export interface Subject {
  /** The "common name" of the subject. */
  commonName: string;
  /** The country code of the subject. */
  countryCode: string;
  /** The organization of the subject. */
  organization: string;
  /** The organizational_unit of the subject. */
  organizationalUnit: string;
  /** The locality or city of the subject. */
  locality: string;
  /** The province, territory, or regional state of the subject. */
  province: string;
  /** The street address of the subject. */
  streetAddress: string;
  /** The postal code of the subject. */
  postalCode: string;
}

/**
 * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
 * corresponds to a more modern way of listing what the asserted identity is in
 * a certificate (i.e., compared to the "common name" in the distinguished
 * name).
 */
export interface SubjectAltNames {
  /** Contains only valid, fully-qualified host names. */
  dnsNames: string[];
  /** Contains only valid RFC 3986 URIs. */
  uris: string[];
  /** Contains only valid RFC 2822 E-mail addresses. */
  emailAddresses: string[];
  /** Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses. */
  ipAddresses: string[];
  /**
   * Contains additional subject alternative name values.
   * For each custom_san, the `value` field must contain an ASN.1 encoded
   * UTF8String.
   */
  customSans: X509Extension[];
}

/**
 * Describes constraints on a
 * [Certificate][google.cloud.security.privateca.v1.Certificate]'s
 * [Subject][google.cloud.security.privateca.v1.Subject] and
 * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames].
 */
export interface CertificateIdentityConstraints {
  /**
   * Optional. A CEL expression that may be used to validate the resolved X.509
   * Subject and/or Subject Alternative Name before a certificate is signed. To
   * see the full allowed syntax and some examples, see
   * https://cloud.google.com/certificate-authority-service/docs/using-cel
   */
  celExpression:
    | Expr
    | undefined;
  /**
   * Required. If this is true, the
   * [Subject][google.cloud.security.privateca.v1.Subject] field may be copied
   * from a certificate request into the signed certificate. Otherwise, the
   * requested [Subject][google.cloud.security.privateca.v1.Subject] will be
   * discarded.
   */
  allowSubjectPassthrough?:
    | boolean
    | undefined;
  /**
   * Required. If this is true, the
   * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
   * extension may be copied from a certificate request into the signed
   * certificate. Otherwise, the requested
   * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will
   * be discarded.
   */
  allowSubjectAltNamesPassthrough?: boolean | undefined;
}

/**
 * Describes a set of X.509 extensions that may be part of some certificate
 * issuance controls.
 */
export interface CertificateExtensionConstraints {
  /**
   * Optional. A set of named X.509 extensions. Will be combined with
   * [additional_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.additional_extensions]
   * to determine the full set of X.509 extensions.
   */
  knownExtensions: CertificateExtensionConstraints_KnownCertificateExtension[];
  /**
   * Optional. A set of [ObjectIds][google.cloud.security.privateca.v1.ObjectId]
   * identifying custom X.509 extensions. Will be combined with
   * [known_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.known_extensions]
   * to determine the full set of X.509 extensions.
   */
  additionalExtensions: ObjectId[];
}

/**
 * Describes well-known X.509 extensions that can appear in a
 * [Certificate][google.cloud.security.privateca.v1.Certificate], not
 * including the
 * [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
 * extension.
 */
export enum CertificateExtensionConstraints_KnownCertificateExtension {
  /** KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED - Not specified. */
  KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED = 0,
  /**
   * BASE_KEY_USAGE - Refers to a certificate's Key Usage extension, as described in [RFC 5280
   * section 4.2.1.3](https://tools.ietf.org/html/rfc5280#section-4.2.1.3).
   * This corresponds to the
   * [KeyUsage.base_key_usage][google.cloud.security.privateca.v1.KeyUsage.base_key_usage]
   * field.
   */
  BASE_KEY_USAGE = 1,
  /**
   * EXTENDED_KEY_USAGE - Refers to a certificate's Extended Key Usage extension, as described in
   * [RFC 5280
   * section 4.2.1.12](https://tools.ietf.org/html/rfc5280#section-4.2.1.12).
   * This corresponds to the
   * [KeyUsage.extended_key_usage][google.cloud.security.privateca.v1.KeyUsage.extended_key_usage]
   * message.
   */
  EXTENDED_KEY_USAGE = 2,
  /**
   * CA_OPTIONS - Refers to a certificate's Basic Constraints extension, as described in
   * [RFC 5280
   * section 4.2.1.9](https://tools.ietf.org/html/rfc5280#section-4.2.1.9).
   * This corresponds to the
   * [X509Parameters.ca_options][google.cloud.security.privateca.v1.X509Parameters.ca_options]
   * field.
   */
  CA_OPTIONS = 3,
  /**
   * POLICY_IDS - Refers to a certificate's Policy object identifiers, as described in
   * [RFC 5280
   * section 4.2.1.4](https://tools.ietf.org/html/rfc5280#section-4.2.1.4).
   * This corresponds to the
   * [X509Parameters.policy_ids][google.cloud.security.privateca.v1.X509Parameters.policy_ids]
   * field.
   */
  POLICY_IDS = 4,
  /**
   * AIA_OCSP_SERVERS - Refers to OCSP servers in a certificate's Authority Information Access
   * extension, as described in
   * [RFC 5280
   * section 4.2.2.1](https://tools.ietf.org/html/rfc5280#section-4.2.2.1),
   * This corresponds to the
   * [X509Parameters.aia_ocsp_servers][google.cloud.security.privateca.v1.X509Parameters.aia_ocsp_servers]
   * field.
   */
  AIA_OCSP_SERVERS = 5,
  /**
   * NAME_CONSTRAINTS - Refers to Name Constraints extension as described in
   * [RFC 5280
   * section 4.2.1.10](https://tools.ietf.org/html/rfc5280#section-4.2.1.10)
   */
  NAME_CONSTRAINTS = 6,
  UNRECOGNIZED = -1,
}

export function certificateExtensionConstraints_KnownCertificateExtensionFromJSON(
  object: any,
): CertificateExtensionConstraints_KnownCertificateExtension {
  switch (object) {
    case 0:
    case "KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED":
      return CertificateExtensionConstraints_KnownCertificateExtension.KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED;
    case 1:
    case "BASE_KEY_USAGE":
      return CertificateExtensionConstraints_KnownCertificateExtension.BASE_KEY_USAGE;
    case 2:
    case "EXTENDED_KEY_USAGE":
      return CertificateExtensionConstraints_KnownCertificateExtension.EXTENDED_KEY_USAGE;
    case 3:
    case "CA_OPTIONS":
      return CertificateExtensionConstraints_KnownCertificateExtension.CA_OPTIONS;
    case 4:
    case "POLICY_IDS":
      return CertificateExtensionConstraints_KnownCertificateExtension.POLICY_IDS;
    case 5:
    case "AIA_OCSP_SERVERS":
      return CertificateExtensionConstraints_KnownCertificateExtension.AIA_OCSP_SERVERS;
    case 6:
    case "NAME_CONSTRAINTS":
      return CertificateExtensionConstraints_KnownCertificateExtension.NAME_CONSTRAINTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateExtensionConstraints_KnownCertificateExtension.UNRECOGNIZED;
  }
}

export function certificateExtensionConstraints_KnownCertificateExtensionToJSON(
  object: CertificateExtensionConstraints_KnownCertificateExtension,
): string {
  switch (object) {
    case CertificateExtensionConstraints_KnownCertificateExtension.KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED:
      return "KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED";
    case CertificateExtensionConstraints_KnownCertificateExtension.BASE_KEY_USAGE:
      return "BASE_KEY_USAGE";
    case CertificateExtensionConstraints_KnownCertificateExtension.EXTENDED_KEY_USAGE:
      return "EXTENDED_KEY_USAGE";
    case CertificateExtensionConstraints_KnownCertificateExtension.CA_OPTIONS:
      return "CA_OPTIONS";
    case CertificateExtensionConstraints_KnownCertificateExtension.POLICY_IDS:
      return "POLICY_IDS";
    case CertificateExtensionConstraints_KnownCertificateExtension.AIA_OCSP_SERVERS:
      return "AIA_OCSP_SERVERS";
    case CertificateExtensionConstraints_KnownCertificateExtension.NAME_CONSTRAINTS:
      return "NAME_CONSTRAINTS";
    case CertificateExtensionConstraints_KnownCertificateExtension.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseCertificateAuthority(): CertificateAuthority {
  return {
    name: "",
    type: 0,
    config: undefined,
    lifetime: undefined,
    keySpec: undefined,
    subordinateConfig: undefined,
    tier: 0,
    state: 0,
    pemCaCertificates: [],
    caCertificateDescriptions: [],
    gcsBucket: "",
    accessUrls: undefined,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    expireTime: undefined,
    labels: {},
  };
}

export const CertificateAuthority: MessageFns<CertificateAuthority> = {
  encode(message: CertificateAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.config !== undefined) {
      CertificateConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(34).fork()).join();
    }
    if (message.keySpec !== undefined) {
      CertificateAuthority_KeyVersionSpec.encode(message.keySpec, writer.uint32(42).fork()).join();
    }
    if (message.subordinateConfig !== undefined) {
      SubordinateConfig.encode(message.subordinateConfig, writer.uint32(50).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(56).int32(message.tier);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    for (const v of message.pemCaCertificates) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.caCertificateDescriptions) {
      CertificateDescription.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.gcsBucket !== "") {
      writer.uint32(90).string(message.gcsBucket);
    }
    if (message.accessUrls !== undefined) {
      CertificateAuthority_AccessUrls.encode(message.accessUrls, writer.uint32(98).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(106).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(114).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(122).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(130).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateAuthority_LabelsEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = CertificateConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.keySpec = CertificateAuthority_KeyVersionSpec.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subordinateConfig = SubordinateConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pemCaCertificates.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.caCertificateDescriptions.push(CertificateDescription.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.gcsBucket = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.accessUrls = CertificateAuthority_AccessUrls.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          const entry17 = CertificateAuthority_LabelsEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.labels[entry17.key] = entry17.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? certificateAuthority_TypeFromJSON(object.type) : 0,
      config: isSet(object.config) ? CertificateConfig.fromJSON(object.config) : undefined,
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      keySpec: isSet(object.keySpec) ? CertificateAuthority_KeyVersionSpec.fromJSON(object.keySpec) : undefined,
      subordinateConfig: isSet(object.subordinateConfig)
        ? SubordinateConfig.fromJSON(object.subordinateConfig)
        : undefined,
      tier: isSet(object.tier) ? caPool_TierFromJSON(object.tier) : 0,
      state: isSet(object.state) ? certificateAuthority_StateFromJSON(object.state) : 0,
      pemCaCertificates: globalThis.Array.isArray(object?.pemCaCertificates)
        ? object.pemCaCertificates.map((e: any) => globalThis.String(e))
        : [],
      caCertificateDescriptions: globalThis.Array.isArray(object?.caCertificateDescriptions)
        ? object.caCertificateDescriptions.map((e: any) => CertificateDescription.fromJSON(e))
        : [],
      gcsBucket: isSet(object.gcsBucket) ? globalThis.String(object.gcsBucket) : "",
      accessUrls: isSet(object.accessUrls) ? CertificateAuthority_AccessUrls.fromJSON(object.accessUrls) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CertificateAuthority): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = certificateAuthority_TypeToJSON(message.type);
    }
    if (message.config !== undefined) {
      obj.config = CertificateConfig.toJSON(message.config);
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.keySpec !== undefined) {
      obj.keySpec = CertificateAuthority_KeyVersionSpec.toJSON(message.keySpec);
    }
    if (message.subordinateConfig !== undefined) {
      obj.subordinateConfig = SubordinateConfig.toJSON(message.subordinateConfig);
    }
    if (message.tier !== 0) {
      obj.tier = caPool_TierToJSON(message.tier);
    }
    if (message.state !== 0) {
      obj.state = certificateAuthority_StateToJSON(message.state);
    }
    if (message.pemCaCertificates?.length) {
      obj.pemCaCertificates = message.pemCaCertificates;
    }
    if (message.caCertificateDescriptions?.length) {
      obj.caCertificateDescriptions = message.caCertificateDescriptions.map((e) => CertificateDescription.toJSON(e));
    }
    if (message.gcsBucket !== "") {
      obj.gcsBucket = message.gcsBucket;
    }
    if (message.accessUrls !== undefined) {
      obj.accessUrls = CertificateAuthority_AccessUrls.toJSON(message.accessUrls);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority>): CertificateAuthority {
    return CertificateAuthority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority>): CertificateAuthority {
    const message = createBaseCertificateAuthority();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.config = (object.config !== undefined && object.config !== null)
      ? CertificateConfig.fromPartial(object.config)
      : undefined;
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.keySpec = (object.keySpec !== undefined && object.keySpec !== null)
      ? CertificateAuthority_KeyVersionSpec.fromPartial(object.keySpec)
      : undefined;
    message.subordinateConfig = (object.subordinateConfig !== undefined && object.subordinateConfig !== null)
      ? SubordinateConfig.fromPartial(object.subordinateConfig)
      : undefined;
    message.tier = object.tier ?? 0;
    message.state = object.state ?? 0;
    message.pemCaCertificates = object.pemCaCertificates?.map((e) => e) || [];
    message.caCertificateDescriptions =
      object.caCertificateDescriptions?.map((e) => CertificateDescription.fromPartial(e)) || [];
    message.gcsBucket = object.gcsBucket ?? "";
    message.accessUrls = (object.accessUrls !== undefined && object.accessUrls !== null)
      ? CertificateAuthority_AccessUrls.fromPartial(object.accessUrls)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificateAuthority_AccessUrls(): CertificateAuthority_AccessUrls {
  return { caCertificateAccessUrl: "", crlAccessUrls: [] };
}

export const CertificateAuthority_AccessUrls: MessageFns<CertificateAuthority_AccessUrls> = {
  encode(message: CertificateAuthority_AccessUrls, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caCertificateAccessUrl !== "") {
      writer.uint32(10).string(message.caCertificateAccessUrl);
    }
    for (const v of message.crlAccessUrls) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_AccessUrls {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_AccessUrls();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.caCertificateAccessUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crlAccessUrls.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_AccessUrls {
    return {
      caCertificateAccessUrl: isSet(object.caCertificateAccessUrl)
        ? globalThis.String(object.caCertificateAccessUrl)
        : "",
      crlAccessUrls: globalThis.Array.isArray(object?.crlAccessUrls)
        ? object.crlAccessUrls.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CertificateAuthority_AccessUrls): unknown {
    const obj: any = {};
    if (message.caCertificateAccessUrl !== "") {
      obj.caCertificateAccessUrl = message.caCertificateAccessUrl;
    }
    if (message.crlAccessUrls?.length) {
      obj.crlAccessUrls = message.crlAccessUrls;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_AccessUrls>): CertificateAuthority_AccessUrls {
    return CertificateAuthority_AccessUrls.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_AccessUrls>): CertificateAuthority_AccessUrls {
    const message = createBaseCertificateAuthority_AccessUrls();
    message.caCertificateAccessUrl = object.caCertificateAccessUrl ?? "";
    message.crlAccessUrls = object.crlAccessUrls?.map((e) => e) || [];
    return message;
  },
};

function createBaseCertificateAuthority_KeyVersionSpec(): CertificateAuthority_KeyVersionSpec {
  return { cloudKmsKeyVersion: undefined, algorithm: undefined };
}

export const CertificateAuthority_KeyVersionSpec: MessageFns<CertificateAuthority_KeyVersionSpec> = {
  encode(message: CertificateAuthority_KeyVersionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudKmsKeyVersion !== undefined) {
      writer.uint32(10).string(message.cloudKmsKeyVersion);
    }
    if (message.algorithm !== undefined) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_KeyVersionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_KeyVersionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudKmsKeyVersion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_KeyVersionSpec {
    return {
      cloudKmsKeyVersion: isSet(object.cloudKmsKeyVersion) ? globalThis.String(object.cloudKmsKeyVersion) : undefined,
      algorithm: isSet(object.algorithm) ? certificateAuthority_SignHashAlgorithmFromJSON(object.algorithm) : undefined,
    };
  },

  toJSON(message: CertificateAuthority_KeyVersionSpec): unknown {
    const obj: any = {};
    if (message.cloudKmsKeyVersion !== undefined) {
      obj.cloudKmsKeyVersion = message.cloudKmsKeyVersion;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = certificateAuthority_SignHashAlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_KeyVersionSpec>): CertificateAuthority_KeyVersionSpec {
    return CertificateAuthority_KeyVersionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_KeyVersionSpec>): CertificateAuthority_KeyVersionSpec {
    const message = createBaseCertificateAuthority_KeyVersionSpec();
    message.cloudKmsKeyVersion = object.cloudKmsKeyVersion ?? undefined;
    message.algorithm = object.algorithm ?? undefined;
    return message;
  },
};

function createBaseCertificateAuthority_LabelsEntry(): CertificateAuthority_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateAuthority_LabelsEntry: MessageFns<CertificateAuthority_LabelsEntry> = {
  encode(message: CertificateAuthority_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateAuthority_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_LabelsEntry>): CertificateAuthority_LabelsEntry {
    return CertificateAuthority_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_LabelsEntry>): CertificateAuthority_LabelsEntry {
    const message = createBaseCertificateAuthority_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCaPool(): CaPool {
  return { name: "", tier: 0, issuancePolicy: undefined, publishingOptions: undefined, labels: {} };
}

export const CaPool: MessageFns<CaPool> = {
  encode(message: CaPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tier !== 0) {
      writer.uint32(16).int32(message.tier);
    }
    if (message.issuancePolicy !== undefined) {
      CaPool_IssuancePolicy.encode(message.issuancePolicy, writer.uint32(26).fork()).join();
    }
    if (message.publishingOptions !== undefined) {
      CaPool_PublishingOptions.encode(message.publishingOptions, writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CaPool_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issuancePolicy = CaPool_IssuancePolicy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.publishingOptions = CaPool_PublishingOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = CaPool_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tier: isSet(object.tier) ? caPool_TierFromJSON(object.tier) : 0,
      issuancePolicy: isSet(object.issuancePolicy) ? CaPool_IssuancePolicy.fromJSON(object.issuancePolicy) : undefined,
      publishingOptions: isSet(object.publishingOptions)
        ? CaPool_PublishingOptions.fromJSON(object.publishingOptions)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CaPool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tier !== 0) {
      obj.tier = caPool_TierToJSON(message.tier);
    }
    if (message.issuancePolicy !== undefined) {
      obj.issuancePolicy = CaPool_IssuancePolicy.toJSON(message.issuancePolicy);
    }
    if (message.publishingOptions !== undefined) {
      obj.publishingOptions = CaPool_PublishingOptions.toJSON(message.publishingOptions);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool>): CaPool {
    return CaPool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool>): CaPool {
    const message = createBaseCaPool();
    message.name = object.name ?? "";
    message.tier = object.tier ?? 0;
    message.issuancePolicy = (object.issuancePolicy !== undefined && object.issuancePolicy !== null)
      ? CaPool_IssuancePolicy.fromPartial(object.issuancePolicy)
      : undefined;
    message.publishingOptions = (object.publishingOptions !== undefined && object.publishingOptions !== null)
      ? CaPool_PublishingOptions.fromPartial(object.publishingOptions)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCaPool_PublishingOptions(): CaPool_PublishingOptions {
  return { publishCaCert: false, publishCrl: false, encodingFormat: 0 };
}

export const CaPool_PublishingOptions: MessageFns<CaPool_PublishingOptions> = {
  encode(message: CaPool_PublishingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publishCaCert !== false) {
      writer.uint32(8).bool(message.publishCaCert);
    }
    if (message.publishCrl !== false) {
      writer.uint32(16).bool(message.publishCrl);
    }
    if (message.encodingFormat !== 0) {
      writer.uint32(24).int32(message.encodingFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_PublishingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_PublishingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.publishCaCert = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.publishCrl = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.encodingFormat = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_PublishingOptions {
    return {
      publishCaCert: isSet(object.publishCaCert) ? globalThis.Boolean(object.publishCaCert) : false,
      publishCrl: isSet(object.publishCrl) ? globalThis.Boolean(object.publishCrl) : false,
      encodingFormat: isSet(object.encodingFormat)
        ? caPool_PublishingOptions_EncodingFormatFromJSON(object.encodingFormat)
        : 0,
    };
  },

  toJSON(message: CaPool_PublishingOptions): unknown {
    const obj: any = {};
    if (message.publishCaCert !== false) {
      obj.publishCaCert = message.publishCaCert;
    }
    if (message.publishCrl !== false) {
      obj.publishCrl = message.publishCrl;
    }
    if (message.encodingFormat !== 0) {
      obj.encodingFormat = caPool_PublishingOptions_EncodingFormatToJSON(message.encodingFormat);
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool_PublishingOptions>): CaPool_PublishingOptions {
    return CaPool_PublishingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool_PublishingOptions>): CaPool_PublishingOptions {
    const message = createBaseCaPool_PublishingOptions();
    message.publishCaCert = object.publishCaCert ?? false;
    message.publishCrl = object.publishCrl ?? false;
    message.encodingFormat = object.encodingFormat ?? 0;
    return message;
  },
};

function createBaseCaPool_IssuancePolicy(): CaPool_IssuancePolicy {
  return {
    allowedKeyTypes: [],
    maximumLifetime: undefined,
    allowedIssuanceModes: undefined,
    baselineValues: undefined,
    identityConstraints: undefined,
    passthroughExtensions: undefined,
  };
}

export const CaPool_IssuancePolicy: MessageFns<CaPool_IssuancePolicy> = {
  encode(message: CaPool_IssuancePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedKeyTypes) {
      CaPool_IssuancePolicy_AllowedKeyType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.maximumLifetime !== undefined) {
      Duration.encode(message.maximumLifetime, writer.uint32(18).fork()).join();
    }
    if (message.allowedIssuanceModes !== undefined) {
      CaPool_IssuancePolicy_IssuanceModes.encode(message.allowedIssuanceModes, writer.uint32(26).fork()).join();
    }
    if (message.baselineValues !== undefined) {
      X509Parameters.encode(message.baselineValues, writer.uint32(34).fork()).join();
    }
    if (message.identityConstraints !== undefined) {
      CertificateIdentityConstraints.encode(message.identityConstraints, writer.uint32(42).fork()).join();
    }
    if (message.passthroughExtensions !== undefined) {
      CertificateExtensionConstraints.encode(message.passthroughExtensions, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_IssuancePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_IssuancePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedKeyTypes.push(CaPool_IssuancePolicy_AllowedKeyType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maximumLifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowedIssuanceModes = CaPool_IssuancePolicy_IssuanceModes.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baselineValues = X509Parameters.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.identityConstraints = CertificateIdentityConstraints.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.passthroughExtensions = CertificateExtensionConstraints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_IssuancePolicy {
    return {
      allowedKeyTypes: globalThis.Array.isArray(object?.allowedKeyTypes)
        ? object.allowedKeyTypes.map((e: any) => CaPool_IssuancePolicy_AllowedKeyType.fromJSON(e))
        : [],
      maximumLifetime: isSet(object.maximumLifetime) ? Duration.fromJSON(object.maximumLifetime) : undefined,
      allowedIssuanceModes: isSet(object.allowedIssuanceModes)
        ? CaPool_IssuancePolicy_IssuanceModes.fromJSON(object.allowedIssuanceModes)
        : undefined,
      baselineValues: isSet(object.baselineValues) ? X509Parameters.fromJSON(object.baselineValues) : undefined,
      identityConstraints: isSet(object.identityConstraints)
        ? CertificateIdentityConstraints.fromJSON(object.identityConstraints)
        : undefined,
      passthroughExtensions: isSet(object.passthroughExtensions)
        ? CertificateExtensionConstraints.fromJSON(object.passthroughExtensions)
        : undefined,
    };
  },

  toJSON(message: CaPool_IssuancePolicy): unknown {
    const obj: any = {};
    if (message.allowedKeyTypes?.length) {
      obj.allowedKeyTypes = message.allowedKeyTypes.map((e) => CaPool_IssuancePolicy_AllowedKeyType.toJSON(e));
    }
    if (message.maximumLifetime !== undefined) {
      obj.maximumLifetime = Duration.toJSON(message.maximumLifetime);
    }
    if (message.allowedIssuanceModes !== undefined) {
      obj.allowedIssuanceModes = CaPool_IssuancePolicy_IssuanceModes.toJSON(message.allowedIssuanceModes);
    }
    if (message.baselineValues !== undefined) {
      obj.baselineValues = X509Parameters.toJSON(message.baselineValues);
    }
    if (message.identityConstraints !== undefined) {
      obj.identityConstraints = CertificateIdentityConstraints.toJSON(message.identityConstraints);
    }
    if (message.passthroughExtensions !== undefined) {
      obj.passthroughExtensions = CertificateExtensionConstraints.toJSON(message.passthroughExtensions);
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool_IssuancePolicy>): CaPool_IssuancePolicy {
    return CaPool_IssuancePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool_IssuancePolicy>): CaPool_IssuancePolicy {
    const message = createBaseCaPool_IssuancePolicy();
    message.allowedKeyTypes = object.allowedKeyTypes?.map((e) => CaPool_IssuancePolicy_AllowedKeyType.fromPartial(e)) ||
      [];
    message.maximumLifetime = (object.maximumLifetime !== undefined && object.maximumLifetime !== null)
      ? Duration.fromPartial(object.maximumLifetime)
      : undefined;
    message.allowedIssuanceModes = (object.allowedIssuanceModes !== undefined && object.allowedIssuanceModes !== null)
      ? CaPool_IssuancePolicy_IssuanceModes.fromPartial(object.allowedIssuanceModes)
      : undefined;
    message.baselineValues = (object.baselineValues !== undefined && object.baselineValues !== null)
      ? X509Parameters.fromPartial(object.baselineValues)
      : undefined;
    message.identityConstraints = (object.identityConstraints !== undefined && object.identityConstraints !== null)
      ? CertificateIdentityConstraints.fromPartial(object.identityConstraints)
      : undefined;
    message.passthroughExtensions =
      (object.passthroughExtensions !== undefined && object.passthroughExtensions !== null)
        ? CertificateExtensionConstraints.fromPartial(object.passthroughExtensions)
        : undefined;
    return message;
  },
};

function createBaseCaPool_IssuancePolicy_AllowedKeyType(): CaPool_IssuancePolicy_AllowedKeyType {
  return { rsa: undefined, ellipticCurve: undefined };
}

export const CaPool_IssuancePolicy_AllowedKeyType: MessageFns<CaPool_IssuancePolicy_AllowedKeyType> = {
  encode(message: CaPool_IssuancePolicy_AllowedKeyType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rsa !== undefined) {
      CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.encode(message.rsa, writer.uint32(10).fork()).join();
    }
    if (message.ellipticCurve !== undefined) {
      CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.encode(message.ellipticCurve, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_IssuancePolicy_AllowedKeyType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rsa = CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ellipticCurve = CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_IssuancePolicy_AllowedKeyType {
    return {
      rsa: isSet(object.rsa) ? CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.fromJSON(object.rsa) : undefined,
      ellipticCurve: isSet(object.ellipticCurve)
        ? CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.fromJSON(object.ellipticCurve)
        : undefined,
    };
  },

  toJSON(message: CaPool_IssuancePolicy_AllowedKeyType): unknown {
    const obj: any = {};
    if (message.rsa !== undefined) {
      obj.rsa = CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.toJSON(message.rsa);
    }
    if (message.ellipticCurve !== undefined) {
      obj.ellipticCurve = CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.toJSON(message.ellipticCurve);
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType>): CaPool_IssuancePolicy_AllowedKeyType {
    return CaPool_IssuancePolicy_AllowedKeyType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType>): CaPool_IssuancePolicy_AllowedKeyType {
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType();
    message.rsa = (object.rsa !== undefined && object.rsa !== null)
      ? CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.fromPartial(object.rsa)
      : undefined;
    message.ellipticCurve = (object.ellipticCurve !== undefined && object.ellipticCurve !== null)
      ? CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.fromPartial(object.ellipticCurve)
      : undefined;
    return message;
  },
};

function createBaseCaPool_IssuancePolicy_AllowedKeyType_RsaKeyType(): CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
  return { minModulusSize: Long.ZERO, maxModulusSize: Long.ZERO };
}

export const CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType: MessageFns<
  CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType
> = {
  encode(
    message: CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.minModulusSize.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.minModulusSize.toString());
    }
    if (!message.maxModulusSize.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxModulusSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType_RsaKeyType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minModulusSize = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxModulusSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
    return {
      minModulusSize: isSet(object.minModulusSize) ? Long.fromValue(object.minModulusSize) : Long.ZERO,
      maxModulusSize: isSet(object.maxModulusSize) ? Long.fromValue(object.maxModulusSize) : Long.ZERO,
    };
  },

  toJSON(message: CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType): unknown {
    const obj: any = {};
    if (!message.minModulusSize.equals(Long.ZERO)) {
      obj.minModulusSize = (message.minModulusSize || Long.ZERO).toString();
    }
    if (!message.maxModulusSize.equals(Long.ZERO)) {
      obj.maxModulusSize = (message.maxModulusSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType>,
  ): CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
    return CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType>,
  ): CaPool_IssuancePolicy_AllowedKeyType_RsaKeyType {
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType_RsaKeyType();
    message.minModulusSize = (object.minModulusSize !== undefined && object.minModulusSize !== null)
      ? Long.fromValue(object.minModulusSize)
      : Long.ZERO;
    message.maxModulusSize = (object.maxModulusSize !== undefined && object.maxModulusSize !== null)
      ? Long.fromValue(object.maxModulusSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseCaPool_IssuancePolicy_AllowedKeyType_EcKeyType(): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
  return { signatureAlgorithm: 0 };
}

export const CaPool_IssuancePolicy_AllowedKeyType_EcKeyType: MessageFns<
  CaPool_IssuancePolicy_AllowedKeyType_EcKeyType
> = {
  encode(
    message: CaPool_IssuancePolicy_AllowedKeyType_EcKeyType,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.signatureAlgorithm !== 0) {
      writer.uint32(8).int32(message.signatureAlgorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType_EcKeyType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.signatureAlgorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
    return {
      signatureAlgorithm: isSet(object.signatureAlgorithm)
        ? caPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithmFromJSON(object.signatureAlgorithm)
        : 0,
    };
  },

  toJSON(message: CaPool_IssuancePolicy_AllowedKeyType_EcKeyType): unknown {
    const obj: any = {};
    if (message.signatureAlgorithm !== 0) {
      obj.signatureAlgorithm = caPool_IssuancePolicy_AllowedKeyType_EcKeyType_EcSignatureAlgorithmToJSON(
        message.signatureAlgorithm,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType_EcKeyType>,
  ): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
    return CaPool_IssuancePolicy_AllowedKeyType_EcKeyType.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CaPool_IssuancePolicy_AllowedKeyType_EcKeyType>,
  ): CaPool_IssuancePolicy_AllowedKeyType_EcKeyType {
    const message = createBaseCaPool_IssuancePolicy_AllowedKeyType_EcKeyType();
    message.signatureAlgorithm = object.signatureAlgorithm ?? 0;
    return message;
  },
};

function createBaseCaPool_IssuancePolicy_IssuanceModes(): CaPool_IssuancePolicy_IssuanceModes {
  return { allowCsrBasedIssuance: false, allowConfigBasedIssuance: false };
}

export const CaPool_IssuancePolicy_IssuanceModes: MessageFns<CaPool_IssuancePolicy_IssuanceModes> = {
  encode(message: CaPool_IssuancePolicy_IssuanceModes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowCsrBasedIssuance !== false) {
      writer.uint32(8).bool(message.allowCsrBasedIssuance);
    }
    if (message.allowConfigBasedIssuance !== false) {
      writer.uint32(16).bool(message.allowConfigBasedIssuance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_IssuancePolicy_IssuanceModes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_IssuancePolicy_IssuanceModes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowCsrBasedIssuance = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowConfigBasedIssuance = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_IssuancePolicy_IssuanceModes {
    return {
      allowCsrBasedIssuance: isSet(object.allowCsrBasedIssuance)
        ? globalThis.Boolean(object.allowCsrBasedIssuance)
        : false,
      allowConfigBasedIssuance: isSet(object.allowConfigBasedIssuance)
        ? globalThis.Boolean(object.allowConfigBasedIssuance)
        : false,
    };
  },

  toJSON(message: CaPool_IssuancePolicy_IssuanceModes): unknown {
    const obj: any = {};
    if (message.allowCsrBasedIssuance !== false) {
      obj.allowCsrBasedIssuance = message.allowCsrBasedIssuance;
    }
    if (message.allowConfigBasedIssuance !== false) {
      obj.allowConfigBasedIssuance = message.allowConfigBasedIssuance;
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool_IssuancePolicy_IssuanceModes>): CaPool_IssuancePolicy_IssuanceModes {
    return CaPool_IssuancePolicy_IssuanceModes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool_IssuancePolicy_IssuanceModes>): CaPool_IssuancePolicy_IssuanceModes {
    const message = createBaseCaPool_IssuancePolicy_IssuanceModes();
    message.allowCsrBasedIssuance = object.allowCsrBasedIssuance ?? false;
    message.allowConfigBasedIssuance = object.allowConfigBasedIssuance ?? false;
    return message;
  },
};

function createBaseCaPool_LabelsEntry(): CaPool_LabelsEntry {
  return { key: "", value: "" };
}

export const CaPool_LabelsEntry: MessageFns<CaPool_LabelsEntry> = {
  encode(message: CaPool_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaPool_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaPool_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaPool_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CaPool_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CaPool_LabelsEntry>): CaPool_LabelsEntry {
    return CaPool_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CaPool_LabelsEntry>): CaPool_LabelsEntry {
    const message = createBaseCaPool_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateRevocationList(): CertificateRevocationList {
  return {
    name: "",
    sequenceNumber: Long.ZERO,
    revokedCertificates: [],
    pemCrl: "",
    accessUrl: "",
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    revisionId: "",
    labels: {},
  };
}

export const CertificateRevocationList: MessageFns<CertificateRevocationList> = {
  encode(message: CertificateRevocationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.sequenceNumber.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sequenceNumber.toString());
    }
    for (const v of message.revokedCertificates) {
      CertificateRevocationList_RevokedCertificate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pemCrl !== "") {
      writer.uint32(34).string(message.pemCrl);
    }
    if (message.accessUrl !== "") {
      writer.uint32(42).string(message.accessUrl);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.revisionId !== "") {
      writer.uint32(74).string(message.revisionId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateRevocationList_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.revokedCertificates.push(
            CertificateRevocationList_RevokedCertificate.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pemCrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accessUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = CertificateRevocationList_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? Long.fromValue(object.sequenceNumber) : Long.ZERO,
      revokedCertificates: globalThis.Array.isArray(object?.revokedCertificates)
        ? object.revokedCertificates.map((e: any) => CertificateRevocationList_RevokedCertificate.fromJSON(e))
        : [],
      pemCrl: isSet(object.pemCrl) ? globalThis.String(object.pemCrl) : "",
      accessUrl: isSet(object.accessUrl) ? globalThis.String(object.accessUrl) : "",
      state: isSet(object.state) ? certificateRevocationList_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CertificateRevocationList): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.sequenceNumber.equals(Long.ZERO)) {
      obj.sequenceNumber = (message.sequenceNumber || Long.ZERO).toString();
    }
    if (message.revokedCertificates?.length) {
      obj.revokedCertificates = message.revokedCertificates.map((e) =>
        CertificateRevocationList_RevokedCertificate.toJSON(e)
      );
    }
    if (message.pemCrl !== "") {
      obj.pemCrl = message.pemCrl;
    }
    if (message.accessUrl !== "") {
      obj.accessUrl = message.accessUrl;
    }
    if (message.state !== 0) {
      obj.state = certificateRevocationList_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateRevocationList>): CertificateRevocationList {
    return CertificateRevocationList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateRevocationList>): CertificateRevocationList {
    const message = createBaseCertificateRevocationList();
    message.name = object.name ?? "";
    message.sequenceNumber = (object.sequenceNumber !== undefined && object.sequenceNumber !== null)
      ? Long.fromValue(object.sequenceNumber)
      : Long.ZERO;
    message.revokedCertificates =
      object.revokedCertificates?.map((e) => CertificateRevocationList_RevokedCertificate.fromPartial(e)) || [];
    message.pemCrl = object.pemCrl ?? "";
    message.accessUrl = object.accessUrl ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.revisionId = object.revisionId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificateRevocationList_RevokedCertificate(): CertificateRevocationList_RevokedCertificate {
  return { certificate: "", hexSerialNumber: "", revocationReason: 0 };
}

export const CertificateRevocationList_RevokedCertificate: MessageFns<CertificateRevocationList_RevokedCertificate> = {
  encode(
    message: CertificateRevocationList_RevokedCertificate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.certificate !== "") {
      writer.uint32(10).string(message.certificate);
    }
    if (message.hexSerialNumber !== "") {
      writer.uint32(18).string(message.hexSerialNumber);
    }
    if (message.revocationReason !== 0) {
      writer.uint32(24).int32(message.revocationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList_RevokedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList_RevokedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hexSerialNumber = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.revocationReason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList_RevokedCertificate {
    return {
      certificate: isSet(object.certificate) ? globalThis.String(object.certificate) : "",
      hexSerialNumber: isSet(object.hexSerialNumber) ? globalThis.String(object.hexSerialNumber) : "",
      revocationReason: isSet(object.revocationReason) ? revocationReasonFromJSON(object.revocationReason) : 0,
    };
  },

  toJSON(message: CertificateRevocationList_RevokedCertificate): unknown {
    const obj: any = {};
    if (message.certificate !== "") {
      obj.certificate = message.certificate;
    }
    if (message.hexSerialNumber !== "") {
      obj.hexSerialNumber = message.hexSerialNumber;
    }
    if (message.revocationReason !== 0) {
      obj.revocationReason = revocationReasonToJSON(message.revocationReason);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateRevocationList_RevokedCertificate>,
  ): CertificateRevocationList_RevokedCertificate {
    return CertificateRevocationList_RevokedCertificate.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateRevocationList_RevokedCertificate>,
  ): CertificateRevocationList_RevokedCertificate {
    const message = createBaseCertificateRevocationList_RevokedCertificate();
    message.certificate = object.certificate ?? "";
    message.hexSerialNumber = object.hexSerialNumber ?? "";
    message.revocationReason = object.revocationReason ?? 0;
    return message;
  },
};

function createBaseCertificateRevocationList_LabelsEntry(): CertificateRevocationList_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateRevocationList_LabelsEntry: MessageFns<CertificateRevocationList_LabelsEntry> = {
  encode(message: CertificateRevocationList_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateRevocationList_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateRevocationList_LabelsEntry>): CertificateRevocationList_LabelsEntry {
    return CertificateRevocationList_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateRevocationList_LabelsEntry>): CertificateRevocationList_LabelsEntry {
    const message = createBaseCertificateRevocationList_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificate(): Certificate {
  return {
    name: "",
    pemCsr: undefined,
    config: undefined,
    issuerCertificateAuthority: "",
    lifetime: undefined,
    certificateTemplate: "",
    subjectMode: 0,
    revocationDetails: undefined,
    pemCertificate: "",
    certificateDescription: undefined,
    pemCertificateChain: [],
    createTime: undefined,
    updateTime: undefined,
    labels: {},
  };
}

export const Certificate: MessageFns<Certificate> = {
  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pemCsr !== undefined) {
      writer.uint32(18).string(message.pemCsr);
    }
    if (message.config !== undefined) {
      CertificateConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.issuerCertificateAuthority !== "") {
      writer.uint32(34).string(message.issuerCertificateAuthority);
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(42).fork()).join();
    }
    if (message.certificateTemplate !== "") {
      writer.uint32(50).string(message.certificateTemplate);
    }
    if (message.subjectMode !== 0) {
      writer.uint32(56).int32(message.subjectMode);
    }
    if (message.revocationDetails !== undefined) {
      Certificate_RevocationDetails.encode(message.revocationDetails, writer.uint32(66).fork()).join();
    }
    if (message.pemCertificate !== "") {
      writer.uint32(74).string(message.pemCertificate);
    }
    if (message.certificateDescription !== undefined) {
      CertificateDescription.encode(message.certificateDescription, writer.uint32(82).fork()).join();
    }
    for (const v of message.pemCertificateChain) {
      writer.uint32(90).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(98).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(106).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Certificate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pemCsr = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = CertificateConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.issuerCertificateAuthority = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.certificateTemplate = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.subjectMode = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.revocationDetails = Certificate_RevocationDetails.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pemCertificate = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.certificateDescription = CertificateDescription.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pemCertificateChain.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = Certificate_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pemCsr: isSet(object.pemCsr) ? globalThis.String(object.pemCsr) : undefined,
      config: isSet(object.config) ? CertificateConfig.fromJSON(object.config) : undefined,
      issuerCertificateAuthority: isSet(object.issuerCertificateAuthority)
        ? globalThis.String(object.issuerCertificateAuthority)
        : "",
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      certificateTemplate: isSet(object.certificateTemplate) ? globalThis.String(object.certificateTemplate) : "",
      subjectMode: isSet(object.subjectMode) ? subjectRequestModeFromJSON(object.subjectMode) : 0,
      revocationDetails: isSet(object.revocationDetails)
        ? Certificate_RevocationDetails.fromJSON(object.revocationDetails)
        : undefined,
      pemCertificate: isSet(object.pemCertificate) ? globalThis.String(object.pemCertificate) : "",
      certificateDescription: isSet(object.certificateDescription)
        ? CertificateDescription.fromJSON(object.certificateDescription)
        : undefined,
      pemCertificateChain: globalThis.Array.isArray(object?.pemCertificateChain)
        ? object.pemCertificateChain.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pemCsr !== undefined) {
      obj.pemCsr = message.pemCsr;
    }
    if (message.config !== undefined) {
      obj.config = CertificateConfig.toJSON(message.config);
    }
    if (message.issuerCertificateAuthority !== "") {
      obj.issuerCertificateAuthority = message.issuerCertificateAuthority;
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.certificateTemplate !== "") {
      obj.certificateTemplate = message.certificateTemplate;
    }
    if (message.subjectMode !== 0) {
      obj.subjectMode = subjectRequestModeToJSON(message.subjectMode);
    }
    if (message.revocationDetails !== undefined) {
      obj.revocationDetails = Certificate_RevocationDetails.toJSON(message.revocationDetails);
    }
    if (message.pemCertificate !== "") {
      obj.pemCertificate = message.pemCertificate;
    }
    if (message.certificateDescription !== undefined) {
      obj.certificateDescription = CertificateDescription.toJSON(message.certificateDescription);
    }
    if (message.pemCertificateChain?.length) {
      obj.pemCertificateChain = message.pemCertificateChain;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate>): Certificate {
    return Certificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate>): Certificate {
    const message = createBaseCertificate();
    message.name = object.name ?? "";
    message.pemCsr = object.pemCsr ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? CertificateConfig.fromPartial(object.config)
      : undefined;
    message.issuerCertificateAuthority = object.issuerCertificateAuthority ?? "";
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.certificateTemplate = object.certificateTemplate ?? "";
    message.subjectMode = object.subjectMode ?? 0;
    message.revocationDetails = (object.revocationDetails !== undefined && object.revocationDetails !== null)
      ? Certificate_RevocationDetails.fromPartial(object.revocationDetails)
      : undefined;
    message.pemCertificate = object.pemCertificate ?? "";
    message.certificateDescription =
      (object.certificateDescription !== undefined && object.certificateDescription !== null)
        ? CertificateDescription.fromPartial(object.certificateDescription)
        : undefined;
    message.pemCertificateChain = object.pemCertificateChain?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificate_RevocationDetails(): Certificate_RevocationDetails {
  return { revocationState: 0, revocationTime: undefined };
}

export const Certificate_RevocationDetails: MessageFns<Certificate_RevocationDetails> = {
  encode(message: Certificate_RevocationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revocationState !== 0) {
      writer.uint32(8).int32(message.revocationState);
    }
    if (message.revocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revocationTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_RevocationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_RevocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.revocationState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_RevocationDetails {
    return {
      revocationState: isSet(object.revocationState) ? revocationReasonFromJSON(object.revocationState) : 0,
      revocationTime: isSet(object.revocationTime) ? fromJsonTimestamp(object.revocationTime) : undefined,
    };
  },

  toJSON(message: Certificate_RevocationDetails): unknown {
    const obj: any = {};
    if (message.revocationState !== 0) {
      obj.revocationState = revocationReasonToJSON(message.revocationState);
    }
    if (message.revocationTime !== undefined) {
      obj.revocationTime = message.revocationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_RevocationDetails>): Certificate_RevocationDetails {
    return Certificate_RevocationDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_RevocationDetails>): Certificate_RevocationDetails {
    const message = createBaseCertificate_RevocationDetails();
    message.revocationState = object.revocationState ?? 0;
    message.revocationTime = object.revocationTime ?? undefined;
    return message;
  },
};

function createBaseCertificate_LabelsEntry(): Certificate_LabelsEntry {
  return { key: "", value: "" };
}

export const Certificate_LabelsEntry: MessageFns<Certificate_LabelsEntry> = {
  encode(message: Certificate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Certificate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    return Certificate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    const message = createBaseCertificate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateTemplate(): CertificateTemplate {
  return {
    name: "",
    maximumLifetime: undefined,
    predefinedValues: undefined,
    identityConstraints: undefined,
    passthroughExtensions: undefined,
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
  };
}

export const CertificateTemplate: MessageFns<CertificateTemplate> = {
  encode(message: CertificateTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.maximumLifetime !== undefined) {
      Duration.encode(message.maximumLifetime, writer.uint32(74).fork()).join();
    }
    if (message.predefinedValues !== undefined) {
      X509Parameters.encode(message.predefinedValues, writer.uint32(18).fork()).join();
    }
    if (message.identityConstraints !== undefined) {
      CertificateIdentityConstraints.encode(message.identityConstraints, writer.uint32(26).fork()).join();
    }
    if (message.passthroughExtensions !== undefined) {
      CertificateExtensionConstraints.encode(message.passthroughExtensions, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateTemplate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.maximumLifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predefinedValues = X509Parameters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.identityConstraints = CertificateIdentityConstraints.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.passthroughExtensions = CertificateExtensionConstraints.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = CertificateTemplate_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maximumLifetime: isSet(object.maximumLifetime) ? Duration.fromJSON(object.maximumLifetime) : undefined,
      predefinedValues: isSet(object.predefinedValues) ? X509Parameters.fromJSON(object.predefinedValues) : undefined,
      identityConstraints: isSet(object.identityConstraints)
        ? CertificateIdentityConstraints.fromJSON(object.identityConstraints)
        : undefined,
      passthroughExtensions: isSet(object.passthroughExtensions)
        ? CertificateExtensionConstraints.fromJSON(object.passthroughExtensions)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CertificateTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maximumLifetime !== undefined) {
      obj.maximumLifetime = Duration.toJSON(message.maximumLifetime);
    }
    if (message.predefinedValues !== undefined) {
      obj.predefinedValues = X509Parameters.toJSON(message.predefinedValues);
    }
    if (message.identityConstraints !== undefined) {
      obj.identityConstraints = CertificateIdentityConstraints.toJSON(message.identityConstraints);
    }
    if (message.passthroughExtensions !== undefined) {
      obj.passthroughExtensions = CertificateExtensionConstraints.toJSON(message.passthroughExtensions);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateTemplate>): CertificateTemplate {
    return CertificateTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateTemplate>): CertificateTemplate {
    const message = createBaseCertificateTemplate();
    message.name = object.name ?? "";
    message.maximumLifetime = (object.maximumLifetime !== undefined && object.maximumLifetime !== null)
      ? Duration.fromPartial(object.maximumLifetime)
      : undefined;
    message.predefinedValues = (object.predefinedValues !== undefined && object.predefinedValues !== null)
      ? X509Parameters.fromPartial(object.predefinedValues)
      : undefined;
    message.identityConstraints = (object.identityConstraints !== undefined && object.identityConstraints !== null)
      ? CertificateIdentityConstraints.fromPartial(object.identityConstraints)
      : undefined;
    message.passthroughExtensions =
      (object.passthroughExtensions !== undefined && object.passthroughExtensions !== null)
        ? CertificateExtensionConstraints.fromPartial(object.passthroughExtensions)
        : undefined;
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificateTemplate_LabelsEntry(): CertificateTemplate_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateTemplate_LabelsEntry: MessageFns<CertificateTemplate_LabelsEntry> = {
  encode(message: CertificateTemplate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateTemplate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateTemplate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateTemplate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateTemplate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateTemplate_LabelsEntry>): CertificateTemplate_LabelsEntry {
    return CertificateTemplate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateTemplate_LabelsEntry>): CertificateTemplate_LabelsEntry {
    const message = createBaseCertificateTemplate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseX509Parameters(): X509Parameters {
  return {
    keyUsage: undefined,
    caOptions: undefined,
    policyIds: [],
    aiaOcspServers: [],
    nameConstraints: undefined,
    additionalExtensions: [],
  };
}

export const X509Parameters: MessageFns<X509Parameters> = {
  encode(message: X509Parameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyUsage !== undefined) {
      KeyUsage.encode(message.keyUsage, writer.uint32(10).fork()).join();
    }
    if (message.caOptions !== undefined) {
      X509Parameters_CaOptions.encode(message.caOptions, writer.uint32(18).fork()).join();
    }
    for (const v of message.policyIds) {
      ObjectId.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.aiaOcspServers) {
      writer.uint32(34).string(v!);
    }
    if (message.nameConstraints !== undefined) {
      X509Parameters_NameConstraints.encode(message.nameConstraints, writer.uint32(50).fork()).join();
    }
    for (const v of message.additionalExtensions) {
      X509Extension.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509Parameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509Parameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyUsage = KeyUsage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.caOptions = X509Parameters_CaOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyIds.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aiaOcspServers.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nameConstraints = X509Parameters_NameConstraints.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additionalExtensions.push(X509Extension.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509Parameters {
    return {
      keyUsage: isSet(object.keyUsage) ? KeyUsage.fromJSON(object.keyUsage) : undefined,
      caOptions: isSet(object.caOptions) ? X509Parameters_CaOptions.fromJSON(object.caOptions) : undefined,
      policyIds: globalThis.Array.isArray(object?.policyIds)
        ? object.policyIds.map((e: any) => ObjectId.fromJSON(e))
        : [],
      aiaOcspServers: globalThis.Array.isArray(object?.aiaOcspServers)
        ? object.aiaOcspServers.map((e: any) => globalThis.String(e))
        : [],
      nameConstraints: isSet(object.nameConstraints)
        ? X509Parameters_NameConstraints.fromJSON(object.nameConstraints)
        : undefined,
      additionalExtensions: globalThis.Array.isArray(object?.additionalExtensions)
        ? object.additionalExtensions.map((e: any) => X509Extension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: X509Parameters): unknown {
    const obj: any = {};
    if (message.keyUsage !== undefined) {
      obj.keyUsage = KeyUsage.toJSON(message.keyUsage);
    }
    if (message.caOptions !== undefined) {
      obj.caOptions = X509Parameters_CaOptions.toJSON(message.caOptions);
    }
    if (message.policyIds?.length) {
      obj.policyIds = message.policyIds.map((e) => ObjectId.toJSON(e));
    }
    if (message.aiaOcspServers?.length) {
      obj.aiaOcspServers = message.aiaOcspServers;
    }
    if (message.nameConstraints !== undefined) {
      obj.nameConstraints = X509Parameters_NameConstraints.toJSON(message.nameConstraints);
    }
    if (message.additionalExtensions?.length) {
      obj.additionalExtensions = message.additionalExtensions.map((e) => X509Extension.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<X509Parameters>): X509Parameters {
    return X509Parameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509Parameters>): X509Parameters {
    const message = createBaseX509Parameters();
    message.keyUsage = (object.keyUsage !== undefined && object.keyUsage !== null)
      ? KeyUsage.fromPartial(object.keyUsage)
      : undefined;
    message.caOptions = (object.caOptions !== undefined && object.caOptions !== null)
      ? X509Parameters_CaOptions.fromPartial(object.caOptions)
      : undefined;
    message.policyIds = object.policyIds?.map((e) => ObjectId.fromPartial(e)) || [];
    message.aiaOcspServers = object.aiaOcspServers?.map((e) => e) || [];
    message.nameConstraints = (object.nameConstraints !== undefined && object.nameConstraints !== null)
      ? X509Parameters_NameConstraints.fromPartial(object.nameConstraints)
      : undefined;
    message.additionalExtensions = object.additionalExtensions?.map((e) => X509Extension.fromPartial(e)) || [];
    return message;
  },
};

function createBaseX509Parameters_CaOptions(): X509Parameters_CaOptions {
  return { isCa: undefined, maxIssuerPathLength: undefined };
}

export const X509Parameters_CaOptions: MessageFns<X509Parameters_CaOptions> = {
  encode(message: X509Parameters_CaOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isCa !== undefined) {
      writer.uint32(8).bool(message.isCa);
    }
    if (message.maxIssuerPathLength !== undefined) {
      writer.uint32(16).int32(message.maxIssuerPathLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509Parameters_CaOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509Parameters_CaOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isCa = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxIssuerPathLength = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509Parameters_CaOptions {
    return {
      isCa: isSet(object.isCa) ? globalThis.Boolean(object.isCa) : undefined,
      maxIssuerPathLength: isSet(object.maxIssuerPathLength)
        ? globalThis.Number(object.maxIssuerPathLength)
        : undefined,
    };
  },

  toJSON(message: X509Parameters_CaOptions): unknown {
    const obj: any = {};
    if (message.isCa !== undefined) {
      obj.isCa = message.isCa;
    }
    if (message.maxIssuerPathLength !== undefined) {
      obj.maxIssuerPathLength = Math.round(message.maxIssuerPathLength);
    }
    return obj;
  },

  create(base?: DeepPartial<X509Parameters_CaOptions>): X509Parameters_CaOptions {
    return X509Parameters_CaOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509Parameters_CaOptions>): X509Parameters_CaOptions {
    const message = createBaseX509Parameters_CaOptions();
    message.isCa = object.isCa ?? undefined;
    message.maxIssuerPathLength = object.maxIssuerPathLength ?? undefined;
    return message;
  },
};

function createBaseX509Parameters_NameConstraints(): X509Parameters_NameConstraints {
  return {
    critical: false,
    permittedDnsNames: [],
    excludedDnsNames: [],
    permittedIpRanges: [],
    excludedIpRanges: [],
    permittedEmailAddresses: [],
    excludedEmailAddresses: [],
    permittedUris: [],
    excludedUris: [],
  };
}

export const X509Parameters_NameConstraints: MessageFns<X509Parameters_NameConstraints> = {
  encode(message: X509Parameters_NameConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.critical !== false) {
      writer.uint32(8).bool(message.critical);
    }
    for (const v of message.permittedDnsNames) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.excludedDnsNames) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.permittedIpRanges) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.excludedIpRanges) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.permittedEmailAddresses) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.excludedEmailAddresses) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.permittedUris) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.excludedUris) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509Parameters_NameConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509Parameters_NameConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.critical = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permittedDnsNames.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludedDnsNames.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.permittedIpRanges.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.excludedIpRanges.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.permittedEmailAddresses.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.excludedEmailAddresses.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.permittedUris.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.excludedUris.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509Parameters_NameConstraints {
    return {
      critical: isSet(object.critical) ? globalThis.Boolean(object.critical) : false,
      permittedDnsNames: globalThis.Array.isArray(object?.permittedDnsNames)
        ? object.permittedDnsNames.map((e: any) => globalThis.String(e))
        : [],
      excludedDnsNames: globalThis.Array.isArray(object?.excludedDnsNames)
        ? object.excludedDnsNames.map((e: any) => globalThis.String(e))
        : [],
      permittedIpRanges: globalThis.Array.isArray(object?.permittedIpRanges)
        ? object.permittedIpRanges.map((e: any) => globalThis.String(e))
        : [],
      excludedIpRanges: globalThis.Array.isArray(object?.excludedIpRanges)
        ? object.excludedIpRanges.map((e: any) => globalThis.String(e))
        : [],
      permittedEmailAddresses: globalThis.Array.isArray(object?.permittedEmailAddresses)
        ? object.permittedEmailAddresses.map((e: any) => globalThis.String(e))
        : [],
      excludedEmailAddresses: globalThis.Array.isArray(object?.excludedEmailAddresses)
        ? object.excludedEmailAddresses.map((e: any) => globalThis.String(e))
        : [],
      permittedUris: globalThis.Array.isArray(object?.permittedUris)
        ? object.permittedUris.map((e: any) => globalThis.String(e))
        : [],
      excludedUris: globalThis.Array.isArray(object?.excludedUris)
        ? object.excludedUris.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: X509Parameters_NameConstraints): unknown {
    const obj: any = {};
    if (message.critical !== false) {
      obj.critical = message.critical;
    }
    if (message.permittedDnsNames?.length) {
      obj.permittedDnsNames = message.permittedDnsNames;
    }
    if (message.excludedDnsNames?.length) {
      obj.excludedDnsNames = message.excludedDnsNames;
    }
    if (message.permittedIpRanges?.length) {
      obj.permittedIpRanges = message.permittedIpRanges;
    }
    if (message.excludedIpRanges?.length) {
      obj.excludedIpRanges = message.excludedIpRanges;
    }
    if (message.permittedEmailAddresses?.length) {
      obj.permittedEmailAddresses = message.permittedEmailAddresses;
    }
    if (message.excludedEmailAddresses?.length) {
      obj.excludedEmailAddresses = message.excludedEmailAddresses;
    }
    if (message.permittedUris?.length) {
      obj.permittedUris = message.permittedUris;
    }
    if (message.excludedUris?.length) {
      obj.excludedUris = message.excludedUris;
    }
    return obj;
  },

  create(base?: DeepPartial<X509Parameters_NameConstraints>): X509Parameters_NameConstraints {
    return X509Parameters_NameConstraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509Parameters_NameConstraints>): X509Parameters_NameConstraints {
    const message = createBaseX509Parameters_NameConstraints();
    message.critical = object.critical ?? false;
    message.permittedDnsNames = object.permittedDnsNames?.map((e) => e) || [];
    message.excludedDnsNames = object.excludedDnsNames?.map((e) => e) || [];
    message.permittedIpRanges = object.permittedIpRanges?.map((e) => e) || [];
    message.excludedIpRanges = object.excludedIpRanges?.map((e) => e) || [];
    message.permittedEmailAddresses = object.permittedEmailAddresses?.map((e) => e) || [];
    message.excludedEmailAddresses = object.excludedEmailAddresses?.map((e) => e) || [];
    message.permittedUris = object.permittedUris?.map((e) => e) || [];
    message.excludedUris = object.excludedUris?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubordinateConfig(): SubordinateConfig {
  return { certificateAuthority: undefined, pemIssuerChain: undefined };
}

export const SubordinateConfig: MessageFns<SubordinateConfig> = {
  encode(message: SubordinateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificateAuthority !== undefined) {
      writer.uint32(10).string(message.certificateAuthority);
    }
    if (message.pemIssuerChain !== undefined) {
      SubordinateConfig_SubordinateConfigChain.encode(message.pemIssuerChain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubordinateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubordinateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateAuthority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pemIssuerChain = SubordinateConfig_SubordinateConfigChain.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubordinateConfig {
    return {
      certificateAuthority: isSet(object.certificateAuthority)
        ? globalThis.String(object.certificateAuthority)
        : undefined,
      pemIssuerChain: isSet(object.pemIssuerChain)
        ? SubordinateConfig_SubordinateConfigChain.fromJSON(object.pemIssuerChain)
        : undefined,
    };
  },

  toJSON(message: SubordinateConfig): unknown {
    const obj: any = {};
    if (message.certificateAuthority !== undefined) {
      obj.certificateAuthority = message.certificateAuthority;
    }
    if (message.pemIssuerChain !== undefined) {
      obj.pemIssuerChain = SubordinateConfig_SubordinateConfigChain.toJSON(message.pemIssuerChain);
    }
    return obj;
  },

  create(base?: DeepPartial<SubordinateConfig>): SubordinateConfig {
    return SubordinateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubordinateConfig>): SubordinateConfig {
    const message = createBaseSubordinateConfig();
    message.certificateAuthority = object.certificateAuthority ?? undefined;
    message.pemIssuerChain = (object.pemIssuerChain !== undefined && object.pemIssuerChain !== null)
      ? SubordinateConfig_SubordinateConfigChain.fromPartial(object.pemIssuerChain)
      : undefined;
    return message;
  },
};

function createBaseSubordinateConfig_SubordinateConfigChain(): SubordinateConfig_SubordinateConfigChain {
  return { pemCertificates: [] };
}

export const SubordinateConfig_SubordinateConfigChain: MessageFns<SubordinateConfig_SubordinateConfigChain> = {
  encode(message: SubordinateConfig_SubordinateConfigChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pemCertificates) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubordinateConfig_SubordinateConfigChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubordinateConfig_SubordinateConfigChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pemCertificates.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubordinateConfig_SubordinateConfigChain {
    return {
      pemCertificates: globalThis.Array.isArray(object?.pemCertificates)
        ? object.pemCertificates.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubordinateConfig_SubordinateConfigChain): unknown {
    const obj: any = {};
    if (message.pemCertificates?.length) {
      obj.pemCertificates = message.pemCertificates;
    }
    return obj;
  },

  create(base?: DeepPartial<SubordinateConfig_SubordinateConfigChain>): SubordinateConfig_SubordinateConfigChain {
    return SubordinateConfig_SubordinateConfigChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubordinateConfig_SubordinateConfigChain>): SubordinateConfig_SubordinateConfigChain {
    const message = createBaseSubordinateConfig_SubordinateConfigChain();
    message.pemCertificates = object.pemCertificates?.map((e) => e) || [];
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { key: Buffer.alloc(0), format: 0 };
}

export const PublicKey: MessageFns<PublicKey> = {
  encode(message: PublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.format !== 0) {
      writer.uint32(16).int32(message.format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return {
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
      format: isSet(object.format) ? publicKey_KeyFormatFromJSON(object.format) : 0,
    };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.format !== 0) {
      obj.format = publicKey_KeyFormatToJSON(message.format);
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKey>): PublicKey {
    return PublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKey>): PublicKey {
    const message = createBasePublicKey();
    message.key = object.key ?? Buffer.alloc(0);
    message.format = object.format ?? 0;
    return message;
  },
};

function createBaseCertificateConfig(): CertificateConfig {
  return { subjectConfig: undefined, x509Config: undefined, publicKey: undefined, subjectKeyId: undefined };
}

export const CertificateConfig: MessageFns<CertificateConfig> = {
  encode(message: CertificateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectConfig !== undefined) {
      CertificateConfig_SubjectConfig.encode(message.subjectConfig, writer.uint32(10).fork()).join();
    }
    if (message.x509Config !== undefined) {
      X509Parameters.encode(message.x509Config, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== undefined) {
      PublicKey.encode(message.publicKey, writer.uint32(26).fork()).join();
    }
    if (message.subjectKeyId !== undefined) {
      CertificateConfig_KeyId.encode(message.subjectKeyId, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectConfig = CertificateConfig_SubjectConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.x509Config = X509Parameters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = PublicKey.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjectKeyId = CertificateConfig_KeyId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateConfig {
    return {
      subjectConfig: isSet(object.subjectConfig)
        ? CertificateConfig_SubjectConfig.fromJSON(object.subjectConfig)
        : undefined,
      x509Config: isSet(object.x509Config) ? X509Parameters.fromJSON(object.x509Config) : undefined,
      publicKey: isSet(object.publicKey) ? PublicKey.fromJSON(object.publicKey) : undefined,
      subjectKeyId: isSet(object.subjectKeyId) ? CertificateConfig_KeyId.fromJSON(object.subjectKeyId) : undefined,
    };
  },

  toJSON(message: CertificateConfig): unknown {
    const obj: any = {};
    if (message.subjectConfig !== undefined) {
      obj.subjectConfig = CertificateConfig_SubjectConfig.toJSON(message.subjectConfig);
    }
    if (message.x509Config !== undefined) {
      obj.x509Config = X509Parameters.toJSON(message.x509Config);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKey.toJSON(message.publicKey);
    }
    if (message.subjectKeyId !== undefined) {
      obj.subjectKeyId = CertificateConfig_KeyId.toJSON(message.subjectKeyId);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateConfig>): CertificateConfig {
    return CertificateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateConfig>): CertificateConfig {
    const message = createBaseCertificateConfig();
    message.subjectConfig = (object.subjectConfig !== undefined && object.subjectConfig !== null)
      ? CertificateConfig_SubjectConfig.fromPartial(object.subjectConfig)
      : undefined;
    message.x509Config = (object.x509Config !== undefined && object.x509Config !== null)
      ? X509Parameters.fromPartial(object.x509Config)
      : undefined;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKey.fromPartial(object.publicKey)
      : undefined;
    message.subjectKeyId = (object.subjectKeyId !== undefined && object.subjectKeyId !== null)
      ? CertificateConfig_KeyId.fromPartial(object.subjectKeyId)
      : undefined;
    return message;
  },
};

function createBaseCertificateConfig_SubjectConfig(): CertificateConfig_SubjectConfig {
  return { subject: undefined, subjectAltName: undefined };
}

export const CertificateConfig_SubjectConfig: MessageFns<CertificateConfig_SubjectConfig> = {
  encode(message: CertificateConfig_SubjectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(10).fork()).join();
    }
    if (message.subjectAltName !== undefined) {
      SubjectAltNames.encode(message.subjectAltName, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateConfig_SubjectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateConfig_SubjectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subjectAltName = SubjectAltNames.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateConfig_SubjectConfig {
    return {
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      subjectAltName: isSet(object.subjectAltName) ? SubjectAltNames.fromJSON(object.subjectAltName) : undefined,
    };
  },

  toJSON(message: CertificateConfig_SubjectConfig): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.subjectAltName !== undefined) {
      obj.subjectAltName = SubjectAltNames.toJSON(message.subjectAltName);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateConfig_SubjectConfig>): CertificateConfig_SubjectConfig {
    return CertificateConfig_SubjectConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateConfig_SubjectConfig>): CertificateConfig_SubjectConfig {
    const message = createBaseCertificateConfig_SubjectConfig();
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.subjectAltName = (object.subjectAltName !== undefined && object.subjectAltName !== null)
      ? SubjectAltNames.fromPartial(object.subjectAltName)
      : undefined;
    return message;
  },
};

function createBaseCertificateConfig_KeyId(): CertificateConfig_KeyId {
  return { keyId: "" };
}

export const CertificateConfig_KeyId: MessageFns<CertificateConfig_KeyId> = {
  encode(message: CertificateConfig_KeyId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateConfig_KeyId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateConfig_KeyId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateConfig_KeyId {
    return { keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "" };
  },

  toJSON(message: CertificateConfig_KeyId): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateConfig_KeyId>): CertificateConfig_KeyId {
    return CertificateConfig_KeyId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateConfig_KeyId>): CertificateConfig_KeyId {
    const message = createBaseCertificateConfig_KeyId();
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseCertificateDescription(): CertificateDescription {
  return {
    subjectDescription: undefined,
    x509Description: undefined,
    publicKey: undefined,
    subjectKeyId: undefined,
    authorityKeyId: undefined,
    crlDistributionPoints: [],
    aiaIssuingCertificateUrls: [],
    certFingerprint: undefined,
  };
}

export const CertificateDescription: MessageFns<CertificateDescription> = {
  encode(message: CertificateDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectDescription !== undefined) {
      CertificateDescription_SubjectDescription.encode(message.subjectDescription, writer.uint32(10).fork()).join();
    }
    if (message.x509Description !== undefined) {
      X509Parameters.encode(message.x509Description, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== undefined) {
      PublicKey.encode(message.publicKey, writer.uint32(26).fork()).join();
    }
    if (message.subjectKeyId !== undefined) {
      CertificateDescription_KeyId.encode(message.subjectKeyId, writer.uint32(34).fork()).join();
    }
    if (message.authorityKeyId !== undefined) {
      CertificateDescription_KeyId.encode(message.authorityKeyId, writer.uint32(42).fork()).join();
    }
    for (const v of message.crlDistributionPoints) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.aiaIssuingCertificateUrls) {
      writer.uint32(58).string(v!);
    }
    if (message.certFingerprint !== undefined) {
      CertificateDescription_CertificateFingerprint.encode(message.certFingerprint, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectDescription = CertificateDescription_SubjectDescription.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.x509Description = X509Parameters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = PublicKey.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjectKeyId = CertificateDescription_KeyId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorityKeyId = CertificateDescription_KeyId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.crlDistributionPoints.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.aiaIssuingCertificateUrls.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.certFingerprint = CertificateDescription_CertificateFingerprint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription {
    return {
      subjectDescription: isSet(object.subjectDescription)
        ? CertificateDescription_SubjectDescription.fromJSON(object.subjectDescription)
        : undefined,
      x509Description: isSet(object.x509Description) ? X509Parameters.fromJSON(object.x509Description) : undefined,
      publicKey: isSet(object.publicKey) ? PublicKey.fromJSON(object.publicKey) : undefined,
      subjectKeyId: isSet(object.subjectKeyId) ? CertificateDescription_KeyId.fromJSON(object.subjectKeyId) : undefined,
      authorityKeyId: isSet(object.authorityKeyId)
        ? CertificateDescription_KeyId.fromJSON(object.authorityKeyId)
        : undefined,
      crlDistributionPoints: globalThis.Array.isArray(object?.crlDistributionPoints)
        ? object.crlDistributionPoints.map((e: any) => globalThis.String(e))
        : [],
      aiaIssuingCertificateUrls: globalThis.Array.isArray(object?.aiaIssuingCertificateUrls)
        ? object.aiaIssuingCertificateUrls.map((e: any) => globalThis.String(e))
        : [],
      certFingerprint: isSet(object.certFingerprint)
        ? CertificateDescription_CertificateFingerprint.fromJSON(object.certFingerprint)
        : undefined,
    };
  },

  toJSON(message: CertificateDescription): unknown {
    const obj: any = {};
    if (message.subjectDescription !== undefined) {
      obj.subjectDescription = CertificateDescription_SubjectDescription.toJSON(message.subjectDescription);
    }
    if (message.x509Description !== undefined) {
      obj.x509Description = X509Parameters.toJSON(message.x509Description);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKey.toJSON(message.publicKey);
    }
    if (message.subjectKeyId !== undefined) {
      obj.subjectKeyId = CertificateDescription_KeyId.toJSON(message.subjectKeyId);
    }
    if (message.authorityKeyId !== undefined) {
      obj.authorityKeyId = CertificateDescription_KeyId.toJSON(message.authorityKeyId);
    }
    if (message.crlDistributionPoints?.length) {
      obj.crlDistributionPoints = message.crlDistributionPoints;
    }
    if (message.aiaIssuingCertificateUrls?.length) {
      obj.aiaIssuingCertificateUrls = message.aiaIssuingCertificateUrls;
    }
    if (message.certFingerprint !== undefined) {
      obj.certFingerprint = CertificateDescription_CertificateFingerprint.toJSON(message.certFingerprint);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription>): CertificateDescription {
    return CertificateDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateDescription>): CertificateDescription {
    const message = createBaseCertificateDescription();
    message.subjectDescription = (object.subjectDescription !== undefined && object.subjectDescription !== null)
      ? CertificateDescription_SubjectDescription.fromPartial(object.subjectDescription)
      : undefined;
    message.x509Description = (object.x509Description !== undefined && object.x509Description !== null)
      ? X509Parameters.fromPartial(object.x509Description)
      : undefined;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKey.fromPartial(object.publicKey)
      : undefined;
    message.subjectKeyId = (object.subjectKeyId !== undefined && object.subjectKeyId !== null)
      ? CertificateDescription_KeyId.fromPartial(object.subjectKeyId)
      : undefined;
    message.authorityKeyId = (object.authorityKeyId !== undefined && object.authorityKeyId !== null)
      ? CertificateDescription_KeyId.fromPartial(object.authorityKeyId)
      : undefined;
    message.crlDistributionPoints = object.crlDistributionPoints?.map((e) => e) || [];
    message.aiaIssuingCertificateUrls = object.aiaIssuingCertificateUrls?.map((e) => e) || [];
    message.certFingerprint = (object.certFingerprint !== undefined && object.certFingerprint !== null)
      ? CertificateDescription_CertificateFingerprint.fromPartial(object.certFingerprint)
      : undefined;
    return message;
  },
};

function createBaseCertificateDescription_SubjectDescription(): CertificateDescription_SubjectDescription {
  return {
    subject: undefined,
    subjectAltName: undefined,
    hexSerialNumber: "",
    lifetime: undefined,
    notBeforeTime: undefined,
    notAfterTime: undefined,
  };
}

export const CertificateDescription_SubjectDescription: MessageFns<CertificateDescription_SubjectDescription> = {
  encode(message: CertificateDescription_SubjectDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(10).fork()).join();
    }
    if (message.subjectAltName !== undefined) {
      SubjectAltNames.encode(message.subjectAltName, writer.uint32(18).fork()).join();
    }
    if (message.hexSerialNumber !== "") {
      writer.uint32(26).string(message.hexSerialNumber);
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(34).fork()).join();
    }
    if (message.notBeforeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notBeforeTime), writer.uint32(42).fork()).join();
    }
    if (message.notAfterTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notAfterTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_SubjectDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription_SubjectDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subjectAltName = SubjectAltNames.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hexSerialNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.notBeforeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notAfterTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription_SubjectDescription {
    return {
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      subjectAltName: isSet(object.subjectAltName) ? SubjectAltNames.fromJSON(object.subjectAltName) : undefined,
      hexSerialNumber: isSet(object.hexSerialNumber) ? globalThis.String(object.hexSerialNumber) : "",
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      notBeforeTime: isSet(object.notBeforeTime) ? fromJsonTimestamp(object.notBeforeTime) : undefined,
      notAfterTime: isSet(object.notAfterTime) ? fromJsonTimestamp(object.notAfterTime) : undefined,
    };
  },

  toJSON(message: CertificateDescription_SubjectDescription): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.subjectAltName !== undefined) {
      obj.subjectAltName = SubjectAltNames.toJSON(message.subjectAltName);
    }
    if (message.hexSerialNumber !== "") {
      obj.hexSerialNumber = message.hexSerialNumber;
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.notBeforeTime !== undefined) {
      obj.notBeforeTime = message.notBeforeTime.toISOString();
    }
    if (message.notAfterTime !== undefined) {
      obj.notAfterTime = message.notAfterTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription_SubjectDescription>): CertificateDescription_SubjectDescription {
    return CertificateDescription_SubjectDescription.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateDescription_SubjectDescription>,
  ): CertificateDescription_SubjectDescription {
    const message = createBaseCertificateDescription_SubjectDescription();
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.subjectAltName = (object.subjectAltName !== undefined && object.subjectAltName !== null)
      ? SubjectAltNames.fromPartial(object.subjectAltName)
      : undefined;
    message.hexSerialNumber = object.hexSerialNumber ?? "";
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.notBeforeTime = object.notBeforeTime ?? undefined;
    message.notAfterTime = object.notAfterTime ?? undefined;
    return message;
  },
};

function createBaseCertificateDescription_KeyId(): CertificateDescription_KeyId {
  return { keyId: "" };
}

export const CertificateDescription_KeyId: MessageFns<CertificateDescription_KeyId> = {
  encode(message: CertificateDescription_KeyId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_KeyId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription_KeyId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription_KeyId {
    return { keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "" };
  },

  toJSON(message: CertificateDescription_KeyId): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription_KeyId>): CertificateDescription_KeyId {
    return CertificateDescription_KeyId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateDescription_KeyId>): CertificateDescription_KeyId {
    const message = createBaseCertificateDescription_KeyId();
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseCertificateDescription_CertificateFingerprint(): CertificateDescription_CertificateFingerprint {
  return { sha256Hash: "" };
}

export const CertificateDescription_CertificateFingerprint: MessageFns<CertificateDescription_CertificateFingerprint> =
  {
    encode(
      message: CertificateDescription_CertificateFingerprint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.sha256Hash !== "") {
        writer.uint32(10).string(message.sha256Hash);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_CertificateFingerprint {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCertificateDescription_CertificateFingerprint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.sha256Hash = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CertificateDescription_CertificateFingerprint {
      return { sha256Hash: isSet(object.sha256Hash) ? globalThis.String(object.sha256Hash) : "" };
    },

    toJSON(message: CertificateDescription_CertificateFingerprint): unknown {
      const obj: any = {};
      if (message.sha256Hash !== "") {
        obj.sha256Hash = message.sha256Hash;
      }
      return obj;
    },

    create(
      base?: DeepPartial<CertificateDescription_CertificateFingerprint>,
    ): CertificateDescription_CertificateFingerprint {
      return CertificateDescription_CertificateFingerprint.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CertificateDescription_CertificateFingerprint>,
    ): CertificateDescription_CertificateFingerprint {
      const message = createBaseCertificateDescription_CertificateFingerprint();
      message.sha256Hash = object.sha256Hash ?? "";
      return message;
    },
  };

function createBaseObjectId(): ObjectId {
  return { objectIdPath: [] };
}

export const ObjectId: MessageFns<ObjectId> = {
  encode(message: ObjectId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.objectIdPath) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.objectIdPath.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.objectIdPath.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectId {
    return {
      objectIdPath: globalThis.Array.isArray(object?.objectIdPath)
        ? object.objectIdPath.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ObjectId): unknown {
    const obj: any = {};
    if (message.objectIdPath?.length) {
      obj.objectIdPath = message.objectIdPath.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectId>): ObjectId {
    return ObjectId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectId>): ObjectId {
    const message = createBaseObjectId();
    message.objectIdPath = object.objectIdPath?.map((e) => e) || [];
    return message;
  },
};

function createBaseX509Extension(): X509Extension {
  return { objectId: undefined, critical: false, value: Buffer.alloc(0) };
}

export const X509Extension: MessageFns<X509Extension> = {
  encode(message: X509Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.objectId !== undefined) {
      ObjectId.encode(message.objectId, writer.uint32(10).fork()).join();
    }
    if (message.critical !== false) {
      writer.uint32(16).bool(message.critical);
    }
    if (message.value.length !== 0) {
      writer.uint32(26).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509Extension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.objectId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.critical = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509Extension {
    return {
      objectId: isSet(object.objectId) ? ObjectId.fromJSON(object.objectId) : undefined,
      critical: isSet(object.critical) ? globalThis.Boolean(object.critical) : false,
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: X509Extension): unknown {
    const obj: any = {};
    if (message.objectId !== undefined) {
      obj.objectId = ObjectId.toJSON(message.objectId);
    }
    if (message.critical !== false) {
      obj.critical = message.critical;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<X509Extension>): X509Extension {
    return X509Extension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509Extension>): X509Extension {
    const message = createBaseX509Extension();
    message.objectId = (object.objectId !== undefined && object.objectId !== null)
      ? ObjectId.fromPartial(object.objectId)
      : undefined;
    message.critical = object.critical ?? false;
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseKeyUsage(): KeyUsage {
  return { baseKeyUsage: undefined, extendedKeyUsage: undefined, unknownExtendedKeyUsages: [] };
}

export const KeyUsage: MessageFns<KeyUsage> = {
  encode(message: KeyUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseKeyUsage !== undefined) {
      KeyUsage_KeyUsageOptions.encode(message.baseKeyUsage, writer.uint32(10).fork()).join();
    }
    if (message.extendedKeyUsage !== undefined) {
      KeyUsage_ExtendedKeyUsageOptions.encode(message.extendedKeyUsage, writer.uint32(18).fork()).join();
    }
    for (const v of message.unknownExtendedKeyUsages) {
      ObjectId.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseKeyUsage = KeyUsage_KeyUsageOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extendedKeyUsage = KeyUsage_ExtendedKeyUsageOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unknownExtendedKeyUsages.push(ObjectId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage {
    return {
      baseKeyUsage: isSet(object.baseKeyUsage) ? KeyUsage_KeyUsageOptions.fromJSON(object.baseKeyUsage) : undefined,
      extendedKeyUsage: isSet(object.extendedKeyUsage)
        ? KeyUsage_ExtendedKeyUsageOptions.fromJSON(object.extendedKeyUsage)
        : undefined,
      unknownExtendedKeyUsages: globalThis.Array.isArray(object?.unknownExtendedKeyUsages)
        ? object.unknownExtendedKeyUsages.map((e: any) => ObjectId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeyUsage): unknown {
    const obj: any = {};
    if (message.baseKeyUsage !== undefined) {
      obj.baseKeyUsage = KeyUsage_KeyUsageOptions.toJSON(message.baseKeyUsage);
    }
    if (message.extendedKeyUsage !== undefined) {
      obj.extendedKeyUsage = KeyUsage_ExtendedKeyUsageOptions.toJSON(message.extendedKeyUsage);
    }
    if (message.unknownExtendedKeyUsages?.length) {
      obj.unknownExtendedKeyUsages = message.unknownExtendedKeyUsages.map((e) => ObjectId.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage>): KeyUsage {
    return KeyUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage>): KeyUsage {
    const message = createBaseKeyUsage();
    message.baseKeyUsage = (object.baseKeyUsage !== undefined && object.baseKeyUsage !== null)
      ? KeyUsage_KeyUsageOptions.fromPartial(object.baseKeyUsage)
      : undefined;
    message.extendedKeyUsage = (object.extendedKeyUsage !== undefined && object.extendedKeyUsage !== null)
      ? KeyUsage_ExtendedKeyUsageOptions.fromPartial(object.extendedKeyUsage)
      : undefined;
    message.unknownExtendedKeyUsages = object.unknownExtendedKeyUsages?.map((e) => ObjectId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyUsage_KeyUsageOptions(): KeyUsage_KeyUsageOptions {
  return {
    digitalSignature: false,
    contentCommitment: false,
    keyEncipherment: false,
    dataEncipherment: false,
    keyAgreement: false,
    certSign: false,
    crlSign: false,
    encipherOnly: false,
    decipherOnly: false,
  };
}

export const KeyUsage_KeyUsageOptions: MessageFns<KeyUsage_KeyUsageOptions> = {
  encode(message: KeyUsage_KeyUsageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digitalSignature !== false) {
      writer.uint32(8).bool(message.digitalSignature);
    }
    if (message.contentCommitment !== false) {
      writer.uint32(16).bool(message.contentCommitment);
    }
    if (message.keyEncipherment !== false) {
      writer.uint32(24).bool(message.keyEncipherment);
    }
    if (message.dataEncipherment !== false) {
      writer.uint32(32).bool(message.dataEncipherment);
    }
    if (message.keyAgreement !== false) {
      writer.uint32(40).bool(message.keyAgreement);
    }
    if (message.certSign !== false) {
      writer.uint32(48).bool(message.certSign);
    }
    if (message.crlSign !== false) {
      writer.uint32(56).bool(message.crlSign);
    }
    if (message.encipherOnly !== false) {
      writer.uint32(64).bool(message.encipherOnly);
    }
    if (message.decipherOnly !== false) {
      writer.uint32(72).bool(message.decipherOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage_KeyUsageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage_KeyUsageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.digitalSignature = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contentCommitment = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keyEncipherment = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dataEncipherment = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.keyAgreement = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.certSign = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.crlSign = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.encipherOnly = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.decipherOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage_KeyUsageOptions {
    return {
      digitalSignature: isSet(object.digitalSignature) ? globalThis.Boolean(object.digitalSignature) : false,
      contentCommitment: isSet(object.contentCommitment) ? globalThis.Boolean(object.contentCommitment) : false,
      keyEncipherment: isSet(object.keyEncipherment) ? globalThis.Boolean(object.keyEncipherment) : false,
      dataEncipherment: isSet(object.dataEncipherment) ? globalThis.Boolean(object.dataEncipherment) : false,
      keyAgreement: isSet(object.keyAgreement) ? globalThis.Boolean(object.keyAgreement) : false,
      certSign: isSet(object.certSign) ? globalThis.Boolean(object.certSign) : false,
      crlSign: isSet(object.crlSign) ? globalThis.Boolean(object.crlSign) : false,
      encipherOnly: isSet(object.encipherOnly) ? globalThis.Boolean(object.encipherOnly) : false,
      decipherOnly: isSet(object.decipherOnly) ? globalThis.Boolean(object.decipherOnly) : false,
    };
  },

  toJSON(message: KeyUsage_KeyUsageOptions): unknown {
    const obj: any = {};
    if (message.digitalSignature !== false) {
      obj.digitalSignature = message.digitalSignature;
    }
    if (message.contentCommitment !== false) {
      obj.contentCommitment = message.contentCommitment;
    }
    if (message.keyEncipherment !== false) {
      obj.keyEncipherment = message.keyEncipherment;
    }
    if (message.dataEncipherment !== false) {
      obj.dataEncipherment = message.dataEncipherment;
    }
    if (message.keyAgreement !== false) {
      obj.keyAgreement = message.keyAgreement;
    }
    if (message.certSign !== false) {
      obj.certSign = message.certSign;
    }
    if (message.crlSign !== false) {
      obj.crlSign = message.crlSign;
    }
    if (message.encipherOnly !== false) {
      obj.encipherOnly = message.encipherOnly;
    }
    if (message.decipherOnly !== false) {
      obj.decipherOnly = message.decipherOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage_KeyUsageOptions>): KeyUsage_KeyUsageOptions {
    return KeyUsage_KeyUsageOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage_KeyUsageOptions>): KeyUsage_KeyUsageOptions {
    const message = createBaseKeyUsage_KeyUsageOptions();
    message.digitalSignature = object.digitalSignature ?? false;
    message.contentCommitment = object.contentCommitment ?? false;
    message.keyEncipherment = object.keyEncipherment ?? false;
    message.dataEncipherment = object.dataEncipherment ?? false;
    message.keyAgreement = object.keyAgreement ?? false;
    message.certSign = object.certSign ?? false;
    message.crlSign = object.crlSign ?? false;
    message.encipherOnly = object.encipherOnly ?? false;
    message.decipherOnly = object.decipherOnly ?? false;
    return message;
  },
};

function createBaseKeyUsage_ExtendedKeyUsageOptions(): KeyUsage_ExtendedKeyUsageOptions {
  return {
    serverAuth: false,
    clientAuth: false,
    codeSigning: false,
    emailProtection: false,
    timeStamping: false,
    ocspSigning: false,
  };
}

export const KeyUsage_ExtendedKeyUsageOptions: MessageFns<KeyUsage_ExtendedKeyUsageOptions> = {
  encode(message: KeyUsage_ExtendedKeyUsageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverAuth !== false) {
      writer.uint32(8).bool(message.serverAuth);
    }
    if (message.clientAuth !== false) {
      writer.uint32(16).bool(message.clientAuth);
    }
    if (message.codeSigning !== false) {
      writer.uint32(24).bool(message.codeSigning);
    }
    if (message.emailProtection !== false) {
      writer.uint32(32).bool(message.emailProtection);
    }
    if (message.timeStamping !== false) {
      writer.uint32(40).bool(message.timeStamping);
    }
    if (message.ocspSigning !== false) {
      writer.uint32(48).bool(message.ocspSigning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage_ExtendedKeyUsageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage_ExtendedKeyUsageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverAuth = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientAuth = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.codeSigning = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.emailProtection = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timeStamping = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ocspSigning = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage_ExtendedKeyUsageOptions {
    return {
      serverAuth: isSet(object.serverAuth) ? globalThis.Boolean(object.serverAuth) : false,
      clientAuth: isSet(object.clientAuth) ? globalThis.Boolean(object.clientAuth) : false,
      codeSigning: isSet(object.codeSigning) ? globalThis.Boolean(object.codeSigning) : false,
      emailProtection: isSet(object.emailProtection) ? globalThis.Boolean(object.emailProtection) : false,
      timeStamping: isSet(object.timeStamping) ? globalThis.Boolean(object.timeStamping) : false,
      ocspSigning: isSet(object.ocspSigning) ? globalThis.Boolean(object.ocspSigning) : false,
    };
  },

  toJSON(message: KeyUsage_ExtendedKeyUsageOptions): unknown {
    const obj: any = {};
    if (message.serverAuth !== false) {
      obj.serverAuth = message.serverAuth;
    }
    if (message.clientAuth !== false) {
      obj.clientAuth = message.clientAuth;
    }
    if (message.codeSigning !== false) {
      obj.codeSigning = message.codeSigning;
    }
    if (message.emailProtection !== false) {
      obj.emailProtection = message.emailProtection;
    }
    if (message.timeStamping !== false) {
      obj.timeStamping = message.timeStamping;
    }
    if (message.ocspSigning !== false) {
      obj.ocspSigning = message.ocspSigning;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage_ExtendedKeyUsageOptions>): KeyUsage_ExtendedKeyUsageOptions {
    return KeyUsage_ExtendedKeyUsageOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage_ExtendedKeyUsageOptions>): KeyUsage_ExtendedKeyUsageOptions {
    const message = createBaseKeyUsage_ExtendedKeyUsageOptions();
    message.serverAuth = object.serverAuth ?? false;
    message.clientAuth = object.clientAuth ?? false;
    message.codeSigning = object.codeSigning ?? false;
    message.emailProtection = object.emailProtection ?? false;
    message.timeStamping = object.timeStamping ?? false;
    message.ocspSigning = object.ocspSigning ?? false;
    return message;
  },
};

function createBaseSubject(): Subject {
  return {
    commonName: "",
    countryCode: "",
    organization: "",
    organizationalUnit: "",
    locality: "",
    province: "",
    streetAddress: "",
    postalCode: "",
  };
}

export const Subject: MessageFns<Subject> = {
  encode(message: Subject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commonName !== "") {
      writer.uint32(10).string(message.commonName);
    }
    if (message.countryCode !== "") {
      writer.uint32(18).string(message.countryCode);
    }
    if (message.organization !== "") {
      writer.uint32(26).string(message.organization);
    }
    if (message.organizationalUnit !== "") {
      writer.uint32(34).string(message.organizationalUnit);
    }
    if (message.locality !== "") {
      writer.uint32(42).string(message.locality);
    }
    if (message.province !== "") {
      writer.uint32(50).string(message.province);
    }
    if (message.streetAddress !== "") {
      writer.uint32(58).string(message.streetAddress);
    }
    if (message.postalCode !== "") {
      writer.uint32(66).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commonName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.organization = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.organizationalUnit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.locality = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.province = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.postalCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subject {
    return {
      commonName: isSet(object.commonName) ? globalThis.String(object.commonName) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      organizationalUnit: isSet(object.organizationalUnit) ? globalThis.String(object.organizationalUnit) : "",
      locality: isSet(object.locality) ? globalThis.String(object.locality) : "",
      province: isSet(object.province) ? globalThis.String(object.province) : "",
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
    };
  },

  toJSON(message: Subject): unknown {
    const obj: any = {};
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.organizationalUnit !== "") {
      obj.organizationalUnit = message.organizationalUnit;
    }
    if (message.locality !== "") {
      obj.locality = message.locality;
    }
    if (message.province !== "") {
      obj.province = message.province;
    }
    if (message.streetAddress !== "") {
      obj.streetAddress = message.streetAddress;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Subject>): Subject {
    return Subject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subject>): Subject {
    const message = createBaseSubject();
    message.commonName = object.commonName ?? "";
    message.countryCode = object.countryCode ?? "";
    message.organization = object.organization ?? "";
    message.organizationalUnit = object.organizationalUnit ?? "";
    message.locality = object.locality ?? "";
    message.province = object.province ?? "";
    message.streetAddress = object.streetAddress ?? "";
    message.postalCode = object.postalCode ?? "";
    return message;
  },
};

function createBaseSubjectAltNames(): SubjectAltNames {
  return { dnsNames: [], uris: [], emailAddresses: [], ipAddresses: [], customSans: [] };
}

export const SubjectAltNames: MessageFns<SubjectAltNames> = {
  encode(message: SubjectAltNames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dnsNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.uris) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.emailAddresses) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.ipAddresses) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.customSans) {
      X509Extension.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubjectAltNames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectAltNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dnsNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emailAddresses.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipAddresses.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customSans.push(X509Extension.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectAltNames {
    return {
      dnsNames: globalThis.Array.isArray(object?.dnsNames) ? object.dnsNames.map((e: any) => globalThis.String(e)) : [],
      uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [],
      emailAddresses: globalThis.Array.isArray(object?.emailAddresses)
        ? object.emailAddresses.map((e: any) => globalThis.String(e))
        : [],
      ipAddresses: globalThis.Array.isArray(object?.ipAddresses)
        ? object.ipAddresses.map((e: any) => globalThis.String(e))
        : [],
      customSans: globalThis.Array.isArray(object?.customSans)
        ? object.customSans.map((e: any) => X509Extension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubjectAltNames): unknown {
    const obj: any = {};
    if (message.dnsNames?.length) {
      obj.dnsNames = message.dnsNames;
    }
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    if (message.emailAddresses?.length) {
      obj.emailAddresses = message.emailAddresses;
    }
    if (message.ipAddresses?.length) {
      obj.ipAddresses = message.ipAddresses;
    }
    if (message.customSans?.length) {
      obj.customSans = message.customSans.map((e) => X509Extension.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubjectAltNames>): SubjectAltNames {
    return SubjectAltNames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubjectAltNames>): SubjectAltNames {
    const message = createBaseSubjectAltNames();
    message.dnsNames = object.dnsNames?.map((e) => e) || [];
    message.uris = object.uris?.map((e) => e) || [];
    message.emailAddresses = object.emailAddresses?.map((e) => e) || [];
    message.ipAddresses = object.ipAddresses?.map((e) => e) || [];
    message.customSans = object.customSans?.map((e) => X509Extension.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateIdentityConstraints(): CertificateIdentityConstraints {
  return { celExpression: undefined, allowSubjectPassthrough: undefined, allowSubjectAltNamesPassthrough: undefined };
}

export const CertificateIdentityConstraints: MessageFns<CertificateIdentityConstraints> = {
  encode(message: CertificateIdentityConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.celExpression !== undefined) {
      Expr.encode(message.celExpression, writer.uint32(10).fork()).join();
    }
    if (message.allowSubjectPassthrough !== undefined) {
      writer.uint32(16).bool(message.allowSubjectPassthrough);
    }
    if (message.allowSubjectAltNamesPassthrough !== undefined) {
      writer.uint32(24).bool(message.allowSubjectAltNamesPassthrough);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateIdentityConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateIdentityConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.celExpression = Expr.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowSubjectPassthrough = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowSubjectAltNamesPassthrough = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateIdentityConstraints {
    return {
      celExpression: isSet(object.celExpression) ? Expr.fromJSON(object.celExpression) : undefined,
      allowSubjectPassthrough: isSet(object.allowSubjectPassthrough)
        ? globalThis.Boolean(object.allowSubjectPassthrough)
        : undefined,
      allowSubjectAltNamesPassthrough: isSet(object.allowSubjectAltNamesPassthrough)
        ? globalThis.Boolean(object.allowSubjectAltNamesPassthrough)
        : undefined,
    };
  },

  toJSON(message: CertificateIdentityConstraints): unknown {
    const obj: any = {};
    if (message.celExpression !== undefined) {
      obj.celExpression = Expr.toJSON(message.celExpression);
    }
    if (message.allowSubjectPassthrough !== undefined) {
      obj.allowSubjectPassthrough = message.allowSubjectPassthrough;
    }
    if (message.allowSubjectAltNamesPassthrough !== undefined) {
      obj.allowSubjectAltNamesPassthrough = message.allowSubjectAltNamesPassthrough;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateIdentityConstraints>): CertificateIdentityConstraints {
    return CertificateIdentityConstraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateIdentityConstraints>): CertificateIdentityConstraints {
    const message = createBaseCertificateIdentityConstraints();
    message.celExpression = (object.celExpression !== undefined && object.celExpression !== null)
      ? Expr.fromPartial(object.celExpression)
      : undefined;
    message.allowSubjectPassthrough = object.allowSubjectPassthrough ?? undefined;
    message.allowSubjectAltNamesPassthrough = object.allowSubjectAltNamesPassthrough ?? undefined;
    return message;
  },
};

function createBaseCertificateExtensionConstraints(): CertificateExtensionConstraints {
  return { knownExtensions: [], additionalExtensions: [] };
}

export const CertificateExtensionConstraints: MessageFns<CertificateExtensionConstraints> = {
  encode(message: CertificateExtensionConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.knownExtensions) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.additionalExtensions) {
      ObjectId.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateExtensionConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateExtensionConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.knownExtensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.knownExtensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.additionalExtensions.push(ObjectId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateExtensionConstraints {
    return {
      knownExtensions: globalThis.Array.isArray(object?.knownExtensions)
        ? object.knownExtensions.map((e: any) => certificateExtensionConstraints_KnownCertificateExtensionFromJSON(e))
        : [],
      additionalExtensions: globalThis.Array.isArray(object?.additionalExtensions)
        ? object.additionalExtensions.map((e: any) => ObjectId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateExtensionConstraints): unknown {
    const obj: any = {};
    if (message.knownExtensions?.length) {
      obj.knownExtensions = message.knownExtensions.map((e) =>
        certificateExtensionConstraints_KnownCertificateExtensionToJSON(e)
      );
    }
    if (message.additionalExtensions?.length) {
      obj.additionalExtensions = message.additionalExtensions.map((e) => ObjectId.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateExtensionConstraints>): CertificateExtensionConstraints {
    return CertificateExtensionConstraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateExtensionConstraints>): CertificateExtensionConstraints {
    const message = createBaseCertificateExtensionConstraints();
    message.knownExtensions = object.knownExtensions?.map((e) => e) || [];
    message.additionalExtensions = object.additionalExtensions?.map((e) => ObjectId.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
