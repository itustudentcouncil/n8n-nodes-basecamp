// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkmanagement/v1beta1/trace.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.networkmanagement.v1beta1";

/**
 * Type of a load balancer. For more information, see [Summary of Google Cloud
 * load
 * balancers](https://cloud.google.com/load-balancing/docs/load-balancing-overview#summary-of-google-cloud-load-balancers).
 */
export enum LoadBalancerType {
  /**
   * LOAD_BALANCER_TYPE_UNSPECIFIED - Forwarding rule points to a different target than a load balancer or a
   * load balancer type is unknown.
   */
  LOAD_BALANCER_TYPE_UNSPECIFIED = 0,
  /** HTTPS_ADVANCED_LOAD_BALANCER - Global external HTTP(S) load balancer. */
  HTTPS_ADVANCED_LOAD_BALANCER = 1,
  /** HTTPS_LOAD_BALANCER - Global external HTTP(S) load balancer (classic) */
  HTTPS_LOAD_BALANCER = 2,
  /** REGIONAL_HTTPS_LOAD_BALANCER - Regional external HTTP(S) load balancer. */
  REGIONAL_HTTPS_LOAD_BALANCER = 3,
  /** INTERNAL_HTTPS_LOAD_BALANCER - Internal HTTP(S) load balancer. */
  INTERNAL_HTTPS_LOAD_BALANCER = 4,
  /** SSL_PROXY_LOAD_BALANCER - External SSL proxy load balancer. */
  SSL_PROXY_LOAD_BALANCER = 5,
  /** TCP_PROXY_LOAD_BALANCER - External TCP proxy load balancer. */
  TCP_PROXY_LOAD_BALANCER = 6,
  /** INTERNAL_TCP_PROXY_LOAD_BALANCER - Internal regional TCP proxy load balancer. */
  INTERNAL_TCP_PROXY_LOAD_BALANCER = 7,
  /** NETWORK_LOAD_BALANCER - External TCP/UDP Network load balancer. */
  NETWORK_LOAD_BALANCER = 8,
  /** LEGACY_NETWORK_LOAD_BALANCER - Target-pool based external TCP/UDP Network load balancer. */
  LEGACY_NETWORK_LOAD_BALANCER = 9,
  /** TCP_UDP_INTERNAL_LOAD_BALANCER - Internal TCP/UDP load balancer. */
  TCP_UDP_INTERNAL_LOAD_BALANCER = 10,
  UNRECOGNIZED = -1,
}

export function loadBalancerTypeFromJSON(object: any): LoadBalancerType {
  switch (object) {
    case 0:
    case "LOAD_BALANCER_TYPE_UNSPECIFIED":
      return LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED;
    case 1:
    case "HTTPS_ADVANCED_LOAD_BALANCER":
      return LoadBalancerType.HTTPS_ADVANCED_LOAD_BALANCER;
    case 2:
    case "HTTPS_LOAD_BALANCER":
      return LoadBalancerType.HTTPS_LOAD_BALANCER;
    case 3:
    case "REGIONAL_HTTPS_LOAD_BALANCER":
      return LoadBalancerType.REGIONAL_HTTPS_LOAD_BALANCER;
    case 4:
    case "INTERNAL_HTTPS_LOAD_BALANCER":
      return LoadBalancerType.INTERNAL_HTTPS_LOAD_BALANCER;
    case 5:
    case "SSL_PROXY_LOAD_BALANCER":
      return LoadBalancerType.SSL_PROXY_LOAD_BALANCER;
    case 6:
    case "TCP_PROXY_LOAD_BALANCER":
      return LoadBalancerType.TCP_PROXY_LOAD_BALANCER;
    case 7:
    case "INTERNAL_TCP_PROXY_LOAD_BALANCER":
      return LoadBalancerType.INTERNAL_TCP_PROXY_LOAD_BALANCER;
    case 8:
    case "NETWORK_LOAD_BALANCER":
      return LoadBalancerType.NETWORK_LOAD_BALANCER;
    case 9:
    case "LEGACY_NETWORK_LOAD_BALANCER":
      return LoadBalancerType.LEGACY_NETWORK_LOAD_BALANCER;
    case 10:
    case "TCP_UDP_INTERNAL_LOAD_BALANCER":
      return LoadBalancerType.TCP_UDP_INTERNAL_LOAD_BALANCER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerType.UNRECOGNIZED;
  }
}

export function loadBalancerTypeToJSON(object: LoadBalancerType): string {
  switch (object) {
    case LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED:
      return "LOAD_BALANCER_TYPE_UNSPECIFIED";
    case LoadBalancerType.HTTPS_ADVANCED_LOAD_BALANCER:
      return "HTTPS_ADVANCED_LOAD_BALANCER";
    case LoadBalancerType.HTTPS_LOAD_BALANCER:
      return "HTTPS_LOAD_BALANCER";
    case LoadBalancerType.REGIONAL_HTTPS_LOAD_BALANCER:
      return "REGIONAL_HTTPS_LOAD_BALANCER";
    case LoadBalancerType.INTERNAL_HTTPS_LOAD_BALANCER:
      return "INTERNAL_HTTPS_LOAD_BALANCER";
    case LoadBalancerType.SSL_PROXY_LOAD_BALANCER:
      return "SSL_PROXY_LOAD_BALANCER";
    case LoadBalancerType.TCP_PROXY_LOAD_BALANCER:
      return "TCP_PROXY_LOAD_BALANCER";
    case LoadBalancerType.INTERNAL_TCP_PROXY_LOAD_BALANCER:
      return "INTERNAL_TCP_PROXY_LOAD_BALANCER";
    case LoadBalancerType.NETWORK_LOAD_BALANCER:
      return "NETWORK_LOAD_BALANCER";
    case LoadBalancerType.LEGACY_NETWORK_LOAD_BALANCER:
      return "LEGACY_NETWORK_LOAD_BALANCER";
    case LoadBalancerType.TCP_UDP_INTERNAL_LOAD_BALANCER:
      return "TCP_UDP_INTERNAL_LOAD_BALANCER";
    case LoadBalancerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Trace represents one simulated packet forwarding path.
 *
 *   * Each trace contains multiple ordered steps.
 *   * Each step is in a particular state with associated configuration.
 *   * State is categorized as final or non-final states.
 *   * Each final state has a reason associated.
 *   * Each trace must end with a final state (the last step).
 * ```
 *   |---------------------Trace----------------------|
 *   Step1(State) Step2(State) ---  StepN(State(final))
 * ```
 */
export interface Trace {
  /**
   * Derived from the source and destination endpoints definition specified by
   * user request, and validated by the data plane model.
   * If there are multiple traces starting from different source locations, then
   * the endpoint_info may be different between traces.
   */
  endpointInfo:
    | EndpointInfo
    | undefined;
  /**
   * A trace of a test contains multiple steps from the initial state to the
   * final state (delivered, dropped, forwarded, or aborted).
   *
   * The steps are ordered by the processing sequence within the simulated
   * network state machine. It is critical to preserve the order of the steps
   * and avoid reordering or sorting them.
   */
  steps: Step[];
  /**
   * ID of trace. For forward traces, this ID is unique for each trace. For
   * return traces, it matches ID of associated forward trace. A single forward
   * trace can be associated with none, one or more than one return trace.
   */
  forwardTraceId: number;
}

/**
 * A simulated forwarding path is composed of multiple steps.
 * Each step has a well-defined state and an associated configuration.
 */
export interface Step {
  /** A description of the step. Usually this is a summary of the state. */
  description: string;
  /** Each step is in one of the pre-defined states. */
  state: Step_State;
  /** This is a step that leads to the final state Drop. */
  causesDrop: boolean;
  /** Project ID that contains the configuration this step is validating. */
  projectId: string;
  /** Display information of a Compute Engine instance. */
  instance?:
    | InstanceInfo
    | undefined;
  /** Display information of a Compute Engine firewall rule. */
  firewall?:
    | FirewallInfo
    | undefined;
  /** Display information of a Compute Engine route. */
  route?:
    | RouteInfo
    | undefined;
  /**
   * Display information of the source and destination under analysis.
   * The endpoint information in an intermediate state may differ with the
   * initial input, as it might be modified by state like NAT,
   * or Connection Proxy.
   */
  endpoint?:
    | EndpointInfo
    | undefined;
  /** Display information of a Google service */
  googleService?:
    | GoogleServiceInfo
    | undefined;
  /** Display information of a Compute Engine forwarding rule. */
  forwardingRule?:
    | ForwardingRuleInfo
    | undefined;
  /** Display information of a Compute Engine VPN gateway. */
  vpnGateway?:
    | VpnGatewayInfo
    | undefined;
  /** Display information of a Compute Engine VPN tunnel. */
  vpnTunnel?:
    | VpnTunnelInfo
    | undefined;
  /** Display information of a VPC connector. */
  vpcConnector?:
    | VpcConnectorInfo
    | undefined;
  /** Display information of the final state "deliver" and reason. */
  deliver?:
    | DeliverInfo
    | undefined;
  /** Display information of the final state "forward" and reason. */
  forward?:
    | ForwardInfo
    | undefined;
  /** Display information of the final state "abort" and reason. */
  abort?:
    | AbortInfo
    | undefined;
  /** Display information of the final state "drop" and reason. */
  drop?:
    | DropInfo
    | undefined;
  /**
   * Display information of the load balancers. Deprecated in favor of the
   * `load_balancer_backend_info` field, not used in new tests.
   *
   * @deprecated
   */
  loadBalancer?:
    | LoadBalancerInfo
    | undefined;
  /** Display information of a Google Cloud network. */
  network?:
    | NetworkInfo
    | undefined;
  /** Display information of a Google Kubernetes Engine cluster master. */
  gkeMaster?:
    | GKEMasterInfo
    | undefined;
  /** Display information of a Cloud SQL instance. */
  cloudSqlInstance?:
    | CloudSQLInstanceInfo
    | undefined;
  /** Display information of a Cloud Function. */
  cloudFunction?:
    | CloudFunctionInfo
    | undefined;
  /** Display information of an App Engine service version. */
  appEngineVersion?:
    | AppEngineVersionInfo
    | undefined;
  /** Display information of a Cloud Run revision. */
  cloudRunRevision?:
    | CloudRunRevisionInfo
    | undefined;
  /** Display information of a NAT. */
  nat?:
    | NatInfo
    | undefined;
  /** Display information of a ProxyConnection. */
  proxyConnection?:
    | ProxyConnectionInfo
    | undefined;
  /** Display information of a specific load balancer backend. */
  loadBalancerBackendInfo?:
    | LoadBalancerBackendInfo
    | undefined;
  /** Display information of a Storage Bucket. Used only for return traces. */
  storageBucket?: StorageBucketInfo | undefined;
}

/**
 * Type of states that are defined in the network state machine.
 * Each step in the packet trace is in a specific state.
 */
export enum Step_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * START_FROM_INSTANCE - Initial state: packet originating from a Compute Engine instance.
   * An InstanceInfo is populated with starting instance information.
   */
  START_FROM_INSTANCE = 1,
  /**
   * START_FROM_INTERNET - Initial state: packet originating from the internet.
   * The endpoint information is populated.
   */
  START_FROM_INTERNET = 2,
  /**
   * START_FROM_GOOGLE_SERVICE - Initial state: packet originating from a Google service.
   * The google_service information is populated.
   */
  START_FROM_GOOGLE_SERVICE = 27,
  /**
   * START_FROM_PRIVATE_NETWORK - Initial state: packet originating from a VPC or on-premises network
   * with internal source IP.
   * If the source is a VPC network visible to the user, a NetworkInfo
   * is populated with details of the network.
   */
  START_FROM_PRIVATE_NETWORK = 3,
  /**
   * START_FROM_GKE_MASTER - Initial state: packet originating from a Google Kubernetes Engine cluster
   * master. A GKEMasterInfo is populated with starting instance information.
   */
  START_FROM_GKE_MASTER = 21,
  /**
   * START_FROM_CLOUD_SQL_INSTANCE - Initial state: packet originating from a Cloud SQL instance.
   * A CloudSQLInstanceInfo is populated with starting instance information.
   */
  START_FROM_CLOUD_SQL_INSTANCE = 22,
  /**
   * START_FROM_CLOUD_FUNCTION - Initial state: packet originating from a Cloud Function.
   * A CloudFunctionInfo is populated with starting function information.
   */
  START_FROM_CLOUD_FUNCTION = 23,
  /**
   * START_FROM_APP_ENGINE_VERSION - Initial state: packet originating from an App Engine service version.
   * An AppEngineVersionInfo is populated with starting version information.
   */
  START_FROM_APP_ENGINE_VERSION = 25,
  /**
   * START_FROM_CLOUD_RUN_REVISION - Initial state: packet originating from a Cloud Run revision.
   * A CloudRunRevisionInfo is populated with starting revision information.
   */
  START_FROM_CLOUD_RUN_REVISION = 26,
  /**
   * START_FROM_STORAGE_BUCKET - Initial state: packet originating from a Storage Bucket. Used only for
   * return traces.
   * The storage_bucket information is populated.
   */
  START_FROM_STORAGE_BUCKET = 29,
  /**
   * START_FROM_PSC_PUBLISHED_SERVICE - Initial state: packet originating from a published service that uses
   * Private Service Connect. Used only for return traces.
   */
  START_FROM_PSC_PUBLISHED_SERVICE = 30,
  /** APPLY_INGRESS_FIREWALL_RULE - Config checking state: verify ingress firewall rule. */
  APPLY_INGRESS_FIREWALL_RULE = 4,
  /** APPLY_EGRESS_FIREWALL_RULE - Config checking state: verify egress firewall rule. */
  APPLY_EGRESS_FIREWALL_RULE = 5,
  /** APPLY_ROUTE - Config checking state: verify route. */
  APPLY_ROUTE = 6,
  /** APPLY_FORWARDING_RULE - Config checking state: match forwarding rule. */
  APPLY_FORWARDING_RULE = 7,
  /** ANALYZE_LOAD_BALANCER_BACKEND - Config checking state: verify load balancer backend configuration. */
  ANALYZE_LOAD_BALANCER_BACKEND = 28,
  /**
   * SPOOFING_APPROVED - Config checking state: packet sent or received under foreign IP
   * address and allowed.
   */
  SPOOFING_APPROVED = 8,
  /** ARRIVE_AT_INSTANCE - Forwarding state: arriving at a Compute Engine instance. */
  ARRIVE_AT_INSTANCE = 9,
  /**
   * ARRIVE_AT_INTERNAL_LOAD_BALANCER - Forwarding state: arriving at a Compute Engine internal load balancer.
   * Deprecated in favor of the `ANALYZE_LOAD_BALANCER_BACKEND` state, not
   * used in new tests.
   *
   * @deprecated
   */
  ARRIVE_AT_INTERNAL_LOAD_BALANCER = 10,
  /**
   * ARRIVE_AT_EXTERNAL_LOAD_BALANCER - Forwarding state: arriving at a Compute Engine external load balancer.
   * Deprecated in favor of the `ANALYZE_LOAD_BALANCER_BACKEND` state, not
   * used in new tests.
   *
   * @deprecated
   */
  ARRIVE_AT_EXTERNAL_LOAD_BALANCER = 11,
  /** ARRIVE_AT_VPN_GATEWAY - Forwarding state: arriving at a Cloud VPN gateway. */
  ARRIVE_AT_VPN_GATEWAY = 12,
  /** ARRIVE_AT_VPN_TUNNEL - Forwarding state: arriving at a Cloud VPN tunnel. */
  ARRIVE_AT_VPN_TUNNEL = 13,
  /** ARRIVE_AT_VPC_CONNECTOR - Forwarding state: arriving at a VPC connector. */
  ARRIVE_AT_VPC_CONNECTOR = 24,
  /** NAT - Transition state: packet header translated. */
  NAT = 14,
  /**
   * PROXY_CONNECTION - Transition state: original connection is terminated and a new proxied
   * connection is initiated.
   */
  PROXY_CONNECTION = 15,
  /** DELIVER - Final state: packet could be delivered. */
  DELIVER = 16,
  /** DROP - Final state: packet could be dropped. */
  DROP = 17,
  /**
   * FORWARD - Final state: packet could be forwarded to a network with an unknown
   * configuration.
   */
  FORWARD = 18,
  /** ABORT - Final state: analysis is aborted. */
  ABORT = 19,
  /**
   * VIEWER_PERMISSION_MISSING - Special state: viewer of the test result does not have permission to
   * see the configuration in this step.
   */
  VIEWER_PERMISSION_MISSING = 20,
  UNRECOGNIZED = -1,
}

export function step_StateFromJSON(object: any): Step_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Step_State.STATE_UNSPECIFIED;
    case 1:
    case "START_FROM_INSTANCE":
      return Step_State.START_FROM_INSTANCE;
    case 2:
    case "START_FROM_INTERNET":
      return Step_State.START_FROM_INTERNET;
    case 27:
    case "START_FROM_GOOGLE_SERVICE":
      return Step_State.START_FROM_GOOGLE_SERVICE;
    case 3:
    case "START_FROM_PRIVATE_NETWORK":
      return Step_State.START_FROM_PRIVATE_NETWORK;
    case 21:
    case "START_FROM_GKE_MASTER":
      return Step_State.START_FROM_GKE_MASTER;
    case 22:
    case "START_FROM_CLOUD_SQL_INSTANCE":
      return Step_State.START_FROM_CLOUD_SQL_INSTANCE;
    case 23:
    case "START_FROM_CLOUD_FUNCTION":
      return Step_State.START_FROM_CLOUD_FUNCTION;
    case 25:
    case "START_FROM_APP_ENGINE_VERSION":
      return Step_State.START_FROM_APP_ENGINE_VERSION;
    case 26:
    case "START_FROM_CLOUD_RUN_REVISION":
      return Step_State.START_FROM_CLOUD_RUN_REVISION;
    case 29:
    case "START_FROM_STORAGE_BUCKET":
      return Step_State.START_FROM_STORAGE_BUCKET;
    case 30:
    case "START_FROM_PSC_PUBLISHED_SERVICE":
      return Step_State.START_FROM_PSC_PUBLISHED_SERVICE;
    case 4:
    case "APPLY_INGRESS_FIREWALL_RULE":
      return Step_State.APPLY_INGRESS_FIREWALL_RULE;
    case 5:
    case "APPLY_EGRESS_FIREWALL_RULE":
      return Step_State.APPLY_EGRESS_FIREWALL_RULE;
    case 6:
    case "APPLY_ROUTE":
      return Step_State.APPLY_ROUTE;
    case 7:
    case "APPLY_FORWARDING_RULE":
      return Step_State.APPLY_FORWARDING_RULE;
    case 28:
    case "ANALYZE_LOAD_BALANCER_BACKEND":
      return Step_State.ANALYZE_LOAD_BALANCER_BACKEND;
    case 8:
    case "SPOOFING_APPROVED":
      return Step_State.SPOOFING_APPROVED;
    case 9:
    case "ARRIVE_AT_INSTANCE":
      return Step_State.ARRIVE_AT_INSTANCE;
    case 10:
    case "ARRIVE_AT_INTERNAL_LOAD_BALANCER":
      return Step_State.ARRIVE_AT_INTERNAL_LOAD_BALANCER;
    case 11:
    case "ARRIVE_AT_EXTERNAL_LOAD_BALANCER":
      return Step_State.ARRIVE_AT_EXTERNAL_LOAD_BALANCER;
    case 12:
    case "ARRIVE_AT_VPN_GATEWAY":
      return Step_State.ARRIVE_AT_VPN_GATEWAY;
    case 13:
    case "ARRIVE_AT_VPN_TUNNEL":
      return Step_State.ARRIVE_AT_VPN_TUNNEL;
    case 24:
    case "ARRIVE_AT_VPC_CONNECTOR":
      return Step_State.ARRIVE_AT_VPC_CONNECTOR;
    case 14:
    case "NAT":
      return Step_State.NAT;
    case 15:
    case "PROXY_CONNECTION":
      return Step_State.PROXY_CONNECTION;
    case 16:
    case "DELIVER":
      return Step_State.DELIVER;
    case 17:
    case "DROP":
      return Step_State.DROP;
    case 18:
    case "FORWARD":
      return Step_State.FORWARD;
    case 19:
    case "ABORT":
      return Step_State.ABORT;
    case 20:
    case "VIEWER_PERMISSION_MISSING":
      return Step_State.VIEWER_PERMISSION_MISSING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Step_State.UNRECOGNIZED;
  }
}

export function step_StateToJSON(object: Step_State): string {
  switch (object) {
    case Step_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Step_State.START_FROM_INSTANCE:
      return "START_FROM_INSTANCE";
    case Step_State.START_FROM_INTERNET:
      return "START_FROM_INTERNET";
    case Step_State.START_FROM_GOOGLE_SERVICE:
      return "START_FROM_GOOGLE_SERVICE";
    case Step_State.START_FROM_PRIVATE_NETWORK:
      return "START_FROM_PRIVATE_NETWORK";
    case Step_State.START_FROM_GKE_MASTER:
      return "START_FROM_GKE_MASTER";
    case Step_State.START_FROM_CLOUD_SQL_INSTANCE:
      return "START_FROM_CLOUD_SQL_INSTANCE";
    case Step_State.START_FROM_CLOUD_FUNCTION:
      return "START_FROM_CLOUD_FUNCTION";
    case Step_State.START_FROM_APP_ENGINE_VERSION:
      return "START_FROM_APP_ENGINE_VERSION";
    case Step_State.START_FROM_CLOUD_RUN_REVISION:
      return "START_FROM_CLOUD_RUN_REVISION";
    case Step_State.START_FROM_STORAGE_BUCKET:
      return "START_FROM_STORAGE_BUCKET";
    case Step_State.START_FROM_PSC_PUBLISHED_SERVICE:
      return "START_FROM_PSC_PUBLISHED_SERVICE";
    case Step_State.APPLY_INGRESS_FIREWALL_RULE:
      return "APPLY_INGRESS_FIREWALL_RULE";
    case Step_State.APPLY_EGRESS_FIREWALL_RULE:
      return "APPLY_EGRESS_FIREWALL_RULE";
    case Step_State.APPLY_ROUTE:
      return "APPLY_ROUTE";
    case Step_State.APPLY_FORWARDING_RULE:
      return "APPLY_FORWARDING_RULE";
    case Step_State.ANALYZE_LOAD_BALANCER_BACKEND:
      return "ANALYZE_LOAD_BALANCER_BACKEND";
    case Step_State.SPOOFING_APPROVED:
      return "SPOOFING_APPROVED";
    case Step_State.ARRIVE_AT_INSTANCE:
      return "ARRIVE_AT_INSTANCE";
    case Step_State.ARRIVE_AT_INTERNAL_LOAD_BALANCER:
      return "ARRIVE_AT_INTERNAL_LOAD_BALANCER";
    case Step_State.ARRIVE_AT_EXTERNAL_LOAD_BALANCER:
      return "ARRIVE_AT_EXTERNAL_LOAD_BALANCER";
    case Step_State.ARRIVE_AT_VPN_GATEWAY:
      return "ARRIVE_AT_VPN_GATEWAY";
    case Step_State.ARRIVE_AT_VPN_TUNNEL:
      return "ARRIVE_AT_VPN_TUNNEL";
    case Step_State.ARRIVE_AT_VPC_CONNECTOR:
      return "ARRIVE_AT_VPC_CONNECTOR";
    case Step_State.NAT:
      return "NAT";
    case Step_State.PROXY_CONNECTION:
      return "PROXY_CONNECTION";
    case Step_State.DELIVER:
      return "DELIVER";
    case Step_State.DROP:
      return "DROP";
    case Step_State.FORWARD:
      return "FORWARD";
    case Step_State.ABORT:
      return "ABORT";
    case Step_State.VIEWER_PERMISSION_MISSING:
      return "VIEWER_PERMISSION_MISSING";
    case Step_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine instance. */
export interface InstanceInfo {
  /** Name of a Compute Engine instance. */
  displayName: string;
  /** URI of a Compute Engine instance. */
  uri: string;
  /** Name of the network interface of a Compute Engine instance. */
  interface: string;
  /** URI of a Compute Engine network. */
  networkUri: string;
  /** Internal IP address of the network interface. */
  internalIp: string;
  /** External IP address of the network interface. */
  externalIp: string;
  /** Network tags configured on the instance. */
  networkTags: string[];
  /**
   * Service account authorized for the instance.
   *
   * @deprecated
   */
  serviceAccount: string;
}

/** For display only. Metadata associated with a Compute Engine network. */
export interface NetworkInfo {
  /** Name of a Compute Engine network. */
  displayName: string;
  /** URI of a Compute Engine network. */
  uri: string;
  /** The IP range that matches the test. */
  matchedIpRange: string;
}

/**
 * For display only. Metadata associated with a VPC firewall rule, an implied
 * VPC firewall rule, or a hierarchical firewall policy rule.
 */
export interface FirewallInfo {
  /**
   * The display name of the VPC firewall rule. This field is not applicable
   * to hierarchical firewall policy rules.
   */
  displayName: string;
  /**
   * The URI of the VPC firewall rule. This field is not applicable to
   * implied firewall rules or hierarchical firewall policy rules.
   */
  uri: string;
  /** Possible values: INGRESS, EGRESS */
  direction: string;
  /** Possible values: ALLOW, DENY, APPLY_SECURITY_PROFILE_GROUP */
  action: string;
  /** The priority of the firewall rule. */
  priority: number;
  /**
   * The URI of the VPC network that the firewall rule is associated with.
   * This field is not applicable to hierarchical firewall policy rules.
   */
  networkUri: string;
  /**
   * The target tags defined by the VPC firewall rule. This field is not
   * applicable to hierarchical firewall policy rules.
   */
  targetTags: string[];
  /** The target service accounts specified by the firewall rule. */
  targetServiceAccounts: string[];
  /**
   * The hierarchical firewall policy that this rule is associated with.
   * This field is not applicable to VPC firewall rules.
   */
  policy: string;
  /** The firewall rule's type. */
  firewallRuleType: FirewallInfo_FirewallRuleType;
}

/** The firewall rule's type. */
export enum FirewallInfo_FirewallRuleType {
  /** FIREWALL_RULE_TYPE_UNSPECIFIED - Unspecified type. */
  FIREWALL_RULE_TYPE_UNSPECIFIED = 0,
  /**
   * HIERARCHICAL_FIREWALL_POLICY_RULE - Hierarchical firewall policy rule. For details, see
   * [Hierarchical firewall policies
   * overview](https://cloud.google.com/vpc/docs/firewall-policies).
   */
  HIERARCHICAL_FIREWALL_POLICY_RULE = 1,
  /**
   * VPC_FIREWALL_RULE - VPC firewall rule. For details, see
   * [VPC firewall rules
   * overview](https://cloud.google.com/vpc/docs/firewalls).
   */
  VPC_FIREWALL_RULE = 2,
  /**
   * IMPLIED_VPC_FIREWALL_RULE - Implied VPC firewall rule. For details, see
   * [Implied
   * rules](https://cloud.google.com/vpc/docs/firewalls#default_firewall_rules).
   */
  IMPLIED_VPC_FIREWALL_RULE = 3,
  /**
   * SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE - Implicit firewall rules that are managed by serverless VPC access to
   * allow ingress access. They are not visible in the Google Cloud console.
   * For details, see [VPC connector's implicit
   * rules](https://cloud.google.com/functions/docs/networking/connecting-vpc#restrict-access).
   */
  SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE = 4,
  /**
   * NETWORK_FIREWALL_POLICY_RULE - Global network firewall policy rule.
   * For details, see [Network firewall
   * policies](https://cloud.google.com/vpc/docs/network-firewall-policies).
   */
  NETWORK_FIREWALL_POLICY_RULE = 5,
  /**
   * NETWORK_REGIONAL_FIREWALL_POLICY_RULE - Regional network firewall policy rule.
   * For details, see [Regional network firewall
   * policies](https://cloud.google.com/firewall/docs/regional-firewall-policies).
   */
  NETWORK_REGIONAL_FIREWALL_POLICY_RULE = 6,
  /**
   * UNSUPPORTED_FIREWALL_POLICY_RULE - Firewall policy rule containing attributes not yet supported in
   * Connectivity tests. Firewall analysis is skipped if such a rule can
   * potentially be matched. Please see the [list of unsupported
   * configurations](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs).
   */
  UNSUPPORTED_FIREWALL_POLICY_RULE = 100,
  /**
   * TRACKING_STATE - Tracking state for response traffic created when request traffic goes
   * through allow firewall rule.
   * For details, see [firewall rules
   * specifications](https://cloud.google.com/firewall/docs/firewalls#specifications)
   */
  TRACKING_STATE = 101,
  UNRECOGNIZED = -1,
}

export function firewallInfo_FirewallRuleTypeFromJSON(object: any): FirewallInfo_FirewallRuleType {
  switch (object) {
    case 0:
    case "FIREWALL_RULE_TYPE_UNSPECIFIED":
      return FirewallInfo_FirewallRuleType.FIREWALL_RULE_TYPE_UNSPECIFIED;
    case 1:
    case "HIERARCHICAL_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.HIERARCHICAL_FIREWALL_POLICY_RULE;
    case 2:
    case "VPC_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.VPC_FIREWALL_RULE;
    case 3:
    case "IMPLIED_VPC_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.IMPLIED_VPC_FIREWALL_RULE;
    case 4:
    case "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE":
      return FirewallInfo_FirewallRuleType.SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE;
    case 5:
    case "NETWORK_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.NETWORK_FIREWALL_POLICY_RULE;
    case 6:
    case "NETWORK_REGIONAL_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.NETWORK_REGIONAL_FIREWALL_POLICY_RULE;
    case 100:
    case "UNSUPPORTED_FIREWALL_POLICY_RULE":
      return FirewallInfo_FirewallRuleType.UNSUPPORTED_FIREWALL_POLICY_RULE;
    case 101:
    case "TRACKING_STATE":
      return FirewallInfo_FirewallRuleType.TRACKING_STATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FirewallInfo_FirewallRuleType.UNRECOGNIZED;
  }
}

export function firewallInfo_FirewallRuleTypeToJSON(object: FirewallInfo_FirewallRuleType): string {
  switch (object) {
    case FirewallInfo_FirewallRuleType.FIREWALL_RULE_TYPE_UNSPECIFIED:
      return "FIREWALL_RULE_TYPE_UNSPECIFIED";
    case FirewallInfo_FirewallRuleType.HIERARCHICAL_FIREWALL_POLICY_RULE:
      return "HIERARCHICAL_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.VPC_FIREWALL_RULE:
      return "VPC_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.IMPLIED_VPC_FIREWALL_RULE:
      return "IMPLIED_VPC_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE:
      return "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE";
    case FirewallInfo_FirewallRuleType.NETWORK_FIREWALL_POLICY_RULE:
      return "NETWORK_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.NETWORK_REGIONAL_FIREWALL_POLICY_RULE:
      return "NETWORK_REGIONAL_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.UNSUPPORTED_FIREWALL_POLICY_RULE:
      return "UNSUPPORTED_FIREWALL_POLICY_RULE";
    case FirewallInfo_FirewallRuleType.TRACKING_STATE:
      return "TRACKING_STATE";
    case FirewallInfo_FirewallRuleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine route. */
export interface RouteInfo {
  /** Type of route. */
  routeType: RouteInfo_RouteType;
  /** Type of next hop. */
  nextHopType: RouteInfo_NextHopType;
  /** Indicates where route is applicable. */
  routeScope: RouteInfo_RouteScope;
  /** Name of a route. */
  displayName: string;
  /**
   * URI of a route.
   * Dynamic, peering static and peering dynamic routes do not have an URI.
   * Advertised route from Google Cloud VPC to on-premises network also does
   * not have an URI.
   */
  uri: string;
  /** Destination IP range of the route. */
  destIpRange: string;
  /** Next hop of the route. */
  nextHop: string;
  /** URI of a Compute Engine network. NETWORK routes only. */
  networkUri: string;
  /** Priority of the route. */
  priority: number;
  /** Instance tags of the route. */
  instanceTags: string[];
  /** Source IP address range of the route. Policy based routes only. */
  srcIpRange: string;
  /** Destination port ranges of the route. Policy based routes only. */
  destPortRanges: string[];
  /** Source port ranges of the route. Policy based routes only. */
  srcPortRanges: string[];
  /** Protocols of the route. Policy based routes only. */
  protocols: string[];
  /** URI of a NCC Hub. NCC_HUB routes only. */
  nccHubUri?:
    | string
    | undefined;
  /** URI of a NCC Spoke. NCC_HUB routes only. */
  nccSpokeUri?: string | undefined;
}

/** Type of route: */
export enum RouteInfo_RouteType {
  /** ROUTE_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  ROUTE_TYPE_UNSPECIFIED = 0,
  /** SUBNET - Route is a subnet route automatically created by the system. */
  SUBNET = 1,
  /**
   * STATIC - Static route created by the user, including the default route to the
   * internet.
   */
  STATIC = 2,
  /** DYNAMIC - Dynamic route exchanged between BGP peers. */
  DYNAMIC = 3,
  /** PEERING_SUBNET - A subnet route received from peering network. */
  PEERING_SUBNET = 4,
  /** PEERING_STATIC - A static route received from peering network. */
  PEERING_STATIC = 5,
  /** PEERING_DYNAMIC - A dynamic route received from peering network. */
  PEERING_DYNAMIC = 6,
  /** POLICY_BASED - Policy based route. */
  POLICY_BASED = 7,
  UNRECOGNIZED = -1,
}

export function routeInfo_RouteTypeFromJSON(object: any): RouteInfo_RouteType {
  switch (object) {
    case 0:
    case "ROUTE_TYPE_UNSPECIFIED":
      return RouteInfo_RouteType.ROUTE_TYPE_UNSPECIFIED;
    case 1:
    case "SUBNET":
      return RouteInfo_RouteType.SUBNET;
    case 2:
    case "STATIC":
      return RouteInfo_RouteType.STATIC;
    case 3:
    case "DYNAMIC":
      return RouteInfo_RouteType.DYNAMIC;
    case 4:
    case "PEERING_SUBNET":
      return RouteInfo_RouteType.PEERING_SUBNET;
    case 5:
    case "PEERING_STATIC":
      return RouteInfo_RouteType.PEERING_STATIC;
    case 6:
    case "PEERING_DYNAMIC":
      return RouteInfo_RouteType.PEERING_DYNAMIC;
    case 7:
    case "POLICY_BASED":
      return RouteInfo_RouteType.POLICY_BASED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteInfo_RouteType.UNRECOGNIZED;
  }
}

export function routeInfo_RouteTypeToJSON(object: RouteInfo_RouteType): string {
  switch (object) {
    case RouteInfo_RouteType.ROUTE_TYPE_UNSPECIFIED:
      return "ROUTE_TYPE_UNSPECIFIED";
    case RouteInfo_RouteType.SUBNET:
      return "SUBNET";
    case RouteInfo_RouteType.STATIC:
      return "STATIC";
    case RouteInfo_RouteType.DYNAMIC:
      return "DYNAMIC";
    case RouteInfo_RouteType.PEERING_SUBNET:
      return "PEERING_SUBNET";
    case RouteInfo_RouteType.PEERING_STATIC:
      return "PEERING_STATIC";
    case RouteInfo_RouteType.PEERING_DYNAMIC:
      return "PEERING_DYNAMIC";
    case RouteInfo_RouteType.POLICY_BASED:
      return "POLICY_BASED";
    case RouteInfo_RouteType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of next hop: */
export enum RouteInfo_NextHopType {
  /** NEXT_HOP_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  NEXT_HOP_TYPE_UNSPECIFIED = 0,
  /** NEXT_HOP_IP - Next hop is an IP address. */
  NEXT_HOP_IP = 1,
  /** NEXT_HOP_INSTANCE - Next hop is a Compute Engine instance. */
  NEXT_HOP_INSTANCE = 2,
  /** NEXT_HOP_NETWORK - Next hop is a VPC network gateway. */
  NEXT_HOP_NETWORK = 3,
  /** NEXT_HOP_PEERING - Next hop is a peering VPC. */
  NEXT_HOP_PEERING = 4,
  /** NEXT_HOP_INTERCONNECT - Next hop is an interconnect. */
  NEXT_HOP_INTERCONNECT = 5,
  /** NEXT_HOP_VPN_TUNNEL - Next hop is a VPN tunnel. */
  NEXT_HOP_VPN_TUNNEL = 6,
  /**
   * NEXT_HOP_VPN_GATEWAY - Next hop is a VPN gateway. This scenario only happens when tracing
   * connectivity from an on-premises network to Google Cloud through a VPN.
   * The analysis simulates a packet departing from the on-premises network
   * through a VPN tunnel and arriving at a Cloud VPN gateway.
   */
  NEXT_HOP_VPN_GATEWAY = 7,
  /** NEXT_HOP_INTERNET_GATEWAY - Next hop is an internet gateway. */
  NEXT_HOP_INTERNET_GATEWAY = 8,
  /**
   * NEXT_HOP_BLACKHOLE - Next hop is blackhole; that is, the next hop either does not exist or is
   * not running.
   */
  NEXT_HOP_BLACKHOLE = 9,
  /** NEXT_HOP_ILB - Next hop is the forwarding rule of an Internal Load Balancer. */
  NEXT_HOP_ILB = 10,
  /**
   * NEXT_HOP_ROUTER_APPLIANCE - Next hop is a
   * [router appliance
   * instance](https://cloud.google.com/network-connectivity/docs/network-connectivity-center/concepts/ra-overview).
   */
  NEXT_HOP_ROUTER_APPLIANCE = 11,
  /** NEXT_HOP_NCC_HUB - Next hop is an NCC hub. */
  NEXT_HOP_NCC_HUB = 12,
  UNRECOGNIZED = -1,
}

export function routeInfo_NextHopTypeFromJSON(object: any): RouteInfo_NextHopType {
  switch (object) {
    case 0:
    case "NEXT_HOP_TYPE_UNSPECIFIED":
      return RouteInfo_NextHopType.NEXT_HOP_TYPE_UNSPECIFIED;
    case 1:
    case "NEXT_HOP_IP":
      return RouteInfo_NextHopType.NEXT_HOP_IP;
    case 2:
    case "NEXT_HOP_INSTANCE":
      return RouteInfo_NextHopType.NEXT_HOP_INSTANCE;
    case 3:
    case "NEXT_HOP_NETWORK":
      return RouteInfo_NextHopType.NEXT_HOP_NETWORK;
    case 4:
    case "NEXT_HOP_PEERING":
      return RouteInfo_NextHopType.NEXT_HOP_PEERING;
    case 5:
    case "NEXT_HOP_INTERCONNECT":
      return RouteInfo_NextHopType.NEXT_HOP_INTERCONNECT;
    case 6:
    case "NEXT_HOP_VPN_TUNNEL":
      return RouteInfo_NextHopType.NEXT_HOP_VPN_TUNNEL;
    case 7:
    case "NEXT_HOP_VPN_GATEWAY":
      return RouteInfo_NextHopType.NEXT_HOP_VPN_GATEWAY;
    case 8:
    case "NEXT_HOP_INTERNET_GATEWAY":
      return RouteInfo_NextHopType.NEXT_HOP_INTERNET_GATEWAY;
    case 9:
    case "NEXT_HOP_BLACKHOLE":
      return RouteInfo_NextHopType.NEXT_HOP_BLACKHOLE;
    case 10:
    case "NEXT_HOP_ILB":
      return RouteInfo_NextHopType.NEXT_HOP_ILB;
    case 11:
    case "NEXT_HOP_ROUTER_APPLIANCE":
      return RouteInfo_NextHopType.NEXT_HOP_ROUTER_APPLIANCE;
    case 12:
    case "NEXT_HOP_NCC_HUB":
      return RouteInfo_NextHopType.NEXT_HOP_NCC_HUB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteInfo_NextHopType.UNRECOGNIZED;
  }
}

export function routeInfo_NextHopTypeToJSON(object: RouteInfo_NextHopType): string {
  switch (object) {
    case RouteInfo_NextHopType.NEXT_HOP_TYPE_UNSPECIFIED:
      return "NEXT_HOP_TYPE_UNSPECIFIED";
    case RouteInfo_NextHopType.NEXT_HOP_IP:
      return "NEXT_HOP_IP";
    case RouteInfo_NextHopType.NEXT_HOP_INSTANCE:
      return "NEXT_HOP_INSTANCE";
    case RouteInfo_NextHopType.NEXT_HOP_NETWORK:
      return "NEXT_HOP_NETWORK";
    case RouteInfo_NextHopType.NEXT_HOP_PEERING:
      return "NEXT_HOP_PEERING";
    case RouteInfo_NextHopType.NEXT_HOP_INTERCONNECT:
      return "NEXT_HOP_INTERCONNECT";
    case RouteInfo_NextHopType.NEXT_HOP_VPN_TUNNEL:
      return "NEXT_HOP_VPN_TUNNEL";
    case RouteInfo_NextHopType.NEXT_HOP_VPN_GATEWAY:
      return "NEXT_HOP_VPN_GATEWAY";
    case RouteInfo_NextHopType.NEXT_HOP_INTERNET_GATEWAY:
      return "NEXT_HOP_INTERNET_GATEWAY";
    case RouteInfo_NextHopType.NEXT_HOP_BLACKHOLE:
      return "NEXT_HOP_BLACKHOLE";
    case RouteInfo_NextHopType.NEXT_HOP_ILB:
      return "NEXT_HOP_ILB";
    case RouteInfo_NextHopType.NEXT_HOP_ROUTER_APPLIANCE:
      return "NEXT_HOP_ROUTER_APPLIANCE";
    case RouteInfo_NextHopType.NEXT_HOP_NCC_HUB:
      return "NEXT_HOP_NCC_HUB";
    case RouteInfo_NextHopType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates where routes are applicable. */
export enum RouteInfo_RouteScope {
  /** ROUTE_SCOPE_UNSPECIFIED - Unspecified scope. Default value. */
  ROUTE_SCOPE_UNSPECIFIED = 0,
  /** NETWORK - Route is applicable to packets in Network. */
  NETWORK = 1,
  /** NCC_HUB - Route is applicable to packets using NCC Hub's routing table. */
  NCC_HUB = 2,
  UNRECOGNIZED = -1,
}

export function routeInfo_RouteScopeFromJSON(object: any): RouteInfo_RouteScope {
  switch (object) {
    case 0:
    case "ROUTE_SCOPE_UNSPECIFIED":
      return RouteInfo_RouteScope.ROUTE_SCOPE_UNSPECIFIED;
    case 1:
    case "NETWORK":
      return RouteInfo_RouteScope.NETWORK;
    case 2:
    case "NCC_HUB":
      return RouteInfo_RouteScope.NCC_HUB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteInfo_RouteScope.UNRECOGNIZED;
  }
}

export function routeInfo_RouteScopeToJSON(object: RouteInfo_RouteScope): string {
  switch (object) {
    case RouteInfo_RouteScope.ROUTE_SCOPE_UNSPECIFIED:
      return "ROUTE_SCOPE_UNSPECIFIED";
    case RouteInfo_RouteScope.NETWORK:
      return "NETWORK";
    case RouteInfo_RouteScope.NCC_HUB:
      return "NCC_HUB";
    case RouteInfo_RouteScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. Details of a Google Service sending packets to a
 * VPC network. Although the source IP might be a publicly routable address,
 * some Google Services use special routes within Google production
 * infrastructure to reach Compute Engine Instances.
 * https://cloud.google.com/vpc/docs/routes#special_return_paths
 */
export interface GoogleServiceInfo {
  /** Source IP address. */
  sourceIp: string;
  /** Recognized type of a Google Service. */
  googleServiceType: GoogleServiceInfo_GoogleServiceType;
}

/** Recognized type of a Google Service. */
export enum GoogleServiceInfo_GoogleServiceType {
  /** GOOGLE_SERVICE_TYPE_UNSPECIFIED - Unspecified Google Service. */
  GOOGLE_SERVICE_TYPE_UNSPECIFIED = 0,
  /**
   * IAP - Identity aware proxy.
   * https://cloud.google.com/iap/docs/using-tcp-forwarding
   */
  IAP = 1,
  /**
   * GFE_PROXY_OR_HEALTH_CHECK_PROBER - One of two services sharing IP ranges:
   * * Load Balancer proxy
   * * Centralized Health Check prober
   * https://cloud.google.com/load-balancing/docs/firewall-rules
   */
  GFE_PROXY_OR_HEALTH_CHECK_PROBER = 2,
  /**
   * CLOUD_DNS - Connectivity from Cloud DNS to forwarding targets or alternate name
   * servers that use private routing.
   * https://cloud.google.com/dns/docs/zones/forwarding-zones#firewall-rules
   * https://cloud.google.com/dns/docs/policies#firewall-rules
   */
  CLOUD_DNS = 3,
  /** GOOGLE_API - private.googleapis.com and restricted.googleapis.com */
  GOOGLE_API = 4,
  /**
   * GOOGLE_API_PSC - Google API via Private Service Connect.
   * https://cloud.google.com/vpc/docs/configure-private-service-connect-apis
   */
  GOOGLE_API_PSC = 5,
  /**
   * GOOGLE_API_VPC_SC - Google API via VPC Service Controls.
   * https://cloud.google.com/vpc/docs/configure-private-service-connect-apis
   */
  GOOGLE_API_VPC_SC = 6,
  UNRECOGNIZED = -1,
}

export function googleServiceInfo_GoogleServiceTypeFromJSON(object: any): GoogleServiceInfo_GoogleServiceType {
  switch (object) {
    case 0:
    case "GOOGLE_SERVICE_TYPE_UNSPECIFIED":
      return GoogleServiceInfo_GoogleServiceType.GOOGLE_SERVICE_TYPE_UNSPECIFIED;
    case 1:
    case "IAP":
      return GoogleServiceInfo_GoogleServiceType.IAP;
    case 2:
    case "GFE_PROXY_OR_HEALTH_CHECK_PROBER":
      return GoogleServiceInfo_GoogleServiceType.GFE_PROXY_OR_HEALTH_CHECK_PROBER;
    case 3:
    case "CLOUD_DNS":
      return GoogleServiceInfo_GoogleServiceType.CLOUD_DNS;
    case 4:
    case "GOOGLE_API":
      return GoogleServiceInfo_GoogleServiceType.GOOGLE_API;
    case 5:
    case "GOOGLE_API_PSC":
      return GoogleServiceInfo_GoogleServiceType.GOOGLE_API_PSC;
    case 6:
    case "GOOGLE_API_VPC_SC":
      return GoogleServiceInfo_GoogleServiceType.GOOGLE_API_VPC_SC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GoogleServiceInfo_GoogleServiceType.UNRECOGNIZED;
  }
}

export function googleServiceInfo_GoogleServiceTypeToJSON(object: GoogleServiceInfo_GoogleServiceType): string {
  switch (object) {
    case GoogleServiceInfo_GoogleServiceType.GOOGLE_SERVICE_TYPE_UNSPECIFIED:
      return "GOOGLE_SERVICE_TYPE_UNSPECIFIED";
    case GoogleServiceInfo_GoogleServiceType.IAP:
      return "IAP";
    case GoogleServiceInfo_GoogleServiceType.GFE_PROXY_OR_HEALTH_CHECK_PROBER:
      return "GFE_PROXY_OR_HEALTH_CHECK_PROBER";
    case GoogleServiceInfo_GoogleServiceType.CLOUD_DNS:
      return "CLOUD_DNS";
    case GoogleServiceInfo_GoogleServiceType.GOOGLE_API:
      return "GOOGLE_API";
    case GoogleServiceInfo_GoogleServiceType.GOOGLE_API_PSC:
      return "GOOGLE_API_PSC";
    case GoogleServiceInfo_GoogleServiceType.GOOGLE_API_VPC_SC:
      return "GOOGLE_API_VPC_SC";
    case GoogleServiceInfo_GoogleServiceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine forwarding rule. */
export interface ForwardingRuleInfo {
  /** Name of a Compute Engine forwarding rule. */
  displayName: string;
  /** URI of a Compute Engine forwarding rule. */
  uri: string;
  /** Protocol defined in the forwarding rule that matches the test. */
  matchedProtocol: string;
  /** Port range defined in the forwarding rule that matches the test. */
  matchedPortRange: string;
  /** VIP of the forwarding rule. */
  vip: string;
  /** Target type of the forwarding rule. */
  target: string;
  /** Network URI. Only valid for Internal Load Balancer. */
  networkUri: string;
}

/** For display only. Metadata associated with a load balancer. */
export interface LoadBalancerInfo {
  /** Type of the load balancer. */
  loadBalancerType: LoadBalancerInfo_LoadBalancerType;
  /**
   * URI of the health check for the load balancer. Deprecated and no longer
   * populated as different load balancer backends might have different health
   * checks.
   *
   * @deprecated
   */
  healthCheckUri: string;
  /** Information for the loadbalancer backends. */
  backends: LoadBalancerBackend[];
  /** Type of load balancer's backend configuration. */
  backendType: LoadBalancerInfo_BackendType;
  /** Backend configuration URI. */
  backendUri: string;
}

/** The type definition for a load balancer: */
export enum LoadBalancerInfo_LoadBalancerType {
  /** LOAD_BALANCER_TYPE_UNSPECIFIED - Type is unspecified. */
  LOAD_BALANCER_TYPE_UNSPECIFIED = 0,
  /** INTERNAL_TCP_UDP - Internal TCP/UDP load balancer. */
  INTERNAL_TCP_UDP = 1,
  /** NETWORK_TCP_UDP - Network TCP/UDP load balancer. */
  NETWORK_TCP_UDP = 2,
  /** HTTP_PROXY - HTTP(S) proxy load balancer. */
  HTTP_PROXY = 3,
  /** TCP_PROXY - TCP proxy load balancer. */
  TCP_PROXY = 4,
  /** SSL_PROXY - SSL proxy load balancer. */
  SSL_PROXY = 5,
  UNRECOGNIZED = -1,
}

export function loadBalancerInfo_LoadBalancerTypeFromJSON(object: any): LoadBalancerInfo_LoadBalancerType {
  switch (object) {
    case 0:
    case "LOAD_BALANCER_TYPE_UNSPECIFIED":
      return LoadBalancerInfo_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED;
    case 1:
    case "INTERNAL_TCP_UDP":
      return LoadBalancerInfo_LoadBalancerType.INTERNAL_TCP_UDP;
    case 2:
    case "NETWORK_TCP_UDP":
      return LoadBalancerInfo_LoadBalancerType.NETWORK_TCP_UDP;
    case 3:
    case "HTTP_PROXY":
      return LoadBalancerInfo_LoadBalancerType.HTTP_PROXY;
    case 4:
    case "TCP_PROXY":
      return LoadBalancerInfo_LoadBalancerType.TCP_PROXY;
    case 5:
    case "SSL_PROXY":
      return LoadBalancerInfo_LoadBalancerType.SSL_PROXY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerInfo_LoadBalancerType.UNRECOGNIZED;
  }
}

export function loadBalancerInfo_LoadBalancerTypeToJSON(object: LoadBalancerInfo_LoadBalancerType): string {
  switch (object) {
    case LoadBalancerInfo_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED:
      return "LOAD_BALANCER_TYPE_UNSPECIFIED";
    case LoadBalancerInfo_LoadBalancerType.INTERNAL_TCP_UDP:
      return "INTERNAL_TCP_UDP";
    case LoadBalancerInfo_LoadBalancerType.NETWORK_TCP_UDP:
      return "NETWORK_TCP_UDP";
    case LoadBalancerInfo_LoadBalancerType.HTTP_PROXY:
      return "HTTP_PROXY";
    case LoadBalancerInfo_LoadBalancerType.TCP_PROXY:
      return "TCP_PROXY";
    case LoadBalancerInfo_LoadBalancerType.SSL_PROXY:
      return "SSL_PROXY";
    case LoadBalancerInfo_LoadBalancerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type definition for a load balancer backend configuration: */
export enum LoadBalancerInfo_BackendType {
  /** BACKEND_TYPE_UNSPECIFIED - Type is unspecified. */
  BACKEND_TYPE_UNSPECIFIED = 0,
  /** BACKEND_SERVICE - Backend Service as the load balancer's backend. */
  BACKEND_SERVICE = 1,
  /** TARGET_POOL - Target Pool as the load balancer's backend. */
  TARGET_POOL = 2,
  /** TARGET_INSTANCE - Target Instance as the load balancer's backend. */
  TARGET_INSTANCE = 3,
  UNRECOGNIZED = -1,
}

export function loadBalancerInfo_BackendTypeFromJSON(object: any): LoadBalancerInfo_BackendType {
  switch (object) {
    case 0:
    case "BACKEND_TYPE_UNSPECIFIED":
      return LoadBalancerInfo_BackendType.BACKEND_TYPE_UNSPECIFIED;
    case 1:
    case "BACKEND_SERVICE":
      return LoadBalancerInfo_BackendType.BACKEND_SERVICE;
    case 2:
    case "TARGET_POOL":
      return LoadBalancerInfo_BackendType.TARGET_POOL;
    case 3:
    case "TARGET_INSTANCE":
      return LoadBalancerInfo_BackendType.TARGET_INSTANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerInfo_BackendType.UNRECOGNIZED;
  }
}

export function loadBalancerInfo_BackendTypeToJSON(object: LoadBalancerInfo_BackendType): string {
  switch (object) {
    case LoadBalancerInfo_BackendType.BACKEND_TYPE_UNSPECIFIED:
      return "BACKEND_TYPE_UNSPECIFIED";
    case LoadBalancerInfo_BackendType.BACKEND_SERVICE:
      return "BACKEND_SERVICE";
    case LoadBalancerInfo_BackendType.TARGET_POOL:
      return "TARGET_POOL";
    case LoadBalancerInfo_BackendType.TARGET_INSTANCE:
      return "TARGET_INSTANCE";
    case LoadBalancerInfo_BackendType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a specific load balancer backend. */
export interface LoadBalancerBackend {
  /** Name of a Compute Engine instance or network endpoint. */
  displayName: string;
  /** URI of a Compute Engine instance or network endpoint. */
  uri: string;
  /** State of the health check firewall configuration. */
  healthCheckFirewallState: LoadBalancerBackend_HealthCheckFirewallState;
  /** A list of firewall rule URIs allowing probes from health check IP ranges. */
  healthCheckAllowingFirewallRules: string[];
  /** A list of firewall rule URIs blocking probes from health check IP ranges. */
  healthCheckBlockingFirewallRules: string[];
}

/** State of a health check firewall configuration: */
export enum LoadBalancerBackend_HealthCheckFirewallState {
  /** HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED - State is unspecified. Default state if not populated. */
  HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED = 0,
  /**
   * CONFIGURED - There are configured firewall rules to allow health check probes to the
   * backend.
   */
  CONFIGURED = 1,
  /**
   * MISCONFIGURED - There are firewall rules configured to allow partial health check ranges
   * or block all health check ranges.
   * If a health check probe is sent from denied IP ranges,
   * the health check to the backend will fail. Then, the backend will be
   * marked unhealthy and will not receive traffic sent to the load balancer.
   */
  MISCONFIGURED = 2,
  UNRECOGNIZED = -1,
}

export function loadBalancerBackend_HealthCheckFirewallStateFromJSON(
  object: any,
): LoadBalancerBackend_HealthCheckFirewallState {
  switch (object) {
    case 0:
    case "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED":
      return LoadBalancerBackend_HealthCheckFirewallState.HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED;
    case 1:
    case "CONFIGURED":
      return LoadBalancerBackend_HealthCheckFirewallState.CONFIGURED;
    case 2:
    case "MISCONFIGURED":
      return LoadBalancerBackend_HealthCheckFirewallState.MISCONFIGURED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerBackend_HealthCheckFirewallState.UNRECOGNIZED;
  }
}

export function loadBalancerBackend_HealthCheckFirewallStateToJSON(
  object: LoadBalancerBackend_HealthCheckFirewallState,
): string {
  switch (object) {
    case LoadBalancerBackend_HealthCheckFirewallState.HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED:
      return "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED";
    case LoadBalancerBackend_HealthCheckFirewallState.CONFIGURED:
      return "CONFIGURED";
    case LoadBalancerBackend_HealthCheckFirewallState.MISCONFIGURED:
      return "MISCONFIGURED";
    case LoadBalancerBackend_HealthCheckFirewallState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with a Compute Engine VPN gateway. */
export interface VpnGatewayInfo {
  /** Name of a VPN gateway. */
  displayName: string;
  /** URI of a VPN gateway. */
  uri: string;
  /** URI of a Compute Engine network where the VPN gateway is configured. */
  networkUri: string;
  /** IP address of the VPN gateway. */
  ipAddress: string;
  /**
   * A VPN tunnel that is associated with this VPN gateway.
   * There may be multiple VPN tunnels configured on a VPN gateway, and only
   * the one relevant to the test is displayed.
   */
  vpnTunnelUri: string;
  /** Name of a Google Cloud region where this VPN gateway is configured. */
  region: string;
}

/** For display only. Metadata associated with a Compute Engine VPN tunnel. */
export interface VpnTunnelInfo {
  /** Name of a VPN tunnel. */
  displayName: string;
  /** URI of a VPN tunnel. */
  uri: string;
  /** URI of the VPN gateway at local end of the tunnel. */
  sourceGateway: string;
  /** URI of a VPN gateway at remote end of the tunnel. */
  remoteGateway: string;
  /** Remote VPN gateway's IP address. */
  remoteGatewayIp: string;
  /** Local VPN gateway's IP address. */
  sourceGatewayIp: string;
  /** URI of a Compute Engine network where the VPN tunnel is configured. */
  networkUri: string;
  /** Name of a Google Cloud region where this VPN tunnel is configured. */
  region: string;
  /** Type of the routing policy. */
  routingType: VpnTunnelInfo_RoutingType;
}

/**
 * Types of VPN routing policy. For details, refer to [Networks and Tunnel
 * routing](https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing/).
 */
export enum VpnTunnelInfo_RoutingType {
  /** ROUTING_TYPE_UNSPECIFIED - Unspecified type. Default value. */
  ROUTING_TYPE_UNSPECIFIED = 0,
  /** ROUTE_BASED - Route based VPN. */
  ROUTE_BASED = 1,
  /** POLICY_BASED - Policy based routing. */
  POLICY_BASED = 2,
  /** DYNAMIC - Dynamic (BGP) routing. */
  DYNAMIC = 3,
  UNRECOGNIZED = -1,
}

export function vpnTunnelInfo_RoutingTypeFromJSON(object: any): VpnTunnelInfo_RoutingType {
  switch (object) {
    case 0:
    case "ROUTING_TYPE_UNSPECIFIED":
      return VpnTunnelInfo_RoutingType.ROUTING_TYPE_UNSPECIFIED;
    case 1:
    case "ROUTE_BASED":
      return VpnTunnelInfo_RoutingType.ROUTE_BASED;
    case 2:
    case "POLICY_BASED":
      return VpnTunnelInfo_RoutingType.POLICY_BASED;
    case 3:
    case "DYNAMIC":
      return VpnTunnelInfo_RoutingType.DYNAMIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VpnTunnelInfo_RoutingType.UNRECOGNIZED;
  }
}

export function vpnTunnelInfo_RoutingTypeToJSON(object: VpnTunnelInfo_RoutingType): string {
  switch (object) {
    case VpnTunnelInfo_RoutingType.ROUTING_TYPE_UNSPECIFIED:
      return "ROUTING_TYPE_UNSPECIFIED";
    case VpnTunnelInfo_RoutingType.ROUTE_BASED:
      return "ROUTE_BASED";
    case VpnTunnelInfo_RoutingType.POLICY_BASED:
      return "POLICY_BASED";
    case VpnTunnelInfo_RoutingType.DYNAMIC:
      return "DYNAMIC";
    case VpnTunnelInfo_RoutingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. The specification of the endpoints for the test.
 * EndpointInfo is derived from source and destination Endpoint and validated
 * by the backend data plane model.
 */
export interface EndpointInfo {
  /** Source IP address. */
  sourceIp: string;
  /** Destination IP address. */
  destinationIp: string;
  /** IP protocol in string format, for example: "TCP", "UDP", "ICMP". */
  protocol: string;
  /** Source port. Only valid when protocol is TCP or UDP. */
  sourcePort: number;
  /** Destination port. Only valid when protocol is TCP or UDP. */
  destinationPort: number;
  /** URI of the network where this packet originates from. */
  sourceNetworkUri: string;
  /** URI of the network where this packet is sent to. */
  destinationNetworkUri: string;
  /** URI of the source telemetry agent this packet originates from. */
  sourceAgentUri: string;
}

/** Details of the final state "deliver" and associated resource. */
export interface DeliverInfo {
  /** Target type where the packet is delivered to. */
  target: DeliverInfo_Target;
  /** URI of the resource that the packet is delivered to. */
  resourceUri: string;
  /** IP address of the target (if applicable). */
  ipAddress: string;
}

/** Deliver target types: */
export enum DeliverInfo_Target {
  /** TARGET_UNSPECIFIED - Target not specified. */
  TARGET_UNSPECIFIED = 0,
  /** INSTANCE - Target is a Compute Engine instance. */
  INSTANCE = 1,
  /** INTERNET - Target is the internet. */
  INTERNET = 2,
  /** GOOGLE_API - Target is a Google API. */
  GOOGLE_API = 3,
  /** GKE_MASTER - Target is a Google Kubernetes Engine cluster master. */
  GKE_MASTER = 4,
  /** CLOUD_SQL_INSTANCE - Target is a Cloud SQL instance. */
  CLOUD_SQL_INSTANCE = 5,
  /**
   * PSC_PUBLISHED_SERVICE - Target is a published service that uses [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
   */
  PSC_PUBLISHED_SERVICE = 6,
  /**
   * PSC_GOOGLE_API - Target is all Google APIs that use [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
   */
  PSC_GOOGLE_API = 7,
  /**
   * PSC_VPC_SC - Target is a VPC-SC that uses [Private Service
   * Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-apis).
   */
  PSC_VPC_SC = 8,
  /** SERVERLESS_NEG - Target is a serverless network endpoint group. */
  SERVERLESS_NEG = 9,
  /** STORAGE_BUCKET - Target is a Cloud Storage bucket. */
  STORAGE_BUCKET = 10,
  /** PRIVATE_NETWORK - Target is a private network. Used only for return traces. */
  PRIVATE_NETWORK = 11,
  /** CLOUD_FUNCTION - Target is a Cloud Function. Used only for return traces. */
  CLOUD_FUNCTION = 12,
  /** APP_ENGINE_VERSION - Target is a App Engine service version. Used only for return traces. */
  APP_ENGINE_VERSION = 13,
  /** CLOUD_RUN_REVISION - Target is a Cloud Run revision. Used only for return traces. */
  CLOUD_RUN_REVISION = 14,
  UNRECOGNIZED = -1,
}

export function deliverInfo_TargetFromJSON(object: any): DeliverInfo_Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return DeliverInfo_Target.TARGET_UNSPECIFIED;
    case 1:
    case "INSTANCE":
      return DeliverInfo_Target.INSTANCE;
    case 2:
    case "INTERNET":
      return DeliverInfo_Target.INTERNET;
    case 3:
    case "GOOGLE_API":
      return DeliverInfo_Target.GOOGLE_API;
    case 4:
    case "GKE_MASTER":
      return DeliverInfo_Target.GKE_MASTER;
    case 5:
    case "CLOUD_SQL_INSTANCE":
      return DeliverInfo_Target.CLOUD_SQL_INSTANCE;
    case 6:
    case "PSC_PUBLISHED_SERVICE":
      return DeliverInfo_Target.PSC_PUBLISHED_SERVICE;
    case 7:
    case "PSC_GOOGLE_API":
      return DeliverInfo_Target.PSC_GOOGLE_API;
    case 8:
    case "PSC_VPC_SC":
      return DeliverInfo_Target.PSC_VPC_SC;
    case 9:
    case "SERVERLESS_NEG":
      return DeliverInfo_Target.SERVERLESS_NEG;
    case 10:
    case "STORAGE_BUCKET":
      return DeliverInfo_Target.STORAGE_BUCKET;
    case 11:
    case "PRIVATE_NETWORK":
      return DeliverInfo_Target.PRIVATE_NETWORK;
    case 12:
    case "CLOUD_FUNCTION":
      return DeliverInfo_Target.CLOUD_FUNCTION;
    case 13:
    case "APP_ENGINE_VERSION":
      return DeliverInfo_Target.APP_ENGINE_VERSION;
    case 14:
    case "CLOUD_RUN_REVISION":
      return DeliverInfo_Target.CLOUD_RUN_REVISION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliverInfo_Target.UNRECOGNIZED;
  }
}

export function deliverInfo_TargetToJSON(object: DeliverInfo_Target): string {
  switch (object) {
    case DeliverInfo_Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case DeliverInfo_Target.INSTANCE:
      return "INSTANCE";
    case DeliverInfo_Target.INTERNET:
      return "INTERNET";
    case DeliverInfo_Target.GOOGLE_API:
      return "GOOGLE_API";
    case DeliverInfo_Target.GKE_MASTER:
      return "GKE_MASTER";
    case DeliverInfo_Target.CLOUD_SQL_INSTANCE:
      return "CLOUD_SQL_INSTANCE";
    case DeliverInfo_Target.PSC_PUBLISHED_SERVICE:
      return "PSC_PUBLISHED_SERVICE";
    case DeliverInfo_Target.PSC_GOOGLE_API:
      return "PSC_GOOGLE_API";
    case DeliverInfo_Target.PSC_VPC_SC:
      return "PSC_VPC_SC";
    case DeliverInfo_Target.SERVERLESS_NEG:
      return "SERVERLESS_NEG";
    case DeliverInfo_Target.STORAGE_BUCKET:
      return "STORAGE_BUCKET";
    case DeliverInfo_Target.PRIVATE_NETWORK:
      return "PRIVATE_NETWORK";
    case DeliverInfo_Target.CLOUD_FUNCTION:
      return "CLOUD_FUNCTION";
    case DeliverInfo_Target.APP_ENGINE_VERSION:
      return "APP_ENGINE_VERSION";
    case DeliverInfo_Target.CLOUD_RUN_REVISION:
      return "CLOUD_RUN_REVISION";
    case DeliverInfo_Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "forward" and associated resource. */
export interface ForwardInfo {
  /** Target type where this packet is forwarded to. */
  target: ForwardInfo_Target;
  /** URI of the resource that the packet is forwarded to. */
  resourceUri: string;
  /** IP address of the target (if applicable). */
  ipAddress: string;
}

/** Forward target types. */
export enum ForwardInfo_Target {
  /** TARGET_UNSPECIFIED - Target not specified. */
  TARGET_UNSPECIFIED = 0,
  /** PEERING_VPC - Forwarded to a VPC peering network. */
  PEERING_VPC = 1,
  /** VPN_GATEWAY - Forwarded to a Cloud VPN gateway. */
  VPN_GATEWAY = 2,
  /** INTERCONNECT - Forwarded to a Cloud Interconnect connection. */
  INTERCONNECT = 3,
  /**
   * GKE_MASTER - Forwarded to a Google Kubernetes Engine Container cluster master.
   *
   * @deprecated
   */
  GKE_MASTER = 4,
  /** IMPORTED_CUSTOM_ROUTE_NEXT_HOP - Forwarded to the next hop of a custom route imported from a peering VPC. */
  IMPORTED_CUSTOM_ROUTE_NEXT_HOP = 5,
  /**
   * CLOUD_SQL_INSTANCE - Forwarded to a Cloud SQL instance.
   *
   * @deprecated
   */
  CLOUD_SQL_INSTANCE = 6,
  /** ANOTHER_PROJECT - Forwarded to a VPC network in another project. */
  ANOTHER_PROJECT = 7,
  /** NCC_HUB - Forwarded to an NCC Hub. */
  NCC_HUB = 8,
  /** ROUTER_APPLIANCE - Forwarded to a router appliance. */
  ROUTER_APPLIANCE = 9,
  UNRECOGNIZED = -1,
}

export function forwardInfo_TargetFromJSON(object: any): ForwardInfo_Target {
  switch (object) {
    case 0:
    case "TARGET_UNSPECIFIED":
      return ForwardInfo_Target.TARGET_UNSPECIFIED;
    case 1:
    case "PEERING_VPC":
      return ForwardInfo_Target.PEERING_VPC;
    case 2:
    case "VPN_GATEWAY":
      return ForwardInfo_Target.VPN_GATEWAY;
    case 3:
    case "INTERCONNECT":
      return ForwardInfo_Target.INTERCONNECT;
    case 4:
    case "GKE_MASTER":
      return ForwardInfo_Target.GKE_MASTER;
    case 5:
    case "IMPORTED_CUSTOM_ROUTE_NEXT_HOP":
      return ForwardInfo_Target.IMPORTED_CUSTOM_ROUTE_NEXT_HOP;
    case 6:
    case "CLOUD_SQL_INSTANCE":
      return ForwardInfo_Target.CLOUD_SQL_INSTANCE;
    case 7:
    case "ANOTHER_PROJECT":
      return ForwardInfo_Target.ANOTHER_PROJECT;
    case 8:
    case "NCC_HUB":
      return ForwardInfo_Target.NCC_HUB;
    case 9:
    case "ROUTER_APPLIANCE":
      return ForwardInfo_Target.ROUTER_APPLIANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ForwardInfo_Target.UNRECOGNIZED;
  }
}

export function forwardInfo_TargetToJSON(object: ForwardInfo_Target): string {
  switch (object) {
    case ForwardInfo_Target.TARGET_UNSPECIFIED:
      return "TARGET_UNSPECIFIED";
    case ForwardInfo_Target.PEERING_VPC:
      return "PEERING_VPC";
    case ForwardInfo_Target.VPN_GATEWAY:
      return "VPN_GATEWAY";
    case ForwardInfo_Target.INTERCONNECT:
      return "INTERCONNECT";
    case ForwardInfo_Target.GKE_MASTER:
      return "GKE_MASTER";
    case ForwardInfo_Target.IMPORTED_CUSTOM_ROUTE_NEXT_HOP:
      return "IMPORTED_CUSTOM_ROUTE_NEXT_HOP";
    case ForwardInfo_Target.CLOUD_SQL_INSTANCE:
      return "CLOUD_SQL_INSTANCE";
    case ForwardInfo_Target.ANOTHER_PROJECT:
      return "ANOTHER_PROJECT";
    case ForwardInfo_Target.NCC_HUB:
      return "NCC_HUB";
    case ForwardInfo_Target.ROUTER_APPLIANCE:
      return "ROUTER_APPLIANCE";
    case ForwardInfo_Target.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "abort" and associated resource. */
export interface AbortInfo {
  /** Causes that the analysis is aborted. */
  cause: AbortInfo_Cause;
  /** URI of the resource that caused the abort. */
  resourceUri: string;
  /** IP address that caused the abort. */
  ipAddress: string;
  /**
   * List of project IDs the user specified in the request but lacks access to.
   * In this case, analysis is aborted with the PERMISSION_DENIED cause.
   */
  projectsMissingPermission: string[];
}

/** Abort cause types: */
export enum AbortInfo_Cause {
  /** CAUSE_UNSPECIFIED - Cause is unspecified. */
  CAUSE_UNSPECIFIED = 0,
  /**
   * UNKNOWN_NETWORK - Aborted due to unknown network. Deprecated, not used in the new tests.
   *
   * @deprecated
   */
  UNKNOWN_NETWORK = 1,
  /**
   * UNKNOWN_PROJECT - Aborted because no project information can be derived from the test
   * input. Deprecated, not used in the new tests.
   *
   * @deprecated
   */
  UNKNOWN_PROJECT = 3,
  /**
   * NO_EXTERNAL_IP - Aborted because traffic is sent from a public IP to an instance without
   * an external IP. Deprecated, not used in the new tests.
   *
   * @deprecated
   */
  NO_EXTERNAL_IP = 7,
  /**
   * UNINTENDED_DESTINATION - Aborted because none of the traces matches destination information
   * specified in the input test request. Deprecated, not used in the new
   * tests.
   *
   * @deprecated
   */
  UNINTENDED_DESTINATION = 8,
  /**
   * SOURCE_ENDPOINT_NOT_FOUND - Aborted because the source endpoint could not be found. Deprecated, not
   * used in the new tests.
   *
   * @deprecated
   */
  SOURCE_ENDPOINT_NOT_FOUND = 11,
  /**
   * MISMATCHED_SOURCE_NETWORK - Aborted because the source network does not match the source endpoint.
   * Deprecated, not used in the new tests.
   *
   * @deprecated
   */
  MISMATCHED_SOURCE_NETWORK = 12,
  /**
   * DESTINATION_ENDPOINT_NOT_FOUND - Aborted because the destination endpoint could not be found. Deprecated,
   * not used in the new tests.
   *
   * @deprecated
   */
  DESTINATION_ENDPOINT_NOT_FOUND = 13,
  /**
   * MISMATCHED_DESTINATION_NETWORK - Aborted because the destination network does not match the destination
   * endpoint. Deprecated, not used in the new tests.
   *
   * @deprecated
   */
  MISMATCHED_DESTINATION_NETWORK = 14,
  /**
   * UNKNOWN_IP - Aborted because no endpoint with the packet's destination IP address is
   * found.
   */
  UNKNOWN_IP = 2,
  /**
   * SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK - Aborted because the source IP address doesn't belong to any of the
   * subnets of the source VPC network.
   */
  SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK = 23,
  /**
   * PERMISSION_DENIED - Aborted because user lacks permission to access all or part of the
   * network configurations required to run the test.
   */
  PERMISSION_DENIED = 4,
  /**
   * PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS - Aborted because user lacks permission to access Cloud NAT configs
   * required to run the test.
   */
  PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS = 28,
  /**
   * PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS - Aborted because user lacks permission to access Network endpoint group
   * endpoint configs required to run the test.
   */
  PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS = 29,
  /**
   * NO_SOURCE_LOCATION - Aborted because no valid source or destination endpoint is derived from
   * the input test request.
   */
  NO_SOURCE_LOCATION = 5,
  /**
   * INVALID_ARGUMENT - Aborted because the source or destination endpoint specified in
   * the request is invalid. Some examples:
   * - The request might contain malformed resource URI, project ID, or IP
   * address.
   * - The request might contain inconsistent information (for example, the
   * request might include both the instance and the network, but the instance
   * might not have a NIC in that network).
   */
  INVALID_ARGUMENT = 6,
  /**
   * TRACE_TOO_LONG - Aborted because the number of steps in the trace exceeds a certain
   * limit. It might be caused by a routing loop.
   */
  TRACE_TOO_LONG = 9,
  /** INTERNAL_ERROR - Aborted due to internal server error. */
  INTERNAL_ERROR = 10,
  /** UNSUPPORTED - Aborted because the test scenario is not supported. */
  UNSUPPORTED = 15,
  /**
   * MISMATCHED_IP_VERSION - Aborted because the source and destination resources have no common IP
   * version.
   */
  MISMATCHED_IP_VERSION = 16,
  /**
   * GKE_KONNECTIVITY_PROXY_UNSUPPORTED - Aborted because the connection between the control plane and the node of
   * the source cluster is initiated by the node and managed by the
   * Konnectivity proxy.
   */
  GKE_KONNECTIVITY_PROXY_UNSUPPORTED = 17,
  /** RESOURCE_CONFIG_NOT_FOUND - Aborted because expected resource configuration was missing. */
  RESOURCE_CONFIG_NOT_FOUND = 18,
  /** VM_INSTANCE_CONFIG_NOT_FOUND - Aborted because expected VM instance configuration was missing. */
  VM_INSTANCE_CONFIG_NOT_FOUND = 24,
  /** NETWORK_CONFIG_NOT_FOUND - Aborted because expected network configuration was missing. */
  NETWORK_CONFIG_NOT_FOUND = 25,
  /** FIREWALL_CONFIG_NOT_FOUND - Aborted because expected firewall configuration was missing. */
  FIREWALL_CONFIG_NOT_FOUND = 26,
  /** ROUTE_CONFIG_NOT_FOUND - Aborted because expected route configuration was missing. */
  ROUTE_CONFIG_NOT_FOUND = 27,
  /**
   * GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT - Aborted because a PSC endpoint selection for the Google-managed service
   * is ambiguous (several PSC endpoints satisfy test input).
   */
  GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT = 19,
  /**
   * SOURCE_PSC_CLOUD_SQL_UNSUPPORTED - Aborted because tests with a PSC-based Cloud SQL instance as a source are
   * not supported.
   */
  SOURCE_PSC_CLOUD_SQL_UNSUPPORTED = 20,
  /**
   * SOURCE_FORWARDING_RULE_UNSUPPORTED - Aborted because tests with a forwarding rule as a source are not
   * supported.
   */
  SOURCE_FORWARDING_RULE_UNSUPPORTED = 21,
  /**
   * NON_ROUTABLE_IP_ADDRESS - Aborted because one of the endpoints is a non-routable IP address
   * (loopback, link-local, etc).
   */
  NON_ROUTABLE_IP_ADDRESS = 22,
  /** UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT - Aborted due to an unknown issue in the Google-managed project. */
  UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT = 30,
  /**
   * UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG - Aborted due to an unsupported configuration of the Google-managed
   * project.
   */
  UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG = 31,
  UNRECOGNIZED = -1,
}

export function abortInfo_CauseFromJSON(object: any): AbortInfo_Cause {
  switch (object) {
    case 0:
    case "CAUSE_UNSPECIFIED":
      return AbortInfo_Cause.CAUSE_UNSPECIFIED;
    case 1:
    case "UNKNOWN_NETWORK":
      return AbortInfo_Cause.UNKNOWN_NETWORK;
    case 3:
    case "UNKNOWN_PROJECT":
      return AbortInfo_Cause.UNKNOWN_PROJECT;
    case 7:
    case "NO_EXTERNAL_IP":
      return AbortInfo_Cause.NO_EXTERNAL_IP;
    case 8:
    case "UNINTENDED_DESTINATION":
      return AbortInfo_Cause.UNINTENDED_DESTINATION;
    case 11:
    case "SOURCE_ENDPOINT_NOT_FOUND":
      return AbortInfo_Cause.SOURCE_ENDPOINT_NOT_FOUND;
    case 12:
    case "MISMATCHED_SOURCE_NETWORK":
      return AbortInfo_Cause.MISMATCHED_SOURCE_NETWORK;
    case 13:
    case "DESTINATION_ENDPOINT_NOT_FOUND":
      return AbortInfo_Cause.DESTINATION_ENDPOINT_NOT_FOUND;
    case 14:
    case "MISMATCHED_DESTINATION_NETWORK":
      return AbortInfo_Cause.MISMATCHED_DESTINATION_NETWORK;
    case 2:
    case "UNKNOWN_IP":
      return AbortInfo_Cause.UNKNOWN_IP;
    case 23:
    case "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK":
      return AbortInfo_Cause.SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK;
    case 4:
    case "PERMISSION_DENIED":
      return AbortInfo_Cause.PERMISSION_DENIED;
    case 28:
    case "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS":
      return AbortInfo_Cause.PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS;
    case 29:
    case "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS":
      return AbortInfo_Cause.PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS;
    case 5:
    case "NO_SOURCE_LOCATION":
      return AbortInfo_Cause.NO_SOURCE_LOCATION;
    case 6:
    case "INVALID_ARGUMENT":
      return AbortInfo_Cause.INVALID_ARGUMENT;
    case 9:
    case "TRACE_TOO_LONG":
      return AbortInfo_Cause.TRACE_TOO_LONG;
    case 10:
    case "INTERNAL_ERROR":
      return AbortInfo_Cause.INTERNAL_ERROR;
    case 15:
    case "UNSUPPORTED":
      return AbortInfo_Cause.UNSUPPORTED;
    case 16:
    case "MISMATCHED_IP_VERSION":
      return AbortInfo_Cause.MISMATCHED_IP_VERSION;
    case 17:
    case "GKE_KONNECTIVITY_PROXY_UNSUPPORTED":
      return AbortInfo_Cause.GKE_KONNECTIVITY_PROXY_UNSUPPORTED;
    case 18:
    case "RESOURCE_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.RESOURCE_CONFIG_NOT_FOUND;
    case 24:
    case "VM_INSTANCE_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.VM_INSTANCE_CONFIG_NOT_FOUND;
    case 25:
    case "NETWORK_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.NETWORK_CONFIG_NOT_FOUND;
    case 26:
    case "FIREWALL_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.FIREWALL_CONFIG_NOT_FOUND;
    case 27:
    case "ROUTE_CONFIG_NOT_FOUND":
      return AbortInfo_Cause.ROUTE_CONFIG_NOT_FOUND;
    case 19:
    case "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT":
      return AbortInfo_Cause.GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT;
    case 20:
    case "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED":
      return AbortInfo_Cause.SOURCE_PSC_CLOUD_SQL_UNSUPPORTED;
    case 21:
    case "SOURCE_FORWARDING_RULE_UNSUPPORTED":
      return AbortInfo_Cause.SOURCE_FORWARDING_RULE_UNSUPPORTED;
    case 22:
    case "NON_ROUTABLE_IP_ADDRESS":
      return AbortInfo_Cause.NON_ROUTABLE_IP_ADDRESS;
    case 30:
    case "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT":
      return AbortInfo_Cause.UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT;
    case 31:
    case "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG":
      return AbortInfo_Cause.UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AbortInfo_Cause.UNRECOGNIZED;
  }
}

export function abortInfo_CauseToJSON(object: AbortInfo_Cause): string {
  switch (object) {
    case AbortInfo_Cause.CAUSE_UNSPECIFIED:
      return "CAUSE_UNSPECIFIED";
    case AbortInfo_Cause.UNKNOWN_NETWORK:
      return "UNKNOWN_NETWORK";
    case AbortInfo_Cause.UNKNOWN_PROJECT:
      return "UNKNOWN_PROJECT";
    case AbortInfo_Cause.NO_EXTERNAL_IP:
      return "NO_EXTERNAL_IP";
    case AbortInfo_Cause.UNINTENDED_DESTINATION:
      return "UNINTENDED_DESTINATION";
    case AbortInfo_Cause.SOURCE_ENDPOINT_NOT_FOUND:
      return "SOURCE_ENDPOINT_NOT_FOUND";
    case AbortInfo_Cause.MISMATCHED_SOURCE_NETWORK:
      return "MISMATCHED_SOURCE_NETWORK";
    case AbortInfo_Cause.DESTINATION_ENDPOINT_NOT_FOUND:
      return "DESTINATION_ENDPOINT_NOT_FOUND";
    case AbortInfo_Cause.MISMATCHED_DESTINATION_NETWORK:
      return "MISMATCHED_DESTINATION_NETWORK";
    case AbortInfo_Cause.UNKNOWN_IP:
      return "UNKNOWN_IP";
    case AbortInfo_Cause.SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK:
      return "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK";
    case AbortInfo_Cause.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case AbortInfo_Cause.PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS:
      return "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS";
    case AbortInfo_Cause.PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS:
      return "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS";
    case AbortInfo_Cause.NO_SOURCE_LOCATION:
      return "NO_SOURCE_LOCATION";
    case AbortInfo_Cause.INVALID_ARGUMENT:
      return "INVALID_ARGUMENT";
    case AbortInfo_Cause.TRACE_TOO_LONG:
      return "TRACE_TOO_LONG";
    case AbortInfo_Cause.INTERNAL_ERROR:
      return "INTERNAL_ERROR";
    case AbortInfo_Cause.UNSUPPORTED:
      return "UNSUPPORTED";
    case AbortInfo_Cause.MISMATCHED_IP_VERSION:
      return "MISMATCHED_IP_VERSION";
    case AbortInfo_Cause.GKE_KONNECTIVITY_PROXY_UNSUPPORTED:
      return "GKE_KONNECTIVITY_PROXY_UNSUPPORTED";
    case AbortInfo_Cause.RESOURCE_CONFIG_NOT_FOUND:
      return "RESOURCE_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.VM_INSTANCE_CONFIG_NOT_FOUND:
      return "VM_INSTANCE_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.NETWORK_CONFIG_NOT_FOUND:
      return "NETWORK_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.FIREWALL_CONFIG_NOT_FOUND:
      return "FIREWALL_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.ROUTE_CONFIG_NOT_FOUND:
      return "ROUTE_CONFIG_NOT_FOUND";
    case AbortInfo_Cause.GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT:
      return "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT";
    case AbortInfo_Cause.SOURCE_PSC_CLOUD_SQL_UNSUPPORTED:
      return "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED";
    case AbortInfo_Cause.SOURCE_FORWARDING_RULE_UNSUPPORTED:
      return "SOURCE_FORWARDING_RULE_UNSUPPORTED";
    case AbortInfo_Cause.NON_ROUTABLE_IP_ADDRESS:
      return "NON_ROUTABLE_IP_ADDRESS";
    case AbortInfo_Cause.UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT:
      return "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT";
    case AbortInfo_Cause.UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG:
      return "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG";
    case AbortInfo_Cause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details of the final state "drop" and associated resource. */
export interface DropInfo {
  /** Cause that the packet is dropped. */
  cause: DropInfo_Cause;
  /** URI of the resource that caused the drop. */
  resourceUri: string;
  /** Source IP address of the dropped packet (if relevant). */
  sourceIp: string;
  /** Destination IP address of the dropped packet (if relevant). */
  destinationIp: string;
  /** Region of the dropped packet (if relevant). */
  region: string;
}

/** Drop cause types: */
export enum DropInfo_Cause {
  /** CAUSE_UNSPECIFIED - Cause is unspecified. */
  CAUSE_UNSPECIFIED = 0,
  /**
   * UNKNOWN_EXTERNAL_ADDRESS - Destination external address cannot be resolved to a known target. If
   * the address is used in a Google Cloud project, provide the project ID
   * as test input.
   */
  UNKNOWN_EXTERNAL_ADDRESS = 1,
  /**
   * FOREIGN_IP_DISALLOWED - A Compute Engine instance can only send or receive a packet with a
   * foreign IP address if ip_forward is enabled.
   */
  FOREIGN_IP_DISALLOWED = 2,
  /**
   * FIREWALL_RULE - Dropped due to a firewall rule, unless allowed due to connection
   * tracking.
   */
  FIREWALL_RULE = 3,
  /** NO_ROUTE - Dropped due to no matching routes. */
  NO_ROUTE = 4,
  /** ROUTE_BLACKHOLE - Dropped due to invalid route. Route's next hop is a blackhole. */
  ROUTE_BLACKHOLE = 5,
  /**
   * ROUTE_WRONG_NETWORK - Packet is sent to a wrong (unintended) network. Example: you trace a
   * packet from VM1:Network1 to VM2:Network2, however, the route configured
   * in Network1 sends the packet destined for VM2's IP address to Network3.
   */
  ROUTE_WRONG_NETWORK = 6,
  /** ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED - Route's next hop IP address cannot be resolved to a GCP resource. */
  ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED = 42,
  /** ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND - Route's next hop resource is not found. */
  ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND = 43,
  /** ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK - Route's next hop instance doesn't have a NIC in the route's network. */
  ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK = 49,
  /**
   * ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP - Route's next hop IP address is not a primary IP address of the next hop
   * instance.
   */
  ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP = 50,
  /** ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH - Route's next hop forwarding rule doesn't match next hop IP address. */
  ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH = 51,
  /** ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED - Route's next hop VPN tunnel is down (does not have valid IKE SAs). */
  ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED = 52,
  /**
   * ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID - Route's next hop forwarding rule type is invalid (it's not a forwarding
   * rule of the internal passthrough load balancer).
   */
  ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID = 53,
  /** NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS - Packet is sent from the Internet to the private IPv6 address. */
  NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS = 44,
  /** VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH - The packet does not match a policy-based VPN tunnel local selector. */
  VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH = 45,
  /** VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH - The packet does not match a policy-based VPN tunnel remote selector. */
  VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH = 46,
  /** PRIVATE_TRAFFIC_TO_INTERNET - Packet with internal destination address sent to the internet gateway. */
  PRIVATE_TRAFFIC_TO_INTERNET = 7,
  /**
   * PRIVATE_GOOGLE_ACCESS_DISALLOWED - Instance with only an internal IP address tries to access Google API and
   * services, but private Google access is not enabled in the subnet.
   */
  PRIVATE_GOOGLE_ACCESS_DISALLOWED = 8,
  /**
   * PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED - Source endpoint tries to access Google API and services through the VPN
   * tunnel to another network, but Private Google Access needs to be enabled
   * in the source endpoint network.
   */
  PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED = 47,
  /**
   * NO_EXTERNAL_ADDRESS - Instance with only an internal IP address tries to access external hosts,
   * but Cloud NAT is not enabled in the subnet, unless special configurations
   * on a VM allow this connection.
   */
  NO_EXTERNAL_ADDRESS = 9,
  /**
   * UNKNOWN_INTERNAL_ADDRESS - Destination internal address cannot be resolved to a known target. If
   * this is a shared VPC scenario, verify if the service project ID is
   * provided as test input. Otherwise, verify if the IP address is being
   * used in the project.
   */
  UNKNOWN_INTERNAL_ADDRESS = 10,
  /** FORWARDING_RULE_MISMATCH - Forwarding rule's protocol and ports do not match the packet header. */
  FORWARDING_RULE_MISMATCH = 11,
  /** FORWARDING_RULE_NO_INSTANCES - Forwarding rule does not have backends configured. */
  FORWARDING_RULE_NO_INSTANCES = 12,
  /**
   * FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK - Firewalls block the health check probes to the backends and cause
   * the backends to be unavailable for traffic from the load balancer.
   * For more details, see [Health check firewall
   * rules](https://cloud.google.com/load-balancing/docs/health-checks#firewall_rules).
   */
  FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK = 13,
  /**
   * INSTANCE_NOT_RUNNING - Packet is sent from or to a Compute Engine instance that is not in a
   * running state.
   */
  INSTANCE_NOT_RUNNING = 14,
  /** GKE_CLUSTER_NOT_RUNNING - Packet sent from or to a GKE cluster that is not in running state. */
  GKE_CLUSTER_NOT_RUNNING = 27,
  /** CLOUD_SQL_INSTANCE_NOT_RUNNING - Packet sent from or to a Cloud SQL instance that is not in running state. */
  CLOUD_SQL_INSTANCE_NOT_RUNNING = 28,
  /**
   * TRAFFIC_TYPE_BLOCKED - The type of traffic is blocked and the user cannot configure a firewall
   * rule to enable it. See [Always blocked
   * traffic](https://cloud.google.com/vpc/docs/firewalls#blockedtraffic) for
   * more details.
   */
  TRAFFIC_TYPE_BLOCKED = 15,
  /**
   * GKE_MASTER_UNAUTHORIZED_ACCESS - Access to Google Kubernetes Engine cluster master's endpoint is not
   * authorized. See [Access to the cluster
   * endpoints](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#access_to_the_cluster_endpoints)
   * for more details.
   */
  GKE_MASTER_UNAUTHORIZED_ACCESS = 16,
  /**
   * CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS - Access to the Cloud SQL instance endpoint is not authorized.
   * See [Authorizing with authorized
   * networks](https://cloud.google.com/sql/docs/mysql/authorize-networks) for
   * more details.
   */
  CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS = 17,
  /** DROPPED_INSIDE_GKE_SERVICE - Packet was dropped inside Google Kubernetes Engine Service. */
  DROPPED_INSIDE_GKE_SERVICE = 18,
  /** DROPPED_INSIDE_CLOUD_SQL_SERVICE - Packet was dropped inside Cloud SQL Service. */
  DROPPED_INSIDE_CLOUD_SQL_SERVICE = 19,
  /**
   * GOOGLE_MANAGED_SERVICE_NO_PEERING - Packet was dropped because there is no peering between the originating
   * network and the Google Managed Services Network.
   */
  GOOGLE_MANAGED_SERVICE_NO_PEERING = 20,
  /**
   * GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT - Packet was dropped because the Google-managed service uses Private
   * Service Connect (PSC), but the PSC endpoint is not found in the project.
   */
  GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT = 38,
  /**
   * GKE_PSC_ENDPOINT_MISSING - Packet was dropped because the GKE cluster uses Private Service Connect
   * (PSC), but the PSC endpoint is not found in the project.
   */
  GKE_PSC_ENDPOINT_MISSING = 36,
  /**
   * CLOUD_SQL_INSTANCE_NO_IP_ADDRESS - Packet was dropped because the Cloud SQL instance has neither a private
   * nor a public IP address.
   */
  CLOUD_SQL_INSTANCE_NO_IP_ADDRESS = 21,
  /**
   * GKE_CONTROL_PLANE_REGION_MISMATCH - Packet was dropped because a GKE cluster private endpoint is
   * unreachable from a region different from the cluster's region.
   */
  GKE_CONTROL_PLANE_REGION_MISMATCH = 30,
  /**
   * PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION - Packet sent from a public GKE cluster control plane to a private
   * IP address.
   */
  PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION = 31,
  /**
   * GKE_CONTROL_PLANE_NO_ROUTE - Packet was dropped because there is no route from a GKE cluster
   * control plane to a destination network.
   */
  GKE_CONTROL_PLANE_NO_ROUTE = 32,
  /**
   * CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC - Packet sent from a Cloud SQL instance to an external IP address is not
   * allowed. The Cloud SQL instance is not configured to send packets to
   * external IP addresses.
   */
  CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC = 33,
  /**
   * PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION - Packet sent from a Cloud SQL instance with only a public IP address to a
   * private IP address.
   */
  PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION = 34,
  /**
   * CLOUD_SQL_INSTANCE_NO_ROUTE - Packet was dropped because there is no route from a Cloud SQL
   * instance to a destination network.
   */
  CLOUD_SQL_INSTANCE_NO_ROUTE = 35,
  /**
   * CLOUD_FUNCTION_NOT_ACTIVE - Packet could be dropped because the Cloud Function is not in an active
   * status.
   */
  CLOUD_FUNCTION_NOT_ACTIVE = 22,
  /** VPC_CONNECTOR_NOT_SET - Packet could be dropped because no VPC connector is set. */
  VPC_CONNECTOR_NOT_SET = 23,
  /**
   * VPC_CONNECTOR_NOT_RUNNING - Packet could be dropped because the VPC connector is not in a running
   * state.
   */
  VPC_CONNECTOR_NOT_RUNNING = 24,
  /**
   * FORWARDING_RULE_REGION_MISMATCH - Packet could be dropped because it was sent from a different region
   * to a regional forwarding without global access.
   */
  FORWARDING_RULE_REGION_MISMATCH = 25,
  /**
   * PSC_CONNECTION_NOT_ACCEPTED - The Private Service Connect endpoint is in a project that is not approved
   * to connect to the service.
   */
  PSC_CONNECTION_NOT_ACCEPTED = 26,
  /**
   * PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK - The packet is sent to the Private Service Connect endpoint over the
   * peering, but [it's not
   * supported](https://cloud.google.com/vpc/docs/configure-private-service-connect-services#on-premises).
   */
  PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK = 41,
  /**
   * PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS - The packet is sent to the Private Service Connect backend (network
   * endpoint group), but the producer PSC forwarding rule does not have
   * global access enabled.
   */
  PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS = 48,
  /**
   * PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS - The packet is sent to the Private Service Connect backend (network
   * endpoint group), but the producer PSC forwarding rule has multiple ports
   * specified.
   */
  PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS = 54,
  /**
   * CLOUD_SQL_PSC_NEG_UNSUPPORTED - The packet is sent to the Private Service Connect backend (network
   * endpoint group) targeting a Cloud SQL service attachment, but this
   * configuration is not supported.
   */
  CLOUD_SQL_PSC_NEG_UNSUPPORTED = 58,
  /** NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT - No NAT subnets are defined for the PSC service attachment. */
  NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT = 57,
  /**
   * HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED - The packet sent from the hybrid NEG proxy matches a non-dynamic route,
   * but such a configuration is not supported.
   */
  HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED = 55,
  /**
   * HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED - The packet sent from the hybrid NEG proxy matches a dynamic route with a
   * next hop in a different region, but such a configuration is not
   * supported.
   */
  HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED = 56,
  /** CLOUD_RUN_REVISION_NOT_READY - Packet sent from a Cloud Run revision that is not ready. */
  CLOUD_RUN_REVISION_NOT_READY = 29,
  /** DROPPED_INSIDE_PSC_SERVICE_PRODUCER - Packet was dropped inside Private Service Connect service producer. */
  DROPPED_INSIDE_PSC_SERVICE_PRODUCER = 37,
  /**
   * LOAD_BALANCER_HAS_NO_PROXY_SUBNET - Packet sent to a load balancer, which requires a proxy-only subnet and
   * the subnet is not found.
   */
  LOAD_BALANCER_HAS_NO_PROXY_SUBNET = 39,
  /** CLOUD_NAT_NO_ADDRESSES - Packet sent to Cloud Nat without active NAT IPs. */
  CLOUD_NAT_NO_ADDRESSES = 40,
  /** ROUTING_LOOP - Packet is stuck in a routing loop. */
  ROUTING_LOOP = 59,
  UNRECOGNIZED = -1,
}

export function dropInfo_CauseFromJSON(object: any): DropInfo_Cause {
  switch (object) {
    case 0:
    case "CAUSE_UNSPECIFIED":
      return DropInfo_Cause.CAUSE_UNSPECIFIED;
    case 1:
    case "UNKNOWN_EXTERNAL_ADDRESS":
      return DropInfo_Cause.UNKNOWN_EXTERNAL_ADDRESS;
    case 2:
    case "FOREIGN_IP_DISALLOWED":
      return DropInfo_Cause.FOREIGN_IP_DISALLOWED;
    case 3:
    case "FIREWALL_RULE":
      return DropInfo_Cause.FIREWALL_RULE;
    case 4:
    case "NO_ROUTE":
      return DropInfo_Cause.NO_ROUTE;
    case 5:
    case "ROUTE_BLACKHOLE":
      return DropInfo_Cause.ROUTE_BLACKHOLE;
    case 6:
    case "ROUTE_WRONG_NETWORK":
      return DropInfo_Cause.ROUTE_WRONG_NETWORK;
    case 42:
    case "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED":
      return DropInfo_Cause.ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED;
    case 43:
    case "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND":
      return DropInfo_Cause.ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND;
    case 49:
    case "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK":
      return DropInfo_Cause.ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK;
    case 50:
    case "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP":
      return DropInfo_Cause.ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP;
    case 51:
    case "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH":
      return DropInfo_Cause.ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH;
    case 52:
    case "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED":
      return DropInfo_Cause.ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED;
    case 53:
    case "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID":
      return DropInfo_Cause.ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID;
    case 44:
    case "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS":
      return DropInfo_Cause.NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS;
    case 45:
    case "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH":
      return DropInfo_Cause.VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH;
    case 46:
    case "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH":
      return DropInfo_Cause.VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH;
    case 7:
    case "PRIVATE_TRAFFIC_TO_INTERNET":
      return DropInfo_Cause.PRIVATE_TRAFFIC_TO_INTERNET;
    case 8:
    case "PRIVATE_GOOGLE_ACCESS_DISALLOWED":
      return DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_DISALLOWED;
    case 47:
    case "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED":
      return DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED;
    case 9:
    case "NO_EXTERNAL_ADDRESS":
      return DropInfo_Cause.NO_EXTERNAL_ADDRESS;
    case 10:
    case "UNKNOWN_INTERNAL_ADDRESS":
      return DropInfo_Cause.UNKNOWN_INTERNAL_ADDRESS;
    case 11:
    case "FORWARDING_RULE_MISMATCH":
      return DropInfo_Cause.FORWARDING_RULE_MISMATCH;
    case 12:
    case "FORWARDING_RULE_NO_INSTANCES":
      return DropInfo_Cause.FORWARDING_RULE_NO_INSTANCES;
    case 13:
    case "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK":
      return DropInfo_Cause.FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK;
    case 14:
    case "INSTANCE_NOT_RUNNING":
      return DropInfo_Cause.INSTANCE_NOT_RUNNING;
    case 27:
    case "GKE_CLUSTER_NOT_RUNNING":
      return DropInfo_Cause.GKE_CLUSTER_NOT_RUNNING;
    case 28:
    case "CLOUD_SQL_INSTANCE_NOT_RUNNING":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_RUNNING;
    case 15:
    case "TRAFFIC_TYPE_BLOCKED":
      return DropInfo_Cause.TRAFFIC_TYPE_BLOCKED;
    case 16:
    case "GKE_MASTER_UNAUTHORIZED_ACCESS":
      return DropInfo_Cause.GKE_MASTER_UNAUTHORIZED_ACCESS;
    case 17:
    case "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS;
    case 18:
    case "DROPPED_INSIDE_GKE_SERVICE":
      return DropInfo_Cause.DROPPED_INSIDE_GKE_SERVICE;
    case 19:
    case "DROPPED_INSIDE_CLOUD_SQL_SERVICE":
      return DropInfo_Cause.DROPPED_INSIDE_CLOUD_SQL_SERVICE;
    case 20:
    case "GOOGLE_MANAGED_SERVICE_NO_PEERING":
      return DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PEERING;
    case 38:
    case "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT":
      return DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT;
    case 36:
    case "GKE_PSC_ENDPOINT_MISSING":
      return DropInfo_Cause.GKE_PSC_ENDPOINT_MISSING;
    case 21:
    case "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_IP_ADDRESS;
    case 30:
    case "GKE_CONTROL_PLANE_REGION_MISMATCH":
      return DropInfo_Cause.GKE_CONTROL_PLANE_REGION_MISMATCH;
    case 31:
    case "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION":
      return DropInfo_Cause.PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION;
    case 32:
    case "GKE_CONTROL_PLANE_NO_ROUTE":
      return DropInfo_Cause.GKE_CONTROL_PLANE_NO_ROUTE;
    case 33:
    case "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC;
    case 34:
    case "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION":
      return DropInfo_Cause.PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION;
    case 35:
    case "CLOUD_SQL_INSTANCE_NO_ROUTE":
      return DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_ROUTE;
    case 22:
    case "CLOUD_FUNCTION_NOT_ACTIVE":
      return DropInfo_Cause.CLOUD_FUNCTION_NOT_ACTIVE;
    case 23:
    case "VPC_CONNECTOR_NOT_SET":
      return DropInfo_Cause.VPC_CONNECTOR_NOT_SET;
    case 24:
    case "VPC_CONNECTOR_NOT_RUNNING":
      return DropInfo_Cause.VPC_CONNECTOR_NOT_RUNNING;
    case 25:
    case "FORWARDING_RULE_REGION_MISMATCH":
      return DropInfo_Cause.FORWARDING_RULE_REGION_MISMATCH;
    case 26:
    case "PSC_CONNECTION_NOT_ACCEPTED":
      return DropInfo_Cause.PSC_CONNECTION_NOT_ACCEPTED;
    case 41:
    case "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK":
      return DropInfo_Cause.PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK;
    case 48:
    case "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS":
      return DropInfo_Cause.PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS;
    case 54:
    case "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS":
      return DropInfo_Cause.PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS;
    case 58:
    case "CLOUD_SQL_PSC_NEG_UNSUPPORTED":
      return DropInfo_Cause.CLOUD_SQL_PSC_NEG_UNSUPPORTED;
    case 57:
    case "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT":
      return DropInfo_Cause.NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT;
    case 55:
    case "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED":
      return DropInfo_Cause.HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED;
    case 56:
    case "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED":
      return DropInfo_Cause.HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED;
    case 29:
    case "CLOUD_RUN_REVISION_NOT_READY":
      return DropInfo_Cause.CLOUD_RUN_REVISION_NOT_READY;
    case 37:
    case "DROPPED_INSIDE_PSC_SERVICE_PRODUCER":
      return DropInfo_Cause.DROPPED_INSIDE_PSC_SERVICE_PRODUCER;
    case 39:
    case "LOAD_BALANCER_HAS_NO_PROXY_SUBNET":
      return DropInfo_Cause.LOAD_BALANCER_HAS_NO_PROXY_SUBNET;
    case 40:
    case "CLOUD_NAT_NO_ADDRESSES":
      return DropInfo_Cause.CLOUD_NAT_NO_ADDRESSES;
    case 59:
    case "ROUTING_LOOP":
      return DropInfo_Cause.ROUTING_LOOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DropInfo_Cause.UNRECOGNIZED;
  }
}

export function dropInfo_CauseToJSON(object: DropInfo_Cause): string {
  switch (object) {
    case DropInfo_Cause.CAUSE_UNSPECIFIED:
      return "CAUSE_UNSPECIFIED";
    case DropInfo_Cause.UNKNOWN_EXTERNAL_ADDRESS:
      return "UNKNOWN_EXTERNAL_ADDRESS";
    case DropInfo_Cause.FOREIGN_IP_DISALLOWED:
      return "FOREIGN_IP_DISALLOWED";
    case DropInfo_Cause.FIREWALL_RULE:
      return "FIREWALL_RULE";
    case DropInfo_Cause.NO_ROUTE:
      return "NO_ROUTE";
    case DropInfo_Cause.ROUTE_BLACKHOLE:
      return "ROUTE_BLACKHOLE";
    case DropInfo_Cause.ROUTE_WRONG_NETWORK:
      return "ROUTE_WRONG_NETWORK";
    case DropInfo_Cause.ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED:
      return "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED";
    case DropInfo_Cause.ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND:
      return "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND";
    case DropInfo_Cause.ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK:
      return "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK";
    case DropInfo_Cause.ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP:
      return "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP";
    case DropInfo_Cause.ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH:
      return "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH";
    case DropInfo_Cause.ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED:
      return "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED";
    case DropInfo_Cause.ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID:
      return "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID";
    case DropInfo_Cause.NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS:
      return "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS";
    case DropInfo_Cause.VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH:
      return "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH";
    case DropInfo_Cause.VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH:
      return "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH";
    case DropInfo_Cause.PRIVATE_TRAFFIC_TO_INTERNET:
      return "PRIVATE_TRAFFIC_TO_INTERNET";
    case DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_DISALLOWED:
      return "PRIVATE_GOOGLE_ACCESS_DISALLOWED";
    case DropInfo_Cause.PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED:
      return "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED";
    case DropInfo_Cause.NO_EXTERNAL_ADDRESS:
      return "NO_EXTERNAL_ADDRESS";
    case DropInfo_Cause.UNKNOWN_INTERNAL_ADDRESS:
      return "UNKNOWN_INTERNAL_ADDRESS";
    case DropInfo_Cause.FORWARDING_RULE_MISMATCH:
      return "FORWARDING_RULE_MISMATCH";
    case DropInfo_Cause.FORWARDING_RULE_NO_INSTANCES:
      return "FORWARDING_RULE_NO_INSTANCES";
    case DropInfo_Cause.FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK:
      return "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK";
    case DropInfo_Cause.INSTANCE_NOT_RUNNING:
      return "INSTANCE_NOT_RUNNING";
    case DropInfo_Cause.GKE_CLUSTER_NOT_RUNNING:
      return "GKE_CLUSTER_NOT_RUNNING";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_RUNNING:
      return "CLOUD_SQL_INSTANCE_NOT_RUNNING";
    case DropInfo_Cause.TRAFFIC_TYPE_BLOCKED:
      return "TRAFFIC_TYPE_BLOCKED";
    case DropInfo_Cause.GKE_MASTER_UNAUTHORIZED_ACCESS:
      return "GKE_MASTER_UNAUTHORIZED_ACCESS";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS:
      return "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS";
    case DropInfo_Cause.DROPPED_INSIDE_GKE_SERVICE:
      return "DROPPED_INSIDE_GKE_SERVICE";
    case DropInfo_Cause.DROPPED_INSIDE_CLOUD_SQL_SERVICE:
      return "DROPPED_INSIDE_CLOUD_SQL_SERVICE";
    case DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PEERING:
      return "GOOGLE_MANAGED_SERVICE_NO_PEERING";
    case DropInfo_Cause.GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT:
      return "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT";
    case DropInfo_Cause.GKE_PSC_ENDPOINT_MISSING:
      return "GKE_PSC_ENDPOINT_MISSING";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_IP_ADDRESS:
      return "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS";
    case DropInfo_Cause.GKE_CONTROL_PLANE_REGION_MISMATCH:
      return "GKE_CONTROL_PLANE_REGION_MISMATCH";
    case DropInfo_Cause.PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION:
      return "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION";
    case DropInfo_Cause.GKE_CONTROL_PLANE_NO_ROUTE:
      return "GKE_CONTROL_PLANE_NO_ROUTE";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC:
      return "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC";
    case DropInfo_Cause.PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION:
      return "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION";
    case DropInfo_Cause.CLOUD_SQL_INSTANCE_NO_ROUTE:
      return "CLOUD_SQL_INSTANCE_NO_ROUTE";
    case DropInfo_Cause.CLOUD_FUNCTION_NOT_ACTIVE:
      return "CLOUD_FUNCTION_NOT_ACTIVE";
    case DropInfo_Cause.VPC_CONNECTOR_NOT_SET:
      return "VPC_CONNECTOR_NOT_SET";
    case DropInfo_Cause.VPC_CONNECTOR_NOT_RUNNING:
      return "VPC_CONNECTOR_NOT_RUNNING";
    case DropInfo_Cause.FORWARDING_RULE_REGION_MISMATCH:
      return "FORWARDING_RULE_REGION_MISMATCH";
    case DropInfo_Cause.PSC_CONNECTION_NOT_ACCEPTED:
      return "PSC_CONNECTION_NOT_ACCEPTED";
    case DropInfo_Cause.PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK:
      return "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK";
    case DropInfo_Cause.PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS:
      return "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS";
    case DropInfo_Cause.PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS:
      return "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS";
    case DropInfo_Cause.CLOUD_SQL_PSC_NEG_UNSUPPORTED:
      return "CLOUD_SQL_PSC_NEG_UNSUPPORTED";
    case DropInfo_Cause.NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT:
      return "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT";
    case DropInfo_Cause.HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED:
      return "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED";
    case DropInfo_Cause.HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED:
      return "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED";
    case DropInfo_Cause.CLOUD_RUN_REVISION_NOT_READY:
      return "CLOUD_RUN_REVISION_NOT_READY";
    case DropInfo_Cause.DROPPED_INSIDE_PSC_SERVICE_PRODUCER:
      return "DROPPED_INSIDE_PSC_SERVICE_PRODUCER";
    case DropInfo_Cause.LOAD_BALANCER_HAS_NO_PROXY_SUBNET:
      return "LOAD_BALANCER_HAS_NO_PROXY_SUBNET";
    case DropInfo_Cause.CLOUD_NAT_NO_ADDRESSES:
      return "CLOUD_NAT_NO_ADDRESSES";
    case DropInfo_Cause.ROUTING_LOOP:
      return "ROUTING_LOOP";
    case DropInfo_Cause.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * For display only. Metadata associated with a Google Kubernetes Engine (GKE)
 * cluster master.
 */
export interface GKEMasterInfo {
  /** URI of a GKE cluster. */
  clusterUri: string;
  /** URI of a GKE cluster network. */
  clusterNetworkUri: string;
  /** Internal IP address of a GKE cluster master. */
  internalIp: string;
  /** External IP address of a GKE cluster master. */
  externalIp: string;
}

/** For display only. Metadata associated with a Cloud SQL instance. */
export interface CloudSQLInstanceInfo {
  /** Name of a Cloud SQL instance. */
  displayName: string;
  /** URI of a Cloud SQL instance. */
  uri: string;
  /**
   * URI of a Cloud SQL instance network or empty string if the instance does
   * not have one.
   */
  networkUri: string;
  /** Internal IP address of a Cloud SQL instance. */
  internalIp: string;
  /** External IP address of a Cloud SQL instance. */
  externalIp: string;
  /** Region in which the Cloud SQL instance is running. */
  region: string;
}

/** For display only. Metadata associated with a Cloud Function. */
export interface CloudFunctionInfo {
  /** Name of a Cloud Function. */
  displayName: string;
  /** URI of a Cloud Function. */
  uri: string;
  /** Location in which the Cloud Function is deployed. */
  location: string;
  /** Latest successfully deployed version id of the Cloud Function. */
  versionId: Long;
}

/** For display only. Metadata associated with a Cloud Run revision. */
export interface CloudRunRevisionInfo {
  /** Name of a Cloud Run revision. */
  displayName: string;
  /** URI of a Cloud Run revision. */
  uri: string;
  /** Location in which this revision is deployed. */
  location: string;
  /** URI of Cloud Run service this revision belongs to. */
  serviceUri: string;
}

/** For display only. Metadata associated with an App Engine version. */
export interface AppEngineVersionInfo {
  /** Name of an App Engine version. */
  displayName: string;
  /** URI of an App Engine version. */
  uri: string;
  /** Runtime of the App Engine version. */
  runtime: string;
  /** App Engine execution environment for a version. */
  environment: string;
}

/** For display only. Metadata associated with a VPC connector. */
export interface VpcConnectorInfo {
  /** Name of a VPC connector. */
  displayName: string;
  /** URI of a VPC connector. */
  uri: string;
  /** Location in which the VPC connector is deployed. */
  location: string;
}

/** For display only. Metadata associated with NAT. */
export interface NatInfo {
  /** Type of NAT. */
  type: NatInfo_Type;
  /** IP protocol in string format, for example: "TCP", "UDP", "ICMP". */
  protocol: string;
  /** URI of the network where NAT translation takes place. */
  networkUri: string;
  /** Source IP address before NAT translation. */
  oldSourceIp: string;
  /** Source IP address after NAT translation. */
  newSourceIp: string;
  /** Destination IP address before NAT translation. */
  oldDestinationIp: string;
  /** Destination IP address after NAT translation. */
  newDestinationIp: string;
  /** Source port before NAT translation. Only valid when protocol is TCP or UDP. */
  oldSourcePort: number;
  /** Source port after NAT translation. Only valid when protocol is TCP or UDP. */
  newSourcePort: number;
  /**
   * Destination port before NAT translation. Only valid when protocol is TCP or
   * UDP.
   */
  oldDestinationPort: number;
  /**
   * Destination port after NAT translation. Only valid when protocol is TCP or
   * UDP.
   */
  newDestinationPort: number;
  /** Uri of the Cloud Router. Only valid when type is CLOUD_NAT. */
  routerUri: string;
  /** The name of Cloud NAT Gateway. Only valid when type is CLOUD_NAT. */
  natGatewayName: string;
}

/** Types of NAT. */
export enum NatInfo_Type {
  /** TYPE_UNSPECIFIED - Type is unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** INTERNAL_TO_EXTERNAL - From Compute Engine instance's internal address to external address. */
  INTERNAL_TO_EXTERNAL = 1,
  /** EXTERNAL_TO_INTERNAL - From Compute Engine instance's external address to internal address. */
  EXTERNAL_TO_INTERNAL = 2,
  /** CLOUD_NAT - Cloud NAT Gateway. */
  CLOUD_NAT = 3,
  /** PRIVATE_SERVICE_CONNECT - Private service connect NAT. */
  PRIVATE_SERVICE_CONNECT = 4,
  UNRECOGNIZED = -1,
}

export function natInfo_TypeFromJSON(object: any): NatInfo_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return NatInfo_Type.TYPE_UNSPECIFIED;
    case 1:
    case "INTERNAL_TO_EXTERNAL":
      return NatInfo_Type.INTERNAL_TO_EXTERNAL;
    case 2:
    case "EXTERNAL_TO_INTERNAL":
      return NatInfo_Type.EXTERNAL_TO_INTERNAL;
    case 3:
    case "CLOUD_NAT":
      return NatInfo_Type.CLOUD_NAT;
    case 4:
    case "PRIVATE_SERVICE_CONNECT":
      return NatInfo_Type.PRIVATE_SERVICE_CONNECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NatInfo_Type.UNRECOGNIZED;
  }
}

export function natInfo_TypeToJSON(object: NatInfo_Type): string {
  switch (object) {
    case NatInfo_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case NatInfo_Type.INTERNAL_TO_EXTERNAL:
      return "INTERNAL_TO_EXTERNAL";
    case NatInfo_Type.EXTERNAL_TO_INTERNAL:
      return "EXTERNAL_TO_INTERNAL";
    case NatInfo_Type.CLOUD_NAT:
      return "CLOUD_NAT";
    case NatInfo_Type.PRIVATE_SERVICE_CONNECT:
      return "PRIVATE_SERVICE_CONNECT";
    case NatInfo_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with ProxyConnection. */
export interface ProxyConnectionInfo {
  /** IP protocol in string format, for example: "TCP", "UDP", "ICMP". */
  protocol: string;
  /** Source IP address of an original connection. */
  oldSourceIp: string;
  /** Source IP address of a new connection. */
  newSourceIp: string;
  /** Destination IP address of an original connection */
  oldDestinationIp: string;
  /** Destination IP address of a new connection. */
  newDestinationIp: string;
  /**
   * Source port of an original connection. Only valid when protocol is TCP or
   * UDP.
   */
  oldSourcePort: number;
  /** Source port of a new connection. Only valid when protocol is TCP or UDP. */
  newSourcePort: number;
  /**
   * Destination port of an original connection. Only valid when protocol is TCP
   * or UDP.
   */
  oldDestinationPort: number;
  /**
   * Destination port of a new connection. Only valid when protocol is TCP or
   * UDP.
   */
  newDestinationPort: number;
  /** Uri of proxy subnet. */
  subnetUri: string;
  /** URI of the network where connection is proxied. */
  networkUri: string;
}

/** For display only. Metadata associated with the load balancer backend. */
export interface LoadBalancerBackendInfo {
  /**
   * Display name of the backend. For example, it might be an instance name for
   * the instance group backends, or an IP address and port for zonal network
   * endpoint group backends.
   */
  name: string;
  /**
   * URI of the backend instance (if applicable). Populated for instance group
   * backends, and zonal NEG backends.
   */
  instanceUri: string;
  /** URI of the backend service this backend belongs to (if applicable). */
  backendServiceUri: string;
  /** URI of the instance group this backend belongs to (if applicable). */
  instanceGroupUri: string;
  /** URI of the network endpoint group this backend belongs to (if applicable). */
  networkEndpointGroupUri: string;
  /** URI of the backend bucket this backend targets (if applicable). */
  backendBucketUri: string;
  /**
   * URI of the PSC service attachment this PSC NEG backend targets (if
   * applicable).
   */
  pscServiceAttachmentUri: string;
  /** PSC Google API target this PSC NEG backend targets (if applicable). */
  pscGoogleApiTarget: string;
  /** URI of the health check attached to this backend (if applicable). */
  healthCheckUri: string;
  /**
   * Output only. Health check firewalls configuration state for the backend.
   * This is a result of the static firewall analysis (verifying that health
   * check traffic from required IP ranges to the backend is allowed or not).
   * The backend might still be unhealthy even if these firewalls are
   * configured. Please refer to the documentation for more information:
   * https://cloud.google.com/load-balancing/docs/firewall-rules
   */
  healthCheckFirewallsConfigState: LoadBalancerBackendInfo_HealthCheckFirewallsConfigState;
}

/** Health check firewalls configuration state enum. */
export enum LoadBalancerBackendInfo_HealthCheckFirewallsConfigState {
  /**
   * HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED - Configuration state unspecified. It usually means that the backend has
   * no health check attached, or there was an unexpected configuration error
   * preventing Connectivity tests from verifying health check configuration.
   */
  HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED = 0,
  /**
   * FIREWALLS_CONFIGURED - Firewall rules (policies) allowing health check traffic from all required
   * IP ranges to the backend are configured.
   */
  FIREWALLS_CONFIGURED = 1,
  /**
   * FIREWALLS_PARTIALLY_CONFIGURED - Firewall rules (policies) allow health check traffic only from a part of
   * required IP ranges.
   */
  FIREWALLS_PARTIALLY_CONFIGURED = 2,
  /**
   * FIREWALLS_NOT_CONFIGURED - Firewall rules (policies) deny health check traffic from all required
   * IP ranges to the backend.
   */
  FIREWALLS_NOT_CONFIGURED = 3,
  /**
   * FIREWALLS_UNSUPPORTED - The network contains firewall rules of unsupported types, so Connectivity
   * tests were not able to verify health check configuration status. Please
   * refer to the documentation for the list of unsupported configurations:
   * https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/concepts/overview#unsupported-configs
   */
  FIREWALLS_UNSUPPORTED = 4,
  UNRECOGNIZED = -1,
}

export function loadBalancerBackendInfo_HealthCheckFirewallsConfigStateFromJSON(
  object: any,
): LoadBalancerBackendInfo_HealthCheckFirewallsConfigState {
  switch (object) {
    case 0:
    case "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED":
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED;
    case 1:
    case "FIREWALLS_CONFIGURED":
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_CONFIGURED;
    case 2:
    case "FIREWALLS_PARTIALLY_CONFIGURED":
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_PARTIALLY_CONFIGURED;
    case 3:
    case "FIREWALLS_NOT_CONFIGURED":
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_NOT_CONFIGURED;
    case 4:
    case "FIREWALLS_UNSUPPORTED":
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_UNSUPPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.UNRECOGNIZED;
  }
}

export function loadBalancerBackendInfo_HealthCheckFirewallsConfigStateToJSON(
  object: LoadBalancerBackendInfo_HealthCheckFirewallsConfigState,
): string {
  switch (object) {
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED:
      return "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED";
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_CONFIGURED:
      return "FIREWALLS_CONFIGURED";
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_PARTIALLY_CONFIGURED:
      return "FIREWALLS_PARTIALLY_CONFIGURED";
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_NOT_CONFIGURED:
      return "FIREWALLS_NOT_CONFIGURED";
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.FIREWALLS_UNSUPPORTED:
      return "FIREWALLS_UNSUPPORTED";
    case LoadBalancerBackendInfo_HealthCheckFirewallsConfigState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For display only. Metadata associated with Storage Bucket. */
export interface StorageBucketInfo {
  /** Cloud Storage Bucket name. */
  bucket: string;
}

function createBaseTrace(): Trace {
  return { endpointInfo: undefined, steps: [], forwardTraceId: 0 };
}

export const Trace: MessageFns<Trace> = {
  encode(message: Trace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpointInfo !== undefined) {
      EndpointInfo.encode(message.endpointInfo, writer.uint32(10).fork()).join();
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.forwardTraceId !== 0) {
      writer.uint32(32).int32(message.forwardTraceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpointInfo = EndpointInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.forwardTraceId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trace {
    return {
      endpointInfo: isSet(object.endpointInfo) ? EndpointInfo.fromJSON(object.endpointInfo) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
      forwardTraceId: isSet(object.forwardTraceId) ? globalThis.Number(object.forwardTraceId) : 0,
    };
  },

  toJSON(message: Trace): unknown {
    const obj: any = {};
    if (message.endpointInfo !== undefined) {
      obj.endpointInfo = EndpointInfo.toJSON(message.endpointInfo);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    if (message.forwardTraceId !== 0) {
      obj.forwardTraceId = Math.round(message.forwardTraceId);
    }
    return obj;
  },

  create(base?: DeepPartial<Trace>): Trace {
    return Trace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trace>): Trace {
    const message = createBaseTrace();
    message.endpointInfo = (object.endpointInfo !== undefined && object.endpointInfo !== null)
      ? EndpointInfo.fromPartial(object.endpointInfo)
      : undefined;
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    message.forwardTraceId = object.forwardTraceId ?? 0;
    return message;
  },
};

function createBaseStep(): Step {
  return {
    description: "",
    state: 0,
    causesDrop: false,
    projectId: "",
    instance: undefined,
    firewall: undefined,
    route: undefined,
    endpoint: undefined,
    googleService: undefined,
    forwardingRule: undefined,
    vpnGateway: undefined,
    vpnTunnel: undefined,
    vpcConnector: undefined,
    deliver: undefined,
    forward: undefined,
    abort: undefined,
    drop: undefined,
    loadBalancer: undefined,
    network: undefined,
    gkeMaster: undefined,
    cloudSqlInstance: undefined,
    cloudFunction: undefined,
    appEngineVersion: undefined,
    cloudRunRevision: undefined,
    nat: undefined,
    proxyConnection: undefined,
    loadBalancerBackendInfo: undefined,
    storageBucket: undefined,
  };
}

export const Step: MessageFns<Step> = {
  encode(message: Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.causesDrop !== false) {
      writer.uint32(24).bool(message.causesDrop);
    }
    if (message.projectId !== "") {
      writer.uint32(34).string(message.projectId);
    }
    if (message.instance !== undefined) {
      InstanceInfo.encode(message.instance, writer.uint32(42).fork()).join();
    }
    if (message.firewall !== undefined) {
      FirewallInfo.encode(message.firewall, writer.uint32(50).fork()).join();
    }
    if (message.route !== undefined) {
      RouteInfo.encode(message.route, writer.uint32(58).fork()).join();
    }
    if (message.endpoint !== undefined) {
      EndpointInfo.encode(message.endpoint, writer.uint32(66).fork()).join();
    }
    if (message.googleService !== undefined) {
      GoogleServiceInfo.encode(message.googleService, writer.uint32(194).fork()).join();
    }
    if (message.forwardingRule !== undefined) {
      ForwardingRuleInfo.encode(message.forwardingRule, writer.uint32(74).fork()).join();
    }
    if (message.vpnGateway !== undefined) {
      VpnGatewayInfo.encode(message.vpnGateway, writer.uint32(82).fork()).join();
    }
    if (message.vpnTunnel !== undefined) {
      VpnTunnelInfo.encode(message.vpnTunnel, writer.uint32(90).fork()).join();
    }
    if (message.vpcConnector !== undefined) {
      VpcConnectorInfo.encode(message.vpcConnector, writer.uint32(170).fork()).join();
    }
    if (message.deliver !== undefined) {
      DeliverInfo.encode(message.deliver, writer.uint32(98).fork()).join();
    }
    if (message.forward !== undefined) {
      ForwardInfo.encode(message.forward, writer.uint32(106).fork()).join();
    }
    if (message.abort !== undefined) {
      AbortInfo.encode(message.abort, writer.uint32(114).fork()).join();
    }
    if (message.drop !== undefined) {
      DropInfo.encode(message.drop, writer.uint32(122).fork()).join();
    }
    if (message.loadBalancer !== undefined) {
      LoadBalancerInfo.encode(message.loadBalancer, writer.uint32(130).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkInfo.encode(message.network, writer.uint32(138).fork()).join();
    }
    if (message.gkeMaster !== undefined) {
      GKEMasterInfo.encode(message.gkeMaster, writer.uint32(146).fork()).join();
    }
    if (message.cloudSqlInstance !== undefined) {
      CloudSQLInstanceInfo.encode(message.cloudSqlInstance, writer.uint32(154).fork()).join();
    }
    if (message.cloudFunction !== undefined) {
      CloudFunctionInfo.encode(message.cloudFunction, writer.uint32(162).fork()).join();
    }
    if (message.appEngineVersion !== undefined) {
      AppEngineVersionInfo.encode(message.appEngineVersion, writer.uint32(178).fork()).join();
    }
    if (message.cloudRunRevision !== undefined) {
      CloudRunRevisionInfo.encode(message.cloudRunRevision, writer.uint32(186).fork()).join();
    }
    if (message.nat !== undefined) {
      NatInfo.encode(message.nat, writer.uint32(202).fork()).join();
    }
    if (message.proxyConnection !== undefined) {
      ProxyConnectionInfo.encode(message.proxyConnection, writer.uint32(210).fork()).join();
    }
    if (message.loadBalancerBackendInfo !== undefined) {
      LoadBalancerBackendInfo.encode(message.loadBalancerBackendInfo, writer.uint32(218).fork()).join();
    }
    if (message.storageBucket !== undefined) {
      StorageBucketInfo.encode(message.storageBucket, writer.uint32(226).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.causesDrop = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instance = InstanceInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.firewall = FirewallInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.route = RouteInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endpoint = EndpointInfo.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.googleService = GoogleServiceInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.forwardingRule = ForwardingRuleInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vpnGateway = VpnGatewayInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.vpnTunnel = VpnTunnelInfo.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.vpcConnector = VpcConnectorInfo.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.deliver = DeliverInfo.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.forward = ForwardInfo.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.abort = AbortInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.drop = DropInfo.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.loadBalancer = LoadBalancerInfo.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.network = NetworkInfo.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.gkeMaster = GKEMasterInfo.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.cloudSqlInstance = CloudSQLInstanceInfo.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.cloudFunction = CloudFunctionInfo.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.appEngineVersion = AppEngineVersionInfo.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.cloudRunRevision = CloudRunRevisionInfo.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.nat = NatInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.proxyConnection = ProxyConnectionInfo.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.loadBalancerBackendInfo = LoadBalancerBackendInfo.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.storageBucket = StorageBucketInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? step_StateFromJSON(object.state) : 0,
      causesDrop: isSet(object.causesDrop) ? globalThis.Boolean(object.causesDrop) : false,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instance: isSet(object.instance) ? InstanceInfo.fromJSON(object.instance) : undefined,
      firewall: isSet(object.firewall) ? FirewallInfo.fromJSON(object.firewall) : undefined,
      route: isSet(object.route) ? RouteInfo.fromJSON(object.route) : undefined,
      endpoint: isSet(object.endpoint) ? EndpointInfo.fromJSON(object.endpoint) : undefined,
      googleService: isSet(object.googleService) ? GoogleServiceInfo.fromJSON(object.googleService) : undefined,
      forwardingRule: isSet(object.forwardingRule) ? ForwardingRuleInfo.fromJSON(object.forwardingRule) : undefined,
      vpnGateway: isSet(object.vpnGateway) ? VpnGatewayInfo.fromJSON(object.vpnGateway) : undefined,
      vpnTunnel: isSet(object.vpnTunnel) ? VpnTunnelInfo.fromJSON(object.vpnTunnel) : undefined,
      vpcConnector: isSet(object.vpcConnector) ? VpcConnectorInfo.fromJSON(object.vpcConnector) : undefined,
      deliver: isSet(object.deliver) ? DeliverInfo.fromJSON(object.deliver) : undefined,
      forward: isSet(object.forward) ? ForwardInfo.fromJSON(object.forward) : undefined,
      abort: isSet(object.abort) ? AbortInfo.fromJSON(object.abort) : undefined,
      drop: isSet(object.drop) ? DropInfo.fromJSON(object.drop) : undefined,
      loadBalancer: isSet(object.loadBalancer) ? LoadBalancerInfo.fromJSON(object.loadBalancer) : undefined,
      network: isSet(object.network) ? NetworkInfo.fromJSON(object.network) : undefined,
      gkeMaster: isSet(object.gkeMaster) ? GKEMasterInfo.fromJSON(object.gkeMaster) : undefined,
      cloudSqlInstance: isSet(object.cloudSqlInstance)
        ? CloudSQLInstanceInfo.fromJSON(object.cloudSqlInstance)
        : undefined,
      cloudFunction: isSet(object.cloudFunction) ? CloudFunctionInfo.fromJSON(object.cloudFunction) : undefined,
      appEngineVersion: isSet(object.appEngineVersion)
        ? AppEngineVersionInfo.fromJSON(object.appEngineVersion)
        : undefined,
      cloudRunRevision: isSet(object.cloudRunRevision)
        ? CloudRunRevisionInfo.fromJSON(object.cloudRunRevision)
        : undefined,
      nat: isSet(object.nat) ? NatInfo.fromJSON(object.nat) : undefined,
      proxyConnection: isSet(object.proxyConnection) ? ProxyConnectionInfo.fromJSON(object.proxyConnection) : undefined,
      loadBalancerBackendInfo: isSet(object.loadBalancerBackendInfo)
        ? LoadBalancerBackendInfo.fromJSON(object.loadBalancerBackendInfo)
        : undefined,
      storageBucket: isSet(object.storageBucket) ? StorageBucketInfo.fromJSON(object.storageBucket) : undefined,
    };
  },

  toJSON(message: Step): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = step_StateToJSON(message.state);
    }
    if (message.causesDrop !== false) {
      obj.causesDrop = message.causesDrop;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instance !== undefined) {
      obj.instance = InstanceInfo.toJSON(message.instance);
    }
    if (message.firewall !== undefined) {
      obj.firewall = FirewallInfo.toJSON(message.firewall);
    }
    if (message.route !== undefined) {
      obj.route = RouteInfo.toJSON(message.route);
    }
    if (message.endpoint !== undefined) {
      obj.endpoint = EndpointInfo.toJSON(message.endpoint);
    }
    if (message.googleService !== undefined) {
      obj.googleService = GoogleServiceInfo.toJSON(message.googleService);
    }
    if (message.forwardingRule !== undefined) {
      obj.forwardingRule = ForwardingRuleInfo.toJSON(message.forwardingRule);
    }
    if (message.vpnGateway !== undefined) {
      obj.vpnGateway = VpnGatewayInfo.toJSON(message.vpnGateway);
    }
    if (message.vpnTunnel !== undefined) {
      obj.vpnTunnel = VpnTunnelInfo.toJSON(message.vpnTunnel);
    }
    if (message.vpcConnector !== undefined) {
      obj.vpcConnector = VpcConnectorInfo.toJSON(message.vpcConnector);
    }
    if (message.deliver !== undefined) {
      obj.deliver = DeliverInfo.toJSON(message.deliver);
    }
    if (message.forward !== undefined) {
      obj.forward = ForwardInfo.toJSON(message.forward);
    }
    if (message.abort !== undefined) {
      obj.abort = AbortInfo.toJSON(message.abort);
    }
    if (message.drop !== undefined) {
      obj.drop = DropInfo.toJSON(message.drop);
    }
    if (message.loadBalancer !== undefined) {
      obj.loadBalancer = LoadBalancerInfo.toJSON(message.loadBalancer);
    }
    if (message.network !== undefined) {
      obj.network = NetworkInfo.toJSON(message.network);
    }
    if (message.gkeMaster !== undefined) {
      obj.gkeMaster = GKEMasterInfo.toJSON(message.gkeMaster);
    }
    if (message.cloudSqlInstance !== undefined) {
      obj.cloudSqlInstance = CloudSQLInstanceInfo.toJSON(message.cloudSqlInstance);
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = CloudFunctionInfo.toJSON(message.cloudFunction);
    }
    if (message.appEngineVersion !== undefined) {
      obj.appEngineVersion = AppEngineVersionInfo.toJSON(message.appEngineVersion);
    }
    if (message.cloudRunRevision !== undefined) {
      obj.cloudRunRevision = CloudRunRevisionInfo.toJSON(message.cloudRunRevision);
    }
    if (message.nat !== undefined) {
      obj.nat = NatInfo.toJSON(message.nat);
    }
    if (message.proxyConnection !== undefined) {
      obj.proxyConnection = ProxyConnectionInfo.toJSON(message.proxyConnection);
    }
    if (message.loadBalancerBackendInfo !== undefined) {
      obj.loadBalancerBackendInfo = LoadBalancerBackendInfo.toJSON(message.loadBalancerBackendInfo);
    }
    if (message.storageBucket !== undefined) {
      obj.storageBucket = StorageBucketInfo.toJSON(message.storageBucket);
    }
    return obj;
  },

  create(base?: DeepPartial<Step>): Step {
    return Step.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Step>): Step {
    const message = createBaseStep();
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.causesDrop = object.causesDrop ?? false;
    message.projectId = object.projectId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? InstanceInfo.fromPartial(object.instance)
      : undefined;
    message.firewall = (object.firewall !== undefined && object.firewall !== null)
      ? FirewallInfo.fromPartial(object.firewall)
      : undefined;
    message.route = (object.route !== undefined && object.route !== null)
      ? RouteInfo.fromPartial(object.route)
      : undefined;
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? EndpointInfo.fromPartial(object.endpoint)
      : undefined;
    message.googleService = (object.googleService !== undefined && object.googleService !== null)
      ? GoogleServiceInfo.fromPartial(object.googleService)
      : undefined;
    message.forwardingRule = (object.forwardingRule !== undefined && object.forwardingRule !== null)
      ? ForwardingRuleInfo.fromPartial(object.forwardingRule)
      : undefined;
    message.vpnGateway = (object.vpnGateway !== undefined && object.vpnGateway !== null)
      ? VpnGatewayInfo.fromPartial(object.vpnGateway)
      : undefined;
    message.vpnTunnel = (object.vpnTunnel !== undefined && object.vpnTunnel !== null)
      ? VpnTunnelInfo.fromPartial(object.vpnTunnel)
      : undefined;
    message.vpcConnector = (object.vpcConnector !== undefined && object.vpcConnector !== null)
      ? VpcConnectorInfo.fromPartial(object.vpcConnector)
      : undefined;
    message.deliver = (object.deliver !== undefined && object.deliver !== null)
      ? DeliverInfo.fromPartial(object.deliver)
      : undefined;
    message.forward = (object.forward !== undefined && object.forward !== null)
      ? ForwardInfo.fromPartial(object.forward)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? AbortInfo.fromPartial(object.abort)
      : undefined;
    message.drop = (object.drop !== undefined && object.drop !== null) ? DropInfo.fromPartial(object.drop) : undefined;
    message.loadBalancer = (object.loadBalancer !== undefined && object.loadBalancer !== null)
      ? LoadBalancerInfo.fromPartial(object.loadBalancer)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkInfo.fromPartial(object.network)
      : undefined;
    message.gkeMaster = (object.gkeMaster !== undefined && object.gkeMaster !== null)
      ? GKEMasterInfo.fromPartial(object.gkeMaster)
      : undefined;
    message.cloudSqlInstance = (object.cloudSqlInstance !== undefined && object.cloudSqlInstance !== null)
      ? CloudSQLInstanceInfo.fromPartial(object.cloudSqlInstance)
      : undefined;
    message.cloudFunction = (object.cloudFunction !== undefined && object.cloudFunction !== null)
      ? CloudFunctionInfo.fromPartial(object.cloudFunction)
      : undefined;
    message.appEngineVersion = (object.appEngineVersion !== undefined && object.appEngineVersion !== null)
      ? AppEngineVersionInfo.fromPartial(object.appEngineVersion)
      : undefined;
    message.cloudRunRevision = (object.cloudRunRevision !== undefined && object.cloudRunRevision !== null)
      ? CloudRunRevisionInfo.fromPartial(object.cloudRunRevision)
      : undefined;
    message.nat = (object.nat !== undefined && object.nat !== null) ? NatInfo.fromPartial(object.nat) : undefined;
    message.proxyConnection = (object.proxyConnection !== undefined && object.proxyConnection !== null)
      ? ProxyConnectionInfo.fromPartial(object.proxyConnection)
      : undefined;
    message.loadBalancerBackendInfo =
      (object.loadBalancerBackendInfo !== undefined && object.loadBalancerBackendInfo !== null)
        ? LoadBalancerBackendInfo.fromPartial(object.loadBalancerBackendInfo)
        : undefined;
    message.storageBucket = (object.storageBucket !== undefined && object.storageBucket !== null)
      ? StorageBucketInfo.fromPartial(object.storageBucket)
      : undefined;
    return message;
  },
};

function createBaseInstanceInfo(): InstanceInfo {
  return {
    displayName: "",
    uri: "",
    interface: "",
    networkUri: "",
    internalIp: "",
    externalIp: "",
    networkTags: [],
    serviceAccount: "",
  };
}

export const InstanceInfo: MessageFns<InstanceInfo> = {
  encode(message: InstanceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.interface !== "") {
      writer.uint32(26).string(message.interface);
    }
    if (message.networkUri !== "") {
      writer.uint32(34).string(message.networkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    for (const v of message.networkTags) {
      writer.uint32(58).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(66).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interface = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: InstanceInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceInfo>): InstanceInfo {
    return InstanceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceInfo>): InstanceInfo {
    const message = createBaseInstanceInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.interface = object.interface ?? "";
    message.networkUri = object.networkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseNetworkInfo(): NetworkInfo {
  return { displayName: "", uri: "", matchedIpRange: "" };
}

export const NetworkInfo: MessageFns<NetworkInfo> = {
  encode(message: NetworkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.matchedIpRange !== "") {
      writer.uint32(34).string(message.matchedIpRange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.matchedIpRange = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      matchedIpRange: isSet(object.matchedIpRange) ? globalThis.String(object.matchedIpRange) : "",
    };
  },

  toJSON(message: NetworkInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.matchedIpRange !== "") {
      obj.matchedIpRange = message.matchedIpRange;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkInfo>): NetworkInfo {
    return NetworkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkInfo>): NetworkInfo {
    const message = createBaseNetworkInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.matchedIpRange = object.matchedIpRange ?? "";
    return message;
  },
};

function createBaseFirewallInfo(): FirewallInfo {
  return {
    displayName: "",
    uri: "",
    direction: "",
    action: "",
    priority: 0,
    networkUri: "",
    targetTags: [],
    targetServiceAccounts: [],
    policy: "",
    firewallRuleType: 0,
  };
}

export const FirewallInfo: MessageFns<FirewallInfo> = {
  encode(message: FirewallInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.direction !== "") {
      writer.uint32(26).string(message.direction);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.priority !== 0) {
      writer.uint32(40).int32(message.priority);
    }
    if (message.networkUri !== "") {
      writer.uint32(50).string(message.networkUri);
    }
    for (const v of message.targetTags) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.targetServiceAccounts) {
      writer.uint32(66).string(v!);
    }
    if (message.policy !== "") {
      writer.uint32(74).string(message.policy);
    }
    if (message.firewallRuleType !== 0) {
      writer.uint32(80).int32(message.firewallRuleType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FirewallInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFirewallInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.direction = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetTags.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.targetServiceAccounts.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.policy = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.firewallRuleType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FirewallInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      targetTags: globalThis.Array.isArray(object?.targetTags)
        ? object.targetTags.map((e: any) => globalThis.String(e))
        : [],
      targetServiceAccounts: globalThis.Array.isArray(object?.targetServiceAccounts)
        ? object.targetServiceAccounts.map((e: any) => globalThis.String(e))
        : [],
      policy: isSet(object.policy) ? globalThis.String(object.policy) : "",
      firewallRuleType: isSet(object.firewallRuleType)
        ? firewallInfo_FirewallRuleTypeFromJSON(object.firewallRuleType)
        : 0,
    };
  },

  toJSON(message: FirewallInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.targetTags?.length) {
      obj.targetTags = message.targetTags;
    }
    if (message.targetServiceAccounts?.length) {
      obj.targetServiceAccounts = message.targetServiceAccounts;
    }
    if (message.policy !== "") {
      obj.policy = message.policy;
    }
    if (message.firewallRuleType !== 0) {
      obj.firewallRuleType = firewallInfo_FirewallRuleTypeToJSON(message.firewallRuleType);
    }
    return obj;
  },

  create(base?: DeepPartial<FirewallInfo>): FirewallInfo {
    return FirewallInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FirewallInfo>): FirewallInfo {
    const message = createBaseFirewallInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.direction = object.direction ?? "";
    message.action = object.action ?? "";
    message.priority = object.priority ?? 0;
    message.networkUri = object.networkUri ?? "";
    message.targetTags = object.targetTags?.map((e) => e) || [];
    message.targetServiceAccounts = object.targetServiceAccounts?.map((e) => e) || [];
    message.policy = object.policy ?? "";
    message.firewallRuleType = object.firewallRuleType ?? 0;
    return message;
  },
};

function createBaseRouteInfo(): RouteInfo {
  return {
    routeType: 0,
    nextHopType: 0,
    routeScope: 0,
    displayName: "",
    uri: "",
    destIpRange: "",
    nextHop: "",
    networkUri: "",
    priority: 0,
    instanceTags: [],
    srcIpRange: "",
    destPortRanges: [],
    srcPortRanges: [],
    protocols: [],
    nccHubUri: undefined,
    nccSpokeUri: undefined,
  };
}

export const RouteInfo: MessageFns<RouteInfo> = {
  encode(message: RouteInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routeType !== 0) {
      writer.uint32(64).int32(message.routeType);
    }
    if (message.nextHopType !== 0) {
      writer.uint32(72).int32(message.nextHopType);
    }
    if (message.routeScope !== 0) {
      writer.uint32(112).int32(message.routeScope);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.destIpRange !== "") {
      writer.uint32(26).string(message.destIpRange);
    }
    if (message.nextHop !== "") {
      writer.uint32(34).string(message.nextHop);
    }
    if (message.networkUri !== "") {
      writer.uint32(42).string(message.networkUri);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    for (const v of message.instanceTags) {
      writer.uint32(58).string(v!);
    }
    if (message.srcIpRange !== "") {
      writer.uint32(82).string(message.srcIpRange);
    }
    for (const v of message.destPortRanges) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.srcPortRanges) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.protocols) {
      writer.uint32(106).string(v!);
    }
    if (message.nccHubUri !== undefined) {
      writer.uint32(122).string(message.nccHubUri);
    }
    if (message.nccSpokeUri !== undefined) {
      writer.uint32(130).string(message.nccSpokeUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 64) {
            break;
          }

          message.routeType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.nextHopType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.routeScope = reader.int32() as any;
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destIpRange = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextHop = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.instanceTags.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.srcIpRange = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.destPortRanges.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.srcPortRanges.push(reader.string());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.protocols.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.nccHubUri = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.nccSpokeUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteInfo {
    return {
      routeType: isSet(object.routeType) ? routeInfo_RouteTypeFromJSON(object.routeType) : 0,
      nextHopType: isSet(object.nextHopType) ? routeInfo_NextHopTypeFromJSON(object.nextHopType) : 0,
      routeScope: isSet(object.routeScope) ? routeInfo_RouteScopeFromJSON(object.routeScope) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      destIpRange: isSet(object.destIpRange) ? globalThis.String(object.destIpRange) : "",
      nextHop: isSet(object.nextHop) ? globalThis.String(object.nextHop) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      instanceTags: globalThis.Array.isArray(object?.instanceTags)
        ? object.instanceTags.map((e: any) => globalThis.String(e))
        : [],
      srcIpRange: isSet(object.srcIpRange) ? globalThis.String(object.srcIpRange) : "",
      destPortRanges: globalThis.Array.isArray(object?.destPortRanges)
        ? object.destPortRanges.map((e: any) => globalThis.String(e))
        : [],
      srcPortRanges: globalThis.Array.isArray(object?.srcPortRanges)
        ? object.srcPortRanges.map((e: any) => globalThis.String(e))
        : [],
      protocols: globalThis.Array.isArray(object?.protocols)
        ? object.protocols.map((e: any) => globalThis.String(e))
        : [],
      nccHubUri: isSet(object.nccHubUri) ? globalThis.String(object.nccHubUri) : undefined,
      nccSpokeUri: isSet(object.nccSpokeUri) ? globalThis.String(object.nccSpokeUri) : undefined,
    };
  },

  toJSON(message: RouteInfo): unknown {
    const obj: any = {};
    if (message.routeType !== 0) {
      obj.routeType = routeInfo_RouteTypeToJSON(message.routeType);
    }
    if (message.nextHopType !== 0) {
      obj.nextHopType = routeInfo_NextHopTypeToJSON(message.nextHopType);
    }
    if (message.routeScope !== 0) {
      obj.routeScope = routeInfo_RouteScopeToJSON(message.routeScope);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.destIpRange !== "") {
      obj.destIpRange = message.destIpRange;
    }
    if (message.nextHop !== "") {
      obj.nextHop = message.nextHop;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.instanceTags?.length) {
      obj.instanceTags = message.instanceTags;
    }
    if (message.srcIpRange !== "") {
      obj.srcIpRange = message.srcIpRange;
    }
    if (message.destPortRanges?.length) {
      obj.destPortRanges = message.destPortRanges;
    }
    if (message.srcPortRanges?.length) {
      obj.srcPortRanges = message.srcPortRanges;
    }
    if (message.protocols?.length) {
      obj.protocols = message.protocols;
    }
    if (message.nccHubUri !== undefined) {
      obj.nccHubUri = message.nccHubUri;
    }
    if (message.nccSpokeUri !== undefined) {
      obj.nccSpokeUri = message.nccSpokeUri;
    }
    return obj;
  },

  create(base?: DeepPartial<RouteInfo>): RouteInfo {
    return RouteInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteInfo>): RouteInfo {
    const message = createBaseRouteInfo();
    message.routeType = object.routeType ?? 0;
    message.nextHopType = object.nextHopType ?? 0;
    message.routeScope = object.routeScope ?? 0;
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.destIpRange = object.destIpRange ?? "";
    message.nextHop = object.nextHop ?? "";
    message.networkUri = object.networkUri ?? "";
    message.priority = object.priority ?? 0;
    message.instanceTags = object.instanceTags?.map((e) => e) || [];
    message.srcIpRange = object.srcIpRange ?? "";
    message.destPortRanges = object.destPortRanges?.map((e) => e) || [];
    message.srcPortRanges = object.srcPortRanges?.map((e) => e) || [];
    message.protocols = object.protocols?.map((e) => e) || [];
    message.nccHubUri = object.nccHubUri ?? undefined;
    message.nccSpokeUri = object.nccSpokeUri ?? undefined;
    return message;
  },
};

function createBaseGoogleServiceInfo(): GoogleServiceInfo {
  return { sourceIp: "", googleServiceType: 0 };
}

export const GoogleServiceInfo: MessageFns<GoogleServiceInfo> = {
  encode(message: GoogleServiceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceIp !== "") {
      writer.uint32(10).string(message.sourceIp);
    }
    if (message.googleServiceType !== 0) {
      writer.uint32(16).int32(message.googleServiceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleServiceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleServiceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.googleServiceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleServiceInfo {
    return {
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
      googleServiceType: isSet(object.googleServiceType)
        ? googleServiceInfo_GoogleServiceTypeFromJSON(object.googleServiceType)
        : 0,
    };
  },

  toJSON(message: GoogleServiceInfo): unknown {
    const obj: any = {};
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    if (message.googleServiceType !== 0) {
      obj.googleServiceType = googleServiceInfo_GoogleServiceTypeToJSON(message.googleServiceType);
    }
    return obj;
  },

  create(base?: DeepPartial<GoogleServiceInfo>): GoogleServiceInfo {
    return GoogleServiceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoogleServiceInfo>): GoogleServiceInfo {
    const message = createBaseGoogleServiceInfo();
    message.sourceIp = object.sourceIp ?? "";
    message.googleServiceType = object.googleServiceType ?? 0;
    return message;
  },
};

function createBaseForwardingRuleInfo(): ForwardingRuleInfo {
  return { displayName: "", uri: "", matchedProtocol: "", matchedPortRange: "", vip: "", target: "", networkUri: "" };
}

export const ForwardingRuleInfo: MessageFns<ForwardingRuleInfo> = {
  encode(message: ForwardingRuleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.matchedProtocol !== "") {
      writer.uint32(26).string(message.matchedProtocol);
    }
    if (message.matchedPortRange !== "") {
      writer.uint32(50).string(message.matchedPortRange);
    }
    if (message.vip !== "") {
      writer.uint32(34).string(message.vip);
    }
    if (message.target !== "") {
      writer.uint32(42).string(message.target);
    }
    if (message.networkUri !== "") {
      writer.uint32(58).string(message.networkUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardingRuleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardingRuleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.matchedProtocol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.matchedPortRange = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vip = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.target = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardingRuleInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      matchedProtocol: isSet(object.matchedProtocol) ? globalThis.String(object.matchedProtocol) : "",
      matchedPortRange: isSet(object.matchedPortRange) ? globalThis.String(object.matchedPortRange) : "",
      vip: isSet(object.vip) ? globalThis.String(object.vip) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
    };
  },

  toJSON(message: ForwardingRuleInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.matchedProtocol !== "") {
      obj.matchedProtocol = message.matchedProtocol;
    }
    if (message.matchedPortRange !== "") {
      obj.matchedPortRange = message.matchedPortRange;
    }
    if (message.vip !== "") {
      obj.vip = message.vip;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardingRuleInfo>): ForwardingRuleInfo {
    return ForwardingRuleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardingRuleInfo>): ForwardingRuleInfo {
    const message = createBaseForwardingRuleInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.matchedProtocol = object.matchedProtocol ?? "";
    message.matchedPortRange = object.matchedPortRange ?? "";
    message.vip = object.vip ?? "";
    message.target = object.target ?? "";
    message.networkUri = object.networkUri ?? "";
    return message;
  },
};

function createBaseLoadBalancerInfo(): LoadBalancerInfo {
  return { loadBalancerType: 0, healthCheckUri: "", backends: [], backendType: 0, backendUri: "" };
}

export const LoadBalancerInfo: MessageFns<LoadBalancerInfo> = {
  encode(message: LoadBalancerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loadBalancerType !== 0) {
      writer.uint32(8).int32(message.loadBalancerType);
    }
    if (message.healthCheckUri !== "") {
      writer.uint32(18).string(message.healthCheckUri);
    }
    for (const v of message.backends) {
      LoadBalancerBackend.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.backendType !== 0) {
      writer.uint32(32).int32(message.backendType);
    }
    if (message.backendUri !== "") {
      writer.uint32(42).string(message.backendUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.loadBalancerType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.healthCheckUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backends.push(LoadBalancerBackend.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.backendType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.backendUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancerInfo {
    return {
      loadBalancerType: isSet(object.loadBalancerType)
        ? loadBalancerInfo_LoadBalancerTypeFromJSON(object.loadBalancerType)
        : 0,
      healthCheckUri: isSet(object.healthCheckUri) ? globalThis.String(object.healthCheckUri) : "",
      backends: globalThis.Array.isArray(object?.backends)
        ? object.backends.map((e: any) => LoadBalancerBackend.fromJSON(e))
        : [],
      backendType: isSet(object.backendType) ? loadBalancerInfo_BackendTypeFromJSON(object.backendType) : 0,
      backendUri: isSet(object.backendUri) ? globalThis.String(object.backendUri) : "",
    };
  },

  toJSON(message: LoadBalancerInfo): unknown {
    const obj: any = {};
    if (message.loadBalancerType !== 0) {
      obj.loadBalancerType = loadBalancerInfo_LoadBalancerTypeToJSON(message.loadBalancerType);
    }
    if (message.healthCheckUri !== "") {
      obj.healthCheckUri = message.healthCheckUri;
    }
    if (message.backends?.length) {
      obj.backends = message.backends.map((e) => LoadBalancerBackend.toJSON(e));
    }
    if (message.backendType !== 0) {
      obj.backendType = loadBalancerInfo_BackendTypeToJSON(message.backendType);
    }
    if (message.backendUri !== "") {
      obj.backendUri = message.backendUri;
    }
    return obj;
  },

  create(base?: DeepPartial<LoadBalancerInfo>): LoadBalancerInfo {
    return LoadBalancerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoadBalancerInfo>): LoadBalancerInfo {
    const message = createBaseLoadBalancerInfo();
    message.loadBalancerType = object.loadBalancerType ?? 0;
    message.healthCheckUri = object.healthCheckUri ?? "";
    message.backends = object.backends?.map((e) => LoadBalancerBackend.fromPartial(e)) || [];
    message.backendType = object.backendType ?? 0;
    message.backendUri = object.backendUri ?? "";
    return message;
  },
};

function createBaseLoadBalancerBackend(): LoadBalancerBackend {
  return {
    displayName: "",
    uri: "",
    healthCheckFirewallState: 0,
    healthCheckAllowingFirewallRules: [],
    healthCheckBlockingFirewallRules: [],
  };
}

export const LoadBalancerBackend: MessageFns<LoadBalancerBackend> = {
  encode(message: LoadBalancerBackend, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.healthCheckFirewallState !== 0) {
      writer.uint32(24).int32(message.healthCheckFirewallState);
    }
    for (const v of message.healthCheckAllowingFirewallRules) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.healthCheckBlockingFirewallRules) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancerBackend {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancerBackend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.healthCheckFirewallState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.healthCheckAllowingFirewallRules.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.healthCheckBlockingFirewallRules.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancerBackend {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      healthCheckFirewallState: isSet(object.healthCheckFirewallState)
        ? loadBalancerBackend_HealthCheckFirewallStateFromJSON(object.healthCheckFirewallState)
        : 0,
      healthCheckAllowingFirewallRules: globalThis.Array.isArray(object?.healthCheckAllowingFirewallRules)
        ? object.healthCheckAllowingFirewallRules.map((e: any) => globalThis.String(e))
        : [],
      healthCheckBlockingFirewallRules: globalThis.Array.isArray(object?.healthCheckBlockingFirewallRules)
        ? object.healthCheckBlockingFirewallRules.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LoadBalancerBackend): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.healthCheckFirewallState !== 0) {
      obj.healthCheckFirewallState = loadBalancerBackend_HealthCheckFirewallStateToJSON(
        message.healthCheckFirewallState,
      );
    }
    if (message.healthCheckAllowingFirewallRules?.length) {
      obj.healthCheckAllowingFirewallRules = message.healthCheckAllowingFirewallRules;
    }
    if (message.healthCheckBlockingFirewallRules?.length) {
      obj.healthCheckBlockingFirewallRules = message.healthCheckBlockingFirewallRules;
    }
    return obj;
  },

  create(base?: DeepPartial<LoadBalancerBackend>): LoadBalancerBackend {
    return LoadBalancerBackend.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoadBalancerBackend>): LoadBalancerBackend {
    const message = createBaseLoadBalancerBackend();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.healthCheckFirewallState = object.healthCheckFirewallState ?? 0;
    message.healthCheckAllowingFirewallRules = object.healthCheckAllowingFirewallRules?.map((e) => e) || [];
    message.healthCheckBlockingFirewallRules = object.healthCheckBlockingFirewallRules?.map((e) => e) || [];
    return message;
  },
};

function createBaseVpnGatewayInfo(): VpnGatewayInfo {
  return { displayName: "", uri: "", networkUri: "", ipAddress: "", vpnTunnelUri: "", region: "" };
}

export const VpnGatewayInfo: MessageFns<VpnGatewayInfo> = {
  encode(message: VpnGatewayInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.networkUri !== "") {
      writer.uint32(26).string(message.networkUri);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.vpnTunnelUri !== "") {
      writer.uint32(42).string(message.vpnTunnelUri);
    }
    if (message.region !== "") {
      writer.uint32(50).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnGatewayInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnGatewayInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vpnTunnelUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnGatewayInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      vpnTunnelUri: isSet(object.vpnTunnelUri) ? globalThis.String(object.vpnTunnelUri) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: VpnGatewayInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.vpnTunnelUri !== "") {
      obj.vpnTunnelUri = message.vpnTunnelUri;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<VpnGatewayInfo>): VpnGatewayInfo {
    return VpnGatewayInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnGatewayInfo>): VpnGatewayInfo {
    const message = createBaseVpnGatewayInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.networkUri = object.networkUri ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.vpnTunnelUri = object.vpnTunnelUri ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseVpnTunnelInfo(): VpnTunnelInfo {
  return {
    displayName: "",
    uri: "",
    sourceGateway: "",
    remoteGateway: "",
    remoteGatewayIp: "",
    sourceGatewayIp: "",
    networkUri: "",
    region: "",
    routingType: 0,
  };
}

export const VpnTunnelInfo: MessageFns<VpnTunnelInfo> = {
  encode(message: VpnTunnelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.sourceGateway !== "") {
      writer.uint32(26).string(message.sourceGateway);
    }
    if (message.remoteGateway !== "") {
      writer.uint32(34).string(message.remoteGateway);
    }
    if (message.remoteGatewayIp !== "") {
      writer.uint32(42).string(message.remoteGatewayIp);
    }
    if (message.sourceGatewayIp !== "") {
      writer.uint32(50).string(message.sourceGatewayIp);
    }
    if (message.networkUri !== "") {
      writer.uint32(58).string(message.networkUri);
    }
    if (message.region !== "") {
      writer.uint32(66).string(message.region);
    }
    if (message.routingType !== 0) {
      writer.uint32(72).int32(message.routingType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnTunnelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnTunnelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceGateway = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.remoteGateway = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.remoteGatewayIp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceGatewayIp = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.region = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.routingType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnTunnelInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      sourceGateway: isSet(object.sourceGateway) ? globalThis.String(object.sourceGateway) : "",
      remoteGateway: isSet(object.remoteGateway) ? globalThis.String(object.remoteGateway) : "",
      remoteGatewayIp: isSet(object.remoteGatewayIp) ? globalThis.String(object.remoteGatewayIp) : "",
      sourceGatewayIp: isSet(object.sourceGatewayIp) ? globalThis.String(object.sourceGatewayIp) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      routingType: isSet(object.routingType) ? vpnTunnelInfo_RoutingTypeFromJSON(object.routingType) : 0,
    };
  },

  toJSON(message: VpnTunnelInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.sourceGateway !== "") {
      obj.sourceGateway = message.sourceGateway;
    }
    if (message.remoteGateway !== "") {
      obj.remoteGateway = message.remoteGateway;
    }
    if (message.remoteGatewayIp !== "") {
      obj.remoteGatewayIp = message.remoteGatewayIp;
    }
    if (message.sourceGatewayIp !== "") {
      obj.sourceGatewayIp = message.sourceGatewayIp;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.routingType !== 0) {
      obj.routingType = vpnTunnelInfo_RoutingTypeToJSON(message.routingType);
    }
    return obj;
  },

  create(base?: DeepPartial<VpnTunnelInfo>): VpnTunnelInfo {
    return VpnTunnelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnTunnelInfo>): VpnTunnelInfo {
    const message = createBaseVpnTunnelInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.sourceGateway = object.sourceGateway ?? "";
    message.remoteGateway = object.remoteGateway ?? "";
    message.remoteGatewayIp = object.remoteGatewayIp ?? "";
    message.sourceGatewayIp = object.sourceGatewayIp ?? "";
    message.networkUri = object.networkUri ?? "";
    message.region = object.region ?? "";
    message.routingType = object.routingType ?? 0;
    return message;
  },
};

function createBaseEndpointInfo(): EndpointInfo {
  return {
    sourceIp: "",
    destinationIp: "",
    protocol: "",
    sourcePort: 0,
    destinationPort: 0,
    sourceNetworkUri: "",
    destinationNetworkUri: "",
    sourceAgentUri: "",
  };
}

export const EndpointInfo: MessageFns<EndpointInfo> = {
  encode(message: EndpointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceIp !== "") {
      writer.uint32(10).string(message.sourceIp);
    }
    if (message.destinationIp !== "") {
      writer.uint32(18).string(message.destinationIp);
    }
    if (message.protocol !== "") {
      writer.uint32(26).string(message.protocol);
    }
    if (message.sourcePort !== 0) {
      writer.uint32(32).int32(message.sourcePort);
    }
    if (message.destinationPort !== 0) {
      writer.uint32(40).int32(message.destinationPort);
    }
    if (message.sourceNetworkUri !== "") {
      writer.uint32(50).string(message.sourceNetworkUri);
    }
    if (message.destinationNetworkUri !== "") {
      writer.uint32(58).string(message.destinationNetworkUri);
    }
    if (message.sourceAgentUri !== "") {
      writer.uint32(66).string(message.sourceAgentUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationIp = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourcePort = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.destinationPort = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceNetworkUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.destinationNetworkUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sourceAgentUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointInfo {
    return {
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
      destinationIp: isSet(object.destinationIp) ? globalThis.String(object.destinationIp) : "",
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      sourcePort: isSet(object.sourcePort) ? globalThis.Number(object.sourcePort) : 0,
      destinationPort: isSet(object.destinationPort) ? globalThis.Number(object.destinationPort) : 0,
      sourceNetworkUri: isSet(object.sourceNetworkUri) ? globalThis.String(object.sourceNetworkUri) : "",
      destinationNetworkUri: isSet(object.destinationNetworkUri) ? globalThis.String(object.destinationNetworkUri) : "",
      sourceAgentUri: isSet(object.sourceAgentUri) ? globalThis.String(object.sourceAgentUri) : "",
    };
  },

  toJSON(message: EndpointInfo): unknown {
    const obj: any = {};
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    if (message.destinationIp !== "") {
      obj.destinationIp = message.destinationIp;
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.sourcePort !== 0) {
      obj.sourcePort = Math.round(message.sourcePort);
    }
    if (message.destinationPort !== 0) {
      obj.destinationPort = Math.round(message.destinationPort);
    }
    if (message.sourceNetworkUri !== "") {
      obj.sourceNetworkUri = message.sourceNetworkUri;
    }
    if (message.destinationNetworkUri !== "") {
      obj.destinationNetworkUri = message.destinationNetworkUri;
    }
    if (message.sourceAgentUri !== "") {
      obj.sourceAgentUri = message.sourceAgentUri;
    }
    return obj;
  },

  create(base?: DeepPartial<EndpointInfo>): EndpointInfo {
    return EndpointInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndpointInfo>): EndpointInfo {
    const message = createBaseEndpointInfo();
    message.sourceIp = object.sourceIp ?? "";
    message.destinationIp = object.destinationIp ?? "";
    message.protocol = object.protocol ?? "";
    message.sourcePort = object.sourcePort ?? 0;
    message.destinationPort = object.destinationPort ?? 0;
    message.sourceNetworkUri = object.sourceNetworkUri ?? "";
    message.destinationNetworkUri = object.destinationNetworkUri ?? "";
    message.sourceAgentUri = object.sourceAgentUri ?? "";
    return message;
  },
};

function createBaseDeliverInfo(): DeliverInfo {
  return { target: 0, resourceUri: "", ipAddress: "" };
}

export const DeliverInfo: MessageFns<DeliverInfo> = {
  encode(message: DeliverInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliverInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliverInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliverInfo {
    return {
      target: isSet(object.target) ? deliverInfo_TargetFromJSON(object.target) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: DeliverInfo): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = deliverInfo_TargetToJSON(message.target);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<DeliverInfo>): DeliverInfo {
    return DeliverInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliverInfo>): DeliverInfo {
    const message = createBaseDeliverInfo();
    message.target = object.target ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function createBaseForwardInfo(): ForwardInfo {
  return { target: 0, resourceUri: "", ipAddress: "" };
}

export const ForwardInfo: MessageFns<ForwardInfo> = {
  encode(message: ForwardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== 0) {
      writer.uint32(8).int32(message.target);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardInfo {
    return {
      target: isSet(object.target) ? forwardInfo_TargetFromJSON(object.target) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: ForwardInfo): unknown {
    const obj: any = {};
    if (message.target !== 0) {
      obj.target = forwardInfo_TargetToJSON(message.target);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardInfo>): ForwardInfo {
    return ForwardInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardInfo>): ForwardInfo {
    const message = createBaseForwardInfo();
    message.target = object.target ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function createBaseAbortInfo(): AbortInfo {
  return { cause: 0, resourceUri: "", ipAddress: "", projectsMissingPermission: [] };
}

export const AbortInfo: MessageFns<AbortInfo> = {
  encode(message: AbortInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cause !== 0) {
      writer.uint32(8).int32(message.cause);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    for (const v of message.projectsMissingPermission) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbortInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbortInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cause = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.projectsMissingPermission.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbortInfo {
    return {
      cause: isSet(object.cause) ? abortInfo_CauseFromJSON(object.cause) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      projectsMissingPermission: globalThis.Array.isArray(object?.projectsMissingPermission)
        ? object.projectsMissingPermission.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AbortInfo): unknown {
    const obj: any = {};
    if (message.cause !== 0) {
      obj.cause = abortInfo_CauseToJSON(message.cause);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.projectsMissingPermission?.length) {
      obj.projectsMissingPermission = message.projectsMissingPermission;
    }
    return obj;
  },

  create(base?: DeepPartial<AbortInfo>): AbortInfo {
    return AbortInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AbortInfo>): AbortInfo {
    const message = createBaseAbortInfo();
    message.cause = object.cause ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.projectsMissingPermission = object.projectsMissingPermission?.map((e) => e) || [];
    return message;
  },
};

function createBaseDropInfo(): DropInfo {
  return { cause: 0, resourceUri: "", sourceIp: "", destinationIp: "", region: "" };
}

export const DropInfo: MessageFns<DropInfo> = {
  encode(message: DropInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cause !== 0) {
      writer.uint32(8).int32(message.cause);
    }
    if (message.resourceUri !== "") {
      writer.uint32(18).string(message.resourceUri);
    }
    if (message.sourceIp !== "") {
      writer.uint32(26).string(message.sourceIp);
    }
    if (message.destinationIp !== "") {
      writer.uint32(34).string(message.destinationIp);
    }
    if (message.region !== "") {
      writer.uint32(42).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DropInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cause = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationIp = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropInfo {
    return {
      cause: isSet(object.cause) ? dropInfo_CauseFromJSON(object.cause) : 0,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      sourceIp: isSet(object.sourceIp) ? globalThis.String(object.sourceIp) : "",
      destinationIp: isSet(object.destinationIp) ? globalThis.String(object.destinationIp) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: DropInfo): unknown {
    const obj: any = {};
    if (message.cause !== 0) {
      obj.cause = dropInfo_CauseToJSON(message.cause);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.sourceIp !== "") {
      obj.sourceIp = message.sourceIp;
    }
    if (message.destinationIp !== "") {
      obj.destinationIp = message.destinationIp;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<DropInfo>): DropInfo {
    return DropInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DropInfo>): DropInfo {
    const message = createBaseDropInfo();
    message.cause = object.cause ?? 0;
    message.resourceUri = object.resourceUri ?? "";
    message.sourceIp = object.sourceIp ?? "";
    message.destinationIp = object.destinationIp ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseGKEMasterInfo(): GKEMasterInfo {
  return { clusterUri: "", clusterNetworkUri: "", internalIp: "", externalIp: "" };
}

export const GKEMasterInfo: MessageFns<GKEMasterInfo> = {
  encode(message: GKEMasterInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterUri !== "") {
      writer.uint32(18).string(message.clusterUri);
    }
    if (message.clusterNetworkUri !== "") {
      writer.uint32(34).string(message.clusterNetworkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GKEMasterInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGKEMasterInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterNetworkUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GKEMasterInfo {
    return {
      clusterUri: isSet(object.clusterUri) ? globalThis.String(object.clusterUri) : "",
      clusterNetworkUri: isSet(object.clusterNetworkUri) ? globalThis.String(object.clusterNetworkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
    };
  },

  toJSON(message: GKEMasterInfo): unknown {
    const obj: any = {};
    if (message.clusterUri !== "") {
      obj.clusterUri = message.clusterUri;
    }
    if (message.clusterNetworkUri !== "") {
      obj.clusterNetworkUri = message.clusterNetworkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    return obj;
  },

  create(base?: DeepPartial<GKEMasterInfo>): GKEMasterInfo {
    return GKEMasterInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GKEMasterInfo>): GKEMasterInfo {
    const message = createBaseGKEMasterInfo();
    message.clusterUri = object.clusterUri ?? "";
    message.clusterNetworkUri = object.clusterNetworkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    return message;
  },
};

function createBaseCloudSQLInstanceInfo(): CloudSQLInstanceInfo {
  return { displayName: "", uri: "", networkUri: "", internalIp: "", externalIp: "", region: "" };
}

export const CloudSQLInstanceInfo: MessageFns<CloudSQLInstanceInfo> = {
  encode(message: CloudSQLInstanceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.networkUri !== "") {
      writer.uint32(34).string(message.networkUri);
    }
    if (message.internalIp !== "") {
      writer.uint32(42).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(50).string(message.externalIp);
    }
    if (message.region !== "") {
      writer.uint32(58).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudSQLInstanceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudSQLInstanceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudSQLInstanceInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: CloudSQLInstanceInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudSQLInstanceInfo>): CloudSQLInstanceInfo {
    return CloudSQLInstanceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudSQLInstanceInfo>): CloudSQLInstanceInfo {
    const message = createBaseCloudSQLInstanceInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.networkUri = object.networkUri ?? "";
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseCloudFunctionInfo(): CloudFunctionInfo {
  return { displayName: "", uri: "", location: "", versionId: Long.ZERO };
}

export const CloudFunctionInfo: MessageFns<CloudFunctionInfo> = {
  encode(message: CloudFunctionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    if (!message.versionId.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.versionId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudFunctionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudFunctionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.versionId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudFunctionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      versionId: isSet(object.versionId) ? Long.fromValue(object.versionId) : Long.ZERO,
    };
  },

  toJSON(message: CloudFunctionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (!message.versionId.equals(Long.ZERO)) {
      obj.versionId = (message.versionId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<CloudFunctionInfo>): CloudFunctionInfo {
    return CloudFunctionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudFunctionInfo>): CloudFunctionInfo {
    const message = createBaseCloudFunctionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    message.versionId = (object.versionId !== undefined && object.versionId !== null)
      ? Long.fromValue(object.versionId)
      : Long.ZERO;
    return message;
  },
};

function createBaseCloudRunRevisionInfo(): CloudRunRevisionInfo {
  return { displayName: "", uri: "", location: "", serviceUri: "" };
}

export const CloudRunRevisionInfo: MessageFns<CloudRunRevisionInfo> = {
  encode(message: CloudRunRevisionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.serviceUri !== "") {
      writer.uint32(42).string(message.serviceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunRevisionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunRevisionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunRevisionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      serviceUri: isSet(object.serviceUri) ? globalThis.String(object.serviceUri) : "",
    };
  },

  toJSON(message: CloudRunRevisionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.serviceUri !== "") {
      obj.serviceUri = message.serviceUri;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunRevisionInfo>): CloudRunRevisionInfo {
    return CloudRunRevisionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunRevisionInfo>): CloudRunRevisionInfo {
    const message = createBaseCloudRunRevisionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    message.serviceUri = object.serviceUri ?? "";
    return message;
  },
};

function createBaseAppEngineVersionInfo(): AppEngineVersionInfo {
  return { displayName: "", uri: "", runtime: "", environment: "" };
}

export const AppEngineVersionInfo: MessageFns<AppEngineVersionInfo> = {
  encode(message: AppEngineVersionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.runtime !== "") {
      writer.uint32(26).string(message.runtime);
    }
    if (message.environment !== "") {
      writer.uint32(34).string(message.environment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineVersionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineVersionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.runtime = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.environment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineVersionInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      environment: isSet(object.environment) ? globalThis.String(object.environment) : "",
    };
  },

  toJSON(message: AppEngineVersionInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.environment !== "") {
      obj.environment = message.environment;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineVersionInfo>): AppEngineVersionInfo {
    return AppEngineVersionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineVersionInfo>): AppEngineVersionInfo {
    const message = createBaseAppEngineVersionInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.runtime = object.runtime ?? "";
    message.environment = object.environment ?? "";
    return message;
  },
};

function createBaseVpcConnectorInfo(): VpcConnectorInfo {
  return { displayName: "", uri: "", location: "" };
}

export const VpcConnectorInfo: MessageFns<VpcConnectorInfo> = {
  encode(message: VpcConnectorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcConnectorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcConnectorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcConnectorInfo {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: VpcConnectorInfo): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<VpcConnectorInfo>): VpcConnectorInfo {
    return VpcConnectorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcConnectorInfo>): VpcConnectorInfo {
    const message = createBaseVpcConnectorInfo();
    message.displayName = object.displayName ?? "";
    message.uri = object.uri ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseNatInfo(): NatInfo {
  return {
    type: 0,
    protocol: "",
    networkUri: "",
    oldSourceIp: "",
    newSourceIp: "",
    oldDestinationIp: "",
    newDestinationIp: "",
    oldSourcePort: 0,
    newSourcePort: 0,
    oldDestinationPort: 0,
    newDestinationPort: 0,
    routerUri: "",
    natGatewayName: "",
  };
}

export const NatInfo: MessageFns<NatInfo> = {
  encode(message: NatInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.protocol !== "") {
      writer.uint32(18).string(message.protocol);
    }
    if (message.networkUri !== "") {
      writer.uint32(26).string(message.networkUri);
    }
    if (message.oldSourceIp !== "") {
      writer.uint32(34).string(message.oldSourceIp);
    }
    if (message.newSourceIp !== "") {
      writer.uint32(42).string(message.newSourceIp);
    }
    if (message.oldDestinationIp !== "") {
      writer.uint32(50).string(message.oldDestinationIp);
    }
    if (message.newDestinationIp !== "") {
      writer.uint32(58).string(message.newDestinationIp);
    }
    if (message.oldSourcePort !== 0) {
      writer.uint32(64).int32(message.oldSourcePort);
    }
    if (message.newSourcePort !== 0) {
      writer.uint32(72).int32(message.newSourcePort);
    }
    if (message.oldDestinationPort !== 0) {
      writer.uint32(80).int32(message.oldDestinationPort);
    }
    if (message.newDestinationPort !== 0) {
      writer.uint32(88).int32(message.newDestinationPort);
    }
    if (message.routerUri !== "") {
      writer.uint32(98).string(message.routerUri);
    }
    if (message.natGatewayName !== "") {
      writer.uint32(106).string(message.natGatewayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NatInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNatInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networkUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.oldSourceIp = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newSourceIp = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oldDestinationIp = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.newDestinationIp = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.oldSourcePort = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.newSourcePort = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.oldDestinationPort = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.newDestinationPort = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.routerUri = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.natGatewayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NatInfo {
    return {
      type: isSet(object.type) ? natInfo_TypeFromJSON(object.type) : 0,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
      oldSourceIp: isSet(object.oldSourceIp) ? globalThis.String(object.oldSourceIp) : "",
      newSourceIp: isSet(object.newSourceIp) ? globalThis.String(object.newSourceIp) : "",
      oldDestinationIp: isSet(object.oldDestinationIp) ? globalThis.String(object.oldDestinationIp) : "",
      newDestinationIp: isSet(object.newDestinationIp) ? globalThis.String(object.newDestinationIp) : "",
      oldSourcePort: isSet(object.oldSourcePort) ? globalThis.Number(object.oldSourcePort) : 0,
      newSourcePort: isSet(object.newSourcePort) ? globalThis.Number(object.newSourcePort) : 0,
      oldDestinationPort: isSet(object.oldDestinationPort) ? globalThis.Number(object.oldDestinationPort) : 0,
      newDestinationPort: isSet(object.newDestinationPort) ? globalThis.Number(object.newDestinationPort) : 0,
      routerUri: isSet(object.routerUri) ? globalThis.String(object.routerUri) : "",
      natGatewayName: isSet(object.natGatewayName) ? globalThis.String(object.natGatewayName) : "",
    };
  },

  toJSON(message: NatInfo): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = natInfo_TypeToJSON(message.type);
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    if (message.oldSourceIp !== "") {
      obj.oldSourceIp = message.oldSourceIp;
    }
    if (message.newSourceIp !== "") {
      obj.newSourceIp = message.newSourceIp;
    }
    if (message.oldDestinationIp !== "") {
      obj.oldDestinationIp = message.oldDestinationIp;
    }
    if (message.newDestinationIp !== "") {
      obj.newDestinationIp = message.newDestinationIp;
    }
    if (message.oldSourcePort !== 0) {
      obj.oldSourcePort = Math.round(message.oldSourcePort);
    }
    if (message.newSourcePort !== 0) {
      obj.newSourcePort = Math.round(message.newSourcePort);
    }
    if (message.oldDestinationPort !== 0) {
      obj.oldDestinationPort = Math.round(message.oldDestinationPort);
    }
    if (message.newDestinationPort !== 0) {
      obj.newDestinationPort = Math.round(message.newDestinationPort);
    }
    if (message.routerUri !== "") {
      obj.routerUri = message.routerUri;
    }
    if (message.natGatewayName !== "") {
      obj.natGatewayName = message.natGatewayName;
    }
    return obj;
  },

  create(base?: DeepPartial<NatInfo>): NatInfo {
    return NatInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NatInfo>): NatInfo {
    const message = createBaseNatInfo();
    message.type = object.type ?? 0;
    message.protocol = object.protocol ?? "";
    message.networkUri = object.networkUri ?? "";
    message.oldSourceIp = object.oldSourceIp ?? "";
    message.newSourceIp = object.newSourceIp ?? "";
    message.oldDestinationIp = object.oldDestinationIp ?? "";
    message.newDestinationIp = object.newDestinationIp ?? "";
    message.oldSourcePort = object.oldSourcePort ?? 0;
    message.newSourcePort = object.newSourcePort ?? 0;
    message.oldDestinationPort = object.oldDestinationPort ?? 0;
    message.newDestinationPort = object.newDestinationPort ?? 0;
    message.routerUri = object.routerUri ?? "";
    message.natGatewayName = object.natGatewayName ?? "";
    return message;
  },
};

function createBaseProxyConnectionInfo(): ProxyConnectionInfo {
  return {
    protocol: "",
    oldSourceIp: "",
    newSourceIp: "",
    oldDestinationIp: "",
    newDestinationIp: "",
    oldSourcePort: 0,
    newSourcePort: 0,
    oldDestinationPort: 0,
    newDestinationPort: 0,
    subnetUri: "",
    networkUri: "",
  };
}

export const ProxyConnectionInfo: MessageFns<ProxyConnectionInfo> = {
  encode(message: ProxyConnectionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== "") {
      writer.uint32(10).string(message.protocol);
    }
    if (message.oldSourceIp !== "") {
      writer.uint32(18).string(message.oldSourceIp);
    }
    if (message.newSourceIp !== "") {
      writer.uint32(26).string(message.newSourceIp);
    }
    if (message.oldDestinationIp !== "") {
      writer.uint32(34).string(message.oldDestinationIp);
    }
    if (message.newDestinationIp !== "") {
      writer.uint32(42).string(message.newDestinationIp);
    }
    if (message.oldSourcePort !== 0) {
      writer.uint32(48).int32(message.oldSourcePort);
    }
    if (message.newSourcePort !== 0) {
      writer.uint32(56).int32(message.newSourcePort);
    }
    if (message.oldDestinationPort !== 0) {
      writer.uint32(64).int32(message.oldDestinationPort);
    }
    if (message.newDestinationPort !== 0) {
      writer.uint32(72).int32(message.newDestinationPort);
    }
    if (message.subnetUri !== "") {
      writer.uint32(82).string(message.subnetUri);
    }
    if (message.networkUri !== "") {
      writer.uint32(90).string(message.networkUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProxyConnectionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProxyConnectionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.oldSourceIp = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.newSourceIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.oldDestinationIp = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.newDestinationIp = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.oldSourcePort = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.newSourcePort = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.oldDestinationPort = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.newDestinationPort = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.subnetUri = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.networkUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProxyConnectionInfo {
    return {
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      oldSourceIp: isSet(object.oldSourceIp) ? globalThis.String(object.oldSourceIp) : "",
      newSourceIp: isSet(object.newSourceIp) ? globalThis.String(object.newSourceIp) : "",
      oldDestinationIp: isSet(object.oldDestinationIp) ? globalThis.String(object.oldDestinationIp) : "",
      newDestinationIp: isSet(object.newDestinationIp) ? globalThis.String(object.newDestinationIp) : "",
      oldSourcePort: isSet(object.oldSourcePort) ? globalThis.Number(object.oldSourcePort) : 0,
      newSourcePort: isSet(object.newSourcePort) ? globalThis.Number(object.newSourcePort) : 0,
      oldDestinationPort: isSet(object.oldDestinationPort) ? globalThis.Number(object.oldDestinationPort) : 0,
      newDestinationPort: isSet(object.newDestinationPort) ? globalThis.Number(object.newDestinationPort) : 0,
      subnetUri: isSet(object.subnetUri) ? globalThis.String(object.subnetUri) : "",
      networkUri: isSet(object.networkUri) ? globalThis.String(object.networkUri) : "",
    };
  },

  toJSON(message: ProxyConnectionInfo): unknown {
    const obj: any = {};
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.oldSourceIp !== "") {
      obj.oldSourceIp = message.oldSourceIp;
    }
    if (message.newSourceIp !== "") {
      obj.newSourceIp = message.newSourceIp;
    }
    if (message.oldDestinationIp !== "") {
      obj.oldDestinationIp = message.oldDestinationIp;
    }
    if (message.newDestinationIp !== "") {
      obj.newDestinationIp = message.newDestinationIp;
    }
    if (message.oldSourcePort !== 0) {
      obj.oldSourcePort = Math.round(message.oldSourcePort);
    }
    if (message.newSourcePort !== 0) {
      obj.newSourcePort = Math.round(message.newSourcePort);
    }
    if (message.oldDestinationPort !== 0) {
      obj.oldDestinationPort = Math.round(message.oldDestinationPort);
    }
    if (message.newDestinationPort !== 0) {
      obj.newDestinationPort = Math.round(message.newDestinationPort);
    }
    if (message.subnetUri !== "") {
      obj.subnetUri = message.subnetUri;
    }
    if (message.networkUri !== "") {
      obj.networkUri = message.networkUri;
    }
    return obj;
  },

  create(base?: DeepPartial<ProxyConnectionInfo>): ProxyConnectionInfo {
    return ProxyConnectionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProxyConnectionInfo>): ProxyConnectionInfo {
    const message = createBaseProxyConnectionInfo();
    message.protocol = object.protocol ?? "";
    message.oldSourceIp = object.oldSourceIp ?? "";
    message.newSourceIp = object.newSourceIp ?? "";
    message.oldDestinationIp = object.oldDestinationIp ?? "";
    message.newDestinationIp = object.newDestinationIp ?? "";
    message.oldSourcePort = object.oldSourcePort ?? 0;
    message.newSourcePort = object.newSourcePort ?? 0;
    message.oldDestinationPort = object.oldDestinationPort ?? 0;
    message.newDestinationPort = object.newDestinationPort ?? 0;
    message.subnetUri = object.subnetUri ?? "";
    message.networkUri = object.networkUri ?? "";
    return message;
  },
};

function createBaseLoadBalancerBackendInfo(): LoadBalancerBackendInfo {
  return {
    name: "",
    instanceUri: "",
    backendServiceUri: "",
    instanceGroupUri: "",
    networkEndpointGroupUri: "",
    backendBucketUri: "",
    pscServiceAttachmentUri: "",
    pscGoogleApiTarget: "",
    healthCheckUri: "",
    healthCheckFirewallsConfigState: 0,
  };
}

export const LoadBalancerBackendInfo: MessageFns<LoadBalancerBackendInfo> = {
  encode(message: LoadBalancerBackendInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.instanceUri !== "") {
      writer.uint32(18).string(message.instanceUri);
    }
    if (message.backendServiceUri !== "") {
      writer.uint32(26).string(message.backendServiceUri);
    }
    if (message.instanceGroupUri !== "") {
      writer.uint32(34).string(message.instanceGroupUri);
    }
    if (message.networkEndpointGroupUri !== "") {
      writer.uint32(42).string(message.networkEndpointGroupUri);
    }
    if (message.backendBucketUri !== "") {
      writer.uint32(66).string(message.backendBucketUri);
    }
    if (message.pscServiceAttachmentUri !== "") {
      writer.uint32(74).string(message.pscServiceAttachmentUri);
    }
    if (message.pscGoogleApiTarget !== "") {
      writer.uint32(82).string(message.pscGoogleApiTarget);
    }
    if (message.healthCheckUri !== "") {
      writer.uint32(50).string(message.healthCheckUri);
    }
    if (message.healthCheckFirewallsConfigState !== 0) {
      writer.uint32(56).int32(message.healthCheckFirewallsConfigState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadBalancerBackendInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadBalancerBackendInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backendServiceUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instanceGroupUri = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.networkEndpointGroupUri = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.backendBucketUri = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pscServiceAttachmentUri = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pscGoogleApiTarget = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.healthCheckUri = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.healthCheckFirewallsConfigState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadBalancerBackendInfo {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instanceUri: isSet(object.instanceUri) ? globalThis.String(object.instanceUri) : "",
      backendServiceUri: isSet(object.backendServiceUri) ? globalThis.String(object.backendServiceUri) : "",
      instanceGroupUri: isSet(object.instanceGroupUri) ? globalThis.String(object.instanceGroupUri) : "",
      networkEndpointGroupUri: isSet(object.networkEndpointGroupUri)
        ? globalThis.String(object.networkEndpointGroupUri)
        : "",
      backendBucketUri: isSet(object.backendBucketUri) ? globalThis.String(object.backendBucketUri) : "",
      pscServiceAttachmentUri: isSet(object.pscServiceAttachmentUri)
        ? globalThis.String(object.pscServiceAttachmentUri)
        : "",
      pscGoogleApiTarget: isSet(object.pscGoogleApiTarget) ? globalThis.String(object.pscGoogleApiTarget) : "",
      healthCheckUri: isSet(object.healthCheckUri) ? globalThis.String(object.healthCheckUri) : "",
      healthCheckFirewallsConfigState: isSet(object.healthCheckFirewallsConfigState)
        ? loadBalancerBackendInfo_HealthCheckFirewallsConfigStateFromJSON(object.healthCheckFirewallsConfigState)
        : 0,
    };
  },

  toJSON(message: LoadBalancerBackendInfo): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instanceUri !== "") {
      obj.instanceUri = message.instanceUri;
    }
    if (message.backendServiceUri !== "") {
      obj.backendServiceUri = message.backendServiceUri;
    }
    if (message.instanceGroupUri !== "") {
      obj.instanceGroupUri = message.instanceGroupUri;
    }
    if (message.networkEndpointGroupUri !== "") {
      obj.networkEndpointGroupUri = message.networkEndpointGroupUri;
    }
    if (message.backendBucketUri !== "") {
      obj.backendBucketUri = message.backendBucketUri;
    }
    if (message.pscServiceAttachmentUri !== "") {
      obj.pscServiceAttachmentUri = message.pscServiceAttachmentUri;
    }
    if (message.pscGoogleApiTarget !== "") {
      obj.pscGoogleApiTarget = message.pscGoogleApiTarget;
    }
    if (message.healthCheckUri !== "") {
      obj.healthCheckUri = message.healthCheckUri;
    }
    if (message.healthCheckFirewallsConfigState !== 0) {
      obj.healthCheckFirewallsConfigState = loadBalancerBackendInfo_HealthCheckFirewallsConfigStateToJSON(
        message.healthCheckFirewallsConfigState,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<LoadBalancerBackendInfo>): LoadBalancerBackendInfo {
    return LoadBalancerBackendInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoadBalancerBackendInfo>): LoadBalancerBackendInfo {
    const message = createBaseLoadBalancerBackendInfo();
    message.name = object.name ?? "";
    message.instanceUri = object.instanceUri ?? "";
    message.backendServiceUri = object.backendServiceUri ?? "";
    message.instanceGroupUri = object.instanceGroupUri ?? "";
    message.networkEndpointGroupUri = object.networkEndpointGroupUri ?? "";
    message.backendBucketUri = object.backendBucketUri ?? "";
    message.pscServiceAttachmentUri = object.pscServiceAttachmentUri ?? "";
    message.pscGoogleApiTarget = object.pscGoogleApiTarget ?? "";
    message.healthCheckUri = object.healthCheckUri ?? "";
    message.healthCheckFirewallsConfigState = object.healthCheckFirewallsConfigState ?? 0;
    return message;
  },
};

function createBaseStorageBucketInfo(): StorageBucketInfo {
  return { bucket: "" };
}

export const StorageBucketInfo: MessageFns<StorageBucketInfo> = {
  encode(message: StorageBucketInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageBucketInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageBucketInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageBucketInfo {
    return { bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "" };
  },

  toJSON(message: StorageBucketInfo): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    return obj;
  },

  create(base?: DeepPartial<StorageBucketInfo>): StorageBucketInfo {
    return StorageBucketInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageBucketInfo>): StorageBucketInfo {
    const message = createBaseStorageBucketInfo();
    message.bucket = object.bucket ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
