// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/blockchainnodeengine/v1/blockchainnodeengine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.blockchainnodeengine.v1";

/** A representation of a blockchain node. */
export interface BlockchainNode {
  /** Ethereum-specific blockchain node details. */
  ethereumDetails?:
    | BlockchainNode_EthereumDetails
    | undefined;
  /**
   * Output only. The fully qualified name of the blockchain node.
   * e.g. `projects/my-project/locations/us-central1/blockchainNodes/my-node`.
   */
  name: string;
  /** Output only. The timestamp at which the blockchain node was first created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp at which the blockchain node was last updated. */
  updateTime:
    | Date
    | undefined;
  /** User-provided key-value pairs. */
  labels: { [key: string]: string };
  /** Immutable. The blockchain type of the node. */
  blockchainType?:
    | BlockchainNode_BlockchainType
    | undefined;
  /**
   * Output only. The connection information used to interact with a blockchain
   * node.
   */
  connectionInfo:
    | BlockchainNode_ConnectionInfo
    | undefined;
  /** Output only. A status representing the state of the node. */
  state: BlockchainNode_State;
  /**
   * Optional. When true, the node is only accessible via Private Service
   * Connect; no public endpoints are exposed. Otherwise, the node is only
   * accessible via public endpoints. Warning: Private Service Connect enabled
   * nodes may require a manual migration effort to remain compatible with
   * future versions of the product. If this feature is enabled, you will be
   * notified of these changes along with any required action to avoid
   * disruption. See https://cloud.google.com/vpc/docs/private-service-connect.
   */
  privateServiceConnectEnabled: boolean;
}

/** The blockchain type of the node. */
export enum BlockchainNode_BlockchainType {
  /** BLOCKCHAIN_TYPE_UNSPECIFIED - Blockchain type has not been specified, but should be. */
  BLOCKCHAIN_TYPE_UNSPECIFIED = 0,
  /** ETHEREUM - The blockchain type is Ethereum. */
  ETHEREUM = 1,
  UNRECOGNIZED = -1,
}

export function blockchainNode_BlockchainTypeFromJSON(object: any): BlockchainNode_BlockchainType {
  switch (object) {
    case 0:
    case "BLOCKCHAIN_TYPE_UNSPECIFIED":
      return BlockchainNode_BlockchainType.BLOCKCHAIN_TYPE_UNSPECIFIED;
    case 1:
    case "ETHEREUM":
      return BlockchainNode_BlockchainType.ETHEREUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_BlockchainType.UNRECOGNIZED;
  }
}

export function blockchainNode_BlockchainTypeToJSON(object: BlockchainNode_BlockchainType): string {
  switch (object) {
    case BlockchainNode_BlockchainType.BLOCKCHAIN_TYPE_UNSPECIFIED:
      return "BLOCKCHAIN_TYPE_UNSPECIFIED";
    case BlockchainNode_BlockchainType.ETHEREUM:
      return "ETHEREUM";
    case BlockchainNode_BlockchainType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** All possible states for a given blockchain node. */
export enum BlockchainNode_State {
  /** STATE_UNSPECIFIED - The state has not been specified. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The node has been requested and is in the process of being created. */
  CREATING = 1,
  /** DELETING - The existing node is undergoing deletion, but is not yet finished. */
  DELETING = 2,
  /** RUNNING - The node is running and ready for use. */
  RUNNING = 4,
  /** ERROR - The node is in an unexpected or errored state. */
  ERROR = 5,
  /** UPDATING - The node is currently being updated. */
  UPDATING = 6,
  /** REPAIRING - The node is currently being repaired. */
  REPAIRING = 7,
  /** RECONCILING - The node is currently being reconciled. */
  RECONCILING = 8,
  /**
   * SYNCING - The node is syncing, which is the process by which it obtains the latest
   * block and current global state.
   */
  SYNCING = 9,
  UNRECOGNIZED = -1,
}

export function blockchainNode_StateFromJSON(object: any): BlockchainNode_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BlockchainNode_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return BlockchainNode_State.CREATING;
    case 2:
    case "DELETING":
      return BlockchainNode_State.DELETING;
    case 4:
    case "RUNNING":
      return BlockchainNode_State.RUNNING;
    case 5:
    case "ERROR":
      return BlockchainNode_State.ERROR;
    case 6:
    case "UPDATING":
      return BlockchainNode_State.UPDATING;
    case 7:
    case "REPAIRING":
      return BlockchainNode_State.REPAIRING;
    case 8:
    case "RECONCILING":
      return BlockchainNode_State.RECONCILING;
    case 9:
    case "SYNCING":
      return BlockchainNode_State.SYNCING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_State.UNRECOGNIZED;
  }
}

export function blockchainNode_StateToJSON(object: BlockchainNode_State): string {
  switch (object) {
    case BlockchainNode_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BlockchainNode_State.CREATING:
      return "CREATING";
    case BlockchainNode_State.DELETING:
      return "DELETING";
    case BlockchainNode_State.RUNNING:
      return "RUNNING";
    case BlockchainNode_State.ERROR:
      return "ERROR";
    case BlockchainNode_State.UPDATING:
      return "UPDATING";
    case BlockchainNode_State.REPAIRING:
      return "REPAIRING";
    case BlockchainNode_State.RECONCILING:
      return "RECONCILING";
    case BlockchainNode_State.SYNCING:
      return "SYNCING";
    case BlockchainNode_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The connection information through which to interact with a blockchain
 * node.
 */
export interface BlockchainNode_ConnectionInfo {
  /**
   * Output only. The endpoint information through which to interact with a
   * blockchain node.
   */
  endpointInfo:
    | BlockchainNode_ConnectionInfo_EndpointInfo
    | undefined;
  /**
   * Output only. A service attachment that exposes a node, and has the
   * following format:
   * projects/{project}/regions/{region}/serviceAttachments/{service_attachment_name}
   */
  serviceAttachment: string;
}

/**
 * Contains endpoint information through which to interact with a blockchain
 * node.
 */
export interface BlockchainNode_ConnectionInfo_EndpointInfo {
  /** Output only. The assigned URL for the node JSON-RPC API endpoint. */
  jsonRpcApiEndpoint: string;
  /** Output only. The assigned URL for the node WebSockets API endpoint. */
  websocketsApiEndpoint: string;
}

/** Ethereum-specific blockchain node details. */
export interface BlockchainNode_EthereumDetails {
  /** Details for the Geth execution client. */
  gethDetails?:
    | BlockchainNode_EthereumDetails_GethDetails
    | undefined;
  /** Immutable. The Ethereum environment being accessed. */
  network?:
    | BlockchainNode_EthereumDetails_Network
    | undefined;
  /** Immutable. The type of Ethereum node. */
  nodeType?:
    | BlockchainNode_EthereumDetails_NodeType
    | undefined;
  /** Immutable. The execution client */
  executionClient?:
    | BlockchainNode_EthereumDetails_ExecutionClient
    | undefined;
  /** Immutable. The consensus client. */
  consensusClient?:
    | BlockchainNode_EthereumDetails_ConsensusClient
    | undefined;
  /**
   * Immutable. Enables JSON-RPC access to functions in the `admin` namespace.
   * Defaults to `false`.
   */
  apiEnableAdmin?:
    | boolean
    | undefined;
  /**
   * Immutable. Enables JSON-RPC access to functions in the `debug` namespace.
   * Defaults to `false`.
   */
  apiEnableDebug?:
    | boolean
    | undefined;
  /** Output only. Ethereum-specific endpoint information. */
  additionalEndpoints?:
    | BlockchainNode_EthereumDetails_EthereumEndpoints
    | undefined;
  /**
   * Configuration for validator-related parameters on the beacon client,
   * and for any GCP-managed validator client.
   */
  validatorConfig?: BlockchainNode_EthereumDetails_ValidatorConfig | undefined;
}

/**
 * The Ethereum environment being accessed.
 *
 * See [Networks](https://ethereum.org/en/developers/docs/networks)
 * for more details.
 */
export enum BlockchainNode_EthereumDetails_Network {
  /** NETWORK_UNSPECIFIED - The network has not been specified, but should be. */
  NETWORK_UNSPECIFIED = 0,
  /** MAINNET - The Ethereum Mainnet. */
  MAINNET = 1,
  /**
   * TESTNET_GOERLI_PRATER - Deprecated: The Ethereum Testnet based on Goerli protocol. Please
   * use another test network.
   *
   * @deprecated
   */
  TESTNET_GOERLI_PRATER = 2,
  /**
   * TESTNET_SEPOLIA - The Ethereum Testnet based on Sepolia/Bepolia protocol.
   * See https://github.com/eth-clients/sepolia.
   */
  TESTNET_SEPOLIA = 3,
  /**
   * TESTNET_HOLESKY - The Ethereum Testnet based on Holesky specification.
   * See https://github.com/eth-clients/holesky.
   */
  TESTNET_HOLESKY = 4,
  UNRECOGNIZED = -1,
}

export function blockchainNode_EthereumDetails_NetworkFromJSON(object: any): BlockchainNode_EthereumDetails_Network {
  switch (object) {
    case 0:
    case "NETWORK_UNSPECIFIED":
      return BlockchainNode_EthereumDetails_Network.NETWORK_UNSPECIFIED;
    case 1:
    case "MAINNET":
      return BlockchainNode_EthereumDetails_Network.MAINNET;
    case 2:
    case "TESTNET_GOERLI_PRATER":
      return BlockchainNode_EthereumDetails_Network.TESTNET_GOERLI_PRATER;
    case 3:
    case "TESTNET_SEPOLIA":
      return BlockchainNode_EthereumDetails_Network.TESTNET_SEPOLIA;
    case 4:
    case "TESTNET_HOLESKY":
      return BlockchainNode_EthereumDetails_Network.TESTNET_HOLESKY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_EthereumDetails_Network.UNRECOGNIZED;
  }
}

export function blockchainNode_EthereumDetails_NetworkToJSON(object: BlockchainNode_EthereumDetails_Network): string {
  switch (object) {
    case BlockchainNode_EthereumDetails_Network.NETWORK_UNSPECIFIED:
      return "NETWORK_UNSPECIFIED";
    case BlockchainNode_EthereumDetails_Network.MAINNET:
      return "MAINNET";
    case BlockchainNode_EthereumDetails_Network.TESTNET_GOERLI_PRATER:
      return "TESTNET_GOERLI_PRATER";
    case BlockchainNode_EthereumDetails_Network.TESTNET_SEPOLIA:
      return "TESTNET_SEPOLIA";
    case BlockchainNode_EthereumDetails_Network.TESTNET_HOLESKY:
      return "TESTNET_HOLESKY";
    case BlockchainNode_EthereumDetails_Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The type of Ethereum node.
 *
 * See
 * [Node
 * Types](https://ethereum.org/en/developers/docs/nodes-and-clients/#node-types)
 * for more details.
 */
export enum BlockchainNode_EthereumDetails_NodeType {
  /** NODE_TYPE_UNSPECIFIED - Node type has not been specified, but should be. */
  NODE_TYPE_UNSPECIFIED = 0,
  /** LIGHT - An Ethereum node that only downloads Ethereum block headers. */
  LIGHT = 1,
  /**
   * FULL - Keeps a complete copy of the blockchain data, and contributes to the
   * network by receiving, validating, and forwarding transactions.
   */
  FULL = 2,
  /**
   * ARCHIVE - Holds the same data as full node as well as all of the blockchain's
   * history state data dating back to the Genesis Block.
   */
  ARCHIVE = 3,
  UNRECOGNIZED = -1,
}

export function blockchainNode_EthereumDetails_NodeTypeFromJSON(object: any): BlockchainNode_EthereumDetails_NodeType {
  switch (object) {
    case 0:
    case "NODE_TYPE_UNSPECIFIED":
      return BlockchainNode_EthereumDetails_NodeType.NODE_TYPE_UNSPECIFIED;
    case 1:
    case "LIGHT":
      return BlockchainNode_EthereumDetails_NodeType.LIGHT;
    case 2:
    case "FULL":
      return BlockchainNode_EthereumDetails_NodeType.FULL;
    case 3:
    case "ARCHIVE":
      return BlockchainNode_EthereumDetails_NodeType.ARCHIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_EthereumDetails_NodeType.UNRECOGNIZED;
  }
}

export function blockchainNode_EthereumDetails_NodeTypeToJSON(object: BlockchainNode_EthereumDetails_NodeType): string {
  switch (object) {
    case BlockchainNode_EthereumDetails_NodeType.NODE_TYPE_UNSPECIFIED:
      return "NODE_TYPE_UNSPECIFIED";
    case BlockchainNode_EthereumDetails_NodeType.LIGHT:
      return "LIGHT";
    case BlockchainNode_EthereumDetails_NodeType.FULL:
      return "FULL";
    case BlockchainNode_EthereumDetails_NodeType.ARCHIVE:
      return "ARCHIVE";
    case BlockchainNode_EthereumDetails_NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The execution client (i.e., Execution Engine or EL client) listens to new
 * transactions broadcast in the network, executes them in EVM, and holds
 * the latest state and database of all current Ethereum data.
 *
 * See
 * [What are nodes and
 * clients?](https://ethereum.org/en/developers/docs/nodes-and-clients/#what-are-nodes-and-clients)
 * for more details.
 */
export enum BlockchainNode_EthereumDetails_ExecutionClient {
  /** EXECUTION_CLIENT_UNSPECIFIED - Execution client has not been specified, but should be. */
  EXECUTION_CLIENT_UNSPECIFIED = 0,
  /**
   * GETH - Official Go implementation of the Ethereum protocol.
   * See [go-ethereum](https://geth.ethereum.org/) for details.
   */
  GETH = 1,
  /**
   * ERIGON - An implementation of Ethereum (execution client), on the efficiency
   * frontier, written in Go. See [Erigon on
   * GitHub](https://github.com/ledgerwatch/erigon) for details.
   */
  ERIGON = 2,
  UNRECOGNIZED = -1,
}

export function blockchainNode_EthereumDetails_ExecutionClientFromJSON(
  object: any,
): BlockchainNode_EthereumDetails_ExecutionClient {
  switch (object) {
    case 0:
    case "EXECUTION_CLIENT_UNSPECIFIED":
      return BlockchainNode_EthereumDetails_ExecutionClient.EXECUTION_CLIENT_UNSPECIFIED;
    case 1:
    case "GETH":
      return BlockchainNode_EthereumDetails_ExecutionClient.GETH;
    case 2:
    case "ERIGON":
      return BlockchainNode_EthereumDetails_ExecutionClient.ERIGON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_EthereumDetails_ExecutionClient.UNRECOGNIZED;
  }
}

export function blockchainNode_EthereumDetails_ExecutionClientToJSON(
  object: BlockchainNode_EthereumDetails_ExecutionClient,
): string {
  switch (object) {
    case BlockchainNode_EthereumDetails_ExecutionClient.EXECUTION_CLIENT_UNSPECIFIED:
      return "EXECUTION_CLIENT_UNSPECIFIED";
    case BlockchainNode_EthereumDetails_ExecutionClient.GETH:
      return "GETH";
    case BlockchainNode_EthereumDetails_ExecutionClient.ERIGON:
      return "ERIGON";
    case BlockchainNode_EthereumDetails_ExecutionClient.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The consensus client (also referred to as beacon node or CL client)
 * implements the proof-of-stake consensus algorithm, which enables the
 * network to achieve agreement based on validated data from the
 * execution client.
 *
 * See
 * [What are nodes and
 * clients?](https://ethereum.org/en/developers/docs/nodes-and-clients/#what-are-nodes-and-clients)
 * for more details.
 */
export enum BlockchainNode_EthereumDetails_ConsensusClient {
  /** CONSENSUS_CLIENT_UNSPECIFIED - Consensus client has not been specified, but should be. */
  CONSENSUS_CLIENT_UNSPECIFIED = 0,
  /**
   * LIGHTHOUSE - Consensus client implementation written in Rust, maintained by Sigma
   * Prime. See [Lighthouse - Sigma
   * Prime](https://lighthouse.sigmaprime.io/) for details.
   */
  LIGHTHOUSE = 1,
  UNRECOGNIZED = -1,
}

export function blockchainNode_EthereumDetails_ConsensusClientFromJSON(
  object: any,
): BlockchainNode_EthereumDetails_ConsensusClient {
  switch (object) {
    case 0:
    case "CONSENSUS_CLIENT_UNSPECIFIED":
      return BlockchainNode_EthereumDetails_ConsensusClient.CONSENSUS_CLIENT_UNSPECIFIED;
    case 1:
    case "LIGHTHOUSE":
      return BlockchainNode_EthereumDetails_ConsensusClient.LIGHTHOUSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_EthereumDetails_ConsensusClient.UNRECOGNIZED;
  }
}

export function blockchainNode_EthereumDetails_ConsensusClientToJSON(
  object: BlockchainNode_EthereumDetails_ConsensusClient,
): string {
  switch (object) {
    case BlockchainNode_EthereumDetails_ConsensusClient.CONSENSUS_CLIENT_UNSPECIFIED:
      return "CONSENSUS_CLIENT_UNSPECIFIED";
    case BlockchainNode_EthereumDetails_ConsensusClient.LIGHTHOUSE:
      return "LIGHTHOUSE";
    case BlockchainNode_EthereumDetails_ConsensusClient.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Options for the Geth execution client.
 *
 * See [Command-line
 * Options](https://geth.ethereum.org/docs/fundamentals/command-line-options)
 * for more details.
 */
export interface BlockchainNode_EthereumDetails_GethDetails {
  /** Immutable. Blockchain garbage collection mode. */
  garbageCollectionMode?: BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode | undefined;
}

/**
 * Blockchain garbage collection modes. Only applicable when `NodeType` is
 * `FULL` or `ARCHIVE`.
 */
export enum BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode {
  /** GARBAGE_COLLECTION_MODE_UNSPECIFIED - The garbage collection has not been specified. */
  GARBAGE_COLLECTION_MODE_UNSPECIFIED = 0,
  /**
   * FULL - Configures Geth's garbage collection so that older data not needed
   * for a full node is deleted. This is the default mode when creating a
   * full node.
   */
  FULL = 1,
  /**
   * ARCHIVE - Configures Geth's garbage collection so that old data is never
   * deleted. This is the default mode when creating an archive node. This
   * value can also be chosen when creating a full node in order to create
   * a partial/recent archive node. See
   * [Sync modes](https://geth.ethereum.org/docs/fundamentals/sync-modes)
   * for more details.
   */
  ARCHIVE = 2,
  UNRECOGNIZED = -1,
}

export function blockchainNode_EthereumDetails_GethDetails_GarbageCollectionModeFromJSON(
  object: any,
): BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode {
  switch (object) {
    case 0:
    case "GARBAGE_COLLECTION_MODE_UNSPECIFIED":
      return BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.GARBAGE_COLLECTION_MODE_UNSPECIFIED;
    case 1:
    case "FULL":
      return BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.FULL;
    case 2:
    case "ARCHIVE":
      return BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.ARCHIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.UNRECOGNIZED;
  }
}

export function blockchainNode_EthereumDetails_GethDetails_GarbageCollectionModeToJSON(
  object: BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode,
): string {
  switch (object) {
    case BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.GARBAGE_COLLECTION_MODE_UNSPECIFIED:
      return "GARBAGE_COLLECTION_MODE_UNSPECIFIED";
    case BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.FULL:
      return "FULL";
    case BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.ARCHIVE:
      return "ARCHIVE";
    case BlockchainNode_EthereumDetails_GethDetails_GarbageCollectionMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains endpoint information specific to Ethereum nodes. */
export interface BlockchainNode_EthereumDetails_EthereumEndpoints {
  /** Output only. The assigned URL for the node's Beacon API endpoint. */
  beaconApiEndpoint: string;
  /**
   * Output only. The assigned URL for the node's Beacon Prometheus metrics
   * endpoint. See [Prometheus
   * Metrics](https://lighthouse-book.sigmaprime.io/advanced_metrics.html)
   * for more details.
   */
  beaconPrometheusMetricsApiEndpoint: string;
  /**
   * Output only. The assigned URL for the node's execution client's
   * Prometheus metrics endpoint.
   */
  executionClientPrometheusMetricsApiEndpoint: string;
}

/**
 * Configuration for validator-related parameters on the beacon client,
 * and for any GCP-managed validator client.
 */
export interface BlockchainNode_EthereumDetails_ValidatorConfig {
  /**
   * URLs for MEV-relay services to use for block building. When set, a
   * GCP-managed MEV-boost service is configured on the beacon client.
   */
  mevRelayUrls: string[];
  /**
   * Immutable. When true, deploys a GCP-managed validator client alongside
   * the beacon client.
   */
  managedValidatorClient: boolean;
  /**
   * An Ethereum address which the beacon client will send fee rewards to if
   * no recipient is configured in the validator client.
   *
   * See https://lighthouse-book.sigmaprime.io/suggested-fee-recipient.html
   * or https://docs.prylabs.network/docs/execution-node/fee-recipient for
   * examples of how this is used.
   *
   * Note that while this is often described as "suggested", as we run the
   * execution node we can trust the execution node, and therefore this is
   * considered enforced.
   */
  beaconFeeRecipient?: string | undefined;
}

export interface BlockchainNode_LabelsEntry {
  key: string;
  value: string;
}

/** Message for requesting list of blockchain nodes. */
export interface ListBlockchainNodesRequest {
  /** Required. Parent value for `ListNodesRequest`. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing blockchain nodes. */
export interface ListBlockchainNodesResponse {
  /** The list of nodes */
  blockchainNodes: BlockchainNode[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a blockchain node. */
export interface GetBlockchainNodeRequest {
  /**
   * Required. The fully qualified name of the blockchain node to fetch.
   * e.g. `projects/my-project/locations/us-central1/blockchainNodes/my-node`.
   */
  name: string;
}

/** Message for creating a blockchain node. */
export interface CreateBlockchainNodeRequest {
  /** Required. Value for parent. */
  parent: string;
  /** Required. ID of the requesting object. */
  blockchainNodeId: string;
  /** Required. The resource being created. */
  blockchainNode:
    | BlockchainNode
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating a blockchain node. */
export interface UpdateBlockchainNodeRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Blockchain node resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated. */
  blockchainNode:
    | BlockchainNode
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a blockchain node. */
export interface DeleteBlockchainNodeRequest {
  /**
   * Required. The fully qualified name of the blockchain node to delete.
   * e.g. `projects/my-project/locations/us-central1/blockchainNodes/my-node`.
   */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have `[Operation.error][]` value with a
   * `[google.rpc.Status.code][google.rpc.Status.code]` of `1`, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

function createBaseBlockchainNode(): BlockchainNode {
  return {
    ethereumDetails: undefined,
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    blockchainType: undefined,
    connectionInfo: undefined,
    state: 0,
    privateServiceConnectEnabled: false,
  };
}

export const BlockchainNode: MessageFns<BlockchainNode> = {
  encode(message: BlockchainNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ethereumDetails !== undefined) {
      BlockchainNode_EthereumDetails.encode(message.ethereumDetails, writer.uint32(58).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      BlockchainNode_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.blockchainType !== undefined) {
      writer.uint32(40).int32(message.blockchainType);
    }
    if (message.connectionInfo !== undefined) {
      BlockchainNode_ConnectionInfo.encode(message.connectionInfo, writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.privateServiceConnectEnabled !== false) {
      writer.uint32(96).bool(message.privateServiceConnectEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ethereumDetails = BlockchainNode_EthereumDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BlockchainNode_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.blockchainType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.connectionInfo = BlockchainNode_ConnectionInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.privateServiceConnectEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode {
    return {
      ethereumDetails: isSet(object.ethereumDetails)
        ? BlockchainNode_EthereumDetails.fromJSON(object.ethereumDetails)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      blockchainType: isSet(object.blockchainType)
        ? blockchainNode_BlockchainTypeFromJSON(object.blockchainType)
        : undefined,
      connectionInfo: isSet(object.connectionInfo)
        ? BlockchainNode_ConnectionInfo.fromJSON(object.connectionInfo)
        : undefined,
      state: isSet(object.state) ? blockchainNode_StateFromJSON(object.state) : 0,
      privateServiceConnectEnabled: isSet(object.privateServiceConnectEnabled)
        ? globalThis.Boolean(object.privateServiceConnectEnabled)
        : false,
    };
  },

  toJSON(message: BlockchainNode): unknown {
    const obj: any = {};
    if (message.ethereumDetails !== undefined) {
      obj.ethereumDetails = BlockchainNode_EthereumDetails.toJSON(message.ethereumDetails);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.blockchainType !== undefined) {
      obj.blockchainType = blockchainNode_BlockchainTypeToJSON(message.blockchainType);
    }
    if (message.connectionInfo !== undefined) {
      obj.connectionInfo = BlockchainNode_ConnectionInfo.toJSON(message.connectionInfo);
    }
    if (message.state !== 0) {
      obj.state = blockchainNode_StateToJSON(message.state);
    }
    if (message.privateServiceConnectEnabled !== false) {
      obj.privateServiceConnectEnabled = message.privateServiceConnectEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode>): BlockchainNode {
    return BlockchainNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainNode>): BlockchainNode {
    const message = createBaseBlockchainNode();
    message.ethereumDetails = (object.ethereumDetails !== undefined && object.ethereumDetails !== null)
      ? BlockchainNode_EthereumDetails.fromPartial(object.ethereumDetails)
      : undefined;
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.blockchainType = object.blockchainType ?? undefined;
    message.connectionInfo = (object.connectionInfo !== undefined && object.connectionInfo !== null)
      ? BlockchainNode_ConnectionInfo.fromPartial(object.connectionInfo)
      : undefined;
    message.state = object.state ?? 0;
    message.privateServiceConnectEnabled = object.privateServiceConnectEnabled ?? false;
    return message;
  },
};

function createBaseBlockchainNode_ConnectionInfo(): BlockchainNode_ConnectionInfo {
  return { endpointInfo: undefined, serviceAttachment: "" };
}

export const BlockchainNode_ConnectionInfo: MessageFns<BlockchainNode_ConnectionInfo> = {
  encode(message: BlockchainNode_ConnectionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpointInfo !== undefined) {
      BlockchainNode_ConnectionInfo_EndpointInfo.encode(message.endpointInfo, writer.uint32(18).fork()).join();
    }
    if (message.serviceAttachment !== "") {
      writer.uint32(26).string(message.serviceAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_ConnectionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_ConnectionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endpointInfo = BlockchainNode_ConnectionInfo_EndpointInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_ConnectionInfo {
    return {
      endpointInfo: isSet(object.endpointInfo)
        ? BlockchainNode_ConnectionInfo_EndpointInfo.fromJSON(object.endpointInfo)
        : undefined,
      serviceAttachment: isSet(object.serviceAttachment) ? globalThis.String(object.serviceAttachment) : "",
    };
  },

  toJSON(message: BlockchainNode_ConnectionInfo): unknown {
    const obj: any = {};
    if (message.endpointInfo !== undefined) {
      obj.endpointInfo = BlockchainNode_ConnectionInfo_EndpointInfo.toJSON(message.endpointInfo);
    }
    if (message.serviceAttachment !== "") {
      obj.serviceAttachment = message.serviceAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode_ConnectionInfo>): BlockchainNode_ConnectionInfo {
    return BlockchainNode_ConnectionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainNode_ConnectionInfo>): BlockchainNode_ConnectionInfo {
    const message = createBaseBlockchainNode_ConnectionInfo();
    message.endpointInfo = (object.endpointInfo !== undefined && object.endpointInfo !== null)
      ? BlockchainNode_ConnectionInfo_EndpointInfo.fromPartial(object.endpointInfo)
      : undefined;
    message.serviceAttachment = object.serviceAttachment ?? "";
    return message;
  },
};

function createBaseBlockchainNode_ConnectionInfo_EndpointInfo(): BlockchainNode_ConnectionInfo_EndpointInfo {
  return { jsonRpcApiEndpoint: "", websocketsApiEndpoint: "" };
}

export const BlockchainNode_ConnectionInfo_EndpointInfo: MessageFns<BlockchainNode_ConnectionInfo_EndpointInfo> = {
  encode(message: BlockchainNode_ConnectionInfo_EndpointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonRpcApiEndpoint !== "") {
      writer.uint32(10).string(message.jsonRpcApiEndpoint);
    }
    if (message.websocketsApiEndpoint !== "") {
      writer.uint32(18).string(message.websocketsApiEndpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_ConnectionInfo_EndpointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_ConnectionInfo_EndpointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jsonRpcApiEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.websocketsApiEndpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_ConnectionInfo_EndpointInfo {
    return {
      jsonRpcApiEndpoint: isSet(object.jsonRpcApiEndpoint) ? globalThis.String(object.jsonRpcApiEndpoint) : "",
      websocketsApiEndpoint: isSet(object.websocketsApiEndpoint) ? globalThis.String(object.websocketsApiEndpoint) : "",
    };
  },

  toJSON(message: BlockchainNode_ConnectionInfo_EndpointInfo): unknown {
    const obj: any = {};
    if (message.jsonRpcApiEndpoint !== "") {
      obj.jsonRpcApiEndpoint = message.jsonRpcApiEndpoint;
    }
    if (message.websocketsApiEndpoint !== "") {
      obj.websocketsApiEndpoint = message.websocketsApiEndpoint;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode_ConnectionInfo_EndpointInfo>): BlockchainNode_ConnectionInfo_EndpointInfo {
    return BlockchainNode_ConnectionInfo_EndpointInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockchainNode_ConnectionInfo_EndpointInfo>,
  ): BlockchainNode_ConnectionInfo_EndpointInfo {
    const message = createBaseBlockchainNode_ConnectionInfo_EndpointInfo();
    message.jsonRpcApiEndpoint = object.jsonRpcApiEndpoint ?? "";
    message.websocketsApiEndpoint = object.websocketsApiEndpoint ?? "";
    return message;
  },
};

function createBaseBlockchainNode_EthereumDetails(): BlockchainNode_EthereumDetails {
  return {
    gethDetails: undefined,
    network: undefined,
    nodeType: undefined,
    executionClient: undefined,
    consensusClient: undefined,
    apiEnableAdmin: undefined,
    apiEnableDebug: undefined,
    additionalEndpoints: undefined,
    validatorConfig: undefined,
  };
}

export const BlockchainNode_EthereumDetails: MessageFns<BlockchainNode_EthereumDetails> = {
  encode(message: BlockchainNode_EthereumDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gethDetails !== undefined) {
      BlockchainNode_EthereumDetails_GethDetails.encode(message.gethDetails, writer.uint32(66).fork()).join();
    }
    if (message.network !== undefined) {
      writer.uint32(8).int32(message.network);
    }
    if (message.nodeType !== undefined) {
      writer.uint32(16).int32(message.nodeType);
    }
    if (message.executionClient !== undefined) {
      writer.uint32(24).int32(message.executionClient);
    }
    if (message.consensusClient !== undefined) {
      writer.uint32(32).int32(message.consensusClient);
    }
    if (message.apiEnableAdmin !== undefined) {
      writer.uint32(40).bool(message.apiEnableAdmin);
    }
    if (message.apiEnableDebug !== undefined) {
      writer.uint32(48).bool(message.apiEnableDebug);
    }
    if (message.additionalEndpoints !== undefined) {
      BlockchainNode_EthereumDetails_EthereumEndpoints.encode(message.additionalEndpoints, writer.uint32(58).fork())
        .join();
    }
    if (message.validatorConfig !== undefined) {
      BlockchainNode_EthereumDetails_ValidatorConfig.encode(message.validatorConfig, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_EthereumDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_EthereumDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gethDetails = BlockchainNode_EthereumDetails_GethDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.executionClient = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.consensusClient = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.apiEnableAdmin = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.apiEnableDebug = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.additionalEndpoints = BlockchainNode_EthereumDetails_EthereumEndpoints.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.validatorConfig = BlockchainNode_EthereumDetails_ValidatorConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_EthereumDetails {
    return {
      gethDetails: isSet(object.gethDetails)
        ? BlockchainNode_EthereumDetails_GethDetails.fromJSON(object.gethDetails)
        : undefined,
      network: isSet(object.network) ? blockchainNode_EthereumDetails_NetworkFromJSON(object.network) : undefined,
      nodeType: isSet(object.nodeType) ? blockchainNode_EthereumDetails_NodeTypeFromJSON(object.nodeType) : undefined,
      executionClient: isSet(object.executionClient)
        ? blockchainNode_EthereumDetails_ExecutionClientFromJSON(object.executionClient)
        : undefined,
      consensusClient: isSet(object.consensusClient)
        ? blockchainNode_EthereumDetails_ConsensusClientFromJSON(object.consensusClient)
        : undefined,
      apiEnableAdmin: isSet(object.apiEnableAdmin) ? globalThis.Boolean(object.apiEnableAdmin) : undefined,
      apiEnableDebug: isSet(object.apiEnableDebug) ? globalThis.Boolean(object.apiEnableDebug) : undefined,
      additionalEndpoints: isSet(object.additionalEndpoints)
        ? BlockchainNode_EthereumDetails_EthereumEndpoints.fromJSON(object.additionalEndpoints)
        : undefined,
      validatorConfig: isSet(object.validatorConfig)
        ? BlockchainNode_EthereumDetails_ValidatorConfig.fromJSON(object.validatorConfig)
        : undefined,
    };
  },

  toJSON(message: BlockchainNode_EthereumDetails): unknown {
    const obj: any = {};
    if (message.gethDetails !== undefined) {
      obj.gethDetails = BlockchainNode_EthereumDetails_GethDetails.toJSON(message.gethDetails);
    }
    if (message.network !== undefined) {
      obj.network = blockchainNode_EthereumDetails_NetworkToJSON(message.network);
    }
    if (message.nodeType !== undefined) {
      obj.nodeType = blockchainNode_EthereumDetails_NodeTypeToJSON(message.nodeType);
    }
    if (message.executionClient !== undefined) {
      obj.executionClient = blockchainNode_EthereumDetails_ExecutionClientToJSON(message.executionClient);
    }
    if (message.consensusClient !== undefined) {
      obj.consensusClient = blockchainNode_EthereumDetails_ConsensusClientToJSON(message.consensusClient);
    }
    if (message.apiEnableAdmin !== undefined) {
      obj.apiEnableAdmin = message.apiEnableAdmin;
    }
    if (message.apiEnableDebug !== undefined) {
      obj.apiEnableDebug = message.apiEnableDebug;
    }
    if (message.additionalEndpoints !== undefined) {
      obj.additionalEndpoints = BlockchainNode_EthereumDetails_EthereumEndpoints.toJSON(message.additionalEndpoints);
    }
    if (message.validatorConfig !== undefined) {
      obj.validatorConfig = BlockchainNode_EthereumDetails_ValidatorConfig.toJSON(message.validatorConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode_EthereumDetails>): BlockchainNode_EthereumDetails {
    return BlockchainNode_EthereumDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainNode_EthereumDetails>): BlockchainNode_EthereumDetails {
    const message = createBaseBlockchainNode_EthereumDetails();
    message.gethDetails = (object.gethDetails !== undefined && object.gethDetails !== null)
      ? BlockchainNode_EthereumDetails_GethDetails.fromPartial(object.gethDetails)
      : undefined;
    message.network = object.network ?? undefined;
    message.nodeType = object.nodeType ?? undefined;
    message.executionClient = object.executionClient ?? undefined;
    message.consensusClient = object.consensusClient ?? undefined;
    message.apiEnableAdmin = object.apiEnableAdmin ?? undefined;
    message.apiEnableDebug = object.apiEnableDebug ?? undefined;
    message.additionalEndpoints = (object.additionalEndpoints !== undefined && object.additionalEndpoints !== null)
      ? BlockchainNode_EthereumDetails_EthereumEndpoints.fromPartial(object.additionalEndpoints)
      : undefined;
    message.validatorConfig = (object.validatorConfig !== undefined && object.validatorConfig !== null)
      ? BlockchainNode_EthereumDetails_ValidatorConfig.fromPartial(object.validatorConfig)
      : undefined;
    return message;
  },
};

function createBaseBlockchainNode_EthereumDetails_GethDetails(): BlockchainNode_EthereumDetails_GethDetails {
  return { garbageCollectionMode: undefined };
}

export const BlockchainNode_EthereumDetails_GethDetails: MessageFns<BlockchainNode_EthereumDetails_GethDetails> = {
  encode(message: BlockchainNode_EthereumDetails_GethDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.garbageCollectionMode !== undefined) {
      writer.uint32(8).int32(message.garbageCollectionMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_EthereumDetails_GethDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_EthereumDetails_GethDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.garbageCollectionMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_EthereumDetails_GethDetails {
    return {
      garbageCollectionMode: isSet(object.garbageCollectionMode)
        ? blockchainNode_EthereumDetails_GethDetails_GarbageCollectionModeFromJSON(object.garbageCollectionMode)
        : undefined,
    };
  },

  toJSON(message: BlockchainNode_EthereumDetails_GethDetails): unknown {
    const obj: any = {};
    if (message.garbageCollectionMode !== undefined) {
      obj.garbageCollectionMode = blockchainNode_EthereumDetails_GethDetails_GarbageCollectionModeToJSON(
        message.garbageCollectionMode,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode_EthereumDetails_GethDetails>): BlockchainNode_EthereumDetails_GethDetails {
    return BlockchainNode_EthereumDetails_GethDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockchainNode_EthereumDetails_GethDetails>,
  ): BlockchainNode_EthereumDetails_GethDetails {
    const message = createBaseBlockchainNode_EthereumDetails_GethDetails();
    message.garbageCollectionMode = object.garbageCollectionMode ?? undefined;
    return message;
  },
};

function createBaseBlockchainNode_EthereumDetails_EthereumEndpoints(): BlockchainNode_EthereumDetails_EthereumEndpoints {
  return {
    beaconApiEndpoint: "",
    beaconPrometheusMetricsApiEndpoint: "",
    executionClientPrometheusMetricsApiEndpoint: "",
  };
}

export const BlockchainNode_EthereumDetails_EthereumEndpoints: MessageFns<
  BlockchainNode_EthereumDetails_EthereumEndpoints
> = {
  encode(
    message: BlockchainNode_EthereumDetails_EthereumEndpoints,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.beaconApiEndpoint !== "") {
      writer.uint32(10).string(message.beaconApiEndpoint);
    }
    if (message.beaconPrometheusMetricsApiEndpoint !== "") {
      writer.uint32(18).string(message.beaconPrometheusMetricsApiEndpoint);
    }
    if (message.executionClientPrometheusMetricsApiEndpoint !== "") {
      writer.uint32(26).string(message.executionClientPrometheusMetricsApiEndpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_EthereumDetails_EthereumEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_EthereumDetails_EthereumEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.beaconApiEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.beaconPrometheusMetricsApiEndpoint = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionClientPrometheusMetricsApiEndpoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_EthereumDetails_EthereumEndpoints {
    return {
      beaconApiEndpoint: isSet(object.beaconApiEndpoint) ? globalThis.String(object.beaconApiEndpoint) : "",
      beaconPrometheusMetricsApiEndpoint: isSet(object.beaconPrometheusMetricsApiEndpoint)
        ? globalThis.String(object.beaconPrometheusMetricsApiEndpoint)
        : "",
      executionClientPrometheusMetricsApiEndpoint: isSet(object.executionClientPrometheusMetricsApiEndpoint)
        ? globalThis.String(object.executionClientPrometheusMetricsApiEndpoint)
        : "",
    };
  },

  toJSON(message: BlockchainNode_EthereumDetails_EthereumEndpoints): unknown {
    const obj: any = {};
    if (message.beaconApiEndpoint !== "") {
      obj.beaconApiEndpoint = message.beaconApiEndpoint;
    }
    if (message.beaconPrometheusMetricsApiEndpoint !== "") {
      obj.beaconPrometheusMetricsApiEndpoint = message.beaconPrometheusMetricsApiEndpoint;
    }
    if (message.executionClientPrometheusMetricsApiEndpoint !== "") {
      obj.executionClientPrometheusMetricsApiEndpoint = message.executionClientPrometheusMetricsApiEndpoint;
    }
    return obj;
  },

  create(
    base?: DeepPartial<BlockchainNode_EthereumDetails_EthereumEndpoints>,
  ): BlockchainNode_EthereumDetails_EthereumEndpoints {
    return BlockchainNode_EthereumDetails_EthereumEndpoints.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockchainNode_EthereumDetails_EthereumEndpoints>,
  ): BlockchainNode_EthereumDetails_EthereumEndpoints {
    const message = createBaseBlockchainNode_EthereumDetails_EthereumEndpoints();
    message.beaconApiEndpoint = object.beaconApiEndpoint ?? "";
    message.beaconPrometheusMetricsApiEndpoint = object.beaconPrometheusMetricsApiEndpoint ?? "";
    message.executionClientPrometheusMetricsApiEndpoint = object.executionClientPrometheusMetricsApiEndpoint ?? "";
    return message;
  },
};

function createBaseBlockchainNode_EthereumDetails_ValidatorConfig(): BlockchainNode_EthereumDetails_ValidatorConfig {
  return { mevRelayUrls: [], managedValidatorClient: false, beaconFeeRecipient: undefined };
}

export const BlockchainNode_EthereumDetails_ValidatorConfig: MessageFns<
  BlockchainNode_EthereumDetails_ValidatorConfig
> = {
  encode(
    message: BlockchainNode_EthereumDetails_ValidatorConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.mevRelayUrls) {
      writer.uint32(10).string(v!);
    }
    if (message.managedValidatorClient !== false) {
      writer.uint32(16).bool(message.managedValidatorClient);
    }
    if (message.beaconFeeRecipient !== undefined) {
      writer.uint32(26).string(message.beaconFeeRecipient);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_EthereumDetails_ValidatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_EthereumDetails_ValidatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mevRelayUrls.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.managedValidatorClient = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beaconFeeRecipient = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_EthereumDetails_ValidatorConfig {
    return {
      mevRelayUrls: globalThis.Array.isArray(object?.mevRelayUrls)
        ? object.mevRelayUrls.map((e: any) => globalThis.String(e))
        : [],
      managedValidatorClient: isSet(object.managedValidatorClient)
        ? globalThis.Boolean(object.managedValidatorClient)
        : false,
      beaconFeeRecipient: isSet(object.beaconFeeRecipient) ? globalThis.String(object.beaconFeeRecipient) : undefined,
    };
  },

  toJSON(message: BlockchainNode_EthereumDetails_ValidatorConfig): unknown {
    const obj: any = {};
    if (message.mevRelayUrls?.length) {
      obj.mevRelayUrls = message.mevRelayUrls;
    }
    if (message.managedValidatorClient !== false) {
      obj.managedValidatorClient = message.managedValidatorClient;
    }
    if (message.beaconFeeRecipient !== undefined) {
      obj.beaconFeeRecipient = message.beaconFeeRecipient;
    }
    return obj;
  },

  create(
    base?: DeepPartial<BlockchainNode_EthereumDetails_ValidatorConfig>,
  ): BlockchainNode_EthereumDetails_ValidatorConfig {
    return BlockchainNode_EthereumDetails_ValidatorConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BlockchainNode_EthereumDetails_ValidatorConfig>,
  ): BlockchainNode_EthereumDetails_ValidatorConfig {
    const message = createBaseBlockchainNode_EthereumDetails_ValidatorConfig();
    message.mevRelayUrls = object.mevRelayUrls?.map((e) => e) || [];
    message.managedValidatorClient = object.managedValidatorClient ?? false;
    message.beaconFeeRecipient = object.beaconFeeRecipient ?? undefined;
    return message;
  },
};

function createBaseBlockchainNode_LabelsEntry(): BlockchainNode_LabelsEntry {
  return { key: "", value: "" };
}

export const BlockchainNode_LabelsEntry: MessageFns<BlockchainNode_LabelsEntry> = {
  encode(message: BlockchainNode_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainNode_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainNode_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainNode_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BlockchainNode_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainNode_LabelsEntry>): BlockchainNode_LabelsEntry {
    return BlockchainNode_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainNode_LabelsEntry>): BlockchainNode_LabelsEntry {
    const message = createBaseBlockchainNode_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListBlockchainNodesRequest(): ListBlockchainNodesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListBlockchainNodesRequest: MessageFns<ListBlockchainNodesRequest> = {
  encode(message: ListBlockchainNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlockchainNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockchainNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlockchainNodesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListBlockchainNodesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlockchainNodesRequest>): ListBlockchainNodesRequest {
    return ListBlockchainNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlockchainNodesRequest>): ListBlockchainNodesRequest {
    const message = createBaseListBlockchainNodesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListBlockchainNodesResponse(): ListBlockchainNodesResponse {
  return { blockchainNodes: [], nextPageToken: "", unreachable: [] };
}

export const ListBlockchainNodesResponse: MessageFns<ListBlockchainNodesResponse> = {
  encode(message: ListBlockchainNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blockchainNodes) {
      BlockchainNode.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlockchainNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlockchainNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchainNodes.push(BlockchainNode.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlockchainNodesResponse {
    return {
      blockchainNodes: globalThis.Array.isArray(object?.blockchainNodes)
        ? object.blockchainNodes.map((e: any) => BlockchainNode.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBlockchainNodesResponse): unknown {
    const obj: any = {};
    if (message.blockchainNodes?.length) {
      obj.blockchainNodes = message.blockchainNodes.map((e) => BlockchainNode.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlockchainNodesResponse>): ListBlockchainNodesResponse {
    return ListBlockchainNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlockchainNodesResponse>): ListBlockchainNodesResponse {
    const message = createBaseListBlockchainNodesResponse();
    message.blockchainNodes = object.blockchainNodes?.map((e) => BlockchainNode.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBlockchainNodeRequest(): GetBlockchainNodeRequest {
  return { name: "" };
}

export const GetBlockchainNodeRequest: MessageFns<GetBlockchainNodeRequest> = {
  encode(message: GetBlockchainNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlockchainNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlockchainNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlockchainNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBlockchainNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlockchainNodeRequest>): GetBlockchainNodeRequest {
    return GetBlockchainNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlockchainNodeRequest>): GetBlockchainNodeRequest {
    const message = createBaseGetBlockchainNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateBlockchainNodeRequest(): CreateBlockchainNodeRequest {
  return { parent: "", blockchainNodeId: "", blockchainNode: undefined, requestId: "" };
}

export const CreateBlockchainNodeRequest: MessageFns<CreateBlockchainNodeRequest> = {
  encode(message: CreateBlockchainNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.blockchainNodeId !== "") {
      writer.uint32(18).string(message.blockchainNodeId);
    }
    if (message.blockchainNode !== undefined) {
      BlockchainNode.encode(message.blockchainNode, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBlockchainNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBlockchainNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchainNodeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchainNode = BlockchainNode.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBlockchainNodeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      blockchainNodeId: isSet(object.blockchainNodeId) ? globalThis.String(object.blockchainNodeId) : "",
      blockchainNode: isSet(object.blockchainNode) ? BlockchainNode.fromJSON(object.blockchainNode) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateBlockchainNodeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.blockchainNodeId !== "") {
      obj.blockchainNodeId = message.blockchainNodeId;
    }
    if (message.blockchainNode !== undefined) {
      obj.blockchainNode = BlockchainNode.toJSON(message.blockchainNode);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBlockchainNodeRequest>): CreateBlockchainNodeRequest {
    return CreateBlockchainNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBlockchainNodeRequest>): CreateBlockchainNodeRequest {
    const message = createBaseCreateBlockchainNodeRequest();
    message.parent = object.parent ?? "";
    message.blockchainNodeId = object.blockchainNodeId ?? "";
    message.blockchainNode = (object.blockchainNode !== undefined && object.blockchainNode !== null)
      ? BlockchainNode.fromPartial(object.blockchainNode)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateBlockchainNodeRequest(): UpdateBlockchainNodeRequest {
  return { updateMask: undefined, blockchainNode: undefined, requestId: "" };
}

export const UpdateBlockchainNodeRequest: MessageFns<UpdateBlockchainNodeRequest> = {
  encode(message: UpdateBlockchainNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.blockchainNode !== undefined) {
      BlockchainNode.encode(message.blockchainNode, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBlockchainNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBlockchainNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchainNode = BlockchainNode.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBlockchainNodeRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      blockchainNode: isSet(object.blockchainNode) ? BlockchainNode.fromJSON(object.blockchainNode) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateBlockchainNodeRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.blockchainNode !== undefined) {
      obj.blockchainNode = BlockchainNode.toJSON(message.blockchainNode);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBlockchainNodeRequest>): UpdateBlockchainNodeRequest {
    return UpdateBlockchainNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBlockchainNodeRequest>): UpdateBlockchainNodeRequest {
    const message = createBaseUpdateBlockchainNodeRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.blockchainNode = (object.blockchainNode !== undefined && object.blockchainNode !== null)
      ? BlockchainNode.fromPartial(object.blockchainNode)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteBlockchainNodeRequest(): DeleteBlockchainNodeRequest {
  return { name: "", requestId: "" };
}

export const DeleteBlockchainNodeRequest: MessageFns<DeleteBlockchainNodeRequest> = {
  encode(message: DeleteBlockchainNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBlockchainNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBlockchainNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBlockchainNodeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteBlockchainNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBlockchainNodeRequest>): DeleteBlockchainNodeRequest {
    return DeleteBlockchainNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBlockchainNodeRequest>): DeleteBlockchainNodeRequest {
    const message = createBaseDeleteBlockchainNodeRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

/**
 * This service is the control plane API for Blockchain Node Engine,
 * and can be used to create, read, and delete blockchain nodes.
 */
export type BlockchainNodeEngineDefinition = typeof BlockchainNodeEngineDefinition;
export const BlockchainNodeEngineDefinition = {
  name: "BlockchainNodeEngine",
  fullName: "google.cloud.blockchainnodeengine.v1.BlockchainNodeEngine",
  methods: {
    /** Lists blockchain nodes in a given project and location. */
    listBlockchainNodes: {
      name: "ListBlockchainNodes",
      requestType: ListBlockchainNodesRequest,
      requestStream: false,
      responseType: ListBlockchainNodesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single blockchain node. */
    getBlockchainNode: {
      name: "GetBlockchainNode",
      requestType: GetBlockchainNodeRequest,
      requestStream: false,
      responseType: BlockchainNode,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new blockchain node in a given project and location. */
    createBlockchainNode: {
      name: "CreateBlockchainNode",
      requestType: CreateBlockchainNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              66,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              44,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              15,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single blockchain node. */
    updateBlockchainNode: {
      name: "UpdateBlockchainNode",
      requestType: UpdateBlockchainNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              66,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              15,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              50,
              67,
              47,
              118,
              49,
              47,
              123,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              95,
              110,
              111,
              100,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single blockchain node. */
    deleteBlockchainNode: {
      name: "DeleteBlockchainNode",
      requestType: DeleteBlockchainNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              108,
              111,
              99,
              107,
              99,
              104,
              97,
              105,
              110,
              78,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface BlockchainNodeEngineServiceImplementation<CallContextExt = {}> {
  /** Lists blockchain nodes in a given project and location. */
  listBlockchainNodes(
    request: ListBlockchainNodesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBlockchainNodesResponse>>;
  /** Gets details of a single blockchain node. */
  getBlockchainNode(
    request: GetBlockchainNodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BlockchainNode>>;
  /** Creates a new blockchain node in a given project and location. */
  createBlockchainNode(
    request: CreateBlockchainNodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single blockchain node. */
  updateBlockchainNode(
    request: UpdateBlockchainNodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single blockchain node. */
  deleteBlockchainNode(
    request: DeleteBlockchainNodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface BlockchainNodeEngineClient<CallOptionsExt = {}> {
  /** Lists blockchain nodes in a given project and location. */
  listBlockchainNodes(
    request: DeepPartial<ListBlockchainNodesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBlockchainNodesResponse>;
  /** Gets details of a single blockchain node. */
  getBlockchainNode(
    request: DeepPartial<GetBlockchainNodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BlockchainNode>;
  /** Creates a new blockchain node in a given project and location. */
  createBlockchainNode(
    request: DeepPartial<CreateBlockchainNodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the parameters of a single blockchain node. */
  updateBlockchainNode(
    request: DeepPartial<UpdateBlockchainNodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single blockchain node. */
  deleteBlockchainNode(
    request: DeepPartial<DeleteBlockchainNodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
