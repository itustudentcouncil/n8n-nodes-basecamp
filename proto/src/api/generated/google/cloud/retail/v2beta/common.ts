// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2beta/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.retail.v2beta";

/** At which level we offer configuration for attributes. */
export enum AttributeConfigLevel {
  /**
   * ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED - Value used when unset. In this case, server behavior defaults to
   * [CATALOG_LEVEL_ATTRIBUTE_CONFIG][google.cloud.retail.v2beta.AttributeConfigLevel.CATALOG_LEVEL_ATTRIBUTE_CONFIG].
   */
  ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED = 0,
  /**
   * PRODUCT_LEVEL_ATTRIBUTE_CONFIG - At this level, we honor the attribute configurations set in
   * [Product.attributes][google.cloud.retail.v2beta.Product.attributes].
   */
  PRODUCT_LEVEL_ATTRIBUTE_CONFIG = 1,
  /**
   * CATALOG_LEVEL_ATTRIBUTE_CONFIG - At this level, we honor the attribute configurations set in
   * [CatalogConfig.attribute_configs][].
   */
  CATALOG_LEVEL_ATTRIBUTE_CONFIG = 2,
  UNRECOGNIZED = -1,
}

export function attributeConfigLevelFromJSON(object: any): AttributeConfigLevel {
  switch (object) {
    case 0:
    case "ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED":
      return AttributeConfigLevel.ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED;
    case 1:
    case "PRODUCT_LEVEL_ATTRIBUTE_CONFIG":
      return AttributeConfigLevel.PRODUCT_LEVEL_ATTRIBUTE_CONFIG;
    case 2:
    case "CATALOG_LEVEL_ATTRIBUTE_CONFIG":
      return AttributeConfigLevel.CATALOG_LEVEL_ATTRIBUTE_CONFIG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttributeConfigLevel.UNRECOGNIZED;
  }
}

export function attributeConfigLevelToJSON(object: AttributeConfigLevel): string {
  switch (object) {
    case AttributeConfigLevel.ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED:
      return "ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED";
    case AttributeConfigLevel.PRODUCT_LEVEL_ATTRIBUTE_CONFIG:
      return "PRODUCT_LEVEL_ATTRIBUTE_CONFIG";
    case AttributeConfigLevel.CATALOG_LEVEL_ATTRIBUTE_CONFIG:
      return "CATALOG_LEVEL_ATTRIBUTE_CONFIG";
    case AttributeConfigLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of solution. */
export enum SolutionType {
  /** SOLUTION_TYPE_UNSPECIFIED - Default value. */
  SOLUTION_TYPE_UNSPECIFIED = 0,
  /** SOLUTION_TYPE_RECOMMENDATION - Used for Recommendations AI. */
  SOLUTION_TYPE_RECOMMENDATION = 1,
  /** SOLUTION_TYPE_SEARCH - Used for Retail Search. */
  SOLUTION_TYPE_SEARCH = 2,
  UNRECOGNIZED = -1,
}

export function solutionTypeFromJSON(object: any): SolutionType {
  switch (object) {
    case 0:
    case "SOLUTION_TYPE_UNSPECIFIED":
      return SolutionType.SOLUTION_TYPE_UNSPECIFIED;
    case 1:
    case "SOLUTION_TYPE_RECOMMENDATION":
      return SolutionType.SOLUTION_TYPE_RECOMMENDATION;
    case 2:
    case "SOLUTION_TYPE_SEARCH":
      return SolutionType.SOLUTION_TYPE_SEARCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SolutionType.UNRECOGNIZED;
  }
}

export function solutionTypeToJSON(object: SolutionType): string {
  switch (object) {
    case SolutionType.SOLUTION_TYPE_UNSPECIFIED:
      return "SOLUTION_TYPE_UNSPECIFIED";
    case SolutionType.SOLUTION_TYPE_RECOMMENDATION:
      return "SOLUTION_TYPE_RECOMMENDATION";
    case SolutionType.SOLUTION_TYPE_SEARCH:
      return "SOLUTION_TYPE_SEARCH";
    case SolutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** If filtering for recommendations is enabled. */
export enum RecommendationsFilteringOption {
  /**
   * RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED - Value used when unset.
   * In this case, server behavior defaults to
   * [RECOMMENDATIONS_FILTERING_DISABLED][google.cloud.retail.v2beta.RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_DISABLED].
   */
  RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED = 0,
  /** RECOMMENDATIONS_FILTERING_DISABLED - Recommendation filtering is disabled. */
  RECOMMENDATIONS_FILTERING_DISABLED = 1,
  /** RECOMMENDATIONS_FILTERING_ENABLED - Recommendation filtering is enabled. */
  RECOMMENDATIONS_FILTERING_ENABLED = 3,
  UNRECOGNIZED = -1,
}

export function recommendationsFilteringOptionFromJSON(object: any): RecommendationsFilteringOption {
  switch (object) {
    case 0:
    case "RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED":
      return RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED;
    case 1:
    case "RECOMMENDATIONS_FILTERING_DISABLED":
      return RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_DISABLED;
    case 3:
    case "RECOMMENDATIONS_FILTERING_ENABLED":
      return RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecommendationsFilteringOption.UNRECOGNIZED;
  }
}

export function recommendationsFilteringOptionToJSON(object: RecommendationsFilteringOption): string {
  switch (object) {
    case RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED:
      return "RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED";
    case RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_DISABLED:
      return "RECOMMENDATIONS_FILTERING_DISABLED";
    case RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_ENABLED:
      return "RECOMMENDATIONS_FILTERING_ENABLED";
    case RecommendationsFilteringOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The use case of Cloud Retail Search. */
export enum SearchSolutionUseCase {
  /**
   * SEARCH_SOLUTION_USE_CASE_UNSPECIFIED - The value when it's unspecified. In this case, server behavior defaults to
   * [SEARCH_SOLUTION_USE_CASE_SEARCH][google.cloud.retail.v2beta.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH].
   */
  SEARCH_SOLUTION_USE_CASE_UNSPECIFIED = 0,
  /**
   * SEARCH_SOLUTION_USE_CASE_SEARCH - Search use case. Expects the traffic has a non-empty
   * [query][google.cloud.retail.v2beta.SearchRequest.query].
   */
  SEARCH_SOLUTION_USE_CASE_SEARCH = 1,
  /**
   * SEARCH_SOLUTION_USE_CASE_BROWSE - Browse use case. Expects the traffic has an empty
   * [query][google.cloud.retail.v2beta.SearchRequest.query].
   */
  SEARCH_SOLUTION_USE_CASE_BROWSE = 2,
  UNRECOGNIZED = -1,
}

export function searchSolutionUseCaseFromJSON(object: any): SearchSolutionUseCase {
  switch (object) {
    case 0:
    case "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED":
      return SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_UNSPECIFIED;
    case 1:
    case "SEARCH_SOLUTION_USE_CASE_SEARCH":
      return SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH;
    case 2:
    case "SEARCH_SOLUTION_USE_CASE_BROWSE":
      return SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_BROWSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchSolutionUseCase.UNRECOGNIZED;
  }
}

export function searchSolutionUseCaseToJSON(object: SearchSolutionUseCase): string {
  switch (object) {
    case SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_UNSPECIFIED:
      return "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED";
    case SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH:
      return "SEARCH_SOLUTION_USE_CASE_SEARCH";
    case SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_BROWSE:
      return "SEARCH_SOLUTION_USE_CASE_BROWSE";
    case SearchSolutionUseCase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Metadata that is used to define a condition that triggers an action.
 * A valid condition must specify at least one of 'query_terms' or
 * 'products_filter'. If multiple fields are specified, the condition is met if
 * all the fields are satisfied e.g. if a set of query terms and product_filter
 * are set, then only items matching the product_filter for requests with a
 * query matching the query terms wil get boosted.
 */
export interface Condition {
  /**
   * A list (up to 10 entries) of terms to match the query on. If not
   * specified, match all queries.
   * If many query terms are specified, the condition
   * is matched if any of the terms is a match (i.e. using the OR operator).
   */
  queryTerms: Condition_QueryTerm[];
  /**
   * Range of time(s) specifying when Condition is active.
   * Condition true if any time range matches.
   */
  activeTimeRange: Condition_TimeRange[];
  /**
   * Used to support browse uses cases.
   * A list (up to 10 entries) of categories or departments.
   * The format should be the same as
   * [UserEvent.page_categories][google.cloud.retail.v2beta.UserEvent.page_categories];
   */
  pageCategories: string[];
}

/** Query terms that we want to match on. */
export interface Condition_QueryTerm {
  /**
   * The value of the term to match on.
   * Value cannot be empty.
   * Value can have at most 3 terms if specified as a partial match. Each
   * space separated string is considered as one term.
   * For example, "a b c" is 3 terms and allowed, but " a b c d" is 4 terms
   * and not allowed for a partial match.
   */
  value: string;
  /** Whether this is supposed to be a full or partial match. */
  fullMatch: boolean;
}

/**
 * Used for time-dependent conditions.
 * Example: Want to have rule applied for week long sale.
 */
export interface Condition_TimeRange {
  /** Start of time range. Range is inclusive. */
  startTime:
    | Date
    | undefined;
  /** End of time range. Range is inclusive. */
  endTime: Date | undefined;
}

/**
 * A rule is a condition-action pair
 *
 * * A condition defines when a rule is to be triggered.
 * * An action specifies what occurs on that trigger.
 * Currently rules only work for [controls][google.cloud.retail.v2beta.Control]
 * with
 * [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2beta.SolutionType.SOLUTION_TYPE_SEARCH].
 */
export interface Rule {
  /** A boost action. */
  boostAction?:
    | Rule_BoostAction
    | undefined;
  /** Redirects a shopper to a specific page. */
  redirectAction?:
    | Rule_RedirectAction
    | undefined;
  /**
   * Treats specific term as a synonym with a group of terms.
   * Group of terms will not be treated as synonyms with the specific term.
   */
  onewaySynonymsAction?:
    | Rule_OnewaySynonymsAction
    | undefined;
  /** Prevents term from being associated with other terms. */
  doNotAssociateAction?:
    | Rule_DoNotAssociateAction
    | undefined;
  /** Replaces specific terms in the query. */
  replacementAction?:
    | Rule_ReplacementAction
    | undefined;
  /** Ignores specific terms from query during search. */
  ignoreAction?:
    | Rule_IgnoreAction
    | undefined;
  /** Filters results. */
  filterAction?:
    | Rule_FilterAction
    | undefined;
  /** Treats a set of terms as synonyms of one another. */
  twowaySynonymsAction?:
    | Rule_TwowaySynonymsAction
    | undefined;
  /** Force returns an attribute as a facet in the request. */
  forceReturnFacetAction?:
    | Rule_ForceReturnFacetAction
    | undefined;
  /** Remove an attribute as a facet in the request (if present). */
  removeFacetAction?:
    | Rule_RemoveFacetAction
    | undefined;
  /**
   * Required. The condition that triggers the rule.
   * If the condition is empty, the rule will always apply.
   */
  condition: Condition | undefined;
}

/** A boost action to apply to results matching condition specified above. */
export interface Rule_BoostAction {
  /**
   * Strength of the condition boost, which must be in [-1, 1]. Negative
   * boost means demotion. Default is 0.0.
   *
   * Setting to 1.0 gives the item a big promotion. However, it does not
   * necessarily mean that the boosted item will be the top result at all
   * times, nor that other items will be excluded. Results could still be
   * shown even when none of them matches the condition. And results that
   * are significantly more relevant to the search query can still trump
   * your heavily favored but irrelevant items.
   *
   * Setting to -1.0 gives the item a big demotion. However, results that
   * are deeply relevant might still be shown. The item will have an
   * upstream battle to get a fairly high ranking, but it is not blocked out
   * completely.
   *
   * Setting to 0.0 means no boost applied. The boosting condition is
   * ignored.
   */
  boost: number;
  /**
   * The filter can have a max size of 5000 characters.
   * An expression which specifies which products to apply an action to.
   * The syntax and supported fields are the same as a filter expression. See
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter]
   * for detail syntax and limitations.
   *
   * Examples:
   *
   * * To boost products with product ID "product_1" or "product_2", and
   * color
   *   "Red" or "Blue":<br>
   *   *(id: ANY("product_1", "product_2"))<br>*
   *   *AND<br>*
   *   *(colorFamilies: ANY("Red", "Blue"))<br>*
   */
  productsFilter: string;
}

/**
 * Rule Condition:
 *     - No
 *     [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 *     provided is a global match.
 *     - 1 or more
 *     [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 *     provided are combined with OR operator.
 *
 * * Action Input: The request query and filter that are applied to the
 * retrieved products, in addition to any filters already provided with the
 * SearchRequest. The AND operator is used to combine the query's existing
 * filters with the filter rule(s). NOTE: May result in 0 results when
 * filters conflict.
 *
 * * Action Result: Filters the returned objects to be ONLY those that passed
 * the filter.
 */
export interface Rule_FilterAction {
  /**
   * A filter to apply on the matching condition results. Supported features:
   *
   * * [filter][google.cloud.retail.v2beta.Rule.FilterAction.filter] must be
   * set.
   * * Filter syntax is identical to
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter].
   * For more
   *   information, see [Filter](/retail/docs/filter-and-order#filter).
   * * To filter products with product ID "product_1" or "product_2", and
   * color
   *   "Red" or "Blue":<br>
   *   *(id: ANY("product_1", "product_2"))<br>*
   *   *AND<br>*
   *   *(colorFamilies: ANY("Red", "Blue"))<br>*
   */
  filter: string;
}

/**
 * Redirects a shopper to a specific page.
 *
 * * Rule Condition:
 *   Must specify
 *   [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms].
 * * Action Input: Request Query
 * * Action Result: Redirects shopper to provided uri.
 */
export interface Rule_RedirectAction {
  /** URL must have length equal or less than 2000 characters. */
  redirectUri: string;
}

/**
 * Creates a set of terms that will be treated as synonyms of each other.
 * Example: synonyms of "sneakers" and "shoes":
 *
 *  * "sneakers" will use a synonym of "shoes".
 *  * "shoes" will use a synonym of "sneakers".
 */
export interface Rule_TwowaySynonymsAction {
  /**
   * Defines a set of synonyms.
   * Can specify up to 100 synonyms.
   * Must specify at least 2 synonyms.
   */
  synonyms: string[];
}

/**
 * Maps a set of terms to a set of synonyms.
 * Set of synonyms will be treated as synonyms of each query term only.
 * `query_terms` will not be treated as synonyms of each other.
 * Example: "sneakers" will use a synonym of "shoes".
 * "shoes" will not use a synonym of "sneakers".
 */
export interface Rule_OnewaySynonymsAction {
  /**
   * Terms from the search query.
   * Will treat synonyms as their synonyms.
   * Not themselves synonyms of the synonyms.
   * Can specify up to 100 terms.
   */
  queryTerms: string[];
  /**
   * Defines a set of synonyms.
   * Cannot contain duplicates.
   * Can specify up to 100 synonyms.
   */
  synonyms: string[];
  /** Will be [deprecated = true] post migration; */
  onewayTerms: string[];
}

/**
 * Prevents `query_term` from being associated with specified terms during
 * search.
 * Example: Don't associate "gShoe" and "cheap".
 */
export interface Rule_DoNotAssociateAction {
  /**
   * Terms from the search query.
   * Will not consider do_not_associate_terms for search if in search query.
   * Can specify up to 100 terms.
   */
  queryTerms: string[];
  /**
   * Cannot contain duplicates or the query term.
   * Can specify up to 100 terms.
   */
  doNotAssociateTerms: string[];
  /** Will be [deprecated = true] post migration; */
  terms: string[];
}

/**
 * Replaces a term in the query. Multiple replacement candidates can be
 * specified. All `query_terms` will be replaced with the replacement term.
 * Example: Replace "gShoe" with "google shoe".
 */
export interface Rule_ReplacementAction {
  /**
   * Terms from the search query.
   * Will be replaced by replacement term.
   * Can specify up to 100 terms.
   */
  queryTerms: string[];
  /** Term that will be used for replacement. */
  replacementTerm: string;
  /** Will be [deprecated = true] post migration; */
  term: string;
}

/**
 * Prevents a term in the query from being used in search.
 * Example: Don't search for "shoddy".
 */
export interface Rule_IgnoreAction {
  /** Terms to ignore in the search query. */
  ignoreTerms: string[];
}

/**
 * Force returns an attribute/facet in the request around a certain position
 * or above.
 *
 * * Rule Condition:
 *   Must specify non-empty
 *   [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 *   (for search only) or
 *   [Condition.page_categories][google.cloud.retail.v2beta.Condition.page_categories]
 *   (for browse only), but can't specify both.
 *
 * * Action Inputs: attribute name, position
 *
 * * Action Result: Will force return a facet key around a certain position
 * or above if the condition is satisfied.
 *
 * Example: Suppose the query is "shoes", the
 * [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 * is "shoes", the
 * [ForceReturnFacetAction.FacetPositionAdjustment.attribute_name][google.cloud.retail.v2beta.Rule.ForceReturnFacetAction.FacetPositionAdjustment.attribute_name]
 * is "size" and the
 * [ForceReturnFacetAction.FacetPositionAdjustment.position][google.cloud.retail.v2beta.Rule.ForceReturnFacetAction.FacetPositionAdjustment.position]
 * is 8.
 *
 * Two cases: a) The facet key "size" is not already in the top 8 slots, then
 * the facet "size" will appear at a position close to 8. b) The facet key
 * "size" in among the top 8 positions in the request, then it will stay at
 * its current rank.
 */
export interface Rule_ForceReturnFacetAction {
  /**
   * Each instance corresponds to a force return attribute for the given
   * condition. There can't be more 3 instances here.
   */
  facetPositionAdjustments: Rule_ForceReturnFacetAction_FacetPositionAdjustment[];
}

/**
 * Each facet position adjustment consists of a single attribute name (i.e.
 * facet key) along with a specified position.
 */
export interface Rule_ForceReturnFacetAction_FacetPositionAdjustment {
  /**
   * The attribute name to force return as a facet. Each attribute name
   * should be a valid attribute name, be non-empty and contain at most 80
   * characters long.
   */
  attributeName: string;
  /**
   * This is the position in the request as explained above. It should be
   * strictly positive be at most 100.
   */
  position: number;
}

/**
 * Removes an attribute/facet in the request if is present.
 *
 * * Rule Condition:
 *   Must specify non-empty
 *   [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 *   (for search only) or
 *   [Condition.page_categories][google.cloud.retail.v2beta.Condition.page_categories]
 *   (for browse only), but can't specify both.
 *
 * * Action Input: attribute name
 *
 * * Action Result: Will remove the attribute (as a facet) from the request
 * if it is present.
 *
 * Example: Suppose the query is "shoes", the
 * [Condition.query_terms][google.cloud.retail.v2beta.Condition.query_terms]
 * is "shoes" and the attribute name "size", then facet key "size" will be
 * removed from the request (if it is present).
 */
export interface Rule_RemoveFacetAction {
  /**
   * The attribute names (i.e. facet keys) to remove from the dynamic facets
   * (if present in the request). There can't be more 3 attribute names.
   * Each attribute name should be a valid attribute name, be non-empty and
   * contain at most 80 characters.
   */
  attributeNames: string[];
}

/**
 * An intended audience of the [Product][google.cloud.retail.v2beta.Product] for
 * whom it's sold.
 */
export interface Audience {
  /**
   * The genders of the audience. Strongly encouraged to use the standard
   * values: "male", "female", "unisex".
   *
   * At most 5 values are allowed. Each value must be a UTF-8 encoded string
   * with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error
   * is returned.
   *
   * Google Merchant Center property
   * [gender](https://support.google.com/merchants/answer/6324479). Schema.org
   * property
   * [Product.audience.suggestedGender](https://schema.org/suggestedGender).
   */
  genders: string[];
  /**
   * The age groups of the audience. Strongly encouraged to use the standard
   * values: "newborn" (up to 3 months old), "infant" (3–12 months old),
   * "toddler" (1–5 years old), "kids" (5–13 years old), "adult" (typically
   * teens or older).
   *
   * At most 5 values are allowed. Each value must be a UTF-8 encoded string
   * with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error
   * is returned.
   *
   * Google Merchant Center property
   * [age_group](https://support.google.com/merchants/answer/6324463).
   * Schema.org property
   * [Product.audience.suggestedMinAge](https://schema.org/suggestedMinAge) and
   * [Product.audience.suggestedMaxAge](https://schema.org/suggestedMaxAge).
   */
  ageGroups: string[];
}

/** The color information of a [Product][google.cloud.retail.v2beta.Product]. */
export interface ColorInfo {
  /**
   * The standard color families. Strongly recommended to use the following
   * standard color groups: "Red", "Pink", "Orange", "Yellow", "Purple",
   * "Green", "Cyan", "Blue", "Brown", "White", "Gray", "Black" and
   * "Mixed". Normally it is expected to have only 1 color family. May consider
   * using single "Mixed" instead of multiple values.
   *
   * A maximum of 5 values are allowed. Each value must be a UTF-8 encoded
   * string with a length limit of 128 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Google Merchant Center property
   * [color](https://support.google.com/merchants/answer/6324487). Schema.org
   * property [Product.color](https://schema.org/color).
   */
  colorFamilies: string[];
  /**
   * The color display names, which may be different from standard color family
   * names, such as the color aliases used in the website frontend. Normally
   * it is expected to have only 1 color. May consider using single "Mixed"
   * instead of multiple values.
   *
   * A maximum of 75 colors are allowed. Each value must be a UTF-8 encoded
   * string with a length limit of 128 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Google Merchant Center property
   * [color](https://support.google.com/merchants/answer/6324487). Schema.org
   * property [Product.color](https://schema.org/color).
   */
  colors: string[];
}

/**
 * A custom attribute that is not explicitly modeled in
 * [Product][google.cloud.retail.v2beta.Product].
 */
export interface CustomAttribute {
  /**
   * The textual values of this custom attribute. For example, `["yellow",
   * "green"]` when the key is "color".
   *
   * Empty string is not allowed. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   *
   * Exactly one of [text][google.cloud.retail.v2beta.CustomAttribute.text] or
   * [numbers][google.cloud.retail.v2beta.CustomAttribute.numbers] should be
   * set. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  text: string[];
  /**
   * The numerical values of this custom attribute. For example, `[2.3, 15.4]`
   * when the key is "lengths_cm".
   *
   * Exactly one of [text][google.cloud.retail.v2beta.CustomAttribute.text] or
   * [numbers][google.cloud.retail.v2beta.CustomAttribute.numbers] should be
   * set. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  numbers: number[];
  /**
   * This field is normally ignored unless
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2beta.AttributesConfig.attribute_config_level]
   * of the [Catalog][google.cloud.retail.v2beta.Catalog] is set to the
   * deprecated 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode. For information about
   * product-level attribute configuration, see [Configuration
   * modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
   * If true, custom attribute values are searchable by text queries in
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search].
   *
   * This field is ignored in a
   * [UserEvent][google.cloud.retail.v2beta.UserEvent].
   *
   * Only set if type [text][google.cloud.retail.v2beta.CustomAttribute.text] is
   * set. Otherwise, a INVALID_ARGUMENT error is returned.
   *
   * @deprecated
   */
  searchable?:
    | boolean
    | undefined;
  /**
   * This field is normally ignored unless
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2beta.AttributesConfig.attribute_config_level]
   * of the [Catalog][google.cloud.retail.v2beta.Catalog] is set to the
   * deprecated 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode. For information about
   * product-level attribute configuration, see [Configuration
   * modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
   * If true, custom attribute values are indexed, so that they can be filtered,
   * faceted or boosted in
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search].
   *
   * This field is ignored in a
   * [UserEvent][google.cloud.retail.v2beta.UserEvent].
   *
   * See
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter],
   * [SearchRequest.facet_specs][google.cloud.retail.v2beta.SearchRequest.facet_specs]
   * and
   * [SearchRequest.boost_spec][google.cloud.retail.v2beta.SearchRequest.boost_spec]
   * for more details.
   *
   * @deprecated
   */
  indexable?: boolean | undefined;
}

/**
 * Fulfillment information, such as the store IDs for in-store pickup or region
 * IDs for different shipping methods.
 */
export interface FulfillmentInfo {
  /**
   * The fulfillment type, including commonly used types (such as pickup in
   * store and same day delivery), and custom types. Customers have to map
   * custom types to their display names before rendering UI.
   *
   * Supported values:
   *
   * * "pickup-in-store"
   * * "ship-to-store"
   * * "same-day-delivery"
   * * "next-day-delivery"
   * * "custom-type-1"
   * * "custom-type-2"
   * * "custom-type-3"
   * * "custom-type-4"
   * * "custom-type-5"
   *
   * If this field is set to an invalid value other than these, an
   * INVALID_ARGUMENT error is returned.
   */
  type: string;
  /**
   * The IDs for this [type][google.cloud.retail.v2beta.FulfillmentInfo.type],
   * such as the store IDs for
   * [FulfillmentInfo.type.pickup-in-store][google.cloud.retail.v2beta.FulfillmentInfo.type]
   * or the region IDs for
   * [FulfillmentInfo.type.same-day-delivery][google.cloud.retail.v2beta.FulfillmentInfo.type].
   *
   * A maximum of 3000 values are allowed. Each value must be a string with a
   * length limit of 30 characters, matching the pattern `[a-zA-Z0-9_-]+`, such
   * as "store1" or "REGION-2". Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  placeIds: string[];
}

/**
 * [Product][google.cloud.retail.v2beta.Product] image. Recommendations AI and
 * Retail Search do not use product images to improve prediction and search
 * results. However, product images can be returned in results, and are shown in
 * prediction or search previews in the console.
 */
export interface Image {
  /**
   * Required. URI of the image.
   *
   * This field must be a valid UTF-8 encoded URI with a length limit of 5,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Google Merchant Center property
   * [image_link](https://support.google.com/merchants/answer/6324350).
   * Schema.org property [Product.image](https://schema.org/image).
   */
  uri: string;
  /**
   * Height of the image in number of pixels.
   *
   * This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  height: number;
  /**
   * Width of the image in number of pixels.
   *
   * This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  width: number;
}

/** A floating point interval. */
export interface Interval {
  /** Inclusive lower bound. */
  minimum?:
    | number
    | undefined;
  /** Exclusive lower bound. */
  exclusiveMinimum?:
    | number
    | undefined;
  /** Inclusive upper bound. */
  maximum?:
    | number
    | undefined;
  /** Exclusive upper bound. */
  exclusiveMaximum?: number | undefined;
}

/** The price information of a [Product][google.cloud.retail.v2beta.Product]. */
export interface PriceInfo {
  /**
   * The 3-letter currency code defined in [ISO
   * 4217](https://www.iso.org/iso-4217-currency-codes.html).
   *
   * If this field is an unrecognizable currency code, an INVALID_ARGUMENT
   * error is returned.
   *
   * The [Product.Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s with the same
   * [Product.primary_product_id][google.cloud.retail.v2beta.Product.primary_product_id]
   * must share the same
   * [currency_code][google.cloud.retail.v2beta.PriceInfo.currency_code].
   * Otherwise, a FAILED_PRECONDITION error is returned.
   */
  currencyCode: string;
  /**
   * Price of the product.
   *
   * Google Merchant Center property
   * [price](https://support.google.com/merchants/answer/6324371). Schema.org
   * property [Offer.price](https://schema.org/price).
   */
  price: number;
  /**
   * Price of the product without any discount. If zero, by default set to be
   * the [price][google.cloud.retail.v2beta.PriceInfo.price]. If set,
   * [original_price][google.cloud.retail.v2beta.PriceInfo.original_price]
   * should be greater than or equal to
   * [price][google.cloud.retail.v2beta.PriceInfo.price], otherwise an
   * INVALID_ARGUMENT error is thrown.
   */
  originalPrice: number;
  /**
   * The costs associated with the sale of a particular product. Used for gross
   * profit reporting.
   *
   * * Profit = [price][google.cloud.retail.v2beta.PriceInfo.price] -
   * [cost][google.cloud.retail.v2beta.PriceInfo.cost]
   *
   * Google Merchant Center property
   * [cost_of_goods_sold](https://support.google.com/merchants/answer/9017895).
   */
  cost: number;
  /**
   * The timestamp when the [price][google.cloud.retail.v2beta.PriceInfo.price]
   * starts to be effective. This can be set as a future timestamp, and the
   * [price][google.cloud.retail.v2beta.PriceInfo.price] is only used for search
   * after
   * [price_effective_time][google.cloud.retail.v2beta.PriceInfo.price_effective_time].
   * If so, the
   * [original_price][google.cloud.retail.v2beta.PriceInfo.original_price] must
   * be set and
   * [original_price][google.cloud.retail.v2beta.PriceInfo.original_price] is
   * used before
   * [price_effective_time][google.cloud.retail.v2beta.PriceInfo.price_effective_time].
   *
   * Do not set if [price][google.cloud.retail.v2beta.PriceInfo.price] is always
   * effective because it will cause additional latency during search.
   */
  priceEffectiveTime:
    | Date
    | undefined;
  /**
   * The timestamp when the [price][google.cloud.retail.v2beta.PriceInfo.price]
   * stops to be effective. The
   * [price][google.cloud.retail.v2beta.PriceInfo.price] is used for search
   * before
   * [price_expire_time][google.cloud.retail.v2beta.PriceInfo.price_expire_time].
   * If this field is set, the
   * [original_price][google.cloud.retail.v2beta.PriceInfo.original_price] must
   * be set and
   * [original_price][google.cloud.retail.v2beta.PriceInfo.original_price] is
   * used after
   * [price_expire_time][google.cloud.retail.v2beta.PriceInfo.price_expire_time].
   *
   * Do not set if [price][google.cloud.retail.v2beta.PriceInfo.price] is always
   * effective because it will cause additional latency during search.
   */
  priceExpireTime:
    | Date
    | undefined;
  /**
   * Output only. The price range of all the child
   * [Product.Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s grouped together on the
   * [Product.Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]. Only populated for
   * [Product.Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]s.
   *
   * Note: This field is OUTPUT_ONLY for
   * [ProductService.GetProduct][google.cloud.retail.v2beta.ProductService.GetProduct].
   * Do not set this field in API requests.
   */
  priceRange: PriceInfo_PriceRange | undefined;
}

/**
 * The price range of all
 * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
 * [Product][google.cloud.retail.v2beta.Product] having the same
 * [Product.primary_product_id][google.cloud.retail.v2beta.Product.primary_product_id].
 */
export interface PriceInfo_PriceRange {
  /**
   * The inclusive
   * [Product.pricing_info.price][google.cloud.retail.v2beta.PriceInfo.price]
   * interval of all
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product] having the same
   * [Product.primary_product_id][google.cloud.retail.v2beta.Product.primary_product_id].
   */
  price:
    | Interval
    | undefined;
  /**
   * The inclusive
   * [Product.pricing_info.original_price][google.cloud.retail.v2beta.PriceInfo.original_price]
   * internal of all
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product] having the same
   * [Product.primary_product_id][google.cloud.retail.v2beta.Product.primary_product_id].
   */
  originalPrice: Interval | undefined;
}

/** The rating of a [Product][google.cloud.retail.v2beta.Product]. */
export interface Rating {
  /**
   * The total number of ratings. This value is independent of the value of
   * [rating_histogram][google.cloud.retail.v2beta.Rating.rating_histogram].
   *
   * This value must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  ratingCount: number;
  /**
   * The average rating of the [Product][google.cloud.retail.v2beta.Product].
   *
   * The rating is scaled at 1-5. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  averageRating: number;
  /**
   * List of rating counts per rating value (index = rating - 1). The list is
   * empty if there is no rating. If the list is non-empty, its size is
   * always 5. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * For example, [41, 14, 13, 47, 303]. It means that the
   * [Product][google.cloud.retail.v2beta.Product] got 41 ratings with 1 star,
   * 14 ratings with 2 star, and so on.
   */
  ratingHistogram: number[];
}

/** Information of an end user. */
export interface UserInfo {
  /**
   * Highly recommended for logged-in users. Unique identifier for logged-in
   * user, such as a user name. Don't set for anonymous users.
   *
   * Always use a hashed value for this ID.
   *
   * Don't set the field to the same fixed ID for different users. This mixes
   * the event history of those users together, which results in degraded
   * model quality.
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  userId: string;
  /**
   * The end user's IP address. This field is used to extract location
   * information for personalization.
   *
   * This field must be either an IPv4 address (e.g. "104.133.9.80") or an IPv6
   * address (e.g. "2001:0db8:85a3:0000:0000:8a2e:0370:7334"). Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * This should not be set when:
   *
   * * setting
   * [SearchRequest.user_info][google.cloud.retail.v2beta.SearchRequest.user_info].
   * * using the JavaScript tag in
   * [UserEventService.CollectUserEvent][google.cloud.retail.v2beta.UserEventService.CollectUserEvent]
   * or if
   * [direct_user_request][google.cloud.retail.v2beta.UserInfo.direct_user_request]
   * is set.
   */
  ipAddress: string;
  /**
   * User agent as included in the HTTP header. Required for getting
   * [SearchResponse.sponsored_results][google.cloud.retail.v2beta.SearchResponse.sponsored_results].
   *
   * The field must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * This should not be set when using the client side event reporting with
   * GTM or JavaScript tag in
   * [UserEventService.CollectUserEvent][google.cloud.retail.v2beta.UserEventService.CollectUserEvent]
   * or if
   * [direct_user_request][google.cloud.retail.v2beta.UserInfo.direct_user_request]
   * is set.
   */
  userAgent: string;
  /**
   * True if the request is made directly from the end user, in which case the
   * [ip_address][google.cloud.retail.v2beta.UserInfo.ip_address] and
   * [user_agent][google.cloud.retail.v2beta.UserInfo.user_agent] can be
   * populated from the HTTP request. This flag should be set only if the API
   * request is made directly from the end user such as a mobile app (and not if
   * a gateway or a server is processing and pushing the user events).
   *
   * This should not be set when using the JavaScript tag in
   * [UserEventService.CollectUserEvent][google.cloud.retail.v2beta.UserEventService.CollectUserEvent].
   */
  directUserRequest: boolean;
}

/**
 * The inventory information at a place (e.g. a store) identified
 * by a place ID.
 */
export interface LocalInventory {
  /** The place ID for the current set of inventory information. */
  placeId: string;
  /**
   * Product price and cost information.
   *
   * Google Merchant Center property
   * [price](https://support.google.com/merchants/answer/6324371).
   */
  priceInfo:
    | PriceInfo
    | undefined;
  /**
   * Additional local inventory attributes, for example, store name, promotion
   * tags, etc.
   *
   * This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
   * error is returned:
   *
   * * At most 30 attributes are allowed.
   * * The key must be a UTF-8 encoded string with a length limit of 32
   *   characters.
   * * The key must match the pattern: `[a-zA-Z0-9][a-zA-Z0-9_]*`. For example,
   *   key0LikeThis or KEY_1_LIKE_THIS.
   * * The attribute values must be of the same type (text or number).
   * * Only 1 value is allowed for each attribute.
   * * For text values, the length limit is 256 UTF-8 characters.
   * * The attribute does not support search. The `searchable` field should be
   *   unset or set to false.
   * * The max summed total bytes of custom attribute keys and values per
   *   product is 5MiB.
   */
  attributes: { [key: string]: CustomAttribute };
  /**
   * Input only. Supported fulfillment types. Valid fulfillment type values
   * include commonly used types (such as pickup in store and same day
   * delivery), and custom types. Customers have to map custom types to their
   * display names before rendering UI.
   *
   * Supported values:
   *
   * * "pickup-in-store"
   * * "ship-to-store"
   * * "same-day-delivery"
   * * "next-day-delivery"
   * * "custom-type-1"
   * * "custom-type-2"
   * * "custom-type-3"
   * * "custom-type-4"
   * * "custom-type-5"
   *
   * If this field is set to an invalid value other than these, an
   * INVALID_ARGUMENT error is returned.
   *
   * All the elements must be distinct. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   */
  fulfillmentTypes: string[];
}

export interface LocalInventory_AttributesEntry {
  key: string;
  value: CustomAttribute | undefined;
}

function createBaseCondition(): Condition {
  return { queryTerms: [], activeTimeRange: [], pageCategories: [] };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTerms) {
      Condition_QueryTerm.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.activeTimeRange) {
      Condition_TimeRange.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.pageCategories) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryTerms.push(Condition_QueryTerm.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.activeTimeRange.push(Condition_TimeRange.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageCategories.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      queryTerms: globalThis.Array.isArray(object?.queryTerms)
        ? object.queryTerms.map((e: any) => Condition_QueryTerm.fromJSON(e))
        : [],
      activeTimeRange: globalThis.Array.isArray(object?.activeTimeRange)
        ? object.activeTimeRange.map((e: any) => Condition_TimeRange.fromJSON(e))
        : [],
      pageCategories: globalThis.Array.isArray(object?.pageCategories)
        ? object.pageCategories.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.queryTerms?.length) {
      obj.queryTerms = message.queryTerms.map((e) => Condition_QueryTerm.toJSON(e));
    }
    if (message.activeTimeRange?.length) {
      obj.activeTimeRange = message.activeTimeRange.map((e) => Condition_TimeRange.toJSON(e));
    }
    if (message.pageCategories?.length) {
      obj.pageCategories = message.pageCategories;
    }
    return obj;
  },

  create(base?: DeepPartial<Condition>): Condition {
    return Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition>): Condition {
    const message = createBaseCondition();
    message.queryTerms = object.queryTerms?.map((e) => Condition_QueryTerm.fromPartial(e)) || [];
    message.activeTimeRange = object.activeTimeRange?.map((e) => Condition_TimeRange.fromPartial(e)) || [];
    message.pageCategories = object.pageCategories?.map((e) => e) || [];
    return message;
  },
};

function createBaseCondition_QueryTerm(): Condition_QueryTerm {
  return { value: "", fullMatch: false };
}

export const Condition_QueryTerm: MessageFns<Condition_QueryTerm> = {
  encode(message: Condition_QueryTerm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.fullMatch !== false) {
      writer.uint32(16).bool(message.fullMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition_QueryTerm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition_QueryTerm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fullMatch = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition_QueryTerm {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      fullMatch: isSet(object.fullMatch) ? globalThis.Boolean(object.fullMatch) : false,
    };
  },

  toJSON(message: Condition_QueryTerm): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.fullMatch !== false) {
      obj.fullMatch = message.fullMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<Condition_QueryTerm>): Condition_QueryTerm {
    return Condition_QueryTerm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition_QueryTerm>): Condition_QueryTerm {
    const message = createBaseCondition_QueryTerm();
    message.value = object.value ?? "";
    message.fullMatch = object.fullMatch ?? false;
    return message;
  },
};

function createBaseCondition_TimeRange(): Condition_TimeRange {
  return { startTime: undefined, endTime: undefined };
}

export const Condition_TimeRange: MessageFns<Condition_TimeRange> = {
  encode(message: Condition_TimeRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition_TimeRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition_TimeRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition_TimeRange {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: Condition_TimeRange): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Condition_TimeRange>): Condition_TimeRange {
    return Condition_TimeRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition_TimeRange>): Condition_TimeRange {
    const message = createBaseCondition_TimeRange();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseRule(): Rule {
  return {
    boostAction: undefined,
    redirectAction: undefined,
    onewaySynonymsAction: undefined,
    doNotAssociateAction: undefined,
    replacementAction: undefined,
    ignoreAction: undefined,
    filterAction: undefined,
    twowaySynonymsAction: undefined,
    forceReturnFacetAction: undefined,
    removeFacetAction: undefined,
    condition: undefined,
  };
}

export const Rule: MessageFns<Rule> = {
  encode(message: Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boostAction !== undefined) {
      Rule_BoostAction.encode(message.boostAction, writer.uint32(18).fork()).join();
    }
    if (message.redirectAction !== undefined) {
      Rule_RedirectAction.encode(message.redirectAction, writer.uint32(26).fork()).join();
    }
    if (message.onewaySynonymsAction !== undefined) {
      Rule_OnewaySynonymsAction.encode(message.onewaySynonymsAction, writer.uint32(50).fork()).join();
    }
    if (message.doNotAssociateAction !== undefined) {
      Rule_DoNotAssociateAction.encode(message.doNotAssociateAction, writer.uint32(58).fork()).join();
    }
    if (message.replacementAction !== undefined) {
      Rule_ReplacementAction.encode(message.replacementAction, writer.uint32(66).fork()).join();
    }
    if (message.ignoreAction !== undefined) {
      Rule_IgnoreAction.encode(message.ignoreAction, writer.uint32(74).fork()).join();
    }
    if (message.filterAction !== undefined) {
      Rule_FilterAction.encode(message.filterAction, writer.uint32(82).fork()).join();
    }
    if (message.twowaySynonymsAction !== undefined) {
      Rule_TwowaySynonymsAction.encode(message.twowaySynonymsAction, writer.uint32(90).fork()).join();
    }
    if (message.forceReturnFacetAction !== undefined) {
      Rule_ForceReturnFacetAction.encode(message.forceReturnFacetAction, writer.uint32(98).fork()).join();
    }
    if (message.removeFacetAction !== undefined) {
      Rule_RemoveFacetAction.encode(message.removeFacetAction, writer.uint32(106).fork()).join();
    }
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boostAction = Rule_BoostAction.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.redirectAction = Rule_RedirectAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.onewaySynonymsAction = Rule_OnewaySynonymsAction.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.doNotAssociateAction = Rule_DoNotAssociateAction.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.replacementAction = Rule_ReplacementAction.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.ignoreAction = Rule_IgnoreAction.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.filterAction = Rule_FilterAction.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.twowaySynonymsAction = Rule_TwowaySynonymsAction.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.forceReturnFacetAction = Rule_ForceReturnFacetAction.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.removeFacetAction = Rule_RemoveFacetAction.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule {
    return {
      boostAction: isSet(object.boostAction) ? Rule_BoostAction.fromJSON(object.boostAction) : undefined,
      redirectAction: isSet(object.redirectAction) ? Rule_RedirectAction.fromJSON(object.redirectAction) : undefined,
      onewaySynonymsAction: isSet(object.onewaySynonymsAction)
        ? Rule_OnewaySynonymsAction.fromJSON(object.onewaySynonymsAction)
        : undefined,
      doNotAssociateAction: isSet(object.doNotAssociateAction)
        ? Rule_DoNotAssociateAction.fromJSON(object.doNotAssociateAction)
        : undefined,
      replacementAction: isSet(object.replacementAction)
        ? Rule_ReplacementAction.fromJSON(object.replacementAction)
        : undefined,
      ignoreAction: isSet(object.ignoreAction) ? Rule_IgnoreAction.fromJSON(object.ignoreAction) : undefined,
      filterAction: isSet(object.filterAction) ? Rule_FilterAction.fromJSON(object.filterAction) : undefined,
      twowaySynonymsAction: isSet(object.twowaySynonymsAction)
        ? Rule_TwowaySynonymsAction.fromJSON(object.twowaySynonymsAction)
        : undefined,
      forceReturnFacetAction: isSet(object.forceReturnFacetAction)
        ? Rule_ForceReturnFacetAction.fromJSON(object.forceReturnFacetAction)
        : undefined,
      removeFacetAction: isSet(object.removeFacetAction)
        ? Rule_RemoveFacetAction.fromJSON(object.removeFacetAction)
        : undefined,
      condition: isSet(object.condition) ? Condition.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: Rule): unknown {
    const obj: any = {};
    if (message.boostAction !== undefined) {
      obj.boostAction = Rule_BoostAction.toJSON(message.boostAction);
    }
    if (message.redirectAction !== undefined) {
      obj.redirectAction = Rule_RedirectAction.toJSON(message.redirectAction);
    }
    if (message.onewaySynonymsAction !== undefined) {
      obj.onewaySynonymsAction = Rule_OnewaySynonymsAction.toJSON(message.onewaySynonymsAction);
    }
    if (message.doNotAssociateAction !== undefined) {
      obj.doNotAssociateAction = Rule_DoNotAssociateAction.toJSON(message.doNotAssociateAction);
    }
    if (message.replacementAction !== undefined) {
      obj.replacementAction = Rule_ReplacementAction.toJSON(message.replacementAction);
    }
    if (message.ignoreAction !== undefined) {
      obj.ignoreAction = Rule_IgnoreAction.toJSON(message.ignoreAction);
    }
    if (message.filterAction !== undefined) {
      obj.filterAction = Rule_FilterAction.toJSON(message.filterAction);
    }
    if (message.twowaySynonymsAction !== undefined) {
      obj.twowaySynonymsAction = Rule_TwowaySynonymsAction.toJSON(message.twowaySynonymsAction);
    }
    if (message.forceReturnFacetAction !== undefined) {
      obj.forceReturnFacetAction = Rule_ForceReturnFacetAction.toJSON(message.forceReturnFacetAction);
    }
    if (message.removeFacetAction !== undefined) {
      obj.removeFacetAction = Rule_RemoveFacetAction.toJSON(message.removeFacetAction);
    }
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<Rule>): Rule {
    return Rule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule>): Rule {
    const message = createBaseRule();
    message.boostAction = (object.boostAction !== undefined && object.boostAction !== null)
      ? Rule_BoostAction.fromPartial(object.boostAction)
      : undefined;
    message.redirectAction = (object.redirectAction !== undefined && object.redirectAction !== null)
      ? Rule_RedirectAction.fromPartial(object.redirectAction)
      : undefined;
    message.onewaySynonymsAction = (object.onewaySynonymsAction !== undefined && object.onewaySynonymsAction !== null)
      ? Rule_OnewaySynonymsAction.fromPartial(object.onewaySynonymsAction)
      : undefined;
    message.doNotAssociateAction = (object.doNotAssociateAction !== undefined && object.doNotAssociateAction !== null)
      ? Rule_DoNotAssociateAction.fromPartial(object.doNotAssociateAction)
      : undefined;
    message.replacementAction = (object.replacementAction !== undefined && object.replacementAction !== null)
      ? Rule_ReplacementAction.fromPartial(object.replacementAction)
      : undefined;
    message.ignoreAction = (object.ignoreAction !== undefined && object.ignoreAction !== null)
      ? Rule_IgnoreAction.fromPartial(object.ignoreAction)
      : undefined;
    message.filterAction = (object.filterAction !== undefined && object.filterAction !== null)
      ? Rule_FilterAction.fromPartial(object.filterAction)
      : undefined;
    message.twowaySynonymsAction = (object.twowaySynonymsAction !== undefined && object.twowaySynonymsAction !== null)
      ? Rule_TwowaySynonymsAction.fromPartial(object.twowaySynonymsAction)
      : undefined;
    message.forceReturnFacetAction =
      (object.forceReturnFacetAction !== undefined && object.forceReturnFacetAction !== null)
        ? Rule_ForceReturnFacetAction.fromPartial(object.forceReturnFacetAction)
        : undefined;
    message.removeFacetAction = (object.removeFacetAction !== undefined && object.removeFacetAction !== null)
      ? Rule_RemoveFacetAction.fromPartial(object.removeFacetAction)
      : undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Condition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseRule_BoostAction(): Rule_BoostAction {
  return { boost: 0, productsFilter: "" };
}

export const Rule_BoostAction: MessageFns<Rule_BoostAction> = {
  encode(message: Rule_BoostAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boost !== 0) {
      writer.uint32(13).float(message.boost);
    }
    if (message.productsFilter !== "") {
      writer.uint32(18).string(message.productsFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_BoostAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_BoostAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.boost = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.productsFilter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_BoostAction {
    return {
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
      productsFilter: isSet(object.productsFilter) ? globalThis.String(object.productsFilter) : "",
    };
  },

  toJSON(message: Rule_BoostAction): unknown {
    const obj: any = {};
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    if (message.productsFilter !== "") {
      obj.productsFilter = message.productsFilter;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_BoostAction>): Rule_BoostAction {
    return Rule_BoostAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_BoostAction>): Rule_BoostAction {
    const message = createBaseRule_BoostAction();
    message.boost = object.boost ?? 0;
    message.productsFilter = object.productsFilter ?? "";
    return message;
  },
};

function createBaseRule_FilterAction(): Rule_FilterAction {
  return { filter: "" };
}

export const Rule_FilterAction: MessageFns<Rule_FilterAction> = {
  encode(message: Rule_FilterAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_FilterAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_FilterAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_FilterAction {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : "" };
  },

  toJSON(message: Rule_FilterAction): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_FilterAction>): Rule_FilterAction {
    return Rule_FilterAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_FilterAction>): Rule_FilterAction {
    const message = createBaseRule_FilterAction();
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseRule_RedirectAction(): Rule_RedirectAction {
  return { redirectUri: "" };
}

export const Rule_RedirectAction: MessageFns<Rule_RedirectAction> = {
  encode(message: Rule_RedirectAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUri !== "") {
      writer.uint32(10).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_RedirectAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_RedirectAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_RedirectAction {
    return { redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "" };
  },

  toJSON(message: Rule_RedirectAction): unknown {
    const obj: any = {};
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_RedirectAction>): Rule_RedirectAction {
    return Rule_RedirectAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_RedirectAction>): Rule_RedirectAction {
    const message = createBaseRule_RedirectAction();
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseRule_TwowaySynonymsAction(): Rule_TwowaySynonymsAction {
  return { synonyms: [] };
}

export const Rule_TwowaySynonymsAction: MessageFns<Rule_TwowaySynonymsAction> = {
  encode(message: Rule_TwowaySynonymsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.synonyms) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_TwowaySynonymsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_TwowaySynonymsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.synonyms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_TwowaySynonymsAction {
    return {
      synonyms: globalThis.Array.isArray(object?.synonyms) ? object.synonyms.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Rule_TwowaySynonymsAction): unknown {
    const obj: any = {};
    if (message.synonyms?.length) {
      obj.synonyms = message.synonyms;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_TwowaySynonymsAction>): Rule_TwowaySynonymsAction {
    return Rule_TwowaySynonymsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_TwowaySynonymsAction>): Rule_TwowaySynonymsAction {
    const message = createBaseRule_TwowaySynonymsAction();
    message.synonyms = object.synonyms?.map((e) => e) || [];
    return message;
  },
};

function createBaseRule_OnewaySynonymsAction(): Rule_OnewaySynonymsAction {
  return { queryTerms: [], synonyms: [], onewayTerms: [] };
}

export const Rule_OnewaySynonymsAction: MessageFns<Rule_OnewaySynonymsAction> = {
  encode(message: Rule_OnewaySynonymsAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTerms) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.synonyms) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.onewayTerms) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_OnewaySynonymsAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_OnewaySynonymsAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queryTerms.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.synonyms.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.onewayTerms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_OnewaySynonymsAction {
    return {
      queryTerms: globalThis.Array.isArray(object?.queryTerms)
        ? object.queryTerms.map((e: any) => globalThis.String(e))
        : [],
      synonyms: globalThis.Array.isArray(object?.synonyms) ? object.synonyms.map((e: any) => globalThis.String(e)) : [],
      onewayTerms: globalThis.Array.isArray(object?.onewayTerms)
        ? object.onewayTerms.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Rule_OnewaySynonymsAction): unknown {
    const obj: any = {};
    if (message.queryTerms?.length) {
      obj.queryTerms = message.queryTerms;
    }
    if (message.synonyms?.length) {
      obj.synonyms = message.synonyms;
    }
    if (message.onewayTerms?.length) {
      obj.onewayTerms = message.onewayTerms;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_OnewaySynonymsAction>): Rule_OnewaySynonymsAction {
    return Rule_OnewaySynonymsAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_OnewaySynonymsAction>): Rule_OnewaySynonymsAction {
    const message = createBaseRule_OnewaySynonymsAction();
    message.queryTerms = object.queryTerms?.map((e) => e) || [];
    message.synonyms = object.synonyms?.map((e) => e) || [];
    message.onewayTerms = object.onewayTerms?.map((e) => e) || [];
    return message;
  },
};

function createBaseRule_DoNotAssociateAction(): Rule_DoNotAssociateAction {
  return { queryTerms: [], doNotAssociateTerms: [], terms: [] };
}

export const Rule_DoNotAssociateAction: MessageFns<Rule_DoNotAssociateAction> = {
  encode(message: Rule_DoNotAssociateAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTerms) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.doNotAssociateTerms) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.terms) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_DoNotAssociateAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_DoNotAssociateAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryTerms.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.doNotAssociateTerms.push(reader.string());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.terms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_DoNotAssociateAction {
    return {
      queryTerms: globalThis.Array.isArray(object?.queryTerms)
        ? object.queryTerms.map((e: any) => globalThis.String(e))
        : [],
      doNotAssociateTerms: globalThis.Array.isArray(object?.doNotAssociateTerms)
        ? object.doNotAssociateTerms.map((e: any) => globalThis.String(e))
        : [],
      terms: globalThis.Array.isArray(object?.terms) ? object.terms.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Rule_DoNotAssociateAction): unknown {
    const obj: any = {};
    if (message.queryTerms?.length) {
      obj.queryTerms = message.queryTerms;
    }
    if (message.doNotAssociateTerms?.length) {
      obj.doNotAssociateTerms = message.doNotAssociateTerms;
    }
    if (message.terms?.length) {
      obj.terms = message.terms;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_DoNotAssociateAction>): Rule_DoNotAssociateAction {
    return Rule_DoNotAssociateAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_DoNotAssociateAction>): Rule_DoNotAssociateAction {
    const message = createBaseRule_DoNotAssociateAction();
    message.queryTerms = object.queryTerms?.map((e) => e) || [];
    message.doNotAssociateTerms = object.doNotAssociateTerms?.map((e) => e) || [];
    message.terms = object.terms?.map((e) => e) || [];
    return message;
  },
};

function createBaseRule_ReplacementAction(): Rule_ReplacementAction {
  return { queryTerms: [], replacementTerm: "", term: "" };
}

export const Rule_ReplacementAction: MessageFns<Rule_ReplacementAction> = {
  encode(message: Rule_ReplacementAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queryTerms) {
      writer.uint32(18).string(v!);
    }
    if (message.replacementTerm !== "") {
      writer.uint32(26).string(message.replacementTerm);
    }
    if (message.term !== "") {
      writer.uint32(10).string(message.term);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_ReplacementAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_ReplacementAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryTerms.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.replacementTerm = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.term = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_ReplacementAction {
    return {
      queryTerms: globalThis.Array.isArray(object?.queryTerms)
        ? object.queryTerms.map((e: any) => globalThis.String(e))
        : [],
      replacementTerm: isSet(object.replacementTerm) ? globalThis.String(object.replacementTerm) : "",
      term: isSet(object.term) ? globalThis.String(object.term) : "",
    };
  },

  toJSON(message: Rule_ReplacementAction): unknown {
    const obj: any = {};
    if (message.queryTerms?.length) {
      obj.queryTerms = message.queryTerms;
    }
    if (message.replacementTerm !== "") {
      obj.replacementTerm = message.replacementTerm;
    }
    if (message.term !== "") {
      obj.term = message.term;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_ReplacementAction>): Rule_ReplacementAction {
    return Rule_ReplacementAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_ReplacementAction>): Rule_ReplacementAction {
    const message = createBaseRule_ReplacementAction();
    message.queryTerms = object.queryTerms?.map((e) => e) || [];
    message.replacementTerm = object.replacementTerm ?? "";
    message.term = object.term ?? "";
    return message;
  },
};

function createBaseRule_IgnoreAction(): Rule_IgnoreAction {
  return { ignoreTerms: [] };
}

export const Rule_IgnoreAction: MessageFns<Rule_IgnoreAction> = {
  encode(message: Rule_IgnoreAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ignoreTerms) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_IgnoreAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_IgnoreAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ignoreTerms.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_IgnoreAction {
    return {
      ignoreTerms: globalThis.Array.isArray(object?.ignoreTerms)
        ? object.ignoreTerms.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Rule_IgnoreAction): unknown {
    const obj: any = {};
    if (message.ignoreTerms?.length) {
      obj.ignoreTerms = message.ignoreTerms;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_IgnoreAction>): Rule_IgnoreAction {
    return Rule_IgnoreAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_IgnoreAction>): Rule_IgnoreAction {
    const message = createBaseRule_IgnoreAction();
    message.ignoreTerms = object.ignoreTerms?.map((e) => e) || [];
    return message;
  },
};

function createBaseRule_ForceReturnFacetAction(): Rule_ForceReturnFacetAction {
  return { facetPositionAdjustments: [] };
}

export const Rule_ForceReturnFacetAction: MessageFns<Rule_ForceReturnFacetAction> = {
  encode(message: Rule_ForceReturnFacetAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.facetPositionAdjustments) {
      Rule_ForceReturnFacetAction_FacetPositionAdjustment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_ForceReturnFacetAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_ForceReturnFacetAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetPositionAdjustments.push(
            Rule_ForceReturnFacetAction_FacetPositionAdjustment.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_ForceReturnFacetAction {
    return {
      facetPositionAdjustments: globalThis.Array.isArray(object?.facetPositionAdjustments)
        ? object.facetPositionAdjustments.map((e: any) =>
          Rule_ForceReturnFacetAction_FacetPositionAdjustment.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: Rule_ForceReturnFacetAction): unknown {
    const obj: any = {};
    if (message.facetPositionAdjustments?.length) {
      obj.facetPositionAdjustments = message.facetPositionAdjustments.map((e) =>
        Rule_ForceReturnFacetAction_FacetPositionAdjustment.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_ForceReturnFacetAction>): Rule_ForceReturnFacetAction {
    return Rule_ForceReturnFacetAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_ForceReturnFacetAction>): Rule_ForceReturnFacetAction {
    const message = createBaseRule_ForceReturnFacetAction();
    message.facetPositionAdjustments =
      object.facetPositionAdjustments?.map((e) => Rule_ForceReturnFacetAction_FacetPositionAdjustment.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseRule_ForceReturnFacetAction_FacetPositionAdjustment(): Rule_ForceReturnFacetAction_FacetPositionAdjustment {
  return { attributeName: "", position: 0 };
}

export const Rule_ForceReturnFacetAction_FacetPositionAdjustment: MessageFns<
  Rule_ForceReturnFacetAction_FacetPositionAdjustment
> = {
  encode(
    message: Rule_ForceReturnFacetAction_FacetPositionAdjustment,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.attributeName !== "") {
      writer.uint32(10).string(message.attributeName);
    }
    if (message.position !== 0) {
      writer.uint32(16).int32(message.position);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_ForceReturnFacetAction_FacetPositionAdjustment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_ForceReturnFacetAction_FacetPositionAdjustment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.position = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_ForceReturnFacetAction_FacetPositionAdjustment {
    return {
      attributeName: isSet(object.attributeName) ? globalThis.String(object.attributeName) : "",
      position: isSet(object.position) ? globalThis.Number(object.position) : 0,
    };
  },

  toJSON(message: Rule_ForceReturnFacetAction_FacetPositionAdjustment): unknown {
    const obj: any = {};
    if (message.attributeName !== "") {
      obj.attributeName = message.attributeName;
    }
    if (message.position !== 0) {
      obj.position = Math.round(message.position);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Rule_ForceReturnFacetAction_FacetPositionAdjustment>,
  ): Rule_ForceReturnFacetAction_FacetPositionAdjustment {
    return Rule_ForceReturnFacetAction_FacetPositionAdjustment.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Rule_ForceReturnFacetAction_FacetPositionAdjustment>,
  ): Rule_ForceReturnFacetAction_FacetPositionAdjustment {
    const message = createBaseRule_ForceReturnFacetAction_FacetPositionAdjustment();
    message.attributeName = object.attributeName ?? "";
    message.position = object.position ?? 0;
    return message;
  },
};

function createBaseRule_RemoveFacetAction(): Rule_RemoveFacetAction {
  return { attributeNames: [] };
}

export const Rule_RemoveFacetAction: MessageFns<Rule_RemoveFacetAction> = {
  encode(message: Rule_RemoveFacetAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributeNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule_RemoveFacetAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule_RemoveFacetAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule_RemoveFacetAction {
    return {
      attributeNames: globalThis.Array.isArray(object?.attributeNames)
        ? object.attributeNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Rule_RemoveFacetAction): unknown {
    const obj: any = {};
    if (message.attributeNames?.length) {
      obj.attributeNames = message.attributeNames;
    }
    return obj;
  },

  create(base?: DeepPartial<Rule_RemoveFacetAction>): Rule_RemoveFacetAction {
    return Rule_RemoveFacetAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule_RemoveFacetAction>): Rule_RemoveFacetAction {
    const message = createBaseRule_RemoveFacetAction();
    message.attributeNames = object.attributeNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseAudience(): Audience {
  return { genders: [], ageGroups: [] };
}

export const Audience: MessageFns<Audience> = {
  encode(message: Audience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.genders) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.ageGroups) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Audience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.genders.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ageGroups.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Audience {
    return {
      genders: globalThis.Array.isArray(object?.genders) ? object.genders.map((e: any) => globalThis.String(e)) : [],
      ageGroups: globalThis.Array.isArray(object?.ageGroups)
        ? object.ageGroups.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Audience): unknown {
    const obj: any = {};
    if (message.genders?.length) {
      obj.genders = message.genders;
    }
    if (message.ageGroups?.length) {
      obj.ageGroups = message.ageGroups;
    }
    return obj;
  },

  create(base?: DeepPartial<Audience>): Audience {
    return Audience.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Audience>): Audience {
    const message = createBaseAudience();
    message.genders = object.genders?.map((e) => e) || [];
    message.ageGroups = object.ageGroups?.map((e) => e) || [];
    return message;
  },
};

function createBaseColorInfo(): ColorInfo {
  return { colorFamilies: [], colors: [] };
}

export const ColorInfo: MessageFns<ColorInfo> = {
  encode(message: ColorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.colorFamilies) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.colors) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.colorFamilies.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.colors.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColorInfo {
    return {
      colorFamilies: globalThis.Array.isArray(object?.colorFamilies)
        ? object.colorFamilies.map((e: any) => globalThis.String(e))
        : [],
      colors: globalThis.Array.isArray(object?.colors) ? object.colors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ColorInfo): unknown {
    const obj: any = {};
    if (message.colorFamilies?.length) {
      obj.colorFamilies = message.colorFamilies;
    }
    if (message.colors?.length) {
      obj.colors = message.colors;
    }
    return obj;
  },

  create(base?: DeepPartial<ColorInfo>): ColorInfo {
    return ColorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColorInfo>): ColorInfo {
    const message = createBaseColorInfo();
    message.colorFamilies = object.colorFamilies?.map((e) => e) || [];
    message.colors = object.colors?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomAttribute(): CustomAttribute {
  return { text: [], numbers: [], searchable: undefined, indexable: undefined };
}

export const CustomAttribute: MessageFns<CustomAttribute> = {
  encode(message: CustomAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.text) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.numbers) {
      writer.double(v);
    }
    writer.join();
    if (message.searchable !== undefined) {
      writer.uint32(24).bool(message.searchable);
    }
    if (message.indexable !== undefined) {
      writer.uint32(32).bool(message.indexable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text.push(reader.string());
          continue;
        case 2:
          if (tag === 17) {
            message.numbers.push(reader.double());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.numbers.push(reader.double());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.searchable = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.indexable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomAttribute {
    return {
      text: globalThis.Array.isArray(object?.text) ? object.text.map((e: any) => globalThis.String(e)) : [],
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.Number(e)) : [],
      searchable: isSet(object.searchable) ? globalThis.Boolean(object.searchable) : undefined,
      indexable: isSet(object.indexable) ? globalThis.Boolean(object.indexable) : undefined,
    };
  },

  toJSON(message: CustomAttribute): unknown {
    const obj: any = {};
    if (message.text?.length) {
      obj.text = message.text;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    if (message.searchable !== undefined) {
      obj.searchable = message.searchable;
    }
    if (message.indexable !== undefined) {
      obj.indexable = message.indexable;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomAttribute>): CustomAttribute {
    return CustomAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomAttribute>): CustomAttribute {
    const message = createBaseCustomAttribute();
    message.text = object.text?.map((e) => e) || [];
    message.numbers = object.numbers?.map((e) => e) || [];
    message.searchable = object.searchable ?? undefined;
    message.indexable = object.indexable ?? undefined;
    return message;
  },
};

function createBaseFulfillmentInfo(): FulfillmentInfo {
  return { type: "", placeIds: [] };
}

export const FulfillmentInfo: MessageFns<FulfillmentInfo> = {
  encode(message: FulfillmentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    for (const v of message.placeIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FulfillmentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFulfillmentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.placeIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FulfillmentInfo {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      placeIds: globalThis.Array.isArray(object?.placeIds) ? object.placeIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: FulfillmentInfo): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.placeIds?.length) {
      obj.placeIds = message.placeIds;
    }
    return obj;
  },

  create(base?: DeepPartial<FulfillmentInfo>): FulfillmentInfo {
    return FulfillmentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FulfillmentInfo>): FulfillmentInfo {
    const message = createBaseFulfillmentInfo();
    message.type = object.type ?? "";
    message.placeIds = object.placeIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseImage(): Image {
  return { uri: "", height: 0, width: 0 };
}

export const Image: MessageFns<Image> = {
  encode(message: Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Image {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
    };
  },

  toJSON(message: Image): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    return obj;
  },

  create(base?: DeepPartial<Image>): Image {
    return Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Image>): Image {
    const message = createBaseImage();
    message.uri = object.uri ?? "";
    message.height = object.height ?? 0;
    message.width = object.width ?? 0;
    return message;
  },
};

function createBaseInterval(): Interval {
  return { minimum: undefined, exclusiveMinimum: undefined, maximum: undefined, exclusiveMaximum: undefined };
}

export const Interval: MessageFns<Interval> = {
  encode(message: Interval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minimum !== undefined) {
      writer.uint32(9).double(message.minimum);
    }
    if (message.exclusiveMinimum !== undefined) {
      writer.uint32(17).double(message.exclusiveMinimum);
    }
    if (message.maximum !== undefined) {
      writer.uint32(25).double(message.maximum);
    }
    if (message.exclusiveMaximum !== undefined) {
      writer.uint32(33).double(message.exclusiveMaximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.minimum = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.exclusiveMinimum = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.maximum = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.exclusiveMaximum = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interval {
    return {
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : undefined,
      exclusiveMinimum: isSet(object.exclusiveMinimum) ? globalThis.Number(object.exclusiveMinimum) : undefined,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : undefined,
      exclusiveMaximum: isSet(object.exclusiveMaximum) ? globalThis.Number(object.exclusiveMaximum) : undefined,
    };
  },

  toJSON(message: Interval): unknown {
    const obj: any = {};
    if (message.minimum !== undefined) {
      obj.minimum = message.minimum;
    }
    if (message.exclusiveMinimum !== undefined) {
      obj.exclusiveMinimum = message.exclusiveMinimum;
    }
    if (message.maximum !== undefined) {
      obj.maximum = message.maximum;
    }
    if (message.exclusiveMaximum !== undefined) {
      obj.exclusiveMaximum = message.exclusiveMaximum;
    }
    return obj;
  },

  create(base?: DeepPartial<Interval>): Interval {
    return Interval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interval>): Interval {
    const message = createBaseInterval();
    message.minimum = object.minimum ?? undefined;
    message.exclusiveMinimum = object.exclusiveMinimum ?? undefined;
    message.maximum = object.maximum ?? undefined;
    message.exclusiveMaximum = object.exclusiveMaximum ?? undefined;
    return message;
  },
};

function createBasePriceInfo(): PriceInfo {
  return {
    currencyCode: "",
    price: 0,
    originalPrice: 0,
    cost: 0,
    priceEffectiveTime: undefined,
    priceExpireTime: undefined,
    priceRange: undefined,
  };
}

export const PriceInfo: MessageFns<PriceInfo> = {
  encode(message: PriceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currencyCode !== "") {
      writer.uint32(10).string(message.currencyCode);
    }
    if (message.price !== 0) {
      writer.uint32(21).float(message.price);
    }
    if (message.originalPrice !== 0) {
      writer.uint32(29).float(message.originalPrice);
    }
    if (message.cost !== 0) {
      writer.uint32(37).float(message.cost);
    }
    if (message.priceEffectiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.priceEffectiveTime), writer.uint32(42).fork()).join();
    }
    if (message.priceExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.priceExpireTime), writer.uint32(50).fork()).join();
    }
    if (message.priceRange !== undefined) {
      PriceInfo_PriceRange.encode(message.priceRange, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.price = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.cost = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.priceEffectiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.priceExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.priceRange = PriceInfo_PriceRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceInfo {
    return {
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : 0,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      priceEffectiveTime: isSet(object.priceEffectiveTime) ? fromJsonTimestamp(object.priceEffectiveTime) : undefined,
      priceExpireTime: isSet(object.priceExpireTime) ? fromJsonTimestamp(object.priceExpireTime) : undefined,
      priceRange: isSet(object.priceRange) ? PriceInfo_PriceRange.fromJSON(object.priceRange) : undefined,
    };
  },

  toJSON(message: PriceInfo): unknown {
    const obj: any = {};
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.originalPrice !== 0) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.priceEffectiveTime !== undefined) {
      obj.priceEffectiveTime = message.priceEffectiveTime.toISOString();
    }
    if (message.priceExpireTime !== undefined) {
      obj.priceExpireTime = message.priceExpireTime.toISOString();
    }
    if (message.priceRange !== undefined) {
      obj.priceRange = PriceInfo_PriceRange.toJSON(message.priceRange);
    }
    return obj;
  },

  create(base?: DeepPartial<PriceInfo>): PriceInfo {
    return PriceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceInfo>): PriceInfo {
    const message = createBasePriceInfo();
    message.currencyCode = object.currencyCode ?? "";
    message.price = object.price ?? 0;
    message.originalPrice = object.originalPrice ?? 0;
    message.cost = object.cost ?? 0;
    message.priceEffectiveTime = object.priceEffectiveTime ?? undefined;
    message.priceExpireTime = object.priceExpireTime ?? undefined;
    message.priceRange = (object.priceRange !== undefined && object.priceRange !== null)
      ? PriceInfo_PriceRange.fromPartial(object.priceRange)
      : undefined;
    return message;
  },
};

function createBasePriceInfo_PriceRange(): PriceInfo_PriceRange {
  return { price: undefined, originalPrice: undefined };
}

export const PriceInfo_PriceRange: MessageFns<PriceInfo_PriceRange> = {
  encode(message: PriceInfo_PriceRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      Interval.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (message.originalPrice !== undefined) {
      Interval.encode(message.originalPrice, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceInfo_PriceRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceInfo_PriceRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.price = Interval.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalPrice = Interval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceInfo_PriceRange {
    return {
      price: isSet(object.price) ? Interval.fromJSON(object.price) : undefined,
      originalPrice: isSet(object.originalPrice) ? Interval.fromJSON(object.originalPrice) : undefined,
    };
  },

  toJSON(message: PriceInfo_PriceRange): unknown {
    const obj: any = {};
    if (message.price !== undefined) {
      obj.price = Interval.toJSON(message.price);
    }
    if (message.originalPrice !== undefined) {
      obj.originalPrice = Interval.toJSON(message.originalPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<PriceInfo_PriceRange>): PriceInfo_PriceRange {
    return PriceInfo_PriceRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceInfo_PriceRange>): PriceInfo_PriceRange {
    const message = createBasePriceInfo_PriceRange();
    message.price = (object.price !== undefined && object.price !== null)
      ? Interval.fromPartial(object.price)
      : undefined;
    message.originalPrice = (object.originalPrice !== undefined && object.originalPrice !== null)
      ? Interval.fromPartial(object.originalPrice)
      : undefined;
    return message;
  },
};

function createBaseRating(): Rating {
  return { ratingCount: 0, averageRating: 0, ratingHistogram: [] };
}

export const Rating: MessageFns<Rating> = {
  encode(message: Rating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ratingCount !== 0) {
      writer.uint32(8).int32(message.ratingCount);
    }
    if (message.averageRating !== 0) {
      writer.uint32(21).float(message.averageRating);
    }
    writer.uint32(26).fork();
    for (const v of message.ratingHistogram) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ratingCount = reader.int32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.averageRating = reader.float();
          continue;
        case 3:
          if (tag === 24) {
            message.ratingHistogram.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ratingHistogram.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rating {
    return {
      ratingCount: isSet(object.ratingCount) ? globalThis.Number(object.ratingCount) : 0,
      averageRating: isSet(object.averageRating) ? globalThis.Number(object.averageRating) : 0,
      ratingHistogram: globalThis.Array.isArray(object?.ratingHistogram)
        ? object.ratingHistogram.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: Rating): unknown {
    const obj: any = {};
    if (message.ratingCount !== 0) {
      obj.ratingCount = Math.round(message.ratingCount);
    }
    if (message.averageRating !== 0) {
      obj.averageRating = message.averageRating;
    }
    if (message.ratingHistogram?.length) {
      obj.ratingHistogram = message.ratingHistogram.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Rating>): Rating {
    return Rating.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rating>): Rating {
    const message = createBaseRating();
    message.ratingCount = object.ratingCount ?? 0;
    message.averageRating = object.averageRating ?? 0;
    message.ratingHistogram = object.ratingHistogram?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { userId: "", ipAddress: "", userAgent: "", directUserRequest: false };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (message.directUserRequest !== false) {
      writer.uint32(32).bool(message.directUserRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.directUserRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      directUserRequest: isSet(object.directUserRequest) ? globalThis.Boolean(object.directUserRequest) : false,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.directUserRequest !== false) {
      obj.directUserRequest = message.directUserRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.directUserRequest = object.directUserRequest ?? false;
    return message;
  },
};

function createBaseLocalInventory(): LocalInventory {
  return { placeId: "", priceInfo: undefined, attributes: {}, fulfillmentTypes: [] };
}

export const LocalInventory: MessageFns<LocalInventory> = {
  encode(message: LocalInventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placeId !== "") {
      writer.uint32(10).string(message.placeId);
    }
    if (message.priceInfo !== undefined) {
      PriceInfo.encode(message.priceInfo, writer.uint32(18).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      LocalInventory_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.fulfillmentTypes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalInventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.priceInfo = PriceInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = LocalInventory_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fulfillmentTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalInventory {
    return {
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
      priceInfo: isSet(object.priceInfo) ? PriceInfo.fromJSON(object.priceInfo) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: CustomAttribute }>((acc, [key, value]) => {
          acc[key] = CustomAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      fulfillmentTypes: globalThis.Array.isArray(object?.fulfillmentTypes)
        ? object.fulfillmentTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LocalInventory): unknown {
    const obj: any = {};
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    if (message.priceInfo !== undefined) {
      obj.priceInfo = PriceInfo.toJSON(message.priceInfo);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = CustomAttribute.toJSON(v);
        });
      }
    }
    if (message.fulfillmentTypes?.length) {
      obj.fulfillmentTypes = message.fulfillmentTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<LocalInventory>): LocalInventory {
    return LocalInventory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalInventory>): LocalInventory {
    const message = createBaseLocalInventory();
    message.placeId = object.placeId ?? "";
    message.priceInfo = (object.priceInfo !== undefined && object.priceInfo !== null)
      ? PriceInfo.fromPartial(object.priceInfo)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: CustomAttribute }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CustomAttribute.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.fulfillmentTypes = object.fulfillmentTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseLocalInventory_AttributesEntry(): LocalInventory_AttributesEntry {
  return { key: "", value: undefined };
}

export const LocalInventory_AttributesEntry: MessageFns<LocalInventory_AttributesEntry> = {
  encode(message: LocalInventory_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CustomAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalInventory_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalInventory_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CustomAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalInventory_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CustomAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LocalInventory_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CustomAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<LocalInventory_AttributesEntry>): LocalInventory_AttributesEntry {
    return LocalInventory_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalInventory_AttributesEntry>): LocalInventory_AttributesEntry {
    const message = createBaseLocalInventory_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CustomAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
