// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2alpha/user_event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import { CustomAttribute, UserInfo } from "./common.js";
import { Product } from "./product.js";

export const protobufPackage = "google.cloud.retail.v2alpha";

/**
 * UserEvent captures all metadata information Retail API needs to know about
 * how end users interact with customers' website.
 */
export interface UserEvent {
  /**
   * Required. User event type. Allowed values are:
   *
   * * `add-to-cart`: Products being added to cart.
   * * `remove-from-cart`: Products being removed from cart.
   * * `category-page-view`: Special pages such as sale or promotion pages
   *   viewed.
   * * `detail-page-view`: Products detail page viewed.
   * * `home-page-view`: Homepage viewed.
   * * `promotion-offered`: Promotion is offered to a user.
   * * `promotion-not-offered`: Promotion is not offered to a user.
   * * `purchase-complete`: User finishing a purchase.
   * * `search`: Product search.
   * * `shopping-cart-page-view`: User viewing a shopping cart.
   */
  eventType: string;
  /**
   * Required. A unique identifier for tracking visitors.
   *
   * For example, this could be implemented with an HTTP cookie, which should be
   * able to uniquely identify a visitor on a single device. This unique
   * identifier should not change if the visitor log in/out of the website.
   *
   * Don't set the field to the same fixed ID for different users. This mixes
   * the event history of those users together, which results in degraded model
   * quality.
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * The field should not contain PII or user-data. We recommend to use Google
   * Analytics [Client
   * ID](https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId)
   * for this field.
   */
  visitorId: string;
  /**
   * A unique identifier for tracking a visitor session with a length limit of
   * 128 bytes. A session is an aggregation of an end user behavior in a time
   * span.
   *
   * A general guideline to populate the sesion_id:
   * 1. If user has no activity for 30 min, a new session_id should be assigned.
   * 2. The session_id should be unique across users, suggest use uuid or add
   * visitor_id as prefix.
   */
  sessionId: string;
  /**
   * Only required for
   * [UserEventService.ImportUserEvents][google.cloud.retail.v2alpha.UserEventService.ImportUserEvents]
   * method. Timestamp of when the user event happened.
   */
  eventTime:
    | Date
    | undefined;
  /**
   * A list of identifiers for the independent experiment groups this user event
   * belongs to. This is used to distinguish between user events associated with
   * different experiment setups (e.g. using Retail API, using different
   * recommendation models).
   */
  experimentIds: string[];
  /**
   * Highly recommended for user events that are the result of
   * [PredictionService.Predict][google.cloud.retail.v2alpha.PredictionService.Predict].
   * This field enables accurate attribution of recommendation model
   * performance.
   *
   * The value must be a valid
   * [PredictResponse.attribution_token][google.cloud.retail.v2alpha.PredictResponse.attribution_token]
   * for user events that are the result of
   * [PredictionService.Predict][google.cloud.retail.v2alpha.PredictionService.Predict].
   * The value must be a valid
   * [SearchResponse.attribution_token][google.cloud.retail.v2alpha.SearchResponse.attribution_token]
   * for user events that are the result of
   * [SearchService.Search][google.cloud.retail.v2alpha.SearchService.Search].
   *
   * This token enables us to accurately attribute page view or purchase back to
   * the event and the particular predict response containing this
   * clicked/purchased product. If user clicks on product K in the
   * recommendation results, pass
   * [PredictResponse.attribution_token][google.cloud.retail.v2alpha.PredictResponse.attribution_token]
   * as a URL parameter to product K's page. When recording events on product
   * K's page, log the
   * [PredictResponse.attribution_token][google.cloud.retail.v2alpha.PredictResponse.attribution_token]
   * to this field.
   */
  attributionToken: string;
  /**
   * The main product details related to the event.
   *
   * This field is optional except for the following event types:
   *
   * * `add-to-cart`
   * * `detail-page-view`
   * * `purchase-complete`
   *
   * In a `search` event, this field represents the products returned to the end
   * user on the current page (the end user may have not finished browsing the
   * whole page yet). When a new page is returned to the end user, after
   * pagination/filtering/ordering even for the same query, a new `search` event
   * with different
   * [product_details][google.cloud.retail.v2alpha.UserEvent.product_details] is
   * desired. The end user may have not finished browsing the whole page yet.
   */
  productDetails: ProductDetail[];
  /**
   * The main auto-completion details related to the event.
   *
   * This field should be set for `search` event when autocomplete function is
   * enabled and the user clicks a suggestion for search.
   */
  completionDetail:
    | CompletionDetail
    | undefined;
  /**
   * Extra user event features to include in the recommendation model.
   *
   * If you provide custom attributes for ingested user events, also include
   * them in the user events that you associate with prediction requests. Custom
   * attribute formatting must be consistent between imported events and events
   * provided with prediction requests. This lets the Retail API use
   * those custom attributes when training models and serving predictions, which
   * helps improve recommendation quality.
   *
   * This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
   * error is returned:
   *
   * * The key must be a UTF-8 encoded string with a length limit of 5,000
   *   characters.
   * * For text attributes, at most 400 values are allowed. Empty values are not
   *   allowed. Each value must be a UTF-8 encoded string with a length limit of
   *   256 characters.
   * * For number attributes, at most 400 values are allowed.
   *
   * For product recommendations, an example of extra user information is
   * traffic_channel, which is how a user arrives at the site. Users can arrive
   * at the site by coming to the site directly, coming through Google
   * search, or in other ways.
   */
  attributes: { [key: string]: CustomAttribute };
  /**
   * The ID or name of the associated shopping cart. This ID is used
   * to associate multiple items added or present in the cart before purchase.
   *
   * This can only be set for `add-to-cart`, `purchase-complete`, or
   * `shopping-cart-page-view` events.
   */
  cartId: string;
  /**
   * A transaction represents the entire purchase transaction.
   *
   * Required for `purchase-complete` events. Other event types should not set
   * this field. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  purchaseTransaction:
    | PurchaseTransaction
    | undefined;
  /**
   * The user's search query.
   *
   * See [SearchRequest.query][google.cloud.retail.v2alpha.SearchRequest.query]
   * for definition.
   *
   * The value must be a UTF-8 encoded string with a length limit of 5,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * At least one of
   * [search_query][google.cloud.retail.v2alpha.UserEvent.search_query] or
   * [page_categories][google.cloud.retail.v2alpha.UserEvent.page_categories] is
   * required for `search` events. Other event types should not set this field.
   * Otherwise, an INVALID_ARGUMENT error is returned.
   */
  searchQuery: string;
  /**
   * The filter syntax consists of an expression language for constructing a
   * predicate from one or more fields of the products being filtered.
   *
   * See
   * [SearchRequest.filter][google.cloud.retail.v2alpha.SearchRequest.filter]
   * for definition and syntax.
   *
   * The value must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  filter: string;
  /**
   * The order in which products are returned.
   *
   * See
   * [SearchRequest.order_by][google.cloud.retail.v2alpha.SearchRequest.order_by]
   * for definition and syntax.
   *
   * The value must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * This can only be set for `search` events. Other event types should not set
   * this field. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  orderBy: string;
  /**
   * An integer that specifies the current offset for pagination (the 0-indexed
   * starting location, amongst the products deemed by the API as relevant).
   *
   * See
   * [SearchRequest.offset][google.cloud.retail.v2alpha.SearchRequest.offset]
   * for definition.
   *
   * If this field is negative, an INVALID_ARGUMENT is returned.
   *
   * This can only be set for `search` events. Other event types should not set
   * this field. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  offset: number;
  /**
   * The categories associated with a category page.
   *
   * To represent full path of category, use '>' sign to separate different
   * hierarchies. If '>' is part of the category name, replace it with
   * other character(s).
   *
   * Category pages include special pages such as sales or promotions. For
   * instance, a special sale page may have the category hierarchy:
   * "pageCategories" : ["Sales > 2017 Black Friday Deals"].
   *
   * Required for `category-page-view` events. At least one of
   * [search_query][google.cloud.retail.v2alpha.UserEvent.search_query] or
   * [page_categories][google.cloud.retail.v2alpha.UserEvent.page_categories] is
   * required for `search` events. Other event types should not set this field.
   * Otherwise, an INVALID_ARGUMENT error is returned.
   */
  pageCategories: string[];
  /** User information. */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * Complete URL (window.location.href) of the user's current page.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically. Maximum length 5,000
   * characters.
   */
  uri: string;
  /**
   * The referrer URL of the current page.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically.
   */
  referrerUri: string;
  /**
   * A unique ID of a web page view.
   *
   * This should be kept the same for all user events triggered from the same
   * pageview. For example, an item detail page view could trigger multiple
   * events as the user is browsing the page. The `pageViewId` property should
   * be kept the same for all these events so that they can be grouped together
   * properly.
   *
   * When using the client side event reporting with JavaScript pixel and Google
   * Tag Manager, this value is filled in automatically.
   */
  pageViewId: string;
  /**
   * The entity for customers that may run multiple different entities, domains,
   * sites or regions, for example, `Google US`, `Google Ads`, `Waymo`,
   * `google.com`, `youtube.com`, etc.
   * We recommend that you set this field to get better per-entity search,
   * completion, and prediction results.
   */
  entity: string;
}

export interface UserEvent_AttributesEntry {
  key: string;
  value: CustomAttribute | undefined;
}

/** Detailed product information associated with a user event. */
export interface ProductDetail {
  /**
   * Required. [Product][google.cloud.retail.v2alpha.Product] information.
   *
   * Required field(s):
   *
   * * [Product.id][google.cloud.retail.v2alpha.Product.id]
   *
   * Optional override field(s):
   *
   * * [Product.price_info][google.cloud.retail.v2alpha.Product.price_info]
   *
   * If any supported optional fields are provided, we will treat them as a full
   * override when looking up product information from the catalog. Thus, it is
   * important to ensure that the overriding fields are accurate and
   * complete.
   *
   * All other product fields are ignored and instead populated via catalog
   * lookup after event ingestion.
   */
  product:
    | Product
    | undefined;
  /**
   * Quantity of the product associated with the user event.
   *
   * For example, this field will be 2 if two products are added to the shopping
   * cart for `purchase-complete` event. Required for `add-to-cart` and
   * `purchase-complete` event types.
   */
  quantity: number | undefined;
}

/**
 * Detailed completion information including completion attribution token and
 * clicked completion info.
 */
export interface CompletionDetail {
  /**
   * Completion attribution token in
   * [CompleteQueryResponse.attribution_token][google.cloud.retail.v2alpha.CompleteQueryResponse.attribution_token].
   */
  completionAttributionToken: string;
  /**
   * End user selected
   * [CompleteQueryResponse.CompletionResult.suggestion][google.cloud.retail.v2alpha.CompleteQueryResponse.CompletionResult.suggestion].
   */
  selectedSuggestion: string;
  /**
   * End user selected
   * [CompleteQueryResponse.CompletionResult.suggestion][google.cloud.retail.v2alpha.CompleteQueryResponse.CompletionResult.suggestion]
   * position, starting from 0.
   */
  selectedPosition: number;
}

/** A transaction represents the entire purchase transaction. */
export interface PurchaseTransaction {
  /** The transaction ID with a length limit of 128 characters. */
  id: string;
  /**
   * Required. Total non-zero revenue or grand total associated with the
   * transaction. This value include shipping, tax, or other adjustments to
   * total revenue that you want to include as part of your revenue
   * calculations.
   */
  revenue: number;
  /** All the taxes associated with the transaction. */
  tax: number;
  /**
   * All the costs associated with the products. These can be manufacturing
   * costs, shipping expenses not borne by the end user, or any other costs,
   * such that:
   *
   * * Profit =
   * [revenue][google.cloud.retail.v2alpha.PurchaseTransaction.revenue] -
   * [tax][google.cloud.retail.v2alpha.PurchaseTransaction.tax] -
   * [cost][google.cloud.retail.v2alpha.PurchaseTransaction.cost]
   */
  cost: number;
  /** Required. Currency code. Use three-character ISO-4217 code. */
  currencyCode: string;
}

function createBaseUserEvent(): UserEvent {
  return {
    eventType: "",
    visitorId: "",
    sessionId: "",
    eventTime: undefined,
    experimentIds: [],
    attributionToken: "",
    productDetails: [],
    completionDetail: undefined,
    attributes: {},
    cartId: "",
    purchaseTransaction: undefined,
    searchQuery: "",
    filter: "",
    orderBy: "",
    offset: 0,
    pageCategories: [],
    userInfo: undefined,
    uri: "",
    referrerUri: "",
    pageViewId: "",
    entity: "",
  };
}

export const UserEvent: MessageFns<UserEvent> = {
  encode(message: UserEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.visitorId !== "") {
      writer.uint32(18).string(message.visitorId);
    }
    if (message.sessionId !== "") {
      writer.uint32(170).string(message.sessionId);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(26).fork()).join();
    }
    for (const v of message.experimentIds) {
      writer.uint32(34).string(v!);
    }
    if (message.attributionToken !== "") {
      writer.uint32(42).string(message.attributionToken);
    }
    for (const v of message.productDetails) {
      ProductDetail.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.completionDetail !== undefined) {
      CompletionDetail.encode(message.completionDetail, writer.uint32(178).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      UserEvent_AttributesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.cartId !== "") {
      writer.uint32(66).string(message.cartId);
    }
    if (message.purchaseTransaction !== undefined) {
      PurchaseTransaction.encode(message.purchaseTransaction, writer.uint32(74).fork()).join();
    }
    if (message.searchQuery !== "") {
      writer.uint32(82).string(message.searchQuery);
    }
    if (message.filter !== "") {
      writer.uint32(130).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(138).string(message.orderBy);
    }
    if (message.offset !== 0) {
      writer.uint32(144).int32(message.offset);
    }
    for (const v of message.pageCategories) {
      writer.uint32(90).string(v!);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(98).fork()).join();
    }
    if (message.uri !== "") {
      writer.uint32(106).string(message.uri);
    }
    if (message.referrerUri !== "") {
      writer.uint32(114).string(message.referrerUri);
    }
    if (message.pageViewId !== "") {
      writer.uint32(122).string(message.pageViewId);
    }
    if (message.entity !== "") {
      writer.uint32(186).string(message.entity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.visitorId = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.experimentIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attributionToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.productDetails.push(ProductDetail.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.completionDetail = CompletionDetail.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = UserEvent_AttributesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.attributes[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cartId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.purchaseTransaction = PurchaseTransaction.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.pageCategories.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.referrerUri = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.pageViewId = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.entity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      visitorId: isSet(object.visitorId) ? globalThis.String(object.visitorId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      experimentIds: globalThis.Array.isArray(object?.experimentIds)
        ? object.experimentIds.map((e: any) => globalThis.String(e))
        : [],
      attributionToken: isSet(object.attributionToken) ? globalThis.String(object.attributionToken) : "",
      productDetails: globalThis.Array.isArray(object?.productDetails)
        ? object.productDetails.map((e: any) => ProductDetail.fromJSON(e))
        : [],
      completionDetail: isSet(object.completionDetail) ? CompletionDetail.fromJSON(object.completionDetail) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: CustomAttribute }>((acc, [key, value]) => {
          acc[key] = CustomAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      cartId: isSet(object.cartId) ? globalThis.String(object.cartId) : "",
      purchaseTransaction: isSet(object.purchaseTransaction)
        ? PurchaseTransaction.fromJSON(object.purchaseTransaction)
        : undefined,
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      pageCategories: globalThis.Array.isArray(object?.pageCategories)
        ? object.pageCategories.map((e: any) => globalThis.String(e))
        : [],
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      referrerUri: isSet(object.referrerUri) ? globalThis.String(object.referrerUri) : "",
      pageViewId: isSet(object.pageViewId) ? globalThis.String(object.pageViewId) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
    };
  },

  toJSON(message: UserEvent): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.visitorId !== "") {
      obj.visitorId = message.visitorId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.experimentIds?.length) {
      obj.experimentIds = message.experimentIds;
    }
    if (message.attributionToken !== "") {
      obj.attributionToken = message.attributionToken;
    }
    if (message.productDetails?.length) {
      obj.productDetails = message.productDetails.map((e) => ProductDetail.toJSON(e));
    }
    if (message.completionDetail !== undefined) {
      obj.completionDetail = CompletionDetail.toJSON(message.completionDetail);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = CustomAttribute.toJSON(v);
        });
      }
    }
    if (message.cartId !== "") {
      obj.cartId = message.cartId;
    }
    if (message.purchaseTransaction !== undefined) {
      obj.purchaseTransaction = PurchaseTransaction.toJSON(message.purchaseTransaction);
    }
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.pageCategories?.length) {
      obj.pageCategories = message.pageCategories;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.referrerUri !== "") {
      obj.referrerUri = message.referrerUri;
    }
    if (message.pageViewId !== "") {
      obj.pageViewId = message.pageViewId;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    return obj;
  },

  create(base?: DeepPartial<UserEvent>): UserEvent {
    return UserEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserEvent>): UserEvent {
    const message = createBaseUserEvent();
    message.eventType = object.eventType ?? "";
    message.visitorId = object.visitorId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.eventTime = object.eventTime ?? undefined;
    message.experimentIds = object.experimentIds?.map((e) => e) || [];
    message.attributionToken = object.attributionToken ?? "";
    message.productDetails = object.productDetails?.map((e) => ProductDetail.fromPartial(e)) || [];
    message.completionDetail = (object.completionDetail !== undefined && object.completionDetail !== null)
      ? CompletionDetail.fromPartial(object.completionDetail)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: CustomAttribute }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CustomAttribute.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.cartId = object.cartId ?? "";
    message.purchaseTransaction = (object.purchaseTransaction !== undefined && object.purchaseTransaction !== null)
      ? PurchaseTransaction.fromPartial(object.purchaseTransaction)
      : undefined;
    message.searchQuery = object.searchQuery ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.offset = object.offset ?? 0;
    message.pageCategories = object.pageCategories?.map((e) => e) || [];
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.uri = object.uri ?? "";
    message.referrerUri = object.referrerUri ?? "";
    message.pageViewId = object.pageViewId ?? "";
    message.entity = object.entity ?? "";
    return message;
  },
};

function createBaseUserEvent_AttributesEntry(): UserEvent_AttributesEntry {
  return { key: "", value: undefined };
}

export const UserEvent_AttributesEntry: MessageFns<UserEvent_AttributesEntry> = {
  encode(message: UserEvent_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CustomAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CustomAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CustomAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: UserEvent_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CustomAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<UserEvent_AttributesEntry>): UserEvent_AttributesEntry {
    return UserEvent_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserEvent_AttributesEntry>): UserEvent_AttributesEntry {
    const message = createBaseUserEvent_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CustomAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseProductDetail(): ProductDetail {
  return { product: undefined, quantity: undefined };
}

export const ProductDetail: MessageFns<ProductDetail> = {
  encode(message: ProductDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== undefined) {
      Int32Value.encode({ value: message.quantity! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quantity = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductDetail {
    return {
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      quantity: isSet(object.quantity) ? Number(object.quantity) : undefined,
    };
  },

  toJSON(message: ProductDetail): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.quantity !== undefined) {
      obj.quantity = message.quantity;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductDetail>): ProductDetail {
    return ProductDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductDetail>): ProductDetail {
    const message = createBaseProductDetail();
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    message.quantity = object.quantity ?? undefined;
    return message;
  },
};

function createBaseCompletionDetail(): CompletionDetail {
  return { completionAttributionToken: "", selectedSuggestion: "", selectedPosition: 0 };
}

export const CompletionDetail: MessageFns<CompletionDetail> = {
  encode(message: CompletionDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.completionAttributionToken !== "") {
      writer.uint32(10).string(message.completionAttributionToken);
    }
    if (message.selectedSuggestion !== "") {
      writer.uint32(18).string(message.selectedSuggestion);
    }
    if (message.selectedPosition !== 0) {
      writer.uint32(24).int32(message.selectedPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.completionAttributionToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.selectedSuggestion = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.selectedPosition = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionDetail {
    return {
      completionAttributionToken: isSet(object.completionAttributionToken)
        ? globalThis.String(object.completionAttributionToken)
        : "",
      selectedSuggestion: isSet(object.selectedSuggestion) ? globalThis.String(object.selectedSuggestion) : "",
      selectedPosition: isSet(object.selectedPosition) ? globalThis.Number(object.selectedPosition) : 0,
    };
  },

  toJSON(message: CompletionDetail): unknown {
    const obj: any = {};
    if (message.completionAttributionToken !== "") {
      obj.completionAttributionToken = message.completionAttributionToken;
    }
    if (message.selectedSuggestion !== "") {
      obj.selectedSuggestion = message.selectedSuggestion;
    }
    if (message.selectedPosition !== 0) {
      obj.selectedPosition = Math.round(message.selectedPosition);
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionDetail>): CompletionDetail {
    return CompletionDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompletionDetail>): CompletionDetail {
    const message = createBaseCompletionDetail();
    message.completionAttributionToken = object.completionAttributionToken ?? "";
    message.selectedSuggestion = object.selectedSuggestion ?? "";
    message.selectedPosition = object.selectedPosition ?? 0;
    return message;
  },
};

function createBasePurchaseTransaction(): PurchaseTransaction {
  return { id: "", revenue: 0, tax: 0, cost: 0, currencyCode: "" };
}

export const PurchaseTransaction: MessageFns<PurchaseTransaction> = {
  encode(message: PurchaseTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.revenue !== 0) {
      writer.uint32(21).float(message.revenue);
    }
    if (message.tax !== 0) {
      writer.uint32(29).float(message.tax);
    }
    if (message.cost !== 0) {
      writer.uint32(37).float(message.cost);
    }
    if (message.currencyCode !== "") {
      writer.uint32(42).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.revenue = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.tax = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.cost = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      revenue: isSet(object.revenue) ? globalThis.Number(object.revenue) : 0,
      tax: isSet(object.tax) ? globalThis.Number(object.tax) : 0,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: PurchaseTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.revenue !== 0) {
      obj.revenue = message.revenue;
    }
    if (message.tax !== 0) {
      obj.tax = message.tax;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<PurchaseTransaction>): PurchaseTransaction {
    return PurchaseTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchaseTransaction>): PurchaseTransaction {
    const message = createBasePurchaseTransaction();
    message.id = object.id ?? "";
    message.revenue = object.revenue ?? 0;
    message.tax = object.tax ?? 0;
    message.cost = object.cost ?? 0;
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
