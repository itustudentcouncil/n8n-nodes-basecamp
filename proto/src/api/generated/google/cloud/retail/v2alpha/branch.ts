// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2alpha/branch.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Product } from "./product.js";

export const protobufPackage = "google.cloud.retail.v2alpha";

/**
 * A view that specifies different level of fields of a
 * [Branch][google.cloud.retail.v2alpha.Branch] to show in responses.
 */
export enum BranchView {
  /** BRANCH_VIEW_UNSPECIFIED - The value when it's unspecified. This defaults to the BASIC view. */
  BRANCH_VIEW_UNSPECIFIED = 0,
  /**
   * BRANCH_VIEW_BASIC - Includes basic metadata about the branch, but not statistical fields.
   * See documentation of fields of [Branch][google.cloud.retail.v2alpha.Branch]
   * to find what fields are excluded from BASIC view.
   */
  BRANCH_VIEW_BASIC = 1,
  /** BRANCH_VIEW_FULL - Includes all fields of a [Branch][google.cloud.retail.v2alpha.Branch]. */
  BRANCH_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function branchViewFromJSON(object: any): BranchView {
  switch (object) {
    case 0:
    case "BRANCH_VIEW_UNSPECIFIED":
      return BranchView.BRANCH_VIEW_UNSPECIFIED;
    case 1:
    case "BRANCH_VIEW_BASIC":
      return BranchView.BRANCH_VIEW_BASIC;
    case 2:
    case "BRANCH_VIEW_FULL":
      return BranchView.BRANCH_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BranchView.UNRECOGNIZED;
  }
}

export function branchViewToJSON(object: BranchView): string {
  switch (object) {
    case BranchView.BRANCH_VIEW_UNSPECIFIED:
      return "BRANCH_VIEW_UNSPECIFIED";
    case BranchView.BRANCH_VIEW_BASIC:
      return "BRANCH_VIEW_BASIC";
    case BranchView.BRANCH_VIEW_FULL:
      return "BRANCH_VIEW_FULL";
    case BranchView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A data branch that stores [Product][google.cloud.retail.v2alpha.Product]s. */
export interface Branch {
  /**
   * Immutable. Full resource name of the branch, such as
   * `projects/* /locations/global/catalogs/default_catalog/branches/branch_id`.
   */
  name: string;
  /** Output only. Human readable name of the branch to display in the UI. */
  displayName: string;
  /**
   * Output only. Indicates whether this branch is set as the default branch of
   * its parent catalog.
   */
  isDefault: boolean;
  /**
   * Output only. Timestamp of last import through
   * [ProductService.ImportProducts][google.cloud.retail.v2alpha.ProductService.ImportProducts].
   * Empty value means no import has been made to this branch.
   */
  lastProductImportTime:
    | Date
    | undefined;
  /**
   * Output only. Statistics for number of products in the branch, provided for
   * different
   * [scopes][google.cloud.retail.v2alpha.Branch.ProductCountStatistic.ProductCountScope].
   *
   * This field is not populated in [BranchView.BASIC][] view.
   */
  productCountStats: Branch_ProductCountStatistic[];
  /**
   * Output only. The quality metrics measured among products of this branch.
   *
   * See
   * [QualityMetric.requirement_key][google.cloud.retail.v2alpha.Branch.QualityMetric.requirement_key]
   * for supported metrics. Metrics could be missing if failed to retrieve.
   *
   * This field is not populated in [BranchView.BASIC][] view.
   */
  qualityMetrics: Branch_QualityMetric[];
}

/** A statistic about the number of products in a branch. */
export interface Branch_ProductCountStatistic {
  /** [ProductCountScope] of the [counts]. */
  scope: Branch_ProductCountStatistic_ProductCountScope;
  /**
   * The number of products in
   * [scope][google.cloud.retail.v2alpha.Branch.ProductCountStatistic.scope]
   * broken down into different groups.
   *
   * The key is a group representing a set of products, and the value is the
   * number of products in that group.
   * Note: keys in this map may change over time.
   *
   * Possible keys:
   * * "primary-in-stock", products have
   * [Product.Type.PRIMARY][google.cloud.retail.v2alpha.Product.Type.PRIMARY]
   * type and
   * [Product.Availability.IN_STOCK][google.cloud.retail.v2alpha.Product.Availability.IN_STOCK]
   * availability.
   *
   * * "primary-out-of-stock", products have
   * [Product.Type.PRIMARY][google.cloud.retail.v2alpha.Product.Type.PRIMARY]
   * type and
   * [Product.Availability.OUT_OF_STOCK][google.cloud.retail.v2alpha.Product.Availability.OUT_OF_STOCK]
   * availability.
   *
   * * "primary-preorder", products have
   * [Product.Type.PRIMARY][google.cloud.retail.v2alpha.Product.Type.PRIMARY]
   * type and
   * [Product.Availability.PREORDER][google.cloud.retail.v2alpha.Product.Availability.PREORDER]
   * availability.
   *
   * * "primary-backorder", products have
   * [Product.Type.PRIMARY][google.cloud.retail.v2alpha.Product.Type.PRIMARY]
   * type and
   * [Product.Availability.BACKORDER][google.cloud.retail.v2alpha.Product.Availability.BACKORDER]
   * availability.
   *
   * * "variant-in-stock", products have
   * [Product.Type.VARIANT][google.cloud.retail.v2alpha.Product.Type.VARIANT]
   * type and
   * [Product.Availability.IN_STOCK][google.cloud.retail.v2alpha.Product.Availability.IN_STOCK]
   * availability.
   *
   * * "variant-out-of-stock", products have
   * [Product.Type.VARIANT][google.cloud.retail.v2alpha.Product.Type.VARIANT]
   * type and
   * [Product.Availability.OUT_OF_STOCK][google.cloud.retail.v2alpha.Product.Availability.OUT_OF_STOCK]
   * availability.
   *
   * * "variant-preorder", products have
   * [Product.Type.VARIANT][google.cloud.retail.v2alpha.Product.Type.VARIANT]
   * type and
   * [Product.Availability.PREORDER][google.cloud.retail.v2alpha.Product.Availability.PREORDER]
   * availability.
   *
   * * "variant-backorder", products have
   * [Product.Type.VARIANT][google.cloud.retail.v2alpha.Product.Type.VARIANT]
   * type and
   * [Product.Availability.BACKORDER][google.cloud.retail.v2alpha.Product.Availability.BACKORDER]
   * availability.
   *
   * * "price-discounted", products have [Product.price_info.price] <
   * [Product.price_info.original_price].
   */
  counts: { [key: string]: Long };
}

/** Scope of what products are included for this count. */
export enum Branch_ProductCountStatistic_ProductCountScope {
  /** PRODUCT_COUNT_SCOPE_UNSPECIFIED - Default value for enum. This value is not used in the API response. */
  PRODUCT_COUNT_SCOPE_UNSPECIFIED = 0,
  /**
   * ALL_PRODUCTS - Scope for all existing products in the branch. Useful for understanding
   * how many products there are in a branch.
   */
  ALL_PRODUCTS = 1,
  /** LAST_24_HOUR_UPDATE - Scope for products created or updated in the last 24 hours. */
  LAST_24_HOUR_UPDATE = 2,
  UNRECOGNIZED = -1,
}

export function branch_ProductCountStatistic_ProductCountScopeFromJSON(
  object: any,
): Branch_ProductCountStatistic_ProductCountScope {
  switch (object) {
    case 0:
    case "PRODUCT_COUNT_SCOPE_UNSPECIFIED":
      return Branch_ProductCountStatistic_ProductCountScope.PRODUCT_COUNT_SCOPE_UNSPECIFIED;
    case 1:
    case "ALL_PRODUCTS":
      return Branch_ProductCountStatistic_ProductCountScope.ALL_PRODUCTS;
    case 2:
    case "LAST_24_HOUR_UPDATE":
      return Branch_ProductCountStatistic_ProductCountScope.LAST_24_HOUR_UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Branch_ProductCountStatistic_ProductCountScope.UNRECOGNIZED;
  }
}

export function branch_ProductCountStatistic_ProductCountScopeToJSON(
  object: Branch_ProductCountStatistic_ProductCountScope,
): string {
  switch (object) {
    case Branch_ProductCountStatistic_ProductCountScope.PRODUCT_COUNT_SCOPE_UNSPECIFIED:
      return "PRODUCT_COUNT_SCOPE_UNSPECIFIED";
    case Branch_ProductCountStatistic_ProductCountScope.ALL_PRODUCTS:
      return "ALL_PRODUCTS";
    case Branch_ProductCountStatistic_ProductCountScope.LAST_24_HOUR_UPDATE:
      return "LAST_24_HOUR_UPDATE";
    case Branch_ProductCountStatistic_ProductCountScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Branch_ProductCountStatistic_CountsEntry {
  key: string;
  value: Long;
}

/**
 * Metric measured on a group of
 * [Product][google.cloud.retail.v2alpha.Product]s against a certain quality
 * requirement. Contains the number of products that pass the check and the
 * number of products that don't.
 */
export interface Branch_QualityMetric {
  /**
   * The key that represents a quality requirement rule.
   *
   * Supported keys:
   * * "has-valid-uri": product has a valid and accessible
   * [uri][google.cloud.retail.v2alpha.Product.uri].
   *
   * * "available-expire-time-conformance":
   * [Product.available_time][google.cloud.retail.v2alpha.Product.available_time]
   * is early than "now", and
   * [Product.expire_time][google.cloud.retail.v2alpha.Product.expire_time] is
   * greater than "now".
   *
   * * "has-searchable-attributes": product has at least one
   * [attribute][google.cloud.retail.v2alpha.Product.attributes] set to
   * searchable.
   *
   * * "has-description": product has non-empty
   * [description][google.cloud.retail.v2alpha.Product.description].
   *
   * * "has-at-least-bigram-title": Product
   * [title][google.cloud.retail.v2alpha.Product.title] has at least two
   * words. A comprehensive title helps to improve search quality.
   *
   * * "variant-has-image": the
   * [variant][google.cloud.retail.v2alpha.Product.Type.VARIANT] products has
   * at least one [image][google.cloud.retail.v2alpha.Product.images]. You may
   * ignore this metric if all your products are at
   * [primary][google.cloud.retail.v2alpha.Product.Type.PRIMARY] level.
   *
   * * "variant-has-price-info": the
   * [variant][google.cloud.retail.v2alpha.Product.Type.VARIANT] products has
   * [price_info][google.cloud.retail.v2alpha.Product.price_info] set. You may
   * ignore this metric if all your products are at
   * [primary][google.cloud.retail.v2alpha.Product.Type.PRIMARY] level.
   *
   * * "has-publish-time": product has non-empty
   * [publish_time][google.cloud.retail.v2alpha.Product.publish_time].
   */
  requirementKey: string;
  /**
   * Number of products passing the quality requirement check. We only check
   * searchable products.
   */
  qualifiedProductCount: number;
  /**
   * Number of products failing the quality requirement check. We only check
   * searchable products.
   */
  unqualifiedProductCount: number;
  /**
   * Value from 0 to 100 representing the suggested percentage of products
   * that meet the quality requirements to get good search and recommendation
   * performance. 100 * (qualified_product_count) /
   * (qualified_product_count + unqualified_product_count) should be greater
   * or equal to this suggestion.
   */
  suggestedQualityPercentThreshold: number;
  /**
   * A list of a maximum of 100 sample products that do not qualify for
   * this requirement.
   *
   * This field is only populated in the response to
   * [BranchService.GetBranch][google.cloud.retail.v2alpha.BranchService.GetBranch]
   * API, and is always empty for
   * [BranchService.ListBranches][google.cloud.retail.v2alpha.BranchService.ListBranches].
   *
   * Only the following fields are set in the
   * [Product][google.cloud.retail.v2alpha.Product].
   *
   * * [Product.name][google.cloud.retail.v2alpha.Product.name]
   * * [Product.id][google.cloud.retail.v2alpha.Product.id]
   * * [Product.title][google.cloud.retail.v2alpha.Product.title]
   */
  unqualifiedSampleProducts: Product[];
}

function createBaseBranch(): Branch {
  return {
    name: "",
    displayName: "",
    isDefault: false,
    lastProductImportTime: undefined,
    productCountStats: [],
    qualityMetrics: [],
  };
}

export const Branch: MessageFns<Branch> = {
  encode(message: Branch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.isDefault !== false) {
      writer.uint32(24).bool(message.isDefault);
    }
    if (message.lastProductImportTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastProductImportTime), writer.uint32(42).fork()).join();
    }
    for (const v of message.productCountStats) {
      Branch_ProductCountStatistic.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.qualityMetrics) {
      Branch_QualityMetric.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Branch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isDefault = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastProductImportTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.productCountStats.push(Branch_ProductCountStatistic.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.qualityMetrics.push(Branch_QualityMetric.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Branch {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      isDefault: isSet(object.isDefault) ? globalThis.Boolean(object.isDefault) : false,
      lastProductImportTime: isSet(object.lastProductImportTime)
        ? fromJsonTimestamp(object.lastProductImportTime)
        : undefined,
      productCountStats: globalThis.Array.isArray(object?.productCountStats)
        ? object.productCountStats.map((e: any) => Branch_ProductCountStatistic.fromJSON(e))
        : [],
      qualityMetrics: globalThis.Array.isArray(object?.qualityMetrics)
        ? object.qualityMetrics.map((e: any) => Branch_QualityMetric.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Branch): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.isDefault !== false) {
      obj.isDefault = message.isDefault;
    }
    if (message.lastProductImportTime !== undefined) {
      obj.lastProductImportTime = message.lastProductImportTime.toISOString();
    }
    if (message.productCountStats?.length) {
      obj.productCountStats = message.productCountStats.map((e) => Branch_ProductCountStatistic.toJSON(e));
    }
    if (message.qualityMetrics?.length) {
      obj.qualityMetrics = message.qualityMetrics.map((e) => Branch_QualityMetric.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Branch>): Branch {
    return Branch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Branch>): Branch {
    const message = createBaseBranch();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.isDefault = object.isDefault ?? false;
    message.lastProductImportTime = object.lastProductImportTime ?? undefined;
    message.productCountStats = object.productCountStats?.map((e) => Branch_ProductCountStatistic.fromPartial(e)) || [];
    message.qualityMetrics = object.qualityMetrics?.map((e) => Branch_QualityMetric.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBranch_ProductCountStatistic(): Branch_ProductCountStatistic {
  return { scope: 0, counts: {} };
}

export const Branch_ProductCountStatistic: MessageFns<Branch_ProductCountStatistic> = {
  encode(message: Branch_ProductCountStatistic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== 0) {
      writer.uint32(8).int32(message.scope);
    }
    Object.entries(message.counts).forEach(([key, value]) => {
      Branch_ProductCountStatistic_CountsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Branch_ProductCountStatistic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranch_ProductCountStatistic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Branch_ProductCountStatistic_CountsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.counts[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Branch_ProductCountStatistic {
    return {
      scope: isSet(object.scope) ? branch_ProductCountStatistic_ProductCountScopeFromJSON(object.scope) : 0,
      counts: isObject(object.counts)
        ? Object.entries(object.counts).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
          acc[key] = Long.fromValue(value as Long | string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Branch_ProductCountStatistic): unknown {
    const obj: any = {};
    if (message.scope !== 0) {
      obj.scope = branch_ProductCountStatistic_ProductCountScopeToJSON(message.scope);
    }
    if (message.counts) {
      const entries = Object.entries(message.counts);
      if (entries.length > 0) {
        obj.counts = {};
        entries.forEach(([k, v]) => {
          obj.counts[k] = v.toString();
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Branch_ProductCountStatistic>): Branch_ProductCountStatistic {
    return Branch_ProductCountStatistic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Branch_ProductCountStatistic>): Branch_ProductCountStatistic {
    const message = createBaseBranch_ProductCountStatistic();
    message.scope = object.scope ?? 0;
    message.counts = Object.entries(object.counts ?? {}).reduce<{ [key: string]: Long }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Long.fromValue(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBranch_ProductCountStatistic_CountsEntry(): Branch_ProductCountStatistic_CountsEntry {
  return { key: "", value: Long.ZERO };
}

export const Branch_ProductCountStatistic_CountsEntry: MessageFns<Branch_ProductCountStatistic_CountsEntry> = {
  encode(message: Branch_ProductCountStatistic_CountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (!message.value.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.value.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Branch_ProductCountStatistic_CountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranch_ProductCountStatistic_CountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Branch_ProductCountStatistic_CountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Long.fromValue(object.value) : Long.ZERO,
    };
  },

  toJSON(message: Branch_ProductCountStatistic_CountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (!message.value.equals(Long.ZERO)) {
      obj.value = (message.value || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Branch_ProductCountStatistic_CountsEntry>): Branch_ProductCountStatistic_CountsEntry {
    return Branch_ProductCountStatistic_CountsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Branch_ProductCountStatistic_CountsEntry>): Branch_ProductCountStatistic_CountsEntry {
    const message = createBaseBranch_ProductCountStatistic_CountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Long.fromValue(object.value) : Long.ZERO;
    return message;
  },
};

function createBaseBranch_QualityMetric(): Branch_QualityMetric {
  return {
    requirementKey: "",
    qualifiedProductCount: 0,
    unqualifiedProductCount: 0,
    suggestedQualityPercentThreshold: 0,
    unqualifiedSampleProducts: [],
  };
}

export const Branch_QualityMetric: MessageFns<Branch_QualityMetric> = {
  encode(message: Branch_QualityMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirementKey !== "") {
      writer.uint32(10).string(message.requirementKey);
    }
    if (message.qualifiedProductCount !== 0) {
      writer.uint32(16).int32(message.qualifiedProductCount);
    }
    if (message.unqualifiedProductCount !== 0) {
      writer.uint32(24).int32(message.unqualifiedProductCount);
    }
    if (message.suggestedQualityPercentThreshold !== 0) {
      writer.uint32(33).double(message.suggestedQualityPercentThreshold);
    }
    for (const v of message.unqualifiedSampleProducts) {
      Product.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Branch_QualityMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBranch_QualityMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requirementKey = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.qualifiedProductCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.unqualifiedProductCount = reader.int32();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.suggestedQualityPercentThreshold = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unqualifiedSampleProducts.push(Product.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Branch_QualityMetric {
    return {
      requirementKey: isSet(object.requirementKey) ? globalThis.String(object.requirementKey) : "",
      qualifiedProductCount: isSet(object.qualifiedProductCount) ? globalThis.Number(object.qualifiedProductCount) : 0,
      unqualifiedProductCount: isSet(object.unqualifiedProductCount)
        ? globalThis.Number(object.unqualifiedProductCount)
        : 0,
      suggestedQualityPercentThreshold: isSet(object.suggestedQualityPercentThreshold)
        ? globalThis.Number(object.suggestedQualityPercentThreshold)
        : 0,
      unqualifiedSampleProducts: globalThis.Array.isArray(object?.unqualifiedSampleProducts)
        ? object.unqualifiedSampleProducts.map((e: any) => Product.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Branch_QualityMetric): unknown {
    const obj: any = {};
    if (message.requirementKey !== "") {
      obj.requirementKey = message.requirementKey;
    }
    if (message.qualifiedProductCount !== 0) {
      obj.qualifiedProductCount = Math.round(message.qualifiedProductCount);
    }
    if (message.unqualifiedProductCount !== 0) {
      obj.unqualifiedProductCount = Math.round(message.unqualifiedProductCount);
    }
    if (message.suggestedQualityPercentThreshold !== 0) {
      obj.suggestedQualityPercentThreshold = message.suggestedQualityPercentThreshold;
    }
    if (message.unqualifiedSampleProducts?.length) {
      obj.unqualifiedSampleProducts = message.unqualifiedSampleProducts.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Branch_QualityMetric>): Branch_QualityMetric {
    return Branch_QualityMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Branch_QualityMetric>): Branch_QualityMetric {
    const message = createBaseBranch_QualityMetric();
    message.requirementKey = object.requirementKey ?? "";
    message.qualifiedProductCount = object.qualifiedProductCount ?? 0;
    message.unqualifiedProductCount = object.unqualifiedProductCount ?? 0;
    message.suggestedQualityPercentThreshold = object.suggestedQualityPercentThreshold ?? 0;
    message.unqualifiedSampleProducts = object.unqualifiedSampleProducts?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
