// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/cloudcontrolspartner/v1beta/access_approval_requests.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.cloudcontrolspartner.v1beta";

/** Details about the Access request. */
export interface AccessApprovalRequest {
  /**
   * Identifier. Format:
   * `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}/accessApprovalRequests/{access_approval_request}`
   */
  name: string;
  /** The time at which approval was requested. */
  requestTime:
    | Date
    | undefined;
  /** The justification for which approval is being requested. */
  requestedReason:
    | AccessReason
    | undefined;
  /**
   * The requested expiration for the approval. If the request is approved,
   * access will be granted from the time of approval until the expiration time.
   */
  requestedExpirationTime: Date | undefined;
}

/** Request for getting the access requests associated with a workload. */
export interface ListAccessApprovalRequestsRequest {
  /**
   * Required. Parent resource
   * Format:
   * `organizations/{organization}/locations/{location}/customers/{customer}/workloads/{workload}`
   */
  parent: string;
  /**
   * Optional. The maximum number of access requests to return. The service may
   * return fewer than this value. If unspecified, at most 500 access requests
   * will be returned.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `ListAccessApprovalRequests` call. Provide this to retrieve the subsequent
   * page.
   */
  pageToken: string;
  /** Optional. Filtering results. */
  filter: string;
  /** Optional. Hint for how to order the results. */
  orderBy: string;
}

/** Response message for list access requests. */
export interface ListAccessApprovalRequestsResponse {
  /** List of access approval requests */
  accessApprovalRequests: AccessApprovalRequest[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Reason for the access. */
export interface AccessReason {
  /** Type of access justification. */
  type: AccessReason_Type;
  /** More detail about certain reason types. See comments for each type above. */
  detail: string;
}

/** Type of access justification. */
export enum AccessReason_Type {
  /** TYPE_UNSPECIFIED - Default value for proto, shouldn't be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * CUSTOMER_INITIATED_SUPPORT - Customer made a request or raised an issue that required the principal to
   * access customer data. `detail` is of the form ("#####" is the issue ID):
   *
   * - "Feedback Report: #####"
   * - "Case Number: #####"
   * - "Case ID: #####"
   * - "E-PIN Reference: #####"
   * - "Google-#####"
   * - "T-#####"
   */
  CUSTOMER_INITIATED_SUPPORT = 1,
  /**
   * GOOGLE_INITIATED_SERVICE - The principal accessed customer data in order to diagnose or resolve a
   * suspected issue in services. Often this access is used to confirm that
   * customers are not affected by a suspected service issue or to remediate a
   * reversible system issue.
   */
  GOOGLE_INITIATED_SERVICE = 2,
  /**
   * GOOGLE_INITIATED_REVIEW - Google initiated service for security, fraud, abuse, or compliance
   * purposes.
   */
  GOOGLE_INITIATED_REVIEW = 3,
  /**
   * THIRD_PARTY_DATA_REQUEST - The principal was compelled to access customer data in order to respond
   * to a legal third party data request or process, including legal processes
   * from customers themselves.
   */
  THIRD_PARTY_DATA_REQUEST = 4,
  /**
   * GOOGLE_RESPONSE_TO_PRODUCTION_ALERT - The principal accessed customer data in order to diagnose or resolve a
   * suspected issue in services or a known outage.
   */
  GOOGLE_RESPONSE_TO_PRODUCTION_ALERT = 5,
  /**
   * CLOUD_INITIATED_ACCESS - Similar to 'GOOGLE_INITIATED_SERVICE' or 'GOOGLE_INITIATED_REVIEW', but
   * with universe agnostic naming. The principal accessed customer data in
   * order to diagnose or resolve a suspected issue in services or a known
   * outage, or for security, fraud, abuse, or compliance review purposes.
   */
  CLOUD_INITIATED_ACCESS = 6,
  UNRECOGNIZED = -1,
}

export function accessReason_TypeFromJSON(object: any): AccessReason_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AccessReason_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CUSTOMER_INITIATED_SUPPORT":
      return AccessReason_Type.CUSTOMER_INITIATED_SUPPORT;
    case 2:
    case "GOOGLE_INITIATED_SERVICE":
      return AccessReason_Type.GOOGLE_INITIATED_SERVICE;
    case 3:
    case "GOOGLE_INITIATED_REVIEW":
      return AccessReason_Type.GOOGLE_INITIATED_REVIEW;
    case 4:
    case "THIRD_PARTY_DATA_REQUEST":
      return AccessReason_Type.THIRD_PARTY_DATA_REQUEST;
    case 5:
    case "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT":
      return AccessReason_Type.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT;
    case 6:
    case "CLOUD_INITIATED_ACCESS":
      return AccessReason_Type.CLOUD_INITIATED_ACCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessReason_Type.UNRECOGNIZED;
  }
}

export function accessReason_TypeToJSON(object: AccessReason_Type): string {
  switch (object) {
    case AccessReason_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AccessReason_Type.CUSTOMER_INITIATED_SUPPORT:
      return "CUSTOMER_INITIATED_SUPPORT";
    case AccessReason_Type.GOOGLE_INITIATED_SERVICE:
      return "GOOGLE_INITIATED_SERVICE";
    case AccessReason_Type.GOOGLE_INITIATED_REVIEW:
      return "GOOGLE_INITIATED_REVIEW";
    case AccessReason_Type.THIRD_PARTY_DATA_REQUEST:
      return "THIRD_PARTY_DATA_REQUEST";
    case AccessReason_Type.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT:
      return "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT";
    case AccessReason_Type.CLOUD_INITIATED_ACCESS:
      return "CLOUD_INITIATED_ACCESS";
    case AccessReason_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAccessApprovalRequest(): AccessApprovalRequest {
  return { name: "", requestTime: undefined, requestedReason: undefined, requestedExpirationTime: undefined };
}

export const AccessApprovalRequest: MessageFns<AccessApprovalRequest> = {
  encode(message: AccessApprovalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestTime !== undefined) {
      Timestamp.encode(toTimestamp(message.requestTime), writer.uint32(18).fork()).join();
    }
    if (message.requestedReason !== undefined) {
      AccessReason.encode(message.requestedReason, writer.uint32(26).fork()).join();
    }
    if (message.requestedExpirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.requestedExpirationTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessApprovalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestedReason = AccessReason.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestedExpirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessApprovalRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestTime: isSet(object.requestTime) ? fromJsonTimestamp(object.requestTime) : undefined,
      requestedReason: isSet(object.requestedReason) ? AccessReason.fromJSON(object.requestedReason) : undefined,
      requestedExpirationTime: isSet(object.requestedExpirationTime)
        ? fromJsonTimestamp(object.requestedExpirationTime)
        : undefined,
    };
  },

  toJSON(message: AccessApprovalRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestTime !== undefined) {
      obj.requestTime = message.requestTime.toISOString();
    }
    if (message.requestedReason !== undefined) {
      obj.requestedReason = AccessReason.toJSON(message.requestedReason);
    }
    if (message.requestedExpirationTime !== undefined) {
      obj.requestedExpirationTime = message.requestedExpirationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AccessApprovalRequest>): AccessApprovalRequest {
    return AccessApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessApprovalRequest>): AccessApprovalRequest {
    const message = createBaseAccessApprovalRequest();
    message.name = object.name ?? "";
    message.requestTime = object.requestTime ?? undefined;
    message.requestedReason = (object.requestedReason !== undefined && object.requestedReason !== null)
      ? AccessReason.fromPartial(object.requestedReason)
      : undefined;
    message.requestedExpirationTime = object.requestedExpirationTime ?? undefined;
    return message;
  },
};

function createBaseListAccessApprovalRequestsRequest(): ListAccessApprovalRequestsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAccessApprovalRequestsRequest: MessageFns<ListAccessApprovalRequestsRequest> = {
  encode(message: ListAccessApprovalRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccessApprovalRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccessApprovalRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccessApprovalRequestsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAccessApprovalRequestsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccessApprovalRequestsRequest>): ListAccessApprovalRequestsRequest {
    return ListAccessApprovalRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccessApprovalRequestsRequest>): ListAccessApprovalRequestsRequest {
    const message = createBaseListAccessApprovalRequestsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAccessApprovalRequestsResponse(): ListAccessApprovalRequestsResponse {
  return { accessApprovalRequests: [], nextPageToken: "", unreachable: [] };
}

export const ListAccessApprovalRequestsResponse: MessageFns<ListAccessApprovalRequestsResponse> = {
  encode(message: ListAccessApprovalRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accessApprovalRequests) {
      AccessApprovalRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccessApprovalRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccessApprovalRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessApprovalRequests.push(AccessApprovalRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccessApprovalRequestsResponse {
    return {
      accessApprovalRequests: globalThis.Array.isArray(object?.accessApprovalRequests)
        ? object.accessApprovalRequests.map((e: any) => AccessApprovalRequest.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAccessApprovalRequestsResponse): unknown {
    const obj: any = {};
    if (message.accessApprovalRequests?.length) {
      obj.accessApprovalRequests = message.accessApprovalRequests.map((e) => AccessApprovalRequest.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccessApprovalRequestsResponse>): ListAccessApprovalRequestsResponse {
    return ListAccessApprovalRequestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccessApprovalRequestsResponse>): ListAccessApprovalRequestsResponse {
    const message = createBaseListAccessApprovalRequestsResponse();
    message.accessApprovalRequests = object.accessApprovalRequests?.map((e) => AccessApprovalRequest.fromPartial(e)) ||
      [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseAccessReason(): AccessReason {
  return { type: 0, detail: "" };
}

export const AccessReason: MessageFns<AccessReason> = {
  encode(message: AccessReason, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessReason {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessReason();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessReason {
    return {
      type: isSet(object.type) ? accessReason_TypeFromJSON(object.type) : 0,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: AccessReason): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = accessReason_TypeToJSON(message.type);
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessReason>): AccessReason {
    return AccessReason.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessReason>): AccessReason {
    const message = createBaseAccessReason();
    message.type = object.type ?? 0;
    message.detail = object.detail ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
