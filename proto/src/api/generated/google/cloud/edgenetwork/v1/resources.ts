// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/edgenetwork/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.edgenetwork.v1";

/**
 * ResourceState describes the state the resource.
 * A normal lifecycle of a new resource being created would be: PENDING ->
 * PROVISIONING -> RUNNING. A normal lifecycle of an existing resource being
 * deleted would be: RUNNING -> DELETING. Any failures during processing will
 * result the resource to be in a SUSPENDED state.
 */
export enum ResourceState {
  /** STATE_UNKNOWN - Unspecified state. */
  STATE_UNKNOWN = 0,
  /** STATE_PENDING - The resource is being prepared to be applied to the rack. */
  STATE_PENDING = 1,
  /** STATE_PROVISIONING - The resource has started being applied to the rack. */
  STATE_PROVISIONING = 2,
  /** STATE_RUNNING - The resource has been pushed to the rack. */
  STATE_RUNNING = 3,
  /** STATE_SUSPENDED - The resource failed to push to the rack. */
  STATE_SUSPENDED = 4,
  /** STATE_DELETING - The resource is under deletion. */
  STATE_DELETING = 5,
  UNRECOGNIZED = -1,
}

export function resourceStateFromJSON(object: any): ResourceState {
  switch (object) {
    case 0:
    case "STATE_UNKNOWN":
      return ResourceState.STATE_UNKNOWN;
    case 1:
    case "STATE_PENDING":
      return ResourceState.STATE_PENDING;
    case 2:
    case "STATE_PROVISIONING":
      return ResourceState.STATE_PROVISIONING;
    case 3:
    case "STATE_RUNNING":
      return ResourceState.STATE_RUNNING;
    case 4:
    case "STATE_SUSPENDED":
      return ResourceState.STATE_SUSPENDED;
    case 5:
    case "STATE_DELETING":
      return ResourceState.STATE_DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceState.UNRECOGNIZED;
  }
}

export function resourceStateToJSON(object: ResourceState): string {
  switch (object) {
    case ResourceState.STATE_UNKNOWN:
      return "STATE_UNKNOWN";
    case ResourceState.STATE_PENDING:
      return "STATE_PENDING";
    case ResourceState.STATE_PROVISIONING:
      return "STATE_PROVISIONING";
    case ResourceState.STATE_RUNNING:
      return "STATE_RUNNING";
    case ResourceState.STATE_SUSPENDED:
      return "STATE_SUSPENDED";
    case ResourceState.STATE_DELETING:
      return "STATE_DELETING";
    case ResourceState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Google Edge Cloud zone. */
export interface Zone {
  /** Required. The resource name of the zone. */
  name: string;
  /** Output only. The time when the zone was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the zone was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Deprecated: not implemented.
   * Labels as key value pairs.
   *
   * @deprecated
   */
  labels: { [key: string]: string };
  /**
   * Deprecated: not implemented.
   * The deployment layout type.
   *
   * @deprecated
   */
  layoutName: string;
}

export interface Zone_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing Network object */
export interface Network {
  /** Required. The canonical resource name of the network. */
  name: string;
  /** Output only. The time when the network was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the network was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * IP (L3) MTU value of the network.
   * Valid values are: 1500 and 9000.
   * Default to 1500 if not set.
   */
  mtu: number;
}

export interface Network_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing Subnet object */
export interface Subnet {
  /** Required. The canonical resource name of the subnet. */
  name: string;
  /** Output only. The time when the subnet was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the subnet was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /** Required. The network that this subnetwork belongs to. */
  network: string;
  /** The ranges of ipv4 addresses that are owned by this subnetwork. */
  ipv4Cidr: string[];
  /** The ranges of ipv6 addresses that are owned by this subnetwork. */
  ipv6Cidr: string[];
  /**
   * Optional. VLAN id provided by user. If not specified we assign one
   * automatically.
   */
  vlanId: number;
  /**
   * Optional. A bonding type in the subnet creation specifies whether a VLAN
   * being created will be present on Bonded or Non-Bonded or Both port types.
   * In addition, this flag is to be used to set the specific network
   * configuration which clusters can then use for their workloads based on the
   * bonding choice.
   */
  bondingType: Subnet_BondingType;
  /** Output only. Current stage of the resource to the device by config push. */
  state: ResourceState;
}

/** Bonding type in the subnet. */
export enum Subnet_BondingType {
  /**
   * BONDING_TYPE_UNSPECIFIED - Unspecified
   * Bonding type will be unspecified by default and if the user chooses to
   * not specify a bonding type at time of creating the VLAN. This will be
   * treated as mixed bonding where the VLAN will have both bonded and
   * non-bonded connectivity to machines.
   */
  BONDING_TYPE_UNSPECIFIED = 0,
  /** BONDED - Multi homed. */
  BONDED = 1,
  /** NON_BONDED - Single homed. */
  NON_BONDED = 2,
  UNRECOGNIZED = -1,
}

export function subnet_BondingTypeFromJSON(object: any): Subnet_BondingType {
  switch (object) {
    case 0:
    case "BONDING_TYPE_UNSPECIFIED":
      return Subnet_BondingType.BONDING_TYPE_UNSPECIFIED;
    case 1:
    case "BONDED":
      return Subnet_BondingType.BONDED;
    case 2:
    case "NON_BONDED":
      return Subnet_BondingType.NON_BONDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subnet_BondingType.UNRECOGNIZED;
  }
}

export function subnet_BondingTypeToJSON(object: Subnet_BondingType): string {
  switch (object) {
    case Subnet_BondingType.BONDING_TYPE_UNSPECIFIED:
      return "BONDING_TYPE_UNSPECIFIED";
    case Subnet_BondingType.BONDED:
      return "BONDED";
    case Subnet_BondingType.NON_BONDED:
      return "NON_BONDED";
    case Subnet_BondingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Subnet_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing Interconnect object */
export interface Interconnect {
  /** Required. The canonical resource name of the interconnect. */
  name: string;
  /** Output only. The time when the subnet was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the subnet was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Optional. Type of interconnect, which takes only the value 'DEDICATED' for
   * now.
   */
  interconnectType: Interconnect_InterconnectType;
  /** Output only. Unique identifier for the link. */
  uuid: string;
  /** Output only. Cloud resource name of the switch device. */
  deviceCloudResourceName: string;
  /**
   * Output only. Physical ports (e.g., TenGigE0/0/0/1) that form the
   * interconnect.
   */
  physicalPorts: string[];
}

/** Type of interconnect. */
export enum Interconnect_InterconnectType {
  /** INTERCONNECT_TYPE_UNSPECIFIED - Unspecified. */
  INTERCONNECT_TYPE_UNSPECIFIED = 0,
  /** DEDICATED - Dedicated Interconnect. */
  DEDICATED = 1,
  UNRECOGNIZED = -1,
}

export function interconnect_InterconnectTypeFromJSON(object: any): Interconnect_InterconnectType {
  switch (object) {
    case 0:
    case "INTERCONNECT_TYPE_UNSPECIFIED":
      return Interconnect_InterconnectType.INTERCONNECT_TYPE_UNSPECIFIED;
    case 1:
    case "DEDICATED":
      return Interconnect_InterconnectType.DEDICATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Interconnect_InterconnectType.UNRECOGNIZED;
  }
}

export function interconnect_InterconnectTypeToJSON(object: Interconnect_InterconnectType): string {
  switch (object) {
    case Interconnect_InterconnectType.INTERCONNECT_TYPE_UNSPECIFIED:
      return "INTERCONNECT_TYPE_UNSPECIFIED";
    case Interconnect_InterconnectType.DEDICATED:
      return "DEDICATED";
    case Interconnect_InterconnectType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Interconnect_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing InterconnectAttachment object */
export interface InterconnectAttachment {
  /** Required. The canonical resource name of the interconnect attachment. */
  name: string;
  /** Output only. The time when the interconnect attachment was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the interconnect attachment was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. The canonical name of underlying Interconnect object that this
   * attachment's traffic will traverse through. The name is in the form of
   * `projects/{project}/locations/{location}/zones/{zone}/interconnects/{interconnect}`.
   */
  interconnect: string;
  /**
   * Optional. The canonical Network name in the form of
   * `projects/{project}/locations/{location}/zones/{zone}/networks/{network}`.
   */
  network: string;
  /** Required. VLAN id provided by user. Must be site-wise unique. */
  vlanId: number;
  /**
   * IP (L3) MTU value of the virtual edge cloud.
   * Valid values are: 1500 and 9000.
   * Default to 1500 if not set.
   */
  mtu: number;
  /** Output only. Current stage of the resource to the device by config push. */
  state: ResourceState;
}

export interface InterconnectAttachment_LabelsEntry {
  key: string;
  value: string;
}

/** Message describing Router object */
export interface Router {
  /** Required. The canonical resource name of the router. */
  name: string;
  /** Output only. The time when the router was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the router was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. The canonical name of the network to which this router belongs.
   * The name is in the form of
   * `projects/{project}/locations/{location}/zones/{zone}/networks/{network}`.
   */
  network: string;
  /** Router interfaces. */
  interface: Router_Interface[];
  /** BGP peers. */
  bgpPeer: Router_BgpPeer[];
  /** BGP information specific to this router. */
  bgp:
    | Router_Bgp
    | undefined;
  /** Output only. Current stage of the resource to the device by config push. */
  state: ResourceState;
  /**
   * Optional. A list of CIDRs in IP/Length format to advertise northbound as
   * static routes from this router.
   */
  routeAdvertisements: string[];
}

/**
 * Router Interface defines the GDCE zone side layer-3 information for
 * building the BGP session.
 */
export interface Router_Interface {
  /** Name of this interface entry. Unique within the Zones resource. */
  name: string;
  /** IP address and range of the interface. */
  ipv4Cidr: string;
  /** IPv6 address and range of the interface. */
  ipv6Cidr: string;
  /** The canonical name of the linked Interconnect attachment. */
  linkedInterconnectAttachment: string;
  /**
   * The canonical name of the subnetwork resource that this interface
   * belongs to.
   */
  subnetwork: string;
  /**
   * Create loopback interface in the router when specified.
   * The number of IP addresses must match the number of TOR devices.
   */
  loopbackIpAddresses: string[];
}

/**
 * BGPPeer defines the peer side layer-3 information for building the BGP
 * session.
 */
export interface Router_BgpPeer {
  /** Name of this BGP peer. Unique within the Zones resource. */
  name: string;
  /** Name of the RouterInterface the BGP peer is associated with. */
  interface: string;
  /** IP range of the interface within Google. */
  interfaceIpv4Cidr: string;
  /** IPv6 range of the interface within Google. */
  interfaceIpv6Cidr: string;
  /** IP range of the BGP interface outside Google. */
  peerIpv4Cidr: string;
  /** IPv6 range of the BGP interface outside Google. */
  peerIpv6Cidr: string;
  /**
   * Peer BGP Autonomous System Number (ASN). Each BGP interface may use
   * a different value.
   */
  peerAsn: number;
  /**
   * Output only. Local BGP Autonomous System Number (ASN).
   * This field is ST_NOT_REQUIRED because it stores private ASNs, which are
   * meaningless outside the zone in which they are being used.
   */
  localAsn: number;
}

/** BGP information specific to this router. */
export interface Router_Bgp {
  /** Locally assigned BGP ASN. */
  asn: number;
  /**
   * The interval in seconds between BGP keepalive messages that are
   * sent to the peer. Default is 20 with value between 20 and 60.
   */
  keepaliveIntervalInSeconds: number;
}

export interface Router_LabelsEntry {
  key: string;
  value: string;
}

/** LinkLayerAddress contains an IP address and corresponding link-layer address. */
export interface LinkLayerAddress {
  /** The MAC address of this neighbor. */
  macAddress: string;
  /** The IP address of this neighbor. */
  ipAddress: string;
}

/**
 * SubnetStatus contains detailed and current technical information about this
 * subnet resource.
 */
export interface SubnetStatus {
  /** The name of CCFE subnet resource. */
  name: string;
  /** BVI MAC address. */
  macAddress: string;
  /**
   * A list of LinkLayerAddress, describing the ip address and corresponding
   * link-layer address of the neighbors for this subnet.
   */
  linkLayerAddresses: LinkLayerAddress[];
}

/**
 * Diagnostics information about interconnect, contains detailed and current
 * technical information about Google's side of the connection.
 */
export interface InterconnectDiagnostics {
  /** The MAC address of the Interconnect's bundle interface. */
  macAddress: string;
  /**
   * A list of LinkLayerAddress, describing the ip address and corresponding
   * link-layer address of the neighbors for this interconnect.
   */
  linkLayerAddresses: LinkLayerAddress[];
  /**
   * A list of LinkStatus objects, used to describe the status for each link on
   * the Interconnect.
   */
  links: InterconnectDiagnostics_LinkStatus[];
}

/** Describing the status for each link on the Interconnect. */
export interface InterconnectDiagnostics_LinkStatus {
  /** The unique ID for this link assigned during turn up by Google. */
  circuitId: string;
  /** Describing the state of a LACP link. */
  lacpStatus:
    | InterconnectDiagnostics_LinkLACPStatus
    | undefined;
  /**
   * A list of LinkLLDPStatus objects, used to describe LLDP status of each
   * peer for each link on the Interconnect.
   */
  lldpStatuses: InterconnectDiagnostics_LinkLLDPStatus[];
  /** Packet counts specific statistics for this link. */
  packetCounts: InterconnectDiagnostics_PacketCounts | undefined;
}

/** Containing a collection of interface-related statistics objects. */
export interface InterconnectDiagnostics_PacketCounts {
  /** The number of packets that are delivered. */
  inboundUnicast: Long;
  /** The number of inbound packets that contained errors. */
  inboundErrors: Long;
  /**
   * The number of inbound packets that were chosen to be discarded even
   * though no errors had been detected to prevent their being deliverable.
   */
  inboundDiscards: Long;
  /** The total number of packets that are requested be transmitted. */
  outboundUnicast: Long;
  /**
   * The number of outbound packets that could not be transmitted because of
   * errors.
   */
  outboundErrors: Long;
  /**
   * The number of outbound packets that were chosen to be discarded even
   * though no errors had been detected to prevent their being transmitted.
   */
  outboundDiscards: Long;
}

/** Describing the status of a LACP link. */
export interface InterconnectDiagnostics_LinkLACPStatus {
  /** The state of a LACP link. */
  state: InterconnectDiagnostics_LinkLACPStatus_State;
  /** System ID of the port on Google's side of the LACP exchange. */
  googleSystemId: string;
  /** System ID of the port on the neighbor's side of the LACP exchange. */
  neighborSystemId: string;
  /**
   * A true value indicates that the participant will allow the link to be
   * used as part of the aggregate.
   * A false value indicates the link should be used as an individual link.
   */
  aggregatable: boolean;
  /**
   * If true, the participant is collecting incoming frames on the link,
   * otherwise false
   */
  collecting: boolean;
  /**
   * When true, the participant is distributing outgoing frames; when false,
   * distribution is disabled
   */
  distributing: boolean;
}

/** State enum for LACP link. */
export enum InterconnectDiagnostics_LinkLACPStatus_State {
  /** UNKNOWN - The default state indicating state is in unknown state. */
  UNKNOWN = 0,
  /** ACTIVE - The link is configured and active within the bundle. */
  ACTIVE = 1,
  /**
   * DETACHED - The link is not configured within the bundle, this means the rest of
   * the object should be empty.
   */
  DETACHED = 2,
  UNRECOGNIZED = -1,
}

export function interconnectDiagnostics_LinkLACPStatus_StateFromJSON(
  object: any,
): InterconnectDiagnostics_LinkLACPStatus_State {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return InterconnectDiagnostics_LinkLACPStatus_State.UNKNOWN;
    case 1:
    case "ACTIVE":
      return InterconnectDiagnostics_LinkLACPStatus_State.ACTIVE;
    case 2:
    case "DETACHED":
      return InterconnectDiagnostics_LinkLACPStatus_State.DETACHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InterconnectDiagnostics_LinkLACPStatus_State.UNRECOGNIZED;
  }
}

export function interconnectDiagnostics_LinkLACPStatus_StateToJSON(
  object: InterconnectDiagnostics_LinkLACPStatus_State,
): string {
  switch (object) {
    case InterconnectDiagnostics_LinkLACPStatus_State.UNKNOWN:
      return "UNKNOWN";
    case InterconnectDiagnostics_LinkLACPStatus_State.ACTIVE:
      return "ACTIVE";
    case InterconnectDiagnostics_LinkLACPStatus_State.DETACHED:
      return "DETACHED";
    case InterconnectDiagnostics_LinkLACPStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describing a LLDP link. */
export interface InterconnectDiagnostics_LinkLLDPStatus {
  /** The peer system's administratively assigned name. */
  peerSystemName: string;
  /** The textual description of the network entity of LLDP peer. */
  peerSystemDescription: string;
  /**
   * The peer chassis component of the endpoint identifier associated with the
   * transmitting LLDP agent.
   */
  peerChassisId: string;
  /** The format and source of the peer chassis identifier string. */
  peerChassisIdType: string;
  /**
   * The port component of the endpoint identifier associated with the
   * transmitting LLDP agent. If the specified port is an IEEE 802.3 Repeater
   * port, then this TLV is optional.
   */
  peerPortId: string;
  /** The format and source of the peer port identifier string. */
  peerPortIdType: string;
}

/** Describing the current status of a router. */
export interface RouterStatus {
  /** The canonical name of the network to which this router belongs. */
  network: string;
  /**
   * A list of BgpPeerStatus objects, describing all BGP peers related to this
   * router.
   */
  bgpPeerStatus: RouterStatus_BgpPeerStatus[];
}

/** Status of a BGP peer. */
export interface RouterStatus_BgpPeerStatus {
  /** Name of this BGP peer. Unique within the Routers resource. */
  name: string;
  /** IP address of the local BGP interface. */
  ipAddress: string;
  /** IP address of the remote BGP interface. */
  peerIpAddress: string;
  /** The current status of BGP. */
  status: RouterStatus_BgpPeerStatus_BgpStatus;
  /** BGP state as specified in RFC1771. */
  state: string;
  /**
   * Time this session has been up.
   * Format:
   *  14 years, 51 weeks, 6 days, 23 hours, 59 minutes, 59 seconds
   */
  uptime: string;
  /** Time this session has been up, in seconds. */
  uptimeSeconds: Long;
  /** A collection of counts for prefixes. */
  prefixCounter: RouterStatus_PrefixCounter | undefined;
}

/** Status of the BGP peer: {UP, DOWN} */
export enum RouterStatus_BgpPeerStatus_BgpStatus {
  /** UNKNOWN - The default status indicating BGP session is in unknown state. */
  UNKNOWN = 0,
  /** UP - The UP status indicating BGP session is established. */
  UP = 1,
  /** DOWN - The DOWN state indicating BGP session is not established yet. */
  DOWN = 2,
  UNRECOGNIZED = -1,
}

export function routerStatus_BgpPeerStatus_BgpStatusFromJSON(object: any): RouterStatus_BgpPeerStatus_BgpStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return RouterStatus_BgpPeerStatus_BgpStatus.UNKNOWN;
    case 1:
    case "UP":
      return RouterStatus_BgpPeerStatus_BgpStatus.UP;
    case 2:
    case "DOWN":
      return RouterStatus_BgpPeerStatus_BgpStatus.DOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouterStatus_BgpPeerStatus_BgpStatus.UNRECOGNIZED;
  }
}

export function routerStatus_BgpPeerStatus_BgpStatusToJSON(object: RouterStatus_BgpPeerStatus_BgpStatus): string {
  switch (object) {
    case RouterStatus_BgpPeerStatus_BgpStatus.UNKNOWN:
      return "UNKNOWN";
    case RouterStatus_BgpPeerStatus_BgpStatus.UP:
      return "UP";
    case RouterStatus_BgpPeerStatus_BgpStatus.DOWN:
      return "DOWN";
    case RouterStatus_BgpPeerStatus_BgpStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PrefixCounter contains a collection of prefixes related counts. */
export interface RouterStatus_PrefixCounter {
  /** Number of prefixes advertised. */
  advertised: Long;
  /** Number of prefixes denied. */
  denied: Long;
  /** Number of prefixes received. */
  received: Long;
  /** Number of prefixes sent. */
  sent: Long;
  /** Number of prefixes suppressed. */
  suppressed: Long;
  /** Number of prefixes withdrawn. */
  withdrawn: Long;
}

function createBaseZone(): Zone {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, layoutName: "" };
}

export const Zone: MessageFns<Zone> = {
  encode(message: Zone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Zone_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.layoutName !== "") {
      writer.uint32(42).string(message.layoutName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Zone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Zone_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.layoutName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Zone {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      layoutName: isSet(object.layoutName) ? globalThis.String(object.layoutName) : "",
    };
  },

  toJSON(message: Zone): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.layoutName !== "") {
      obj.layoutName = message.layoutName;
    }
    return obj;
  },

  create(base?: DeepPartial<Zone>): Zone {
    return Zone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Zone>): Zone {
    const message = createBaseZone();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.layoutName = object.layoutName ?? "";
    return message;
  },
};

function createBaseZone_LabelsEntry(): Zone_LabelsEntry {
  return { key: "", value: "" };
}

export const Zone_LabelsEntry: MessageFns<Zone_LabelsEntry> = {
  encode(message: Zone_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Zone_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZone_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Zone_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Zone_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Zone_LabelsEntry>): Zone_LabelsEntry {
    return Zone_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Zone_LabelsEntry>): Zone_LabelsEntry {
    const message = createBaseZone_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNetwork(): Network {
  return { name: "", createTime: undefined, updateTime: undefined, labels: {}, description: "", mtu: 0 };
}

export const Network: MessageFns<Network> = {
  encode(message: Network, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Network_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.mtu !== 0) {
      writer.uint32(48).int32(message.mtu);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Network_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.mtu = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      mtu: isSet(object.mtu) ? globalThis.Number(object.mtu) : 0,
    };
  },

  toJSON(message: Network): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.mtu !== 0) {
      obj.mtu = Math.round(message.mtu);
    }
    return obj;
  },

  create(base?: DeepPartial<Network>): Network {
    return Network.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Network>): Network {
    const message = createBaseNetwork();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.mtu = object.mtu ?? 0;
    return message;
  },
};

function createBaseNetwork_LabelsEntry(): Network_LabelsEntry {
  return { key: "", value: "" };
}

export const Network_LabelsEntry: MessageFns<Network_LabelsEntry> = {
  encode(message: Network_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Network_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Network_LabelsEntry>): Network_LabelsEntry {
    return Network_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Network_LabelsEntry>): Network_LabelsEntry {
    const message = createBaseNetwork_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSubnet(): Subnet {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    network: "",
    ipv4Cidr: [],
    ipv6Cidr: [],
    vlanId: 0,
    bondingType: 0,
    state: 0,
  };
}

export const Subnet: MessageFns<Subnet> = {
  encode(message: Subnet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Subnet_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    for (const v of message.ipv4Cidr) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.ipv6Cidr) {
      writer.uint32(66).string(v!);
    }
    if (message.vlanId !== 0) {
      writer.uint32(72).int32(message.vlanId);
    }
    if (message.bondingType !== 0) {
      writer.uint32(88).int32(message.bondingType);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subnet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubnet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Subnet_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ipv4Cidr.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ipv6Cidr.push(reader.string());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.vlanId = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.bondingType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subnet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ipv4Cidr: globalThis.Array.isArray(object?.ipv4Cidr) ? object.ipv4Cidr.map((e: any) => globalThis.String(e)) : [],
      ipv6Cidr: globalThis.Array.isArray(object?.ipv6Cidr) ? object.ipv6Cidr.map((e: any) => globalThis.String(e)) : [],
      vlanId: isSet(object.vlanId) ? globalThis.Number(object.vlanId) : 0,
      bondingType: isSet(object.bondingType) ? subnet_BondingTypeFromJSON(object.bondingType) : 0,
      state: isSet(object.state) ? resourceStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Subnet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ipv4Cidr?.length) {
      obj.ipv4Cidr = message.ipv4Cidr;
    }
    if (message.ipv6Cidr?.length) {
      obj.ipv6Cidr = message.ipv6Cidr;
    }
    if (message.vlanId !== 0) {
      obj.vlanId = Math.round(message.vlanId);
    }
    if (message.bondingType !== 0) {
      obj.bondingType = subnet_BondingTypeToJSON(message.bondingType);
    }
    if (message.state !== 0) {
      obj.state = resourceStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Subnet>): Subnet {
    return Subnet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subnet>): Subnet {
    const message = createBaseSubnet();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.network = object.network ?? "";
    message.ipv4Cidr = object.ipv4Cidr?.map((e) => e) || [];
    message.ipv6Cidr = object.ipv6Cidr?.map((e) => e) || [];
    message.vlanId = object.vlanId ?? 0;
    message.bondingType = object.bondingType ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseSubnet_LabelsEntry(): Subnet_LabelsEntry {
  return { key: "", value: "" };
}

export const Subnet_LabelsEntry: MessageFns<Subnet_LabelsEntry> = {
  encode(message: Subnet_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subnet_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubnet_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subnet_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Subnet_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Subnet_LabelsEntry>): Subnet_LabelsEntry {
    return Subnet_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subnet_LabelsEntry>): Subnet_LabelsEntry {
    const message = createBaseSubnet_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInterconnect(): Interconnect {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    interconnectType: 0,
    uuid: "",
    deviceCloudResourceName: "",
    physicalPorts: [],
  };
}

export const Interconnect: MessageFns<Interconnect> = {
  encode(message: Interconnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Interconnect_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.interconnectType !== 0) {
      writer.uint32(48).int32(message.interconnectType);
    }
    if (message.uuid !== "") {
      writer.uint32(58).string(message.uuid);
    }
    if (message.deviceCloudResourceName !== "") {
      writer.uint32(66).string(message.deviceCloudResourceName);
    }
    for (const v of message.physicalPorts) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interconnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Interconnect_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.interconnectType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deviceCloudResourceName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.physicalPorts.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interconnect {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      interconnectType: isSet(object.interconnectType)
        ? interconnect_InterconnectTypeFromJSON(object.interconnectType)
        : 0,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      deviceCloudResourceName: isSet(object.deviceCloudResourceName)
        ? globalThis.String(object.deviceCloudResourceName)
        : "",
      physicalPorts: globalThis.Array.isArray(object?.physicalPorts)
        ? object.physicalPorts.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Interconnect): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.interconnectType !== 0) {
      obj.interconnectType = interconnect_InterconnectTypeToJSON(message.interconnectType);
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.deviceCloudResourceName !== "") {
      obj.deviceCloudResourceName = message.deviceCloudResourceName;
    }
    if (message.physicalPorts?.length) {
      obj.physicalPorts = message.physicalPorts;
    }
    return obj;
  },

  create(base?: DeepPartial<Interconnect>): Interconnect {
    return Interconnect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interconnect>): Interconnect {
    const message = createBaseInterconnect();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.interconnectType = object.interconnectType ?? 0;
    message.uuid = object.uuid ?? "";
    message.deviceCloudResourceName = object.deviceCloudResourceName ?? "";
    message.physicalPorts = object.physicalPorts?.map((e) => e) || [];
    return message;
  },
};

function createBaseInterconnect_LabelsEntry(): Interconnect_LabelsEntry {
  return { key: "", value: "" };
}

export const Interconnect_LabelsEntry: MessageFns<Interconnect_LabelsEntry> = {
  encode(message: Interconnect_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Interconnect_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnect_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Interconnect_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Interconnect_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Interconnect_LabelsEntry>): Interconnect_LabelsEntry {
    return Interconnect_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Interconnect_LabelsEntry>): Interconnect_LabelsEntry {
    const message = createBaseInterconnect_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInterconnectAttachment(): InterconnectAttachment {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    interconnect: "",
    network: "",
    vlanId: 0,
    mtu: 0,
    state: 0,
  };
}

export const InterconnectAttachment: MessageFns<InterconnectAttachment> = {
  encode(message: InterconnectAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      InterconnectAttachment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.interconnect !== "") {
      writer.uint32(50).string(message.interconnect);
    }
    if (message.network !== "") {
      writer.uint32(90).string(message.network);
    }
    if (message.vlanId !== 0) {
      writer.uint32(64).int32(message.vlanId);
    }
    if (message.mtu !== 0) {
      writer.uint32(72).int32(message.mtu);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = InterconnectAttachment_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.interconnect = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.network = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.vlanId = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mtu = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectAttachment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      interconnect: isSet(object.interconnect) ? globalThis.String(object.interconnect) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      vlanId: isSet(object.vlanId) ? globalThis.Number(object.vlanId) : 0,
      mtu: isSet(object.mtu) ? globalThis.Number(object.mtu) : 0,
      state: isSet(object.state) ? resourceStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: InterconnectAttachment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.interconnect !== "") {
      obj.interconnect = message.interconnect;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.vlanId !== 0) {
      obj.vlanId = Math.round(message.vlanId);
    }
    if (message.mtu !== 0) {
      obj.mtu = Math.round(message.mtu);
    }
    if (message.state !== 0) {
      obj.state = resourceStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectAttachment>): InterconnectAttachment {
    return InterconnectAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectAttachment>): InterconnectAttachment {
    const message = createBaseInterconnectAttachment();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.interconnect = object.interconnect ?? "";
    message.network = object.network ?? "";
    message.vlanId = object.vlanId ?? 0;
    message.mtu = object.mtu ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseInterconnectAttachment_LabelsEntry(): InterconnectAttachment_LabelsEntry {
  return { key: "", value: "" };
}

export const InterconnectAttachment_LabelsEntry: MessageFns<InterconnectAttachment_LabelsEntry> = {
  encode(message: InterconnectAttachment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectAttachment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectAttachment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectAttachment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InterconnectAttachment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectAttachment_LabelsEntry>): InterconnectAttachment_LabelsEntry {
    return InterconnectAttachment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectAttachment_LabelsEntry>): InterconnectAttachment_LabelsEntry {
    const message = createBaseInterconnectAttachment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRouter(): Router {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    network: "",
    interface: [],
    bgpPeer: [],
    bgp: undefined,
    state: 0,
    routeAdvertisements: [],
  };
}

export const Router: MessageFns<Router> = {
  encode(message: Router, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Router_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    for (const v of message.interface) {
      Router_Interface.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.bgpPeer) {
      Router_BgpPeer.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.bgp !== undefined) {
      Router_Bgp.encode(message.bgp, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    for (const v of message.routeAdvertisements) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Router_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.interface.push(Router_Interface.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bgpPeer.push(Router_BgpPeer.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.bgp = Router_Bgp.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.routeAdvertisements.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      interface: globalThis.Array.isArray(object?.interface)
        ? object.interface.map((e: any) => Router_Interface.fromJSON(e))
        : [],
      bgpPeer: globalThis.Array.isArray(object?.bgpPeer)
        ? object.bgpPeer.map((e: any) => Router_BgpPeer.fromJSON(e))
        : [],
      bgp: isSet(object.bgp) ? Router_Bgp.fromJSON(object.bgp) : undefined,
      state: isSet(object.state) ? resourceStateFromJSON(object.state) : 0,
      routeAdvertisements: globalThis.Array.isArray(object?.routeAdvertisements)
        ? object.routeAdvertisements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Router): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.interface?.length) {
      obj.interface = message.interface.map((e) => Router_Interface.toJSON(e));
    }
    if (message.bgpPeer?.length) {
      obj.bgpPeer = message.bgpPeer.map((e) => Router_BgpPeer.toJSON(e));
    }
    if (message.bgp !== undefined) {
      obj.bgp = Router_Bgp.toJSON(message.bgp);
    }
    if (message.state !== 0) {
      obj.state = resourceStateToJSON(message.state);
    }
    if (message.routeAdvertisements?.length) {
      obj.routeAdvertisements = message.routeAdvertisements;
    }
    return obj;
  },

  create(base?: DeepPartial<Router>): Router {
    return Router.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Router>): Router {
    const message = createBaseRouter();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.network = object.network ?? "";
    message.interface = object.interface?.map((e) => Router_Interface.fromPartial(e)) || [];
    message.bgpPeer = object.bgpPeer?.map((e) => Router_BgpPeer.fromPartial(e)) || [];
    message.bgp = (object.bgp !== undefined && object.bgp !== null) ? Router_Bgp.fromPartial(object.bgp) : undefined;
    message.state = object.state ?? 0;
    message.routeAdvertisements = object.routeAdvertisements?.map((e) => e) || [];
    return message;
  },
};

function createBaseRouter_Interface(): Router_Interface {
  return {
    name: "",
    ipv4Cidr: "",
    ipv6Cidr: "",
    linkedInterconnectAttachment: "",
    subnetwork: "",
    loopbackIpAddresses: [],
  };
}

export const Router_Interface: MessageFns<Router_Interface> = {
  encode(message: Router_Interface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ipv4Cidr !== "") {
      writer.uint32(26).string(message.ipv4Cidr);
    }
    if (message.ipv6Cidr !== "") {
      writer.uint32(50).string(message.ipv6Cidr);
    }
    if (message.linkedInterconnectAttachment !== "") {
      writer.uint32(18).string(message.linkedInterconnectAttachment);
    }
    if (message.subnetwork !== "") {
      writer.uint32(34).string(message.subnetwork);
    }
    for (const v of message.loopbackIpAddresses) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router_Interface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter_Interface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipv4Cidr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ipv6Cidr = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.linkedInterconnectAttachment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.loopbackIpAddresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router_Interface {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ipv4Cidr: isSet(object.ipv4Cidr) ? globalThis.String(object.ipv4Cidr) : "",
      ipv6Cidr: isSet(object.ipv6Cidr) ? globalThis.String(object.ipv6Cidr) : "",
      linkedInterconnectAttachment: isSet(object.linkedInterconnectAttachment)
        ? globalThis.String(object.linkedInterconnectAttachment)
        : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      loopbackIpAddresses: globalThis.Array.isArray(object?.loopbackIpAddresses)
        ? object.loopbackIpAddresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Router_Interface): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ipv4Cidr !== "") {
      obj.ipv4Cidr = message.ipv4Cidr;
    }
    if (message.ipv6Cidr !== "") {
      obj.ipv6Cidr = message.ipv6Cidr;
    }
    if (message.linkedInterconnectAttachment !== "") {
      obj.linkedInterconnectAttachment = message.linkedInterconnectAttachment;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.loopbackIpAddresses?.length) {
      obj.loopbackIpAddresses = message.loopbackIpAddresses;
    }
    return obj;
  },

  create(base?: DeepPartial<Router_Interface>): Router_Interface {
    return Router_Interface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Router_Interface>): Router_Interface {
    const message = createBaseRouter_Interface();
    message.name = object.name ?? "";
    message.ipv4Cidr = object.ipv4Cidr ?? "";
    message.ipv6Cidr = object.ipv6Cidr ?? "";
    message.linkedInterconnectAttachment = object.linkedInterconnectAttachment ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.loopbackIpAddresses = object.loopbackIpAddresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseRouter_BgpPeer(): Router_BgpPeer {
  return {
    name: "",
    interface: "",
    interfaceIpv4Cidr: "",
    interfaceIpv6Cidr: "",
    peerIpv4Cidr: "",
    peerIpv6Cidr: "",
    peerAsn: 0,
    localAsn: 0,
  };
}

export const Router_BgpPeer: MessageFns<Router_BgpPeer> = {
  encode(message: Router_BgpPeer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.interface !== "") {
      writer.uint32(18).string(message.interface);
    }
    if (message.interfaceIpv4Cidr !== "") {
      writer.uint32(26).string(message.interfaceIpv4Cidr);
    }
    if (message.interfaceIpv6Cidr !== "") {
      writer.uint32(58).string(message.interfaceIpv6Cidr);
    }
    if (message.peerIpv4Cidr !== "") {
      writer.uint32(34).string(message.peerIpv4Cidr);
    }
    if (message.peerIpv6Cidr !== "") {
      writer.uint32(50).string(message.peerIpv6Cidr);
    }
    if (message.peerAsn !== 0) {
      writer.uint32(40).uint32(message.peerAsn);
    }
    if (message.localAsn !== 0) {
      writer.uint32(64).uint32(message.localAsn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router_BgpPeer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter_BgpPeer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interface = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interfaceIpv4Cidr = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.interfaceIpv6Cidr = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.peerIpv4Cidr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.peerIpv6Cidr = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.peerAsn = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.localAsn = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router_BgpPeer {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      interfaceIpv4Cidr: isSet(object.interfaceIpv4Cidr) ? globalThis.String(object.interfaceIpv4Cidr) : "",
      interfaceIpv6Cidr: isSet(object.interfaceIpv6Cidr) ? globalThis.String(object.interfaceIpv6Cidr) : "",
      peerIpv4Cidr: isSet(object.peerIpv4Cidr) ? globalThis.String(object.peerIpv4Cidr) : "",
      peerIpv6Cidr: isSet(object.peerIpv6Cidr) ? globalThis.String(object.peerIpv6Cidr) : "",
      peerAsn: isSet(object.peerAsn) ? globalThis.Number(object.peerAsn) : 0,
      localAsn: isSet(object.localAsn) ? globalThis.Number(object.localAsn) : 0,
    };
  },

  toJSON(message: Router_BgpPeer): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.interfaceIpv4Cidr !== "") {
      obj.interfaceIpv4Cidr = message.interfaceIpv4Cidr;
    }
    if (message.interfaceIpv6Cidr !== "") {
      obj.interfaceIpv6Cidr = message.interfaceIpv6Cidr;
    }
    if (message.peerIpv4Cidr !== "") {
      obj.peerIpv4Cidr = message.peerIpv4Cidr;
    }
    if (message.peerIpv6Cidr !== "") {
      obj.peerIpv6Cidr = message.peerIpv6Cidr;
    }
    if (message.peerAsn !== 0) {
      obj.peerAsn = Math.round(message.peerAsn);
    }
    if (message.localAsn !== 0) {
      obj.localAsn = Math.round(message.localAsn);
    }
    return obj;
  },

  create(base?: DeepPartial<Router_BgpPeer>): Router_BgpPeer {
    return Router_BgpPeer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Router_BgpPeer>): Router_BgpPeer {
    const message = createBaseRouter_BgpPeer();
    message.name = object.name ?? "";
    message.interface = object.interface ?? "";
    message.interfaceIpv4Cidr = object.interfaceIpv4Cidr ?? "";
    message.interfaceIpv6Cidr = object.interfaceIpv6Cidr ?? "";
    message.peerIpv4Cidr = object.peerIpv4Cidr ?? "";
    message.peerIpv6Cidr = object.peerIpv6Cidr ?? "";
    message.peerAsn = object.peerAsn ?? 0;
    message.localAsn = object.localAsn ?? 0;
    return message;
  },
};

function createBaseRouter_Bgp(): Router_Bgp {
  return { asn: 0, keepaliveIntervalInSeconds: 0 };
}

export const Router_Bgp: MessageFns<Router_Bgp> = {
  encode(message: Router_Bgp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asn !== 0) {
      writer.uint32(8).uint32(message.asn);
    }
    if (message.keepaliveIntervalInSeconds !== 0) {
      writer.uint32(16).uint32(message.keepaliveIntervalInSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router_Bgp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter_Bgp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.asn = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.keepaliveIntervalInSeconds = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router_Bgp {
    return {
      asn: isSet(object.asn) ? globalThis.Number(object.asn) : 0,
      keepaliveIntervalInSeconds: isSet(object.keepaliveIntervalInSeconds)
        ? globalThis.Number(object.keepaliveIntervalInSeconds)
        : 0,
    };
  },

  toJSON(message: Router_Bgp): unknown {
    const obj: any = {};
    if (message.asn !== 0) {
      obj.asn = Math.round(message.asn);
    }
    if (message.keepaliveIntervalInSeconds !== 0) {
      obj.keepaliveIntervalInSeconds = Math.round(message.keepaliveIntervalInSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<Router_Bgp>): Router_Bgp {
    return Router_Bgp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Router_Bgp>): Router_Bgp {
    const message = createBaseRouter_Bgp();
    message.asn = object.asn ?? 0;
    message.keepaliveIntervalInSeconds = object.keepaliveIntervalInSeconds ?? 0;
    return message;
  },
};

function createBaseRouter_LabelsEntry(): Router_LabelsEntry {
  return { key: "", value: "" };
}

export const Router_LabelsEntry: MessageFns<Router_LabelsEntry> = {
  encode(message: Router_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Router_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouter_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Router_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Router_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Router_LabelsEntry>): Router_LabelsEntry {
    return Router_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Router_LabelsEntry>): Router_LabelsEntry {
    const message = createBaseRouter_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLinkLayerAddress(): LinkLayerAddress {
  return { macAddress: "", ipAddress: "" };
}

export const LinkLayerAddress: MessageFns<LinkLayerAddress> = {
  encode(message: LinkLayerAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.macAddress !== "") {
      writer.uint32(10).string(message.macAddress);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkLayerAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkLayerAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.macAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkLayerAddress {
    return {
      macAddress: isSet(object.macAddress) ? globalThis.String(object.macAddress) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: LinkLayerAddress): unknown {
    const obj: any = {};
    if (message.macAddress !== "") {
      obj.macAddress = message.macAddress;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<LinkLayerAddress>): LinkLayerAddress {
    return LinkLayerAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinkLayerAddress>): LinkLayerAddress {
    const message = createBaseLinkLayerAddress();
    message.macAddress = object.macAddress ?? "";
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function createBaseSubnetStatus(): SubnetStatus {
  return { name: "", macAddress: "", linkLayerAddresses: [] };
}

export const SubnetStatus: MessageFns<SubnetStatus> = {
  encode(message: SubnetStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.macAddress !== "") {
      writer.uint32(18).string(message.macAddress);
    }
    for (const v of message.linkLayerAddresses) {
      LinkLayerAddress.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubnetStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubnetStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.macAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.linkLayerAddresses.push(LinkLayerAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubnetStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      macAddress: isSet(object.macAddress) ? globalThis.String(object.macAddress) : "",
      linkLayerAddresses: globalThis.Array.isArray(object?.linkLayerAddresses)
        ? object.linkLayerAddresses.map((e: any) => LinkLayerAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubnetStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.macAddress !== "") {
      obj.macAddress = message.macAddress;
    }
    if (message.linkLayerAddresses?.length) {
      obj.linkLayerAddresses = message.linkLayerAddresses.map((e) => LinkLayerAddress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubnetStatus>): SubnetStatus {
    return SubnetStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubnetStatus>): SubnetStatus {
    const message = createBaseSubnetStatus();
    message.name = object.name ?? "";
    message.macAddress = object.macAddress ?? "";
    message.linkLayerAddresses = object.linkLayerAddresses?.map((e) => LinkLayerAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInterconnectDiagnostics(): InterconnectDiagnostics {
  return { macAddress: "", linkLayerAddresses: [], links: [] };
}

export const InterconnectDiagnostics: MessageFns<InterconnectDiagnostics> = {
  encode(message: InterconnectDiagnostics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.macAddress !== "") {
      writer.uint32(10).string(message.macAddress);
    }
    for (const v of message.linkLayerAddresses) {
      LinkLayerAddress.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.links) {
      InterconnectDiagnostics_LinkStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectDiagnostics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectDiagnostics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.macAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.linkLayerAddresses.push(LinkLayerAddress.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.links.push(InterconnectDiagnostics_LinkStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectDiagnostics {
    return {
      macAddress: isSet(object.macAddress) ? globalThis.String(object.macAddress) : "",
      linkLayerAddresses: globalThis.Array.isArray(object?.linkLayerAddresses)
        ? object.linkLayerAddresses.map((e: any) => LinkLayerAddress.fromJSON(e))
        : [],
      links: globalThis.Array.isArray(object?.links)
        ? object.links.map((e: any) => InterconnectDiagnostics_LinkStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InterconnectDiagnostics): unknown {
    const obj: any = {};
    if (message.macAddress !== "") {
      obj.macAddress = message.macAddress;
    }
    if (message.linkLayerAddresses?.length) {
      obj.linkLayerAddresses = message.linkLayerAddresses.map((e) => LinkLayerAddress.toJSON(e));
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => InterconnectDiagnostics_LinkStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectDiagnostics>): InterconnectDiagnostics {
    return InterconnectDiagnostics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectDiagnostics>): InterconnectDiagnostics {
    const message = createBaseInterconnectDiagnostics();
    message.macAddress = object.macAddress ?? "";
    message.linkLayerAddresses = object.linkLayerAddresses?.map((e) => LinkLayerAddress.fromPartial(e)) || [];
    message.links = object.links?.map((e) => InterconnectDiagnostics_LinkStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInterconnectDiagnostics_LinkStatus(): InterconnectDiagnostics_LinkStatus {
  return { circuitId: "", lacpStatus: undefined, lldpStatuses: [], packetCounts: undefined };
}

export const InterconnectDiagnostics_LinkStatus: MessageFns<InterconnectDiagnostics_LinkStatus> = {
  encode(message: InterconnectDiagnostics_LinkStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.circuitId !== "") {
      writer.uint32(10).string(message.circuitId);
    }
    if (message.lacpStatus !== undefined) {
      InterconnectDiagnostics_LinkLACPStatus.encode(message.lacpStatus, writer.uint32(18).fork()).join();
    }
    for (const v of message.lldpStatuses) {
      InterconnectDiagnostics_LinkLLDPStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.packetCounts !== undefined) {
      InterconnectDiagnostics_PacketCounts.encode(message.packetCounts, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectDiagnostics_LinkStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectDiagnostics_LinkStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.circuitId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lacpStatus = InterconnectDiagnostics_LinkLACPStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lldpStatuses.push(InterconnectDiagnostics_LinkLLDPStatus.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.packetCounts = InterconnectDiagnostics_PacketCounts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectDiagnostics_LinkStatus {
    return {
      circuitId: isSet(object.circuitId) ? globalThis.String(object.circuitId) : "",
      lacpStatus: isSet(object.lacpStatus)
        ? InterconnectDiagnostics_LinkLACPStatus.fromJSON(object.lacpStatus)
        : undefined,
      lldpStatuses: globalThis.Array.isArray(object?.lldpStatuses)
        ? object.lldpStatuses.map((e: any) => InterconnectDiagnostics_LinkLLDPStatus.fromJSON(e))
        : [],
      packetCounts: isSet(object.packetCounts)
        ? InterconnectDiagnostics_PacketCounts.fromJSON(object.packetCounts)
        : undefined,
    };
  },

  toJSON(message: InterconnectDiagnostics_LinkStatus): unknown {
    const obj: any = {};
    if (message.circuitId !== "") {
      obj.circuitId = message.circuitId;
    }
    if (message.lacpStatus !== undefined) {
      obj.lacpStatus = InterconnectDiagnostics_LinkLACPStatus.toJSON(message.lacpStatus);
    }
    if (message.lldpStatuses?.length) {
      obj.lldpStatuses = message.lldpStatuses.map((e) => InterconnectDiagnostics_LinkLLDPStatus.toJSON(e));
    }
    if (message.packetCounts !== undefined) {
      obj.packetCounts = InterconnectDiagnostics_PacketCounts.toJSON(message.packetCounts);
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectDiagnostics_LinkStatus>): InterconnectDiagnostics_LinkStatus {
    return InterconnectDiagnostics_LinkStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectDiagnostics_LinkStatus>): InterconnectDiagnostics_LinkStatus {
    const message = createBaseInterconnectDiagnostics_LinkStatus();
    message.circuitId = object.circuitId ?? "";
    message.lacpStatus = (object.lacpStatus !== undefined && object.lacpStatus !== null)
      ? InterconnectDiagnostics_LinkLACPStatus.fromPartial(object.lacpStatus)
      : undefined;
    message.lldpStatuses = object.lldpStatuses?.map((e) => InterconnectDiagnostics_LinkLLDPStatus.fromPartial(e)) || [];
    message.packetCounts = (object.packetCounts !== undefined && object.packetCounts !== null)
      ? InterconnectDiagnostics_PacketCounts.fromPartial(object.packetCounts)
      : undefined;
    return message;
  },
};

function createBaseInterconnectDiagnostics_PacketCounts(): InterconnectDiagnostics_PacketCounts {
  return {
    inboundUnicast: Long.ZERO,
    inboundErrors: Long.ZERO,
    inboundDiscards: Long.ZERO,
    outboundUnicast: Long.ZERO,
    outboundErrors: Long.ZERO,
    outboundDiscards: Long.ZERO,
  };
}

export const InterconnectDiagnostics_PacketCounts: MessageFns<InterconnectDiagnostics_PacketCounts> = {
  encode(message: InterconnectDiagnostics_PacketCounts, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.inboundUnicast.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.inboundUnicast.toString());
    }
    if (!message.inboundErrors.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.inboundErrors.toString());
    }
    if (!message.inboundDiscards.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.inboundDiscards.toString());
    }
    if (!message.outboundUnicast.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.outboundUnicast.toString());
    }
    if (!message.outboundErrors.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.outboundErrors.toString());
    }
    if (!message.outboundDiscards.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.outboundDiscards.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectDiagnostics_PacketCounts {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectDiagnostics_PacketCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inboundUnicast = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inboundErrors = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inboundDiscards = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outboundUnicast = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outboundErrors = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.outboundDiscards = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectDiagnostics_PacketCounts {
    return {
      inboundUnicast: isSet(object.inboundUnicast) ? Long.fromValue(object.inboundUnicast) : Long.ZERO,
      inboundErrors: isSet(object.inboundErrors) ? Long.fromValue(object.inboundErrors) : Long.ZERO,
      inboundDiscards: isSet(object.inboundDiscards) ? Long.fromValue(object.inboundDiscards) : Long.ZERO,
      outboundUnicast: isSet(object.outboundUnicast) ? Long.fromValue(object.outboundUnicast) : Long.ZERO,
      outboundErrors: isSet(object.outboundErrors) ? Long.fromValue(object.outboundErrors) : Long.ZERO,
      outboundDiscards: isSet(object.outboundDiscards) ? Long.fromValue(object.outboundDiscards) : Long.ZERO,
    };
  },

  toJSON(message: InterconnectDiagnostics_PacketCounts): unknown {
    const obj: any = {};
    if (!message.inboundUnicast.equals(Long.ZERO)) {
      obj.inboundUnicast = (message.inboundUnicast || Long.ZERO).toString();
    }
    if (!message.inboundErrors.equals(Long.ZERO)) {
      obj.inboundErrors = (message.inboundErrors || Long.ZERO).toString();
    }
    if (!message.inboundDiscards.equals(Long.ZERO)) {
      obj.inboundDiscards = (message.inboundDiscards || Long.ZERO).toString();
    }
    if (!message.outboundUnicast.equals(Long.ZERO)) {
      obj.outboundUnicast = (message.outboundUnicast || Long.ZERO).toString();
    }
    if (!message.outboundErrors.equals(Long.ZERO)) {
      obj.outboundErrors = (message.outboundErrors || Long.ZERO).toString();
    }
    if (!message.outboundDiscards.equals(Long.ZERO)) {
      obj.outboundDiscards = (message.outboundDiscards || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectDiagnostics_PacketCounts>): InterconnectDiagnostics_PacketCounts {
    return InterconnectDiagnostics_PacketCounts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectDiagnostics_PacketCounts>): InterconnectDiagnostics_PacketCounts {
    const message = createBaseInterconnectDiagnostics_PacketCounts();
    message.inboundUnicast = (object.inboundUnicast !== undefined && object.inboundUnicast !== null)
      ? Long.fromValue(object.inboundUnicast)
      : Long.ZERO;
    message.inboundErrors = (object.inboundErrors !== undefined && object.inboundErrors !== null)
      ? Long.fromValue(object.inboundErrors)
      : Long.ZERO;
    message.inboundDiscards = (object.inboundDiscards !== undefined && object.inboundDiscards !== null)
      ? Long.fromValue(object.inboundDiscards)
      : Long.ZERO;
    message.outboundUnicast = (object.outboundUnicast !== undefined && object.outboundUnicast !== null)
      ? Long.fromValue(object.outboundUnicast)
      : Long.ZERO;
    message.outboundErrors = (object.outboundErrors !== undefined && object.outboundErrors !== null)
      ? Long.fromValue(object.outboundErrors)
      : Long.ZERO;
    message.outboundDiscards = (object.outboundDiscards !== undefined && object.outboundDiscards !== null)
      ? Long.fromValue(object.outboundDiscards)
      : Long.ZERO;
    return message;
  },
};

function createBaseInterconnectDiagnostics_LinkLACPStatus(): InterconnectDiagnostics_LinkLACPStatus {
  return {
    state: 0,
    googleSystemId: "",
    neighborSystemId: "",
    aggregatable: false,
    collecting: false,
    distributing: false,
  };
}

export const InterconnectDiagnostics_LinkLACPStatus: MessageFns<InterconnectDiagnostics_LinkLACPStatus> = {
  encode(message: InterconnectDiagnostics_LinkLACPStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.googleSystemId !== "") {
      writer.uint32(18).string(message.googleSystemId);
    }
    if (message.neighborSystemId !== "") {
      writer.uint32(26).string(message.neighborSystemId);
    }
    if (message.aggregatable !== false) {
      writer.uint32(32).bool(message.aggregatable);
    }
    if (message.collecting !== false) {
      writer.uint32(40).bool(message.collecting);
    }
    if (message.distributing !== false) {
      writer.uint32(48).bool(message.distributing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectDiagnostics_LinkLACPStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectDiagnostics_LinkLACPStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.googleSystemId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.neighborSystemId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.aggregatable = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.collecting = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.distributing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectDiagnostics_LinkLACPStatus {
    return {
      state: isSet(object.state) ? interconnectDiagnostics_LinkLACPStatus_StateFromJSON(object.state) : 0,
      googleSystemId: isSet(object.googleSystemId) ? globalThis.String(object.googleSystemId) : "",
      neighborSystemId: isSet(object.neighborSystemId) ? globalThis.String(object.neighborSystemId) : "",
      aggregatable: isSet(object.aggregatable) ? globalThis.Boolean(object.aggregatable) : false,
      collecting: isSet(object.collecting) ? globalThis.Boolean(object.collecting) : false,
      distributing: isSet(object.distributing) ? globalThis.Boolean(object.distributing) : false,
    };
  },

  toJSON(message: InterconnectDiagnostics_LinkLACPStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = interconnectDiagnostics_LinkLACPStatus_StateToJSON(message.state);
    }
    if (message.googleSystemId !== "") {
      obj.googleSystemId = message.googleSystemId;
    }
    if (message.neighborSystemId !== "") {
      obj.neighborSystemId = message.neighborSystemId;
    }
    if (message.aggregatable !== false) {
      obj.aggregatable = message.aggregatable;
    }
    if (message.collecting !== false) {
      obj.collecting = message.collecting;
    }
    if (message.distributing !== false) {
      obj.distributing = message.distributing;
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectDiagnostics_LinkLACPStatus>): InterconnectDiagnostics_LinkLACPStatus {
    return InterconnectDiagnostics_LinkLACPStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectDiagnostics_LinkLACPStatus>): InterconnectDiagnostics_LinkLACPStatus {
    const message = createBaseInterconnectDiagnostics_LinkLACPStatus();
    message.state = object.state ?? 0;
    message.googleSystemId = object.googleSystemId ?? "";
    message.neighborSystemId = object.neighborSystemId ?? "";
    message.aggregatable = object.aggregatable ?? false;
    message.collecting = object.collecting ?? false;
    message.distributing = object.distributing ?? false;
    return message;
  },
};

function createBaseInterconnectDiagnostics_LinkLLDPStatus(): InterconnectDiagnostics_LinkLLDPStatus {
  return {
    peerSystemName: "",
    peerSystemDescription: "",
    peerChassisId: "",
    peerChassisIdType: "",
    peerPortId: "",
    peerPortIdType: "",
  };
}

export const InterconnectDiagnostics_LinkLLDPStatus: MessageFns<InterconnectDiagnostics_LinkLLDPStatus> = {
  encode(message: InterconnectDiagnostics_LinkLLDPStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.peerSystemName !== "") {
      writer.uint32(10).string(message.peerSystemName);
    }
    if (message.peerSystemDescription !== "") {
      writer.uint32(18).string(message.peerSystemDescription);
    }
    if (message.peerChassisId !== "") {
      writer.uint32(26).string(message.peerChassisId);
    }
    if (message.peerChassisIdType !== "") {
      writer.uint32(34).string(message.peerChassisIdType);
    }
    if (message.peerPortId !== "") {
      writer.uint32(42).string(message.peerPortId);
    }
    if (message.peerPortIdType !== "") {
      writer.uint32(50).string(message.peerPortIdType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterconnectDiagnostics_LinkLLDPStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterconnectDiagnostics_LinkLLDPStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peerSystemName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.peerSystemDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.peerChassisId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.peerChassisIdType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.peerPortId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.peerPortIdType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterconnectDiagnostics_LinkLLDPStatus {
    return {
      peerSystemName: isSet(object.peerSystemName) ? globalThis.String(object.peerSystemName) : "",
      peerSystemDescription: isSet(object.peerSystemDescription) ? globalThis.String(object.peerSystemDescription) : "",
      peerChassisId: isSet(object.peerChassisId) ? globalThis.String(object.peerChassisId) : "",
      peerChassisIdType: isSet(object.peerChassisIdType) ? globalThis.String(object.peerChassisIdType) : "",
      peerPortId: isSet(object.peerPortId) ? globalThis.String(object.peerPortId) : "",
      peerPortIdType: isSet(object.peerPortIdType) ? globalThis.String(object.peerPortIdType) : "",
    };
  },

  toJSON(message: InterconnectDiagnostics_LinkLLDPStatus): unknown {
    const obj: any = {};
    if (message.peerSystemName !== "") {
      obj.peerSystemName = message.peerSystemName;
    }
    if (message.peerSystemDescription !== "") {
      obj.peerSystemDescription = message.peerSystemDescription;
    }
    if (message.peerChassisId !== "") {
      obj.peerChassisId = message.peerChassisId;
    }
    if (message.peerChassisIdType !== "") {
      obj.peerChassisIdType = message.peerChassisIdType;
    }
    if (message.peerPortId !== "") {
      obj.peerPortId = message.peerPortId;
    }
    if (message.peerPortIdType !== "") {
      obj.peerPortIdType = message.peerPortIdType;
    }
    return obj;
  },

  create(base?: DeepPartial<InterconnectDiagnostics_LinkLLDPStatus>): InterconnectDiagnostics_LinkLLDPStatus {
    return InterconnectDiagnostics_LinkLLDPStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InterconnectDiagnostics_LinkLLDPStatus>): InterconnectDiagnostics_LinkLLDPStatus {
    const message = createBaseInterconnectDiagnostics_LinkLLDPStatus();
    message.peerSystemName = object.peerSystemName ?? "";
    message.peerSystemDescription = object.peerSystemDescription ?? "";
    message.peerChassisId = object.peerChassisId ?? "";
    message.peerChassisIdType = object.peerChassisIdType ?? "";
    message.peerPortId = object.peerPortId ?? "";
    message.peerPortIdType = object.peerPortIdType ?? "";
    return message;
  },
};

function createBaseRouterStatus(): RouterStatus {
  return { network: "", bgpPeerStatus: [] };
}

export const RouterStatus: MessageFns<RouterStatus> = {
  encode(message: RouterStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    for (const v of message.bgpPeerStatus) {
      RouterStatus_BgpPeerStatus.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouterStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouterStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bgpPeerStatus.push(RouterStatus_BgpPeerStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouterStatus {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      bgpPeerStatus: globalThis.Array.isArray(object?.bgpPeerStatus)
        ? object.bgpPeerStatus.map((e: any) => RouterStatus_BgpPeerStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RouterStatus): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.bgpPeerStatus?.length) {
      obj.bgpPeerStatus = message.bgpPeerStatus.map((e) => RouterStatus_BgpPeerStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RouterStatus>): RouterStatus {
    return RouterStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouterStatus>): RouterStatus {
    const message = createBaseRouterStatus();
    message.network = object.network ?? "";
    message.bgpPeerStatus = object.bgpPeerStatus?.map((e) => RouterStatus_BgpPeerStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRouterStatus_BgpPeerStatus(): RouterStatus_BgpPeerStatus {
  return {
    name: "",
    ipAddress: "",
    peerIpAddress: "",
    status: 0,
    state: "",
    uptime: "",
    uptimeSeconds: Long.ZERO,
    prefixCounter: undefined,
  };
}

export const RouterStatus_BgpPeerStatus: MessageFns<RouterStatus_BgpPeerStatus> = {
  encode(message: RouterStatus_BgpPeerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.peerIpAddress !== "") {
      writer.uint32(26).string(message.peerIpAddress);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.uptime !== "") {
      writer.uint32(50).string(message.uptime);
    }
    if (!message.uptimeSeconds.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.uptimeSeconds.toString());
    }
    if (message.prefixCounter !== undefined) {
      RouterStatus_PrefixCounter.encode(message.prefixCounter, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouterStatus_BgpPeerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouterStatus_BgpPeerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.peerIpAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uptime = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.uptimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.prefixCounter = RouterStatus_PrefixCounter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouterStatus_BgpPeerStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      peerIpAddress: isSet(object.peerIpAddress) ? globalThis.String(object.peerIpAddress) : "",
      status: isSet(object.status) ? routerStatus_BgpPeerStatus_BgpStatusFromJSON(object.status) : 0,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      uptime: isSet(object.uptime) ? globalThis.String(object.uptime) : "",
      uptimeSeconds: isSet(object.uptimeSeconds) ? Long.fromValue(object.uptimeSeconds) : Long.ZERO,
      prefixCounter: isSet(object.prefixCounter)
        ? RouterStatus_PrefixCounter.fromJSON(object.prefixCounter)
        : undefined,
    };
  },

  toJSON(message: RouterStatus_BgpPeerStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.peerIpAddress !== "") {
      obj.peerIpAddress = message.peerIpAddress;
    }
    if (message.status !== 0) {
      obj.status = routerStatus_BgpPeerStatus_BgpStatusToJSON(message.status);
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.uptime !== "") {
      obj.uptime = message.uptime;
    }
    if (!message.uptimeSeconds.equals(Long.ZERO)) {
      obj.uptimeSeconds = (message.uptimeSeconds || Long.ZERO).toString();
    }
    if (message.prefixCounter !== undefined) {
      obj.prefixCounter = RouterStatus_PrefixCounter.toJSON(message.prefixCounter);
    }
    return obj;
  },

  create(base?: DeepPartial<RouterStatus_BgpPeerStatus>): RouterStatus_BgpPeerStatus {
    return RouterStatus_BgpPeerStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouterStatus_BgpPeerStatus>): RouterStatus_BgpPeerStatus {
    const message = createBaseRouterStatus_BgpPeerStatus();
    message.name = object.name ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.peerIpAddress = object.peerIpAddress ?? "";
    message.status = object.status ?? 0;
    message.state = object.state ?? "";
    message.uptime = object.uptime ?? "";
    message.uptimeSeconds = (object.uptimeSeconds !== undefined && object.uptimeSeconds !== null)
      ? Long.fromValue(object.uptimeSeconds)
      : Long.ZERO;
    message.prefixCounter = (object.prefixCounter !== undefined && object.prefixCounter !== null)
      ? RouterStatus_PrefixCounter.fromPartial(object.prefixCounter)
      : undefined;
    return message;
  },
};

function createBaseRouterStatus_PrefixCounter(): RouterStatus_PrefixCounter {
  return {
    advertised: Long.ZERO,
    denied: Long.ZERO,
    received: Long.ZERO,
    sent: Long.ZERO,
    suppressed: Long.ZERO,
    withdrawn: Long.ZERO,
  };
}

export const RouterStatus_PrefixCounter: MessageFns<RouterStatus_PrefixCounter> = {
  encode(message: RouterStatus_PrefixCounter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.advertised.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.advertised.toString());
    }
    if (!message.denied.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.denied.toString());
    }
    if (!message.received.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.received.toString());
    }
    if (!message.sent.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.sent.toString());
    }
    if (!message.suppressed.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.suppressed.toString());
    }
    if (!message.withdrawn.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.withdrawn.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouterStatus_PrefixCounter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouterStatus_PrefixCounter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.advertised = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.denied = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.received = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sent = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.suppressed = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.withdrawn = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouterStatus_PrefixCounter {
    return {
      advertised: isSet(object.advertised) ? Long.fromValue(object.advertised) : Long.ZERO,
      denied: isSet(object.denied) ? Long.fromValue(object.denied) : Long.ZERO,
      received: isSet(object.received) ? Long.fromValue(object.received) : Long.ZERO,
      sent: isSet(object.sent) ? Long.fromValue(object.sent) : Long.ZERO,
      suppressed: isSet(object.suppressed) ? Long.fromValue(object.suppressed) : Long.ZERO,
      withdrawn: isSet(object.withdrawn) ? Long.fromValue(object.withdrawn) : Long.ZERO,
    };
  },

  toJSON(message: RouterStatus_PrefixCounter): unknown {
    const obj: any = {};
    if (!message.advertised.equals(Long.ZERO)) {
      obj.advertised = (message.advertised || Long.ZERO).toString();
    }
    if (!message.denied.equals(Long.ZERO)) {
      obj.denied = (message.denied || Long.ZERO).toString();
    }
    if (!message.received.equals(Long.ZERO)) {
      obj.received = (message.received || Long.ZERO).toString();
    }
    if (!message.sent.equals(Long.ZERO)) {
      obj.sent = (message.sent || Long.ZERO).toString();
    }
    if (!message.suppressed.equals(Long.ZERO)) {
      obj.suppressed = (message.suppressed || Long.ZERO).toString();
    }
    if (!message.withdrawn.equals(Long.ZERO)) {
      obj.withdrawn = (message.withdrawn || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<RouterStatus_PrefixCounter>): RouterStatus_PrefixCounter {
    return RouterStatus_PrefixCounter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouterStatus_PrefixCounter>): RouterStatus_PrefixCounter {
    const message = createBaseRouterStatus_PrefixCounter();
    message.advertised = (object.advertised !== undefined && object.advertised !== null)
      ? Long.fromValue(object.advertised)
      : Long.ZERO;
    message.denied = (object.denied !== undefined && object.denied !== null)
      ? Long.fromValue(object.denied)
      : Long.ZERO;
    message.received = (object.received !== undefined && object.received !== null)
      ? Long.fromValue(object.received)
      : Long.ZERO;
    message.sent = (object.sent !== undefined && object.sent !== null) ? Long.fromValue(object.sent) : Long.ZERO;
    message.suppressed = (object.suppressed !== undefined && object.suppressed !== null)
      ? Long.fromValue(object.suppressed)
      : Long.ZERO;
    message.withdrawn = (object.withdrawn !== undefined && object.withdrawn !== null)
      ? Long.fromValue(object.withdrawn)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
