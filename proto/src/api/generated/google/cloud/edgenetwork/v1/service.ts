// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/edgenetwork/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  Interconnect,
  InterconnectAttachment,
  InterconnectDiagnostics,
  Network,
  Router,
  RouterStatus,
  Subnet,
  SubnetStatus,
  Zone,
} from "./resources.js";

export const protobufPackage = "google.cloud.edgenetwork.v1";

/**
 * Deprecated: not implemented.
 * Message for requesting list of Zones
 *
 * @deprecated
 */
export interface ListZonesRequest {
  /** Required. Parent value for ListZonesRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/**
 * Deprecated: not implemented.
 * Message for response to listing Zones
 *
 * @deprecated
 */
export interface ListZonesResponse {
  /** The list of Zone */
  zones: Zone[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/**
 * Deprecated: not implemented.
 * Message for getting a Zone
 *
 * @deprecated
 */
export interface GetZoneRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for requesting list of Networks */
export interface ListNetworksRequest {
  /** Required. Parent value for ListNetworksRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing Networks */
export interface ListNetworksResponse {
  /** The list of Network */
  networks: Network[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Network */
export interface GetNetworkRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a Network */
export interface CreateNetworkRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * network_id from the method_signature of Create RPC
   */
  networkId: string;
  /** Required. The resource being created */
  network:
    | Network
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a Network */
export interface DeleteNetworkRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for requesting list of Subnets */
export interface ListSubnetsRequest {
  /** Required. Parent value for ListSubnetsRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing Subnets */
export interface ListSubnetsResponse {
  /** The list of Subnet */
  subnets: Subnet[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Subnet */
export interface GetSubnetRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a Subnet */
export interface CreateSubnetRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * subnet_id from the method_signature of Create RPC
   */
  subnetId: string;
  /** Required. The resource being created */
  subnet:
    | Subnet
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating a Subnet */
export interface UpdateSubnetRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Subnet resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  subnet:
    | Subnet
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a Subnet */
export interface DeleteSubnetRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for requesting list of Interconnects */
export interface ListInterconnectsRequest {
  /** Required. Parent value for ListInterconnectsRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing Interconnects */
export interface ListInterconnectsResponse {
  /** The list of Interconnect */
  interconnects: Interconnect[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Interconnect */
export interface GetInterconnectRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for requesting list of InterconnectAttachments */
export interface ListInterconnectAttachmentsRequest {
  /** Required. Parent value for ListInterconnectAttachmentsRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing InterconnectAttachments */
export interface ListInterconnectAttachmentsResponse {
  /** The list of InterconnectAttachment */
  interconnectAttachments: InterconnectAttachment[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a InterconnectAttachment */
export interface GetInterconnectAttachmentRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a InterconnectAttachment */
export interface CreateInterconnectAttachmentRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * interconnect_attachment_id from the method_signature of Create RPC
   */
  interconnectAttachmentId: string;
  /** Required. The resource being created */
  interconnectAttachment:
    | InterconnectAttachment
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a InterconnectAttachment */
export interface DeleteInterconnectAttachmentRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for requesting list of Routers */
export interface ListRoutersRequest {
  /** Required. Parent value for ListRoutersRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing Routers */
export interface ListRoutersResponse {
  /** The list of Router */
  routers: Router[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Router */
export interface GetRouterRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a Router */
export interface CreateRouterRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * router_id from the method_signature of Create RPC
   */
  routerId: string;
  /** Required. The resource being created */
  router:
    | Router
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for updating a Router */
export interface UpdateRouterRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Router resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  router:
    | Router
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a Router */
export interface DeleteRouterRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** Message for requesting the diagnostics of a network within a specific zone. */
export interface DiagnoseNetworkRequest {
  /** Required. The name of the network resource. */
  name: string;
}

/** DiagnoseNetworkResponse contains the current status for a specific network. */
export interface DiagnoseNetworkResponse {
  /** The time when the network status was last updated. */
  updateTime:
    | Date
    | undefined;
  /** The network status of a specific network. */
  result: DiagnoseNetworkResponse_NetworkStatus | undefined;
}

/**
 * NetworkStatus has a list of status for the subnets under the current
 * network.
 */
export interface DiagnoseNetworkResponse_NetworkStatus {
  /** A list of status for the subnets under the current network. */
  subnetStatus: SubnetStatus[];
  /** The MACsec status of internal links. */
  macsecStatusInternalLinks: DiagnoseNetworkResponse_NetworkStatus_MacsecStatus;
}

/** Denotes the status of MACsec sessions for the links of a zone. */
export enum DiagnoseNetworkResponse_NetworkStatus_MacsecStatus {
  /** MACSEC_STATUS_UNSPECIFIED - MACsec status not specified, likely due to missing metrics. */
  MACSEC_STATUS_UNSPECIFIED = 0,
  /** SECURE - All relevant links have at least one MACsec session up. */
  SECURE = 1,
  /** UNSECURE - At least one relevant link does not have any MACsec sessions up. */
  UNSECURE = 2,
  UNRECOGNIZED = -1,
}

export function diagnoseNetworkResponse_NetworkStatus_MacsecStatusFromJSON(
  object: any,
): DiagnoseNetworkResponse_NetworkStatus_MacsecStatus {
  switch (object) {
    case 0:
    case "MACSEC_STATUS_UNSPECIFIED":
      return DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.MACSEC_STATUS_UNSPECIFIED;
    case 1:
    case "SECURE":
      return DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.SECURE;
    case 2:
    case "UNSECURE":
      return DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.UNSECURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.UNRECOGNIZED;
  }
}

export function diagnoseNetworkResponse_NetworkStatus_MacsecStatusToJSON(
  object: DiagnoseNetworkResponse_NetworkStatus_MacsecStatus,
): string {
  switch (object) {
    case DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.MACSEC_STATUS_UNSPECIFIED:
      return "MACSEC_STATUS_UNSPECIFIED";
    case DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.SECURE:
      return "SECURE";
    case DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.UNSECURE:
      return "UNSECURE";
    case DiagnoseNetworkResponse_NetworkStatus_MacsecStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Message for requesting the diagnostics of an interconnect within a specific
 * zone.
 */
export interface DiagnoseInterconnectRequest {
  /** Required. The name of the interconnect resource. */
  name: string;
}

/**
 * DiagnoseInterconnectResponse contains the current diagnostics for a
 * specific interconnect.
 */
export interface DiagnoseInterconnectResponse {
  /** The time when the interconnect diagnostics was last updated. */
  updateTime:
    | Date
    | undefined;
  /** The network status of a specific interconnect. */
  result: InterconnectDiagnostics | undefined;
}

/** Message for requesting diagnositcs of a router within a specific zone. */
export interface DiagnoseRouterRequest {
  /** Required. The name of the router resource. */
  name: string;
}

/** DiagnoseRouterResponse contains the current status for a specific router. */
export interface DiagnoseRouterResponse {
  /** The time when the router status was last updated. */
  updateTime:
    | Date
    | undefined;
  /** The network status of a specific router. */
  result: RouterStatus | undefined;
}

/** Message for initializing a specified zone */
export interface InitializeZoneRequest {
  /** Required. The name of the zone resource. */
  name: string;
}

/** The response of initializing a zone */
export interface InitializeZoneResponse {
}

function createBaseListZonesRequest(): ListZonesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListZonesRequest: MessageFns<ListZonesRequest> = {
  encode(message: ListZonesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListZonesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListZonesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListZonesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListZonesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListZonesRequest>): ListZonesRequest {
    return ListZonesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListZonesRequest>): ListZonesRequest {
    const message = createBaseListZonesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListZonesResponse(): ListZonesResponse {
  return { zones: [], nextPageToken: "", unreachable: [] };
}

export const ListZonesResponse: MessageFns<ListZonesResponse> = {
  encode(message: ListZonesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.zones) {
      Zone.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListZonesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListZonesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.zones.push(Zone.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListZonesResponse {
    return {
      zones: globalThis.Array.isArray(object?.zones) ? object.zones.map((e: any) => Zone.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListZonesResponse): unknown {
    const obj: any = {};
    if (message.zones?.length) {
      obj.zones = message.zones.map((e) => Zone.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListZonesResponse>): ListZonesResponse {
    return ListZonesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListZonesResponse>): ListZonesResponse {
    const message = createBaseListZonesResponse();
    message.zones = object.zones?.map((e) => Zone.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetZoneRequest(): GetZoneRequest {
  return { name: "" };
}

export const GetZoneRequest: MessageFns<GetZoneRequest> = {
  encode(message: GetZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetZoneRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetZoneRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetZoneRequest>): GetZoneRequest {
    return GetZoneRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetZoneRequest>): GetZoneRequest {
    const message = createBaseGetZoneRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNetworksRequest(): ListNetworksRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListNetworksRequest: MessageFns<ListNetworksRequest> = {
  encode(message: ListNetworksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListNetworksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworksRequest>): ListNetworksRequest {
    return ListNetworksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworksRequest>): ListNetworksRequest {
    const message = createBaseListNetworksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListNetworksResponse(): ListNetworksResponse {
  return { networks: [], nextPageToken: "", unreachable: [] };
}

export const ListNetworksResponse: MessageFns<ListNetworksResponse> = {
  encode(message: ListNetworksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networks) {
      Network.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networks.push(Network.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworksResponse {
    return {
      networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e: any) => Network.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNetworksResponse): unknown {
    const obj: any = {};
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => Network.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworksResponse>): ListNetworksResponse {
    return ListNetworksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworksResponse>): ListNetworksResponse {
    const message = createBaseListNetworksResponse();
    message.networks = object.networks?.map((e) => Network.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNetworkRequest(): GetNetworkRequest {
  return { name: "" };
}

export const GetNetworkRequest: MessageFns<GetNetworkRequest> = {
  encode(message: GetNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkRequest>): GetNetworkRequest {
    return GetNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkRequest>): GetNetworkRequest {
    const message = createBaseGetNetworkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNetworkRequest(): CreateNetworkRequest {
  return { parent: "", networkId: "", network: undefined, requestId: "" };
}

export const CreateNetworkRequest: MessageFns<CreateNetworkRequest> = {
  encode(message: CreateNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.networkId !== "") {
      writer.uint32(18).string(message.networkId);
    }
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.networkId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNetworkRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateNetworkRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNetworkRequest>): CreateNetworkRequest {
    return CreateNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNetworkRequest>): CreateNetworkRequest {
    const message = createBaseCreateNetworkRequest();
    message.parent = object.parent ?? "";
    message.networkId = object.networkId ?? "";
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteNetworkRequest(): DeleteNetworkRequest {
  return { name: "", requestId: "" };
}

export const DeleteNetworkRequest: MessageFns<DeleteNetworkRequest> = {
  encode(message: DeleteNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNetworkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNetworkRequest>): DeleteNetworkRequest {
    return DeleteNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNetworkRequest>): DeleteNetworkRequest {
    const message = createBaseDeleteNetworkRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListSubnetsRequest(): ListSubnetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListSubnetsRequest: MessageFns<ListSubnetsRequest> = {
  encode(message: ListSubnetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubnetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubnetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubnetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListSubnetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubnetsRequest>): ListSubnetsRequest {
    return ListSubnetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubnetsRequest>): ListSubnetsRequest {
    const message = createBaseListSubnetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListSubnetsResponse(): ListSubnetsResponse {
  return { subnets: [], nextPageToken: "", unreachable: [] };
}

export const ListSubnetsResponse: MessageFns<ListSubnetsResponse> = {
  encode(message: ListSubnetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subnets) {
      Subnet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubnetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubnetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnets.push(Subnet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubnetsResponse {
    return {
      subnets: globalThis.Array.isArray(object?.subnets) ? object.subnets.map((e: any) => Subnet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListSubnetsResponse): unknown {
    const obj: any = {};
    if (message.subnets?.length) {
      obj.subnets = message.subnets.map((e) => Subnet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubnetsResponse>): ListSubnetsResponse {
    return ListSubnetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubnetsResponse>): ListSubnetsResponse {
    const message = createBaseListSubnetsResponse();
    message.subnets = object.subnets?.map((e) => Subnet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubnetRequest(): GetSubnetRequest {
  return { name: "" };
}

export const GetSubnetRequest: MessageFns<GetSubnetRequest> = {
  encode(message: GetSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubnetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSubnetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSubnetRequest>): GetSubnetRequest {
    return GetSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubnetRequest>): GetSubnetRequest {
    const message = createBaseGetSubnetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateSubnetRequest(): CreateSubnetRequest {
  return { parent: "", subnetId: "", subnet: undefined, requestId: "" };
}

export const CreateSubnetRequest: MessageFns<CreateSubnetRequest> = {
  encode(message: CreateSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.subnetId !== "") {
      writer.uint32(18).string(message.subnetId);
    }
    if (message.subnet !== undefined) {
      Subnet.encode(message.subnet, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subnet = Subnet.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubnetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      subnetId: isSet(object.subnetId) ? globalThis.String(object.subnetId) : "",
      subnet: isSet(object.subnet) ? Subnet.fromJSON(object.subnet) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateSubnetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.subnetId !== "") {
      obj.subnetId = message.subnetId;
    }
    if (message.subnet !== undefined) {
      obj.subnet = Subnet.toJSON(message.subnet);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSubnetRequest>): CreateSubnetRequest {
    return CreateSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSubnetRequest>): CreateSubnetRequest {
    const message = createBaseCreateSubnetRequest();
    message.parent = object.parent ?? "";
    message.subnetId = object.subnetId ?? "";
    message.subnet = (object.subnet !== undefined && object.subnet !== null)
      ? Subnet.fromPartial(object.subnet)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateSubnetRequest(): UpdateSubnetRequest {
  return { updateMask: undefined, subnet: undefined, requestId: "" };
}

export const UpdateSubnetRequest: MessageFns<UpdateSubnetRequest> = {
  encode(message: UpdateSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.subnet !== undefined) {
      Subnet.encode(message.subnet, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = Subnet.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubnetRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      subnet: isSet(object.subnet) ? Subnet.fromJSON(object.subnet) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateSubnetRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.subnet !== undefined) {
      obj.subnet = Subnet.toJSON(message.subnet);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSubnetRequest>): UpdateSubnetRequest {
    return UpdateSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSubnetRequest>): UpdateSubnetRequest {
    const message = createBaseUpdateSubnetRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.subnet = (object.subnet !== undefined && object.subnet !== null)
      ? Subnet.fromPartial(object.subnet)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteSubnetRequest(): DeleteSubnetRequest {
  return { name: "", requestId: "" };
}

export const DeleteSubnetRequest: MessageFns<DeleteSubnetRequest> = {
  encode(message: DeleteSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSubnetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteSubnetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSubnetRequest>): DeleteSubnetRequest {
    return DeleteSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSubnetRequest>): DeleteSubnetRequest {
    const message = createBaseDeleteSubnetRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListInterconnectsRequest(): ListInterconnectsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListInterconnectsRequest: MessageFns<ListInterconnectsRequest> = {
  encode(message: ListInterconnectsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInterconnectsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInterconnectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInterconnectsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListInterconnectsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInterconnectsRequest>): ListInterconnectsRequest {
    return ListInterconnectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInterconnectsRequest>): ListInterconnectsRequest {
    const message = createBaseListInterconnectsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListInterconnectsResponse(): ListInterconnectsResponse {
  return { interconnects: [], nextPageToken: "", unreachable: [] };
}

export const ListInterconnectsResponse: MessageFns<ListInterconnectsResponse> = {
  encode(message: ListInterconnectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.interconnects) {
      Interconnect.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInterconnectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInterconnectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interconnects.push(Interconnect.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInterconnectsResponse {
    return {
      interconnects: globalThis.Array.isArray(object?.interconnects)
        ? object.interconnects.map((e: any) => Interconnect.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInterconnectsResponse): unknown {
    const obj: any = {};
    if (message.interconnects?.length) {
      obj.interconnects = message.interconnects.map((e) => Interconnect.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInterconnectsResponse>): ListInterconnectsResponse {
    return ListInterconnectsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInterconnectsResponse>): ListInterconnectsResponse {
    const message = createBaseListInterconnectsResponse();
    message.interconnects = object.interconnects?.map((e) => Interconnect.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInterconnectRequest(): GetInterconnectRequest {
  return { name: "" };
}

export const GetInterconnectRequest: MessageFns<GetInterconnectRequest> = {
  encode(message: GetInterconnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInterconnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInterconnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInterconnectRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInterconnectRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInterconnectRequest>): GetInterconnectRequest {
    return GetInterconnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInterconnectRequest>): GetInterconnectRequest {
    const message = createBaseGetInterconnectRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListInterconnectAttachmentsRequest(): ListInterconnectAttachmentsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListInterconnectAttachmentsRequest: MessageFns<ListInterconnectAttachmentsRequest> = {
  encode(message: ListInterconnectAttachmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInterconnectAttachmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInterconnectAttachmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInterconnectAttachmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListInterconnectAttachmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInterconnectAttachmentsRequest>): ListInterconnectAttachmentsRequest {
    return ListInterconnectAttachmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInterconnectAttachmentsRequest>): ListInterconnectAttachmentsRequest {
    const message = createBaseListInterconnectAttachmentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListInterconnectAttachmentsResponse(): ListInterconnectAttachmentsResponse {
  return { interconnectAttachments: [], nextPageToken: "", unreachable: [] };
}

export const ListInterconnectAttachmentsResponse: MessageFns<ListInterconnectAttachmentsResponse> = {
  encode(message: ListInterconnectAttachmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.interconnectAttachments) {
      InterconnectAttachment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInterconnectAttachmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInterconnectAttachmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interconnectAttachments.push(InterconnectAttachment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInterconnectAttachmentsResponse {
    return {
      interconnectAttachments: globalThis.Array.isArray(object?.interconnectAttachments)
        ? object.interconnectAttachments.map((e: any) => InterconnectAttachment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInterconnectAttachmentsResponse): unknown {
    const obj: any = {};
    if (message.interconnectAttachments?.length) {
      obj.interconnectAttachments = message.interconnectAttachments.map((e) => InterconnectAttachment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInterconnectAttachmentsResponse>): ListInterconnectAttachmentsResponse {
    return ListInterconnectAttachmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInterconnectAttachmentsResponse>): ListInterconnectAttachmentsResponse {
    const message = createBaseListInterconnectAttachmentsResponse();
    message.interconnectAttachments =
      object.interconnectAttachments?.map((e) => InterconnectAttachment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInterconnectAttachmentRequest(): GetInterconnectAttachmentRequest {
  return { name: "" };
}

export const GetInterconnectAttachmentRequest: MessageFns<GetInterconnectAttachmentRequest> = {
  encode(message: GetInterconnectAttachmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInterconnectAttachmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInterconnectAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInterconnectAttachmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInterconnectAttachmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInterconnectAttachmentRequest>): GetInterconnectAttachmentRequest {
    return GetInterconnectAttachmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInterconnectAttachmentRequest>): GetInterconnectAttachmentRequest {
    const message = createBaseGetInterconnectAttachmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateInterconnectAttachmentRequest(): CreateInterconnectAttachmentRequest {
  return { parent: "", interconnectAttachmentId: "", interconnectAttachment: undefined, requestId: "" };
}

export const CreateInterconnectAttachmentRequest: MessageFns<CreateInterconnectAttachmentRequest> = {
  encode(message: CreateInterconnectAttachmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.interconnectAttachmentId !== "") {
      writer.uint32(18).string(message.interconnectAttachmentId);
    }
    if (message.interconnectAttachment !== undefined) {
      InterconnectAttachment.encode(message.interconnectAttachment, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInterconnectAttachmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInterconnectAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interconnectAttachmentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interconnectAttachment = InterconnectAttachment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInterconnectAttachmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      interconnectAttachmentId: isSet(object.interconnectAttachmentId)
        ? globalThis.String(object.interconnectAttachmentId)
        : "",
      interconnectAttachment: isSet(object.interconnectAttachment)
        ? InterconnectAttachment.fromJSON(object.interconnectAttachment)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateInterconnectAttachmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.interconnectAttachmentId !== "") {
      obj.interconnectAttachmentId = message.interconnectAttachmentId;
    }
    if (message.interconnectAttachment !== undefined) {
      obj.interconnectAttachment = InterconnectAttachment.toJSON(message.interconnectAttachment);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInterconnectAttachmentRequest>): CreateInterconnectAttachmentRequest {
    return CreateInterconnectAttachmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInterconnectAttachmentRequest>): CreateInterconnectAttachmentRequest {
    const message = createBaseCreateInterconnectAttachmentRequest();
    message.parent = object.parent ?? "";
    message.interconnectAttachmentId = object.interconnectAttachmentId ?? "";
    message.interconnectAttachment =
      (object.interconnectAttachment !== undefined && object.interconnectAttachment !== null)
        ? InterconnectAttachment.fromPartial(object.interconnectAttachment)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteInterconnectAttachmentRequest(): DeleteInterconnectAttachmentRequest {
  return { name: "", requestId: "" };
}

export const DeleteInterconnectAttachmentRequest: MessageFns<DeleteInterconnectAttachmentRequest> = {
  encode(message: DeleteInterconnectAttachmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInterconnectAttachmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInterconnectAttachmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInterconnectAttachmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteInterconnectAttachmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInterconnectAttachmentRequest>): DeleteInterconnectAttachmentRequest {
    return DeleteInterconnectAttachmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInterconnectAttachmentRequest>): DeleteInterconnectAttachmentRequest {
    const message = createBaseDeleteInterconnectAttachmentRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListRoutersRequest(): ListRoutersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListRoutersRequest: MessageFns<ListRoutersRequest> = {
  encode(message: ListRoutersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoutersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoutersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoutersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListRoutersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRoutersRequest>): ListRoutersRequest {
    return ListRoutersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRoutersRequest>): ListRoutersRequest {
    const message = createBaseListRoutersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListRoutersResponse(): ListRoutersResponse {
  return { routers: [], nextPageToken: "", unreachable: [] };
}

export const ListRoutersResponse: MessageFns<ListRoutersResponse> = {
  encode(message: ListRoutersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routers) {
      Router.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoutersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoutersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routers.push(Router.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoutersResponse {
    return {
      routers: globalThis.Array.isArray(object?.routers) ? object.routers.map((e: any) => Router.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRoutersResponse): unknown {
    const obj: any = {};
    if (message.routers?.length) {
      obj.routers = message.routers.map((e) => Router.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRoutersResponse>): ListRoutersResponse {
    return ListRoutersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRoutersResponse>): ListRoutersResponse {
    const message = createBaseListRoutersResponse();
    message.routers = object.routers?.map((e) => Router.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRouterRequest(): GetRouterRequest {
  return { name: "" };
}

export const GetRouterRequest: MessageFns<GetRouterRequest> = {
  encode(message: GetRouterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRouterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRouterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRouterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRouterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRouterRequest>): GetRouterRequest {
    return GetRouterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRouterRequest>): GetRouterRequest {
    const message = createBaseGetRouterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateRouterRequest(): CreateRouterRequest {
  return { parent: "", routerId: "", router: undefined, requestId: "" };
}

export const CreateRouterRequest: MessageFns<CreateRouterRequest> = {
  encode(message: CreateRouterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.routerId !== "") {
      writer.uint32(18).string(message.routerId);
    }
    if (message.router !== undefined) {
      Router.encode(message.router, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRouterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRouterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.router = Router.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRouterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      routerId: isSet(object.routerId) ? globalThis.String(object.routerId) : "",
      router: isSet(object.router) ? Router.fromJSON(object.router) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateRouterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.routerId !== "") {
      obj.routerId = message.routerId;
    }
    if (message.router !== undefined) {
      obj.router = Router.toJSON(message.router);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRouterRequest>): CreateRouterRequest {
    return CreateRouterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRouterRequest>): CreateRouterRequest {
    const message = createBaseCreateRouterRequest();
    message.parent = object.parent ?? "";
    message.routerId = object.routerId ?? "";
    message.router = (object.router !== undefined && object.router !== null)
      ? Router.fromPartial(object.router)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateRouterRequest(): UpdateRouterRequest {
  return { updateMask: undefined, router: undefined, requestId: "" };
}

export const UpdateRouterRequest: MessageFns<UpdateRouterRequest> = {
  encode(message: UpdateRouterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.router !== undefined) {
      Router.encode(message.router, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRouterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRouterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.router = Router.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRouterRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      router: isSet(object.router) ? Router.fromJSON(object.router) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateRouterRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.router !== undefined) {
      obj.router = Router.toJSON(message.router);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRouterRequest>): UpdateRouterRequest {
    return UpdateRouterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRouterRequest>): UpdateRouterRequest {
    const message = createBaseUpdateRouterRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.router = (object.router !== undefined && object.router !== null)
      ? Router.fromPartial(object.router)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteRouterRequest(): DeleteRouterRequest {
  return { name: "", requestId: "" };
}

export const DeleteRouterRequest: MessageFns<DeleteRouterRequest> = {
  encode(message: DeleteRouterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRouterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRouterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRouterRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteRouterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRouterRequest>): DeleteRouterRequest {
    return DeleteRouterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRouterRequest>): DeleteRouterRequest {
    const message = createBaseDeleteRouterRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseDiagnoseNetworkRequest(): DiagnoseNetworkRequest {
  return { name: "" };
}

export const DiagnoseNetworkRequest: MessageFns<DiagnoseNetworkRequest> = {
  encode(message: DiagnoseNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseNetworkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DiagnoseNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseNetworkRequest>): DiagnoseNetworkRequest {
    return DiagnoseNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseNetworkRequest>): DiagnoseNetworkRequest {
    const message = createBaseDiagnoseNetworkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDiagnoseNetworkResponse(): DiagnoseNetworkResponse {
  return { updateTime: undefined, result: undefined };
}

export const DiagnoseNetworkResponse: MessageFns<DiagnoseNetworkResponse> = {
  encode(message: DiagnoseNetworkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      DiagnoseNetworkResponse_NetworkStatus.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseNetworkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseNetworkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = DiagnoseNetworkResponse_NetworkStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseNetworkResponse {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      result: isSet(object.result) ? DiagnoseNetworkResponse_NetworkStatus.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: DiagnoseNetworkResponse): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.result !== undefined) {
      obj.result = DiagnoseNetworkResponse_NetworkStatus.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseNetworkResponse>): DiagnoseNetworkResponse {
    return DiagnoseNetworkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseNetworkResponse>): DiagnoseNetworkResponse {
    const message = createBaseDiagnoseNetworkResponse();
    message.updateTime = object.updateTime ?? undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? DiagnoseNetworkResponse_NetworkStatus.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseDiagnoseNetworkResponse_NetworkStatus(): DiagnoseNetworkResponse_NetworkStatus {
  return { subnetStatus: [], macsecStatusInternalLinks: 0 };
}

export const DiagnoseNetworkResponse_NetworkStatus: MessageFns<DiagnoseNetworkResponse_NetworkStatus> = {
  encode(message: DiagnoseNetworkResponse_NetworkStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subnetStatus) {
      SubnetStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.macsecStatusInternalLinks !== 0) {
      writer.uint32(16).int32(message.macsecStatusInternalLinks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseNetworkResponse_NetworkStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseNetworkResponse_NetworkStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnetStatus.push(SubnetStatus.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.macsecStatusInternalLinks = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseNetworkResponse_NetworkStatus {
    return {
      subnetStatus: globalThis.Array.isArray(object?.subnetStatus)
        ? object.subnetStatus.map((e: any) => SubnetStatus.fromJSON(e))
        : [],
      macsecStatusInternalLinks: isSet(object.macsecStatusInternalLinks)
        ? diagnoseNetworkResponse_NetworkStatus_MacsecStatusFromJSON(object.macsecStatusInternalLinks)
        : 0,
    };
  },

  toJSON(message: DiagnoseNetworkResponse_NetworkStatus): unknown {
    const obj: any = {};
    if (message.subnetStatus?.length) {
      obj.subnetStatus = message.subnetStatus.map((e) => SubnetStatus.toJSON(e));
    }
    if (message.macsecStatusInternalLinks !== 0) {
      obj.macsecStatusInternalLinks = diagnoseNetworkResponse_NetworkStatus_MacsecStatusToJSON(
        message.macsecStatusInternalLinks,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseNetworkResponse_NetworkStatus>): DiagnoseNetworkResponse_NetworkStatus {
    return DiagnoseNetworkResponse_NetworkStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseNetworkResponse_NetworkStatus>): DiagnoseNetworkResponse_NetworkStatus {
    const message = createBaseDiagnoseNetworkResponse_NetworkStatus();
    message.subnetStatus = object.subnetStatus?.map((e) => SubnetStatus.fromPartial(e)) || [];
    message.macsecStatusInternalLinks = object.macsecStatusInternalLinks ?? 0;
    return message;
  },
};

function createBaseDiagnoseInterconnectRequest(): DiagnoseInterconnectRequest {
  return { name: "" };
}

export const DiagnoseInterconnectRequest: MessageFns<DiagnoseInterconnectRequest> = {
  encode(message: DiagnoseInterconnectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseInterconnectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseInterconnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseInterconnectRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DiagnoseInterconnectRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseInterconnectRequest>): DiagnoseInterconnectRequest {
    return DiagnoseInterconnectRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseInterconnectRequest>): DiagnoseInterconnectRequest {
    const message = createBaseDiagnoseInterconnectRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDiagnoseInterconnectResponse(): DiagnoseInterconnectResponse {
  return { updateTime: undefined, result: undefined };
}

export const DiagnoseInterconnectResponse: MessageFns<DiagnoseInterconnectResponse> = {
  encode(message: DiagnoseInterconnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      InterconnectDiagnostics.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseInterconnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseInterconnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = InterconnectDiagnostics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseInterconnectResponse {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      result: isSet(object.result) ? InterconnectDiagnostics.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: DiagnoseInterconnectResponse): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.result !== undefined) {
      obj.result = InterconnectDiagnostics.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseInterconnectResponse>): DiagnoseInterconnectResponse {
    return DiagnoseInterconnectResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseInterconnectResponse>): DiagnoseInterconnectResponse {
    const message = createBaseDiagnoseInterconnectResponse();
    message.updateTime = object.updateTime ?? undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? InterconnectDiagnostics.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseDiagnoseRouterRequest(): DiagnoseRouterRequest {
  return { name: "" };
}

export const DiagnoseRouterRequest: MessageFns<DiagnoseRouterRequest> = {
  encode(message: DiagnoseRouterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseRouterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseRouterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseRouterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DiagnoseRouterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseRouterRequest>): DiagnoseRouterRequest {
    return DiagnoseRouterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseRouterRequest>): DiagnoseRouterRequest {
    const message = createBaseDiagnoseRouterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDiagnoseRouterResponse(): DiagnoseRouterResponse {
  return { updateTime: undefined, result: undefined };
}

export const DiagnoseRouterResponse: MessageFns<DiagnoseRouterResponse> = {
  encode(message: DiagnoseRouterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      RouterStatus.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnoseRouterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnoseRouterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result = RouterStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnoseRouterResponse {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      result: isSet(object.result) ? RouterStatus.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: DiagnoseRouterResponse): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.result !== undefined) {
      obj.result = RouterStatus.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<DiagnoseRouterResponse>): DiagnoseRouterResponse {
    return DiagnoseRouterResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiagnoseRouterResponse>): DiagnoseRouterResponse {
    const message = createBaseDiagnoseRouterResponse();
    message.updateTime = object.updateTime ?? undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? RouterStatus.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseInitializeZoneRequest(): InitializeZoneRequest {
  return { name: "" };
}

export const InitializeZoneRequest: MessageFns<InitializeZoneRequest> = {
  encode(message: InitializeZoneRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeZoneRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeZoneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeZoneRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: InitializeZoneRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<InitializeZoneRequest>): InitializeZoneRequest {
    return InitializeZoneRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitializeZoneRequest>): InitializeZoneRequest {
    const message = createBaseInitializeZoneRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseInitializeZoneResponse(): InitializeZoneResponse {
  return {};
}

export const InitializeZoneResponse: MessageFns<InitializeZoneResponse> = {
  encode(_: InitializeZoneResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeZoneResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeZoneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InitializeZoneResponse {
    return {};
  },

  toJSON(_: InitializeZoneResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InitializeZoneResponse>): InitializeZoneResponse {
    return InitializeZoneResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InitializeZoneResponse>): InitializeZoneResponse {
    const message = createBaseInitializeZoneResponse();
    return message;
  },
};

/**
 * EdgeNetwork API provides managed, highly available cloud dynamic network
 * configuration service to the GEC customer to enable edge application and
 * network function solutions. This allows the customers to easily define and
 * configure the network setup and property to meet the workload requirement.
 */
export type EdgeNetworkDefinition = typeof EdgeNetworkDefinition;
export const EdgeNetworkDefinition = {
  name: "EdgeNetwork",
  fullName: "google.cloud.edgenetwork.v1.EdgeNetwork",
  methods: {
    /** InitializeZone will initialize resources for a zone in a project. */
    initializeZone: {
      name: "InitializeZone",
      requestType: InitializeZoneRequest,
      requestStream: false,
      responseType: InitializeZoneResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              58,
              105,
              110,
              105,
              116,
              105,
              97,
              108,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Deprecated: not implemented.
     * Lists Zones in a given project and location.
     *
     * @deprecated
     */
    listZones: {
      name: "ListZones",
      requestType: ListZonesRequest,
      requestStream: false,
      responseType: ListZonesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deprecated: not implemented.
     * Gets details of a single Zone.
     *
     * @deprecated
     */
    getZone: {
      name: "GetZone",
      requestType: GetZoneRequest,
      requestStream: false,
      responseType: Zone,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Networks in a given project and location. */
    listNetworks: {
      name: "ListNetworks",
      requestType: ListNetworksRequest,
      requestStream: false,
      responseType: ListNetworksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Network. */
    getNetwork: {
      name: "GetNetwork",
      requestType: GetNetworkRequest,
      requestStream: false,
      responseType: Network,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get the diagnostics of a single network resource. */
    diagnoseNetwork: {
      name: "DiagnoseNetwork",
      requestType: DiagnoseNetworkRequest,
      requestStream: false,
      responseType: DiagnoseNetworkResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              63,
              18,
              61,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              97,
              103,
              110,
              111,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new Network in a given project and location. */
    createNetwork: {
      name: "CreateNetwork",
      requestType: CreateNetworkRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              7,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Network. */
    deleteNetwork: {
      name: "DeleteNetwork",
      requestType: DeleteNetworkRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Subnets in a given project and location. */
    listSubnets: {
      name: "ListSubnets",
      requestType: ListSubnetsRequest,
      requestStream: false,
      responseType: ListSubnetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Subnet. */
    getSubnet: {
      name: "GetSubnet",
      requestType: GetSubnetRequest,
      requestStream: false,
      responseType: Subnet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new Subnet in a given project and location. */
    createSubnet: {
      name: "CreateSubnet",
      requestType: CreateSubnetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              117,
              98,
              110,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              117,
              98,
              110,
              101,
              116,
              44,
              115,
              117,
              98,
              110,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              6,
              115,
              117,
              98,
              110,
              101,
              116,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Subnet. */
    updateSubnet: {
      name: "UpdateSubnet",
      requestType: UpdateSubnetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              117,
              98,
              110,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 115, 117, 98, 110, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              6,
              115,
              117,
              98,
              110,
              101,
              116,
              50,
              58,
              47,
              118,
              49,
              47,
              123,
              115,
              117,
              98,
              110,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Subnet. */
    deleteSubnet: {
      name: "DeleteSubnet",
      requestType: DeleteSubnetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Interconnects in a given project and location. */
    listInterconnects: {
      name: "ListInterconnects",
      requestType: ListInterconnectsRequest,
      requestStream: false,
      responseType: ListInterconnectsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Interconnect. */
    getInterconnect: {
      name: "GetInterconnect",
      requestType: GetInterconnectRequest,
      requestStream: false,
      responseType: Interconnect,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get the diagnostics of a single interconnect resource. */
    diagnoseInterconnect: {
      name: "DiagnoseInterconnect",
      requestType: DiagnoseInterconnectRequest,
      requestStream: false,
      responseType: DiagnoseInterconnectResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              97,
              103,
              110,
              111,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** Lists InterconnectAttachments in a given project and location. */
    listInterconnectAttachments: {
      name: "ListInterconnectAttachments",
      requestType: ListInterconnectAttachmentsRequest,
      requestStream: false,
      responseType: ListInterconnectAttachmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              65,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single InterconnectAttachment. */
    getInterconnectAttachment: {
      name: "GetInterconnectAttachment",
      requestType: GetInterconnectAttachmentRequest,
      requestStream: false,
      responseType: InterconnectAttachment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              65,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new InterconnectAttachment in a given project and location. */
    createInterconnectAttachment: {
      name: "CreateInterconnectAttachment",
      requestType: CreateInterconnectAttachmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              43,
              10,
              22,
              73,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              65,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              57,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              95,
              97,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              44,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              95,
              97,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              94,
              58,
              23,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              95,
              97,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              34,
              67,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              65,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single InterconnectAttachment. */
    deleteInterconnectAttachment: {
      name: "DeleteInterconnectAttachment",
      requestType: DeleteInterconnectAttachmentRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              42,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              105,
              110,
              116,
              101,
              114,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              65,
              116,
              116,
              97,
              99,
              104,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Routers in a given project and location. */
    listRouters: {
      name: "ListRouters",
      requestType: ListRoutersRequest,
      requestStream: false,
      responseType: ListRoutersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single Router. */
    getRouter: {
      name: "GetRouter",
      requestType: GetRouterRequest,
      requestStream: false,
      responseType: Router,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get the diagnostics of a single router resource. */
    diagnoseRouter: {
      name: "DiagnoseRouter",
      requestType: DiagnoseRouterRequest,
      requestStream: false,
      responseType: DiagnoseRouterResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              97,
              103,
              110,
              111,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** Creates a new Router in a given project and location. */
    createRouter: {
      name: "CreateRouter",
      requestType: CreateRouterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              82,
              111,
              117,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              111,
              117,
              116,
              101,
              114,
              44,
              114,
              111,
              117,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              6,
              114,
              111,
              117,
              116,
              101,
              114,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the parameters of a single Router. */
    updateRouter: {
      name: "UpdateRouter",
      requestType: UpdateRouterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              82,
              111,
              117,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 114, 111, 117, 116, 101, 114, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              68,
              58,
              6,
              114,
              111,
              117,
              116,
              101,
              114,
              50,
              58,
              47,
              118,
              49,
              47,
              123,
              114,
              111,
              117,
              116,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single Router. */
    deleteRouter: {
      name: "DeleteRouter",
      requestType: DeleteRouterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              42,
              47,
              114,
              111,
              117,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface EdgeNetworkServiceImplementation<CallContextExt = {}> {
  /** InitializeZone will initialize resources for a zone in a project. */
  initializeZone(
    request: InitializeZoneRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InitializeZoneResponse>>;
  /**
   * Deprecated: not implemented.
   * Lists Zones in a given project and location.
   *
   * @deprecated
   */
  listZones(request: ListZonesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListZonesResponse>>;
  /**
   * Deprecated: not implemented.
   * Gets details of a single Zone.
   *
   * @deprecated
   */
  getZone(request: GetZoneRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Zone>>;
  /** Lists Networks in a given project and location. */
  listNetworks(
    request: ListNetworksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNetworksResponse>>;
  /** Gets details of a single Network. */
  getNetwork(request: GetNetworkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Network>>;
  /** Get the diagnostics of a single network resource. */
  diagnoseNetwork(
    request: DiagnoseNetworkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DiagnoseNetworkResponse>>;
  /** Creates a new Network in a given project and location. */
  createNetwork(request: CreateNetworkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Network. */
  deleteNetwork(request: DeleteNetworkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists Subnets in a given project and location. */
  listSubnets(
    request: ListSubnetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubnetsResponse>>;
  /** Gets details of a single Subnet. */
  getSubnet(request: GetSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Subnet>>;
  /** Creates a new Subnet in a given project and location. */
  createSubnet(request: CreateSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Subnet. */
  updateSubnet(request: UpdateSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Subnet. */
  deleteSubnet(request: DeleteSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists Interconnects in a given project and location. */
  listInterconnects(
    request: ListInterconnectsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInterconnectsResponse>>;
  /** Gets details of a single Interconnect. */
  getInterconnect(
    request: GetInterconnectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Interconnect>>;
  /** Get the diagnostics of a single interconnect resource. */
  diagnoseInterconnect(
    request: DiagnoseInterconnectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DiagnoseInterconnectResponse>>;
  /** Lists InterconnectAttachments in a given project and location. */
  listInterconnectAttachments(
    request: ListInterconnectAttachmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInterconnectAttachmentsResponse>>;
  /** Gets details of a single InterconnectAttachment. */
  getInterconnectAttachment(
    request: GetInterconnectAttachmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InterconnectAttachment>>;
  /** Creates a new InterconnectAttachment in a given project and location. */
  createInterconnectAttachment(
    request: CreateInterconnectAttachmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single InterconnectAttachment. */
  deleteInterconnectAttachment(
    request: DeleteInterconnectAttachmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Routers in a given project and location. */
  listRouters(
    request: ListRoutersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRoutersResponse>>;
  /** Gets details of a single Router. */
  getRouter(request: GetRouterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Router>>;
  /** Get the diagnostics of a single router resource. */
  diagnoseRouter(
    request: DiagnoseRouterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DiagnoseRouterResponse>>;
  /** Creates a new Router in a given project and location. */
  createRouter(request: CreateRouterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the parameters of a single Router. */
  updateRouter(request: UpdateRouterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single Router. */
  deleteRouter(request: DeleteRouterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface EdgeNetworkClient<CallOptionsExt = {}> {
  /** InitializeZone will initialize resources for a zone in a project. */
  initializeZone(
    request: DeepPartial<InitializeZoneRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InitializeZoneResponse>;
  /**
   * Deprecated: not implemented.
   * Lists Zones in a given project and location.
   *
   * @deprecated
   */
  listZones(request: DeepPartial<ListZonesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListZonesResponse>;
  /**
   * Deprecated: not implemented.
   * Gets details of a single Zone.
   *
   * @deprecated
   */
  getZone(request: DeepPartial<GetZoneRequest>, options?: CallOptions & CallOptionsExt): Promise<Zone>;
  /** Lists Networks in a given project and location. */
  listNetworks(
    request: DeepPartial<ListNetworksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNetworksResponse>;
  /** Gets details of a single Network. */
  getNetwork(request: DeepPartial<GetNetworkRequest>, options?: CallOptions & CallOptionsExt): Promise<Network>;
  /** Get the diagnostics of a single network resource. */
  diagnoseNetwork(
    request: DeepPartial<DiagnoseNetworkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DiagnoseNetworkResponse>;
  /** Creates a new Network in a given project and location. */
  createNetwork(request: DeepPartial<CreateNetworkRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Network. */
  deleteNetwork(request: DeepPartial<DeleteNetworkRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists Subnets in a given project and location. */
  listSubnets(
    request: DeepPartial<ListSubnetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubnetsResponse>;
  /** Gets details of a single Subnet. */
  getSubnet(request: DeepPartial<GetSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Subnet>;
  /** Creates a new Subnet in a given project and location. */
  createSubnet(request: DeepPartial<CreateSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Subnet. */
  updateSubnet(request: DeepPartial<UpdateSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Subnet. */
  deleteSubnet(request: DeepPartial<DeleteSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists Interconnects in a given project and location. */
  listInterconnects(
    request: DeepPartial<ListInterconnectsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInterconnectsResponse>;
  /** Gets details of a single Interconnect. */
  getInterconnect(
    request: DeepPartial<GetInterconnectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Interconnect>;
  /** Get the diagnostics of a single interconnect resource. */
  diagnoseInterconnect(
    request: DeepPartial<DiagnoseInterconnectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DiagnoseInterconnectResponse>;
  /** Lists InterconnectAttachments in a given project and location. */
  listInterconnectAttachments(
    request: DeepPartial<ListInterconnectAttachmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInterconnectAttachmentsResponse>;
  /** Gets details of a single InterconnectAttachment. */
  getInterconnectAttachment(
    request: DeepPartial<GetInterconnectAttachmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InterconnectAttachment>;
  /** Creates a new InterconnectAttachment in a given project and location. */
  createInterconnectAttachment(
    request: DeepPartial<CreateInterconnectAttachmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single InterconnectAttachment. */
  deleteInterconnectAttachment(
    request: DeepPartial<DeleteInterconnectAttachmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Routers in a given project and location. */
  listRouters(
    request: DeepPartial<ListRoutersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRoutersResponse>;
  /** Gets details of a single Router. */
  getRouter(request: DeepPartial<GetRouterRequest>, options?: CallOptions & CallOptionsExt): Promise<Router>;
  /** Get the diagnostics of a single router resource. */
  diagnoseRouter(
    request: DeepPartial<DiagnoseRouterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DiagnoseRouterResponse>;
  /** Creates a new Router in a given project and location. */
  createRouter(request: DeepPartial<CreateRouterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the parameters of a single Router. */
  updateRouter(request: DeepPartial<UpdateRouterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single Router. */
  deleteRouter(request: DeepPartial<DeleteRouterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
