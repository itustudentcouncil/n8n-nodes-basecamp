// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/batch/v1/task.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Volume } from "./volume.js";

export const protobufPackage = "google.cloud.batch.v1";

/**
 * Compute resource requirements.
 *
 * ComputeResource defines the amount of resources required for each task.
 * Make sure your tasks have enough resources to successfully run.
 * If you also define the types of resources for a job to use with the
 * [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
 * field, make sure both fields are compatible with each other.
 */
export interface ComputeResource {
  /**
   * The milliCPU count.
   *
   * `cpuMilli` defines the amount of CPU resources per task in milliCPU units.
   * For example, `1000` corresponds to 1 vCPU per task. If undefined, the
   * default value is `2000`.
   *
   * If you also define the VM's machine type using the `machineType` in
   * [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy)
   * field or inside the `instanceTemplate` in the
   * [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
   * field, make sure the CPU resources for both fields are compatible with each
   * other and with how many tasks you want to allow to run on the same VM at
   * the same time.
   *
   * For example, if you specify the `n2-standard-2` machine type, which has 2
   * vCPUs each, you are recommended to set `cpuMilli` no more than `2000`, or
   * you are recommended to run two tasks on the same VM if you set `cpuMilli`
   * to `1000` or less.
   */
  cpuMilli: Long;
  /**
   * Memory in MiB.
   *
   * `memoryMib` defines the amount of memory per task in MiB units.
   * If undefined, the default value is `2000`.
   * If you also define the VM's machine type using the `machineType` in
   * [InstancePolicy](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicy)
   * field or inside the `instanceTemplate` in the
   * [InstancePolicyOrTemplate](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#instancepolicyortemplate)
   * field, make sure the memory resources for both fields are compatible with
   * each other and with how many tasks you want to allow to run on the same VM
   * at the same time.
   *
   * For example, if you specify the `n2-standard-2` machine type, which has 8
   * GiB each, you are recommended to set `memoryMib` to no more than `8192`,
   * or you are recommended to run two tasks on the same VM if you set
   * `memoryMib` to `4096` or less.
   */
  memoryMib: Long;
  /** Extra boot disk size in MiB for each task. */
  bootDiskMib: Long;
}

/** Status event. */
export interface StatusEvent {
  /** Type of the event. */
  type: string;
  /** Description of the event. */
  description: string;
  /** The time this event occurred. */
  eventTime:
    | Date
    | undefined;
  /**
   * Task Execution.
   * This field is only defined for task-level status events where the task
   * fails.
   */
  taskExecution:
    | TaskExecution
    | undefined;
  /**
   * Task State.
   * This field is only defined for task-level status events.
   */
  taskState: TaskStatus_State;
}

/**
 * This Task Execution field includes detail information for
 * task execution procedures, based on StatusEvent types.
 */
export interface TaskExecution {
  /**
   * The exit code of a finished task.
   *
   * If the task succeeded, the exit code will be 0. If the task failed but not
   * due to the following reasons, the exit code will be 50000.
   *
   * Otherwise, it can be from different sources:
   * * Batch known failures:
   * https://cloud.google.com/batch/docs/troubleshooting#reserved-exit-codes.
   * * Batch runnable execution failures; you can rely on Batch logs to further
   * diagnose: https://cloud.google.com/batch/docs/analyze-job-using-logs. If
   * there are multiple runnables failures, Batch only exposes the first error.
   */
  exitCode: number;
}

/** Status of a task. */
export interface TaskStatus {
  /** Task state. */
  state: TaskStatus_State;
  /** Detailed info about why the state is reached. */
  statusEvents: StatusEvent[];
}

/** Task states. */
export enum TaskStatus_State {
  /** STATE_UNSPECIFIED - Unknown state. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The Task is created and waiting for resources. */
  PENDING = 1,
  /** ASSIGNED - The Task is assigned to at least one VM. */
  ASSIGNED = 2,
  /** RUNNING - The Task is running. */
  RUNNING = 3,
  /** FAILED - The Task has failed. */
  FAILED = 4,
  /** SUCCEEDED - The Task has succeeded. */
  SUCCEEDED = 5,
  /** UNEXECUTED - The Task has not been executed when the Job finishes. */
  UNEXECUTED = 6,
  UNRECOGNIZED = -1,
}

export function taskStatus_StateFromJSON(object: any): TaskStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return TaskStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return TaskStatus_State.PENDING;
    case 2:
    case "ASSIGNED":
      return TaskStatus_State.ASSIGNED;
    case 3:
    case "RUNNING":
      return TaskStatus_State.RUNNING;
    case 4:
    case "FAILED":
      return TaskStatus_State.FAILED;
    case 5:
    case "SUCCEEDED":
      return TaskStatus_State.SUCCEEDED;
    case 6:
    case "UNEXECUTED":
      return TaskStatus_State.UNEXECUTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskStatus_State.UNRECOGNIZED;
  }
}

export function taskStatus_StateToJSON(object: TaskStatus_State): string {
  switch (object) {
    case TaskStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case TaskStatus_State.PENDING:
      return "PENDING";
    case TaskStatus_State.ASSIGNED:
      return "ASSIGNED";
    case TaskStatus_State.RUNNING:
      return "RUNNING";
    case TaskStatus_State.FAILED:
      return "FAILED";
    case TaskStatus_State.SUCCEEDED:
      return "SUCCEEDED";
    case TaskStatus_State.UNEXECUTED:
      return "UNEXECUTED";
    case TaskStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Runnable describes instructions for executing a specific script or container
 * as part of a Task.
 */
export interface Runnable {
  /** Container runnable. */
  container?:
    | Runnable_Container
    | undefined;
  /** Script runnable. */
  script?:
    | Runnable_Script
    | undefined;
  /** Barrier runnable. */
  barrier?:
    | Runnable_Barrier
    | undefined;
  /**
   * Optional. DisplayName is an optional field that can be provided by the
   * caller. If provided, it will be used in logs and other outputs to identify
   * the script, making it easier for users to understand the logs. If not
   * provided the index of the runnable will be used for outputs.
   */
  displayName: string;
  /**
   * Normally, a runnable that returns a non-zero exit status fails and causes
   * the task to fail. However, you can set this field to `true` to allow the
   * task to continue executing its other runnables even if this runnable
   * fails.
   */
  ignoreExitStatus: boolean;
  /**
   * Normally, a runnable that doesn't exit causes its task to fail. However,
   * you can set this field to `true` to configure a background runnable.
   * Background runnables are allowed continue running in the background while
   * the task executes subsequent runnables. For example, background runnables
   * are useful for providing services to other runnables or providing
   * debugging-support tools like SSH servers.
   *
   * Specifically, background runnables are killed automatically (if they have
   * not already exited) a short time after all foreground runnables have
   * completed. Even though this is likely to result in a non-zero exit status
   * for the background runnable, these automatic kills are not treated as task
   * failures.
   */
  background: boolean;
  /**
   * By default, after a Runnable fails, no further Runnable are executed. This
   * flag indicates that this Runnable must be run even if the Task has already
   * failed. This is useful for Runnables that copy output files off of the VM
   * or for debugging.
   *
   * The always_run flag does not override the Task's overall max_run_duration.
   * If the max_run_duration has expired then no further Runnables will execute,
   * not even always_run Runnables.
   */
  alwaysRun: boolean;
  /**
   * Environment variables for this Runnable (overrides variables set for the
   * whole Task or TaskGroup).
   */
  environment:
    | Environment
    | undefined;
  /** Timeout for this Runnable. */
  timeout:
    | Duration
    | undefined;
  /** Labels for this Runnable. */
  labels: { [key: string]: string };
}

/** Container runnable. */
export interface Runnable_Container {
  /** Required. The URI to pull the container image from. */
  imageUri: string;
  /**
   * Required for some container images. Overrides the `CMD` specified in the
   * container. If there is an `ENTRYPOINT` (either in the container image or
   * with the `entrypoint` field below) then these commands are appended as
   * arguments to the `ENTRYPOINT`.
   */
  commands: string[];
  /**
   * Required for some container images. Overrides the `ENTRYPOINT` specified
   * in the container.
   */
  entrypoint: string;
  /**
   * Volumes to mount (bind mount) from the host machine files or directories
   * into the container, formatted to match `--volume` option for the
   * `docker run` command&mdash;for example, `/foo:/bar` or `/foo:/bar:ro`.
   *
   * If the `TaskSpec.Volumes` field is specified but this field is not, Batch
   * will mount each volume from the host machine to the container with the
   * same mount path by default. In this case, the default mount option for
   * containers will be read-only (`ro`) for existing persistent disks and
   * read-write (`rw`) for other volume types, regardless of the original
   * mount options specified in `TaskSpec.Volumes`. If you need different
   * mount settings, you can explicitly configure them in this field.
   */
  volumes: string[];
  /**
   * Required for some container images. Arbitrary additional options to
   * include in the `docker run` command when running this container&mdash;for
   * example, `--network host`. For the `--volume` option, use the `volumes`
   * field for the container.
   */
  options: string;
  /**
   * If set to true, external network access to and from container will be
   * blocked, containers that are with block_external_network as true can
   * still communicate with each other, network cannot be specified in the
   * `container.options` field.
   */
  blockExternalNetwork: boolean;
  /**
   * Required if the container image is from a private Docker registry. The
   * username to login to the Docker registry that contains the image.
   *
   * You can either specify the username directly by using plain text or
   * specify an encrypted username by using a Secret Manager secret:
   * `projects/* /secrets/* /versions/*`. However, using a secret is
   * recommended for enhanced security.
   *
   * Caution: If you specify the username using plain text, you risk the
   * username being exposed to any users who can view the job or its logs.
   * To avoid this risk, specify a secret that contains the username instead.
   *
   * Learn more about [Secret
   * Manager](https://cloud.google.com/secret-manager/docs/) and [using
   * Secret Manager with
   * Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
   */
  username: string;
  /**
   * Required if the container image is from a private Docker registry. The
   * password to login to the Docker registry that contains the image.
   *
   * For security, it is strongly recommended to specify an
   * encrypted password by using a Secret Manager secret:
   * `projects/* /secrets/* /versions/*`.
   *
   * Warning: If you specify the password using plain text, you risk the
   * password being exposed to any users who can view the job or its logs.
   * To avoid this risk, specify a secret that contains the password instead.
   *
   * Learn more about [Secret
   * Manager](https://cloud.google.com/secret-manager/docs/) and [using
   * Secret Manager with
   * Batch](https://cloud.google.com/batch/docs/create-run-job-secret-manager).
   */
  password: string;
  /**
   * Optional. If set to true, this container runnable uses Image streaming.
   *
   * Use Image streaming to allow the runnable to initialize without
   * waiting for the entire container image to download, which can
   * significantly reduce startup time for large container images.
   *
   * When `enableImageStreaming` is set to true, the container
   * runtime is [containerd](https://containerd.io/) instead of Docker.
   * Additionally, this container runnable only supports the following
   * `container` subfields: `imageUri`,
   * `commands[]`, `entrypoint`, and
   * `volumes[]`; any other `container` subfields are ignored.
   *
   * For more information about the requirements and limitations for using
   * Image streaming with Batch, see the [`image-streaming`
   * sample on
   * GitHub](https://github.com/GoogleCloudPlatform/batch-samples/tree/main/api-samples/image-streaming).
   */
  enableImageStreaming: boolean;
}

/** Script runnable. */
export interface Runnable_Script {
  /**
   * The path to a script file that is accessible from the host VM(s).
   *
   * Unless the script file supports the default `#!/bin/sh` shell
   * interpreter, you must specify an interpreter by including a
   * [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix) as the
   * first line of the file. For example, to execute the script using bash,
   * include `#!/bin/bash` as the first line of the file. Alternatively,
   * to execute the script using Python3, include `#!/usr/bin/env python3`
   * as the first line of the file.
   */
  path?:
    | string
    | undefined;
  /**
   * The text for a script.
   *
   * Unless the script text supports the default `#!/bin/sh` shell
   * interpreter, you must specify an interpreter by including a
   * [shebang line](https://en.wikipedia.org/wiki/Shebang_(Unix) at the
   * beginning of the text. For example, to execute the script using bash,
   * include `#!/bin/bash\n` at the beginning of the text. Alternatively,
   * to execute the script using Python3, include `#!/usr/bin/env python3\n`
   * at the beginning of the text.
   */
  text?: string | undefined;
}

/**
 * A barrier runnable automatically blocks the execution of subsequent
 * runnables until all the tasks in the task group reach the barrier.
 */
export interface Runnable_Barrier {
  /**
   * Barriers are identified by their index in runnable list.
   * Names are not required, but if present should be an identifier.
   */
  name: string;
}

export interface Runnable_LabelsEntry {
  key: string;
  value: string;
}

/** Spec of a task */
export interface TaskSpec {
  /**
   * Required. The sequence of one or more runnables (executable scripts,
   * executable containers, and/or barriers) for each task in this task group to
   * run. Each task runs this list of runnables in order. For a task to succeed,
   * all of its script and container runnables each must meet at least one of
   * the following conditions:
   *
   * + The runnable exited with a zero status.
   * + The runnable didn't finish, but you enabled its `background` subfield.
   * + The runnable exited with a non-zero status, but you enabled its
   *   `ignore_exit_status` subfield.
   */
  runnables: Runnable[];
  /** ComputeResource requirements. */
  computeResource:
    | ComputeResource
    | undefined;
  /**
   * Maximum duration the task should run before being automatically retried
   * (if enabled) or automatically failed. Format the value of this field
   * as a time limit in seconds followed by `s`&mdash;for example, `3600s`
   * for 1 hour. The field accepts any value between 0 and the maximum listed
   * for the `Duration` field type at
   * https://protobuf.dev/reference/protobuf/google.protobuf/#duration; however,
   * the actual maximum run time for a job will be limited to the maximum run
   * time for a job listed at
   * https://cloud.google.com/batch/quotas#max-job-duration.
   */
  maxRunDuration:
    | Duration
    | undefined;
  /**
   * Maximum number of retries on failures.
   * The default, 0, which means never retry.
   * The valid value range is [0, 10].
   */
  maxRetryCount: number;
  /**
   * Lifecycle management schema when any task in a task group is failed.
   * Currently we only support one lifecycle policy.
   * When the lifecycle policy condition is met,
   * the action in the policy will execute.
   * If task execution result does not meet with the defined lifecycle
   * policy, we consider it as the default policy.
   * Default policy means if the exit code is 0, exit task.
   * If task ends with non-zero exit code, retry the task with max_retry_count.
   */
  lifecyclePolicies: LifecyclePolicy[];
  /**
   * Deprecated: please use environment(non-plural) instead.
   *
   * @deprecated
   */
  environments: { [key: string]: string };
  /** Volumes to mount before running Tasks using this TaskSpec. */
  volumes: Volume[];
  /** Environment variables to set before running the Task. */
  environment: Environment | undefined;
}

export interface TaskSpec_EnvironmentsEntry {
  key: string;
  value: string;
}

/**
 * LifecyclePolicy describes how to deal with task failures
 * based on different conditions.
 */
export interface LifecyclePolicy {
  /**
   * Action to execute when ActionCondition is true.
   * When RETRY_TASK is specified, we will retry failed tasks
   * if we notice any exit code match and fail tasks if no match is found.
   * Likewise, when FAIL_TASK is specified, we will fail tasks
   * if we notice any exit code match and retry tasks if no match is found.
   */
  action: LifecyclePolicy_Action;
  /** Conditions that decide why a task failure is dealt with a specific action. */
  actionCondition: LifecyclePolicy_ActionCondition | undefined;
}

/** Action on task failures based on different conditions. */
export enum LifecyclePolicy_Action {
  /** ACTION_UNSPECIFIED - Action unspecified. */
  ACTION_UNSPECIFIED = 0,
  /** RETRY_TASK - Action that tasks in the group will be scheduled to re-execute. */
  RETRY_TASK = 1,
  /** FAIL_TASK - Action that tasks in the group will be stopped immediately. */
  FAIL_TASK = 2,
  UNRECOGNIZED = -1,
}

export function lifecyclePolicy_ActionFromJSON(object: any): LifecyclePolicy_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return LifecyclePolicy_Action.ACTION_UNSPECIFIED;
    case 1:
    case "RETRY_TASK":
      return LifecyclePolicy_Action.RETRY_TASK;
    case 2:
    case "FAIL_TASK":
      return LifecyclePolicy_Action.FAIL_TASK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LifecyclePolicy_Action.UNRECOGNIZED;
  }
}

export function lifecyclePolicy_ActionToJSON(object: LifecyclePolicy_Action): string {
  switch (object) {
    case LifecyclePolicy_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case LifecyclePolicy_Action.RETRY_TASK:
      return "RETRY_TASK";
    case LifecyclePolicy_Action.FAIL_TASK:
      return "FAIL_TASK";
    case LifecyclePolicy_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Conditions for actions to deal with task failures. */
export interface LifecyclePolicy_ActionCondition {
  /**
   * Exit codes of a task execution.
   * If there are more than 1 exit codes,
   * when task executes with any of the exit code in the list,
   * the condition is met and the action will be executed.
   */
  exitCodes: number[];
}

/** A Cloud Batch task. */
export interface Task {
  /**
   * Task name.
   * The name is generated from the parent TaskGroup name and 'id' field.
   * For example:
   * "projects/123456/locations/us-west1/jobs/job01/taskGroups/group01/tasks/task01".
   */
  name: string;
  /** Task Status. */
  status: TaskStatus | undefined;
}

/**
 * An Environment describes a collection of environment variables to set when
 * executing Tasks.
 */
export interface Environment {
  /** A map of environment variable names to values. */
  variables: { [key: string]: string };
  /**
   * A map of environment variable names to Secret Manager secret names.
   * The VM will access the named secrets to set the value of each environment
   * variable.
   */
  secretVariables: { [key: string]: string };
  /**
   * An encrypted JSON dictionary where the key/value pairs correspond to
   * environment variable names and their values.
   */
  encryptedVariables: Environment_KMSEnvMap | undefined;
}

export interface Environment_KMSEnvMap {
  /** The name of the KMS key that will be used to decrypt the cipher text. */
  keyName: string;
  /** The value of the cipherText response from the `encrypt` method. */
  cipherText: string;
}

export interface Environment_VariablesEntry {
  key: string;
  value: string;
}

export interface Environment_SecretVariablesEntry {
  key: string;
  value: string;
}

function createBaseComputeResource(): ComputeResource {
  return { cpuMilli: Long.ZERO, memoryMib: Long.ZERO, bootDiskMib: Long.ZERO };
}

export const ComputeResource: MessageFns<ComputeResource> = {
  encode(message: ComputeResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.cpuMilli.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.cpuMilli.toString());
    }
    if (!message.memoryMib.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.memoryMib.toString());
    }
    if (!message.bootDiskMib.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.bootDiskMib.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cpuMilli = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.memoryMib = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bootDiskMib = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeResource {
    return {
      cpuMilli: isSet(object.cpuMilli) ? Long.fromValue(object.cpuMilli) : Long.ZERO,
      memoryMib: isSet(object.memoryMib) ? Long.fromValue(object.memoryMib) : Long.ZERO,
      bootDiskMib: isSet(object.bootDiskMib) ? Long.fromValue(object.bootDiskMib) : Long.ZERO,
    };
  },

  toJSON(message: ComputeResource): unknown {
    const obj: any = {};
    if (!message.cpuMilli.equals(Long.ZERO)) {
      obj.cpuMilli = (message.cpuMilli || Long.ZERO).toString();
    }
    if (!message.memoryMib.equals(Long.ZERO)) {
      obj.memoryMib = (message.memoryMib || Long.ZERO).toString();
    }
    if (!message.bootDiskMib.equals(Long.ZERO)) {
      obj.bootDiskMib = (message.bootDiskMib || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeResource>): ComputeResource {
    return ComputeResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeResource>): ComputeResource {
    const message = createBaseComputeResource();
    message.cpuMilli = (object.cpuMilli !== undefined && object.cpuMilli !== null)
      ? Long.fromValue(object.cpuMilli)
      : Long.ZERO;
    message.memoryMib = (object.memoryMib !== undefined && object.memoryMib !== null)
      ? Long.fromValue(object.memoryMib)
      : Long.ZERO;
    message.bootDiskMib = (object.bootDiskMib !== undefined && object.bootDiskMib !== null)
      ? Long.fromValue(object.bootDiskMib)
      : Long.ZERO;
    return message;
  },
};

function createBaseStatusEvent(): StatusEvent {
  return { type: "", description: "", eventTime: undefined, taskExecution: undefined, taskState: 0 };
}

export const StatusEvent: MessageFns<StatusEvent> = {
  encode(message: StatusEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(18).fork()).join();
    }
    if (message.taskExecution !== undefined) {
      TaskExecution.encode(message.taskExecution, writer.uint32(34).fork()).join();
    }
    if (message.taskState !== 0) {
      writer.uint32(40).int32(message.taskState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskExecution = TaskExecution.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.taskState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusEvent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      taskExecution: isSet(object.taskExecution) ? TaskExecution.fromJSON(object.taskExecution) : undefined,
      taskState: isSet(object.taskState) ? taskStatus_StateFromJSON(object.taskState) : 0,
    };
  },

  toJSON(message: StatusEvent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.taskExecution !== undefined) {
      obj.taskExecution = TaskExecution.toJSON(message.taskExecution);
    }
    if (message.taskState !== 0) {
      obj.taskState = taskStatus_StateToJSON(message.taskState);
    }
    return obj;
  },

  create(base?: DeepPartial<StatusEvent>): StatusEvent {
    return StatusEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusEvent>): StatusEvent {
    const message = createBaseStatusEvent();
    message.type = object.type ?? "";
    message.description = object.description ?? "";
    message.eventTime = object.eventTime ?? undefined;
    message.taskExecution = (object.taskExecution !== undefined && object.taskExecution !== null)
      ? TaskExecution.fromPartial(object.taskExecution)
      : undefined;
    message.taskState = object.taskState ?? 0;
    return message;
  },
};

function createBaseTaskExecution(): TaskExecution {
  return { exitCode: 0 };
}

export const TaskExecution: MessageFns<TaskExecution> = {
  encode(message: TaskExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskExecution {
    return { exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0 };
  },

  toJSON(message: TaskExecution): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskExecution>): TaskExecution {
    return TaskExecution.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskExecution>): TaskExecution {
    const message = createBaseTaskExecution();
    message.exitCode = object.exitCode ?? 0;
    return message;
  },
};

function createBaseTaskStatus(): TaskStatus {
  return { state: 0, statusEvents: [] };
}

export const TaskStatus: MessageFns<TaskStatus> = {
  encode(message: TaskStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    for (const v of message.statusEvents) {
      StatusEvent.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statusEvents.push(StatusEvent.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskStatus {
    return {
      state: isSet(object.state) ? taskStatus_StateFromJSON(object.state) : 0,
      statusEvents: globalThis.Array.isArray(object?.statusEvents)
        ? object.statusEvents.map((e: any) => StatusEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = taskStatus_StateToJSON(message.state);
    }
    if (message.statusEvents?.length) {
      obj.statusEvents = message.statusEvents.map((e) => StatusEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskStatus>): TaskStatus {
    return TaskStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskStatus>): TaskStatus {
    const message = createBaseTaskStatus();
    message.state = object.state ?? 0;
    message.statusEvents = object.statusEvents?.map((e) => StatusEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunnable(): Runnable {
  return {
    container: undefined,
    script: undefined,
    barrier: undefined,
    displayName: "",
    ignoreExitStatus: false,
    background: false,
    alwaysRun: false,
    environment: undefined,
    timeout: undefined,
    labels: {},
  };
}

export const Runnable: MessageFns<Runnable> = {
  encode(message: Runnable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.container !== undefined) {
      Runnable_Container.encode(message.container, writer.uint32(10).fork()).join();
    }
    if (message.script !== undefined) {
      Runnable_Script.encode(message.script, writer.uint32(18).fork()).join();
    }
    if (message.barrier !== undefined) {
      Runnable_Barrier.encode(message.barrier, writer.uint32(50).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(82).string(message.displayName);
    }
    if (message.ignoreExitStatus !== false) {
      writer.uint32(24).bool(message.ignoreExitStatus);
    }
    if (message.background !== false) {
      writer.uint32(32).bool(message.background);
    }
    if (message.alwaysRun !== false) {
      writer.uint32(40).bool(message.alwaysRun);
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Runnable_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runnable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.container = Runnable_Container.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.script = Runnable_Script.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.barrier = Runnable_Barrier.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ignoreExitStatus = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.background = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.alwaysRun = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Runnable_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runnable {
    return {
      container: isSet(object.container) ? Runnable_Container.fromJSON(object.container) : undefined,
      script: isSet(object.script) ? Runnable_Script.fromJSON(object.script) : undefined,
      barrier: isSet(object.barrier) ? Runnable_Barrier.fromJSON(object.barrier) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      ignoreExitStatus: isSet(object.ignoreExitStatus) ? globalThis.Boolean(object.ignoreExitStatus) : false,
      background: isSet(object.background) ? globalThis.Boolean(object.background) : false,
      alwaysRun: isSet(object.alwaysRun) ? globalThis.Boolean(object.alwaysRun) : false,
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Runnable): unknown {
    const obj: any = {};
    if (message.container !== undefined) {
      obj.container = Runnable_Container.toJSON(message.container);
    }
    if (message.script !== undefined) {
      obj.script = Runnable_Script.toJSON(message.script);
    }
    if (message.barrier !== undefined) {
      obj.barrier = Runnable_Barrier.toJSON(message.barrier);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.ignoreExitStatus !== false) {
      obj.ignoreExitStatus = message.ignoreExitStatus;
    }
    if (message.background !== false) {
      obj.background = message.background;
    }
    if (message.alwaysRun !== false) {
      obj.alwaysRun = message.alwaysRun;
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Runnable>): Runnable {
    return Runnable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runnable>): Runnable {
    const message = createBaseRunnable();
    message.container = (object.container !== undefined && object.container !== null)
      ? Runnable_Container.fromPartial(object.container)
      : undefined;
    message.script = (object.script !== undefined && object.script !== null)
      ? Runnable_Script.fromPartial(object.script)
      : undefined;
    message.barrier = (object.barrier !== undefined && object.barrier !== null)
      ? Runnable_Barrier.fromPartial(object.barrier)
      : undefined;
    message.displayName = object.displayName ?? "";
    message.ignoreExitStatus = object.ignoreExitStatus ?? false;
    message.background = object.background ?? false;
    message.alwaysRun = object.alwaysRun ?? false;
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRunnable_Container(): Runnable_Container {
  return {
    imageUri: "",
    commands: [],
    entrypoint: "",
    volumes: [],
    options: "",
    blockExternalNetwork: false,
    username: "",
    password: "",
    enableImageStreaming: false,
  };
}

export const Runnable_Container: MessageFns<Runnable_Container> = {
  encode(message: Runnable_Container, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageUri !== "") {
      writer.uint32(10).string(message.imageUri);
    }
    for (const v of message.commands) {
      writer.uint32(18).string(v!);
    }
    if (message.entrypoint !== "") {
      writer.uint32(26).string(message.entrypoint);
    }
    for (const v of message.volumes) {
      writer.uint32(58).string(v!);
    }
    if (message.options !== "") {
      writer.uint32(66).string(message.options);
    }
    if (message.blockExternalNetwork !== false) {
      writer.uint32(72).bool(message.blockExternalNetwork);
    }
    if (message.username !== "") {
      writer.uint32(82).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(90).string(message.password);
    }
    if (message.enableImageStreaming !== false) {
      writer.uint32(96).bool(message.enableImageStreaming);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runnable_Container {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnable_Container();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imageUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commands.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.volumes.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.options = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.blockExternalNetwork = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.username = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.password = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableImageStreaming = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runnable_Container {
    return {
      imageUri: isSet(object.imageUri) ? globalThis.String(object.imageUri) : "",
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e: any) => globalThis.String(e)) : [],
      entrypoint: isSet(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => globalThis.String(e)) : [],
      options: isSet(object.options) ? globalThis.String(object.options) : "",
      blockExternalNetwork: isSet(object.blockExternalNetwork)
        ? globalThis.Boolean(object.blockExternalNetwork)
        : false,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      enableImageStreaming: isSet(object.enableImageStreaming)
        ? globalThis.Boolean(object.enableImageStreaming)
        : false,
    };
  },

  toJSON(message: Runnable_Container): unknown {
    const obj: any = {};
    if (message.imageUri !== "") {
      obj.imageUri = message.imageUri;
    }
    if (message.commands?.length) {
      obj.commands = message.commands;
    }
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes;
    }
    if (message.options !== "") {
      obj.options = message.options;
    }
    if (message.blockExternalNetwork !== false) {
      obj.blockExternalNetwork = message.blockExternalNetwork;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.enableImageStreaming !== false) {
      obj.enableImageStreaming = message.enableImageStreaming;
    }
    return obj;
  },

  create(base?: DeepPartial<Runnable_Container>): Runnable_Container {
    return Runnable_Container.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runnable_Container>): Runnable_Container {
    const message = createBaseRunnable_Container();
    message.imageUri = object.imageUri ?? "";
    message.commands = object.commands?.map((e) => e) || [];
    message.entrypoint = object.entrypoint ?? "";
    message.volumes = object.volumes?.map((e) => e) || [];
    message.options = object.options ?? "";
    message.blockExternalNetwork = object.blockExternalNetwork ?? false;
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.enableImageStreaming = object.enableImageStreaming ?? false;
    return message;
  },
};

function createBaseRunnable_Script(): Runnable_Script {
  return { path: undefined, text: undefined };
}

export const Runnable_Script: MessageFns<Runnable_Script> = {
  encode(message: Runnable_Script, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined) {
      writer.uint32(10).string(message.path);
    }
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runnable_Script {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnable_Script();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runnable_Script {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
    };
  },

  toJSON(message: Runnable_Script): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<Runnable_Script>): Runnable_Script {
    return Runnable_Script.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runnable_Script>): Runnable_Script {
    const message = createBaseRunnable_Script();
    message.path = object.path ?? undefined;
    message.text = object.text ?? undefined;
    return message;
  },
};

function createBaseRunnable_Barrier(): Runnable_Barrier {
  return { name: "" };
}

export const Runnable_Barrier: MessageFns<Runnable_Barrier> = {
  encode(message: Runnable_Barrier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runnable_Barrier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnable_Barrier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runnable_Barrier {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Runnable_Barrier): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Runnable_Barrier>): Runnable_Barrier {
    return Runnable_Barrier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runnable_Barrier>): Runnable_Barrier {
    const message = createBaseRunnable_Barrier();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRunnable_LabelsEntry(): Runnable_LabelsEntry {
  return { key: "", value: "" };
}

export const Runnable_LabelsEntry: MessageFns<Runnable_LabelsEntry> = {
  encode(message: Runnable_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Runnable_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnable_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Runnable_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Runnable_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Runnable_LabelsEntry>): Runnable_LabelsEntry {
    return Runnable_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Runnable_LabelsEntry>): Runnable_LabelsEntry {
    const message = createBaseRunnable_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTaskSpec(): TaskSpec {
  return {
    runnables: [],
    computeResource: undefined,
    maxRunDuration: undefined,
    maxRetryCount: 0,
    lifecyclePolicies: [],
    environments: {},
    volumes: [],
    environment: undefined,
  };
}

export const TaskSpec: MessageFns<TaskSpec> = {
  encode(message: TaskSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runnables) {
      Runnable.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.computeResource !== undefined) {
      ComputeResource.encode(message.computeResource, writer.uint32(26).fork()).join();
    }
    if (message.maxRunDuration !== undefined) {
      Duration.encode(message.maxRunDuration, writer.uint32(34).fork()).join();
    }
    if (message.maxRetryCount !== 0) {
      writer.uint32(40).int32(message.maxRetryCount);
    }
    for (const v of message.lifecyclePolicies) {
      LifecyclePolicy.encode(v!, writer.uint32(74).fork()).join();
    }
    Object.entries(message.environments).forEach(([key, value]) => {
      TaskSpec_EnvironmentsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.environment !== undefined) {
      Environment.encode(message.environment, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.runnables.push(Runnable.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.computeResource = ComputeResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxRunDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxRetryCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lifecyclePolicies.push(LifecyclePolicy.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = TaskSpec_EnvironmentsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.environments[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.environment = Environment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskSpec {
    return {
      runnables: globalThis.Array.isArray(object?.runnables)
        ? object.runnables.map((e: any) => Runnable.fromJSON(e))
        : [],
      computeResource: isSet(object.computeResource) ? ComputeResource.fromJSON(object.computeResource) : undefined,
      maxRunDuration: isSet(object.maxRunDuration) ? Duration.fromJSON(object.maxRunDuration) : undefined,
      maxRetryCount: isSet(object.maxRetryCount) ? globalThis.Number(object.maxRetryCount) : 0,
      lifecyclePolicies: globalThis.Array.isArray(object?.lifecyclePolicies)
        ? object.lifecyclePolicies.map((e: any) => LifecyclePolicy.fromJSON(e))
        : [],
      environments: isObject(object.environments)
        ? Object.entries(object.environments).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
      environment: isSet(object.environment) ? Environment.fromJSON(object.environment) : undefined,
    };
  },

  toJSON(message: TaskSpec): unknown {
    const obj: any = {};
    if (message.runnables?.length) {
      obj.runnables = message.runnables.map((e) => Runnable.toJSON(e));
    }
    if (message.computeResource !== undefined) {
      obj.computeResource = ComputeResource.toJSON(message.computeResource);
    }
    if (message.maxRunDuration !== undefined) {
      obj.maxRunDuration = Duration.toJSON(message.maxRunDuration);
    }
    if (message.maxRetryCount !== 0) {
      obj.maxRetryCount = Math.round(message.maxRetryCount);
    }
    if (message.lifecyclePolicies?.length) {
      obj.lifecyclePolicies = message.lifecyclePolicies.map((e) => LifecyclePolicy.toJSON(e));
    }
    if (message.environments) {
      const entries = Object.entries(message.environments);
      if (entries.length > 0) {
        obj.environments = {};
        entries.forEach(([k, v]) => {
          obj.environments[k] = v;
        });
      }
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e));
    }
    if (message.environment !== undefined) {
      obj.environment = Environment.toJSON(message.environment);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskSpec>): TaskSpec {
    return TaskSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskSpec>): TaskSpec {
    const message = createBaseTaskSpec();
    message.runnables = object.runnables?.map((e) => Runnable.fromPartial(e)) || [];
    message.computeResource = (object.computeResource !== undefined && object.computeResource !== null)
      ? ComputeResource.fromPartial(object.computeResource)
      : undefined;
    message.maxRunDuration = (object.maxRunDuration !== undefined && object.maxRunDuration !== null)
      ? Duration.fromPartial(object.maxRunDuration)
      : undefined;
    message.maxRetryCount = object.maxRetryCount ?? 0;
    message.lifecyclePolicies = object.lifecyclePolicies?.map((e) => LifecyclePolicy.fromPartial(e)) || [];
    message.environments = Object.entries(object.environments ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || [];
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? Environment.fromPartial(object.environment)
      : undefined;
    return message;
  },
};

function createBaseTaskSpec_EnvironmentsEntry(): TaskSpec_EnvironmentsEntry {
  return { key: "", value: "" };
}

export const TaskSpec_EnvironmentsEntry: MessageFns<TaskSpec_EnvironmentsEntry> = {
  encode(message: TaskSpec_EnvironmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskSpec_EnvironmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskSpec_EnvironmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskSpec_EnvironmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TaskSpec_EnvironmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskSpec_EnvironmentsEntry>): TaskSpec_EnvironmentsEntry {
    return TaskSpec_EnvironmentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskSpec_EnvironmentsEntry>): TaskSpec_EnvironmentsEntry {
    const message = createBaseTaskSpec_EnvironmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLifecyclePolicy(): LifecyclePolicy {
  return { action: 0, actionCondition: undefined };
}

export const LifecyclePolicy: MessageFns<LifecyclePolicy> = {
  encode(message: LifecyclePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.actionCondition !== undefined) {
      LifecyclePolicy_ActionCondition.encode(message.actionCondition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LifecyclePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifecyclePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionCondition = LifecyclePolicy_ActionCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LifecyclePolicy {
    return {
      action: isSet(object.action) ? lifecyclePolicy_ActionFromJSON(object.action) : 0,
      actionCondition: isSet(object.actionCondition)
        ? LifecyclePolicy_ActionCondition.fromJSON(object.actionCondition)
        : undefined,
    };
  },

  toJSON(message: LifecyclePolicy): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = lifecyclePolicy_ActionToJSON(message.action);
    }
    if (message.actionCondition !== undefined) {
      obj.actionCondition = LifecyclePolicy_ActionCondition.toJSON(message.actionCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<LifecyclePolicy>): LifecyclePolicy {
    return LifecyclePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LifecyclePolicy>): LifecyclePolicy {
    const message = createBaseLifecyclePolicy();
    message.action = object.action ?? 0;
    message.actionCondition = (object.actionCondition !== undefined && object.actionCondition !== null)
      ? LifecyclePolicy_ActionCondition.fromPartial(object.actionCondition)
      : undefined;
    return message;
  },
};

function createBaseLifecyclePolicy_ActionCondition(): LifecyclePolicy_ActionCondition {
  return { exitCodes: [] };
}

export const LifecyclePolicy_ActionCondition: MessageFns<LifecyclePolicy_ActionCondition> = {
  encode(message: LifecyclePolicy_ActionCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.exitCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LifecyclePolicy_ActionCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifecyclePolicy_ActionCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.exitCodes.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.exitCodes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LifecyclePolicy_ActionCondition {
    return {
      exitCodes: globalThis.Array.isArray(object?.exitCodes)
        ? object.exitCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: LifecyclePolicy_ActionCondition): unknown {
    const obj: any = {};
    if (message.exitCodes?.length) {
      obj.exitCodes = message.exitCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LifecyclePolicy_ActionCondition>): LifecyclePolicy_ActionCondition {
    return LifecyclePolicy_ActionCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LifecyclePolicy_ActionCondition>): LifecyclePolicy_ActionCondition {
    const message = createBaseLifecyclePolicy_ActionCondition();
    message.exitCodes = object.exitCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseTask(): Task {
  return { name: "", status: undefined };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.status !== undefined) {
      TaskStatus.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = TaskStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? TaskStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== undefined) {
      obj.status = TaskStatus.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<Task>): Task {
    return Task.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Task>): Task {
    const message = createBaseTask();
    message.name = object.name ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? TaskStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseEnvironment(): Environment {
  return { variables: {}, secretVariables: {}, encryptedVariables: undefined };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.variables).forEach(([key, value]) => {
      Environment_VariablesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.secretVariables).forEach(([key, value]) => {
      Environment_SecretVariablesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.encryptedVariables !== undefined) {
      Environment_KMSEnvMap.encode(message.encryptedVariables, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Environment_VariablesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.variables[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Environment_SecretVariablesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.secretVariables[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.encryptedVariables = Environment_KMSEnvMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      variables: isObject(object.variables)
        ? Object.entries(object.variables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      secretVariables: isObject(object.secretVariables)
        ? Object.entries(object.secretVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      encryptedVariables: isSet(object.encryptedVariables)
        ? Environment_KMSEnvMap.fromJSON(object.encryptedVariables)
        : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.variables) {
      const entries = Object.entries(message.variables);
      if (entries.length > 0) {
        obj.variables = {};
        entries.forEach(([k, v]) => {
          obj.variables[k] = v;
        });
      }
    }
    if (message.secretVariables) {
      const entries = Object.entries(message.secretVariables);
      if (entries.length > 0) {
        obj.secretVariables = {};
        entries.forEach(([k, v]) => {
          obj.secretVariables[k] = v;
        });
      }
    }
    if (message.encryptedVariables !== undefined) {
      obj.encryptedVariables = Environment_KMSEnvMap.toJSON(message.encryptedVariables);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.variables = Object.entries(object.variables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.secretVariables = Object.entries(object.secretVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.encryptedVariables = (object.encryptedVariables !== undefined && object.encryptedVariables !== null)
      ? Environment_KMSEnvMap.fromPartial(object.encryptedVariables)
      : undefined;
    return message;
  },
};

function createBaseEnvironment_KMSEnvMap(): Environment_KMSEnvMap {
  return { keyName: "", cipherText: "" };
}

export const Environment_KMSEnvMap: MessageFns<Environment_KMSEnvMap> = {
  encode(message: Environment_KMSEnvMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyName !== "") {
      writer.uint32(10).string(message.keyName);
    }
    if (message.cipherText !== "") {
      writer.uint32(18).string(message.cipherText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_KMSEnvMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_KMSEnvMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cipherText = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_KMSEnvMap {
    return {
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      cipherText: isSet(object.cipherText) ? globalThis.String(object.cipherText) : "",
    };
  },

  toJSON(message: Environment_KMSEnvMap): unknown {
    const obj: any = {};
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.cipherText !== "") {
      obj.cipherText = message.cipherText;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_KMSEnvMap>): Environment_KMSEnvMap {
    return Environment_KMSEnvMap.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_KMSEnvMap>): Environment_KMSEnvMap {
    const message = createBaseEnvironment_KMSEnvMap();
    message.keyName = object.keyName ?? "";
    message.cipherText = object.cipherText ?? "";
    return message;
  },
};

function createBaseEnvironment_VariablesEntry(): Environment_VariablesEntry {
  return { key: "", value: "" };
}

export const Environment_VariablesEntry: MessageFns<Environment_VariablesEntry> = {
  encode(message: Environment_VariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_VariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_VariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Environment_VariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_VariablesEntry>): Environment_VariablesEntry {
    return Environment_VariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_VariablesEntry>): Environment_VariablesEntry {
    const message = createBaseEnvironment_VariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnvironment_SecretVariablesEntry(): Environment_SecretVariablesEntry {
  return { key: "", value: "" };
}

export const Environment_SecretVariablesEntry: MessageFns<Environment_SecretVariablesEntry> = {
  encode(message: Environment_SecretVariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_SecretVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_SecretVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_SecretVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Environment_SecretVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_SecretVariablesEntry>): Environment_SecretVariablesEntry {
    return Environment_SecretVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_SecretVariablesEntry>): Environment_SecretVariablesEntry {
    const message = createBaseEnvironment_SecretVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
