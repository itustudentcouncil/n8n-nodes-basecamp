// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkservices/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.networkservices.v1";

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** Specification of a port-based selector. */
export interface TrafficPortSelector {
  /**
   * Optional. A list of ports. Can be port numbers or port range
   * (example, [80-90] specifies all ports from 80 to 90, including
   * 80 and 90) or named ports or * to specify all ports. If the
   * list is empty, all ports are selected.
   */
  ports: string[];
}

/**
 * A definition of a matcher that selects endpoints to which the policies
 * should be applied.
 */
export interface EndpointMatcher {
  /** The matcher is based on node metadata presented by xDS clients. */
  metadataLabelMatcher?: EndpointMatcher_MetadataLabelMatcher | undefined;
}

/** The matcher that is based on node metadata presented by xDS clients. */
export interface EndpointMatcher_MetadataLabelMatcher {
  /**
   * Specifies how matching should be done.
   *
   * Supported values are:
   * MATCH_ANY: At least one of the Labels specified in the
   *   matcher should match the metadata presented by xDS client.
   * MATCH_ALL: The metadata presented by the xDS client should
   *   contain all of the labels specified here.
   *
   * The selection is determined based on the best match. For
   * example, suppose there are three EndpointPolicy
   * resources P1, P2 and P3 and if P1 has a the matcher as
   * MATCH_ANY <A:1, B:1>, P2 has MATCH_ALL <A:1,B:1>, and P3 has
   * MATCH_ALL <A:1,B:1,C:1>.
   *
   * If a client with label <A:1> connects, the config from P1
   * will be selected.
   *
   * If a client with label <A:1,B:1> connects, the config from P2
   * will be selected.
   *
   * If a client with label <A:1,B:1,C:1> connects, the config
   * from P3 will be selected.
   *
   * If there is more than one best match, (for example, if a
   * config P4 with selector <A:1,D:1> exists and if a client with
   * label <A:1,B:1,D:1> connects), an error will be thrown.
   */
  metadataLabelMatchCriteria: EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria;
  /**
   * The list of label value pairs that must match labels in the
   * provided metadata based on filterMatchCriteria This list can
   * have at most 64 entries. The list can be empty if the match
   * criteria is MATCH_ANY, to specify a wildcard match (i.e this
   * matches any client).
   */
  metadataLabels: EndpointMatcher_MetadataLabelMatcher_MetadataLabels[];
}

/** Possible criteria values that define logic of how matching is made. */
export enum EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria {
  /** METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED - Default value. Should not be used. */
  METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED = 0,
  /**
   * MATCH_ANY - At least one of the Labels specified in the matcher should match the
   * metadata presented by xDS client.
   */
  MATCH_ANY = 1,
  /**
   * MATCH_ALL - The metadata presented by the xDS client should contain all of the
   * labels specified here.
   */
  MATCH_ALL = 2,
  UNRECOGNIZED = -1,
}

export function endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaFromJSON(
  object: any,
): EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria {
  switch (object) {
    case 0:
    case "METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED;
    case 1:
    case "MATCH_ANY":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ANY;
    case 2:
    case "MATCH_ALL":
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.UNRECOGNIZED;
  }
}

export function endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaToJSON(
  object: EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria,
): string {
  switch (object) {
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED:
      return "METADATA_LABEL_MATCH_CRITERIA_UNSPECIFIED";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ANY:
      return "MATCH_ANY";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.MATCH_ALL:
      return "MATCH_ALL";
    case EndpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteria.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines a name-pair value for a single label. */
export interface EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
  /** Required. Label name presented as key in xDS Node Metadata. */
  labelName: string;
  /**
   * Required. Label value presented as value corresponding to the above
   * key, in xDS Node Metadata.
   */
  labelValue: string;
}

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseTrafficPortSelector(): TrafficPortSelector {
  return { ports: [] };
}

export const TrafficPortSelector: MessageFns<TrafficPortSelector> = {
  encode(message: TrafficPortSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ports) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrafficPortSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrafficPortSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ports.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrafficPortSelector {
    return { ports: globalThis.Array.isArray(object?.ports) ? object.ports.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: TrafficPortSelector): unknown {
    const obj: any = {};
    if (message.ports?.length) {
      obj.ports = message.ports;
    }
    return obj;
  },

  create(base?: DeepPartial<TrafficPortSelector>): TrafficPortSelector {
    return TrafficPortSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrafficPortSelector>): TrafficPortSelector {
    const message = createBaseTrafficPortSelector();
    message.ports = object.ports?.map((e) => e) || [];
    return message;
  },
};

function createBaseEndpointMatcher(): EndpointMatcher {
  return { metadataLabelMatcher: undefined };
}

export const EndpointMatcher: MessageFns<EndpointMatcher> = {
  encode(message: EndpointMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataLabelMatcher !== undefined) {
      EndpointMatcher_MetadataLabelMatcher.encode(message.metadataLabelMatcher, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadataLabelMatcher = EndpointMatcher_MetadataLabelMatcher.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher {
    return {
      metadataLabelMatcher: isSet(object.metadataLabelMatcher)
        ? EndpointMatcher_MetadataLabelMatcher.fromJSON(object.metadataLabelMatcher)
        : undefined,
    };
  },

  toJSON(message: EndpointMatcher): unknown {
    const obj: any = {};
    if (message.metadataLabelMatcher !== undefined) {
      obj.metadataLabelMatcher = EndpointMatcher_MetadataLabelMatcher.toJSON(message.metadataLabelMatcher);
    }
    return obj;
  },

  create(base?: DeepPartial<EndpointMatcher>): EndpointMatcher {
    return EndpointMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndpointMatcher>): EndpointMatcher {
    const message = createBaseEndpointMatcher();
    message.metadataLabelMatcher = (object.metadataLabelMatcher !== undefined && object.metadataLabelMatcher !== null)
      ? EndpointMatcher_MetadataLabelMatcher.fromPartial(object.metadataLabelMatcher)
      : undefined;
    return message;
  },
};

function createBaseEndpointMatcher_MetadataLabelMatcher(): EndpointMatcher_MetadataLabelMatcher {
  return { metadataLabelMatchCriteria: 0, metadataLabels: [] };
}

export const EndpointMatcher_MetadataLabelMatcher: MessageFns<EndpointMatcher_MetadataLabelMatcher> = {
  encode(message: EndpointMatcher_MetadataLabelMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataLabelMatchCriteria !== 0) {
      writer.uint32(8).int32(message.metadataLabelMatchCriteria);
    }
    for (const v of message.metadataLabels) {
      EndpointMatcher_MetadataLabelMatcher_MetadataLabels.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher_MetadataLabelMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher_MetadataLabelMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.metadataLabelMatchCriteria = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadataLabels.push(
            EndpointMatcher_MetadataLabelMatcher_MetadataLabels.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher_MetadataLabelMatcher {
    return {
      metadataLabelMatchCriteria: isSet(object.metadataLabelMatchCriteria)
        ? endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaFromJSON(object.metadataLabelMatchCriteria)
        : 0,
      metadataLabels: globalThis.Array.isArray(object?.metadataLabels)
        ? object.metadataLabels.map((e: any) => EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EndpointMatcher_MetadataLabelMatcher): unknown {
    const obj: any = {};
    if (message.metadataLabelMatchCriteria !== 0) {
      obj.metadataLabelMatchCriteria = endpointMatcher_MetadataLabelMatcher_MetadataLabelMatchCriteriaToJSON(
        message.metadataLabelMatchCriteria,
      );
    }
    if (message.metadataLabels?.length) {
      obj.metadataLabels = message.metadataLabels.map((e) =>
        EndpointMatcher_MetadataLabelMatcher_MetadataLabels.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<EndpointMatcher_MetadataLabelMatcher>): EndpointMatcher_MetadataLabelMatcher {
    return EndpointMatcher_MetadataLabelMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndpointMatcher_MetadataLabelMatcher>): EndpointMatcher_MetadataLabelMatcher {
    const message = createBaseEndpointMatcher_MetadataLabelMatcher();
    message.metadataLabelMatchCriteria = object.metadataLabelMatchCriteria ?? 0;
    message.metadataLabels =
      object.metadataLabels?.map((e) => EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels(): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
  return { labelName: "", labelValue: "" };
}

export const EndpointMatcher_MetadataLabelMatcher_MetadataLabels: MessageFns<
  EndpointMatcher_MetadataLabelMatcher_MetadataLabels
> = {
  encode(
    message: EndpointMatcher_MetadataLabelMatcher_MetadataLabels,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.labelName !== "") {
      writer.uint32(10).string(message.labelName);
    }
    if (message.labelValue !== "") {
      writer.uint32(18).string(message.labelValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.labelName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.labelValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    return {
      labelName: isSet(object.labelName) ? globalThis.String(object.labelName) : "",
      labelValue: isSet(object.labelValue) ? globalThis.String(object.labelValue) : "",
    };
  },

  toJSON(message: EndpointMatcher_MetadataLabelMatcher_MetadataLabels): unknown {
    const obj: any = {};
    if (message.labelName !== "") {
      obj.labelName = message.labelName;
    }
    if (message.labelValue !== "") {
      obj.labelValue = message.labelValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<EndpointMatcher_MetadataLabelMatcher_MetadataLabels>,
  ): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    return EndpointMatcher_MetadataLabelMatcher_MetadataLabels.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EndpointMatcher_MetadataLabelMatcher_MetadataLabels>,
  ): EndpointMatcher_MetadataLabelMatcher_MetadataLabels {
    const message = createBaseEndpointMatcher_MetadataLabelMatcher_MetadataLabels();
    message.labelName = object.labelName ?? "";
    message.labelValue = object.labelValue ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
