// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkservices/v1/grpc_route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.networkservices.v1";

/**
 * GrpcRoute is the resource defining how gRPC traffic routed by a Mesh
 * or Gateway resource is routed.
 */
export interface GrpcRoute {
  /**
   * Required. Name of the GrpcRoute resource. It matches pattern
   * `projects/* /locations/global/grpcRoutes/<grpc_route_name>`
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /** Output only. The timestamp when the resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Set of label tags associated with the GrpcRoute resource. */
  labels: { [key: string]: string };
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /**
   * Required. Service hostnames with an optional port for which this route
   * describes traffic.
   *
   * Format: <hostname>[:<port>]
   *
   * Hostname is the fully qualified domain name of a network host. This matches
   * the RFC 1123 definition of a hostname with 2 notable exceptions:
   *  - IPs are not allowed.
   *  - A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * Hostname can be "precise" which is a domain name without the terminating
   * dot of a network host (e.g. `foo.example.com`) or "wildcard", which is a
   * domain name prefixed with a single wildcard label (e.g. `*.example.com`).
   *
   * Note that as per RFC1035 and RFC1123, a label must consist of lower case
   * alphanumeric characters or '-', and must start and end with an alphanumeric
   * character. No other punctuation is allowed.
   *
   * The routes associated with a Mesh or Gateway must have unique hostnames. If
   * you attempt to attach multiple routes with conflicting hostnames, the
   * configuration will be rejected.
   *
   * For example, while it is acceptable for routes for the hostnames
   * `*.foo.bar.com` and `*.bar.com` to be associated with the same route, it is
   * not possible to associate two routes both with `*.bar.com` or both with
   * `bar.com`.
   *
   * If a port is specified, then gRPC clients must use the channel URI with the
   * port to match this rule (i.e. "xds:///service:123"), otherwise they must
   * supply the URI without a port (i.e. "xds:///service").
   */
  hostnames: string[];
  /**
   * Optional. Meshes defines a list of meshes this GrpcRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this GrpcRoute is attached
   * to, as one of the routing rules to route the requests served by the
   * gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
  /**
   * Required. A list of detailed rules defining how to route traffic.
   *
   * Within a single GrpcRoute, the GrpcRoute.RouteAction associated with the
   * first matching GrpcRoute.RouteRule will be executed. At least one rule
   * must be supplied.
   */
  rules: GrpcRoute_RouteRule[];
}

/** Specifies a match against a method. */
export interface GrpcRoute_MethodMatch {
  /**
   * Optional. Specifies how to match against the name. If not specified, a
   * default value of "EXACT" is used.
   */
  type: GrpcRoute_MethodMatch_Type;
  /**
   * Required. Name of the service to match against. If unspecified, will
   * match all services.
   */
  grpcService: string;
  /**
   * Required. Name of the method to match against. If unspecified, will match
   * all methods.
   */
  grpcMethod: string;
  /**
   * Optional. Specifies that matches are case sensitive.  The default value
   * is true. case_sensitive must not be used with a type of
   * REGULAR_EXPRESSION.
   */
  caseSensitive?: boolean | undefined;
}

/** The type of the match. */
export enum GrpcRoute_MethodMatch_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** EXACT - Will only match the exact name provided. */
  EXACT = 1,
  /**
   * REGULAR_EXPRESSION - Will interpret grpc_method and grpc_service as regexes. RE2 syntax is
   * supported.
   */
  REGULAR_EXPRESSION = 2,
  UNRECOGNIZED = -1,
}

export function grpcRoute_MethodMatch_TypeFromJSON(object: any): GrpcRoute_MethodMatch_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GrpcRoute_MethodMatch_Type.TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return GrpcRoute_MethodMatch_Type.EXACT;
    case 2:
    case "REGULAR_EXPRESSION":
      return GrpcRoute_MethodMatch_Type.REGULAR_EXPRESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GrpcRoute_MethodMatch_Type.UNRECOGNIZED;
  }
}

export function grpcRoute_MethodMatch_TypeToJSON(object: GrpcRoute_MethodMatch_Type): string {
  switch (object) {
    case GrpcRoute_MethodMatch_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GrpcRoute_MethodMatch_Type.EXACT:
      return "EXACT";
    case GrpcRoute_MethodMatch_Type.REGULAR_EXPRESSION:
      return "REGULAR_EXPRESSION";
    case GrpcRoute_MethodMatch_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A match against a collection of headers. */
export interface GrpcRoute_HeaderMatch {
  /**
   * Optional. Specifies how to match against the value of the header. If not
   * specified, a default value of EXACT is used.
   */
  type: GrpcRoute_HeaderMatch_Type;
  /** Required. The key of the header. */
  key: string;
  /** Required. The value of the header. */
  value: string;
}

/** The type of match. */
export enum GrpcRoute_HeaderMatch_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** EXACT - Will only match the exact value provided. */
  EXACT = 1,
  /**
   * REGULAR_EXPRESSION - Will match paths conforming to the prefix specified by value. RE2
   * syntax is supported.
   */
  REGULAR_EXPRESSION = 2,
  UNRECOGNIZED = -1,
}

export function grpcRoute_HeaderMatch_TypeFromJSON(object: any): GrpcRoute_HeaderMatch_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GrpcRoute_HeaderMatch_Type.TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return GrpcRoute_HeaderMatch_Type.EXACT;
    case 2:
    case "REGULAR_EXPRESSION":
      return GrpcRoute_HeaderMatch_Type.REGULAR_EXPRESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GrpcRoute_HeaderMatch_Type.UNRECOGNIZED;
  }
}

export function grpcRoute_HeaderMatch_TypeToJSON(object: GrpcRoute_HeaderMatch_Type): string {
  switch (object) {
    case GrpcRoute_HeaderMatch_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GrpcRoute_HeaderMatch_Type.EXACT:
      return "EXACT";
    case GrpcRoute_HeaderMatch_Type.REGULAR_EXPRESSION:
      return "REGULAR_EXPRESSION";
    case GrpcRoute_HeaderMatch_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Criteria for matching traffic. A RouteMatch will be considered to match
 * when all supplied fields match.
 */
export interface GrpcRoute_RouteMatch {
  /**
   * Optional. A gRPC method to match against. If this field is empty or
   * omitted, will match all methods.
   */
  method?:
    | GrpcRoute_MethodMatch
    | undefined;
  /** Optional. Specifies a collection of headers to match. */
  headers: GrpcRoute_HeaderMatch[];
}

/** The destination to which traffic will be routed. */
export interface GrpcRoute_Destination {
  /**
   * Required. The URL of a destination service to which to route traffic.
   * Must refer to either a BackendService or ServiceDirectoryService.
   */
  serviceName?:
    | string
    | undefined;
  /**
   * Optional. Specifies the proportion of requests forwarded to the backend
   * referenced by the serviceName field. This is computed as:
   * - weight/Sum(weights in this destination list).
   * For non-zero values, there may be some epsilon from the exact proportion
   * defined here depending on the precision an implementation supports.
   *
   * If only one serviceName is specified and it has a weight greater than 0,
   * 100% of the traffic is forwarded to that backend.
   *
   * If weights are specified for any one service name, they need to be
   * specified for all of them.
   *
   * If weights are unspecified for all services, then, traffic is distributed
   * in equal proportions to all of them.
   */
  weight?: number | undefined;
}

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to destination service failure. As part of fault
 * injection, when clients send requests to a destination, delays can be
 * introduced on a percentage of requests before sending those requests to the
 * destination service. Similarly requests from clients can be aborted by for
 * a percentage of requests.
 */
export interface GrpcRoute_FaultInjectionPolicy {
  /** The specification for injecting delay to client requests. */
  delay?:
    | GrpcRoute_FaultInjectionPolicy_Delay
    | undefined;
  /** The specification for aborting to client requests. */
  abort?: GrpcRoute_FaultInjectionPolicy_Abort | undefined;
}

/**
 * Specification of how client requests are delayed as part of fault
 * injection before being sent to a destination.
 */
export interface GrpcRoute_FaultInjectionPolicy_Delay {
  /** Specify a fixed delay before forwarding the request. */
  fixedDelay?:
    | Duration
    | undefined;
  /**
   * The percentage of traffic on which delay will be injected.
   *
   * The value must be between [0, 100]
   */
  percentage?: number | undefined;
}

/**
 * Specification of how client requests are aborted as part of fault
 * injection before being sent to a destination.
 */
export interface GrpcRoute_FaultInjectionPolicy_Abort {
  /**
   * The HTTP status code used to abort the request.
   *
   * The value must be between 200 and 599 inclusive.
   */
  httpStatus?:
    | number
    | undefined;
  /**
   * The percentage of traffic which will be aborted.
   *
   * The value must be between [0, 100]
   */
  percentage?: number | undefined;
}

/** The specifications for retries. */
export interface GrpcRoute_RetryPolicy {
  /**
   * - connect-failure: Router will retry on failures connecting to Backend
   *    Services, for example due to connection timeouts.
   * - refused-stream: Router will retry if the backend service resets the
   * stream
   *    with a REFUSED_STREAM error code. This reset type indicates that it is
   *    safe to retry.
   * - cancelled: Router will retry if the gRPC status code in the response
   * header
   *    is set to cancelled
   * - deadline-exceeded: Router will retry if the gRPC status code in the
   * response
   *    header is set to deadline-exceeded
   * - resource-exhausted: Router will retry if the gRPC status code in the
   *    response header is set to resource-exhausted
   * - unavailable: Router will retry if the gRPC status code in the response
   *    header is set to unavailable
   */
  retryConditions: string[];
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not
   * specified, default to 1.
   */
  numRetries: number;
}

/** Specifies how to route matched traffic. */
export interface GrpcRoute_RouteAction {
  /**
   * Optional. The destination services to which traffic should be forwarded.
   * If multiple destinations are specified, traffic will be split between
   * Backend Service(s) according to the weight field of these destinations.
   */
  destinations: GrpcRoute_Destination[];
  /**
   * Optional. The specification for fault injection introduced into traffic to test the
   * resiliency of clients to destination service failure. As part of fault
   * injection, when clients send requests to a destination, delays can be
   * introduced on a percentage of requests before sending those requests to
   * the destination service. Similarly requests from clients can be aborted
   * by for a percentage of requests.
   *
   * timeout and retry_policy will be ignored by clients that are configured
   * with a fault_injection_policy
   */
  faultInjectionPolicy:
    | GrpcRoute_FaultInjectionPolicy
    | undefined;
  /**
   * Optional. Specifies the timeout for selected route. Timeout is computed
   * from the time the request has been fully processed (i.e. end of stream)
   * up until the response has been completely processed. Timeout includes all
   * retries.
   */
  timeout:
    | Duration
    | undefined;
  /** Optional. Specifies the retry policy associated with this route. */
  retryPolicy: GrpcRoute_RetryPolicy | undefined;
}

/** Describes how to route traffic. */
export interface GrpcRoute_RouteRule {
  /**
   * Optional. Matches define conditions used for matching the rule against
   * incoming gRPC requests. Each match is independent, i.e. this rule will be
   * matched if ANY one of the matches is satisfied.  If no matches field is
   * specified, this rule will unconditionally match traffic.
   */
  matches: GrpcRoute_RouteMatch[];
  /**
   * Required. A detailed rule defining how to route traffic. This field is
   * required.
   */
  action: GrpcRoute_RouteAction | undefined;
}

export interface GrpcRoute_LabelsEntry {
  key: string;
  value: string;
}

/** Request used with the ListGrpcRoutes method. */
export interface ListGrpcRoutesRequest {
  /**
   * Required. The project and location from which the GrpcRoutes should be
   * listed, specified in the format `projects/* /locations/global`.
   */
  parent: string;
  /** Maximum number of GrpcRoutes to return per call. */
  pageSize: number;
  /**
   * The value returned by the last `ListGrpcRoutesResponse`
   * Indicates that this is a continuation of a prior `ListGrpcRoutes` call,
   * and that the system should return the next page of data.
   */
  pageToken: string;
}

/** Response returned by the ListGrpcRoutes method. */
export interface ListGrpcRoutesResponse {
  /** List of GrpcRoute resources. */
  grpcRoutes: GrpcRoute[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
}

/** Request used by the GetGrpcRoute method. */
export interface GetGrpcRouteRequest {
  /**
   * Required. A name of the GrpcRoute to get. Must be in the format
   * `projects/* /locations/global/grpcRoutes/*`.
   */
  name: string;
}

/** Request used by the CreateGrpcRoute method. */
export interface CreateGrpcRouteRequest {
  /**
   * Required. The parent resource of the GrpcRoute. Must be in the
   * format `projects/* /locations/global`.
   */
  parent: string;
  /** Required. Short name of the GrpcRoute resource to be created. */
  grpcRouteId: string;
  /** Required. GrpcRoute resource to be created. */
  grpcRoute: GrpcRoute | undefined;
}

/** Request used by the UpdateGrpcRoute method. */
export interface UpdateGrpcRouteRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * GrpcRoute resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. Updated GrpcRoute resource. */
  grpcRoute: GrpcRoute | undefined;
}

/** Request used by the DeleteGrpcRoute method. */
export interface DeleteGrpcRouteRequest {
  /**
   * Required. A name of the GrpcRoute to delete. Must be in the format
   * `projects/* /locations/global/grpcRoutes/*`.
   */
  name: string;
}

function createBaseGrpcRoute(): GrpcRoute {
  return {
    name: "",
    selfLink: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    hostnames: [],
    meshes: [],
    gateways: [],
    rules: [],
  };
}

export const GrpcRoute: MessageFns<GrpcRoute> = {
  encode(message: GrpcRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(98).string(message.selfLink);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      GrpcRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.hostnames) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.meshes) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.rules) {
      GrpcRoute_RouteRule.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = GrpcRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hostnames.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rules.push(GrpcRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      hostnames: globalThis.Array.isArray(object?.hostnames)
        ? object.hostnames.map((e: any) => globalThis.String(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => GrpcRoute_RouteRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GrpcRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.hostnames?.length) {
      obj.hostnames = message.hostnames;
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => GrpcRoute_RouteRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute>): GrpcRoute {
    return GrpcRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute>): GrpcRoute {
    const message = createBaseGrpcRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.hostnames = object.hostnames?.map((e) => e) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    message.rules = object.rules?.map((e) => GrpcRoute_RouteRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGrpcRoute_MethodMatch(): GrpcRoute_MethodMatch {
  return { type: 0, grpcService: "", grpcMethod: "", caseSensitive: undefined };
}

export const GrpcRoute_MethodMatch: MessageFns<GrpcRoute_MethodMatch> = {
  encode(message: GrpcRoute_MethodMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.grpcService !== "") {
      writer.uint32(18).string(message.grpcService);
    }
    if (message.grpcMethod !== "") {
      writer.uint32(26).string(message.grpcMethod);
    }
    if (message.caseSensitive !== undefined) {
      writer.uint32(32).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_MethodMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_MethodMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.grpcService = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.grpcMethod = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_MethodMatch {
    return {
      type: isSet(object.type) ? grpcRoute_MethodMatch_TypeFromJSON(object.type) : 0,
      grpcService: isSet(object.grpcService) ? globalThis.String(object.grpcService) : "",
      grpcMethod: isSet(object.grpcMethod) ? globalThis.String(object.grpcMethod) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : undefined,
    };
  },

  toJSON(message: GrpcRoute_MethodMatch): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = grpcRoute_MethodMatch_TypeToJSON(message.type);
    }
    if (message.grpcService !== "") {
      obj.grpcService = message.grpcService;
    }
    if (message.grpcMethod !== "") {
      obj.grpcMethod = message.grpcMethod;
    }
    if (message.caseSensitive !== undefined) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_MethodMatch>): GrpcRoute_MethodMatch {
    return GrpcRoute_MethodMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_MethodMatch>): GrpcRoute_MethodMatch {
    const message = createBaseGrpcRoute_MethodMatch();
    message.type = object.type ?? 0;
    message.grpcService = object.grpcService ?? "";
    message.grpcMethod = object.grpcMethod ?? "";
    message.caseSensitive = object.caseSensitive ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_HeaderMatch(): GrpcRoute_HeaderMatch {
  return { type: 0, key: "", value: "" };
}

export const GrpcRoute_HeaderMatch: MessageFns<GrpcRoute_HeaderMatch> = {
  encode(message: GrpcRoute_HeaderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_HeaderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_HeaderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_HeaderMatch {
    return {
      type: isSet(object.type) ? grpcRoute_HeaderMatch_TypeFromJSON(object.type) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GrpcRoute_HeaderMatch): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = grpcRoute_HeaderMatch_TypeToJSON(message.type);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_HeaderMatch>): GrpcRoute_HeaderMatch {
    return GrpcRoute_HeaderMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_HeaderMatch>): GrpcRoute_HeaderMatch {
    const message = createBaseGrpcRoute_HeaderMatch();
    message.type = object.type ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGrpcRoute_RouteMatch(): GrpcRoute_RouteMatch {
  return { method: undefined, headers: [] };
}

export const GrpcRoute_RouteMatch: MessageFns<GrpcRoute_RouteMatch> = {
  encode(message: GrpcRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== undefined) {
      GrpcRoute_MethodMatch.encode(message.method, writer.uint32(10).fork()).join();
    }
    for (const v of message.headers) {
      GrpcRoute_HeaderMatch.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = GrpcRoute_MethodMatch.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.headers.push(GrpcRoute_HeaderMatch.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteMatch {
    return {
      method: isSet(object.method) ? GrpcRoute_MethodMatch.fromJSON(object.method) : undefined,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => GrpcRoute_HeaderMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GrpcRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.method !== undefined) {
      obj.method = GrpcRoute_MethodMatch.toJSON(message.method);
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => GrpcRoute_HeaderMatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_RouteMatch>): GrpcRoute_RouteMatch {
    return GrpcRoute_RouteMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_RouteMatch>): GrpcRoute_RouteMatch {
    const message = createBaseGrpcRoute_RouteMatch();
    message.method = (object.method !== undefined && object.method !== null)
      ? GrpcRoute_MethodMatch.fromPartial(object.method)
      : undefined;
    message.headers = object.headers?.map((e) => GrpcRoute_HeaderMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGrpcRoute_Destination(): GrpcRoute_Destination {
  return { serviceName: undefined, weight: undefined };
}

export const GrpcRoute_Destination: MessageFns<GrpcRoute_Destination> = {
  encode(message: GrpcRoute_Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== undefined) {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== undefined) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_Destination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: GrpcRoute_Destination): unknown {
    const obj: any = {};
    if (message.serviceName !== undefined) {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== undefined) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_Destination>): GrpcRoute_Destination {
    return GrpcRoute_Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_Destination>): GrpcRoute_Destination {
    const message = createBaseGrpcRoute_Destination();
    message.serviceName = object.serviceName ?? undefined;
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy(): GrpcRoute_FaultInjectionPolicy {
  return { delay: undefined, abort: undefined };
}

export const GrpcRoute_FaultInjectionPolicy: MessageFns<GrpcRoute_FaultInjectionPolicy> = {
  encode(message: GrpcRoute_FaultInjectionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delay !== undefined) {
      GrpcRoute_FaultInjectionPolicy_Delay.encode(message.delay, writer.uint32(10).fork()).join();
    }
    if (message.abort !== undefined) {
      GrpcRoute_FaultInjectionPolicy_Abort.encode(message.abort, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delay = GrpcRoute_FaultInjectionPolicy_Delay.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.abort = GrpcRoute_FaultInjectionPolicy_Abort.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy {
    return {
      delay: isSet(object.delay) ? GrpcRoute_FaultInjectionPolicy_Delay.fromJSON(object.delay) : undefined,
      abort: isSet(object.abort) ? GrpcRoute_FaultInjectionPolicy_Abort.fromJSON(object.abort) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy): unknown {
    const obj: any = {};
    if (message.delay !== undefined) {
      obj.delay = GrpcRoute_FaultInjectionPolicy_Delay.toJSON(message.delay);
    }
    if (message.abort !== undefined) {
      obj.abort = GrpcRoute_FaultInjectionPolicy_Abort.toJSON(message.abort);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_FaultInjectionPolicy>): GrpcRoute_FaultInjectionPolicy {
    return GrpcRoute_FaultInjectionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_FaultInjectionPolicy>): GrpcRoute_FaultInjectionPolicy {
    const message = createBaseGrpcRoute_FaultInjectionPolicy();
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? GrpcRoute_FaultInjectionPolicy_Delay.fromPartial(object.delay)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? GrpcRoute_FaultInjectionPolicy_Abort.fromPartial(object.abort)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy_Delay(): GrpcRoute_FaultInjectionPolicy_Delay {
  return { fixedDelay: undefined, percentage: undefined };
}

export const GrpcRoute_FaultInjectionPolicy_Delay: MessageFns<GrpcRoute_FaultInjectionPolicy_Delay> = {
  encode(message: GrpcRoute_FaultInjectionPolicy_Delay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedDelay !== undefined) {
      Duration.encode(message.fixedDelay, writer.uint32(10).fork()).join();
    }
    if (message.percentage !== undefined) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy_Delay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Delay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fixedDelay = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy_Delay {
    return {
      fixedDelay: isSet(object.fixedDelay) ? Duration.fromJSON(object.fixedDelay) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy_Delay): unknown {
    const obj: any = {};
    if (message.fixedDelay !== undefined) {
      obj.fixedDelay = Duration.toJSON(message.fixedDelay);
    }
    if (message.percentage !== undefined) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_FaultInjectionPolicy_Delay>): GrpcRoute_FaultInjectionPolicy_Delay {
    return GrpcRoute_FaultInjectionPolicy_Delay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_FaultInjectionPolicy_Delay>): GrpcRoute_FaultInjectionPolicy_Delay {
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Delay();
    message.fixedDelay = (object.fixedDelay !== undefined && object.fixedDelay !== null)
      ? Duration.fromPartial(object.fixedDelay)
      : undefined;
    message.percentage = object.percentage ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_FaultInjectionPolicy_Abort(): GrpcRoute_FaultInjectionPolicy_Abort {
  return { httpStatus: undefined, percentage: undefined };
}

export const GrpcRoute_FaultInjectionPolicy_Abort: MessageFns<GrpcRoute_FaultInjectionPolicy_Abort> = {
  encode(message: GrpcRoute_FaultInjectionPolicy_Abort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpStatus !== undefined) {
      writer.uint32(8).int32(message.httpStatus);
    }
    if (message.percentage !== undefined) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_FaultInjectionPolicy_Abort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Abort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpStatus = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_FaultInjectionPolicy_Abort {
    return {
      httpStatus: isSet(object.httpStatus) ? globalThis.Number(object.httpStatus) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : undefined,
    };
  },

  toJSON(message: GrpcRoute_FaultInjectionPolicy_Abort): unknown {
    const obj: any = {};
    if (message.httpStatus !== undefined) {
      obj.httpStatus = Math.round(message.httpStatus);
    }
    if (message.percentage !== undefined) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_FaultInjectionPolicy_Abort>): GrpcRoute_FaultInjectionPolicy_Abort {
    return GrpcRoute_FaultInjectionPolicy_Abort.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_FaultInjectionPolicy_Abort>): GrpcRoute_FaultInjectionPolicy_Abort {
    const message = createBaseGrpcRoute_FaultInjectionPolicy_Abort();
    message.httpStatus = object.httpStatus ?? undefined;
    message.percentage = object.percentage ?? undefined;
    return message;
  },
};

function createBaseGrpcRoute_RetryPolicy(): GrpcRoute_RetryPolicy {
  return { retryConditions: [], numRetries: 0 };
}

export const GrpcRoute_RetryPolicy: MessageFns<GrpcRoute_RetryPolicy> = {
  encode(message: GrpcRoute_RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.retryConditions) {
      writer.uint32(10).string(v!);
    }
    if (message.numRetries !== 0) {
      writer.uint32(16).uint32(message.numRetries);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retryConditions.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numRetries = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RetryPolicy {
    return {
      retryConditions: globalThis.Array.isArray(object?.retryConditions)
        ? object.retryConditions.map((e: any) => globalThis.String(e))
        : [],
      numRetries: isSet(object.numRetries) ? globalThis.Number(object.numRetries) : 0,
    };
  },

  toJSON(message: GrpcRoute_RetryPolicy): unknown {
    const obj: any = {};
    if (message.retryConditions?.length) {
      obj.retryConditions = message.retryConditions;
    }
    if (message.numRetries !== 0) {
      obj.numRetries = Math.round(message.numRetries);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_RetryPolicy>): GrpcRoute_RetryPolicy {
    return GrpcRoute_RetryPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_RetryPolicy>): GrpcRoute_RetryPolicy {
    const message = createBaseGrpcRoute_RetryPolicy();
    message.retryConditions = object.retryConditions?.map((e) => e) || [];
    message.numRetries = object.numRetries ?? 0;
    return message;
  },
};

function createBaseGrpcRoute_RouteAction(): GrpcRoute_RouteAction {
  return { destinations: [], faultInjectionPolicy: undefined, timeout: undefined, retryPolicy: undefined };
}

export const GrpcRoute_RouteAction: MessageFns<GrpcRoute_RouteAction> = {
  encode(message: GrpcRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      GrpcRoute_Destination.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.faultInjectionPolicy !== undefined) {
      GrpcRoute_FaultInjectionPolicy.encode(message.faultInjectionPolicy, writer.uint32(26).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(58).fork()).join();
    }
    if (message.retryPolicy !== undefined) {
      GrpcRoute_RetryPolicy.encode(message.retryPolicy, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destinations.push(GrpcRoute_Destination.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.faultInjectionPolicy = GrpcRoute_FaultInjectionPolicy.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.retryPolicy = GrpcRoute_RetryPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => GrpcRoute_Destination.fromJSON(e))
        : [],
      faultInjectionPolicy: isSet(object.faultInjectionPolicy)
        ? GrpcRoute_FaultInjectionPolicy.fromJSON(object.faultInjectionPolicy)
        : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      retryPolicy: isSet(object.retryPolicy) ? GrpcRoute_RetryPolicy.fromJSON(object.retryPolicy) : undefined,
    };
  },

  toJSON(message: GrpcRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => GrpcRoute_Destination.toJSON(e));
    }
    if (message.faultInjectionPolicy !== undefined) {
      obj.faultInjectionPolicy = GrpcRoute_FaultInjectionPolicy.toJSON(message.faultInjectionPolicy);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.retryPolicy !== undefined) {
      obj.retryPolicy = GrpcRoute_RetryPolicy.toJSON(message.retryPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_RouteAction>): GrpcRoute_RouteAction {
    return GrpcRoute_RouteAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_RouteAction>): GrpcRoute_RouteAction {
    const message = createBaseGrpcRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => GrpcRoute_Destination.fromPartial(e)) || [];
    message.faultInjectionPolicy = (object.faultInjectionPolicy !== undefined && object.faultInjectionPolicy !== null)
      ? GrpcRoute_FaultInjectionPolicy.fromPartial(object.faultInjectionPolicy)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? GrpcRoute_RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_RouteRule(): GrpcRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const GrpcRoute_RouteRule: MessageFns<GrpcRoute_RouteRule> = {
  encode(message: GrpcRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      GrpcRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      GrpcRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matches.push(GrpcRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = GrpcRoute_RouteAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => GrpcRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? GrpcRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: GrpcRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => GrpcRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = GrpcRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_RouteRule>): GrpcRoute_RouteRule {
    return GrpcRoute_RouteRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_RouteRule>): GrpcRoute_RouteRule {
    const message = createBaseGrpcRoute_RouteRule();
    message.matches = object.matches?.map((e) => GrpcRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? GrpcRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseGrpcRoute_LabelsEntry(): GrpcRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const GrpcRoute_LabelsEntry: MessageFns<GrpcRoute_LabelsEntry> = {
  encode(message: GrpcRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrpcRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrpcRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrpcRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GrpcRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GrpcRoute_LabelsEntry>): GrpcRoute_LabelsEntry {
    return GrpcRoute_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrpcRoute_LabelsEntry>): GrpcRoute_LabelsEntry {
    const message = createBaseGrpcRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListGrpcRoutesRequest(): ListGrpcRoutesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListGrpcRoutesRequest: MessageFns<ListGrpcRoutesRequest> = {
  encode(message: ListGrpcRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGrpcRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGrpcRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGrpcRoutesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListGrpcRoutesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGrpcRoutesRequest>): ListGrpcRoutesRequest {
    return ListGrpcRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGrpcRoutesRequest>): ListGrpcRoutesRequest {
    const message = createBaseListGrpcRoutesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListGrpcRoutesResponse(): ListGrpcRoutesResponse {
  return { grpcRoutes: [], nextPageToken: "" };
}

export const ListGrpcRoutesResponse: MessageFns<ListGrpcRoutesResponse> = {
  encode(message: ListGrpcRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.grpcRoutes) {
      GrpcRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGrpcRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGrpcRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.grpcRoutes.push(GrpcRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGrpcRoutesResponse {
    return {
      grpcRoutes: globalThis.Array.isArray(object?.grpcRoutes)
        ? object.grpcRoutes.map((e: any) => GrpcRoute.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListGrpcRoutesResponse): unknown {
    const obj: any = {};
    if (message.grpcRoutes?.length) {
      obj.grpcRoutes = message.grpcRoutes.map((e) => GrpcRoute.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGrpcRoutesResponse>): ListGrpcRoutesResponse {
    return ListGrpcRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGrpcRoutesResponse>): ListGrpcRoutesResponse {
    const message = createBaseListGrpcRoutesResponse();
    message.grpcRoutes = object.grpcRoutes?.map((e) => GrpcRoute.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetGrpcRouteRequest(): GetGrpcRouteRequest {
  return { name: "" };
}

export const GetGrpcRouteRequest: MessageFns<GetGrpcRouteRequest> = {
  encode(message: GetGrpcRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGrpcRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGrpcRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGrpcRouteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGrpcRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGrpcRouteRequest>): GetGrpcRouteRequest {
    return GetGrpcRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGrpcRouteRequest>): GetGrpcRouteRequest {
    const message = createBaseGetGrpcRouteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateGrpcRouteRequest(): CreateGrpcRouteRequest {
  return { parent: "", grpcRouteId: "", grpcRoute: undefined };
}

export const CreateGrpcRouteRequest: MessageFns<CreateGrpcRouteRequest> = {
  encode(message: CreateGrpcRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.grpcRouteId !== "") {
      writer.uint32(18).string(message.grpcRouteId);
    }
    if (message.grpcRoute !== undefined) {
      GrpcRoute.encode(message.grpcRoute, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGrpcRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGrpcRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.grpcRouteId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.grpcRoute = GrpcRoute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGrpcRouteRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      grpcRouteId: isSet(object.grpcRouteId) ? globalThis.String(object.grpcRouteId) : "",
      grpcRoute: isSet(object.grpcRoute) ? GrpcRoute.fromJSON(object.grpcRoute) : undefined,
    };
  },

  toJSON(message: CreateGrpcRouteRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.grpcRouteId !== "") {
      obj.grpcRouteId = message.grpcRouteId;
    }
    if (message.grpcRoute !== undefined) {
      obj.grpcRoute = GrpcRoute.toJSON(message.grpcRoute);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGrpcRouteRequest>): CreateGrpcRouteRequest {
    return CreateGrpcRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGrpcRouteRequest>): CreateGrpcRouteRequest {
    const message = createBaseCreateGrpcRouteRequest();
    message.parent = object.parent ?? "";
    message.grpcRouteId = object.grpcRouteId ?? "";
    message.grpcRoute = (object.grpcRoute !== undefined && object.grpcRoute !== null)
      ? GrpcRoute.fromPartial(object.grpcRoute)
      : undefined;
    return message;
  },
};

function createBaseUpdateGrpcRouteRequest(): UpdateGrpcRouteRequest {
  return { updateMask: undefined, grpcRoute: undefined };
}

export const UpdateGrpcRouteRequest: MessageFns<UpdateGrpcRouteRequest> = {
  encode(message: UpdateGrpcRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.grpcRoute !== undefined) {
      GrpcRoute.encode(message.grpcRoute, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGrpcRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGrpcRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.grpcRoute = GrpcRoute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGrpcRouteRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      grpcRoute: isSet(object.grpcRoute) ? GrpcRoute.fromJSON(object.grpcRoute) : undefined,
    };
  },

  toJSON(message: UpdateGrpcRouteRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.grpcRoute !== undefined) {
      obj.grpcRoute = GrpcRoute.toJSON(message.grpcRoute);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateGrpcRouteRequest>): UpdateGrpcRouteRequest {
    return UpdateGrpcRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateGrpcRouteRequest>): UpdateGrpcRouteRequest {
    const message = createBaseUpdateGrpcRouteRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.grpcRoute = (object.grpcRoute !== undefined && object.grpcRoute !== null)
      ? GrpcRoute.fromPartial(object.grpcRoute)
      : undefined;
    return message;
  },
};

function createBaseDeleteGrpcRouteRequest(): DeleteGrpcRouteRequest {
  return { name: "" };
}

export const DeleteGrpcRouteRequest: MessageFns<DeleteGrpcRouteRequest> = {
  encode(message: DeleteGrpcRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGrpcRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGrpcRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGrpcRouteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteGrpcRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGrpcRouteRequest>): DeleteGrpcRouteRequest {
    return DeleteGrpcRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGrpcRouteRequest>): DeleteGrpcRouteRequest {
    const message = createBaseDeleteGrpcRouteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
