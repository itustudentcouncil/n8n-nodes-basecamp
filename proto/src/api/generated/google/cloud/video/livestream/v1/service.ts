// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/livestream/v1/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../longrunning/operations.js";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Asset, Channel, Clip, Event, Input, Pool } from "./resources.js";

export const protobufPackage = "google.cloud.video.livestream.v1";

/** Request message for "LivestreamService.CreateAsset". */
export interface CreateAssetRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /** Required. The asset resource to be created. */
  asset:
    | Asset
    | undefined;
  /**
   * Required. The ID of the asset resource to be created.
   * This value must be 1-63 characters, begin and end with `[a-z0-9]`,
   * could contain dashes (-) in between.
   */
  assetId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.DeleteAsset". */
export interface DeleteAssetRequest {
  /**
   * Required. The name of the asset resource, in the form of:
   * `projects/{project}/locations/{location}/assets/{assetId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.ListAssets". */
export interface ListAssetsRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Response message for "LivestreamService.ListAssets". */
export interface ListAssetsResponse {
  /** The list of Assets */
  assets: Asset[];
  /** The next_page_token value returned from a previous List request, if any. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for "LivestreamService.GetAsset". */
export interface GetAssetRequest {
  /**
   * Required. Name of the resource, in the following form:
   * `projects/{project}/locations/{location}/assets/{asset}`.
   */
  name: string;
}

/** Request message for "LivestreamService.CreateChannel". */
export interface CreateChannelRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /** Required. The channel resource to be created. */
  channel:
    | Channel
    | undefined;
  /**
   * Required. The ID of the channel resource to be created.
   * This value must be 1-63 characters, begin and end with `[a-z0-9]`,
   * could contain dashes (-) in between.
   */
  channelId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.ListChannels". */
export interface ListChannelsRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /**
   * The maximum number of items to return. If unspecified, server
   * will pick an appropriate default. Server may return fewer items than
   * requested. A caller should only rely on response's
   * [next_page_token][google.cloud.video.livestream.v1.ListChannelsResponse.next_page_token]
   * to determine if there are more items left to be queried.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** The filter to apply to list results. */
  filter: string;
  /**
   * Specifies the ordering of results following syntax at
   * https://cloud.google.com/apis/design/design_patterns#sorting_order.
   */
  orderBy: string;
}

/** Response message for "LivestreamService.ListChannels". */
export interface ListChannelsResponse {
  /** A list of channels. */
  channels: Channel[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for "LivestreamService.GetChannel". */
export interface GetChannelRequest {
  /**
   * Required. The name of the channel resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  name: string;
}

/** Request message for "LivestreamService.DeleteChannel". */
export interface DeleteChannelRequest {
  /**
   * Required. The name of the channel resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
  /**
   * If the `force` field is set to the default value of `false`, you must
   * delete all of a channel's events before you can delete the channel itself.
   * If the field is set to `true`, requests to delete a channel also delete
   * associated channel events.
   */
  force: boolean;
}

/** Request message for "LivestreamService.UpdateChannel". */
export interface UpdateChannelRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the Channel
   * resource by the update. You can only update the following fields:
   *
   * * [`inputAttachments`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#inputattachment)
   * * [`inputConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#inputconfig)
   * * [`output`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#output)
   * * [`elementaryStreams`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#elementarystream)
   * * [`muxStreams`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#muxstream)
   * * [`manifests`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#manifest)
   * * [`spriteSheets`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#spritesheet)
   * * [`logConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#logconfig)
   * * [`timecodeConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#timecodeconfig)
   * * [`encryptions`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.channels#encryption)
   *
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask.
   *
   * If the mask is not present, then each field from the list above is updated
   * if the field appears in the request payload. To unset a field, add the
   * field to the update mask and remove it from the request payload.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The channel resource to be updated. */
  channel:
    | Channel
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.StartChannel". */
export interface StartChannelRequest {
  /**
   * Required. The name of the channel resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.StopChannel". */
export interface StopChannelRequest {
  /**
   * Required. The name of the channel resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.CreateInput". */
export interface CreateInputRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /** Required. The input resource to be created. */
  input:
    | Input
    | undefined;
  /**
   * Required. The ID of the input resource to be created.
   * This value must be 1-63 characters, begin and end with `[a-z0-9]`,
   * could contain dashes (-) in between.
   */
  inputId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.ListInputs". */
export interface ListInputsRequest {
  /**
   * Required. The parent location for the resource, in the form of:
   * `projects/{project}/locations/{location}`.
   */
  parent: string;
  /**
   * The maximum number of items to return. If unspecified, server
   * will pick an appropriate default. Server may return fewer items than
   * requested. A caller should only rely on response's
   * [next_page_token][google.cloud.video.livestream.v1.ListInputsResponse.next_page_token]
   * to determine if there are more items left to be queried.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** The filter to apply to list results. */
  filter: string;
  /**
   * Specifies the ordering of results following syntax at [Sorting
   * Order](https://cloud.google.com/apis/design/design_patterns#sorting_order).
   */
  orderBy: string;
}

/** Response message for "LivestreamService.ListInputs". */
export interface ListInputsResponse {
  /** A list of inputs. */
  inputs: Input[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for "LivestreamService.GetInput". */
export interface GetInputRequest {
  /**
   * Required. The name of the input resource, in the form of:
   * `projects/{project}/locations/{location}/inputs/{inputId}`.
   */
  name: string;
}

/** Request message for "LivestreamService.DeleteInput". */
export interface DeleteInputRequest {
  /**
   * Required. The name of the input resource, in the form of:
   * `projects/{project}/locations/{location}/inputs/{inputId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.UpdateInput". */
export interface UpdateInputRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the Input
   * resource by the update. You can only update the following fields:
   *
   * * [`preprocessingConfig`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.inputs#PreprocessingConfig)
   * * [`securityRules`](https://cloud.google.com/livestream/docs/reference/rest/v1/projects.locations.inputs#SecurityRule)
   *
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask.
   *
   * If the mask is not present, then each field from the list above is updated
   * if the field appears in the request payload. To unset a field, add the
   * field to the update mask and remove it from the request payload.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The input resource to be updated. */
  input:
    | Input
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.CreateEvent". */
export interface CreateEventRequest {
  /**
   * Required. The parent channel for the resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  parent: string;
  /** Required. The event resource to be created. */
  event:
    | Event
    | undefined;
  /**
   * Required. The ID of the event resource to be created.
   * This value must be 1-63 characters, begin and end with `[a-z0-9]`,
   * could contain dashes (-) in between.
   */
  eventId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Request message for "LivestreamService.ListEvents". */
export interface ListEventsRequest {
  /**
   * Required. The parent channel for the resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}`.
   */
  parent: string;
  /**
   * The maximum number of items to return. If unspecified, server
   * will pick an appropriate default. Server may return fewer items than
   * requested. A caller should only rely on response's
   * [next_page_token][google.cloud.video.livestream.v1.ListEventsResponse.next_page_token]
   * to determine if there are more items left to be queried.
   */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** The filter to apply to list results. */
  filter: string;
  /**
   * Specifies the ordering of results following syntax at
   * https://cloud.google.com/apis/design/design_patterns#sorting_order.
   */
  orderBy: string;
}

/** Response message for "LivestreamService.ListEvents". */
export interface ListEventsResponse {
  /** A list of events. */
  events: Event[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for "LivestreamService.GetEvent". */
export interface GetEventRequest {
  /**
   * Required. The name of the event resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
   */
  name: string;
}

/** Request message for "LivestreamService.DeleteEvent". */
export interface DeleteEventRequest {
  /**
   * Required. The name of the event resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}/events/{eventId}`.
   */
  name: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Response message for Start/Stop Channel long-running operations. */
export interface ChannelOperationResponse {
}

/** Request message for "LivestreamService.ListClips". */
export interface ListClipsRequest {
  /** Required. Parent value for ListClipsRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Response message for "LivestreamService.ListClips". */
export interface ListClipsResponse {
  /** The list of Clip */
  clips: Clip[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for "LivestreamService.GetClip". */
export interface GetClipRequest {
  /**
   * Required. Name of the resource, in the following form:
   * `projects/{project}/locations/{location}/channels/{channel}/clips/{clip}`.
   */
  name: string;
}

/** Request message for "LivestreamService.CreateClip". */
export interface CreateClipRequest {
  /**
   * Required. The parent resource name, in the following form:
   * `projects/{project}/locations/{location}/channels/{channel}`.
   */
  parent: string;
  /**
   * Required. Id of the requesting object in the following form:
   *
   * 1. 1 character minimum, 63 characters maximum
   * 2. Only contains letters, digits, underscores, and hyphens
   */
  clipId: string;
  /** Required. The resource being created */
  clip:
    | Clip
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for "LivestreamService.DeleteClip". */
export interface DeleteClipRequest {
  /**
   * Required. The name of the clip resource, in the form of:
   * `projects/{project}/locations/{location}/channels/{channelId}/clips/{clipId}`.
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** Request message for "LivestreamService.GetPool". */
export interface GetPoolRequest {
  /**
   * Required. The name of the pool resource, in the form of:
   * `projects/{project}/locations/{location}/pools/{poolId}`.
   */
  name: string;
}

/** Request message for "LivestreamService.UpdatePool". */
export interface UpdatePoolRequest {
  /**
   * Field mask is used to specify the fields to be overwritten in the Pool
   * resource by the update. You can only update the following fields:
   *
   * * `networkConfig`
   *
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The pool resource to be updated. */
  pool:
    | Pool
    | undefined;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server will guarantee
   * that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported `(00000000-0000-0000-0000-000000000000)`.
   */
  requestId: string;
}

function createBaseCreateAssetRequest(): CreateAssetRequest {
  return { parent: "", asset: undefined, assetId: "", requestId: "" };
}

export const CreateAssetRequest: MessageFns<CreateAssetRequest> = {
  encode(message: CreateAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(18).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssetRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateAssetRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    return CreateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    const message = createBaseCreateAssetRequest();
    message.parent = object.parent ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.assetId = object.assetId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteAssetRequest(): DeleteAssetRequest {
  return { name: "", requestId: "" };
}

export const DeleteAssetRequest: MessageFns<DeleteAssetRequest> = {
  encode(message: DeleteAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAssetRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    return DeleteAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAssetRequest>): DeleteAssetRequest {
    const message = createBaseDeleteAssetRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListAssetsRequest(): ListAssetsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAssetsRequest: MessageFns<ListAssetsRequest> = {
  encode(message: ListAssetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAssetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    return ListAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsRequest>): ListAssetsRequest {
    const message = createBaseListAssetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAssetsResponse(): ListAssetsResponse {
  return { assets: [], nextPageToken: "", unreachable: [] };
}

export const ListAssetsResponse: MessageFns<ListAssetsResponse> = {
  encode(message: ListAssetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assets) {
      Asset.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assets.push(Asset.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssetsResponse {
    return {
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => Asset.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAssetsResponse): unknown {
    const obj: any = {};
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => Asset.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    return ListAssetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssetsResponse>): ListAssetsResponse {
    const message = createBaseListAssetsResponse();
    message.assets = object.assets?.map((e) => Asset.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAssetRequest(): GetAssetRequest {
  return { name: "" };
}

export const GetAssetRequest: MessageFns<GetAssetRequest> = {
  encode(message: GetAssetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAssetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAssetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetRequest>): GetAssetRequest {
    return GetAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetRequest>): GetAssetRequest {
    const message = createBaseGetAssetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateChannelRequest(): CreateChannelRequest {
  return { parent: "", channel: undefined, channelId: "", requestId: "" };
}

export const CreateChannelRequest: MessageFns<CreateChannelRequest> = {
  encode(message: CreateChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.channelId !== "") {
      writer.uint32(26).string(message.channelId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChannelRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined,
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateChannelRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateChannelRequest>): CreateChannelRequest {
    return CreateChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateChannelRequest>): CreateChannelRequest {
    const message = createBaseCreateChannelRequest();
    message.parent = object.parent ?? "";
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? Channel.fromPartial(object.channel)
      : undefined;
    message.channelId = object.channelId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListChannelsRequest(): ListChannelsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListChannelsRequest: MessageFns<ListChannelsRequest> = {
  encode(message: ListChannelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListChannelsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelsRequest>): ListChannelsRequest {
    return ListChannelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelsRequest>): ListChannelsRequest {
    const message = createBaseListChannelsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListChannelsResponse(): ListChannelsResponse {
  return { channels: [], nextPageToken: "", unreachable: [] };
}

export const ListChannelsResponse: MessageFns<ListChannelsResponse> = {
  encode(message: ListChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channels) {
      Channel.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channels.push(Channel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelsResponse {
    return {
      channels: globalThis.Array.isArray(object?.channels) ? object.channels.map((e: any) => Channel.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListChannelsResponse): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => Channel.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelsResponse>): ListChannelsResponse {
    return ListChannelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelsResponse>): ListChannelsResponse {
    const message = createBaseListChannelsResponse();
    message.channels = object.channels?.map((e) => Channel.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetChannelRequest(): GetChannelRequest {
  return { name: "" };
}

export const GetChannelRequest: MessageFns<GetChannelRequest> = {
  encode(message: GetChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChannelRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChannelRequest>): GetChannelRequest {
    return GetChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChannelRequest>): GetChannelRequest {
    const message = createBaseGetChannelRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteChannelRequest(): DeleteChannelRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteChannelRequest: MessageFns<DeleteChannelRequest> = {
  encode(message: DeleteChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteChannelRequest>): DeleteChannelRequest {
    return DeleteChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteChannelRequest>): DeleteChannelRequest {
    const message = createBaseDeleteChannelRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUpdateChannelRequest(): UpdateChannelRequest {
  return { updateMask: undefined, channel: undefined, requestId: "" };
}

export const UpdateChannelRequest: MessageFns<UpdateChannelRequest> = {
  encode(message: UpdateChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.channel !== undefined) {
      Channel.encode(message.channel, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channel = Channel.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChannelRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      channel: isSet(object.channel) ? Channel.fromJSON(object.channel) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateChannelRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.channel !== undefined) {
      obj.channel = Channel.toJSON(message.channel);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateChannelRequest>): UpdateChannelRequest {
    return UpdateChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateChannelRequest>): UpdateChannelRequest {
    const message = createBaseUpdateChannelRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? Channel.fromPartial(object.channel)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseStartChannelRequest(): StartChannelRequest {
  return { name: "", requestId: "" };
}

export const StartChannelRequest: MessageFns<StartChannelRequest> = {
  encode(message: StartChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: StartChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<StartChannelRequest>): StartChannelRequest {
    return StartChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartChannelRequest>): StartChannelRequest {
    const message = createBaseStartChannelRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseStopChannelRequest(): StopChannelRequest {
  return { name: "", requestId: "" };
}

export const StopChannelRequest: MessageFns<StopChannelRequest> = {
  encode(message: StopChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: StopChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<StopChannelRequest>): StopChannelRequest {
    return StopChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopChannelRequest>): StopChannelRequest {
    const message = createBaseStopChannelRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateInputRequest(): CreateInputRequest {
  return { parent: "", input: undefined, inputId: "", requestId: "" };
}

export const CreateInputRequest: MessageFns<CreateInputRequest> = {
  encode(message: CreateInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.inputId !== "") {
      writer.uint32(26).string(message.inputId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInputRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      inputId: isSet(object.inputId) ? globalThis.String(object.inputId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateInputRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.inputId !== "") {
      obj.inputId = message.inputId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInputRequest>): CreateInputRequest {
    return CreateInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInputRequest>): CreateInputRequest {
    const message = createBaseCreateInputRequest();
    message.parent = object.parent ?? "";
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.inputId = object.inputId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListInputsRequest(): ListInputsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListInputsRequest: MessageFns<ListInputsRequest> = {
  encode(message: ListInputsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInputsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListInputsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInputsRequest>): ListInputsRequest {
    return ListInputsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInputsRequest>): ListInputsRequest {
    const message = createBaseListInputsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListInputsResponse(): ListInputsResponse {
  return { inputs: [], nextPageToken: "", unreachable: [] };
}

export const ListInputsResponse: MessageFns<ListInputsResponse> = {
  encode(message: ListInputsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInputsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputsResponse {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInputsResponse): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInputsResponse>): ListInputsResponse {
    return ListInputsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInputsResponse>): ListInputsResponse {
    const message = createBaseListInputsResponse();
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetInputRequest(): GetInputRequest {
  return { name: "" };
}

export const GetInputRequest: MessageFns<GetInputRequest> = {
  encode(message: GetInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInputRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInputRequest>): GetInputRequest {
    return GetInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInputRequest>): GetInputRequest {
    const message = createBaseGetInputRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteInputRequest(): DeleteInputRequest {
  return { name: "", requestId: "" };
}

export const DeleteInputRequest: MessageFns<DeleteInputRequest> = {
  encode(message: DeleteInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInputRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteInputRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInputRequest>): DeleteInputRequest {
    return DeleteInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInputRequest>): DeleteInputRequest {
    const message = createBaseDeleteInputRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateInputRequest(): UpdateInputRequest {
  return { updateMask: undefined, input: undefined, requestId: "" };
}

export const UpdateInputRequest: MessageFns<UpdateInputRequest> = {
  encode(message: UpdateInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.input !== undefined) {
      Input.encode(message.input, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = Input.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInputRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      input: isSet(object.input) ? Input.fromJSON(object.input) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateInputRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.input !== undefined) {
      obj.input = Input.toJSON(message.input);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInputRequest>): UpdateInputRequest {
    return UpdateInputRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInputRequest>): UpdateInputRequest {
    const message = createBaseUpdateInputRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.input = (object.input !== undefined && object.input !== null) ? Input.fromPartial(object.input) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateEventRequest(): CreateEventRequest {
  return { parent: "", event: undefined, eventId: "", requestId: "" };
}

export const CreateEventRequest: MessageFns<CreateEventRequest> = {
  encode(message: CreateEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(18).fork()).join();
    }
    if (message.eventId !== "") {
      writer.uint32(26).string(message.eventId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEventRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateEventRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEventRequest>): CreateEventRequest {
    return CreateEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEventRequest>): CreateEventRequest {
    const message = createBaseCreateEventRequest();
    message.parent = object.parent ?? "";
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.eventId = object.eventId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListEventsRequest(): ListEventsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListEventsRequest: MessageFns<ListEventsRequest> = {
  encode(message: ListEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListEventsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsRequest>): ListEventsRequest {
    return ListEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsRequest>): ListEventsRequest {
    const message = createBaseListEventsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListEventsResponse(): ListEventsResponse {
  return { events: [], nextPageToken: "", unreachable: [] };
}

export const ListEventsResponse: MessageFns<ListEventsResponse> = {
  encode(message: ListEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      Event.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.events.push(Event.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Event.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => Event.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEventsResponse>): ListEventsResponse {
    return ListEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEventsResponse>): ListEventsResponse {
    const message = createBaseListEventsResponse();
    message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEventRequest(): GetEventRequest {
  return { name: "" };
}

export const GetEventRequest: MessageFns<GetEventRequest> = {
  encode(message: GetEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEventRequest>): GetEventRequest {
    return GetEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEventRequest>): GetEventRequest {
    const message = createBaseGetEventRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteEventRequest(): DeleteEventRequest {
  return { name: "", requestId: "" };
}

export const DeleteEventRequest: MessageFns<DeleteEventRequest> = {
  encode(message: DeleteEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEventRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEventRequest>): DeleteEventRequest {
    return DeleteEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEventRequest>): DeleteEventRequest {
    const message = createBaseDeleteEventRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseChannelOperationResponse(): ChannelOperationResponse {
  return {};
}

export const ChannelOperationResponse: MessageFns<ChannelOperationResponse> = {
  encode(_: ChannelOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ChannelOperationResponse {
    return {};
  },

  toJSON(_: ChannelOperationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ChannelOperationResponse>): ChannelOperationResponse {
    return ChannelOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ChannelOperationResponse>): ChannelOperationResponse {
    const message = createBaseChannelOperationResponse();
    return message;
  },
};

function createBaseListClipsRequest(): ListClipsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListClipsRequest: MessageFns<ListClipsRequest> = {
  encode(message: ListClipsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClipsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClipsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClipsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListClipsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClipsRequest>): ListClipsRequest {
    return ListClipsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClipsRequest>): ListClipsRequest {
    const message = createBaseListClipsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListClipsResponse(): ListClipsResponse {
  return { clips: [], nextPageToken: "", unreachable: [] };
}

export const ListClipsResponse: MessageFns<ListClipsResponse> = {
  encode(message: ListClipsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clips) {
      Clip.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClipsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClipsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clips.push(Clip.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClipsResponse {
    return {
      clips: globalThis.Array.isArray(object?.clips) ? object.clips.map((e: any) => Clip.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListClipsResponse): unknown {
    const obj: any = {};
    if (message.clips?.length) {
      obj.clips = message.clips.map((e) => Clip.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClipsResponse>): ListClipsResponse {
    return ListClipsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClipsResponse>): ListClipsResponse {
    const message = createBaseListClipsResponse();
    message.clips = object.clips?.map((e) => Clip.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetClipRequest(): GetClipRequest {
  return { name: "" };
}

export const GetClipRequest: MessageFns<GetClipRequest> = {
  encode(message: GetClipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClipRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetClipRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetClipRequest>): GetClipRequest {
    return GetClipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClipRequest>): GetClipRequest {
    const message = createBaseGetClipRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateClipRequest(): CreateClipRequest {
  return { parent: "", clipId: "", clip: undefined, requestId: "" };
}

export const CreateClipRequest: MessageFns<CreateClipRequest> = {
  encode(message: CreateClipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.clipId !== "") {
      writer.uint32(18).string(message.clipId);
    }
    if (message.clip !== undefined) {
      Clip.encode(message.clip, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clipId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clip = Clip.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClipRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      clipId: isSet(object.clipId) ? globalThis.String(object.clipId) : "",
      clip: isSet(object.clip) ? Clip.fromJSON(object.clip) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateClipRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.clipId !== "") {
      obj.clipId = message.clipId;
    }
    if (message.clip !== undefined) {
      obj.clip = Clip.toJSON(message.clip);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateClipRequest>): CreateClipRequest {
    return CreateClipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateClipRequest>): CreateClipRequest {
    const message = createBaseCreateClipRequest();
    message.parent = object.parent ?? "";
    message.clipId = object.clipId ?? "";
    message.clip = (object.clip !== undefined && object.clip !== null) ? Clip.fromPartial(object.clip) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteClipRequest(): DeleteClipRequest {
  return { name: "", requestId: "" };
}

export const DeleteClipRequest: MessageFns<DeleteClipRequest> = {
  encode(message: DeleteClipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClipRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteClipRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteClipRequest>): DeleteClipRequest {
    return DeleteClipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteClipRequest>): DeleteClipRequest {
    const message = createBaseDeleteClipRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(40).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(50).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseGetPoolRequest(): GetPoolRequest {
  return { name: "" };
}

export const GetPoolRequest: MessageFns<GetPoolRequest> = {
  encode(message: GetPoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPoolRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPoolRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPoolRequest>): GetPoolRequest {
    return GetPoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPoolRequest>): GetPoolRequest {
    const message = createBaseGetPoolRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdatePoolRequest(): UpdatePoolRequest {
  return { updateMask: undefined, pool: undefined, requestId: "" };
}

export const UpdatePoolRequest: MessageFns<UpdatePoolRequest> = {
  encode(message: UpdatePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.pool !== undefined) {
      Pool.encode(message.pool, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pool = Pool.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePoolRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      pool: isSet(object.pool) ? Pool.fromJSON(object.pool) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdatePoolRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.pool !== undefined) {
      obj.pool = Pool.toJSON(message.pool);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePoolRequest>): UpdatePoolRequest {
    return UpdatePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePoolRequest>): UpdatePoolRequest {
    const message = createBaseUpdatePoolRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

/**
 * Using Live Stream API, you can generate live streams in the various
 * renditions and streaming formats. The streaming format include HTTP Live
 * Streaming (HLS) and Dynamic Adaptive Streaming over HTTP (DASH). You can send
 * a source stream in the various ways, including Real-Time Messaging
 * Protocol (RTMP) and Secure Reliable Transport (SRT).
 */
export type LivestreamServiceDefinition = typeof LivestreamServiceDefinition;
export const LivestreamServiceDefinition = {
  name: "LivestreamService",
  fullName: "google.cloud.video.livestream.v1.LivestreamService",
  methods: {
    /**
     * Creates a channel with the provided unique ID in the specified
     * region.
     */
    createChannel: {
      name: "CreateChannel",
      requestType: CreateChannelRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              44,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              55,
              58,
              7,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns a list of all channels in the specified region. */
    listChannels: {
      name: "ListChannels",
      requestType: ListChannelsRequest,
      requestStream: false,
      responseType: ListChannelsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified channel. */
    getChannel: {
      name: "GetChannel",
      requestType: GetChannelRequest,
      requestStream: false,
      responseType: Channel,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified channel. */
    deleteChannel: {
      name: "DeleteChannel",
      requestType: DeleteChannelRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified channel. */
    updateChannel: {
      name: "UpdateChannel",
      requestType: UpdateChannelRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([19, 99, 104, 97, 110, 110, 101, 108, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              7,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              50,
              52,
              47,
              118,
              49,
              47,
              123,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Starts the specified channel. Part of the video pipeline will be created
     * only when the StartChannel request is received by the server.
     */
    startChannel: {
      name: "StartChannel",
      requestType: StartChannelRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Stops the specified channel. Part of the video pipeline will be released
     * when the StopChannel request is received by the server.
     */
    stopChannel: {
      name: "StopChannel",
      requestType: StopChannelRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
            ]),
          ],
        },
      },
    },
    /** Creates an input with the provided unique ID in the specified region. */
    createInput: {
      name: "CreateInput",
      requestType: CreateInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              73,
              110,
              112,
              117,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              112,
              117,
              116,
              44,
              105,
              110,
              112,
              117,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              5,
              105,
              110,
              112,
              117,
              116,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              112,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns a list of all inputs in the specified region. */
    listInputs: {
      name: "ListInputs",
      requestType: ListInputsRequest,
      requestStream: false,
      responseType: ListInputsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              112,
              117,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified input. */
    getInput: {
      name: "GetInput",
      requestType: GetInputRequest,
      requestStream: false,
      responseType: Input,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              112,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified input. */
    deleteInput: {
      name: "DeleteInput",
      requestType: DeleteInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              112,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified input. */
    updateInput: {
      name: "UpdateInput",
      requestType: UpdateInputRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              73,
              110,
              112,
              117,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([17, 105, 110, 112, 117, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              57,
              58,
              5,
              105,
              110,
              112,
              117,
              116,
              50,
              48,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              112,
              117,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              112,
              117,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates an event with the provided unique ID in the specified channel. */
    createEvent: {
      name: "CreateEvent",
      requestType: CreateEventRequest,
      requestStream: false,
      responseType: Event,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              118,
              101,
              110,
              116,
              44,
              101,
              118,
              101,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              5,
              101,
              118,
              101,
              110,
              116,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns a list of all events in the specified channel. */
    listEvents: {
      name: "ListEvents",
      requestType: ListEventsRequest,
      requestStream: false,
      responseType: ListEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified event. */
    getEvent: {
      name: "GetEvent",
      requestType: GetEventRequest,
      requestStream: false,
      responseType: Event,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified event. */
    deleteEvent: {
      name: "DeleteEvent",
      requestType: DeleteEventRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              42,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              47,
              101,
              118,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a list of all clips in the specified channel. */
    listClips: {
      name: "ListClips",
      requestType: ListClipsRequest,
      requestStream: false,
      responseType: ListClipsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              105,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified clip. */
    getClip: {
      name: "GetClip",
      requestType: GetClipRequest,
      requestStream: false,
      responseType: Clip,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              47,
              99,
              108,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a clip with the provided clip ID in the specified channel. */
    createClip: {
      name: "CreateClip",
      requestType: CreateClipRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              67,
              108,
              105,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([19, 112, 97, 114, 101, 110, 116, 44, 99, 108, 105, 112, 44, 99, 108, 105, 112, 95, 105, 100]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              4,
              99,
              108,
              105,
              112,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              105,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the specified clip job resource. This method only deletes the clip
     * job and does not delete the VOD clip stored in the GCS.
     */
    deleteClip: {
      name: "DeleteClip",
      requestType: DeleteClipRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              47,
              99,
              108,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a Asset with the provided unique ID in the specified
     * region.
     */
    createAsset: {
      name: "CreateAsset",
      requestType: CreateAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              26,
              10,
              5,
              65,
              115,
              115,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              44,
              97,
              115,
              115,
              101,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              5,
              97,
              115,
              115,
              101,
              116,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes the specified asset if it is not used. */
    deleteAsset: {
      name: "DeleteAsset",
      requestType: DeleteAssetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the specified asset. */
    getAsset: {
      name: "GetAsset",
      requestType: GetAssetRequest,
      requestStream: false,
      responseType: Asset,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a list of all assets in the specified region. */
    listAssets: {
      name: "ListAssets",
      requestType: ListAssetsRequest,
      requestStream: false,
      responseType: ListAssetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the specified pool. */
    getPool: {
      name: "GetPool",
      requestType: GetPoolRequest,
      requestStream: false,
      responseType: Pool,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the specified pool. */
    updatePool: {
      name: "UpdatePool",
      requestType: UpdatePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              80,
              111,
              111,
              108,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([16, 112, 111, 111, 108, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              54,
              58,
              4,
              112,
              111,
              111,
              108,
              50,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              111,
              111,
              108,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface LivestreamServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a channel with the provided unique ID in the specified
   * region.
   */
  createChannel(request: CreateChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Returns a list of all channels in the specified region. */
  listChannels(
    request: ListChannelsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListChannelsResponse>>;
  /** Returns the specified channel. */
  getChannel(request: GetChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Channel>>;
  /** Deletes the specified channel. */
  deleteChannel(request: DeleteChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the specified channel. */
  updateChannel(request: UpdateChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Starts the specified channel. Part of the video pipeline will be created
   * only when the StartChannel request is received by the server.
   */
  startChannel(request: StartChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Stops the specified channel. Part of the video pipeline will be released
   * when the StopChannel request is received by the server.
   */
  stopChannel(request: StopChannelRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates an input with the provided unique ID in the specified region. */
  createInput(request: CreateInputRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Returns a list of all inputs in the specified region. */
  listInputs(
    request: ListInputsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInputsResponse>>;
  /** Returns the specified input. */
  getInput(request: GetInputRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Input>>;
  /** Deletes the specified input. */
  deleteInput(request: DeleteInputRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the specified input. */
  updateInput(request: UpdateInputRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates an event with the provided unique ID in the specified channel. */
  createEvent(request: CreateEventRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Event>>;
  /** Returns a list of all events in the specified channel. */
  listEvents(
    request: ListEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEventsResponse>>;
  /** Returns the specified event. */
  getEvent(request: GetEventRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Event>>;
  /** Deletes the specified event. */
  deleteEvent(request: DeleteEventRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Returns a list of all clips in the specified channel. */
  listClips(request: ListClipsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListClipsResponse>>;
  /** Returns the specified clip. */
  getClip(request: GetClipRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Clip>>;
  /** Creates a clip with the provided clip ID in the specified channel. */
  createClip(request: CreateClipRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the specified clip job resource. This method only deletes the clip
   * job and does not delete the VOD clip stored in the GCS.
   */
  deleteClip(request: DeleteClipRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Creates a Asset with the provided unique ID in the specified
   * region.
   */
  createAsset(request: CreateAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes the specified asset if it is not used. */
  deleteAsset(request: DeleteAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Returns the specified asset. */
  getAsset(request: GetAssetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Asset>>;
  /** Returns a list of all assets in the specified region. */
  listAssets(
    request: ListAssetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssetsResponse>>;
  /** Returns the specified pool. */
  getPool(request: GetPoolRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Pool>>;
  /** Updates the specified pool. */
  updatePool(request: UpdatePoolRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface LivestreamServiceClient<CallOptionsExt = {}> {
  /**
   * Creates a channel with the provided unique ID in the specified
   * region.
   */
  createChannel(request: DeepPartial<CreateChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Returns a list of all channels in the specified region. */
  listChannels(
    request: DeepPartial<ListChannelsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListChannelsResponse>;
  /** Returns the specified channel. */
  getChannel(request: DeepPartial<GetChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Channel>;
  /** Deletes the specified channel. */
  deleteChannel(request: DeepPartial<DeleteChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the specified channel. */
  updateChannel(request: DeepPartial<UpdateChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Starts the specified channel. Part of the video pipeline will be created
   * only when the StartChannel request is received by the server.
   */
  startChannel(request: DeepPartial<StartChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Stops the specified channel. Part of the video pipeline will be released
   * when the StopChannel request is received by the server.
   */
  stopChannel(request: DeepPartial<StopChannelRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates an input with the provided unique ID in the specified region. */
  createInput(request: DeepPartial<CreateInputRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Returns a list of all inputs in the specified region. */
  listInputs(
    request: DeepPartial<ListInputsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInputsResponse>;
  /** Returns the specified input. */
  getInput(request: DeepPartial<GetInputRequest>, options?: CallOptions & CallOptionsExt): Promise<Input>;
  /** Deletes the specified input. */
  deleteInput(request: DeepPartial<DeleteInputRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the specified input. */
  updateInput(request: DeepPartial<UpdateInputRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates an event with the provided unique ID in the specified channel. */
  createEvent(request: DeepPartial<CreateEventRequest>, options?: CallOptions & CallOptionsExt): Promise<Event>;
  /** Returns a list of all events in the specified channel. */
  listEvents(
    request: DeepPartial<ListEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEventsResponse>;
  /** Returns the specified event. */
  getEvent(request: DeepPartial<GetEventRequest>, options?: CallOptions & CallOptionsExt): Promise<Event>;
  /** Deletes the specified event. */
  deleteEvent(request: DeepPartial<DeleteEventRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Returns a list of all clips in the specified channel. */
  listClips(request: DeepPartial<ListClipsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListClipsResponse>;
  /** Returns the specified clip. */
  getClip(request: DeepPartial<GetClipRequest>, options?: CallOptions & CallOptionsExt): Promise<Clip>;
  /** Creates a clip with the provided clip ID in the specified channel. */
  createClip(request: DeepPartial<CreateClipRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes the specified clip job resource. This method only deletes the clip
   * job and does not delete the VOD clip stored in the GCS.
   */
  deleteClip(request: DeepPartial<DeleteClipRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Creates a Asset with the provided unique ID in the specified
   * region.
   */
  createAsset(request: DeepPartial<CreateAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes the specified asset if it is not used. */
  deleteAsset(request: DeepPartial<DeleteAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Returns the specified asset. */
  getAsset(request: DeepPartial<GetAssetRequest>, options?: CallOptions & CallOptionsExt): Promise<Asset>;
  /** Returns a list of all assets in the specified region. */
  listAssets(
    request: DeepPartial<ListAssetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssetsResponse>;
  /** Returns the specified pool. */
  getPool(request: DeepPartial<GetPoolRequest>, options?: CallOptions & CallOptionsExt): Promise<Pool>;
  /** Updates the specified pool. */
  updatePool(request: DeepPartial<UpdatePoolRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
