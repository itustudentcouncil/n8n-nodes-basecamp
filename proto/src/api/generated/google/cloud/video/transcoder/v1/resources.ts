// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/transcoder/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";

export const protobufPackage = "google.cloud.video.transcoder.v1";

/** Transcoding job resource. */
export interface Job {
  /**
   * The resource name of the job.
   * Format: `projects/{project_number}/locations/{location}/jobs/{job}`
   */
  name: string;
  /**
   * Input only. Specify the `input_uri` to populate empty `uri` fields in each
   * element of `Job.config.inputs` or `JobTemplate.config.inputs` when using
   * template. URI of the media. Input files must be at least 5 seconds in
   * duration and stored in Cloud Storage (for example,
   * `gs://bucket/inputs/file.mp4`). See [Supported input and output
   * formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
   */
  inputUri: string;
  /**
   * Input only. Specify the `output_uri` to populate an empty
   * `Job.config.output.uri` or `JobTemplate.config.output.uri` when using
   * template. URI for the output file(s). For example,
   * `gs://my-bucket/outputs/`. See [Supported input and output
   * formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
   */
  outputUri: string;
  /**
   * Input only. Specify the `template_id` to use for populating `Job.config`.
   * The default is `preset/web-hd`, which is the only supported preset.
   *
   * User defined JobTemplate: `{job_template_id}`
   */
  templateId?:
    | string
    | undefined;
  /** The configuration for this job. */
  config?:
    | JobConfig
    | undefined;
  /** Output only. The current state of the job. */
  state: Job_ProcessingState;
  /** Output only. The time the job was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the transcoding started. */
  startTime:
    | Date
    | undefined;
  /** Output only. The time the transcoding finished. */
  endTime:
    | Date
    | undefined;
  /**
   * Job time to live value in days, which will be effective after job
   * completion. Job should be deleted automatically after the given TTL. Enter
   * a value between 1 and 90. The default is 30.
   */
  ttlAfterCompletionDays: number;
  /**
   * The labels associated with this job. You can use these to organize and
   * group your jobs.
   */
  labels: { [key: string]: string };
  /**
   * Output only. An error object that describes the reason for the failure.
   * This property is always present when `state` is `FAILED`.
   */
  error:
    | Status
    | undefined;
  /**
   * The processing mode of the job.
   * The default is `PROCESSING_MODE_INTERACTIVE`.
   */
  mode: Job_ProcessingMode;
  /**
   * The processing priority of a batch job.
   * This field can only be set for batch mode jobs. The default value is 0.
   * This value cannot be negative. Higher values correspond to higher
   * priorities for the job.
   */
  batchModePriority: number;
  /**
   * Optional. The optimization strategy of the job. The default is
   * `AUTODETECT`.
   */
  optimization: Job_OptimizationStrategy;
}

/** The current state of the job. */
export enum Job_ProcessingState {
  /** PROCESSING_STATE_UNSPECIFIED - The processing state is not specified. */
  PROCESSING_STATE_UNSPECIFIED = 0,
  /** PENDING - The job is enqueued and will be picked up for processing soon. */
  PENDING = 1,
  /** RUNNING - The job is being processed. */
  RUNNING = 2,
  /** SUCCEEDED - The job has been completed successfully. */
  SUCCEEDED = 3,
  /**
   * FAILED - The job has failed. For additional information, see `failure_reason` and
   * `failure_details`
   */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function job_ProcessingStateFromJSON(object: any): Job_ProcessingState {
  switch (object) {
    case 0:
    case "PROCESSING_STATE_UNSPECIFIED":
      return Job_ProcessingState.PROCESSING_STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Job_ProcessingState.PENDING;
    case 2:
    case "RUNNING":
      return Job_ProcessingState.RUNNING;
    case 3:
    case "SUCCEEDED":
      return Job_ProcessingState.SUCCEEDED;
    case 4:
    case "FAILED":
      return Job_ProcessingState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_ProcessingState.UNRECOGNIZED;
  }
}

export function job_ProcessingStateToJSON(object: Job_ProcessingState): string {
  switch (object) {
    case Job_ProcessingState.PROCESSING_STATE_UNSPECIFIED:
      return "PROCESSING_STATE_UNSPECIFIED";
    case Job_ProcessingState.PENDING:
      return "PENDING";
    case Job_ProcessingState.RUNNING:
      return "RUNNING";
    case Job_ProcessingState.SUCCEEDED:
      return "SUCCEEDED";
    case Job_ProcessingState.FAILED:
      return "FAILED";
    case Job_ProcessingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The processing mode of the job. */
export enum Job_ProcessingMode {
  /** PROCESSING_MODE_UNSPECIFIED - The job processing mode is not specified. */
  PROCESSING_MODE_UNSPECIFIED = 0,
  /**
   * PROCESSING_MODE_INTERACTIVE - The job processing mode is interactive mode.
   * Interactive job will either be ran or rejected if quota does not allow
   * for it.
   */
  PROCESSING_MODE_INTERACTIVE = 1,
  /**
   * PROCESSING_MODE_BATCH - The job processing mode is batch mode.
   * Batch mode allows queuing of jobs.
   */
  PROCESSING_MODE_BATCH = 2,
  UNRECOGNIZED = -1,
}

export function job_ProcessingModeFromJSON(object: any): Job_ProcessingMode {
  switch (object) {
    case 0:
    case "PROCESSING_MODE_UNSPECIFIED":
      return Job_ProcessingMode.PROCESSING_MODE_UNSPECIFIED;
    case 1:
    case "PROCESSING_MODE_INTERACTIVE":
      return Job_ProcessingMode.PROCESSING_MODE_INTERACTIVE;
    case 2:
    case "PROCESSING_MODE_BATCH":
      return Job_ProcessingMode.PROCESSING_MODE_BATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_ProcessingMode.UNRECOGNIZED;
  }
}

export function job_ProcessingModeToJSON(object: Job_ProcessingMode): string {
  switch (object) {
    case Job_ProcessingMode.PROCESSING_MODE_UNSPECIFIED:
      return "PROCESSING_MODE_UNSPECIFIED";
    case Job_ProcessingMode.PROCESSING_MODE_INTERACTIVE:
      return "PROCESSING_MODE_INTERACTIVE";
    case Job_ProcessingMode.PROCESSING_MODE_BATCH:
      return "PROCESSING_MODE_BATCH";
    case Job_ProcessingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The optimization strategy of the job. The default is `AUTODETECT`. */
export enum Job_OptimizationStrategy {
  /** OPTIMIZATION_STRATEGY_UNSPECIFIED - The optimization strategy is not specified. */
  OPTIMIZATION_STRATEGY_UNSPECIFIED = 0,
  /** AUTODETECT - Prioritize job processing speed. */
  AUTODETECT = 1,
  /** DISABLED - Disable all optimizations. */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function job_OptimizationStrategyFromJSON(object: any): Job_OptimizationStrategy {
  switch (object) {
    case 0:
    case "OPTIMIZATION_STRATEGY_UNSPECIFIED":
      return Job_OptimizationStrategy.OPTIMIZATION_STRATEGY_UNSPECIFIED;
    case 1:
    case "AUTODETECT":
      return Job_OptimizationStrategy.AUTODETECT;
    case 2:
    case "DISABLED":
      return Job_OptimizationStrategy.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_OptimizationStrategy.UNRECOGNIZED;
  }
}

export function job_OptimizationStrategyToJSON(object: Job_OptimizationStrategy): string {
  switch (object) {
    case Job_OptimizationStrategy.OPTIMIZATION_STRATEGY_UNSPECIFIED:
      return "OPTIMIZATION_STRATEGY_UNSPECIFIED";
    case Job_OptimizationStrategy.AUTODETECT:
      return "AUTODETECT";
    case Job_OptimizationStrategy.DISABLED:
      return "DISABLED";
    case Job_OptimizationStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Job_LabelsEntry {
  key: string;
  value: string;
}

/** Transcoding job template resource. */
export interface JobTemplate {
  /**
   * The resource name of the job template.
   * Format:
   * `projects/{project_number}/locations/{location}/jobTemplates/{job_template}`
   */
  name: string;
  /** The configuration for this template. */
  config:
    | JobConfig
    | undefined;
  /**
   * The labels associated with this job template. You can use these to organize
   * and group your job templates.
   */
  labels: { [key: string]: string };
}

export interface JobTemplate_LabelsEntry {
  key: string;
  value: string;
}

/** Job configuration */
export interface JobConfig {
  /** List of input assets stored in Cloud Storage. */
  inputs: Input[];
  /**
   * List of `Edit atom`s. Defines the ultimate timeline of the resulting
   * file or manifest.
   */
  editList: EditAtom[];
  /** List of elementary streams. */
  elementaryStreams: ElementaryStream[];
  /** List of multiplexing settings for output streams. */
  muxStreams: MuxStream[];
  /** List of output manifests. */
  manifests: Manifest[];
  /** Output configuration. */
  output:
    | Output
    | undefined;
  /**
   * List of ad breaks. Specifies where to insert ad break tags in the output
   * manifests.
   */
  adBreaks: AdBreak[];
  /** Destination on Pub/Sub. */
  pubsubDestination:
    | PubsubDestination
    | undefined;
  /**
   * List of output sprite sheets.
   * Spritesheets require at least one VideoStream in the Jobconfig.
   */
  spriteSheets: SpriteSheet[];
  /** List of overlays on the output video, in descending Z-order. */
  overlays: Overlay[];
  /**
   * List of encryption configurations for the content.
   * Each configuration has an ID. Specify this ID in the
   * [MuxStream.encryption_id][google.cloud.video.transcoder.v1.MuxStream.encryption_id]
   * field to indicate the configuration to use for that `MuxStream` output.
   */
  encryptions: Encryption[];
}

/** Input asset. */
export interface Input {
  /**
   * A unique key for this input. Must be specified when using advanced
   * mapping and edit lists.
   */
  key: string;
  /**
   * URI of the media. Input files must be at least 5 seconds in duration and
   * stored in Cloud Storage (for example, `gs://bucket/inputs/file.mp4`).
   * If empty, the value is populated from `Job.input_uri`. See
   * [Supported input and output
   * formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
   */
  uri: string;
  /** Preprocessing configurations. */
  preprocessingConfig: PreprocessingConfig | undefined;
}

/** Location of output file(s) in a Cloud Storage bucket. */
export interface Output {
  /**
   * URI for the output file(s). For example, `gs://my-bucket/outputs/`.
   * If empty, the value is populated from `Job.output_uri`. See
   * [Supported input and output
   * formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats).
   */
  uri: string;
}

/** Edit atom. */
export interface EditAtom {
  /**
   * A unique key for this atom. Must be specified when using advanced
   * mapping.
   */
  key: string;
  /**
   * List of `Input.key`s identifying files that should be used in this atom.
   * The listed `inputs` must have the same timeline.
   */
  inputs: string[];
  /**
   * End time in seconds for the atom, relative to the input file timeline.
   * When `end_time_offset` is not specified, the `inputs` are used until
   * the end of the atom.
   */
  endTimeOffset:
    | Duration
    | undefined;
  /**
   * Start time in seconds for the atom, relative to the input file timeline.
   * The default is `0s`.
   */
  startTimeOffset: Duration | undefined;
}

/** Ad break. */
export interface AdBreak {
  /**
   * Start time in seconds for the ad break, relative to the output file
   * timeline. The default is `0s`.
   */
  startTimeOffset: Duration | undefined;
}

/**
 * Encoding of an input file such as an audio, video, or text track.
 * Elementary streams must be packaged before
 * mapping and sharing between different output formats.
 */
export interface ElementaryStream {
  /** A unique key for this elementary stream. */
  key: string;
  /** Encoding of a video stream. */
  videoStream?:
    | VideoStream
    | undefined;
  /** Encoding of an audio stream. */
  audioStream?:
    | AudioStream
    | undefined;
  /** Encoding of a text stream. For example, closed captions or subtitles. */
  textStream?: TextStream | undefined;
}

/** Multiplexing settings for output stream. */
export interface MuxStream {
  /**
   * A unique key for this multiplexed stream. HLS media manifests will be
   * named `MuxStream.key` with the `.m3u8` extension suffix.
   */
  key: string;
  /**
   * The name of the generated file. The default is `MuxStream.key` with the
   * extension suffix corresponding to the `MuxStream.container`.
   *
   * Individual segments also have an incremental 10-digit zero-padded suffix
   * starting from 0 before the extension, such as `mux_stream0000000123.ts`.
   */
  fileName: string;
  /**
   * The container format. The default is `mp4`
   *
   * Supported container formats:
   *
   * - `ts`
   * - `fmp4`- the corresponding file extension is `.m4s`
   * - `mp4`
   * - `vtt`
   *
   * See also:
   * [Supported input and output
   * formats](https://cloud.google.com/transcoder/docs/concepts/supported-input-and-output-formats)
   */
  container: string;
  /** List of `ElementaryStream.key`s multiplexed in this stream. */
  elementaryStreams: string[];
  /** Segment settings for `ts`, `fmp4` and `vtt`. */
  segmentSettings:
    | SegmentSettings
    | undefined;
  /**
   * Identifier of the encryption configuration to use. If omitted, output will
   * be unencrypted.
   */
  encryptionId: string;
}

/** Manifest configuration. */
export interface Manifest {
  /**
   * The name of the generated file. The default is `manifest` with the
   * extension suffix corresponding to the `Manifest.type`.
   */
  fileName: string;
  /** Required. Type of the manifest. */
  type: Manifest_ManifestType;
  /**
   * Required. List of user given `MuxStream.key`s that should appear in this
   * manifest.
   *
   * When `Manifest.type` is `HLS`, a media manifest with name `MuxStream.key`
   * and `.m3u8` extension is generated for each element of the
   * `Manifest.mux_streams`.
   */
  muxStreams: string[];
  /** `DASH` manifest configuration. */
  dash?: Manifest_DashConfig | undefined;
}

/** The manifest type, which corresponds to the adaptive streaming format used. */
export enum Manifest_ManifestType {
  /** MANIFEST_TYPE_UNSPECIFIED - The manifest type is not specified. */
  MANIFEST_TYPE_UNSPECIFIED = 0,
  /** HLS - Create an HLS manifest. The corresponding file extension is `.m3u8`. */
  HLS = 1,
  /** DASH - Create an MPEG-DASH manifest. The corresponding file extension is `.mpd`. */
  DASH = 2,
  UNRECOGNIZED = -1,
}

export function manifest_ManifestTypeFromJSON(object: any): Manifest_ManifestType {
  switch (object) {
    case 0:
    case "MANIFEST_TYPE_UNSPECIFIED":
      return Manifest_ManifestType.MANIFEST_TYPE_UNSPECIFIED;
    case 1:
    case "HLS":
      return Manifest_ManifestType.HLS;
    case 2:
    case "DASH":
      return Manifest_ManifestType.DASH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Manifest_ManifestType.UNRECOGNIZED;
  }
}

export function manifest_ManifestTypeToJSON(object: Manifest_ManifestType): string {
  switch (object) {
    case Manifest_ManifestType.MANIFEST_TYPE_UNSPECIFIED:
      return "MANIFEST_TYPE_UNSPECIFIED";
    case Manifest_ManifestType.HLS:
      return "HLS";
    case Manifest_ManifestType.DASH:
      return "DASH";
    case Manifest_ManifestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** `DASH` manifest configuration. */
export interface Manifest_DashConfig {
  /**
   * The segment reference scheme for a `DASH` manifest. The default is
   * `SEGMENT_LIST`.
   */
  segmentReferenceScheme: Manifest_DashConfig_SegmentReferenceScheme;
}

/** The segment reference scheme for a `DASH` manifest. */
export enum Manifest_DashConfig_SegmentReferenceScheme {
  /** SEGMENT_REFERENCE_SCHEME_UNSPECIFIED - The segment reference scheme is not specified. */
  SEGMENT_REFERENCE_SCHEME_UNSPECIFIED = 0,
  /** SEGMENT_LIST - Lists the URLs of media files for each segment. */
  SEGMENT_LIST = 1,
  /** SEGMENT_TEMPLATE_NUMBER - Lists each segment from a template with $Number$ variable. */
  SEGMENT_TEMPLATE_NUMBER = 2,
  UNRECOGNIZED = -1,
}

export function manifest_DashConfig_SegmentReferenceSchemeFromJSON(
  object: any,
): Manifest_DashConfig_SegmentReferenceScheme {
  switch (object) {
    case 0:
    case "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED":
      return Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_REFERENCE_SCHEME_UNSPECIFIED;
    case 1:
    case "SEGMENT_LIST":
      return Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_LIST;
    case 2:
    case "SEGMENT_TEMPLATE_NUMBER":
      return Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_TEMPLATE_NUMBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Manifest_DashConfig_SegmentReferenceScheme.UNRECOGNIZED;
  }
}

export function manifest_DashConfig_SegmentReferenceSchemeToJSON(
  object: Manifest_DashConfig_SegmentReferenceScheme,
): string {
  switch (object) {
    case Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_REFERENCE_SCHEME_UNSPECIFIED:
      return "SEGMENT_REFERENCE_SCHEME_UNSPECIFIED";
    case Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_LIST:
      return "SEGMENT_LIST";
    case Manifest_DashConfig_SegmentReferenceScheme.SEGMENT_TEMPLATE_NUMBER:
      return "SEGMENT_TEMPLATE_NUMBER";
    case Manifest_DashConfig_SegmentReferenceScheme.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Pub/Sub destination. */
export interface PubsubDestination {
  /**
   * The name of the Pub/Sub topic to publish job completion notification
   * to. For example: `projects/{project}/topics/{topic}`.
   */
  topic: string;
}

/** Sprite sheet configuration. */
export interface SpriteSheet {
  /**
   * Format type. The default is `jpeg`.
   *
   * Supported formats:
   *
   * - `jpeg`
   */
  format: string;
  /**
   * Required. File name prefix for the generated sprite sheets.
   *
   * Each sprite sheet has an incremental 10-digit zero-padded suffix starting
   * from 0 before the extension, such as `sprite_sheet0000000123.jpeg`.
   */
  filePrefix: string;
  /**
   * Required. The width of sprite in pixels. Must be an even integer. To
   * preserve the source aspect ratio, set the
   * [SpriteSheet.sprite_width_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_width_pixels]
   * field or the
   * [SpriteSheet.sprite_height_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_height_pixels]
   * field, but not both (the API will automatically calculate the missing
   * field).
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the width, in pixels, per the horizontal ASR. The API calculates
   * the height per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  spriteWidthPixels: number;
  /**
   * Required. The height of sprite in pixels. Must be an even integer. To
   * preserve the source aspect ratio, set the
   * [SpriteSheet.sprite_height_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_height_pixels]
   * field or the
   * [SpriteSheet.sprite_width_pixels][google.cloud.video.transcoder.v1.SpriteSheet.sprite_width_pixels]
   * field, but not both (the API will automatically calculate the missing
   * field).
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the height, in pixels, per the horizontal ASR. The API calculates
   * the width per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  spriteHeightPixels: number;
  /**
   * The maximum number of sprites per row in a sprite sheet. The default is 0,
   * which indicates no maximum limit.
   */
  columnCount: number;
  /**
   * The maximum number of rows per sprite sheet. When the sprite sheet is full,
   * a new sprite sheet is created. The default is 0, which indicates no maximum
   * limit.
   */
  rowCount: number;
  /**
   * Start time in seconds, relative to the output file timeline. Determines the
   * first sprite to pick. The default is `0s`.
   */
  startTimeOffset:
    | Duration
    | undefined;
  /**
   * End time in seconds, relative to the output file timeline. When
   * `end_time_offset` is not specified, the sprites are generated until the end
   * of the output file.
   */
  endTimeOffset:
    | Duration
    | undefined;
  /**
   * Total number of sprites. Create the specified number of sprites
   * distributed evenly across the timeline of the output media. The default
   * is 100.
   */
  totalCount?:
    | number
    | undefined;
  /**
   * Starting from `0s`, create sprites at regular intervals. Specify the
   * interval value in seconds.
   */
  interval?:
    | Duration
    | undefined;
  /**
   * The quality of the generated sprite sheet. Enter a value between 1
   * and 100, where 1 is the lowest quality and 100 is the highest quality.
   * The default is 100. A high quality value corresponds to a low image data
   * compression ratio.
   */
  quality: number;
}

/** Overlay configuration. */
export interface Overlay {
  /** Image overlay. */
  image:
    | Overlay_Image
    | undefined;
  /**
   * List of Animations. The list should be chronological, without any time
   * overlap.
   */
  animations: Overlay_Animation[];
}

/** Fade type for the overlay: `FADE_IN` or `FADE_OUT`. */
export enum Overlay_FadeType {
  /** FADE_TYPE_UNSPECIFIED - The fade type is not specified. */
  FADE_TYPE_UNSPECIFIED = 0,
  /** FADE_IN - Fade the overlay object into view. */
  FADE_IN = 1,
  /** FADE_OUT - Fade the overlay object out of view. */
  FADE_OUT = 2,
  UNRECOGNIZED = -1,
}

export function overlay_FadeTypeFromJSON(object: any): Overlay_FadeType {
  switch (object) {
    case 0:
    case "FADE_TYPE_UNSPECIFIED":
      return Overlay_FadeType.FADE_TYPE_UNSPECIFIED;
    case 1:
    case "FADE_IN":
      return Overlay_FadeType.FADE_IN;
    case 2:
    case "FADE_OUT":
      return Overlay_FadeType.FADE_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Overlay_FadeType.UNRECOGNIZED;
  }
}

export function overlay_FadeTypeToJSON(object: Overlay_FadeType): string {
  switch (object) {
    case Overlay_FadeType.FADE_TYPE_UNSPECIFIED:
      return "FADE_TYPE_UNSPECIFIED";
    case Overlay_FadeType.FADE_IN:
      return "FADE_IN";
    case Overlay_FadeType.FADE_OUT:
      return "FADE_OUT";
    case Overlay_FadeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 2D normalized coordinates. Default: `{0.0, 0.0}` */
export interface Overlay_NormalizedCoordinate {
  /** Normalized x coordinate. */
  x: number;
  /** Normalized y coordinate. */
  y: number;
}

/** Overlaid image. */
export interface Overlay_Image {
  /**
   * Required. URI of the image in Cloud Storage. For example,
   * `gs://bucket/inputs/image.png`. Only PNG and JPEG images are supported.
   */
  uri: string;
  /**
   * Normalized image resolution, based on output video resolution. Valid
   * values: `0.0`–`1.0`. To respect the original image aspect ratio, set
   * either `x` or `y` to `0.0`. To use the original image resolution, set
   * both `x` and `y` to `0.0`.
   */
  resolution:
    | Overlay_NormalizedCoordinate
    | undefined;
  /**
   * Target image opacity. Valid values are from  `1.0` (solid, default) to
   * `0.0` (transparent), exclusive. Set this to a value greater than `0.0`.
   */
  alpha: number;
}

/** Display static overlay object. */
export interface Overlay_AnimationStatic {
  /**
   * Normalized coordinates based on output video resolution. Valid
   * values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
   * object. For example, use the x and y coordinates {0,0} to position the
   * top-left corner of the overlay animation in the top-left corner of the
   * output video.
   */
  xy:
    | Overlay_NormalizedCoordinate
    | undefined;
  /** The time to start displaying the overlay object, in seconds. Default: 0 */
  startTimeOffset: Duration | undefined;
}

/** Display overlay object with fade animation. */
export interface Overlay_AnimationFade {
  /** Required. Type of fade animation: `FADE_IN` or `FADE_OUT`. */
  fadeType: Overlay_FadeType;
  /**
   * Normalized coordinates based on output video resolution. Valid
   * values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
   * object. For example, use the x and y coordinates {0,0} to position the
   * top-left corner of the overlay animation in the top-left corner of the
   * output video.
   */
  xy:
    | Overlay_NormalizedCoordinate
    | undefined;
  /** The time to start the fade animation, in seconds. Default: 0 */
  startTimeOffset:
    | Duration
    | undefined;
  /**
   * The time to end the fade animation, in seconds. Default:
   * `start_time_offset` + 1s
   */
  endTimeOffset: Duration | undefined;
}

/**
 * End previous overlay animation from the video. Without AnimationEnd, the
 * overlay object will keep the state of previous animation until the end of
 * the video.
 */
export interface Overlay_AnimationEnd {
  /** The time to end overlay object, in seconds. Default: 0 */
  startTimeOffset: Duration | undefined;
}

/** Animation types. */
export interface Overlay_Animation {
  /** Display static overlay object. */
  animationStatic?:
    | Overlay_AnimationStatic
    | undefined;
  /** Display overlay object with fade animation. */
  animationFade?:
    | Overlay_AnimationFade
    | undefined;
  /** End previous animation. */
  animationEnd?: Overlay_AnimationEnd | undefined;
}

/** Preprocessing configurations. */
export interface PreprocessingConfig {
  /** Color preprocessing configuration. */
  color:
    | PreprocessingConfig_Color
    | undefined;
  /** Denoise preprocessing configuration. */
  denoise:
    | PreprocessingConfig_Denoise
    | undefined;
  /** Deblock preprocessing configuration. */
  deblock:
    | PreprocessingConfig_Deblock
    | undefined;
  /** Audio preprocessing configuration. */
  audio:
    | PreprocessingConfig_Audio
    | undefined;
  /** Specify the video cropping configuration. */
  crop:
    | PreprocessingConfig_Crop
    | undefined;
  /** Specify the video pad filter configuration. */
  pad:
    | PreprocessingConfig_Pad
    | undefined;
  /** Specify the video deinterlace configuration. */
  deinterlace: PreprocessingConfig_Deinterlace | undefined;
}

/**
 * Color preprocessing configuration.
 *
 * **Note:** This configuration is not supported.
 */
export interface PreprocessingConfig_Color {
  /**
   * Control color saturation of the video. Enter a value between -1 and 1,
   * where -1 is fully desaturated and 1 is maximum saturation. 0 is no
   * change. The default is 0.
   */
  saturation: number;
  /**
   * Control black and white contrast of the video. Enter a value between -1
   * and 1, where -1 is minimum contrast and 1 is maximum contrast. 0 is no
   * change. The default is 0.
   */
  contrast: number;
  /**
   * Control brightness of the video. Enter a value between -1 and 1, where -1
   * is minimum brightness and 1 is maximum brightness. 0 is no change. The
   * default is 0.
   */
  brightness: number;
}

/**
 * Denoise preprocessing configuration.
 *
 * **Note:** This configuration is not supported.
 */
export interface PreprocessingConfig_Denoise {
  /**
   * Set strength of the denoise. Enter a value between 0 and 1. The higher
   * the value, the smoother the image. 0 is no denoising. The default is 0.
   */
  strength: number;
  /**
   * Set the denoiser mode. The default is `standard`.
   *
   * Supported denoiser modes:
   *
   * - `standard`
   * - `grain`
   */
  tune: string;
}

/**
 * Deblock preprocessing configuration.
 *
 * **Note:** This configuration is not supported.
 */
export interface PreprocessingConfig_Deblock {
  /**
   * Set strength of the deblocker. Enter a value between 0 and 1. The higher
   * the value, the stronger the block removal. 0 is no deblocking. The
   * default is 0.
   */
  strength: number;
  /** Enable deblocker. The default is `false`. */
  enabled: boolean;
}

/** Audio preprocessing configuration. */
export interface PreprocessingConfig_Audio {
  /**
   * Specify audio loudness normalization in loudness units relative to full
   * scale (LUFS). Enter a value between -24 and 0 (the default), where:
   *
   * *   -24 is the Advanced Television Systems Committee (ATSC A/85) standard
   * *   -23 is the EU R128 broadcast standard
   * *   -19 is the prior standard for online mono audio
   * *   -18 is the ReplayGain standard
   * *   -16 is the prior standard for stereo audio
   * *   -14 is the new online audio standard recommended by Spotify, as well
   *     as Amazon Echo
   * *   0 disables normalization
   */
  lufs: number;
  /**
   * Enable boosting high frequency components. The default is `false`.
   *
   * **Note:** This field is not supported.
   */
  highBoost: boolean;
  /**
   * Enable boosting low frequency components. The default is `false`.
   *
   * **Note:** This field is not supported.
   */
  lowBoost: boolean;
}

/**
 * Video cropping configuration for the input video. The cropped input video
 * is scaled to match the output resolution.
 */
export interface PreprocessingConfig_Crop {
  /** The number of pixels to crop from the top. The default is 0. */
  topPixels: number;
  /** The number of pixels to crop from the bottom. The default is 0. */
  bottomPixels: number;
  /** The number of pixels to crop from the left. The default is 0. */
  leftPixels: number;
  /** The number of pixels to crop from the right. The default is 0. */
  rightPixels: number;
}

/**
 * Pad filter configuration for the input video. The padded input video
 * is scaled after padding with black to match the output resolution.
 */
export interface PreprocessingConfig_Pad {
  /** The number of pixels to add to the top. The default is 0. */
  topPixels: number;
  /** The number of pixels to add to the bottom. The default is 0. */
  bottomPixels: number;
  /** The number of pixels to add to the left. The default is 0. */
  leftPixels: number;
  /** The number of pixels to add to the right. The default is 0. */
  rightPixels: number;
}

/** Deinterlace configuration for input video. */
export interface PreprocessingConfig_Deinterlace {
  /** Specifies the Yet Another Deinterlacing Filter Configuration. */
  yadif?:
    | PreprocessingConfig_Deinterlace_YadifConfig
    | undefined;
  /** Specifies the Bob Weaver Deinterlacing Filter Configuration. */
  bwdif?: PreprocessingConfig_Deinterlace_BwdifConfig | undefined;
}

/** Yet Another Deinterlacing Filter Configuration. */
export interface PreprocessingConfig_Deinterlace_YadifConfig {
  /**
   * Specifies the deinterlacing mode to adopt.
   * The default is `send_frame`.
   * Supported values:
   *
   * - `send_frame`: Output one frame for each frame
   * - `send_field`: Output one frame for each field
   */
  mode: string;
  /**
   * Disable spacial interlacing.
   * The default is `false`.
   */
  disableSpatialInterlacing: boolean;
  /**
   * The picture field parity assumed for the input interlaced video.
   * The default is `auto`.
   * Supported values:
   *
   * - `tff`: Assume the top field is first
   * - `bff`: Assume the bottom field is first
   * - `auto`: Enable automatic detection of field parity
   */
  parity: string;
  /**
   * Deinterlace all frames rather than just the frames identified as
   * interlaced. The default is `false`.
   */
  deinterlaceAllFrames: boolean;
}

/** Bob Weaver Deinterlacing Filter Configuration. */
export interface PreprocessingConfig_Deinterlace_BwdifConfig {
  /**
   * Specifies the deinterlacing mode to adopt.
   * The default is `send_frame`.
   * Supported values:
   *
   * - `send_frame`: Output one frame for each frame
   * - `send_field`: Output one frame for each field
   */
  mode: string;
  /**
   * The picture field parity assumed for the input interlaced video.
   * The default is `auto`.
   * Supported values:
   *
   * - `tff`: Assume the top field is first
   * - `bff`: Assume the bottom field is first
   * - `auto`: Enable automatic detection of field parity
   */
  parity: string;
  /**
   * Deinterlace all frames rather than just the frames identified as
   * interlaced. The default is `false`.
   */
  deinterlaceAllFrames: boolean;
}

/** Video stream resource. */
export interface VideoStream {
  /** H264 codec settings. */
  h264?:
    | VideoStream_H264CodecSettings
    | undefined;
  /** H265 codec settings. */
  h265?:
    | VideoStream_H265CodecSettings
    | undefined;
  /** VP9 codec settings. */
  vp9?: VideoStream_Vp9CodecSettings | undefined;
}

/** H264 codec settings. */
export interface VideoStream_H264CodecSettings {
  /**
   * The width of the video in pixels. Must be an even integer.
   * When not specified, the width is adjusted to match the specified height
   * and input aspect ratio. If both are omitted, the input width is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the width, in pixels, per the horizontal ASR. The API calculates
   * the height per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  widthPixels: number;
  /**
   * The height of the video in pixels. Must be an even integer.
   * When not specified, the height is adjusted to match the specified width
   * and input aspect ratio. If both are omitted, the input height is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the height, in pixels, per the horizontal ASR. The API calculates
   * the width per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  heightPixels: number;
  /**
   * Required. The target video frame rate in frames per second (FPS). Must be
   * less than or equal to 120. Will default to the input frame rate if larger
   * than the input frame rate. The API will generate an output FPS that is
   * divisible by the input FPS, and smaller or equal to the target FPS. See
   * [Calculating frame
   * rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for
   * more information.
   */
  frameRate: number;
  /**
   * Required. The video bitrate in bits per second. The minimum value is
   * 1,000. The maximum value is 800,000,000.
   */
  bitrateBps: number;
  /**
   * Pixel format to use. The default is `yuv420p`.
   *
   * Supported pixel formats:
   *
   * - `yuv420p` pixel format
   * - `yuv422p` pixel format
   * - `yuv444p` pixel format
   * - `yuv420p10` 10-bit HDR pixel format
   * - `yuv422p10` 10-bit HDR pixel format
   * - `yuv444p10` 10-bit HDR pixel format
   * - `yuv420p12` 12-bit HDR pixel format
   * - `yuv422p12` 12-bit HDR pixel format
   * - `yuv444p12` 12-bit HDR pixel format
   */
  pixelFormat: string;
  /**
   * Specify the `rate_control_mode`. The default is `vbr`.
   *
   * Supported rate control modes:
   *
   * - `vbr` - variable bitrate
   * - `crf` - constant rate factor
   */
  rateControlMode: string;
  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest
   * quality and 36 is the most efficient compression. The default is 21.
   */
  crfLevel: number;
  /**
   * Specifies whether an open Group of Pictures (GOP) structure should be
   * allowed or not. The default is `false`.
   */
  allowOpenGop: boolean;
  /**
   * Select the GOP size based on the specified frame count. Must be greater
   * than zero.
   */
  gopFrameCount?:
    | number
    | undefined;
  /**
   * Select the GOP size based on the specified duration. The default is
   * `3s`. Note that `gopDuration` must be less than or equal to
   * [`segmentDuration`](#SegmentSettings), and
   * [`segmentDuration`](#SegmentSettings) must be divisible by
   * `gopDuration`.
   */
  gopDuration?:
    | Duration
    | undefined;
  /**
   * Use two-pass encoding strategy to achieve better video quality.
   * `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
   */
  enableTwoPass: boolean;
  /**
   * Size of the Video Buffering Verifier (VBV) buffer in bits. Must be
   * greater than zero. The default is equal to `VideoStream.bitrate_bps`.
   */
  vbvSizeBits: number;
  /**
   * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
   * Must be greater than zero. The default is equal to 90% of
   * `VideoStream.vbv_size_bits`.
   */
  vbvFullnessBits: number;
  /**
   * The entropy coder to use. The default is `cabac`.
   *
   * Supported entropy coders:
   *
   * - `cavlc`
   * - `cabac`
   */
  entropyCoder: string;
  /**
   * Allow B-pyramid for reference frame selection. This may not be supported
   * on all decoders. The default is `false`.
   */
  bPyramid: boolean;
  /**
   * The number of consecutive B-frames. Must be greater than or equal to
   * zero. Must be less than `VideoStream.gop_frame_count` if set. The default
   * is 0.
   */
  bFrameCount: number;
  /**
   * Specify the intensity of the adaptive quantizer (AQ). Must be between 0
   * and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
   * higher value equals a lower bitrate but smoother image. The default is 0.
   */
  aqStrength: number;
  /**
   * Enforces the specified codec profile. The following profiles are
   * supported:
   *
   * *   `baseline`
   * *   `main`
   * *   `high` (default)
   *
   * The available options are
   * [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H264CodecSettings`
   * message.
   */
  profile: string;
  /**
   * Enforces the specified codec tune. The available options are
   * [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Tune).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H264CodecSettings`
   * message.
   */
  tune: string;
  /**
   * Enforces the specified codec preset. The default is `veryfast`. The
   * available options are
   * [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.264#Preset).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H264CodecSettings`
   * message.
   */
  preset: string;
}

/** H265 codec settings. */
export interface VideoStream_H265CodecSettings {
  /**
   * The width of the video in pixels. Must be an even integer.
   * When not specified, the width is adjusted to match the specified height
   * and input aspect ratio. If both are omitted, the input width is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the width, in pixels, per the horizontal ASR. The API calculates
   * the height per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  widthPixels: number;
  /**
   * The height of the video in pixels. Must be an even integer.
   * When not specified, the height is adjusted to match the specified width
   * and input aspect ratio. If both are omitted, the input height is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the height, in pixels, per the horizontal ASR. The API calculates
   * the width per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  heightPixels: number;
  /**
   * Required. The target video frame rate in frames per second (FPS). Must be
   * less than or equal to 120. Will default to the input frame rate if larger
   * than the input frame rate. The API will generate an output FPS that is
   * divisible by the input FPS, and smaller or equal to the target FPS. See
   * [Calculating frame
   * rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for
   * more information.
   */
  frameRate: number;
  /**
   * Required. The video bitrate in bits per second. The minimum value is
   * 1,000. The maximum value is 800,000,000.
   */
  bitrateBps: number;
  /**
   * Pixel format to use. The default is `yuv420p`.
   *
   * Supported pixel formats:
   *
   * - `yuv420p` pixel format
   * - `yuv422p` pixel format
   * - `yuv444p` pixel format
   * - `yuv420p10` 10-bit HDR pixel format
   * - `yuv422p10` 10-bit HDR pixel format
   * - `yuv444p10` 10-bit HDR pixel format
   * - `yuv420p12` 12-bit HDR pixel format
   * - `yuv422p12` 12-bit HDR pixel format
   * - `yuv444p12` 12-bit HDR pixel format
   */
  pixelFormat: string;
  /**
   * Specify the `rate_control_mode`. The default is `vbr`.
   *
   * Supported rate control modes:
   *
   * - `vbr` - variable bitrate
   * - `crf` - constant rate factor
   */
  rateControlMode: string;
  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest
   * quality and 36 is the most efficient compression. The default is 21.
   */
  crfLevel: number;
  /**
   * Specifies whether an open Group of Pictures (GOP) structure should be
   * allowed or not. The default is `false`.
   */
  allowOpenGop: boolean;
  /**
   * Select the GOP size based on the specified frame count. Must be greater
   * than zero.
   */
  gopFrameCount?:
    | number
    | undefined;
  /**
   * Select the GOP size based on the specified duration. The default is
   * `3s`. Note that `gopDuration` must be less than or equal to
   * [`segmentDuration`](#SegmentSettings), and
   * [`segmentDuration`](#SegmentSettings) must be divisible by
   * `gopDuration`.
   */
  gopDuration?:
    | Duration
    | undefined;
  /**
   * Use two-pass encoding strategy to achieve better video quality.
   * `VideoStream.rate_control_mode` must be `vbr`. The default is `false`.
   */
  enableTwoPass: boolean;
  /**
   * Size of the Video Buffering Verifier (VBV) buffer in bits. Must be
   * greater than zero. The default is equal to `VideoStream.bitrate_bps`.
   */
  vbvSizeBits: number;
  /**
   * Initial fullness of the Video Buffering Verifier (VBV) buffer in bits.
   * Must be greater than zero. The default is equal to 90% of
   * `VideoStream.vbv_size_bits`.
   */
  vbvFullnessBits: number;
  /**
   * Allow B-pyramid for reference frame selection. This may not be supported
   * on all decoders. The default is `false`.
   */
  bPyramid: boolean;
  /**
   * The number of consecutive B-frames. Must be greater than or equal to
   * zero. Must be less than `VideoStream.gop_frame_count` if set. The default
   * is 0.
   */
  bFrameCount: number;
  /**
   * Specify the intensity of the adaptive quantizer (AQ). Must be between 0
   * and 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
   * higher value equals a lower bitrate but smoother image. The default is 0.
   */
  aqStrength: number;
  /**
   * Enforces the specified codec profile. The following profiles are
   * supported:
   *
   * *   8-bit profiles
   *     *   `main` (default)
   *     *   `main-intra`
   *     *   `mainstillpicture`
   * *   10-bit profiles
   *     *   `main10` (default)
   *     *   `main10-intra`
   *     *   `main422-10`
   *     *   `main422-10-intra`
   *     *   `main444-10`
   *     *   `main444-10-intra`
   * *   12-bit profiles
   *     *   `main12` (default)
   *     *   `main12-intra`
   *     *   `main422-12`
   *     *   `main422-12-intra`
   *     *   `main444-12`
   *     *   `main444-12-intra`
   *
   * The available options are
   * [FFmpeg-compatible](https://x265.readthedocs.io/).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H265CodecSettings`
   * message.
   */
  profile: string;
  /**
   * Enforces the specified codec tune. The available options are
   * [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H265CodecSettings`
   * message.
   */
  tune: string;
  /**
   * Enforces the specified codec preset. The default is `veryfast`. The
   * available options are
   * [FFmpeg-compatible](https://trac.ffmpeg.org/wiki/Encode/H.265).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `H265CodecSettings`
   * message.
   */
  preset: string;
}

/** VP9 codec settings. */
export interface VideoStream_Vp9CodecSettings {
  /**
   * The width of the video in pixels. Must be an even integer.
   * When not specified, the width is adjusted to match the specified height
   * and input aspect ratio. If both are omitted, the input width is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the width, in pixels, per the horizontal ASR. The API calculates
   * the height per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  widthPixels: number;
  /**
   * The height of the video in pixels. Must be an even integer.
   * When not specified, the height is adjusted to match the specified width
   * and input aspect ratio. If both are omitted, the input height is used.
   *
   * For portrait videos that contain horizontal ASR and rotation metadata,
   * provide the height, in pixels, per the horizontal ASR. The API calculates
   * the width per the horizontal ASR. The API detects any rotation metadata
   * and swaps the requested height and width for the output.
   */
  heightPixels: number;
  /**
   * Required. The target video frame rate in frames per second (FPS). Must be
   * less than or equal to 120. Will default to the input frame rate if larger
   * than the input frame rate. The API will generate an output FPS that is
   * divisible by the input FPS, and smaller or equal to the target FPS. See
   * [Calculating frame
   * rate](https://cloud.google.com/transcoder/docs/concepts/frame-rate) for
   * more information.
   */
  frameRate: number;
  /**
   * Required. The video bitrate in bits per second. The minimum value is
   * 1,000. The maximum value is 480,000,000.
   */
  bitrateBps: number;
  /**
   * Pixel format to use. The default is `yuv420p`.
   *
   * Supported pixel formats:
   *
   * - `yuv420p` pixel format
   * - `yuv422p` pixel format
   * - `yuv444p` pixel format
   * - `yuv420p10` 10-bit HDR pixel format
   * - `yuv422p10` 10-bit HDR pixel format
   * - `yuv444p10` 10-bit HDR pixel format
   * - `yuv420p12` 12-bit HDR pixel format
   * - `yuv422p12` 12-bit HDR pixel format
   * - `yuv444p12` 12-bit HDR pixel format
   */
  pixelFormat: string;
  /**
   * Specify the `rate_control_mode`. The default is `vbr`.
   *
   * Supported rate control modes:
   *
   * - `vbr` - variable bitrate
   */
  rateControlMode: string;
  /**
   * Target CRF level. Must be between 10 and 36, where 10 is the highest
   * quality and 36 is the most efficient compression. The default is 21.
   *
   * **Note:** This field is not supported.
   */
  crfLevel: number;
  /**
   * Select the GOP size based on the specified frame count. Must be greater
   * than zero.
   */
  gopFrameCount?:
    | number
    | undefined;
  /**
   * Select the GOP size based on the specified duration. The default is
   * `3s`. Note that `gopDuration` must be less than or equal to
   * [`segmentDuration`](#SegmentSettings), and
   * [`segmentDuration`](#SegmentSettings) must be divisible by
   * `gopDuration`.
   */
  gopDuration?:
    | Duration
    | undefined;
  /**
   * Enforces the specified codec profile. The following profiles are
   * supported:
   *
   * *   `profile0` (default)
   * *   `profile1`
   * *   `profile2`
   * *   `profile3`
   *
   * The available options are
   * [WebM-compatible](https://www.webmproject.org/vp9/profiles/).
   * Note that certain values for this field may cause the
   * transcoder to override other fields you set in the `Vp9CodecSettings`
   * message.
   */
  profile: string;
}

/** Audio stream resource. */
export interface AudioStream {
  /**
   * The codec for this audio stream. The default is `aac`.
   *
   * Supported audio codecs:
   *
   * - `aac`
   * - `aac-he`
   * - `aac-he-v2`
   * - `mp3`
   * - `ac3`
   * - `eac3`
   */
  codec: string;
  /**
   * Required. Audio bitrate in bits per second. Must be between 1 and
   * 10,000,000.
   */
  bitrateBps: number;
  /** Number of audio channels. Must be between 1 and 6. The default is 2. */
  channelCount: number;
  /**
   * A list of channel names specifying layout of the audio channels.
   * This only affects the metadata embedded in the container headers, if
   * supported by the specified format. The default is `["fl", "fr"]`.
   *
   * Supported channel names:
   *
   * - `fl` - Front left channel
   * - `fr` - Front right channel
   * - `sl` - Side left channel
   * - `sr` - Side right channel
   * - `fc` - Front center channel
   * - `lfe` - Low frequency
   */
  channelLayout: string[];
  /** The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`. */
  mapping: AudioStream_AudioMapping[];
  /** The audio sample rate in Hertz. The default is 48000 Hertz. */
  sampleRateHertz: number;
  /**
   * The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
   * information, see
   * https://www.unicode.org/reports/tr35/#Unicode_locale_identifier. Not
   * supported in MP4 files.
   */
  languageCode: string;
  /**
   * The name for this particular audio stream that
   * will be added to the HLS/DASH manifest. Not supported in MP4 files.
   */
  displayName: string;
}

/** The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`. */
export interface AudioStream_AudioMapping {
  /**
   * Required. The `EditAtom.key` that references the atom with audio inputs
   * in the `Job.edit_list`.
   */
  atomKey: string;
  /** Required. The `Input.key` that identifies the input file. */
  inputKey: string;
  /** Required. The zero-based index of the track in the input file. */
  inputTrack: number;
  /** Required. The zero-based index of the channel in the input audio stream. */
  inputChannel: number;
  /** Required. The zero-based index of the channel in the output audio stream. */
  outputChannel: number;
  /**
   * Audio volume control in dB. Negative values decrease volume,
   * positive values increase. The default is 0.
   */
  gainDb: number;
}

/** Encoding of a text stream. For example, closed captions or subtitles. */
export interface TextStream {
  /**
   * The codec for this text stream. The default is `webvtt`.
   *
   * Supported text codecs:
   *
   * - `srt`
   * - `ttml`
   * - `cea608`
   * - `cea708`
   * - `webvtt`
   */
  codec: string;
  /**
   * The BCP-47 language code, such as `en-US` or `sr-Latn`. For more
   * information, see
   * https://www.unicode.org/reports/tr35/#Unicode_locale_identifier. Not
   * supported in MP4 files.
   */
  languageCode: string;
  /** The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`. */
  mapping: TextStream_TextMapping[];
  /**
   * The name for this particular text stream that
   * will be added to the HLS/DASH manifest. Not supported in MP4 files.
   */
  displayName: string;
}

/** The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`. */
export interface TextStream_TextMapping {
  /**
   * Required. The `EditAtom.key` that references atom with text inputs in the
   * `Job.edit_list`.
   */
  atomKey: string;
  /** Required. The `Input.key` that identifies the input file. */
  inputKey: string;
  /** Required. The zero-based index of the track in the input file. */
  inputTrack: number;
}

/** Segment settings for `ts`, `fmp4` and `vtt`. */
export interface SegmentSettings {
  /**
   * Duration of the segments in seconds. The default is `6.0s`. Note that
   * `segmentDuration` must be greater than or equal to
   * [`gopDuration`](#videostream), and `segmentDuration` must be divisible by
   * [`gopDuration`](#videostream).
   */
  segmentDuration:
    | Duration
    | undefined;
  /** Required. Create an individual segment file. The default is `false`. */
  individualSegments: boolean;
}

/** Encryption settings. */
export interface Encryption {
  /** Required. Identifier for this set of encryption options. */
  id: string;
  /** Configuration for AES-128 encryption. */
  aes128?:
    | Encryption_Aes128Encryption
    | undefined;
  /** Configuration for SAMPLE-AES encryption. */
  sampleAes?:
    | Encryption_SampleAesEncryption
    | undefined;
  /** Configuration for MPEG Common Encryption (MPEG-CENC). */
  mpegCenc?:
    | Encryption_MpegCommonEncryption
    | undefined;
  /** Keys are stored in Google Secret Manager. */
  secretManagerKeySource?:
    | Encryption_SecretManagerSource
    | undefined;
  /**
   * Required. DRM system(s) to use; at least one must be specified. If a
   * DRM system is omitted, it is considered disabled.
   */
  drmSystems: Encryption_DrmSystems | undefined;
}

/** Configuration for AES-128 encryption. */
export interface Encryption_Aes128Encryption {
}

/** Configuration for SAMPLE-AES encryption. */
export interface Encryption_SampleAesEncryption {
}

/** Configuration for MPEG Common Encryption (MPEG-CENC). */
export interface Encryption_MpegCommonEncryption {
  /**
   * Required. Specify the encryption scheme.
   *
   * Supported encryption schemes:
   *
   * - `cenc`
   * - `cbcs`
   */
  scheme: string;
}

/** Configuration for secrets stored in Google Secret Manager. */
export interface Encryption_SecretManagerSource {
  /**
   * Required. The name of the Secret Version containing the encryption key in
   * the following format:
   * `projects/{project}/secrets/{secret_id}/versions/{version_number}`
   *
   * Note that only numbered versions are supported. Aliases like "latest" are
   * not supported.
   */
  secretVersion: string;
}

/** Widevine configuration. */
export interface Encryption_Widevine {
}

/** Fairplay configuration. */
export interface Encryption_Fairplay {
}

/** Playready configuration. */
export interface Encryption_Playready {
}

/** Clearkey configuration. */
export interface Encryption_Clearkey {
}

/** Defines configuration for DRM systems in use. */
export interface Encryption_DrmSystems {
  /** Widevine configuration. */
  widevine:
    | Encryption_Widevine
    | undefined;
  /** Fairplay configuration. */
  fairplay:
    | Encryption_Fairplay
    | undefined;
  /** Playready configuration. */
  playready:
    | Encryption_Playready
    | undefined;
  /** Clearkey configuration. */
  clearkey: Encryption_Clearkey | undefined;
}

function createBaseJob(): Job {
  return {
    name: "",
    inputUri: "",
    outputUri: "",
    templateId: undefined,
    config: undefined,
    state: 0,
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    ttlAfterCompletionDays: 0,
    labels: {},
    error: undefined,
    mode: 0,
    batchModePriority: 0,
    optimization: 0,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.inputUri !== "") {
      writer.uint32(18).string(message.inputUri);
    }
    if (message.outputUri !== "") {
      writer.uint32(26).string(message.outputUri);
    }
    if (message.templateId !== undefined) {
      writer.uint32(34).string(message.templateId);
    }
    if (message.config !== undefined) {
      JobConfig.encode(message.config, writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(98).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(106).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(114).fork()).join();
    }
    if (message.ttlAfterCompletionDays !== 0) {
      writer.uint32(120).int32(message.ttlAfterCompletionDays);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Job_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(138).fork()).join();
    }
    if (message.mode !== 0) {
      writer.uint32(160).int32(message.mode);
    }
    if (message.batchModePriority !== 0) {
      writer.uint32(168).int32(message.batchModePriority);
    }
    if (message.optimization !== 0) {
      writer.uint32(176).int32(message.optimization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.templateId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.config = JobConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.ttlAfterCompletionDays = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = Job_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.batchModePriority = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.optimization = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      inputUri: isSet(object.inputUri) ? globalThis.String(object.inputUri) : "",
      outputUri: isSet(object.outputUri) ? globalThis.String(object.outputUri) : "",
      templateId: isSet(object.templateId) ? globalThis.String(object.templateId) : undefined,
      config: isSet(object.config) ? JobConfig.fromJSON(object.config) : undefined,
      state: isSet(object.state) ? job_ProcessingStateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      ttlAfterCompletionDays: isSet(object.ttlAfterCompletionDays)
        ? globalThis.Number(object.ttlAfterCompletionDays)
        : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      mode: isSet(object.mode) ? job_ProcessingModeFromJSON(object.mode) : 0,
      batchModePriority: isSet(object.batchModePriority) ? globalThis.Number(object.batchModePriority) : 0,
      optimization: isSet(object.optimization) ? job_OptimizationStrategyFromJSON(object.optimization) : 0,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.inputUri !== "") {
      obj.inputUri = message.inputUri;
    }
    if (message.outputUri !== "") {
      obj.outputUri = message.outputUri;
    }
    if (message.templateId !== undefined) {
      obj.templateId = message.templateId;
    }
    if (message.config !== undefined) {
      obj.config = JobConfig.toJSON(message.config);
    }
    if (message.state !== 0) {
      obj.state = job_ProcessingStateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.ttlAfterCompletionDays !== 0) {
      obj.ttlAfterCompletionDays = Math.round(message.ttlAfterCompletionDays);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.mode !== 0) {
      obj.mode = job_ProcessingModeToJSON(message.mode);
    }
    if (message.batchModePriority !== 0) {
      obj.batchModePriority = Math.round(message.batchModePriority);
    }
    if (message.optimization !== 0) {
      obj.optimization = job_OptimizationStrategyToJSON(message.optimization);
    }
    return obj;
  },

  create(base?: DeepPartial<Job>): Job {
    return Job.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job>): Job {
    const message = createBaseJob();
    message.name = object.name ?? "";
    message.inputUri = object.inputUri ?? "";
    message.outputUri = object.outputUri ?? "";
    message.templateId = object.templateId ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? JobConfig.fromPartial(object.config)
      : undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.ttlAfterCompletionDays = object.ttlAfterCompletionDays ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.mode = object.mode ?? 0;
    message.batchModePriority = object.batchModePriority ?? 0;
    message.optimization = object.optimization ?? 0;
    return message;
  },
};

function createBaseJob_LabelsEntry(): Job_LabelsEntry {
  return { key: "", value: "" };
}

export const Job_LabelsEntry: MessageFns<Job_LabelsEntry> = {
  encode(message: Job_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Job_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Job_LabelsEntry>): Job_LabelsEntry {
    return Job_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job_LabelsEntry>): Job_LabelsEntry {
    const message = createBaseJob_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseJobTemplate(): JobTemplate {
  return { name: "", config: undefined, labels: {} };
}

export const JobTemplate: MessageFns<JobTemplate> = {
  encode(message: JobTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      JobConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      JobTemplate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = JobConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = JobTemplate_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? JobConfig.fromJSON(object.config) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: JobTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = JobConfig.toJSON(message.config);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<JobTemplate>): JobTemplate {
    return JobTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobTemplate>): JobTemplate {
    const message = createBaseJobTemplate();
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? JobConfig.fromPartial(object.config)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseJobTemplate_LabelsEntry(): JobTemplate_LabelsEntry {
  return { key: "", value: "" };
}

export const JobTemplate_LabelsEntry: MessageFns<JobTemplate_LabelsEntry> = {
  encode(message: JobTemplate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobTemplate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobTemplate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobTemplate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JobTemplate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<JobTemplate_LabelsEntry>): JobTemplate_LabelsEntry {
    return JobTemplate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobTemplate_LabelsEntry>): JobTemplate_LabelsEntry {
    const message = createBaseJobTemplate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseJobConfig(): JobConfig {
  return {
    inputs: [],
    editList: [],
    elementaryStreams: [],
    muxStreams: [],
    manifests: [],
    output: undefined,
    adBreaks: [],
    pubsubDestination: undefined,
    spriteSheets: [],
    overlays: [],
    encryptions: [],
  };
}

export const JobConfig: MessageFns<JobConfig> = {
  encode(message: JobConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inputs) {
      Input.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.editList) {
      EditAtom.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.elementaryStreams) {
      ElementaryStream.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.muxStreams) {
      MuxStream.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.manifests) {
      Manifest.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(50).fork()).join();
    }
    for (const v of message.adBreaks) {
      AdBreak.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.pubsubDestination !== undefined) {
      PubsubDestination.encode(message.pubsubDestination, writer.uint32(66).fork()).join();
    }
    for (const v of message.spriteSheets) {
      SpriteSheet.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.overlays) {
      Overlay.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.encryptions) {
      Encryption.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(Input.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.editList.push(EditAtom.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.elementaryStreams.push(ElementaryStream.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.muxStreams.push(MuxStream.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.manifests.push(Manifest.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.adBreaks.push(AdBreak.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pubsubDestination = PubsubDestination.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.spriteSheets.push(SpriteSheet.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.overlays.push(Overlay.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.encryptions.push(Encryption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobConfig {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => Input.fromJSON(e)) : [],
      editList: globalThis.Array.isArray(object?.editList) ? object.editList.map((e: any) => EditAtom.fromJSON(e)) : [],
      elementaryStreams: globalThis.Array.isArray(object?.elementaryStreams)
        ? object.elementaryStreams.map((e: any) => ElementaryStream.fromJSON(e))
        : [],
      muxStreams: globalThis.Array.isArray(object?.muxStreams)
        ? object.muxStreams.map((e: any) => MuxStream.fromJSON(e))
        : [],
      manifests: globalThis.Array.isArray(object?.manifests)
        ? object.manifests.map((e: any) => Manifest.fromJSON(e))
        : [],
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
      adBreaks: globalThis.Array.isArray(object?.adBreaks) ? object.adBreaks.map((e: any) => AdBreak.fromJSON(e)) : [],
      pubsubDestination: isSet(object.pubsubDestination)
        ? PubsubDestination.fromJSON(object.pubsubDestination)
        : undefined,
      spriteSheets: globalThis.Array.isArray(object?.spriteSheets)
        ? object.spriteSheets.map((e: any) => SpriteSheet.fromJSON(e))
        : [],
      overlays: globalThis.Array.isArray(object?.overlays) ? object.overlays.map((e: any) => Overlay.fromJSON(e)) : [],
      encryptions: globalThis.Array.isArray(object?.encryptions)
        ? object.encryptions.map((e: any) => Encryption.fromJSON(e))
        : [],
    };
  },

  toJSON(message: JobConfig): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => Input.toJSON(e));
    }
    if (message.editList?.length) {
      obj.editList = message.editList.map((e) => EditAtom.toJSON(e));
    }
    if (message.elementaryStreams?.length) {
      obj.elementaryStreams = message.elementaryStreams.map((e) => ElementaryStream.toJSON(e));
    }
    if (message.muxStreams?.length) {
      obj.muxStreams = message.muxStreams.map((e) => MuxStream.toJSON(e));
    }
    if (message.manifests?.length) {
      obj.manifests = message.manifests.map((e) => Manifest.toJSON(e));
    }
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    if (message.adBreaks?.length) {
      obj.adBreaks = message.adBreaks.map((e) => AdBreak.toJSON(e));
    }
    if (message.pubsubDestination !== undefined) {
      obj.pubsubDestination = PubsubDestination.toJSON(message.pubsubDestination);
    }
    if (message.spriteSheets?.length) {
      obj.spriteSheets = message.spriteSheets.map((e) => SpriteSheet.toJSON(e));
    }
    if (message.overlays?.length) {
      obj.overlays = message.overlays.map((e) => Overlay.toJSON(e));
    }
    if (message.encryptions?.length) {
      obj.encryptions = message.encryptions.map((e) => Encryption.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<JobConfig>): JobConfig {
    return JobConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JobConfig>): JobConfig {
    const message = createBaseJobConfig();
    message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
    message.editList = object.editList?.map((e) => EditAtom.fromPartial(e)) || [];
    message.elementaryStreams = object.elementaryStreams?.map((e) => ElementaryStream.fromPartial(e)) || [];
    message.muxStreams = object.muxStreams?.map((e) => MuxStream.fromPartial(e)) || [];
    message.manifests = object.manifests?.map((e) => Manifest.fromPartial(e)) || [];
    message.output = (object.output !== undefined && object.output !== null)
      ? Output.fromPartial(object.output)
      : undefined;
    message.adBreaks = object.adBreaks?.map((e) => AdBreak.fromPartial(e)) || [];
    message.pubsubDestination = (object.pubsubDestination !== undefined && object.pubsubDestination !== null)
      ? PubsubDestination.fromPartial(object.pubsubDestination)
      : undefined;
    message.spriteSheets = object.spriteSheets?.map((e) => SpriteSheet.fromPartial(e)) || [];
    message.overlays = object.overlays?.map((e) => Overlay.fromPartial(e)) || [];
    message.encryptions = object.encryptions?.map((e) => Encryption.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInput(): Input {
  return { key: "", uri: "", preprocessingConfig: undefined };
}

export const Input: MessageFns<Input> = {
  encode(message: Input, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.preprocessingConfig !== undefined) {
      PreprocessingConfig.encode(message.preprocessingConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Input {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.preprocessingConfig = PreprocessingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Input {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      preprocessingConfig: isSet(object.preprocessingConfig)
        ? PreprocessingConfig.fromJSON(object.preprocessingConfig)
        : undefined,
    };
  },

  toJSON(message: Input): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.preprocessingConfig !== undefined) {
      obj.preprocessingConfig = PreprocessingConfig.toJSON(message.preprocessingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Input>): Input {
    return Input.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Input>): Input {
    const message = createBaseInput();
    message.key = object.key ?? "";
    message.uri = object.uri ?? "";
    message.preprocessingConfig = (object.preprocessingConfig !== undefined && object.preprocessingConfig !== null)
      ? PreprocessingConfig.fromPartial(object.preprocessingConfig)
      : undefined;
    return message;
  },
};

function createBaseOutput(): Output {
  return { uri: "" };
}

export const Output: MessageFns<Output> = {
  encode(message: Output, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: Output): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<Output>): Output {
    return Output.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Output>): Output {
    const message = createBaseOutput();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseEditAtom(): EditAtom {
  return { key: "", inputs: [], endTimeOffset: undefined, startTimeOffset: undefined };
}

export const EditAtom: MessageFns<EditAtom> = {
  encode(message: EditAtom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.inputs) {
      writer.uint32(18).string(v!);
    }
    if (message.endTimeOffset !== undefined) {
      Duration.encode(message.endTimeOffset, writer.uint32(26).fork()).join();
    }
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EditAtom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEditAtom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EditAtom {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => globalThis.String(e)) : [],
      endTimeOffset: isSet(object.endTimeOffset) ? Duration.fromJSON(object.endTimeOffset) : undefined,
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
    };
  },

  toJSON(message: EditAtom): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs;
    }
    if (message.endTimeOffset !== undefined) {
      obj.endTimeOffset = Duration.toJSON(message.endTimeOffset);
    }
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<EditAtom>): EditAtom {
    return EditAtom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EditAtom>): EditAtom {
    const message = createBaseEditAtom();
    message.key = object.key ?? "";
    message.inputs = object.inputs?.map((e) => e) || [];
    message.endTimeOffset = (object.endTimeOffset !== undefined && object.endTimeOffset !== null)
      ? Duration.fromPartial(object.endTimeOffset)
      : undefined;
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseAdBreak(): AdBreak {
  return { startTimeOffset: undefined };
}

export const AdBreak: MessageFns<AdBreak> = {
  encode(message: AdBreak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdBreak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdBreak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdBreak {
    return { startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined };
  },

  toJSON(message: AdBreak): unknown {
    const obj: any = {};
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<AdBreak>): AdBreak {
    return AdBreak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdBreak>): AdBreak {
    const message = createBaseAdBreak();
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseElementaryStream(): ElementaryStream {
  return { key: "", videoStream: undefined, audioStream: undefined, textStream: undefined };
}

export const ElementaryStream: MessageFns<ElementaryStream> = {
  encode(message: ElementaryStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(34).string(message.key);
    }
    if (message.videoStream !== undefined) {
      VideoStream.encode(message.videoStream, writer.uint32(10).fork()).join();
    }
    if (message.audioStream !== undefined) {
      AudioStream.encode(message.audioStream, writer.uint32(18).fork()).join();
    }
    if (message.textStream !== undefined) {
      TextStream.encode(message.textStream, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ElementaryStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseElementaryStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.key = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.videoStream = VideoStream.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioStream = AudioStream.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textStream = TextStream.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ElementaryStream {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      videoStream: isSet(object.videoStream) ? VideoStream.fromJSON(object.videoStream) : undefined,
      audioStream: isSet(object.audioStream) ? AudioStream.fromJSON(object.audioStream) : undefined,
      textStream: isSet(object.textStream) ? TextStream.fromJSON(object.textStream) : undefined,
    };
  },

  toJSON(message: ElementaryStream): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.videoStream !== undefined) {
      obj.videoStream = VideoStream.toJSON(message.videoStream);
    }
    if (message.audioStream !== undefined) {
      obj.audioStream = AudioStream.toJSON(message.audioStream);
    }
    if (message.textStream !== undefined) {
      obj.textStream = TextStream.toJSON(message.textStream);
    }
    return obj;
  },

  create(base?: DeepPartial<ElementaryStream>): ElementaryStream {
    return ElementaryStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ElementaryStream>): ElementaryStream {
    const message = createBaseElementaryStream();
    message.key = object.key ?? "";
    message.videoStream = (object.videoStream !== undefined && object.videoStream !== null)
      ? VideoStream.fromPartial(object.videoStream)
      : undefined;
    message.audioStream = (object.audioStream !== undefined && object.audioStream !== null)
      ? AudioStream.fromPartial(object.audioStream)
      : undefined;
    message.textStream = (object.textStream !== undefined && object.textStream !== null)
      ? TextStream.fromPartial(object.textStream)
      : undefined;
    return message;
  },
};

function createBaseMuxStream(): MuxStream {
  return { key: "", fileName: "", container: "", elementaryStreams: [], segmentSettings: undefined, encryptionId: "" };
}

export const MuxStream: MessageFns<MuxStream> = {
  encode(message: MuxStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.container !== "") {
      writer.uint32(26).string(message.container);
    }
    for (const v of message.elementaryStreams) {
      writer.uint32(34).string(v!);
    }
    if (message.segmentSettings !== undefined) {
      SegmentSettings.encode(message.segmentSettings, writer.uint32(42).fork()).join();
    }
    if (message.encryptionId !== "") {
      writer.uint32(58).string(message.encryptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuxStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuxStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.container = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.elementaryStreams.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.segmentSettings = SegmentSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.encryptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuxStream {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      elementaryStreams: globalThis.Array.isArray(object?.elementaryStreams)
        ? object.elementaryStreams.map((e: any) => globalThis.String(e))
        : [],
      segmentSettings: isSet(object.segmentSettings) ? SegmentSettings.fromJSON(object.segmentSettings) : undefined,
      encryptionId: isSet(object.encryptionId) ? globalThis.String(object.encryptionId) : "",
    };
  },

  toJSON(message: MuxStream): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.elementaryStreams?.length) {
      obj.elementaryStreams = message.elementaryStreams;
    }
    if (message.segmentSettings !== undefined) {
      obj.segmentSettings = SegmentSettings.toJSON(message.segmentSettings);
    }
    if (message.encryptionId !== "") {
      obj.encryptionId = message.encryptionId;
    }
    return obj;
  },

  create(base?: DeepPartial<MuxStream>): MuxStream {
    return MuxStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MuxStream>): MuxStream {
    const message = createBaseMuxStream();
    message.key = object.key ?? "";
    message.fileName = object.fileName ?? "";
    message.container = object.container ?? "";
    message.elementaryStreams = object.elementaryStreams?.map((e) => e) || [];
    message.segmentSettings = (object.segmentSettings !== undefined && object.segmentSettings !== null)
      ? SegmentSettings.fromPartial(object.segmentSettings)
      : undefined;
    message.encryptionId = object.encryptionId ?? "";
    return message;
  },
};

function createBaseManifest(): Manifest {
  return { fileName: "", type: 0, muxStreams: [], dash: undefined };
}

export const Manifest: MessageFns<Manifest> = {
  encode(message: Manifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileName !== "") {
      writer.uint32(10).string(message.fileName);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    for (const v of message.muxStreams) {
      writer.uint32(26).string(v!);
    }
    if (message.dash !== undefined) {
      Manifest_DashConfig.encode(message.dash, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Manifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.muxStreams.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dash = Manifest_DashConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Manifest {
    return {
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      type: isSet(object.type) ? manifest_ManifestTypeFromJSON(object.type) : 0,
      muxStreams: globalThis.Array.isArray(object?.muxStreams)
        ? object.muxStreams.map((e: any) => globalThis.String(e))
        : [],
      dash: isSet(object.dash) ? Manifest_DashConfig.fromJSON(object.dash) : undefined,
    };
  },

  toJSON(message: Manifest): unknown {
    const obj: any = {};
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.type !== 0) {
      obj.type = manifest_ManifestTypeToJSON(message.type);
    }
    if (message.muxStreams?.length) {
      obj.muxStreams = message.muxStreams;
    }
    if (message.dash !== undefined) {
      obj.dash = Manifest_DashConfig.toJSON(message.dash);
    }
    return obj;
  },

  create(base?: DeepPartial<Manifest>): Manifest {
    return Manifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Manifest>): Manifest {
    const message = createBaseManifest();
    message.fileName = object.fileName ?? "";
    message.type = object.type ?? 0;
    message.muxStreams = object.muxStreams?.map((e) => e) || [];
    message.dash = (object.dash !== undefined && object.dash !== null)
      ? Manifest_DashConfig.fromPartial(object.dash)
      : undefined;
    return message;
  },
};

function createBaseManifest_DashConfig(): Manifest_DashConfig {
  return { segmentReferenceScheme: 0 };
}

export const Manifest_DashConfig: MessageFns<Manifest_DashConfig> = {
  encode(message: Manifest_DashConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segmentReferenceScheme !== 0) {
      writer.uint32(8).int32(message.segmentReferenceScheme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Manifest_DashConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManifest_DashConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.segmentReferenceScheme = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Manifest_DashConfig {
    return {
      segmentReferenceScheme: isSet(object.segmentReferenceScheme)
        ? manifest_DashConfig_SegmentReferenceSchemeFromJSON(object.segmentReferenceScheme)
        : 0,
    };
  },

  toJSON(message: Manifest_DashConfig): unknown {
    const obj: any = {};
    if (message.segmentReferenceScheme !== 0) {
      obj.segmentReferenceScheme = manifest_DashConfig_SegmentReferenceSchemeToJSON(message.segmentReferenceScheme);
    }
    return obj;
  },

  create(base?: DeepPartial<Manifest_DashConfig>): Manifest_DashConfig {
    return Manifest_DashConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Manifest_DashConfig>): Manifest_DashConfig {
    const message = createBaseManifest_DashConfig();
    message.segmentReferenceScheme = object.segmentReferenceScheme ?? 0;
    return message;
  },
};

function createBasePubsubDestination(): PubsubDestination {
  return { topic: "" };
}

export const PubsubDestination: MessageFns<PubsubDestination> = {
  encode(message: PubsubDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubDestination {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: PubsubDestination): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubDestination>): PubsubDestination {
    return PubsubDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubDestination>): PubsubDestination {
    const message = createBasePubsubDestination();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseSpriteSheet(): SpriteSheet {
  return {
    format: "",
    filePrefix: "",
    spriteWidthPixels: 0,
    spriteHeightPixels: 0,
    columnCount: 0,
    rowCount: 0,
    startTimeOffset: undefined,
    endTimeOffset: undefined,
    totalCount: undefined,
    interval: undefined,
    quality: 0,
  };
}

export const SpriteSheet: MessageFns<SpriteSheet> = {
  encode(message: SpriteSheet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    if (message.filePrefix !== "") {
      writer.uint32(18).string(message.filePrefix);
    }
    if (message.spriteWidthPixels !== 0) {
      writer.uint32(24).int32(message.spriteWidthPixels);
    }
    if (message.spriteHeightPixels !== 0) {
      writer.uint32(32).int32(message.spriteHeightPixels);
    }
    if (message.columnCount !== 0) {
      writer.uint32(40).int32(message.columnCount);
    }
    if (message.rowCount !== 0) {
      writer.uint32(48).int32(message.rowCount);
    }
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(58).fork()).join();
    }
    if (message.endTimeOffset !== undefined) {
      Duration.encode(message.endTimeOffset, writer.uint32(66).fork()).join();
    }
    if (message.totalCount !== undefined) {
      writer.uint32(72).int32(message.totalCount);
    }
    if (message.interval !== undefined) {
      Duration.encode(message.interval, writer.uint32(82).fork()).join();
    }
    if (message.quality !== 0) {
      writer.uint32(88).int32(message.quality);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpriteSheet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpriteSheet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePrefix = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.spriteWidthPixels = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.spriteHeightPixels = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.columnCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.interval = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.quality = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpriteSheet {
    return {
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      filePrefix: isSet(object.filePrefix) ? globalThis.String(object.filePrefix) : "",
      spriteWidthPixels: isSet(object.spriteWidthPixels) ? globalThis.Number(object.spriteWidthPixels) : 0,
      spriteHeightPixels: isSet(object.spriteHeightPixels) ? globalThis.Number(object.spriteHeightPixels) : 0,
      columnCount: isSet(object.columnCount) ? globalThis.Number(object.columnCount) : 0,
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : 0,
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
      endTimeOffset: isSet(object.endTimeOffset) ? Duration.fromJSON(object.endTimeOffset) : undefined,
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : undefined,
      interval: isSet(object.interval) ? Duration.fromJSON(object.interval) : undefined,
      quality: isSet(object.quality) ? globalThis.Number(object.quality) : 0,
    };
  },

  toJSON(message: SpriteSheet): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.filePrefix !== "") {
      obj.filePrefix = message.filePrefix;
    }
    if (message.spriteWidthPixels !== 0) {
      obj.spriteWidthPixels = Math.round(message.spriteWidthPixels);
    }
    if (message.spriteHeightPixels !== 0) {
      obj.spriteHeightPixels = Math.round(message.spriteHeightPixels);
    }
    if (message.columnCount !== 0) {
      obj.columnCount = Math.round(message.columnCount);
    }
    if (message.rowCount !== 0) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    if (message.endTimeOffset !== undefined) {
      obj.endTimeOffset = Duration.toJSON(message.endTimeOffset);
    }
    if (message.totalCount !== undefined) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.interval !== undefined) {
      obj.interval = Duration.toJSON(message.interval);
    }
    if (message.quality !== 0) {
      obj.quality = Math.round(message.quality);
    }
    return obj;
  },

  create(base?: DeepPartial<SpriteSheet>): SpriteSheet {
    return SpriteSheet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpriteSheet>): SpriteSheet {
    const message = createBaseSpriteSheet();
    message.format = object.format ?? "";
    message.filePrefix = object.filePrefix ?? "";
    message.spriteWidthPixels = object.spriteWidthPixels ?? 0;
    message.spriteHeightPixels = object.spriteHeightPixels ?? 0;
    message.columnCount = object.columnCount ?? 0;
    message.rowCount = object.rowCount ?? 0;
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    message.endTimeOffset = (object.endTimeOffset !== undefined && object.endTimeOffset !== null)
      ? Duration.fromPartial(object.endTimeOffset)
      : undefined;
    message.totalCount = object.totalCount ?? undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Duration.fromPartial(object.interval)
      : undefined;
    message.quality = object.quality ?? 0;
    return message;
  },
};

function createBaseOverlay(): Overlay {
  return { image: undefined, animations: [] };
}

export const Overlay: MessageFns<Overlay> = {
  encode(message: Overlay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== undefined) {
      Overlay_Image.encode(message.image, writer.uint32(10).fork()).join();
    }
    for (const v of message.animations) {
      Overlay_Animation.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = Overlay_Image.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.animations.push(Overlay_Animation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay {
    return {
      image: isSet(object.image) ? Overlay_Image.fromJSON(object.image) : undefined,
      animations: globalThis.Array.isArray(object?.animations)
        ? object.animations.map((e: any) => Overlay_Animation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Overlay): unknown {
    const obj: any = {};
    if (message.image !== undefined) {
      obj.image = Overlay_Image.toJSON(message.image);
    }
    if (message.animations?.length) {
      obj.animations = message.animations.map((e) => Overlay_Animation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay>): Overlay {
    return Overlay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay>): Overlay {
    const message = createBaseOverlay();
    message.image = (object.image !== undefined && object.image !== null)
      ? Overlay_Image.fromPartial(object.image)
      : undefined;
    message.animations = object.animations?.map((e) => Overlay_Animation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOverlay_NormalizedCoordinate(): Overlay_NormalizedCoordinate {
  return { x: 0, y: 0 };
}

export const Overlay_NormalizedCoordinate: MessageFns<Overlay_NormalizedCoordinate> = {
  encode(message: Overlay_NormalizedCoordinate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_NormalizedCoordinate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_NormalizedCoordinate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_NormalizedCoordinate {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Overlay_NormalizedCoordinate): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_NormalizedCoordinate>): Overlay_NormalizedCoordinate {
    return Overlay_NormalizedCoordinate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_NormalizedCoordinate>): Overlay_NormalizedCoordinate {
    const message = createBaseOverlay_NormalizedCoordinate();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseOverlay_Image(): Overlay_Image {
  return { uri: "", resolution: undefined, alpha: 0 };
}

export const Overlay_Image: MessageFns<Overlay_Image> = {
  encode(message: Overlay_Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.resolution !== undefined) {
      Overlay_NormalizedCoordinate.encode(message.resolution, writer.uint32(18).fork()).join();
    }
    if (message.alpha !== 0) {
      writer.uint32(25).double(message.alpha);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resolution = Overlay_NormalizedCoordinate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.alpha = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_Image {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      resolution: isSet(object.resolution) ? Overlay_NormalizedCoordinate.fromJSON(object.resolution) : undefined,
      alpha: isSet(object.alpha) ? globalThis.Number(object.alpha) : 0,
    };
  },

  toJSON(message: Overlay_Image): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.resolution !== undefined) {
      obj.resolution = Overlay_NormalizedCoordinate.toJSON(message.resolution);
    }
    if (message.alpha !== 0) {
      obj.alpha = message.alpha;
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_Image>): Overlay_Image {
    return Overlay_Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_Image>): Overlay_Image {
    const message = createBaseOverlay_Image();
    message.uri = object.uri ?? "";
    message.resolution = (object.resolution !== undefined && object.resolution !== null)
      ? Overlay_NormalizedCoordinate.fromPartial(object.resolution)
      : undefined;
    message.alpha = object.alpha ?? 0;
    return message;
  },
};

function createBaseOverlay_AnimationStatic(): Overlay_AnimationStatic {
  return { xy: undefined, startTimeOffset: undefined };
}

export const Overlay_AnimationStatic: MessageFns<Overlay_AnimationStatic> = {
  encode(message: Overlay_AnimationStatic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xy !== undefined) {
      Overlay_NormalizedCoordinate.encode(message.xy, writer.uint32(10).fork()).join();
    }
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_AnimationStatic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_AnimationStatic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.xy = Overlay_NormalizedCoordinate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_AnimationStatic {
    return {
      xy: isSet(object.xy) ? Overlay_NormalizedCoordinate.fromJSON(object.xy) : undefined,
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
    };
  },

  toJSON(message: Overlay_AnimationStatic): unknown {
    const obj: any = {};
    if (message.xy !== undefined) {
      obj.xy = Overlay_NormalizedCoordinate.toJSON(message.xy);
    }
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_AnimationStatic>): Overlay_AnimationStatic {
    return Overlay_AnimationStatic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_AnimationStatic>): Overlay_AnimationStatic {
    const message = createBaseOverlay_AnimationStatic();
    message.xy = (object.xy !== undefined && object.xy !== null)
      ? Overlay_NormalizedCoordinate.fromPartial(object.xy)
      : undefined;
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseOverlay_AnimationFade(): Overlay_AnimationFade {
  return { fadeType: 0, xy: undefined, startTimeOffset: undefined, endTimeOffset: undefined };
}

export const Overlay_AnimationFade: MessageFns<Overlay_AnimationFade> = {
  encode(message: Overlay_AnimationFade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fadeType !== 0) {
      writer.uint32(8).int32(message.fadeType);
    }
    if (message.xy !== undefined) {
      Overlay_NormalizedCoordinate.encode(message.xy, writer.uint32(18).fork()).join();
    }
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(26).fork()).join();
    }
    if (message.endTimeOffset !== undefined) {
      Duration.encode(message.endTimeOffset, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_AnimationFade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_AnimationFade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fadeType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.xy = Overlay_NormalizedCoordinate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_AnimationFade {
    return {
      fadeType: isSet(object.fadeType) ? overlay_FadeTypeFromJSON(object.fadeType) : 0,
      xy: isSet(object.xy) ? Overlay_NormalizedCoordinate.fromJSON(object.xy) : undefined,
      startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined,
      endTimeOffset: isSet(object.endTimeOffset) ? Duration.fromJSON(object.endTimeOffset) : undefined,
    };
  },

  toJSON(message: Overlay_AnimationFade): unknown {
    const obj: any = {};
    if (message.fadeType !== 0) {
      obj.fadeType = overlay_FadeTypeToJSON(message.fadeType);
    }
    if (message.xy !== undefined) {
      obj.xy = Overlay_NormalizedCoordinate.toJSON(message.xy);
    }
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    if (message.endTimeOffset !== undefined) {
      obj.endTimeOffset = Duration.toJSON(message.endTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_AnimationFade>): Overlay_AnimationFade {
    return Overlay_AnimationFade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_AnimationFade>): Overlay_AnimationFade {
    const message = createBaseOverlay_AnimationFade();
    message.fadeType = object.fadeType ?? 0;
    message.xy = (object.xy !== undefined && object.xy !== null)
      ? Overlay_NormalizedCoordinate.fromPartial(object.xy)
      : undefined;
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    message.endTimeOffset = (object.endTimeOffset !== undefined && object.endTimeOffset !== null)
      ? Duration.fromPartial(object.endTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseOverlay_AnimationEnd(): Overlay_AnimationEnd {
  return { startTimeOffset: undefined };
}

export const Overlay_AnimationEnd: MessageFns<Overlay_AnimationEnd> = {
  encode(message: Overlay_AnimationEnd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTimeOffset !== undefined) {
      Duration.encode(message.startTimeOffset, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_AnimationEnd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_AnimationEnd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTimeOffset = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_AnimationEnd {
    return { startTimeOffset: isSet(object.startTimeOffset) ? Duration.fromJSON(object.startTimeOffset) : undefined };
  },

  toJSON(message: Overlay_AnimationEnd): unknown {
    const obj: any = {};
    if (message.startTimeOffset !== undefined) {
      obj.startTimeOffset = Duration.toJSON(message.startTimeOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_AnimationEnd>): Overlay_AnimationEnd {
    return Overlay_AnimationEnd.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_AnimationEnd>): Overlay_AnimationEnd {
    const message = createBaseOverlay_AnimationEnd();
    message.startTimeOffset = (object.startTimeOffset !== undefined && object.startTimeOffset !== null)
      ? Duration.fromPartial(object.startTimeOffset)
      : undefined;
    return message;
  },
};

function createBaseOverlay_Animation(): Overlay_Animation {
  return { animationStatic: undefined, animationFade: undefined, animationEnd: undefined };
}

export const Overlay_Animation: MessageFns<Overlay_Animation> = {
  encode(message: Overlay_Animation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.animationStatic !== undefined) {
      Overlay_AnimationStatic.encode(message.animationStatic, writer.uint32(10).fork()).join();
    }
    if (message.animationFade !== undefined) {
      Overlay_AnimationFade.encode(message.animationFade, writer.uint32(18).fork()).join();
    }
    if (message.animationEnd !== undefined) {
      Overlay_AnimationEnd.encode(message.animationEnd, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Overlay_Animation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlay_Animation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.animationStatic = Overlay_AnimationStatic.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.animationFade = Overlay_AnimationFade.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.animationEnd = Overlay_AnimationEnd.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Overlay_Animation {
    return {
      animationStatic: isSet(object.animationStatic)
        ? Overlay_AnimationStatic.fromJSON(object.animationStatic)
        : undefined,
      animationFade: isSet(object.animationFade) ? Overlay_AnimationFade.fromJSON(object.animationFade) : undefined,
      animationEnd: isSet(object.animationEnd) ? Overlay_AnimationEnd.fromJSON(object.animationEnd) : undefined,
    };
  },

  toJSON(message: Overlay_Animation): unknown {
    const obj: any = {};
    if (message.animationStatic !== undefined) {
      obj.animationStatic = Overlay_AnimationStatic.toJSON(message.animationStatic);
    }
    if (message.animationFade !== undefined) {
      obj.animationFade = Overlay_AnimationFade.toJSON(message.animationFade);
    }
    if (message.animationEnd !== undefined) {
      obj.animationEnd = Overlay_AnimationEnd.toJSON(message.animationEnd);
    }
    return obj;
  },

  create(base?: DeepPartial<Overlay_Animation>): Overlay_Animation {
    return Overlay_Animation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Overlay_Animation>): Overlay_Animation {
    const message = createBaseOverlay_Animation();
    message.animationStatic = (object.animationStatic !== undefined && object.animationStatic !== null)
      ? Overlay_AnimationStatic.fromPartial(object.animationStatic)
      : undefined;
    message.animationFade = (object.animationFade !== undefined && object.animationFade !== null)
      ? Overlay_AnimationFade.fromPartial(object.animationFade)
      : undefined;
    message.animationEnd = (object.animationEnd !== undefined && object.animationEnd !== null)
      ? Overlay_AnimationEnd.fromPartial(object.animationEnd)
      : undefined;
    return message;
  },
};

function createBasePreprocessingConfig(): PreprocessingConfig {
  return {
    color: undefined,
    denoise: undefined,
    deblock: undefined,
    audio: undefined,
    crop: undefined,
    pad: undefined,
    deinterlace: undefined,
  };
}

export const PreprocessingConfig: MessageFns<PreprocessingConfig> = {
  encode(message: PreprocessingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.color !== undefined) {
      PreprocessingConfig_Color.encode(message.color, writer.uint32(10).fork()).join();
    }
    if (message.denoise !== undefined) {
      PreprocessingConfig_Denoise.encode(message.denoise, writer.uint32(18).fork()).join();
    }
    if (message.deblock !== undefined) {
      PreprocessingConfig_Deblock.encode(message.deblock, writer.uint32(26).fork()).join();
    }
    if (message.audio !== undefined) {
      PreprocessingConfig_Audio.encode(message.audio, writer.uint32(34).fork()).join();
    }
    if (message.crop !== undefined) {
      PreprocessingConfig_Crop.encode(message.crop, writer.uint32(42).fork()).join();
    }
    if (message.pad !== undefined) {
      PreprocessingConfig_Pad.encode(message.pad, writer.uint32(50).fork()).join();
    }
    if (message.deinterlace !== undefined) {
      PreprocessingConfig_Deinterlace.encode(message.deinterlace, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.color = PreprocessingConfig_Color.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.denoise = PreprocessingConfig_Denoise.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deblock = PreprocessingConfig_Deblock.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.audio = PreprocessingConfig_Audio.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.crop = PreprocessingConfig_Crop.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pad = PreprocessingConfig_Pad.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deinterlace = PreprocessingConfig_Deinterlace.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig {
    return {
      color: isSet(object.color) ? PreprocessingConfig_Color.fromJSON(object.color) : undefined,
      denoise: isSet(object.denoise) ? PreprocessingConfig_Denoise.fromJSON(object.denoise) : undefined,
      deblock: isSet(object.deblock) ? PreprocessingConfig_Deblock.fromJSON(object.deblock) : undefined,
      audio: isSet(object.audio) ? PreprocessingConfig_Audio.fromJSON(object.audio) : undefined,
      crop: isSet(object.crop) ? PreprocessingConfig_Crop.fromJSON(object.crop) : undefined,
      pad: isSet(object.pad) ? PreprocessingConfig_Pad.fromJSON(object.pad) : undefined,
      deinterlace: isSet(object.deinterlace) ? PreprocessingConfig_Deinterlace.fromJSON(object.deinterlace) : undefined,
    };
  },

  toJSON(message: PreprocessingConfig): unknown {
    const obj: any = {};
    if (message.color !== undefined) {
      obj.color = PreprocessingConfig_Color.toJSON(message.color);
    }
    if (message.denoise !== undefined) {
      obj.denoise = PreprocessingConfig_Denoise.toJSON(message.denoise);
    }
    if (message.deblock !== undefined) {
      obj.deblock = PreprocessingConfig_Deblock.toJSON(message.deblock);
    }
    if (message.audio !== undefined) {
      obj.audio = PreprocessingConfig_Audio.toJSON(message.audio);
    }
    if (message.crop !== undefined) {
      obj.crop = PreprocessingConfig_Crop.toJSON(message.crop);
    }
    if (message.pad !== undefined) {
      obj.pad = PreprocessingConfig_Pad.toJSON(message.pad);
    }
    if (message.deinterlace !== undefined) {
      obj.deinterlace = PreprocessingConfig_Deinterlace.toJSON(message.deinterlace);
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig>): PreprocessingConfig {
    return PreprocessingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig>): PreprocessingConfig {
    const message = createBasePreprocessingConfig();
    message.color = (object.color !== undefined && object.color !== null)
      ? PreprocessingConfig_Color.fromPartial(object.color)
      : undefined;
    message.denoise = (object.denoise !== undefined && object.denoise !== null)
      ? PreprocessingConfig_Denoise.fromPartial(object.denoise)
      : undefined;
    message.deblock = (object.deblock !== undefined && object.deblock !== null)
      ? PreprocessingConfig_Deblock.fromPartial(object.deblock)
      : undefined;
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? PreprocessingConfig_Audio.fromPartial(object.audio)
      : undefined;
    message.crop = (object.crop !== undefined && object.crop !== null)
      ? PreprocessingConfig_Crop.fromPartial(object.crop)
      : undefined;
    message.pad = (object.pad !== undefined && object.pad !== null)
      ? PreprocessingConfig_Pad.fromPartial(object.pad)
      : undefined;
    message.deinterlace = (object.deinterlace !== undefined && object.deinterlace !== null)
      ? PreprocessingConfig_Deinterlace.fromPartial(object.deinterlace)
      : undefined;
    return message;
  },
};

function createBasePreprocessingConfig_Color(): PreprocessingConfig_Color {
  return { saturation: 0, contrast: 0, brightness: 0 };
}

export const PreprocessingConfig_Color: MessageFns<PreprocessingConfig_Color> = {
  encode(message: PreprocessingConfig_Color, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.saturation !== 0) {
      writer.uint32(9).double(message.saturation);
    }
    if (message.contrast !== 0) {
      writer.uint32(17).double(message.contrast);
    }
    if (message.brightness !== 0) {
      writer.uint32(25).double(message.brightness);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Color {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Color();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.saturation = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.contrast = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.brightness = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Color {
    return {
      saturation: isSet(object.saturation) ? globalThis.Number(object.saturation) : 0,
      contrast: isSet(object.contrast) ? globalThis.Number(object.contrast) : 0,
      brightness: isSet(object.brightness) ? globalThis.Number(object.brightness) : 0,
    };
  },

  toJSON(message: PreprocessingConfig_Color): unknown {
    const obj: any = {};
    if (message.saturation !== 0) {
      obj.saturation = message.saturation;
    }
    if (message.contrast !== 0) {
      obj.contrast = message.contrast;
    }
    if (message.brightness !== 0) {
      obj.brightness = message.brightness;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Color>): PreprocessingConfig_Color {
    return PreprocessingConfig_Color.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Color>): PreprocessingConfig_Color {
    const message = createBasePreprocessingConfig_Color();
    message.saturation = object.saturation ?? 0;
    message.contrast = object.contrast ?? 0;
    message.brightness = object.brightness ?? 0;
    return message;
  },
};

function createBasePreprocessingConfig_Denoise(): PreprocessingConfig_Denoise {
  return { strength: 0, tune: "" };
}

export const PreprocessingConfig_Denoise: MessageFns<PreprocessingConfig_Denoise> = {
  encode(message: PreprocessingConfig_Denoise, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strength !== 0) {
      writer.uint32(9).double(message.strength);
    }
    if (message.tune !== "") {
      writer.uint32(18).string(message.tune);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Denoise {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Denoise();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.strength = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tune = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Denoise {
    return {
      strength: isSet(object.strength) ? globalThis.Number(object.strength) : 0,
      tune: isSet(object.tune) ? globalThis.String(object.tune) : "",
    };
  },

  toJSON(message: PreprocessingConfig_Denoise): unknown {
    const obj: any = {};
    if (message.strength !== 0) {
      obj.strength = message.strength;
    }
    if (message.tune !== "") {
      obj.tune = message.tune;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Denoise>): PreprocessingConfig_Denoise {
    return PreprocessingConfig_Denoise.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Denoise>): PreprocessingConfig_Denoise {
    const message = createBasePreprocessingConfig_Denoise();
    message.strength = object.strength ?? 0;
    message.tune = object.tune ?? "";
    return message;
  },
};

function createBasePreprocessingConfig_Deblock(): PreprocessingConfig_Deblock {
  return { strength: 0, enabled: false };
}

export const PreprocessingConfig_Deblock: MessageFns<PreprocessingConfig_Deblock> = {
  encode(message: PreprocessingConfig_Deblock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.strength !== 0) {
      writer.uint32(9).double(message.strength);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Deblock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Deblock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.strength = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Deblock {
    return {
      strength: isSet(object.strength) ? globalThis.Number(object.strength) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: PreprocessingConfig_Deblock): unknown {
    const obj: any = {};
    if (message.strength !== 0) {
      obj.strength = message.strength;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Deblock>): PreprocessingConfig_Deblock {
    return PreprocessingConfig_Deblock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Deblock>): PreprocessingConfig_Deblock {
    const message = createBasePreprocessingConfig_Deblock();
    message.strength = object.strength ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBasePreprocessingConfig_Audio(): PreprocessingConfig_Audio {
  return { lufs: 0, highBoost: false, lowBoost: false };
}

export const PreprocessingConfig_Audio: MessageFns<PreprocessingConfig_Audio> = {
  encode(message: PreprocessingConfig_Audio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lufs !== 0) {
      writer.uint32(9).double(message.lufs);
    }
    if (message.highBoost !== false) {
      writer.uint32(16).bool(message.highBoost);
    }
    if (message.lowBoost !== false) {
      writer.uint32(24).bool(message.lowBoost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Audio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Audio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.lufs = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.highBoost = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lowBoost = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Audio {
    return {
      lufs: isSet(object.lufs) ? globalThis.Number(object.lufs) : 0,
      highBoost: isSet(object.highBoost) ? globalThis.Boolean(object.highBoost) : false,
      lowBoost: isSet(object.lowBoost) ? globalThis.Boolean(object.lowBoost) : false,
    };
  },

  toJSON(message: PreprocessingConfig_Audio): unknown {
    const obj: any = {};
    if (message.lufs !== 0) {
      obj.lufs = message.lufs;
    }
    if (message.highBoost !== false) {
      obj.highBoost = message.highBoost;
    }
    if (message.lowBoost !== false) {
      obj.lowBoost = message.lowBoost;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Audio>): PreprocessingConfig_Audio {
    return PreprocessingConfig_Audio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Audio>): PreprocessingConfig_Audio {
    const message = createBasePreprocessingConfig_Audio();
    message.lufs = object.lufs ?? 0;
    message.highBoost = object.highBoost ?? false;
    message.lowBoost = object.lowBoost ?? false;
    return message;
  },
};

function createBasePreprocessingConfig_Crop(): PreprocessingConfig_Crop {
  return { topPixels: 0, bottomPixels: 0, leftPixels: 0, rightPixels: 0 };
}

export const PreprocessingConfig_Crop: MessageFns<PreprocessingConfig_Crop> = {
  encode(message: PreprocessingConfig_Crop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topPixels !== 0) {
      writer.uint32(8).int32(message.topPixels);
    }
    if (message.bottomPixels !== 0) {
      writer.uint32(16).int32(message.bottomPixels);
    }
    if (message.leftPixels !== 0) {
      writer.uint32(24).int32(message.leftPixels);
    }
    if (message.rightPixels !== 0) {
      writer.uint32(32).int32(message.rightPixels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Crop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Crop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.topPixels = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bottomPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leftPixels = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rightPixels = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Crop {
    return {
      topPixels: isSet(object.topPixels) ? globalThis.Number(object.topPixels) : 0,
      bottomPixels: isSet(object.bottomPixels) ? globalThis.Number(object.bottomPixels) : 0,
      leftPixels: isSet(object.leftPixels) ? globalThis.Number(object.leftPixels) : 0,
      rightPixels: isSet(object.rightPixels) ? globalThis.Number(object.rightPixels) : 0,
    };
  },

  toJSON(message: PreprocessingConfig_Crop): unknown {
    const obj: any = {};
    if (message.topPixels !== 0) {
      obj.topPixels = Math.round(message.topPixels);
    }
    if (message.bottomPixels !== 0) {
      obj.bottomPixels = Math.round(message.bottomPixels);
    }
    if (message.leftPixels !== 0) {
      obj.leftPixels = Math.round(message.leftPixels);
    }
    if (message.rightPixels !== 0) {
      obj.rightPixels = Math.round(message.rightPixels);
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Crop>): PreprocessingConfig_Crop {
    return PreprocessingConfig_Crop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Crop>): PreprocessingConfig_Crop {
    const message = createBasePreprocessingConfig_Crop();
    message.topPixels = object.topPixels ?? 0;
    message.bottomPixels = object.bottomPixels ?? 0;
    message.leftPixels = object.leftPixels ?? 0;
    message.rightPixels = object.rightPixels ?? 0;
    return message;
  },
};

function createBasePreprocessingConfig_Pad(): PreprocessingConfig_Pad {
  return { topPixels: 0, bottomPixels: 0, leftPixels: 0, rightPixels: 0 };
}

export const PreprocessingConfig_Pad: MessageFns<PreprocessingConfig_Pad> = {
  encode(message: PreprocessingConfig_Pad, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topPixels !== 0) {
      writer.uint32(8).int32(message.topPixels);
    }
    if (message.bottomPixels !== 0) {
      writer.uint32(16).int32(message.bottomPixels);
    }
    if (message.leftPixels !== 0) {
      writer.uint32(24).int32(message.leftPixels);
    }
    if (message.rightPixels !== 0) {
      writer.uint32(32).int32(message.rightPixels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Pad {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Pad();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.topPixels = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bottomPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.leftPixels = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.rightPixels = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Pad {
    return {
      topPixels: isSet(object.topPixels) ? globalThis.Number(object.topPixels) : 0,
      bottomPixels: isSet(object.bottomPixels) ? globalThis.Number(object.bottomPixels) : 0,
      leftPixels: isSet(object.leftPixels) ? globalThis.Number(object.leftPixels) : 0,
      rightPixels: isSet(object.rightPixels) ? globalThis.Number(object.rightPixels) : 0,
    };
  },

  toJSON(message: PreprocessingConfig_Pad): unknown {
    const obj: any = {};
    if (message.topPixels !== 0) {
      obj.topPixels = Math.round(message.topPixels);
    }
    if (message.bottomPixels !== 0) {
      obj.bottomPixels = Math.round(message.bottomPixels);
    }
    if (message.leftPixels !== 0) {
      obj.leftPixels = Math.round(message.leftPixels);
    }
    if (message.rightPixels !== 0) {
      obj.rightPixels = Math.round(message.rightPixels);
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Pad>): PreprocessingConfig_Pad {
    return PreprocessingConfig_Pad.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Pad>): PreprocessingConfig_Pad {
    const message = createBasePreprocessingConfig_Pad();
    message.topPixels = object.topPixels ?? 0;
    message.bottomPixels = object.bottomPixels ?? 0;
    message.leftPixels = object.leftPixels ?? 0;
    message.rightPixels = object.rightPixels ?? 0;
    return message;
  },
};

function createBasePreprocessingConfig_Deinterlace(): PreprocessingConfig_Deinterlace {
  return { yadif: undefined, bwdif: undefined };
}

export const PreprocessingConfig_Deinterlace: MessageFns<PreprocessingConfig_Deinterlace> = {
  encode(message: PreprocessingConfig_Deinterlace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.yadif !== undefined) {
      PreprocessingConfig_Deinterlace_YadifConfig.encode(message.yadif, writer.uint32(10).fork()).join();
    }
    if (message.bwdif !== undefined) {
      PreprocessingConfig_Deinterlace_BwdifConfig.encode(message.bwdif, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Deinterlace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Deinterlace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.yadif = PreprocessingConfig_Deinterlace_YadifConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bwdif = PreprocessingConfig_Deinterlace_BwdifConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Deinterlace {
    return {
      yadif: isSet(object.yadif) ? PreprocessingConfig_Deinterlace_YadifConfig.fromJSON(object.yadif) : undefined,
      bwdif: isSet(object.bwdif) ? PreprocessingConfig_Deinterlace_BwdifConfig.fromJSON(object.bwdif) : undefined,
    };
  },

  toJSON(message: PreprocessingConfig_Deinterlace): unknown {
    const obj: any = {};
    if (message.yadif !== undefined) {
      obj.yadif = PreprocessingConfig_Deinterlace_YadifConfig.toJSON(message.yadif);
    }
    if (message.bwdif !== undefined) {
      obj.bwdif = PreprocessingConfig_Deinterlace_BwdifConfig.toJSON(message.bwdif);
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Deinterlace>): PreprocessingConfig_Deinterlace {
    return PreprocessingConfig_Deinterlace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PreprocessingConfig_Deinterlace>): PreprocessingConfig_Deinterlace {
    const message = createBasePreprocessingConfig_Deinterlace();
    message.yadif = (object.yadif !== undefined && object.yadif !== null)
      ? PreprocessingConfig_Deinterlace_YadifConfig.fromPartial(object.yadif)
      : undefined;
    message.bwdif = (object.bwdif !== undefined && object.bwdif !== null)
      ? PreprocessingConfig_Deinterlace_BwdifConfig.fromPartial(object.bwdif)
      : undefined;
    return message;
  },
};

function createBasePreprocessingConfig_Deinterlace_YadifConfig(): PreprocessingConfig_Deinterlace_YadifConfig {
  return { mode: "", disableSpatialInterlacing: false, parity: "", deinterlaceAllFrames: false };
}

export const PreprocessingConfig_Deinterlace_YadifConfig: MessageFns<PreprocessingConfig_Deinterlace_YadifConfig> = {
  encode(
    message: PreprocessingConfig_Deinterlace_YadifConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mode !== "") {
      writer.uint32(10).string(message.mode);
    }
    if (message.disableSpatialInterlacing !== false) {
      writer.uint32(16).bool(message.disableSpatialInterlacing);
    }
    if (message.parity !== "") {
      writer.uint32(26).string(message.parity);
    }
    if (message.deinterlaceAllFrames !== false) {
      writer.uint32(32).bool(message.deinterlaceAllFrames);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Deinterlace_YadifConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Deinterlace_YadifConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.disableSpatialInterlacing = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parity = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deinterlaceAllFrames = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Deinterlace_YadifConfig {
    return {
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      disableSpatialInterlacing: isSet(object.disableSpatialInterlacing)
        ? globalThis.Boolean(object.disableSpatialInterlacing)
        : false,
      parity: isSet(object.parity) ? globalThis.String(object.parity) : "",
      deinterlaceAllFrames: isSet(object.deinterlaceAllFrames)
        ? globalThis.Boolean(object.deinterlaceAllFrames)
        : false,
    };
  },

  toJSON(message: PreprocessingConfig_Deinterlace_YadifConfig): unknown {
    const obj: any = {};
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.disableSpatialInterlacing !== false) {
      obj.disableSpatialInterlacing = message.disableSpatialInterlacing;
    }
    if (message.parity !== "") {
      obj.parity = message.parity;
    }
    if (message.deinterlaceAllFrames !== false) {
      obj.deinterlaceAllFrames = message.deinterlaceAllFrames;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Deinterlace_YadifConfig>): PreprocessingConfig_Deinterlace_YadifConfig {
    return PreprocessingConfig_Deinterlace_YadifConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PreprocessingConfig_Deinterlace_YadifConfig>,
  ): PreprocessingConfig_Deinterlace_YadifConfig {
    const message = createBasePreprocessingConfig_Deinterlace_YadifConfig();
    message.mode = object.mode ?? "";
    message.disableSpatialInterlacing = object.disableSpatialInterlacing ?? false;
    message.parity = object.parity ?? "";
    message.deinterlaceAllFrames = object.deinterlaceAllFrames ?? false;
    return message;
  },
};

function createBasePreprocessingConfig_Deinterlace_BwdifConfig(): PreprocessingConfig_Deinterlace_BwdifConfig {
  return { mode: "", parity: "", deinterlaceAllFrames: false };
}

export const PreprocessingConfig_Deinterlace_BwdifConfig: MessageFns<PreprocessingConfig_Deinterlace_BwdifConfig> = {
  encode(
    message: PreprocessingConfig_Deinterlace_BwdifConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mode !== "") {
      writer.uint32(10).string(message.mode);
    }
    if (message.parity !== "") {
      writer.uint32(18).string(message.parity);
    }
    if (message.deinterlaceAllFrames !== false) {
      writer.uint32(24).bool(message.deinterlaceAllFrames);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessingConfig_Deinterlace_BwdifConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessingConfig_Deinterlace_BwdifConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parity = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deinterlaceAllFrames = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessingConfig_Deinterlace_BwdifConfig {
    return {
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      parity: isSet(object.parity) ? globalThis.String(object.parity) : "",
      deinterlaceAllFrames: isSet(object.deinterlaceAllFrames)
        ? globalThis.Boolean(object.deinterlaceAllFrames)
        : false,
    };
  },

  toJSON(message: PreprocessingConfig_Deinterlace_BwdifConfig): unknown {
    const obj: any = {};
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.parity !== "") {
      obj.parity = message.parity;
    }
    if (message.deinterlaceAllFrames !== false) {
      obj.deinterlaceAllFrames = message.deinterlaceAllFrames;
    }
    return obj;
  },

  create(base?: DeepPartial<PreprocessingConfig_Deinterlace_BwdifConfig>): PreprocessingConfig_Deinterlace_BwdifConfig {
    return PreprocessingConfig_Deinterlace_BwdifConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PreprocessingConfig_Deinterlace_BwdifConfig>,
  ): PreprocessingConfig_Deinterlace_BwdifConfig {
    const message = createBasePreprocessingConfig_Deinterlace_BwdifConfig();
    message.mode = object.mode ?? "";
    message.parity = object.parity ?? "";
    message.deinterlaceAllFrames = object.deinterlaceAllFrames ?? false;
    return message;
  },
};

function createBaseVideoStream(): VideoStream {
  return { h264: undefined, h265: undefined, vp9: undefined };
}

export const VideoStream: MessageFns<VideoStream> = {
  encode(message: VideoStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.h264 !== undefined) {
      VideoStream_H264CodecSettings.encode(message.h264, writer.uint32(10).fork()).join();
    }
    if (message.h265 !== undefined) {
      VideoStream_H265CodecSettings.encode(message.h265, writer.uint32(18).fork()).join();
    }
    if (message.vp9 !== undefined) {
      VideoStream_Vp9CodecSettings.encode(message.vp9, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.h264 = VideoStream_H264CodecSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.h265 = VideoStream_H265CodecSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vp9 = VideoStream_Vp9CodecSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStream {
    return {
      h264: isSet(object.h264) ? VideoStream_H264CodecSettings.fromJSON(object.h264) : undefined,
      h265: isSet(object.h265) ? VideoStream_H265CodecSettings.fromJSON(object.h265) : undefined,
      vp9: isSet(object.vp9) ? VideoStream_Vp9CodecSettings.fromJSON(object.vp9) : undefined,
    };
  },

  toJSON(message: VideoStream): unknown {
    const obj: any = {};
    if (message.h264 !== undefined) {
      obj.h264 = VideoStream_H264CodecSettings.toJSON(message.h264);
    }
    if (message.h265 !== undefined) {
      obj.h265 = VideoStream_H265CodecSettings.toJSON(message.h265);
    }
    if (message.vp9 !== undefined) {
      obj.vp9 = VideoStream_Vp9CodecSettings.toJSON(message.vp9);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStream>): VideoStream {
    return VideoStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStream>): VideoStream {
    const message = createBaseVideoStream();
    message.h264 = (object.h264 !== undefined && object.h264 !== null)
      ? VideoStream_H264CodecSettings.fromPartial(object.h264)
      : undefined;
    message.h265 = (object.h265 !== undefined && object.h265 !== null)
      ? VideoStream_H265CodecSettings.fromPartial(object.h265)
      : undefined;
    message.vp9 = (object.vp9 !== undefined && object.vp9 !== null)
      ? VideoStream_Vp9CodecSettings.fromPartial(object.vp9)
      : undefined;
    return message;
  },
};

function createBaseVideoStream_H264CodecSettings(): VideoStream_H264CodecSettings {
  return {
    widthPixels: 0,
    heightPixels: 0,
    frameRate: 0,
    bitrateBps: 0,
    pixelFormat: "",
    rateControlMode: "",
    crfLevel: 0,
    allowOpenGop: false,
    gopFrameCount: undefined,
    gopDuration: undefined,
    enableTwoPass: false,
    vbvSizeBits: 0,
    vbvFullnessBits: 0,
    entropyCoder: "",
    bPyramid: false,
    bFrameCount: 0,
    aqStrength: 0,
    profile: "",
    tune: "",
    preset: "",
  };
}

export const VideoStream_H264CodecSettings: MessageFns<VideoStream_H264CodecSettings> = {
  encode(message: VideoStream_H264CodecSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widthPixels !== 0) {
      writer.uint32(8).int32(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      writer.uint32(16).int32(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      writer.uint32(25).double(message.frameRate);
    }
    if (message.bitrateBps !== 0) {
      writer.uint32(32).int32(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      writer.uint32(42).string(message.pixelFormat);
    }
    if (message.rateControlMode !== "") {
      writer.uint32(50).string(message.rateControlMode);
    }
    if (message.crfLevel !== 0) {
      writer.uint32(56).int32(message.crfLevel);
    }
    if (message.allowOpenGop !== false) {
      writer.uint32(64).bool(message.allowOpenGop);
    }
    if (message.gopFrameCount !== undefined) {
      writer.uint32(72).int32(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      Duration.encode(message.gopDuration, writer.uint32(82).fork()).join();
    }
    if (message.enableTwoPass !== false) {
      writer.uint32(88).bool(message.enableTwoPass);
    }
    if (message.vbvSizeBits !== 0) {
      writer.uint32(96).int32(message.vbvSizeBits);
    }
    if (message.vbvFullnessBits !== 0) {
      writer.uint32(104).int32(message.vbvFullnessBits);
    }
    if (message.entropyCoder !== "") {
      writer.uint32(114).string(message.entropyCoder);
    }
    if (message.bPyramid !== false) {
      writer.uint32(120).bool(message.bPyramid);
    }
    if (message.bFrameCount !== 0) {
      writer.uint32(128).int32(message.bFrameCount);
    }
    if (message.aqStrength !== 0) {
      writer.uint32(137).double(message.aqStrength);
    }
    if (message.profile !== "") {
      writer.uint32(146).string(message.profile);
    }
    if (message.tune !== "") {
      writer.uint32(154).string(message.tune);
    }
    if (message.preset !== "") {
      writer.uint32(162).string(message.preset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStream_H264CodecSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStream_H264CodecSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.widthPixels = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heightPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.frameRate = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bitrateBps = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pixelFormat = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rateControlMode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.crfLevel = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.allowOpenGop = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.gopFrameCount = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gopDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableTwoPass = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.vbvSizeBits = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.vbvFullnessBits = reader.int32();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.entropyCoder = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.bPyramid = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.bFrameCount = reader.int32();
          continue;
        case 17:
          if (tag !== 137) {
            break;
          }

          message.aqStrength = reader.double();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.tune = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.preset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStream_H264CodecSettings {
    return {
      widthPixels: isSet(object.widthPixels) ? globalThis.Number(object.widthPixels) : 0,
      heightPixels: isSet(object.heightPixels) ? globalThis.Number(object.heightPixels) : 0,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
      bitrateBps: isSet(object.bitrateBps) ? globalThis.Number(object.bitrateBps) : 0,
      pixelFormat: isSet(object.pixelFormat) ? globalThis.String(object.pixelFormat) : "",
      rateControlMode: isSet(object.rateControlMode) ? globalThis.String(object.rateControlMode) : "",
      crfLevel: isSet(object.crfLevel) ? globalThis.Number(object.crfLevel) : 0,
      allowOpenGop: isSet(object.allowOpenGop) ? globalThis.Boolean(object.allowOpenGop) : false,
      gopFrameCount: isSet(object.gopFrameCount) ? globalThis.Number(object.gopFrameCount) : undefined,
      gopDuration: isSet(object.gopDuration) ? Duration.fromJSON(object.gopDuration) : undefined,
      enableTwoPass: isSet(object.enableTwoPass) ? globalThis.Boolean(object.enableTwoPass) : false,
      vbvSizeBits: isSet(object.vbvSizeBits) ? globalThis.Number(object.vbvSizeBits) : 0,
      vbvFullnessBits: isSet(object.vbvFullnessBits) ? globalThis.Number(object.vbvFullnessBits) : 0,
      entropyCoder: isSet(object.entropyCoder) ? globalThis.String(object.entropyCoder) : "",
      bPyramid: isSet(object.bPyramid) ? globalThis.Boolean(object.bPyramid) : false,
      bFrameCount: isSet(object.bFrameCount) ? globalThis.Number(object.bFrameCount) : 0,
      aqStrength: isSet(object.aqStrength) ? globalThis.Number(object.aqStrength) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      tune: isSet(object.tune) ? globalThis.String(object.tune) : "",
      preset: isSet(object.preset) ? globalThis.String(object.preset) : "",
    };
  },

  toJSON(message: VideoStream_H264CodecSettings): unknown {
    const obj: any = {};
    if (message.widthPixels !== 0) {
      obj.widthPixels = Math.round(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      obj.heightPixels = Math.round(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    if (message.bitrateBps !== 0) {
      obj.bitrateBps = Math.round(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      obj.pixelFormat = message.pixelFormat;
    }
    if (message.rateControlMode !== "") {
      obj.rateControlMode = message.rateControlMode;
    }
    if (message.crfLevel !== 0) {
      obj.crfLevel = Math.round(message.crfLevel);
    }
    if (message.allowOpenGop !== false) {
      obj.allowOpenGop = message.allowOpenGop;
    }
    if (message.gopFrameCount !== undefined) {
      obj.gopFrameCount = Math.round(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      obj.gopDuration = Duration.toJSON(message.gopDuration);
    }
    if (message.enableTwoPass !== false) {
      obj.enableTwoPass = message.enableTwoPass;
    }
    if (message.vbvSizeBits !== 0) {
      obj.vbvSizeBits = Math.round(message.vbvSizeBits);
    }
    if (message.vbvFullnessBits !== 0) {
      obj.vbvFullnessBits = Math.round(message.vbvFullnessBits);
    }
    if (message.entropyCoder !== "") {
      obj.entropyCoder = message.entropyCoder;
    }
    if (message.bPyramid !== false) {
      obj.bPyramid = message.bPyramid;
    }
    if (message.bFrameCount !== 0) {
      obj.bFrameCount = Math.round(message.bFrameCount);
    }
    if (message.aqStrength !== 0) {
      obj.aqStrength = message.aqStrength;
    }
    if (message.profile !== "") {
      obj.profile = message.profile;
    }
    if (message.tune !== "") {
      obj.tune = message.tune;
    }
    if (message.preset !== "") {
      obj.preset = message.preset;
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStream_H264CodecSettings>): VideoStream_H264CodecSettings {
    return VideoStream_H264CodecSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStream_H264CodecSettings>): VideoStream_H264CodecSettings {
    const message = createBaseVideoStream_H264CodecSettings();
    message.widthPixels = object.widthPixels ?? 0;
    message.heightPixels = object.heightPixels ?? 0;
    message.frameRate = object.frameRate ?? 0;
    message.bitrateBps = object.bitrateBps ?? 0;
    message.pixelFormat = object.pixelFormat ?? "";
    message.rateControlMode = object.rateControlMode ?? "";
    message.crfLevel = object.crfLevel ?? 0;
    message.allowOpenGop = object.allowOpenGop ?? false;
    message.gopFrameCount = object.gopFrameCount ?? undefined;
    message.gopDuration = (object.gopDuration !== undefined && object.gopDuration !== null)
      ? Duration.fromPartial(object.gopDuration)
      : undefined;
    message.enableTwoPass = object.enableTwoPass ?? false;
    message.vbvSizeBits = object.vbvSizeBits ?? 0;
    message.vbvFullnessBits = object.vbvFullnessBits ?? 0;
    message.entropyCoder = object.entropyCoder ?? "";
    message.bPyramid = object.bPyramid ?? false;
    message.bFrameCount = object.bFrameCount ?? 0;
    message.aqStrength = object.aqStrength ?? 0;
    message.profile = object.profile ?? "";
    message.tune = object.tune ?? "";
    message.preset = object.preset ?? "";
    return message;
  },
};

function createBaseVideoStream_H265CodecSettings(): VideoStream_H265CodecSettings {
  return {
    widthPixels: 0,
    heightPixels: 0,
    frameRate: 0,
    bitrateBps: 0,
    pixelFormat: "",
    rateControlMode: "",
    crfLevel: 0,
    allowOpenGop: false,
    gopFrameCount: undefined,
    gopDuration: undefined,
    enableTwoPass: false,
    vbvSizeBits: 0,
    vbvFullnessBits: 0,
    bPyramid: false,
    bFrameCount: 0,
    aqStrength: 0,
    profile: "",
    tune: "",
    preset: "",
  };
}

export const VideoStream_H265CodecSettings: MessageFns<VideoStream_H265CodecSettings> = {
  encode(message: VideoStream_H265CodecSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widthPixels !== 0) {
      writer.uint32(8).int32(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      writer.uint32(16).int32(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      writer.uint32(25).double(message.frameRate);
    }
    if (message.bitrateBps !== 0) {
      writer.uint32(32).int32(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      writer.uint32(42).string(message.pixelFormat);
    }
    if (message.rateControlMode !== "") {
      writer.uint32(50).string(message.rateControlMode);
    }
    if (message.crfLevel !== 0) {
      writer.uint32(56).int32(message.crfLevel);
    }
    if (message.allowOpenGop !== false) {
      writer.uint32(64).bool(message.allowOpenGop);
    }
    if (message.gopFrameCount !== undefined) {
      writer.uint32(72).int32(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      Duration.encode(message.gopDuration, writer.uint32(82).fork()).join();
    }
    if (message.enableTwoPass !== false) {
      writer.uint32(88).bool(message.enableTwoPass);
    }
    if (message.vbvSizeBits !== 0) {
      writer.uint32(96).int32(message.vbvSizeBits);
    }
    if (message.vbvFullnessBits !== 0) {
      writer.uint32(104).int32(message.vbvFullnessBits);
    }
    if (message.bPyramid !== false) {
      writer.uint32(112).bool(message.bPyramid);
    }
    if (message.bFrameCount !== 0) {
      writer.uint32(120).int32(message.bFrameCount);
    }
    if (message.aqStrength !== 0) {
      writer.uint32(129).double(message.aqStrength);
    }
    if (message.profile !== "") {
      writer.uint32(138).string(message.profile);
    }
    if (message.tune !== "") {
      writer.uint32(146).string(message.tune);
    }
    if (message.preset !== "") {
      writer.uint32(154).string(message.preset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStream_H265CodecSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStream_H265CodecSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.widthPixels = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heightPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.frameRate = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bitrateBps = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pixelFormat = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rateControlMode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.crfLevel = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.allowOpenGop = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.gopFrameCount = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.gopDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableTwoPass = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.vbvSizeBits = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.vbvFullnessBits = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.bPyramid = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.bFrameCount = reader.int32();
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.aqStrength = reader.double();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.profile = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.tune = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.preset = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStream_H265CodecSettings {
    return {
      widthPixels: isSet(object.widthPixels) ? globalThis.Number(object.widthPixels) : 0,
      heightPixels: isSet(object.heightPixels) ? globalThis.Number(object.heightPixels) : 0,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
      bitrateBps: isSet(object.bitrateBps) ? globalThis.Number(object.bitrateBps) : 0,
      pixelFormat: isSet(object.pixelFormat) ? globalThis.String(object.pixelFormat) : "",
      rateControlMode: isSet(object.rateControlMode) ? globalThis.String(object.rateControlMode) : "",
      crfLevel: isSet(object.crfLevel) ? globalThis.Number(object.crfLevel) : 0,
      allowOpenGop: isSet(object.allowOpenGop) ? globalThis.Boolean(object.allowOpenGop) : false,
      gopFrameCount: isSet(object.gopFrameCount) ? globalThis.Number(object.gopFrameCount) : undefined,
      gopDuration: isSet(object.gopDuration) ? Duration.fromJSON(object.gopDuration) : undefined,
      enableTwoPass: isSet(object.enableTwoPass) ? globalThis.Boolean(object.enableTwoPass) : false,
      vbvSizeBits: isSet(object.vbvSizeBits) ? globalThis.Number(object.vbvSizeBits) : 0,
      vbvFullnessBits: isSet(object.vbvFullnessBits) ? globalThis.Number(object.vbvFullnessBits) : 0,
      bPyramid: isSet(object.bPyramid) ? globalThis.Boolean(object.bPyramid) : false,
      bFrameCount: isSet(object.bFrameCount) ? globalThis.Number(object.bFrameCount) : 0,
      aqStrength: isSet(object.aqStrength) ? globalThis.Number(object.aqStrength) : 0,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
      tune: isSet(object.tune) ? globalThis.String(object.tune) : "",
      preset: isSet(object.preset) ? globalThis.String(object.preset) : "",
    };
  },

  toJSON(message: VideoStream_H265CodecSettings): unknown {
    const obj: any = {};
    if (message.widthPixels !== 0) {
      obj.widthPixels = Math.round(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      obj.heightPixels = Math.round(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    if (message.bitrateBps !== 0) {
      obj.bitrateBps = Math.round(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      obj.pixelFormat = message.pixelFormat;
    }
    if (message.rateControlMode !== "") {
      obj.rateControlMode = message.rateControlMode;
    }
    if (message.crfLevel !== 0) {
      obj.crfLevel = Math.round(message.crfLevel);
    }
    if (message.allowOpenGop !== false) {
      obj.allowOpenGop = message.allowOpenGop;
    }
    if (message.gopFrameCount !== undefined) {
      obj.gopFrameCount = Math.round(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      obj.gopDuration = Duration.toJSON(message.gopDuration);
    }
    if (message.enableTwoPass !== false) {
      obj.enableTwoPass = message.enableTwoPass;
    }
    if (message.vbvSizeBits !== 0) {
      obj.vbvSizeBits = Math.round(message.vbvSizeBits);
    }
    if (message.vbvFullnessBits !== 0) {
      obj.vbvFullnessBits = Math.round(message.vbvFullnessBits);
    }
    if (message.bPyramid !== false) {
      obj.bPyramid = message.bPyramid;
    }
    if (message.bFrameCount !== 0) {
      obj.bFrameCount = Math.round(message.bFrameCount);
    }
    if (message.aqStrength !== 0) {
      obj.aqStrength = message.aqStrength;
    }
    if (message.profile !== "") {
      obj.profile = message.profile;
    }
    if (message.tune !== "") {
      obj.tune = message.tune;
    }
    if (message.preset !== "") {
      obj.preset = message.preset;
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStream_H265CodecSettings>): VideoStream_H265CodecSettings {
    return VideoStream_H265CodecSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStream_H265CodecSettings>): VideoStream_H265CodecSettings {
    const message = createBaseVideoStream_H265CodecSettings();
    message.widthPixels = object.widthPixels ?? 0;
    message.heightPixels = object.heightPixels ?? 0;
    message.frameRate = object.frameRate ?? 0;
    message.bitrateBps = object.bitrateBps ?? 0;
    message.pixelFormat = object.pixelFormat ?? "";
    message.rateControlMode = object.rateControlMode ?? "";
    message.crfLevel = object.crfLevel ?? 0;
    message.allowOpenGop = object.allowOpenGop ?? false;
    message.gopFrameCount = object.gopFrameCount ?? undefined;
    message.gopDuration = (object.gopDuration !== undefined && object.gopDuration !== null)
      ? Duration.fromPartial(object.gopDuration)
      : undefined;
    message.enableTwoPass = object.enableTwoPass ?? false;
    message.vbvSizeBits = object.vbvSizeBits ?? 0;
    message.vbvFullnessBits = object.vbvFullnessBits ?? 0;
    message.bPyramid = object.bPyramid ?? false;
    message.bFrameCount = object.bFrameCount ?? 0;
    message.aqStrength = object.aqStrength ?? 0;
    message.profile = object.profile ?? "";
    message.tune = object.tune ?? "";
    message.preset = object.preset ?? "";
    return message;
  },
};

function createBaseVideoStream_Vp9CodecSettings(): VideoStream_Vp9CodecSettings {
  return {
    widthPixels: 0,
    heightPixels: 0,
    frameRate: 0,
    bitrateBps: 0,
    pixelFormat: "",
    rateControlMode: "",
    crfLevel: 0,
    gopFrameCount: undefined,
    gopDuration: undefined,
    profile: "",
  };
}

export const VideoStream_Vp9CodecSettings: MessageFns<VideoStream_Vp9CodecSettings> = {
  encode(message: VideoStream_Vp9CodecSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widthPixels !== 0) {
      writer.uint32(8).int32(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      writer.uint32(16).int32(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      writer.uint32(25).double(message.frameRate);
    }
    if (message.bitrateBps !== 0) {
      writer.uint32(32).int32(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      writer.uint32(42).string(message.pixelFormat);
    }
    if (message.rateControlMode !== "") {
      writer.uint32(50).string(message.rateControlMode);
    }
    if (message.crfLevel !== 0) {
      writer.uint32(56).int32(message.crfLevel);
    }
    if (message.gopFrameCount !== undefined) {
      writer.uint32(64).int32(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      Duration.encode(message.gopDuration, writer.uint32(74).fork()).join();
    }
    if (message.profile !== "") {
      writer.uint32(82).string(message.profile);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoStream_Vp9CodecSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoStream_Vp9CodecSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.widthPixels = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.heightPixels = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.frameRate = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bitrateBps = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pixelFormat = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rateControlMode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.crfLevel = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.gopFrameCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gopDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.profile = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoStream_Vp9CodecSettings {
    return {
      widthPixels: isSet(object.widthPixels) ? globalThis.Number(object.widthPixels) : 0,
      heightPixels: isSet(object.heightPixels) ? globalThis.Number(object.heightPixels) : 0,
      frameRate: isSet(object.frameRate) ? globalThis.Number(object.frameRate) : 0,
      bitrateBps: isSet(object.bitrateBps) ? globalThis.Number(object.bitrateBps) : 0,
      pixelFormat: isSet(object.pixelFormat) ? globalThis.String(object.pixelFormat) : "",
      rateControlMode: isSet(object.rateControlMode) ? globalThis.String(object.rateControlMode) : "",
      crfLevel: isSet(object.crfLevel) ? globalThis.Number(object.crfLevel) : 0,
      gopFrameCount: isSet(object.gopFrameCount) ? globalThis.Number(object.gopFrameCount) : undefined,
      gopDuration: isSet(object.gopDuration) ? Duration.fromJSON(object.gopDuration) : undefined,
      profile: isSet(object.profile) ? globalThis.String(object.profile) : "",
    };
  },

  toJSON(message: VideoStream_Vp9CodecSettings): unknown {
    const obj: any = {};
    if (message.widthPixels !== 0) {
      obj.widthPixels = Math.round(message.widthPixels);
    }
    if (message.heightPixels !== 0) {
      obj.heightPixels = Math.round(message.heightPixels);
    }
    if (message.frameRate !== 0) {
      obj.frameRate = message.frameRate;
    }
    if (message.bitrateBps !== 0) {
      obj.bitrateBps = Math.round(message.bitrateBps);
    }
    if (message.pixelFormat !== "") {
      obj.pixelFormat = message.pixelFormat;
    }
    if (message.rateControlMode !== "") {
      obj.rateControlMode = message.rateControlMode;
    }
    if (message.crfLevel !== 0) {
      obj.crfLevel = Math.round(message.crfLevel);
    }
    if (message.gopFrameCount !== undefined) {
      obj.gopFrameCount = Math.round(message.gopFrameCount);
    }
    if (message.gopDuration !== undefined) {
      obj.gopDuration = Duration.toJSON(message.gopDuration);
    }
    if (message.profile !== "") {
      obj.profile = message.profile;
    }
    return obj;
  },

  create(base?: DeepPartial<VideoStream_Vp9CodecSettings>): VideoStream_Vp9CodecSettings {
    return VideoStream_Vp9CodecSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoStream_Vp9CodecSettings>): VideoStream_Vp9CodecSettings {
    const message = createBaseVideoStream_Vp9CodecSettings();
    message.widthPixels = object.widthPixels ?? 0;
    message.heightPixels = object.heightPixels ?? 0;
    message.frameRate = object.frameRate ?? 0;
    message.bitrateBps = object.bitrateBps ?? 0;
    message.pixelFormat = object.pixelFormat ?? "";
    message.rateControlMode = object.rateControlMode ?? "";
    message.crfLevel = object.crfLevel ?? 0;
    message.gopFrameCount = object.gopFrameCount ?? undefined;
    message.gopDuration = (object.gopDuration !== undefined && object.gopDuration !== null)
      ? Duration.fromPartial(object.gopDuration)
      : undefined;
    message.profile = object.profile ?? "";
    return message;
  },
};

function createBaseAudioStream(): AudioStream {
  return {
    codec: "",
    bitrateBps: 0,
    channelCount: 0,
    channelLayout: [],
    mapping: [],
    sampleRateHertz: 0,
    languageCode: "",
    displayName: "",
  };
}

export const AudioStream: MessageFns<AudioStream> = {
  encode(message: AudioStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.bitrateBps !== 0) {
      writer.uint32(16).int32(message.bitrateBps);
    }
    if (message.channelCount !== 0) {
      writer.uint32(24).int32(message.channelCount);
    }
    for (const v of message.channelLayout) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.mapping) {
      AudioStream_AudioMapping.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.sampleRateHertz !== 0) {
      writer.uint32(48).int32(message.sampleRateHertz);
    }
    if (message.languageCode !== "") {
      writer.uint32(58).string(message.languageCode);
    }
    if (message.displayName !== "") {
      writer.uint32(66).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bitrateBps = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.channelCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.channelLayout.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mapping.push(AudioStream_AudioMapping.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sampleRateHertz = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStream {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      bitrateBps: isSet(object.bitrateBps) ? globalThis.Number(object.bitrateBps) : 0,
      channelCount: isSet(object.channelCount) ? globalThis.Number(object.channelCount) : 0,
      channelLayout: globalThis.Array.isArray(object?.channelLayout)
        ? object.channelLayout.map((e: any) => globalThis.String(e))
        : [],
      mapping: globalThis.Array.isArray(object?.mapping)
        ? object.mapping.map((e: any) => AudioStream_AudioMapping.fromJSON(e))
        : [],
      sampleRateHertz: isSet(object.sampleRateHertz) ? globalThis.Number(object.sampleRateHertz) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: AudioStream): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.bitrateBps !== 0) {
      obj.bitrateBps = Math.round(message.bitrateBps);
    }
    if (message.channelCount !== 0) {
      obj.channelCount = Math.round(message.channelCount);
    }
    if (message.channelLayout?.length) {
      obj.channelLayout = message.channelLayout;
    }
    if (message.mapping?.length) {
      obj.mapping = message.mapping.map((e) => AudioStream_AudioMapping.toJSON(e));
    }
    if (message.sampleRateHertz !== 0) {
      obj.sampleRateHertz = Math.round(message.sampleRateHertz);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStream>): AudioStream {
    return AudioStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStream>): AudioStream {
    const message = createBaseAudioStream();
    message.codec = object.codec ?? "";
    message.bitrateBps = object.bitrateBps ?? 0;
    message.channelCount = object.channelCount ?? 0;
    message.channelLayout = object.channelLayout?.map((e) => e) || [];
    message.mapping = object.mapping?.map((e) => AudioStream_AudioMapping.fromPartial(e)) || [];
    message.sampleRateHertz = object.sampleRateHertz ?? 0;
    message.languageCode = object.languageCode ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseAudioStream_AudioMapping(): AudioStream_AudioMapping {
  return { atomKey: "", inputKey: "", inputTrack: 0, inputChannel: 0, outputChannel: 0, gainDb: 0 };
}

export const AudioStream_AudioMapping: MessageFns<AudioStream_AudioMapping> = {
  encode(message: AudioStream_AudioMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.atomKey !== "") {
      writer.uint32(10).string(message.atomKey);
    }
    if (message.inputKey !== "") {
      writer.uint32(18).string(message.inputKey);
    }
    if (message.inputTrack !== 0) {
      writer.uint32(24).int32(message.inputTrack);
    }
    if (message.inputChannel !== 0) {
      writer.uint32(32).int32(message.inputChannel);
    }
    if (message.outputChannel !== 0) {
      writer.uint32(40).int32(message.outputChannel);
    }
    if (message.gainDb !== 0) {
      writer.uint32(49).double(message.gainDb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudioStream_AudioMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudioStream_AudioMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.atomKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputKey = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inputTrack = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.inputChannel = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.outputChannel = reader.int32();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.gainDb = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudioStream_AudioMapping {
    return {
      atomKey: isSet(object.atomKey) ? globalThis.String(object.atomKey) : "",
      inputKey: isSet(object.inputKey) ? globalThis.String(object.inputKey) : "",
      inputTrack: isSet(object.inputTrack) ? globalThis.Number(object.inputTrack) : 0,
      inputChannel: isSet(object.inputChannel) ? globalThis.Number(object.inputChannel) : 0,
      outputChannel: isSet(object.outputChannel) ? globalThis.Number(object.outputChannel) : 0,
      gainDb: isSet(object.gainDb) ? globalThis.Number(object.gainDb) : 0,
    };
  },

  toJSON(message: AudioStream_AudioMapping): unknown {
    const obj: any = {};
    if (message.atomKey !== "") {
      obj.atomKey = message.atomKey;
    }
    if (message.inputKey !== "") {
      obj.inputKey = message.inputKey;
    }
    if (message.inputTrack !== 0) {
      obj.inputTrack = Math.round(message.inputTrack);
    }
    if (message.inputChannel !== 0) {
      obj.inputChannel = Math.round(message.inputChannel);
    }
    if (message.outputChannel !== 0) {
      obj.outputChannel = Math.round(message.outputChannel);
    }
    if (message.gainDb !== 0) {
      obj.gainDb = message.gainDb;
    }
    return obj;
  },

  create(base?: DeepPartial<AudioStream_AudioMapping>): AudioStream_AudioMapping {
    return AudioStream_AudioMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudioStream_AudioMapping>): AudioStream_AudioMapping {
    const message = createBaseAudioStream_AudioMapping();
    message.atomKey = object.atomKey ?? "";
    message.inputKey = object.inputKey ?? "";
    message.inputTrack = object.inputTrack ?? 0;
    message.inputChannel = object.inputChannel ?? 0;
    message.outputChannel = object.outputChannel ?? 0;
    message.gainDb = object.gainDb ?? 0;
    return message;
  },
};

function createBaseTextStream(): TextStream {
  return { codec: "", languageCode: "", mapping: [], displayName: "" };
}

export const TextStream: MessageFns<TextStream> = {
  encode(message: TextStream, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    for (const v of message.mapping) {
      TextStream_TextMapping.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextStream {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextStream();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapping.push(TextStream_TextMapping.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextStream {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      mapping: globalThis.Array.isArray(object?.mapping)
        ? object.mapping.map((e: any) => TextStream_TextMapping.fromJSON(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: TextStream): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.mapping?.length) {
      obj.mapping = message.mapping.map((e) => TextStream_TextMapping.toJSON(e));
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<TextStream>): TextStream {
    return TextStream.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextStream>): TextStream {
    const message = createBaseTextStream();
    message.codec = object.codec ?? "";
    message.languageCode = object.languageCode ?? "";
    message.mapping = object.mapping?.map((e) => TextStream_TextMapping.fromPartial(e)) || [];
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseTextStream_TextMapping(): TextStream_TextMapping {
  return { atomKey: "", inputKey: "", inputTrack: 0 };
}

export const TextStream_TextMapping: MessageFns<TextStream_TextMapping> = {
  encode(message: TextStream_TextMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.atomKey !== "") {
      writer.uint32(10).string(message.atomKey);
    }
    if (message.inputKey !== "") {
      writer.uint32(18).string(message.inputKey);
    }
    if (message.inputTrack !== 0) {
      writer.uint32(24).int32(message.inputTrack);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextStream_TextMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextStream_TextMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.atomKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputKey = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.inputTrack = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextStream_TextMapping {
    return {
      atomKey: isSet(object.atomKey) ? globalThis.String(object.atomKey) : "",
      inputKey: isSet(object.inputKey) ? globalThis.String(object.inputKey) : "",
      inputTrack: isSet(object.inputTrack) ? globalThis.Number(object.inputTrack) : 0,
    };
  },

  toJSON(message: TextStream_TextMapping): unknown {
    const obj: any = {};
    if (message.atomKey !== "") {
      obj.atomKey = message.atomKey;
    }
    if (message.inputKey !== "") {
      obj.inputKey = message.inputKey;
    }
    if (message.inputTrack !== 0) {
      obj.inputTrack = Math.round(message.inputTrack);
    }
    return obj;
  },

  create(base?: DeepPartial<TextStream_TextMapping>): TextStream_TextMapping {
    return TextStream_TextMapping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextStream_TextMapping>): TextStream_TextMapping {
    const message = createBaseTextStream_TextMapping();
    message.atomKey = object.atomKey ?? "";
    message.inputKey = object.inputKey ?? "";
    message.inputTrack = object.inputTrack ?? 0;
    return message;
  },
};

function createBaseSegmentSettings(): SegmentSettings {
  return { segmentDuration: undefined, individualSegments: false };
}

export const SegmentSettings: MessageFns<SegmentSettings> = {
  encode(message: SegmentSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segmentDuration !== undefined) {
      Duration.encode(message.segmentDuration, writer.uint32(10).fork()).join();
    }
    if (message.individualSegments !== false) {
      writer.uint32(24).bool(message.individualSegments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SegmentSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSegmentSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.segmentDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.individualSegments = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SegmentSettings {
    return {
      segmentDuration: isSet(object.segmentDuration) ? Duration.fromJSON(object.segmentDuration) : undefined,
      individualSegments: isSet(object.individualSegments) ? globalThis.Boolean(object.individualSegments) : false,
    };
  },

  toJSON(message: SegmentSettings): unknown {
    const obj: any = {};
    if (message.segmentDuration !== undefined) {
      obj.segmentDuration = Duration.toJSON(message.segmentDuration);
    }
    if (message.individualSegments !== false) {
      obj.individualSegments = message.individualSegments;
    }
    return obj;
  },

  create(base?: DeepPartial<SegmentSettings>): SegmentSettings {
    return SegmentSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SegmentSettings>): SegmentSettings {
    const message = createBaseSegmentSettings();
    message.segmentDuration = (object.segmentDuration !== undefined && object.segmentDuration !== null)
      ? Duration.fromPartial(object.segmentDuration)
      : undefined;
    message.individualSegments = object.individualSegments ?? false;
    return message;
  },
};

function createBaseEncryption(): Encryption {
  return {
    id: "",
    aes128: undefined,
    sampleAes: undefined,
    mpegCenc: undefined,
    secretManagerKeySource: undefined,
    drmSystems: undefined,
  };
}

export const Encryption: MessageFns<Encryption> = {
  encode(message: Encryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.aes128 !== undefined) {
      Encryption_Aes128Encryption.encode(message.aes128, writer.uint32(26).fork()).join();
    }
    if (message.sampleAes !== undefined) {
      Encryption_SampleAesEncryption.encode(message.sampleAes, writer.uint32(34).fork()).join();
    }
    if (message.mpegCenc !== undefined) {
      Encryption_MpegCommonEncryption.encode(message.mpegCenc, writer.uint32(42).fork()).join();
    }
    if (message.secretManagerKeySource !== undefined) {
      Encryption_SecretManagerSource.encode(message.secretManagerKeySource, writer.uint32(58).fork()).join();
    }
    if (message.drmSystems !== undefined) {
      Encryption_DrmSystems.encode(message.drmSystems, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aes128 = Encryption_Aes128Encryption.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sampleAes = Encryption_SampleAesEncryption.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mpegCenc = Encryption_MpegCommonEncryption.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.secretManagerKeySource = Encryption_SecretManagerSource.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.drmSystems = Encryption_DrmSystems.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      aes128: isSet(object.aes128) ? Encryption_Aes128Encryption.fromJSON(object.aes128) : undefined,
      sampleAes: isSet(object.sampleAes) ? Encryption_SampleAesEncryption.fromJSON(object.sampleAes) : undefined,
      mpegCenc: isSet(object.mpegCenc) ? Encryption_MpegCommonEncryption.fromJSON(object.mpegCenc) : undefined,
      secretManagerKeySource: isSet(object.secretManagerKeySource)
        ? Encryption_SecretManagerSource.fromJSON(object.secretManagerKeySource)
        : undefined,
      drmSystems: isSet(object.drmSystems) ? Encryption_DrmSystems.fromJSON(object.drmSystems) : undefined,
    };
  },

  toJSON(message: Encryption): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.aes128 !== undefined) {
      obj.aes128 = Encryption_Aes128Encryption.toJSON(message.aes128);
    }
    if (message.sampleAes !== undefined) {
      obj.sampleAes = Encryption_SampleAesEncryption.toJSON(message.sampleAes);
    }
    if (message.mpegCenc !== undefined) {
      obj.mpegCenc = Encryption_MpegCommonEncryption.toJSON(message.mpegCenc);
    }
    if (message.secretManagerKeySource !== undefined) {
      obj.secretManagerKeySource = Encryption_SecretManagerSource.toJSON(message.secretManagerKeySource);
    }
    if (message.drmSystems !== undefined) {
      obj.drmSystems = Encryption_DrmSystems.toJSON(message.drmSystems);
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption>): Encryption {
    return Encryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption>): Encryption {
    const message = createBaseEncryption();
    message.id = object.id ?? "";
    message.aes128 = (object.aes128 !== undefined && object.aes128 !== null)
      ? Encryption_Aes128Encryption.fromPartial(object.aes128)
      : undefined;
    message.sampleAes = (object.sampleAes !== undefined && object.sampleAes !== null)
      ? Encryption_SampleAesEncryption.fromPartial(object.sampleAes)
      : undefined;
    message.mpegCenc = (object.mpegCenc !== undefined && object.mpegCenc !== null)
      ? Encryption_MpegCommonEncryption.fromPartial(object.mpegCenc)
      : undefined;
    message.secretManagerKeySource =
      (object.secretManagerKeySource !== undefined && object.secretManagerKeySource !== null)
        ? Encryption_SecretManagerSource.fromPartial(object.secretManagerKeySource)
        : undefined;
    message.drmSystems = (object.drmSystems !== undefined && object.drmSystems !== null)
      ? Encryption_DrmSystems.fromPartial(object.drmSystems)
      : undefined;
    return message;
  },
};

function createBaseEncryption_Aes128Encryption(): Encryption_Aes128Encryption {
  return {};
}

export const Encryption_Aes128Encryption: MessageFns<Encryption_Aes128Encryption> = {
  encode(_: Encryption_Aes128Encryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Aes128Encryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Aes128Encryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Aes128Encryption {
    return {};
  },

  toJSON(_: Encryption_Aes128Encryption): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Aes128Encryption>): Encryption_Aes128Encryption {
    return Encryption_Aes128Encryption.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Aes128Encryption>): Encryption_Aes128Encryption {
    const message = createBaseEncryption_Aes128Encryption();
    return message;
  },
};

function createBaseEncryption_SampleAesEncryption(): Encryption_SampleAesEncryption {
  return {};
}

export const Encryption_SampleAesEncryption: MessageFns<Encryption_SampleAesEncryption> = {
  encode(_: Encryption_SampleAesEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_SampleAesEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_SampleAesEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_SampleAesEncryption {
    return {};
  },

  toJSON(_: Encryption_SampleAesEncryption): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_SampleAesEncryption>): Encryption_SampleAesEncryption {
    return Encryption_SampleAesEncryption.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_SampleAesEncryption>): Encryption_SampleAesEncryption {
    const message = createBaseEncryption_SampleAesEncryption();
    return message;
  },
};

function createBaseEncryption_MpegCommonEncryption(): Encryption_MpegCommonEncryption {
  return { scheme: "" };
}

export const Encryption_MpegCommonEncryption: MessageFns<Encryption_MpegCommonEncryption> = {
  encode(message: Encryption_MpegCommonEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheme !== "") {
      writer.uint32(18).string(message.scheme);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_MpegCommonEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_MpegCommonEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scheme = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_MpegCommonEncryption {
    return { scheme: isSet(object.scheme) ? globalThis.String(object.scheme) : "" };
  },

  toJSON(message: Encryption_MpegCommonEncryption): unknown {
    const obj: any = {};
    if (message.scheme !== "") {
      obj.scheme = message.scheme;
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_MpegCommonEncryption>): Encryption_MpegCommonEncryption {
    return Encryption_MpegCommonEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_MpegCommonEncryption>): Encryption_MpegCommonEncryption {
    const message = createBaseEncryption_MpegCommonEncryption();
    message.scheme = object.scheme ?? "";
    return message;
  },
};

function createBaseEncryption_SecretManagerSource(): Encryption_SecretManagerSource {
  return { secretVersion: "" };
}

export const Encryption_SecretManagerSource: MessageFns<Encryption_SecretManagerSource> = {
  encode(message: Encryption_SecretManagerSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretVersion !== "") {
      writer.uint32(10).string(message.secretVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_SecretManagerSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_SecretManagerSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secretVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_SecretManagerSource {
    return { secretVersion: isSet(object.secretVersion) ? globalThis.String(object.secretVersion) : "" };
  },

  toJSON(message: Encryption_SecretManagerSource): unknown {
    const obj: any = {};
    if (message.secretVersion !== "") {
      obj.secretVersion = message.secretVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_SecretManagerSource>): Encryption_SecretManagerSource {
    return Encryption_SecretManagerSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_SecretManagerSource>): Encryption_SecretManagerSource {
    const message = createBaseEncryption_SecretManagerSource();
    message.secretVersion = object.secretVersion ?? "";
    return message;
  },
};

function createBaseEncryption_Widevine(): Encryption_Widevine {
  return {};
}

export const Encryption_Widevine: MessageFns<Encryption_Widevine> = {
  encode(_: Encryption_Widevine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Widevine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Widevine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Widevine {
    return {};
  },

  toJSON(_: Encryption_Widevine): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Widevine>): Encryption_Widevine {
    return Encryption_Widevine.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Widevine>): Encryption_Widevine {
    const message = createBaseEncryption_Widevine();
    return message;
  },
};

function createBaseEncryption_Fairplay(): Encryption_Fairplay {
  return {};
}

export const Encryption_Fairplay: MessageFns<Encryption_Fairplay> = {
  encode(_: Encryption_Fairplay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Fairplay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Fairplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Fairplay {
    return {};
  },

  toJSON(_: Encryption_Fairplay): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Fairplay>): Encryption_Fairplay {
    return Encryption_Fairplay.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Fairplay>): Encryption_Fairplay {
    const message = createBaseEncryption_Fairplay();
    return message;
  },
};

function createBaseEncryption_Playready(): Encryption_Playready {
  return {};
}

export const Encryption_Playready: MessageFns<Encryption_Playready> = {
  encode(_: Encryption_Playready, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Playready {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Playready();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Playready {
    return {};
  },

  toJSON(_: Encryption_Playready): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Playready>): Encryption_Playready {
    return Encryption_Playready.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Playready>): Encryption_Playready {
    const message = createBaseEncryption_Playready();
    return message;
  },
};

function createBaseEncryption_Clearkey(): Encryption_Clearkey {
  return {};
}

export const Encryption_Clearkey: MessageFns<Encryption_Clearkey> = {
  encode(_: Encryption_Clearkey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_Clearkey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_Clearkey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Encryption_Clearkey {
    return {};
  },

  toJSON(_: Encryption_Clearkey): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Encryption_Clearkey>): Encryption_Clearkey {
    return Encryption_Clearkey.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Encryption_Clearkey>): Encryption_Clearkey {
    const message = createBaseEncryption_Clearkey();
    return message;
  },
};

function createBaseEncryption_DrmSystems(): Encryption_DrmSystems {
  return { widevine: undefined, fairplay: undefined, playready: undefined, clearkey: undefined };
}

export const Encryption_DrmSystems: MessageFns<Encryption_DrmSystems> = {
  encode(message: Encryption_DrmSystems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widevine !== undefined) {
      Encryption_Widevine.encode(message.widevine, writer.uint32(10).fork()).join();
    }
    if (message.fairplay !== undefined) {
      Encryption_Fairplay.encode(message.fairplay, writer.uint32(18).fork()).join();
    }
    if (message.playready !== undefined) {
      Encryption_Playready.encode(message.playready, writer.uint32(26).fork()).join();
    }
    if (message.clearkey !== undefined) {
      Encryption_Clearkey.encode(message.clearkey, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Encryption_DrmSystems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryption_DrmSystems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.widevine = Encryption_Widevine.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fairplay = Encryption_Fairplay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.playready = Encryption_Playready.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clearkey = Encryption_Clearkey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Encryption_DrmSystems {
    return {
      widevine: isSet(object.widevine) ? Encryption_Widevine.fromJSON(object.widevine) : undefined,
      fairplay: isSet(object.fairplay) ? Encryption_Fairplay.fromJSON(object.fairplay) : undefined,
      playready: isSet(object.playready) ? Encryption_Playready.fromJSON(object.playready) : undefined,
      clearkey: isSet(object.clearkey) ? Encryption_Clearkey.fromJSON(object.clearkey) : undefined,
    };
  },

  toJSON(message: Encryption_DrmSystems): unknown {
    const obj: any = {};
    if (message.widevine !== undefined) {
      obj.widevine = Encryption_Widevine.toJSON(message.widevine);
    }
    if (message.fairplay !== undefined) {
      obj.fairplay = Encryption_Fairplay.toJSON(message.fairplay);
    }
    if (message.playready !== undefined) {
      obj.playready = Encryption_Playready.toJSON(message.playready);
    }
    if (message.clearkey !== undefined) {
      obj.clearkey = Encryption_Clearkey.toJSON(message.clearkey);
    }
    return obj;
  },

  create(base?: DeepPartial<Encryption_DrmSystems>): Encryption_DrmSystems {
    return Encryption_DrmSystems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Encryption_DrmSystems>): Encryption_DrmSystems {
    const message = createBaseEncryption_DrmSystems();
    message.widevine = (object.widevine !== undefined && object.widevine !== null)
      ? Encryption_Widevine.fromPartial(object.widevine)
      : undefined;
    message.fairplay = (object.fairplay !== undefined && object.fairplay !== null)
      ? Encryption_Fairplay.fromPartial(object.fairplay)
      : undefined;
    message.playready = (object.playready !== undefined && object.playready !== null)
      ? Encryption_Playready.fromPartial(object.playready)
      : undefined;
    message.clearkey = (object.clearkey !== undefined && object.clearkey !== null)
      ? Encryption_Clearkey.fromPartial(object.clearkey)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
