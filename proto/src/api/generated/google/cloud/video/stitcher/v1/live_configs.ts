// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/video/stitcher/v1/live_configs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { FetchOptions } from "./fetch_options.js";

export const protobufPackage = "google.cloud.video.stitcher.v1";

/** Determines the ad tracking policy. */
export enum AdTracking {
  /** AD_TRACKING_UNSPECIFIED - The ad tracking policy is not specified. */
  AD_TRACKING_UNSPECIFIED = 0,
  /**
   * CLIENT - Client-side ad tracking is specified. The client player is expected to
   * trigger playback and activity events itself.
   */
  CLIENT = 1,
  /**
   * SERVER - The Video Stitcher API will trigger playback events on behalf of
   * the client player.
   */
  SERVER = 2,
  UNRECOGNIZED = -1,
}

export function adTrackingFromJSON(object: any): AdTracking {
  switch (object) {
    case 0:
    case "AD_TRACKING_UNSPECIFIED":
      return AdTracking.AD_TRACKING_UNSPECIFIED;
    case 1:
    case "CLIENT":
      return AdTracking.CLIENT;
    case 2:
    case "SERVER":
      return AdTracking.SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AdTracking.UNRECOGNIZED;
  }
}

export function adTrackingToJSON(object: AdTracking): string {
  switch (object) {
    case AdTracking.AD_TRACKING_UNSPECIFIED:
      return "AD_TRACKING_UNSPECIFIED";
    case AdTracking.CLIENT:
      return "CLIENT";
    case AdTracking.SERVER:
      return "SERVER";
    case AdTracking.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Metadata for used to register live configs. */
export interface LiveConfig {
  /**
   * Output only. The resource name of the live config, in the form of
   * `projects/{project}/locations/{location}/liveConfigs/{id}`.
   */
  name: string;
  /** Required. Source URI for the live stream manifest. */
  sourceUri: string;
  /** The default ad tag associated with this live stream config. */
  adTagUri: string;
  /**
   * Additional metadata used to register a live stream with Google Ad Manager
   * (GAM)
   */
  gamLiveConfig:
    | GamLiveConfig
    | undefined;
  /** Output only. State of the live config. */
  state: LiveConfig_State;
  /** Required. Determines how the ads are tracked. */
  adTracking: AdTracking;
  /**
   * This must refer to a slate in the same
   * project. If Google Ad Manager (GAM) is used for ads, this string sets the
   * value of `slateCreativeId` in
   * https://developers.google.com/ad-manager/api/reference/v202211/LiveStreamEventService.LiveStreamEvent#slateCreativeId
   */
  defaultSlate: string;
  /**
   * Defines the stitcher behavior in case an ad does not align exactly with
   * the ad break boundaries. If not specified, the default is `CUT_CURRENT`.
   */
  stitchingPolicy: LiveConfig_StitchingPolicy;
  /** The configuration for prefetching ads. */
  prefetchConfig:
    | PrefetchConfig
    | undefined;
  /** Options for fetching source manifests and segments. */
  sourceFetchOptions: FetchOptions | undefined;
}

/** State of the live config. */
export enum LiveConfig_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Live config is being created. */
  CREATING = 1,
  /** READY - Live config is ready for use. */
  READY = 2,
  /** DELETING - Live config is queued up for deletion. */
  DELETING = 3,
  UNRECOGNIZED = -1,
}

export function liveConfig_StateFromJSON(object: any): LiveConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return LiveConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return LiveConfig_State.CREATING;
    case 2:
    case "READY":
      return LiveConfig_State.READY;
    case 3:
    case "DELETING":
      return LiveConfig_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LiveConfig_State.UNRECOGNIZED;
  }
}

export function liveConfig_StateToJSON(object: LiveConfig_State): string {
  switch (object) {
    case LiveConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case LiveConfig_State.CREATING:
      return "CREATING";
    case LiveConfig_State.READY:
      return "READY";
    case LiveConfig_State.DELETING:
      return "DELETING";
    case LiveConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines the ad stitching behavior in case the ad duration does not align
 * exactly with the ad break boundaries. If not specified, the default is
 * `CUT_CURRENT`.
 */
export enum LiveConfig_StitchingPolicy {
  /** STITCHING_POLICY_UNSPECIFIED - Stitching policy is not specified. */
  STITCHING_POLICY_UNSPECIFIED = 0,
  /** CUT_CURRENT - Cuts an ad short and returns to content in the middle of the ad. */
  CUT_CURRENT = 1,
  /** COMPLETE_AD - Finishes stitching the current ad before returning to content. */
  COMPLETE_AD = 2,
  UNRECOGNIZED = -1,
}

export function liveConfig_StitchingPolicyFromJSON(object: any): LiveConfig_StitchingPolicy {
  switch (object) {
    case 0:
    case "STITCHING_POLICY_UNSPECIFIED":
      return LiveConfig_StitchingPolicy.STITCHING_POLICY_UNSPECIFIED;
    case 1:
    case "CUT_CURRENT":
      return LiveConfig_StitchingPolicy.CUT_CURRENT;
    case 2:
    case "COMPLETE_AD":
      return LiveConfig_StitchingPolicy.COMPLETE_AD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LiveConfig_StitchingPolicy.UNRECOGNIZED;
  }
}

export function liveConfig_StitchingPolicyToJSON(object: LiveConfig_StitchingPolicy): string {
  switch (object) {
    case LiveConfig_StitchingPolicy.STITCHING_POLICY_UNSPECIFIED:
      return "STITCHING_POLICY_UNSPECIFIED";
    case LiveConfig_StitchingPolicy.CUT_CURRENT:
      return "CUT_CURRENT";
    case LiveConfig_StitchingPolicy.COMPLETE_AD:
      return "COMPLETE_AD";
    case LiveConfig_StitchingPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The configuration for prefetch ads. */
export interface PrefetchConfig {
  /** Required. Indicates whether the option to prefetch ad requests is enabled. */
  enabled: boolean;
  /**
   * The duration in seconds of the part of the break to be prefetched.
   * This field is only relevant if prefetch is enabled.
   * You should set this duration to as long as possible to increase the
   * benefits of prefetching, but not longer than the shortest ad break
   * expected. For example, for a live event with 30s and 60s ad breaks, the
   * initial duration should be set to 30s.
   */
  initialAdRequestDuration: Duration | undefined;
}

/** Metadata used to register a live stream with Google Ad Manager (GAM) */
export interface GamLiveConfig {
  /** Required. Ad Manager network code to associate with the live config. */
  networkCode: string;
  /** Output only. The asset key identifier generated for the live config. */
  assetKey: string;
  /** Output only. The custom asset key identifier generated for the live config. */
  customAssetKey: string;
}

function createBaseLiveConfig(): LiveConfig {
  return {
    name: "",
    sourceUri: "",
    adTagUri: "",
    gamLiveConfig: undefined,
    state: 0,
    adTracking: 0,
    defaultSlate: "",
    stitchingPolicy: 0,
    prefetchConfig: undefined,
    sourceFetchOptions: undefined,
  };
}

export const LiveConfig: MessageFns<LiveConfig> = {
  encode(message: LiveConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sourceUri !== "") {
      writer.uint32(18).string(message.sourceUri);
    }
    if (message.adTagUri !== "") {
      writer.uint32(26).string(message.adTagUri);
    }
    if (message.gamLiveConfig !== undefined) {
      GamLiveConfig.encode(message.gamLiveConfig, writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.adTracking !== 0) {
      writer.uint32(48).int32(message.adTracking);
    }
    if (message.defaultSlate !== "") {
      writer.uint32(58).string(message.defaultSlate);
    }
    if (message.stitchingPolicy !== 0) {
      writer.uint32(64).int32(message.stitchingPolicy);
    }
    if (message.prefetchConfig !== undefined) {
      PrefetchConfig.encode(message.prefetchConfig, writer.uint32(82).fork()).join();
    }
    if (message.sourceFetchOptions !== undefined) {
      FetchOptions.encode(message.sourceFetchOptions, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiveConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiveConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adTagUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gamLiveConfig = GamLiveConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.adTracking = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultSlate = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.stitchingPolicy = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.prefetchConfig = PrefetchConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.sourceFetchOptions = FetchOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LiveConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      adTagUri: isSet(object.adTagUri) ? globalThis.String(object.adTagUri) : "",
      gamLiveConfig: isSet(object.gamLiveConfig) ? GamLiveConfig.fromJSON(object.gamLiveConfig) : undefined,
      state: isSet(object.state) ? liveConfig_StateFromJSON(object.state) : 0,
      adTracking: isSet(object.adTracking) ? adTrackingFromJSON(object.adTracking) : 0,
      defaultSlate: isSet(object.defaultSlate) ? globalThis.String(object.defaultSlate) : "",
      stitchingPolicy: isSet(object.stitchingPolicy) ? liveConfig_StitchingPolicyFromJSON(object.stitchingPolicy) : 0,
      prefetchConfig: isSet(object.prefetchConfig) ? PrefetchConfig.fromJSON(object.prefetchConfig) : undefined,
      sourceFetchOptions: isSet(object.sourceFetchOptions)
        ? FetchOptions.fromJSON(object.sourceFetchOptions)
        : undefined,
    };
  },

  toJSON(message: LiveConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.adTagUri !== "") {
      obj.adTagUri = message.adTagUri;
    }
    if (message.gamLiveConfig !== undefined) {
      obj.gamLiveConfig = GamLiveConfig.toJSON(message.gamLiveConfig);
    }
    if (message.state !== 0) {
      obj.state = liveConfig_StateToJSON(message.state);
    }
    if (message.adTracking !== 0) {
      obj.adTracking = adTrackingToJSON(message.adTracking);
    }
    if (message.defaultSlate !== "") {
      obj.defaultSlate = message.defaultSlate;
    }
    if (message.stitchingPolicy !== 0) {
      obj.stitchingPolicy = liveConfig_StitchingPolicyToJSON(message.stitchingPolicy);
    }
    if (message.prefetchConfig !== undefined) {
      obj.prefetchConfig = PrefetchConfig.toJSON(message.prefetchConfig);
    }
    if (message.sourceFetchOptions !== undefined) {
      obj.sourceFetchOptions = FetchOptions.toJSON(message.sourceFetchOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<LiveConfig>): LiveConfig {
    return LiveConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiveConfig>): LiveConfig {
    const message = createBaseLiveConfig();
    message.name = object.name ?? "";
    message.sourceUri = object.sourceUri ?? "";
    message.adTagUri = object.adTagUri ?? "";
    message.gamLiveConfig = (object.gamLiveConfig !== undefined && object.gamLiveConfig !== null)
      ? GamLiveConfig.fromPartial(object.gamLiveConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.adTracking = object.adTracking ?? 0;
    message.defaultSlate = object.defaultSlate ?? "";
    message.stitchingPolicy = object.stitchingPolicy ?? 0;
    message.prefetchConfig = (object.prefetchConfig !== undefined && object.prefetchConfig !== null)
      ? PrefetchConfig.fromPartial(object.prefetchConfig)
      : undefined;
    message.sourceFetchOptions = (object.sourceFetchOptions !== undefined && object.sourceFetchOptions !== null)
      ? FetchOptions.fromPartial(object.sourceFetchOptions)
      : undefined;
    return message;
  },
};

function createBasePrefetchConfig(): PrefetchConfig {
  return { enabled: false, initialAdRequestDuration: undefined };
}

export const PrefetchConfig: MessageFns<PrefetchConfig> = {
  encode(message: PrefetchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.initialAdRequestDuration !== undefined) {
      Duration.encode(message.initialAdRequestDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefetchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefetchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initialAdRequestDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefetchConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      initialAdRequestDuration: isSet(object.initialAdRequestDuration)
        ? Duration.fromJSON(object.initialAdRequestDuration)
        : undefined,
    };
  },

  toJSON(message: PrefetchConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.initialAdRequestDuration !== undefined) {
      obj.initialAdRequestDuration = Duration.toJSON(message.initialAdRequestDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<PrefetchConfig>): PrefetchConfig {
    return PrefetchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrefetchConfig>): PrefetchConfig {
    const message = createBasePrefetchConfig();
    message.enabled = object.enabled ?? false;
    message.initialAdRequestDuration =
      (object.initialAdRequestDuration !== undefined && object.initialAdRequestDuration !== null)
        ? Duration.fromPartial(object.initialAdRequestDuration)
        : undefined;
    return message;
  },
};

function createBaseGamLiveConfig(): GamLiveConfig {
  return { networkCode: "", assetKey: "", customAssetKey: "" };
}

export const GamLiveConfig: MessageFns<GamLiveConfig> = {
  encode(message: GamLiveConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkCode !== "") {
      writer.uint32(10).string(message.networkCode);
    }
    if (message.assetKey !== "") {
      writer.uint32(18).string(message.assetKey);
    }
    if (message.customAssetKey !== "") {
      writer.uint32(26).string(message.customAssetKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GamLiveConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGamLiveConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customAssetKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GamLiveConfig {
    return {
      networkCode: isSet(object.networkCode) ? globalThis.String(object.networkCode) : "",
      assetKey: isSet(object.assetKey) ? globalThis.String(object.assetKey) : "",
      customAssetKey: isSet(object.customAssetKey) ? globalThis.String(object.customAssetKey) : "",
    };
  },

  toJSON(message: GamLiveConfig): unknown {
    const obj: any = {};
    if (message.networkCode !== "") {
      obj.networkCode = message.networkCode;
    }
    if (message.assetKey !== "") {
      obj.assetKey = message.assetKey;
    }
    if (message.customAssetKey !== "") {
      obj.customAssetKey = message.customAssetKey;
    }
    return obj;
  },

  create(base?: DeepPartial<GamLiveConfig>): GamLiveConfig {
    return GamLiveConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GamLiveConfig>): GamLiveConfig {
    const message = createBaseGamLiveConfig();
    message.networkCode = object.networkCode ?? "";
    message.assetKey = object.assetKey ?? "";
    message.customAssetKey = object.customAssetKey ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
