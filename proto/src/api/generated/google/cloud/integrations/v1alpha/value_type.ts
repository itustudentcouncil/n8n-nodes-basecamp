// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/integrations/v1alpha/value_type.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.integrations.v1alpha";

/** The type of the parameter. */
export interface ValueType {
  /** String. */
  stringValue?:
    | string
    | undefined;
  /** Integer. */
  intValue?:
    | Long
    | undefined;
  /** Double Number. */
  doubleValue?:
    | number
    | undefined;
  /** Boolean. */
  booleanValue?:
    | boolean
    | undefined;
  /** String Array. */
  stringArray?:
    | StringParameterArray
    | undefined;
  /** Integer Array. */
  intArray?:
    | IntParameterArray
    | undefined;
  /** Double Number Array. */
  doubleArray?:
    | DoubleParameterArray
    | undefined;
  /** Boolean Array. */
  booleanArray?:
    | BooleanParameterArray
    | undefined;
  /** Json. */
  jsonValue?: string | undefined;
}

/** This message only contains a field of string array. */
export interface StringParameterArray {
  /** String array. */
  stringValues: string[];
}

/** This message only contains a field of integer array. */
export interface IntParameterArray {
  /** Integer array. */
  intValues: Long[];
}

/** This message only contains a field of double number array. */
export interface DoubleParameterArray {
  /** Double number array. */
  doubleValues: number[];
}

/** This message only contains a field of boolean array. */
export interface BooleanParameterArray {
  /** Boolean array. */
  booleanValues: boolean[];
}

function createBaseValueType(): ValueType {
  return {
    stringValue: undefined,
    intValue: undefined,
    doubleValue: undefined,
    booleanValue: undefined,
    stringArray: undefined,
    intArray: undefined,
    doubleArray: undefined,
    booleanArray: undefined,
    jsonValue: undefined,
  };
}

export const ValueType: MessageFns<ValueType> = {
  encode(message: ValueType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(25).double(message.doubleValue);
    }
    if (message.booleanValue !== undefined) {
      writer.uint32(32).bool(message.booleanValue);
    }
    if (message.stringArray !== undefined) {
      StringParameterArray.encode(message.stringArray, writer.uint32(42).fork()).join();
    }
    if (message.intArray !== undefined) {
      IntParameterArray.encode(message.intArray, writer.uint32(50).fork()).join();
    }
    if (message.doubleArray !== undefined) {
      DoubleParameterArray.encode(message.doubleArray, writer.uint32(58).fork()).join();
    }
    if (message.booleanArray !== undefined) {
      BooleanParameterArray.encode(message.booleanArray, writer.uint32(66).fork()).join();
    }
    if (message.jsonValue !== undefined) {
      writer.uint32(74).string(message.jsonValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValueType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValueType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.booleanValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stringArray = StringParameterArray.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.intArray = IntParameterArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.doubleArray = DoubleParameterArray.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.booleanArray = BooleanParameterArray.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.jsonValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValueType {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      booleanValue: isSet(object.booleanValue) ? globalThis.Boolean(object.booleanValue) : undefined,
      stringArray: isSet(object.stringArray) ? StringParameterArray.fromJSON(object.stringArray) : undefined,
      intArray: isSet(object.intArray) ? IntParameterArray.fromJSON(object.intArray) : undefined,
      doubleArray: isSet(object.doubleArray) ? DoubleParameterArray.fromJSON(object.doubleArray) : undefined,
      booleanArray: isSet(object.booleanArray) ? BooleanParameterArray.fromJSON(object.booleanArray) : undefined,
      jsonValue: isSet(object.jsonValue) ? globalThis.String(object.jsonValue) : undefined,
    };
  },

  toJSON(message: ValueType): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.booleanValue !== undefined) {
      obj.booleanValue = message.booleanValue;
    }
    if (message.stringArray !== undefined) {
      obj.stringArray = StringParameterArray.toJSON(message.stringArray);
    }
    if (message.intArray !== undefined) {
      obj.intArray = IntParameterArray.toJSON(message.intArray);
    }
    if (message.doubleArray !== undefined) {
      obj.doubleArray = DoubleParameterArray.toJSON(message.doubleArray);
    }
    if (message.booleanArray !== undefined) {
      obj.booleanArray = BooleanParameterArray.toJSON(message.booleanArray);
    }
    if (message.jsonValue !== undefined) {
      obj.jsonValue = message.jsonValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ValueType>): ValueType {
    return ValueType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValueType>): ValueType {
    const message = createBaseValueType();
    message.stringValue = object.stringValue ?? undefined;
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.booleanValue = object.booleanValue ?? undefined;
    message.stringArray = (object.stringArray !== undefined && object.stringArray !== null)
      ? StringParameterArray.fromPartial(object.stringArray)
      : undefined;
    message.intArray = (object.intArray !== undefined && object.intArray !== null)
      ? IntParameterArray.fromPartial(object.intArray)
      : undefined;
    message.doubleArray = (object.doubleArray !== undefined && object.doubleArray !== null)
      ? DoubleParameterArray.fromPartial(object.doubleArray)
      : undefined;
    message.booleanArray = (object.booleanArray !== undefined && object.booleanArray !== null)
      ? BooleanParameterArray.fromPartial(object.booleanArray)
      : undefined;
    message.jsonValue = object.jsonValue ?? undefined;
    return message;
  },
};

function createBaseStringParameterArray(): StringParameterArray {
  return { stringValues: [] };
}

export const StringParameterArray: MessageFns<StringParameterArray> = {
  encode(message: StringParameterArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stringValues) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringParameterArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringParameterArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringParameterArray {
    return {
      stringValues: globalThis.Array.isArray(object?.stringValues)
        ? object.stringValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StringParameterArray): unknown {
    const obj: any = {};
    if (message.stringValues?.length) {
      obj.stringValues = message.stringValues;
    }
    return obj;
  },

  create(base?: DeepPartial<StringParameterArray>): StringParameterArray {
    return StringParameterArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringParameterArray>): StringParameterArray {
    const message = createBaseStringParameterArray();
    message.stringValues = object.stringValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntParameterArray(): IntParameterArray {
  return { intValues: [] };
}

export const IntParameterArray: MessageFns<IntParameterArray> = {
  encode(message: IntParameterArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.intValues) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntParameterArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntParameterArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.intValues.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.intValues.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntParameterArray {
    return {
      intValues: globalThis.Array.isArray(object?.intValues) ? object.intValues.map((e: any) => Long.fromValue(e)) : [],
    };
  },

  toJSON(message: IntParameterArray): unknown {
    const obj: any = {};
    if (message.intValues?.length) {
      obj.intValues = message.intValues.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(base?: DeepPartial<IntParameterArray>): IntParameterArray {
    return IntParameterArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntParameterArray>): IntParameterArray {
    const message = createBaseIntParameterArray();
    message.intValues = object.intValues?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseDoubleParameterArray(): DoubleParameterArray {
  return { doubleValues: [] };
}

export const DoubleParameterArray: MessageFns<DoubleParameterArray> = {
  encode(message: DoubleParameterArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.doubleValues) {
      writer.double(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleParameterArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleParameterArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.doubleValues.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.doubleValues.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleParameterArray {
    return {
      doubleValues: globalThis.Array.isArray(object?.doubleValues)
        ? object.doubleValues.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: DoubleParameterArray): unknown {
    const obj: any = {};
    if (message.doubleValues?.length) {
      obj.doubleValues = message.doubleValues;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleParameterArray>): DoubleParameterArray {
    return DoubleParameterArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleParameterArray>): DoubleParameterArray {
    const message = createBaseDoubleParameterArray();
    message.doubleValues = object.doubleValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseBooleanParameterArray(): BooleanParameterArray {
  return { booleanValues: [] };
}

export const BooleanParameterArray: MessageFns<BooleanParameterArray> = {
  encode(message: BooleanParameterArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.booleanValues) {
      writer.bool(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BooleanParameterArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBooleanParameterArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.booleanValues.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.booleanValues.push(reader.bool());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BooleanParameterArray {
    return {
      booleanValues: globalThis.Array.isArray(object?.booleanValues)
        ? object.booleanValues.map((e: any) => globalThis.Boolean(e))
        : [],
    };
  },

  toJSON(message: BooleanParameterArray): unknown {
    const obj: any = {};
    if (message.booleanValues?.length) {
      obj.booleanValues = message.booleanValues;
    }
    return obj;
  },

  create(base?: DeepPartial<BooleanParameterArray>): BooleanParameterArray {
    return BooleanParameterArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BooleanParameterArray>): BooleanParameterArray {
    const message = createBaseBooleanParameterArray();
    message.booleanValues = object.booleanValues?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
