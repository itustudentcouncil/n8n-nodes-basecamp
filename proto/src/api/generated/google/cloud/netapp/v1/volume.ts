// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/netapp/v1/volume.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  EncryptionType,
  encryptionTypeFromJSON,
  encryptionTypeToJSON,
  ServiceLevel,
  serviceLevelFromJSON,
  serviceLevelToJSON,
} from "./common.js";

export const protobufPackage = "google.cloud.netapp.v1";

/** Protocols is an enum of all the supported network protocols for a volume. */
export enum Protocols {
  /** PROTOCOLS_UNSPECIFIED - Unspecified protocol */
  PROTOCOLS_UNSPECIFIED = 0,
  /** NFSV3 - NFS V3 protocol */
  NFSV3 = 1,
  /** NFSV4 - NFS V4 protocol */
  NFSV4 = 2,
  /** SMB - SMB protocol */
  SMB = 3,
  UNRECOGNIZED = -1,
}

export function protocolsFromJSON(object: any): Protocols {
  switch (object) {
    case 0:
    case "PROTOCOLS_UNSPECIFIED":
      return Protocols.PROTOCOLS_UNSPECIFIED;
    case 1:
    case "NFSV3":
      return Protocols.NFSV3;
    case 2:
    case "NFSV4":
      return Protocols.NFSV4;
    case 3:
    case "SMB":
      return Protocols.SMB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Protocols.UNRECOGNIZED;
  }
}

export function protocolsToJSON(object: Protocols): string {
  switch (object) {
    case Protocols.PROTOCOLS_UNSPECIFIED:
      return "PROTOCOLS_UNSPECIFIED";
    case Protocols.NFSV3:
      return "NFSV3";
    case Protocols.NFSV4:
      return "NFSV4";
    case Protocols.SMB:
      return "SMB";
    case Protocols.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AccessType is an enum of all the supported access types for a volume. */
export enum AccessType {
  /** ACCESS_TYPE_UNSPECIFIED - Unspecified Access Type */
  ACCESS_TYPE_UNSPECIFIED = 0,
  /** READ_ONLY - Read Only */
  READ_ONLY = 1,
  /** READ_WRITE - Read Write */
  READ_WRITE = 2,
  /** READ_NONE - None */
  READ_NONE = 3,
  UNRECOGNIZED = -1,
}

export function accessTypeFromJSON(object: any): AccessType {
  switch (object) {
    case 0:
    case "ACCESS_TYPE_UNSPECIFIED":
      return AccessType.ACCESS_TYPE_UNSPECIFIED;
    case 1:
    case "READ_ONLY":
      return AccessType.READ_ONLY;
    case 2:
    case "READ_WRITE":
      return AccessType.READ_WRITE;
    case 3:
    case "READ_NONE":
      return AccessType.READ_NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessType.UNRECOGNIZED;
  }
}

export function accessTypeToJSON(object: AccessType): string {
  switch (object) {
    case AccessType.ACCESS_TYPE_UNSPECIFIED:
      return "ACCESS_TYPE_UNSPECIFIED";
    case AccessType.READ_ONLY:
      return "READ_ONLY";
    case AccessType.READ_WRITE:
      return "READ_WRITE";
    case AccessType.READ_NONE:
      return "READ_NONE";
    case AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * SMBSettings
 * Modifies the behaviour of a SMB volume.
 */
export enum SMBSettings {
  /** SMB_SETTINGS_UNSPECIFIED - Unspecified default option */
  SMB_SETTINGS_UNSPECIFIED = 0,
  /** ENCRYPT_DATA - SMB setting encrypt data */
  ENCRYPT_DATA = 1,
  /** BROWSABLE - SMB setting browsable */
  BROWSABLE = 2,
  /** CHANGE_NOTIFY - SMB setting notify change */
  CHANGE_NOTIFY = 3,
  /** NON_BROWSABLE - SMB setting not to notify change */
  NON_BROWSABLE = 4,
  /** OPLOCKS - SMB setting oplocks */
  OPLOCKS = 5,
  /** SHOW_SNAPSHOT - SMB setting to show snapshots */
  SHOW_SNAPSHOT = 6,
  /** SHOW_PREVIOUS_VERSIONS - SMB setting to show previous versions */
  SHOW_PREVIOUS_VERSIONS = 7,
  /** ACCESS_BASED_ENUMERATION - SMB setting to access volume based on enumerartion */
  ACCESS_BASED_ENUMERATION = 8,
  /** CONTINUOUSLY_AVAILABLE - Continuously available enumeration */
  CONTINUOUSLY_AVAILABLE = 9,
  UNRECOGNIZED = -1,
}

export function sMBSettingsFromJSON(object: any): SMBSettings {
  switch (object) {
    case 0:
    case "SMB_SETTINGS_UNSPECIFIED":
      return SMBSettings.SMB_SETTINGS_UNSPECIFIED;
    case 1:
    case "ENCRYPT_DATA":
      return SMBSettings.ENCRYPT_DATA;
    case 2:
    case "BROWSABLE":
      return SMBSettings.BROWSABLE;
    case 3:
    case "CHANGE_NOTIFY":
      return SMBSettings.CHANGE_NOTIFY;
    case 4:
    case "NON_BROWSABLE":
      return SMBSettings.NON_BROWSABLE;
    case 5:
    case "OPLOCKS":
      return SMBSettings.OPLOCKS;
    case 6:
    case "SHOW_SNAPSHOT":
      return SMBSettings.SHOW_SNAPSHOT;
    case 7:
    case "SHOW_PREVIOUS_VERSIONS":
      return SMBSettings.SHOW_PREVIOUS_VERSIONS;
    case 8:
    case "ACCESS_BASED_ENUMERATION":
      return SMBSettings.ACCESS_BASED_ENUMERATION;
    case 9:
    case "CONTINUOUSLY_AVAILABLE":
      return SMBSettings.CONTINUOUSLY_AVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SMBSettings.UNRECOGNIZED;
  }
}

export function sMBSettingsToJSON(object: SMBSettings): string {
  switch (object) {
    case SMBSettings.SMB_SETTINGS_UNSPECIFIED:
      return "SMB_SETTINGS_UNSPECIFIED";
    case SMBSettings.ENCRYPT_DATA:
      return "ENCRYPT_DATA";
    case SMBSettings.BROWSABLE:
      return "BROWSABLE";
    case SMBSettings.CHANGE_NOTIFY:
      return "CHANGE_NOTIFY";
    case SMBSettings.NON_BROWSABLE:
      return "NON_BROWSABLE";
    case SMBSettings.OPLOCKS:
      return "OPLOCKS";
    case SMBSettings.SHOW_SNAPSHOT:
      return "SHOW_SNAPSHOT";
    case SMBSettings.SHOW_PREVIOUS_VERSIONS:
      return "SHOW_PREVIOUS_VERSIONS";
    case SMBSettings.ACCESS_BASED_ENUMERATION:
      return "ACCESS_BASED_ENUMERATION";
    case SMBSettings.CONTINUOUSLY_AVAILABLE:
      return "CONTINUOUSLY_AVAILABLE";
    case SMBSettings.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The security style of the volume, can be either UNIX or NTFS. */
export enum SecurityStyle {
  /** SECURITY_STYLE_UNSPECIFIED - SecurityStyle is unspecified */
  SECURITY_STYLE_UNSPECIFIED = 0,
  /** NTFS - SecurityStyle uses NTFS */
  NTFS = 1,
  /** UNIX - SecurityStyle uses UNIX */
  UNIX = 2,
  UNRECOGNIZED = -1,
}

export function securityStyleFromJSON(object: any): SecurityStyle {
  switch (object) {
    case 0:
    case "SECURITY_STYLE_UNSPECIFIED":
      return SecurityStyle.SECURITY_STYLE_UNSPECIFIED;
    case 1:
    case "NTFS":
      return SecurityStyle.NTFS;
    case 2:
    case "UNIX":
      return SecurityStyle.UNIX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityStyle.UNRECOGNIZED;
  }
}

export function securityStyleToJSON(object: SecurityStyle): string {
  switch (object) {
    case SecurityStyle.SECURITY_STYLE_UNSPECIFIED:
      return "SECURITY_STYLE_UNSPECIFIED";
    case SecurityStyle.NTFS:
      return "NTFS";
    case SecurityStyle.UNIX:
      return "UNIX";
    case SecurityStyle.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Actions to be restricted for a volume. */
export enum RestrictedAction {
  /** RESTRICTED_ACTION_UNSPECIFIED - Unspecified restricted action */
  RESTRICTED_ACTION_UNSPECIFIED = 0,
  /** DELETE - Prevent volume from being deleted when mounted. */
  DELETE = 1,
  UNRECOGNIZED = -1,
}

export function restrictedActionFromJSON(object: any): RestrictedAction {
  switch (object) {
    case 0:
    case "RESTRICTED_ACTION_UNSPECIFIED":
      return RestrictedAction.RESTRICTED_ACTION_UNSPECIFIED;
    case 1:
    case "DELETE":
      return RestrictedAction.DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RestrictedAction.UNRECOGNIZED;
  }
}

export function restrictedActionToJSON(object: RestrictedAction): string {
  switch (object) {
    case RestrictedAction.RESTRICTED_ACTION_UNSPECIFIED:
      return "RESTRICTED_ACTION_UNSPECIFIED";
    case RestrictedAction.DELETE:
      return "DELETE";
    case RestrictedAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for requesting list of Volumes */
export interface ListVolumesRequest {
  /** Required. Parent value for ListVolumesRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, the server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing Volumes */
export interface ListVolumesResponse {
  /** The list of Volume */
  volumes: Volume[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a Volume */
export interface GetVolumeRequest {
  /** Required. Name of the volume */
  name: string;
}

/** Message for creating a Volume */
export interface CreateVolumeRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting volume. Must be unique within the parent
   * resource. Must contain only letters, numbers, underscore and hyphen, with
   * the first character a letter or underscore, the last a letter or underscore
   * or a number, and a 63 character maximum.
   */
  volumeId: string;
  /** Required. The volume being created. */
  volume: Volume | undefined;
}

/** Message for updating a Volume */
export interface UpdateVolumeRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Volume resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The volume being updated */
  volume: Volume | undefined;
}

/** Message for deleting a Volume */
export interface DeleteVolumeRequest {
  /** Required. Name of the volume */
  name: string;
  /**
   * If this field is set as true, CCFE will not block the volume resource
   * deletion even if it has any snapshots resource. (Otherwise, the request
   * will only work if the volume has no snapshots.)
   */
  force: boolean;
}

/** RevertVolumeRequest reverts the given volume to the specified snapshot. */
export interface RevertVolumeRequest {
  /**
   * Required. The resource name of the volume, in the format of
   * projects/{project_id}/locations/{location}/volumes/{volume_id}.
   */
  name: string;
  /**
   * Required. The snapshot resource ID, in the format 'my-snapshot', where the
   * specified ID is the {snapshot_id} of the fully qualified name like
   * projects/{project_id}/locations/{location_id}/volumes/{volume_id}/snapshots/{snapshot_id}
   */
  snapshotId: string;
}

/** Volume provides a filesystem that you can mount. */
export interface Volume {
  /** Identifier. Name of the volume */
  name: string;
  /** Output only. State of the volume */
  state: Volume_State;
  /** Output only. State details of the volume */
  stateDetails: string;
  /** Output only. Create time of the volume */
  createTime:
    | Date
    | undefined;
  /** Required. Share name of the volume */
  shareName: string;
  /**
   * Output only. This field is not implemented. The values provided in this
   * field are ignored.
   */
  psaRange: string;
  /** Required. StoragePool name of the volume */
  storagePool: string;
  /**
   * Output only. VPC Network name.
   * Format: projects/{project}/global/networks/{network}
   */
  network: string;
  /** Output only. Service level of the volume */
  serviceLevel: ServiceLevel;
  /** Required. Capacity in GIB of the volume */
  capacityGib: Long;
  /** Optional. Export policy of the volume */
  exportPolicy:
    | ExportPolicy
    | undefined;
  /** Required. Protocols required for the volume */
  protocols: Protocols[];
  /** Optional. SMB share settings for the volume. */
  smbSettings: SMBSettings[];
  /** Output only. Mount options of this volume */
  mountOptions: MountOption[];
  /**
   * Optional. Default unix style permission (e.g. 777) the mount point will be
   * created with. Applicable for NFS protocol types only.
   */
  unixPermissions: string;
  /** Optional. Labels as key value pairs */
  labels: { [key: string]: string };
  /** Optional. Description of the volume */
  description: string;
  /** Optional. SnapshotPolicy for a volume. */
  snapshotPolicy:
    | SnapshotPolicy
    | undefined;
  /**
   * Optional. Snap_reserve specifies percentage of volume storage reserved for
   * snapshot storage. Default is 0 percent.
   */
  snapReserve: number;
  /**
   * Optional. Snapshot_directory if enabled (true) the volume will contain a
   * read-only .snapshot directory which provides access to each of the volume's
   * snapshots.
   */
  snapshotDirectory: boolean;
  /**
   * Output only. Used capacity in GIB of the volume. This is computed
   * periodically and it does not represent the realtime usage.
   */
  usedGib: Long;
  /** Optional. Security Style of the Volume */
  securityStyle: SecurityStyle;
  /**
   * Optional. Flag indicating if the volume is a kerberos volume or not, export
   * policy rules control kerberos security modes (krb5, krb5i, krb5p).
   */
  kerberosEnabled: boolean;
  /** Output only. Flag indicating if the volume is NFS LDAP enabled or not. */
  ldapEnabled: boolean;
  /** Output only. Specifies the ActiveDirectory name of a SMB volume. */
  activeDirectory: string;
  /** Optional. Specifies the source of the volume to be created from. */
  restoreParameters:
    | RestoreParameters
    | undefined;
  /** Output only. Specifies the KMS config to be used for volume encryption. */
  kmsConfig: string;
  /** Output only. Specified the current volume encryption key source. */
  encryptionType: EncryptionType;
  /**
   * Output only. Indicates whether the volume is part of a replication
   * relationship.
   */
  hasReplication: boolean;
  /** BackupConfig of the volume. */
  backupConfig?:
    | BackupConfig
    | undefined;
  /** Optional. List of actions that are restricted on this volume. */
  restrictedActions: RestrictedAction[];
  /**
   * Optional. Flag indicating if the volume will be a large capacity volume or
   * a regular volume.
   */
  largeCapacity: boolean;
  /**
   * Optional. Flag indicating if the volume will have an IP address per node
   * for volumes supporting multiple IP endpoints. Only the volume with
   * large_capacity will be allowed to have multiple endpoints.
   */
  multipleEndpoints: boolean;
  /** Tiering policy for the volume. */
  tieringPolicy?:
    | TieringPolicy
    | undefined;
  /** Output only. Specifies the replica zone for regional volume. */
  replicaZone: string;
  /** Output only. Specifies the active zone for regional volume. */
  zone: string;
  /** Output only. Size of the volume cold tier data in GiB. */
  coldTierSizeGib: Long;
}

/** The volume states */
export enum Volume_State {
  /** STATE_UNSPECIFIED - Unspecified Volume State */
  STATE_UNSPECIFIED = 0,
  /** READY - Volume State is Ready */
  READY = 1,
  /** CREATING - Volume State is Creating */
  CREATING = 2,
  /** DELETING - Volume State is Deleting */
  DELETING = 3,
  /** UPDATING - Volume State is Updating */
  UPDATING = 4,
  /** RESTORING - Volume State is Restoring */
  RESTORING = 5,
  /** DISABLED - Volume State is Disabled */
  DISABLED = 6,
  /** ERROR - Volume State is Error */
  ERROR = 7,
  UNRECOGNIZED = -1,
}

export function volume_StateFromJSON(object: any): Volume_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Volume_State.STATE_UNSPECIFIED;
    case 1:
    case "READY":
      return Volume_State.READY;
    case 2:
    case "CREATING":
      return Volume_State.CREATING;
    case 3:
    case "DELETING":
      return Volume_State.DELETING;
    case 4:
    case "UPDATING":
      return Volume_State.UPDATING;
    case 5:
    case "RESTORING":
      return Volume_State.RESTORING;
    case 6:
    case "DISABLED":
      return Volume_State.DISABLED;
    case 7:
    case "ERROR":
      return Volume_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_State.UNRECOGNIZED;
  }
}

export function volume_StateToJSON(object: Volume_State): string {
  switch (object) {
    case Volume_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Volume_State.READY:
      return "READY";
    case Volume_State.CREATING:
      return "CREATING";
    case Volume_State.DELETING:
      return "DELETING";
    case Volume_State.UPDATING:
      return "UPDATING";
    case Volume_State.RESTORING:
      return "RESTORING";
    case Volume_State.DISABLED:
      return "DISABLED";
    case Volume_State.ERROR:
      return "ERROR";
    case Volume_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Volume_LabelsEntry {
  key: string;
  value: string;
}

/** Defines the export policy for the volume. */
export interface ExportPolicy {
  /** Required. List of export policy rules */
  rules: SimpleExportPolicyRule[];
}

/** An export policy rule describing various export options. */
export interface SimpleExportPolicyRule {
  /** Comma separated list of allowed clients IP addresses */
  allowedClients?:
    | string
    | undefined;
  /** Whether Unix root access will be granted. */
  hasRootAccess?:
    | string
    | undefined;
  /** Access type (ReadWrite, ReadOnly, None) */
  accessType?:
    | AccessType
    | undefined;
  /** NFS V3 protocol. */
  nfsv3?:
    | boolean
    | undefined;
  /** NFS V4 protocol. */
  nfsv4?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines a read only access for clients matching
   * the 'allowedClients' specification. It enables nfs clients to mount using
   * 'authentication' kerberos security mode.
   */
  kerberos5ReadOnly?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines read and write access for clients
   * matching the 'allowedClients' specification. It enables nfs clients to
   * mount using 'authentication' kerberos security mode. The
   * 'kerberos5ReadOnly' value be ignored if this is enabled.
   */
  kerberos5ReadWrite?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines a read only access for clients matching
   * the 'allowedClients' specification. It enables nfs clients to mount using
   * 'integrity' kerberos security mode.
   */
  kerberos5iReadOnly?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines read and write access for clients
   * matching the 'allowedClients' specification. It enables nfs clients to
   * mount using 'integrity' kerberos security mode. The 'kerberos5iReadOnly'
   * value be ignored if this is enabled.
   */
  kerberos5iReadWrite?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines a read only access for clients matching
   * the 'allowedClients' specification. It enables nfs clients to mount using
   * 'privacy' kerberos security mode.
   */
  kerberos5pReadOnly?:
    | boolean
    | undefined;
  /**
   * If enabled (true) the rule defines read and write access for clients
   * matching the 'allowedClients' specification. It enables nfs clients to
   * mount using 'privacy' kerberos security mode. The 'kerberos5pReadOnly'
   * value be ignored if this is enabled.
   */
  kerberos5pReadWrite?: boolean | undefined;
}

/** Snapshot Policy for a volume. */
export interface SnapshotPolicy {
  /**
   * If enabled, make snapshots automatically according to the schedules.
   * Default is false.
   */
  enabled?:
    | boolean
    | undefined;
  /** Hourly schedule policy. */
  hourlySchedule?:
    | HourlySchedule
    | undefined;
  /** Daily schedule policy. */
  dailySchedule?:
    | DailySchedule
    | undefined;
  /** Weekly schedule policy. */
  weeklySchedule?:
    | WeeklySchedule
    | undefined;
  /** Monthly schedule policy. */
  monthlySchedule?: MonthlySchedule | undefined;
}

/** Make a snapshot every hour e.g. at 04:00, 05:00, 06:00. */
export interface HourlySchedule {
  /** The maximum number of Snapshots to keep for the hourly schedule */
  snapshotsToKeep?:
    | number
    | undefined;
  /**
   * Set the minute of the hour to start the snapshot (0-59), defaults to the
   * top of the hour (0).
   */
  minute?: number | undefined;
}

/** Make a snapshot every day e.g. at 04:00, 05:20, 23:50 */
export interface DailySchedule {
  /** The maximum number of Snapshots to keep for the hourly schedule */
  snapshotsToKeep?:
    | number
    | undefined;
  /**
   * Set the minute of the hour to start the snapshot (0-59), defaults to the
   * top of the hour (0).
   */
  minute?:
    | number
    | undefined;
  /** Set the hour to start the snapshot (0-23), defaults to midnight (0). */
  hour?: number | undefined;
}

/**
 * Make a snapshot every week e.g. at Monday 04:00, Wednesday 05:20, Sunday
 * 23:50
 */
export interface WeeklySchedule {
  /** The maximum number of Snapshots to keep for the hourly schedule */
  snapshotsToKeep?:
    | number
    | undefined;
  /**
   * Set the minute of the hour to start the snapshot (0-59), defaults to the
   * top of the hour (0).
   */
  minute?:
    | number
    | undefined;
  /** Set the hour to start the snapshot (0-23), defaults to midnight (0). */
  hour?:
    | number
    | undefined;
  /**
   * Set the day or days of the week to make a snapshot. Accepts a comma
   * separated days of the week. Defaults to 'Sunday'.
   */
  day?: string | undefined;
}

/** Make a snapshot once a month e.g. at 2nd 04:00, 7th 05:20, 24th 23:50 */
export interface MonthlySchedule {
  /** The maximum number of Snapshots to keep for the hourly schedule */
  snapshotsToKeep?:
    | number
    | undefined;
  /**
   * Set the minute of the hour to start the snapshot (0-59), defaults to the
   * top of the hour (0).
   */
  minute?:
    | number
    | undefined;
  /** Set the hour to start the snapshot (0-23), defaults to midnight (0). */
  hour?:
    | number
    | undefined;
  /**
   * Set the day or days of the month to make a snapshot (1-31). Accepts a
   * comma separated number of days. Defaults to '1'.
   */
  daysOfMonth?: string | undefined;
}

/** View only mount options for a volume. */
export interface MountOption {
  /** Export string */
  export: string;
  /** Full export string */
  exportFull: string;
  /** Protocol to mount with. */
  protocol: Protocols;
  /** Instructions for mounting */
  instructions: string;
}

/** The RestoreParameters if volume is created from a snapshot or backup. */
export interface RestoreParameters {
  /**
   * Full name of the snapshot resource.
   * Format:
   * projects/{project}/locations/{location}/volumes/{volume}/snapshots/{snapshot}
   */
  sourceSnapshot?:
    | string
    | undefined;
  /**
   * Full name of the backup resource.
   * Format:
   * projects/{project}/locations/{location}/backupVaults/{backup_vault_id}/backups/{backup_id}
   */
  sourceBackup?: string | undefined;
}

/** BackupConfig contains backup related config on a volume. */
export interface BackupConfig {
  /**
   * Optional. When specified, schedule backups will be created based on the
   * policy configuration.
   */
  backupPolicies: string[];
  /**
   * Optional. Name of backup vault.
   * Format:
   * projects/{project_id}/locations/{location}/backupVaults/{backup_vault_id}
   */
  backupVault: string;
  /**
   * Optional. When set to true, scheduled backup is enabled on the volume.
   * This field should be nil when there's no backup policy attached.
   */
  scheduledBackupEnabled?:
    | boolean
    | undefined;
  /**
   * Output only. Total size of all backups in a chain in bytes = baseline
   * backup size + sum(incremental backup size).
   */
  backupChainBytes?: Long | undefined;
}

/** Defines tiering policy for the volume. */
export interface TieringPolicy {
  /**
   * Optional. Flag indicating if the volume has tiering policy enable/pause.
   * Default is PAUSED.
   */
  tierAction?:
    | TieringPolicy_TierAction
    | undefined;
  /**
   * Optional. Time in days to mark the volume's data block as cold and make it
   * eligible for tiering, can be range from 7-183. Default is 31.
   */
  coolingThresholdDays?: number | undefined;
}

/** Tier action for the volume. */
export enum TieringPolicy_TierAction {
  /** TIER_ACTION_UNSPECIFIED - Unspecified. */
  TIER_ACTION_UNSPECIFIED = 0,
  /** ENABLED - When tiering is enabled, new cold data will be tiered. */
  ENABLED = 1,
  /**
   * PAUSED - When paused, tiering won't be performed on new data. Existing data stays
   * tiered until accessed.
   */
  PAUSED = 2,
  UNRECOGNIZED = -1,
}

export function tieringPolicy_TierActionFromJSON(object: any): TieringPolicy_TierAction {
  switch (object) {
    case 0:
    case "TIER_ACTION_UNSPECIFIED":
      return TieringPolicy_TierAction.TIER_ACTION_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return TieringPolicy_TierAction.ENABLED;
    case 2:
    case "PAUSED":
      return TieringPolicy_TierAction.PAUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TieringPolicy_TierAction.UNRECOGNIZED;
  }
}

export function tieringPolicy_TierActionToJSON(object: TieringPolicy_TierAction): string {
  switch (object) {
    case TieringPolicy_TierAction.TIER_ACTION_UNSPECIFIED:
      return "TIER_ACTION_UNSPECIFIED";
    case TieringPolicy_TierAction.ENABLED:
      return "ENABLED";
    case TieringPolicy_TierAction.PAUSED:
      return "PAUSED";
    case TieringPolicy_TierAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseListVolumesRequest(): ListVolumesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListVolumesRequest: MessageFns<ListVolumesRequest> = {
  encode(message: ListVolumesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListVolumesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVolumesRequest>): ListVolumesRequest {
    return ListVolumesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVolumesRequest>): ListVolumesRequest {
    const message = createBaseListVolumesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListVolumesResponse(): ListVolumesResponse {
  return { volumes: [], nextPageToken: "", unreachable: [] };
}

export const ListVolumesResponse: MessageFns<ListVolumesResponse> = {
  encode(message: ListVolumesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumesResponse {
    return {
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListVolumesResponse): unknown {
    const obj: any = {};
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVolumesResponse>): ListVolumesResponse {
    return ListVolumesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVolumesResponse>): ListVolumesResponse {
    const message = createBaseListVolumesResponse();
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetVolumeRequest(): GetVolumeRequest {
  return { name: "" };
}

export const GetVolumeRequest: MessageFns<GetVolumeRequest> = {
  encode(message: GetVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVolumeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVolumeRequest>): GetVolumeRequest {
    return GetVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVolumeRequest>): GetVolumeRequest {
    const message = createBaseGetVolumeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateVolumeRequest(): CreateVolumeRequest {
  return { parent: "", volumeId: "", volume: undefined };
}

export const CreateVolumeRequest: MessageFns<CreateVolumeRequest> = {
  encode(message: CreateVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.volumeId !== "") {
      writer.uint32(18).string(message.volumeId);
    }
    if (message.volume !== undefined) {
      Volume.encode(message.volume, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.volumeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.volume = Volume.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVolumeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      volumeId: isSet(object.volumeId) ? globalThis.String(object.volumeId) : "",
      volume: isSet(object.volume) ? Volume.fromJSON(object.volume) : undefined,
    };
  },

  toJSON(message: CreateVolumeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.volumeId !== "") {
      obj.volumeId = message.volumeId;
    }
    if (message.volume !== undefined) {
      obj.volume = Volume.toJSON(message.volume);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVolumeRequest>): CreateVolumeRequest {
    return CreateVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVolumeRequest>): CreateVolumeRequest {
    const message = createBaseCreateVolumeRequest();
    message.parent = object.parent ?? "";
    message.volumeId = object.volumeId ?? "";
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Volume.fromPartial(object.volume)
      : undefined;
    return message;
  },
};

function createBaseUpdateVolumeRequest(): UpdateVolumeRequest {
  return { updateMask: undefined, volume: undefined };
}

export const UpdateVolumeRequest: MessageFns<UpdateVolumeRequest> = {
  encode(message: UpdateVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.volume !== undefined) {
      Volume.encode(message.volume, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.volume = Volume.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVolumeRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      volume: isSet(object.volume) ? Volume.fromJSON(object.volume) : undefined,
    };
  },

  toJSON(message: UpdateVolumeRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.volume !== undefined) {
      obj.volume = Volume.toJSON(message.volume);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVolumeRequest>): UpdateVolumeRequest {
    return UpdateVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVolumeRequest>): UpdateVolumeRequest {
    const message = createBaseUpdateVolumeRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Volume.fromPartial(object.volume)
      : undefined;
    return message;
  },
};

function createBaseDeleteVolumeRequest(): DeleteVolumeRequest {
  return { name: "", force: false };
}

export const DeleteVolumeRequest: MessageFns<DeleteVolumeRequest> = {
  encode(message: DeleteVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVolumeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteVolumeRequest>): DeleteVolumeRequest {
    return DeleteVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteVolumeRequest>): DeleteVolumeRequest {
    const message = createBaseDeleteVolumeRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseRevertVolumeRequest(): RevertVolumeRequest {
  return { name: "", snapshotId: "" };
}

export const RevertVolumeRequest: MessageFns<RevertVolumeRequest> = {
  encode(message: RevertVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.snapshotId !== "") {
      writer.uint32(18).string(message.snapshotId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevertVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevertVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevertVolumeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
    };
  },

  toJSON(message: RevertVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    return obj;
  },

  create(base?: DeepPartial<RevertVolumeRequest>): RevertVolumeRequest {
    return RevertVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevertVolumeRequest>): RevertVolumeRequest {
    const message = createBaseRevertVolumeRequest();
    message.name = object.name ?? "";
    message.snapshotId = object.snapshotId ?? "";
    return message;
  },
};

function createBaseVolume(): Volume {
  return {
    name: "",
    state: 0,
    stateDetails: "",
    createTime: undefined,
    shareName: "",
    psaRange: "",
    storagePool: "",
    network: "",
    serviceLevel: 0,
    capacityGib: Long.ZERO,
    exportPolicy: undefined,
    protocols: [],
    smbSettings: [],
    mountOptions: [],
    unixPermissions: "",
    labels: {},
    description: "",
    snapshotPolicy: undefined,
    snapReserve: 0,
    snapshotDirectory: false,
    usedGib: Long.ZERO,
    securityStyle: 0,
    kerberosEnabled: false,
    ldapEnabled: false,
    activeDirectory: "",
    restoreParameters: undefined,
    kmsConfig: "",
    encryptionType: 0,
    hasReplication: false,
    backupConfig: undefined,
    restrictedActions: [],
    largeCapacity: false,
    multipleEndpoints: false,
    tieringPolicy: undefined,
    replicaZone: "",
    zone: "",
    coldTierSizeGib: Long.ZERO,
  };
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.stateDetails !== "") {
      writer.uint32(26).string(message.stateDetails);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.shareName !== "") {
      writer.uint32(42).string(message.shareName);
    }
    if (message.psaRange !== "") {
      writer.uint32(50).string(message.psaRange);
    }
    if (message.storagePool !== "") {
      writer.uint32(58).string(message.storagePool);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    if (message.serviceLevel !== 0) {
      writer.uint32(72).int32(message.serviceLevel);
    }
    if (!message.capacityGib.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.capacityGib.toString());
    }
    if (message.exportPolicy !== undefined) {
      ExportPolicy.encode(message.exportPolicy, writer.uint32(90).fork()).join();
    }
    writer.uint32(98).fork();
    for (const v of message.protocols) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(106).fork();
    for (const v of message.smbSettings) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.mountOptions) {
      MountOption.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.unixPermissions !== "") {
      writer.uint32(122).string(message.unixPermissions);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Volume_LabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(138).string(message.description);
    }
    if (message.snapshotPolicy !== undefined) {
      SnapshotPolicy.encode(message.snapshotPolicy, writer.uint32(146).fork()).join();
    }
    if (message.snapReserve !== 0) {
      writer.uint32(153).double(message.snapReserve);
    }
    if (message.snapshotDirectory !== false) {
      writer.uint32(160).bool(message.snapshotDirectory);
    }
    if (!message.usedGib.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.usedGib.toString());
    }
    if (message.securityStyle !== 0) {
      writer.uint32(176).int32(message.securityStyle);
    }
    if (message.kerberosEnabled !== false) {
      writer.uint32(184).bool(message.kerberosEnabled);
    }
    if (message.ldapEnabled !== false) {
      writer.uint32(192).bool(message.ldapEnabled);
    }
    if (message.activeDirectory !== "") {
      writer.uint32(202).string(message.activeDirectory);
    }
    if (message.restoreParameters !== undefined) {
      RestoreParameters.encode(message.restoreParameters, writer.uint32(210).fork()).join();
    }
    if (message.kmsConfig !== "") {
      writer.uint32(218).string(message.kmsConfig);
    }
    if (message.encryptionType !== 0) {
      writer.uint32(224).int32(message.encryptionType);
    }
    if (message.hasReplication !== false) {
      writer.uint32(232).bool(message.hasReplication);
    }
    if (message.backupConfig !== undefined) {
      BackupConfig.encode(message.backupConfig, writer.uint32(242).fork()).join();
    }
    writer.uint32(250).fork();
    for (const v of message.restrictedActions) {
      writer.int32(v);
    }
    writer.join();
    if (message.largeCapacity !== false) {
      writer.uint32(256).bool(message.largeCapacity);
    }
    if (message.multipleEndpoints !== false) {
      writer.uint32(264).bool(message.multipleEndpoints);
    }
    if (message.tieringPolicy !== undefined) {
      TieringPolicy.encode(message.tieringPolicy, writer.uint32(274).fork()).join();
    }
    if (message.replicaZone !== "") {
      writer.uint32(290).string(message.replicaZone);
    }
    if (message.zone !== "") {
      writer.uint32(298).string(message.zone);
    }
    if (!message.coldTierSizeGib.equals(Long.ZERO)) {
      writer.uint32(312).int64(message.coldTierSizeGib.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateDetails = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.shareName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.psaRange = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.storagePool = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.serviceLevel = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.capacityGib = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.exportPolicy = ExportPolicy.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag === 96) {
            message.protocols.push(reader.int32() as any);

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.protocols.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 13:
          if (tag === 104) {
            message.smbSettings.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.smbSettings.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.mountOptions.push(MountOption.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.unixPermissions = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = Volume_LabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.labels[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.description = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.snapshotPolicy = SnapshotPolicy.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 153) {
            break;
          }

          message.snapReserve = reader.double();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.snapshotDirectory = reader.bool();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.usedGib = Long.fromString(reader.int64().toString());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.securityStyle = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.kerberosEnabled = reader.bool();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.ldapEnabled = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.activeDirectory = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.restoreParameters = RestoreParameters.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.kmsConfig = reader.string();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.encryptionType = reader.int32() as any;
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.hasReplication = reader.bool();
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.backupConfig = BackupConfig.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag === 248) {
            message.restrictedActions.push(reader.int32() as any);

            continue;
          }

          if (tag === 250) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.restrictedActions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.largeCapacity = reader.bool();
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.multipleEndpoints = reader.bool();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.tieringPolicy = TieringPolicy.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.replicaZone = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.coldTierSizeGib = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? volume_StateFromJSON(object.state) : 0,
      stateDetails: isSet(object.stateDetails) ? globalThis.String(object.stateDetails) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      shareName: isSet(object.shareName) ? globalThis.String(object.shareName) : "",
      psaRange: isSet(object.psaRange) ? globalThis.String(object.psaRange) : "",
      storagePool: isSet(object.storagePool) ? globalThis.String(object.storagePool) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      serviceLevel: isSet(object.serviceLevel) ? serviceLevelFromJSON(object.serviceLevel) : 0,
      capacityGib: isSet(object.capacityGib) ? Long.fromValue(object.capacityGib) : Long.ZERO,
      exportPolicy: isSet(object.exportPolicy) ? ExportPolicy.fromJSON(object.exportPolicy) : undefined,
      protocols: globalThis.Array.isArray(object?.protocols)
        ? object.protocols.map((e: any) => protocolsFromJSON(e))
        : [],
      smbSettings: globalThis.Array.isArray(object?.smbSettings)
        ? object.smbSettings.map((e: any) => sMBSettingsFromJSON(e))
        : [],
      mountOptions: globalThis.Array.isArray(object?.mountOptions)
        ? object.mountOptions.map((e: any) => MountOption.fromJSON(e))
        : [],
      unixPermissions: isSet(object.unixPermissions) ? globalThis.String(object.unixPermissions) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      snapshotPolicy: isSet(object.snapshotPolicy) ? SnapshotPolicy.fromJSON(object.snapshotPolicy) : undefined,
      snapReserve: isSet(object.snapReserve) ? globalThis.Number(object.snapReserve) : 0,
      snapshotDirectory: isSet(object.snapshotDirectory) ? globalThis.Boolean(object.snapshotDirectory) : false,
      usedGib: isSet(object.usedGib) ? Long.fromValue(object.usedGib) : Long.ZERO,
      securityStyle: isSet(object.securityStyle) ? securityStyleFromJSON(object.securityStyle) : 0,
      kerberosEnabled: isSet(object.kerberosEnabled) ? globalThis.Boolean(object.kerberosEnabled) : false,
      ldapEnabled: isSet(object.ldapEnabled) ? globalThis.Boolean(object.ldapEnabled) : false,
      activeDirectory: isSet(object.activeDirectory) ? globalThis.String(object.activeDirectory) : "",
      restoreParameters: isSet(object.restoreParameters)
        ? RestoreParameters.fromJSON(object.restoreParameters)
        : undefined,
      kmsConfig: isSet(object.kmsConfig) ? globalThis.String(object.kmsConfig) : "",
      encryptionType: isSet(object.encryptionType) ? encryptionTypeFromJSON(object.encryptionType) : 0,
      hasReplication: isSet(object.hasReplication) ? globalThis.Boolean(object.hasReplication) : false,
      backupConfig: isSet(object.backupConfig) ? BackupConfig.fromJSON(object.backupConfig) : undefined,
      restrictedActions: globalThis.Array.isArray(object?.restrictedActions)
        ? object.restrictedActions.map((e: any) => restrictedActionFromJSON(e))
        : [],
      largeCapacity: isSet(object.largeCapacity) ? globalThis.Boolean(object.largeCapacity) : false,
      multipleEndpoints: isSet(object.multipleEndpoints) ? globalThis.Boolean(object.multipleEndpoints) : false,
      tieringPolicy: isSet(object.tieringPolicy) ? TieringPolicy.fromJSON(object.tieringPolicy) : undefined,
      replicaZone: isSet(object.replicaZone) ? globalThis.String(object.replicaZone) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      coldTierSizeGib: isSet(object.coldTierSizeGib) ? Long.fromValue(object.coldTierSizeGib) : Long.ZERO,
    };
  },

  toJSON(message: Volume): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = volume_StateToJSON(message.state);
    }
    if (message.stateDetails !== "") {
      obj.stateDetails = message.stateDetails;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.shareName !== "") {
      obj.shareName = message.shareName;
    }
    if (message.psaRange !== "") {
      obj.psaRange = message.psaRange;
    }
    if (message.storagePool !== "") {
      obj.storagePool = message.storagePool;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.serviceLevel !== 0) {
      obj.serviceLevel = serviceLevelToJSON(message.serviceLevel);
    }
    if (!message.capacityGib.equals(Long.ZERO)) {
      obj.capacityGib = (message.capacityGib || Long.ZERO).toString();
    }
    if (message.exportPolicy !== undefined) {
      obj.exportPolicy = ExportPolicy.toJSON(message.exportPolicy);
    }
    if (message.protocols?.length) {
      obj.protocols = message.protocols.map((e) => protocolsToJSON(e));
    }
    if (message.smbSettings?.length) {
      obj.smbSettings = message.smbSettings.map((e) => sMBSettingsToJSON(e));
    }
    if (message.mountOptions?.length) {
      obj.mountOptions = message.mountOptions.map((e) => MountOption.toJSON(e));
    }
    if (message.unixPermissions !== "") {
      obj.unixPermissions = message.unixPermissions;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.snapshotPolicy !== undefined) {
      obj.snapshotPolicy = SnapshotPolicy.toJSON(message.snapshotPolicy);
    }
    if (message.snapReserve !== 0) {
      obj.snapReserve = message.snapReserve;
    }
    if (message.snapshotDirectory !== false) {
      obj.snapshotDirectory = message.snapshotDirectory;
    }
    if (!message.usedGib.equals(Long.ZERO)) {
      obj.usedGib = (message.usedGib || Long.ZERO).toString();
    }
    if (message.securityStyle !== 0) {
      obj.securityStyle = securityStyleToJSON(message.securityStyle);
    }
    if (message.kerberosEnabled !== false) {
      obj.kerberosEnabled = message.kerberosEnabled;
    }
    if (message.ldapEnabled !== false) {
      obj.ldapEnabled = message.ldapEnabled;
    }
    if (message.activeDirectory !== "") {
      obj.activeDirectory = message.activeDirectory;
    }
    if (message.restoreParameters !== undefined) {
      obj.restoreParameters = RestoreParameters.toJSON(message.restoreParameters);
    }
    if (message.kmsConfig !== "") {
      obj.kmsConfig = message.kmsConfig;
    }
    if (message.encryptionType !== 0) {
      obj.encryptionType = encryptionTypeToJSON(message.encryptionType);
    }
    if (message.hasReplication !== false) {
      obj.hasReplication = message.hasReplication;
    }
    if (message.backupConfig !== undefined) {
      obj.backupConfig = BackupConfig.toJSON(message.backupConfig);
    }
    if (message.restrictedActions?.length) {
      obj.restrictedActions = message.restrictedActions.map((e) => restrictedActionToJSON(e));
    }
    if (message.largeCapacity !== false) {
      obj.largeCapacity = message.largeCapacity;
    }
    if (message.multipleEndpoints !== false) {
      obj.multipleEndpoints = message.multipleEndpoints;
    }
    if (message.tieringPolicy !== undefined) {
      obj.tieringPolicy = TieringPolicy.toJSON(message.tieringPolicy);
    }
    if (message.replicaZone !== "") {
      obj.replicaZone = message.replicaZone;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (!message.coldTierSizeGib.equals(Long.ZERO)) {
      obj.coldTierSizeGib = (message.coldTierSizeGib || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Volume>): Volume {
    return Volume.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume>): Volume {
    const message = createBaseVolume();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.stateDetails = object.stateDetails ?? "";
    message.createTime = object.createTime ?? undefined;
    message.shareName = object.shareName ?? "";
    message.psaRange = object.psaRange ?? "";
    message.storagePool = object.storagePool ?? "";
    message.network = object.network ?? "";
    message.serviceLevel = object.serviceLevel ?? 0;
    message.capacityGib = (object.capacityGib !== undefined && object.capacityGib !== null)
      ? Long.fromValue(object.capacityGib)
      : Long.ZERO;
    message.exportPolicy = (object.exportPolicy !== undefined && object.exportPolicy !== null)
      ? ExportPolicy.fromPartial(object.exportPolicy)
      : undefined;
    message.protocols = object.protocols?.map((e) => e) || [];
    message.smbSettings = object.smbSettings?.map((e) => e) || [];
    message.mountOptions = object.mountOptions?.map((e) => MountOption.fromPartial(e)) || [];
    message.unixPermissions = object.unixPermissions ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.snapshotPolicy = (object.snapshotPolicy !== undefined && object.snapshotPolicy !== null)
      ? SnapshotPolicy.fromPartial(object.snapshotPolicy)
      : undefined;
    message.snapReserve = object.snapReserve ?? 0;
    message.snapshotDirectory = object.snapshotDirectory ?? false;
    message.usedGib = (object.usedGib !== undefined && object.usedGib !== null)
      ? Long.fromValue(object.usedGib)
      : Long.ZERO;
    message.securityStyle = object.securityStyle ?? 0;
    message.kerberosEnabled = object.kerberosEnabled ?? false;
    message.ldapEnabled = object.ldapEnabled ?? false;
    message.activeDirectory = object.activeDirectory ?? "";
    message.restoreParameters = (object.restoreParameters !== undefined && object.restoreParameters !== null)
      ? RestoreParameters.fromPartial(object.restoreParameters)
      : undefined;
    message.kmsConfig = object.kmsConfig ?? "";
    message.encryptionType = object.encryptionType ?? 0;
    message.hasReplication = object.hasReplication ?? false;
    message.backupConfig = (object.backupConfig !== undefined && object.backupConfig !== null)
      ? BackupConfig.fromPartial(object.backupConfig)
      : undefined;
    message.restrictedActions = object.restrictedActions?.map((e) => e) || [];
    message.largeCapacity = object.largeCapacity ?? false;
    message.multipleEndpoints = object.multipleEndpoints ?? false;
    message.tieringPolicy = (object.tieringPolicy !== undefined && object.tieringPolicy !== null)
      ? TieringPolicy.fromPartial(object.tieringPolicy)
      : undefined;
    message.replicaZone = object.replicaZone ?? "";
    message.zone = object.zone ?? "";
    message.coldTierSizeGib = (object.coldTierSizeGib !== undefined && object.coldTierSizeGib !== null)
      ? Long.fromValue(object.coldTierSizeGib)
      : Long.ZERO;
    return message;
  },
};

function createBaseVolume_LabelsEntry(): Volume_LabelsEntry {
  return { key: "", value: "" };
}

export const Volume_LabelsEntry: MessageFns<Volume_LabelsEntry> = {
  encode(message: Volume_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Volume_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Volume_LabelsEntry>): Volume_LabelsEntry {
    return Volume_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume_LabelsEntry>): Volume_LabelsEntry {
    const message = createBaseVolume_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExportPolicy(): ExportPolicy {
  return { rules: [] };
}

export const ExportPolicy: MessageFns<ExportPolicy> = {
  encode(message: ExportPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      SimpleExportPolicyRule.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(SimpleExportPolicyRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportPolicy {
    return {
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => SimpleExportPolicyRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExportPolicy): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => SimpleExportPolicyRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExportPolicy>): ExportPolicy {
    return ExportPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportPolicy>): ExportPolicy {
    const message = createBaseExportPolicy();
    message.rules = object.rules?.map((e) => SimpleExportPolicyRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSimpleExportPolicyRule(): SimpleExportPolicyRule {
  return {
    allowedClients: undefined,
    hasRootAccess: undefined,
    accessType: undefined,
    nfsv3: undefined,
    nfsv4: undefined,
    kerberos5ReadOnly: undefined,
    kerberos5ReadWrite: undefined,
    kerberos5iReadOnly: undefined,
    kerberos5iReadWrite: undefined,
    kerberos5pReadOnly: undefined,
    kerberos5pReadWrite: undefined,
  };
}

export const SimpleExportPolicyRule: MessageFns<SimpleExportPolicyRule> = {
  encode(message: SimpleExportPolicyRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowedClients !== undefined) {
      writer.uint32(10).string(message.allowedClients);
    }
    if (message.hasRootAccess !== undefined) {
      writer.uint32(18).string(message.hasRootAccess);
    }
    if (message.accessType !== undefined) {
      writer.uint32(24).int32(message.accessType);
    }
    if (message.nfsv3 !== undefined) {
      writer.uint32(32).bool(message.nfsv3);
    }
    if (message.nfsv4 !== undefined) {
      writer.uint32(40).bool(message.nfsv4);
    }
    if (message.kerberos5ReadOnly !== undefined) {
      writer.uint32(48).bool(message.kerberos5ReadOnly);
    }
    if (message.kerberos5ReadWrite !== undefined) {
      writer.uint32(56).bool(message.kerberos5ReadWrite);
    }
    if (message.kerberos5iReadOnly !== undefined) {
      writer.uint32(64).bool(message.kerberos5iReadOnly);
    }
    if (message.kerberos5iReadWrite !== undefined) {
      writer.uint32(72).bool(message.kerberos5iReadWrite);
    }
    if (message.kerberos5pReadOnly !== undefined) {
      writer.uint32(80).bool(message.kerberos5pReadOnly);
    }
    if (message.kerberos5pReadWrite !== undefined) {
      writer.uint32(88).bool(message.kerberos5pReadWrite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleExportPolicyRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleExportPolicyRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedClients = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hasRootAccess = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accessType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nfsv3 = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nfsv4 = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.kerberos5ReadOnly = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.kerberos5ReadWrite = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.kerberos5iReadOnly = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.kerberos5iReadWrite = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.kerberos5pReadOnly = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.kerberos5pReadWrite = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleExportPolicyRule {
    return {
      allowedClients: isSet(object.allowedClients) ? globalThis.String(object.allowedClients) : undefined,
      hasRootAccess: isSet(object.hasRootAccess) ? globalThis.String(object.hasRootAccess) : undefined,
      accessType: isSet(object.accessType) ? accessTypeFromJSON(object.accessType) : undefined,
      nfsv3: isSet(object.nfsv3) ? globalThis.Boolean(object.nfsv3) : undefined,
      nfsv4: isSet(object.nfsv4) ? globalThis.Boolean(object.nfsv4) : undefined,
      kerberos5ReadOnly: isSet(object.kerberos5ReadOnly) ? globalThis.Boolean(object.kerberos5ReadOnly) : undefined,
      kerberos5ReadWrite: isSet(object.kerberos5ReadWrite) ? globalThis.Boolean(object.kerberos5ReadWrite) : undefined,
      kerberos5iReadOnly: isSet(object.kerberos5iReadOnly) ? globalThis.Boolean(object.kerberos5iReadOnly) : undefined,
      kerberos5iReadWrite: isSet(object.kerberos5iReadWrite)
        ? globalThis.Boolean(object.kerberos5iReadWrite)
        : undefined,
      kerberos5pReadOnly: isSet(object.kerberos5pReadOnly) ? globalThis.Boolean(object.kerberos5pReadOnly) : undefined,
      kerberos5pReadWrite: isSet(object.kerberos5pReadWrite)
        ? globalThis.Boolean(object.kerberos5pReadWrite)
        : undefined,
    };
  },

  toJSON(message: SimpleExportPolicyRule): unknown {
    const obj: any = {};
    if (message.allowedClients !== undefined) {
      obj.allowedClients = message.allowedClients;
    }
    if (message.hasRootAccess !== undefined) {
      obj.hasRootAccess = message.hasRootAccess;
    }
    if (message.accessType !== undefined) {
      obj.accessType = accessTypeToJSON(message.accessType);
    }
    if (message.nfsv3 !== undefined) {
      obj.nfsv3 = message.nfsv3;
    }
    if (message.nfsv4 !== undefined) {
      obj.nfsv4 = message.nfsv4;
    }
    if (message.kerberos5ReadOnly !== undefined) {
      obj.kerberos5ReadOnly = message.kerberos5ReadOnly;
    }
    if (message.kerberos5ReadWrite !== undefined) {
      obj.kerberos5ReadWrite = message.kerberos5ReadWrite;
    }
    if (message.kerberos5iReadOnly !== undefined) {
      obj.kerberos5iReadOnly = message.kerberos5iReadOnly;
    }
    if (message.kerberos5iReadWrite !== undefined) {
      obj.kerberos5iReadWrite = message.kerberos5iReadWrite;
    }
    if (message.kerberos5pReadOnly !== undefined) {
      obj.kerberos5pReadOnly = message.kerberos5pReadOnly;
    }
    if (message.kerberos5pReadWrite !== undefined) {
      obj.kerberos5pReadWrite = message.kerberos5pReadWrite;
    }
    return obj;
  },

  create(base?: DeepPartial<SimpleExportPolicyRule>): SimpleExportPolicyRule {
    return SimpleExportPolicyRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SimpleExportPolicyRule>): SimpleExportPolicyRule {
    const message = createBaseSimpleExportPolicyRule();
    message.allowedClients = object.allowedClients ?? undefined;
    message.hasRootAccess = object.hasRootAccess ?? undefined;
    message.accessType = object.accessType ?? undefined;
    message.nfsv3 = object.nfsv3 ?? undefined;
    message.nfsv4 = object.nfsv4 ?? undefined;
    message.kerberos5ReadOnly = object.kerberos5ReadOnly ?? undefined;
    message.kerberos5ReadWrite = object.kerberos5ReadWrite ?? undefined;
    message.kerberos5iReadOnly = object.kerberos5iReadOnly ?? undefined;
    message.kerberos5iReadWrite = object.kerberos5iReadWrite ?? undefined;
    message.kerberos5pReadOnly = object.kerberos5pReadOnly ?? undefined;
    message.kerberos5pReadWrite = object.kerberos5pReadWrite ?? undefined;
    return message;
  },
};

function createBaseSnapshotPolicy(): SnapshotPolicy {
  return {
    enabled: undefined,
    hourlySchedule: undefined,
    dailySchedule: undefined,
    weeklySchedule: undefined,
    monthlySchedule: undefined,
  };
}

export const SnapshotPolicy: MessageFns<SnapshotPolicy> = {
  encode(message: SnapshotPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== undefined) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.hourlySchedule !== undefined) {
      HourlySchedule.encode(message.hourlySchedule, writer.uint32(18).fork()).join();
    }
    if (message.dailySchedule !== undefined) {
      DailySchedule.encode(message.dailySchedule, writer.uint32(26).fork()).join();
    }
    if (message.weeklySchedule !== undefined) {
      WeeklySchedule.encode(message.weeklySchedule, writer.uint32(34).fork()).join();
    }
    if (message.monthlySchedule !== undefined) {
      MonthlySchedule.encode(message.monthlySchedule, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapshotPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hourlySchedule = HourlySchedule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dailySchedule = DailySchedule.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.weeklySchedule = WeeklySchedule.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.monthlySchedule = MonthlySchedule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotPolicy {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : undefined,
      hourlySchedule: isSet(object.hourlySchedule) ? HourlySchedule.fromJSON(object.hourlySchedule) : undefined,
      dailySchedule: isSet(object.dailySchedule) ? DailySchedule.fromJSON(object.dailySchedule) : undefined,
      weeklySchedule: isSet(object.weeklySchedule) ? WeeklySchedule.fromJSON(object.weeklySchedule) : undefined,
      monthlySchedule: isSet(object.monthlySchedule) ? MonthlySchedule.fromJSON(object.monthlySchedule) : undefined,
    };
  },

  toJSON(message: SnapshotPolicy): unknown {
    const obj: any = {};
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.hourlySchedule !== undefined) {
      obj.hourlySchedule = HourlySchedule.toJSON(message.hourlySchedule);
    }
    if (message.dailySchedule !== undefined) {
      obj.dailySchedule = DailySchedule.toJSON(message.dailySchedule);
    }
    if (message.weeklySchedule !== undefined) {
      obj.weeklySchedule = WeeklySchedule.toJSON(message.weeklySchedule);
    }
    if (message.monthlySchedule !== undefined) {
      obj.monthlySchedule = MonthlySchedule.toJSON(message.monthlySchedule);
    }
    return obj;
  },

  create(base?: DeepPartial<SnapshotPolicy>): SnapshotPolicy {
    return SnapshotPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SnapshotPolicy>): SnapshotPolicy {
    const message = createBaseSnapshotPolicy();
    message.enabled = object.enabled ?? undefined;
    message.hourlySchedule = (object.hourlySchedule !== undefined && object.hourlySchedule !== null)
      ? HourlySchedule.fromPartial(object.hourlySchedule)
      : undefined;
    message.dailySchedule = (object.dailySchedule !== undefined && object.dailySchedule !== null)
      ? DailySchedule.fromPartial(object.dailySchedule)
      : undefined;
    message.weeklySchedule = (object.weeklySchedule !== undefined && object.weeklySchedule !== null)
      ? WeeklySchedule.fromPartial(object.weeklySchedule)
      : undefined;
    message.monthlySchedule = (object.monthlySchedule !== undefined && object.monthlySchedule !== null)
      ? MonthlySchedule.fromPartial(object.monthlySchedule)
      : undefined;
    return message;
  },
};

function createBaseHourlySchedule(): HourlySchedule {
  return { snapshotsToKeep: undefined, minute: undefined };
}

export const HourlySchedule: MessageFns<HourlySchedule> = {
  encode(message: HourlySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotsToKeep !== undefined) {
      writer.uint32(9).double(message.snapshotsToKeep);
    }
    if (message.minute !== undefined) {
      writer.uint32(17).double(message.minute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HourlySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHourlySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.snapshotsToKeep = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minute = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HourlySchedule {
    return {
      snapshotsToKeep: isSet(object.snapshotsToKeep) ? globalThis.Number(object.snapshotsToKeep) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
    };
  },

  toJSON(message: HourlySchedule): unknown {
    const obj: any = {};
    if (message.snapshotsToKeep !== undefined) {
      obj.snapshotsToKeep = message.snapshotsToKeep;
    }
    if (message.minute !== undefined) {
      obj.minute = message.minute;
    }
    return obj;
  },

  create(base?: DeepPartial<HourlySchedule>): HourlySchedule {
    return HourlySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HourlySchedule>): HourlySchedule {
    const message = createBaseHourlySchedule();
    message.snapshotsToKeep = object.snapshotsToKeep ?? undefined;
    message.minute = object.minute ?? undefined;
    return message;
  },
};

function createBaseDailySchedule(): DailySchedule {
  return { snapshotsToKeep: undefined, minute: undefined, hour: undefined };
}

export const DailySchedule: MessageFns<DailySchedule> = {
  encode(message: DailySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotsToKeep !== undefined) {
      writer.uint32(9).double(message.snapshotsToKeep);
    }
    if (message.minute !== undefined) {
      writer.uint32(17).double(message.minute);
    }
    if (message.hour !== undefined) {
      writer.uint32(25).double(message.hour);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.snapshotsToKeep = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minute = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.hour = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailySchedule {
    return {
      snapshotsToKeep: isSet(object.snapshotsToKeep) ? globalThis.Number(object.snapshotsToKeep) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
    };
  },

  toJSON(message: DailySchedule): unknown {
    const obj: any = {};
    if (message.snapshotsToKeep !== undefined) {
      obj.snapshotsToKeep = message.snapshotsToKeep;
    }
    if (message.minute !== undefined) {
      obj.minute = message.minute;
    }
    if (message.hour !== undefined) {
      obj.hour = message.hour;
    }
    return obj;
  },

  create(base?: DeepPartial<DailySchedule>): DailySchedule {
    return DailySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailySchedule>): DailySchedule {
    const message = createBaseDailySchedule();
    message.snapshotsToKeep = object.snapshotsToKeep ?? undefined;
    message.minute = object.minute ?? undefined;
    message.hour = object.hour ?? undefined;
    return message;
  },
};

function createBaseWeeklySchedule(): WeeklySchedule {
  return { snapshotsToKeep: undefined, minute: undefined, hour: undefined, day: undefined };
}

export const WeeklySchedule: MessageFns<WeeklySchedule> = {
  encode(message: WeeklySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotsToKeep !== undefined) {
      writer.uint32(9).double(message.snapshotsToKeep);
    }
    if (message.minute !== undefined) {
      writer.uint32(17).double(message.minute);
    }
    if (message.hour !== undefined) {
      writer.uint32(25).double(message.hour);
    }
    if (message.day !== undefined) {
      writer.uint32(34).string(message.day);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.snapshotsToKeep = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minute = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.hour = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.day = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklySchedule {
    return {
      snapshotsToKeep: isSet(object.snapshotsToKeep) ? globalThis.Number(object.snapshotsToKeep) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
      day: isSet(object.day) ? globalThis.String(object.day) : undefined,
    };
  },

  toJSON(message: WeeklySchedule): unknown {
    const obj: any = {};
    if (message.snapshotsToKeep !== undefined) {
      obj.snapshotsToKeep = message.snapshotsToKeep;
    }
    if (message.minute !== undefined) {
      obj.minute = message.minute;
    }
    if (message.hour !== undefined) {
      obj.hour = message.hour;
    }
    if (message.day !== undefined) {
      obj.day = message.day;
    }
    return obj;
  },

  create(base?: DeepPartial<WeeklySchedule>): WeeklySchedule {
    return WeeklySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeeklySchedule>): WeeklySchedule {
    const message = createBaseWeeklySchedule();
    message.snapshotsToKeep = object.snapshotsToKeep ?? undefined;
    message.minute = object.minute ?? undefined;
    message.hour = object.hour ?? undefined;
    message.day = object.day ?? undefined;
    return message;
  },
};

function createBaseMonthlySchedule(): MonthlySchedule {
  return { snapshotsToKeep: undefined, minute: undefined, hour: undefined, daysOfMonth: undefined };
}

export const MonthlySchedule: MessageFns<MonthlySchedule> = {
  encode(message: MonthlySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotsToKeep !== undefined) {
      writer.uint32(9).double(message.snapshotsToKeep);
    }
    if (message.minute !== undefined) {
      writer.uint32(17).double(message.minute);
    }
    if (message.hour !== undefined) {
      writer.uint32(25).double(message.hour);
    }
    if (message.daysOfMonth !== undefined) {
      writer.uint32(34).string(message.daysOfMonth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonthlySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthlySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.snapshotsToKeep = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.minute = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.hour = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.daysOfMonth = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonthlySchedule {
    return {
      snapshotsToKeep: isSet(object.snapshotsToKeep) ? globalThis.Number(object.snapshotsToKeep) : undefined,
      minute: isSet(object.minute) ? globalThis.Number(object.minute) : undefined,
      hour: isSet(object.hour) ? globalThis.Number(object.hour) : undefined,
      daysOfMonth: isSet(object.daysOfMonth) ? globalThis.String(object.daysOfMonth) : undefined,
    };
  },

  toJSON(message: MonthlySchedule): unknown {
    const obj: any = {};
    if (message.snapshotsToKeep !== undefined) {
      obj.snapshotsToKeep = message.snapshotsToKeep;
    }
    if (message.minute !== undefined) {
      obj.minute = message.minute;
    }
    if (message.hour !== undefined) {
      obj.hour = message.hour;
    }
    if (message.daysOfMonth !== undefined) {
      obj.daysOfMonth = message.daysOfMonth;
    }
    return obj;
  },

  create(base?: DeepPartial<MonthlySchedule>): MonthlySchedule {
    return MonthlySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonthlySchedule>): MonthlySchedule {
    const message = createBaseMonthlySchedule();
    message.snapshotsToKeep = object.snapshotsToKeep ?? undefined;
    message.minute = object.minute ?? undefined;
    message.hour = object.hour ?? undefined;
    message.daysOfMonth = object.daysOfMonth ?? undefined;
    return message;
  },
};

function createBaseMountOption(): MountOption {
  return { export: "", exportFull: "", protocol: 0, instructions: "" };
}

export const MountOption: MessageFns<MountOption> = {
  encode(message: MountOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.export !== "") {
      writer.uint32(10).string(message.export);
    }
    if (message.exportFull !== "") {
      writer.uint32(18).string(message.exportFull);
    }
    if (message.protocol !== 0) {
      writer.uint32(24).int32(message.protocol);
    }
    if (message.instructions !== "") {
      writer.uint32(34).string(message.instructions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MountOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMountOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.export = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exportFull = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instructions = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MountOption {
    return {
      export: isSet(object.export) ? globalThis.String(object.export) : "",
      exportFull: isSet(object.exportFull) ? globalThis.String(object.exportFull) : "",
      protocol: isSet(object.protocol) ? protocolsFromJSON(object.protocol) : 0,
      instructions: isSet(object.instructions) ? globalThis.String(object.instructions) : "",
    };
  },

  toJSON(message: MountOption): unknown {
    const obj: any = {};
    if (message.export !== "") {
      obj.export = message.export;
    }
    if (message.exportFull !== "") {
      obj.exportFull = message.exportFull;
    }
    if (message.protocol !== 0) {
      obj.protocol = protocolsToJSON(message.protocol);
    }
    if (message.instructions !== "") {
      obj.instructions = message.instructions;
    }
    return obj;
  },

  create(base?: DeepPartial<MountOption>): MountOption {
    return MountOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MountOption>): MountOption {
    const message = createBaseMountOption();
    message.export = object.export ?? "";
    message.exportFull = object.exportFull ?? "";
    message.protocol = object.protocol ?? 0;
    message.instructions = object.instructions ?? "";
    return message;
  },
};

function createBaseRestoreParameters(): RestoreParameters {
  return { sourceSnapshot: undefined, sourceBackup: undefined };
}

export const RestoreParameters: MessageFns<RestoreParameters> = {
  encode(message: RestoreParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceSnapshot !== undefined) {
      writer.uint32(10).string(message.sourceSnapshot);
    }
    if (message.sourceBackup !== undefined) {
      writer.uint32(18).string(message.sourceBackup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceSnapshot = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceBackup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreParameters {
    return {
      sourceSnapshot: isSet(object.sourceSnapshot) ? globalThis.String(object.sourceSnapshot) : undefined,
      sourceBackup: isSet(object.sourceBackup) ? globalThis.String(object.sourceBackup) : undefined,
    };
  },

  toJSON(message: RestoreParameters): unknown {
    const obj: any = {};
    if (message.sourceSnapshot !== undefined) {
      obj.sourceSnapshot = message.sourceSnapshot;
    }
    if (message.sourceBackup !== undefined) {
      obj.sourceBackup = message.sourceBackup;
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreParameters>): RestoreParameters {
    return RestoreParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreParameters>): RestoreParameters {
    const message = createBaseRestoreParameters();
    message.sourceSnapshot = object.sourceSnapshot ?? undefined;
    message.sourceBackup = object.sourceBackup ?? undefined;
    return message;
  },
};

function createBaseBackupConfig(): BackupConfig {
  return { backupPolicies: [], backupVault: "", scheduledBackupEnabled: undefined, backupChainBytes: undefined };
}

export const BackupConfig: MessageFns<BackupConfig> = {
  encode(message: BackupConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backupPolicies) {
      writer.uint32(10).string(v!);
    }
    if (message.backupVault !== "") {
      writer.uint32(18).string(message.backupVault);
    }
    if (message.scheduledBackupEnabled !== undefined) {
      writer.uint32(24).bool(message.scheduledBackupEnabled);
    }
    if (message.backupChainBytes !== undefined) {
      writer.uint32(32).int64(message.backupChainBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPolicies.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupVault = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.scheduledBackupEnabled = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.backupChainBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupConfig {
    return {
      backupPolicies: globalThis.Array.isArray(object?.backupPolicies)
        ? object.backupPolicies.map((e: any) => globalThis.String(e))
        : [],
      backupVault: isSet(object.backupVault) ? globalThis.String(object.backupVault) : "",
      scheduledBackupEnabled: isSet(object.scheduledBackupEnabled)
        ? globalThis.Boolean(object.scheduledBackupEnabled)
        : undefined,
      backupChainBytes: isSet(object.backupChainBytes) ? Long.fromValue(object.backupChainBytes) : undefined,
    };
  },

  toJSON(message: BackupConfig): unknown {
    const obj: any = {};
    if (message.backupPolicies?.length) {
      obj.backupPolicies = message.backupPolicies;
    }
    if (message.backupVault !== "") {
      obj.backupVault = message.backupVault;
    }
    if (message.scheduledBackupEnabled !== undefined) {
      obj.scheduledBackupEnabled = message.scheduledBackupEnabled;
    }
    if (message.backupChainBytes !== undefined) {
      obj.backupChainBytes = (message.backupChainBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BackupConfig>): BackupConfig {
    return BackupConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupConfig>): BackupConfig {
    const message = createBaseBackupConfig();
    message.backupPolicies = object.backupPolicies?.map((e) => e) || [];
    message.backupVault = object.backupVault ?? "";
    message.scheduledBackupEnabled = object.scheduledBackupEnabled ?? undefined;
    message.backupChainBytes = (object.backupChainBytes !== undefined && object.backupChainBytes !== null)
      ? Long.fromValue(object.backupChainBytes)
      : undefined;
    return message;
  },
};

function createBaseTieringPolicy(): TieringPolicy {
  return { tierAction: undefined, coolingThresholdDays: undefined };
}

export const TieringPolicy: MessageFns<TieringPolicy> = {
  encode(message: TieringPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tierAction !== undefined) {
      writer.uint32(8).int32(message.tierAction);
    }
    if (message.coolingThresholdDays !== undefined) {
      writer.uint32(16).int32(message.coolingThresholdDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TieringPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTieringPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tierAction = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.coolingThresholdDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TieringPolicy {
    return {
      tierAction: isSet(object.tierAction) ? tieringPolicy_TierActionFromJSON(object.tierAction) : undefined,
      coolingThresholdDays: isSet(object.coolingThresholdDays)
        ? globalThis.Number(object.coolingThresholdDays)
        : undefined,
    };
  },

  toJSON(message: TieringPolicy): unknown {
    const obj: any = {};
    if (message.tierAction !== undefined) {
      obj.tierAction = tieringPolicy_TierActionToJSON(message.tierAction);
    }
    if (message.coolingThresholdDays !== undefined) {
      obj.coolingThresholdDays = Math.round(message.coolingThresholdDays);
    }
    return obj;
  },

  create(base?: DeepPartial<TieringPolicy>): TieringPolicy {
    return TieringPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TieringPolicy>): TieringPolicy {
    const message = createBaseTieringPolicy();
    message.tierAction = object.tierAction ?? undefined;
    message.coolingThresholdDays = object.coolingThresholdDays ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
