// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dataproc/logging/reconciler_log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";

export const protobufPackage = "google.cloud.dataproc.logging";

/** Decision type */
export enum ReconciliationDecisionType {
  /** RECONCILIATION_DECISION_TYPE_UNSPECIFIED - Unspecified type */
  RECONCILIATION_DECISION_TYPE_UNSPECIFIED = 0,
  /** RECONCILIATION_TERMINATE_SESSION - Terminate session */
  RECONCILIATION_TERMINATE_SESSION = 1,
  UNRECOGNIZED = -1,
}

export function reconciliationDecisionTypeFromJSON(object: any): ReconciliationDecisionType {
  switch (object) {
    case 0:
    case "RECONCILIATION_DECISION_TYPE_UNSPECIFIED":
      return ReconciliationDecisionType.RECONCILIATION_DECISION_TYPE_UNSPECIFIED;
    case 1:
    case "RECONCILIATION_TERMINATE_SESSION":
      return ReconciliationDecisionType.RECONCILIATION_TERMINATE_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReconciliationDecisionType.UNRECOGNIZED;
  }
}

export function reconciliationDecisionTypeToJSON(object: ReconciliationDecisionType): string {
  switch (object) {
    case ReconciliationDecisionType.RECONCILIATION_DECISION_TYPE_UNSPECIFIED:
      return "RECONCILIATION_DECISION_TYPE_UNSPECIFIED";
    case ReconciliationDecisionType.RECONCILIATION_TERMINATE_SESSION:
      return "RECONCILIATION_TERMINATE_SESSION";
    case ReconciliationDecisionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Reconciliation log for session ttl event. */
export interface ReconciliationLog {
  /** The reconciliation algorithm inputs. */
  inputs:
    | ReconciliationLog_Inputs
    | undefined;
  /** The algorithm outputs for the recommended reconciliation operation. */
  outputs: ReconciliationLog_Outputs | undefined;
}

/**
 * The input values for the Reconciler recommendation algorithm.
 * We could add more details in future if required.
 */
export interface ReconciliationLog_Inputs {
  /** Idle duration */
  idleDuration:
    | Duration
    | undefined;
  /** Configured idle TTL */
  idleTtl:
    | Duration
    | undefined;
  /** Total session lifetime */
  sessionLifetime:
    | Duration
    | undefined;
  /** Configured ttl */
  ttl: Duration | undefined;
}

/** Reconciler recommendations. */
export interface ReconciliationLog_Outputs {
  /** The high-level reconciliation decision. */
  decision: ReconciliationDecisionType;
  /** Human readable context messages which explain the reconciler decision. */
  decisionDetails: string;
}

/** Reconciliation log for cluster heal event. */
export interface ReconciliationClusterHealLog {
  /** The algorithm outputs for the recommended reconciliation operation. */
  outputs: ReconciliationClusterHealLog_Outputs | undefined;
}

/** Autohealer decision. */
export interface ReconciliationClusterHealLog_Outputs {
  /** The repair operation id triggered by Autohealer if any. */
  repairOperationId: string;
  /** Human readable context messages which explain the autohealer decision. */
  decisionDetails: string;
}

function createBaseReconciliationLog(): ReconciliationLog {
  return { inputs: undefined, outputs: undefined };
}

export const ReconciliationLog: MessageFns<ReconciliationLog> = {
  encode(message: ReconciliationLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputs !== undefined) {
      ReconciliationLog_Inputs.encode(message.inputs, writer.uint32(10).fork()).join();
    }
    if (message.outputs !== undefined) {
      ReconciliationLog_Outputs.encode(message.outputs, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs = ReconciliationLog_Inputs.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs = ReconciliationLog_Outputs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationLog {
    return {
      inputs: isSet(object.inputs) ? ReconciliationLog_Inputs.fromJSON(object.inputs) : undefined,
      outputs: isSet(object.outputs) ? ReconciliationLog_Outputs.fromJSON(object.outputs) : undefined,
    };
  },

  toJSON(message: ReconciliationLog): unknown {
    const obj: any = {};
    if (message.inputs !== undefined) {
      obj.inputs = ReconciliationLog_Inputs.toJSON(message.inputs);
    }
    if (message.outputs !== undefined) {
      obj.outputs = ReconciliationLog_Outputs.toJSON(message.outputs);
    }
    return obj;
  },

  create(base?: DeepPartial<ReconciliationLog>): ReconciliationLog {
    return ReconciliationLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconciliationLog>): ReconciliationLog {
    const message = createBaseReconciliationLog();
    message.inputs = (object.inputs !== undefined && object.inputs !== null)
      ? ReconciliationLog_Inputs.fromPartial(object.inputs)
      : undefined;
    message.outputs = (object.outputs !== undefined && object.outputs !== null)
      ? ReconciliationLog_Outputs.fromPartial(object.outputs)
      : undefined;
    return message;
  },
};

function createBaseReconciliationLog_Inputs(): ReconciliationLog_Inputs {
  return { idleDuration: undefined, idleTtl: undefined, sessionLifetime: undefined, ttl: undefined };
}

export const ReconciliationLog_Inputs: MessageFns<ReconciliationLog_Inputs> = {
  encode(message: ReconciliationLog_Inputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idleDuration !== undefined) {
      Duration.encode(message.idleDuration, writer.uint32(10).fork()).join();
    }
    if (message.idleTtl !== undefined) {
      Duration.encode(message.idleTtl, writer.uint32(18).fork()).join();
    }
    if (message.sessionLifetime !== undefined) {
      Duration.encode(message.sessionLifetime, writer.uint32(26).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationLog_Inputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationLog_Inputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.idleDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.idleTtl = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionLifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationLog_Inputs {
    return {
      idleDuration: isSet(object.idleDuration) ? Duration.fromJSON(object.idleDuration) : undefined,
      idleTtl: isSet(object.idleTtl) ? Duration.fromJSON(object.idleTtl) : undefined,
      sessionLifetime: isSet(object.sessionLifetime) ? Duration.fromJSON(object.sessionLifetime) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
    };
  },

  toJSON(message: ReconciliationLog_Inputs): unknown {
    const obj: any = {};
    if (message.idleDuration !== undefined) {
      obj.idleDuration = Duration.toJSON(message.idleDuration);
    }
    if (message.idleTtl !== undefined) {
      obj.idleTtl = Duration.toJSON(message.idleTtl);
    }
    if (message.sessionLifetime !== undefined) {
      obj.sessionLifetime = Duration.toJSON(message.sessionLifetime);
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    return obj;
  },

  create(base?: DeepPartial<ReconciliationLog_Inputs>): ReconciliationLog_Inputs {
    return ReconciliationLog_Inputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconciliationLog_Inputs>): ReconciliationLog_Inputs {
    const message = createBaseReconciliationLog_Inputs();
    message.idleDuration = (object.idleDuration !== undefined && object.idleDuration !== null)
      ? Duration.fromPartial(object.idleDuration)
      : undefined;
    message.idleTtl = (object.idleTtl !== undefined && object.idleTtl !== null)
      ? Duration.fromPartial(object.idleTtl)
      : undefined;
    message.sessionLifetime = (object.sessionLifetime !== undefined && object.sessionLifetime !== null)
      ? Duration.fromPartial(object.sessionLifetime)
      : undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    return message;
  },
};

function createBaseReconciliationLog_Outputs(): ReconciliationLog_Outputs {
  return { decision: 0, decisionDetails: "" };
}

export const ReconciliationLog_Outputs: MessageFns<ReconciliationLog_Outputs> = {
  encode(message: ReconciliationLog_Outputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decision !== 0) {
      writer.uint32(8).int32(message.decision);
    }
    if (message.decisionDetails !== "") {
      writer.uint32(18).string(message.decisionDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationLog_Outputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationLog_Outputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.decision = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.decisionDetails = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationLog_Outputs {
    return {
      decision: isSet(object.decision) ? reconciliationDecisionTypeFromJSON(object.decision) : 0,
      decisionDetails: isSet(object.decisionDetails) ? globalThis.String(object.decisionDetails) : "",
    };
  },

  toJSON(message: ReconciliationLog_Outputs): unknown {
    const obj: any = {};
    if (message.decision !== 0) {
      obj.decision = reconciliationDecisionTypeToJSON(message.decision);
    }
    if (message.decisionDetails !== "") {
      obj.decisionDetails = message.decisionDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<ReconciliationLog_Outputs>): ReconciliationLog_Outputs {
    return ReconciliationLog_Outputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconciliationLog_Outputs>): ReconciliationLog_Outputs {
    const message = createBaseReconciliationLog_Outputs();
    message.decision = object.decision ?? 0;
    message.decisionDetails = object.decisionDetails ?? "";
    return message;
  },
};

function createBaseReconciliationClusterHealLog(): ReconciliationClusterHealLog {
  return { outputs: undefined };
}

export const ReconciliationClusterHealLog: MessageFns<ReconciliationClusterHealLog> = {
  encode(message: ReconciliationClusterHealLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputs !== undefined) {
      ReconciliationClusterHealLog_Outputs.encode(message.outputs, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationClusterHealLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationClusterHealLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outputs = ReconciliationClusterHealLog_Outputs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationClusterHealLog {
    return {
      outputs: isSet(object.outputs) ? ReconciliationClusterHealLog_Outputs.fromJSON(object.outputs) : undefined,
    };
  },

  toJSON(message: ReconciliationClusterHealLog): unknown {
    const obj: any = {};
    if (message.outputs !== undefined) {
      obj.outputs = ReconciliationClusterHealLog_Outputs.toJSON(message.outputs);
    }
    return obj;
  },

  create(base?: DeepPartial<ReconciliationClusterHealLog>): ReconciliationClusterHealLog {
    return ReconciliationClusterHealLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconciliationClusterHealLog>): ReconciliationClusterHealLog {
    const message = createBaseReconciliationClusterHealLog();
    message.outputs = (object.outputs !== undefined && object.outputs !== null)
      ? ReconciliationClusterHealLog_Outputs.fromPartial(object.outputs)
      : undefined;
    return message;
  },
};

function createBaseReconciliationClusterHealLog_Outputs(): ReconciliationClusterHealLog_Outputs {
  return { repairOperationId: "", decisionDetails: "" };
}

export const ReconciliationClusterHealLog_Outputs: MessageFns<ReconciliationClusterHealLog_Outputs> = {
  encode(message: ReconciliationClusterHealLog_Outputs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repairOperationId !== "") {
      writer.uint32(10).string(message.repairOperationId);
    }
    if (message.decisionDetails !== "") {
      writer.uint32(18).string(message.decisionDetails);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconciliationClusterHealLog_Outputs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconciliationClusterHealLog_Outputs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repairOperationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.decisionDetails = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconciliationClusterHealLog_Outputs {
    return {
      repairOperationId: isSet(object.repairOperationId) ? globalThis.String(object.repairOperationId) : "",
      decisionDetails: isSet(object.decisionDetails) ? globalThis.String(object.decisionDetails) : "",
    };
  },

  toJSON(message: ReconciliationClusterHealLog_Outputs): unknown {
    const obj: any = {};
    if (message.repairOperationId !== "") {
      obj.repairOperationId = message.repairOperationId;
    }
    if (message.decisionDetails !== "") {
      obj.decisionDetails = message.decisionDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<ReconciliationClusterHealLog_Outputs>): ReconciliationClusterHealLog_Outputs {
    return ReconciliationClusterHealLog_Outputs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconciliationClusterHealLog_Outputs>): ReconciliationClusterHealLog_Outputs {
    const message = createBaseReconciliationClusterHealLog_Outputs();
    message.repairOperationId = object.repairOperationId ?? "";
    message.decisionDetails = object.decisionDetails ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
