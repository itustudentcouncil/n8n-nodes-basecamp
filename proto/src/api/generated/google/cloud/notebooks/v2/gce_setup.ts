// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/notebooks/v2/gce_setup.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.notebooks.v2";

/** Definition of the disk encryption options. */
export enum DiskEncryption {
  /** DISK_ENCRYPTION_UNSPECIFIED - Disk encryption is not specified. */
  DISK_ENCRYPTION_UNSPECIFIED = 0,
  /** GMEK - Use Google managed encryption keys to encrypt the boot disk. */
  GMEK = 1,
  /** CMEK - Use customer managed encryption keys to encrypt the boot disk. */
  CMEK = 2,
  UNRECOGNIZED = -1,
}

export function diskEncryptionFromJSON(object: any): DiskEncryption {
  switch (object) {
    case 0:
    case "DISK_ENCRYPTION_UNSPECIFIED":
      return DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED;
    case 1:
    case "GMEK":
      return DiskEncryption.GMEK;
    case 2:
    case "CMEK":
      return DiskEncryption.CMEK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskEncryption.UNRECOGNIZED;
  }
}

export function diskEncryptionToJSON(object: DiskEncryption): string {
  switch (object) {
    case DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED:
      return "DISK_ENCRYPTION_UNSPECIFIED";
    case DiskEncryption.GMEK:
      return "GMEK";
    case DiskEncryption.CMEK:
      return "CMEK";
    case DiskEncryption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible disk types. */
export enum DiskType {
  /** DISK_TYPE_UNSPECIFIED - Disk type not set. */
  DISK_TYPE_UNSPECIFIED = 0,
  /** PD_STANDARD - Standard persistent disk type. */
  PD_STANDARD = 1,
  /** PD_SSD - SSD persistent disk type. */
  PD_SSD = 2,
  /** PD_BALANCED - Balanced persistent disk type. */
  PD_BALANCED = 3,
  /** PD_EXTREME - Extreme persistent disk type. */
  PD_EXTREME = 4,
  UNRECOGNIZED = -1,
}

export function diskTypeFromJSON(object: any): DiskType {
  switch (object) {
    case 0:
    case "DISK_TYPE_UNSPECIFIED":
      return DiskType.DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PD_STANDARD":
      return DiskType.PD_STANDARD;
    case 2:
    case "PD_SSD":
      return DiskType.PD_SSD;
    case 3:
    case "PD_BALANCED":
      return DiskType.PD_BALANCED;
    case 4:
    case "PD_EXTREME":
      return DiskType.PD_EXTREME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DiskType.UNRECOGNIZED;
  }
}

export function diskTypeToJSON(object: DiskType): string {
  switch (object) {
    case DiskType.DISK_TYPE_UNSPECIFIED:
      return "DISK_TYPE_UNSPECIFIED";
    case DiskType.PD_STANDARD:
      return "PD_STANDARD";
    case DiskType.PD_SSD:
      return "PD_SSD";
    case DiskType.PD_BALANCED:
      return "PD_BALANCED";
    case DiskType.PD_EXTREME:
      return "PD_EXTREME";
    case DiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of a network interface resource attached to a VM. */
export interface NetworkInterface {
  /**
   * Optional. The name of the VPC that this VM instance is in.
   * Format:
   * `projects/{project_id}/global/networks/{network_id}`
   */
  network: string;
  /**
   * Optional. The name of the subnet that this VM instance is in.
   * Format:
   * `projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}`
   */
  subnet: string;
  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC
   * or VirtioNet.
   */
  nicType: NetworkInterface_NicType;
}

/**
 * The type of vNIC driver.
 * Default should be NIC_TYPE_UNSPECIFIED.
 */
export enum NetworkInterface_NicType {
  /** NIC_TYPE_UNSPECIFIED - No type specified. */
  NIC_TYPE_UNSPECIFIED = 0,
  /** VIRTIO_NET - VIRTIO */
  VIRTIO_NET = 1,
  /** GVNIC - GVNIC */
  GVNIC = 2,
  UNRECOGNIZED = -1,
}

export function networkInterface_NicTypeFromJSON(object: any): NetworkInterface_NicType {
  switch (object) {
    case 0:
    case "NIC_TYPE_UNSPECIFIED":
      return NetworkInterface_NicType.NIC_TYPE_UNSPECIFIED;
    case 1:
    case "VIRTIO_NET":
      return NetworkInterface_NicType.VIRTIO_NET;
    case 2:
    case "GVNIC":
      return NetworkInterface_NicType.GVNIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkInterface_NicType.UNRECOGNIZED;
  }
}

export function networkInterface_NicTypeToJSON(object: NetworkInterface_NicType): string {
  switch (object) {
    case NetworkInterface_NicType.NIC_TYPE_UNSPECIFIED:
      return "NIC_TYPE_UNSPECIFIED";
    case NetworkInterface_NicType.VIRTIO_NET:
      return "VIRTIO_NET";
    case NetworkInterface_NicType.GVNIC:
      return "GVNIC";
    case NetworkInterface_NicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Definition of a custom Compute Engine virtual machine image for starting a
 * notebook instance with the environment installed directly on the VM.
 */
export interface VmImage {
  /**
   * Required. The name of the Google Cloud project that this VM image belongs
   * to. Format: `{project_id}`
   */
  project: string;
  /** Optional. Use VM image name to find the image. */
  name?:
    | string
    | undefined;
  /**
   * Optional. Use this VM image family to find the image; the newest image in
   * this family will be used.
   */
  family?: string | undefined;
}

/**
 * Definition of a container image for starting a notebook instance with the
 * environment installed in a container.
 */
export interface ContainerImage {
  /**
   * Required. The path to the container image repository. For example:
   * `gcr.io/{project_id}/{image_name}`
   */
  repository: string;
  /**
   * Optional. The tag of the container image. If not specified, this defaults
   * to the latest tag.
   */
  tag: string;
}

/**
 * An accelerator configuration for a VM instance
 * Definition of a hardware accelerator. Note that there is no check on `type`
 * and `core_count` combinations. TPUs are not supported.
 * See [GPUs on Compute
 * Engine](https://cloud.google.com/compute/docs/gpus/#gpus-list) to find a
 * valid combination.
 */
export interface AcceleratorConfig {
  /** Optional. Type of this accelerator. */
  type: AcceleratorConfig_AcceleratorType;
  /** Optional. Count of cores of this accelerator. */
  coreCount: Long;
}

/**
 * Definition of the types of hardware accelerators that can be used on
 * this instance.
 */
export enum AcceleratorConfig_AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Accelerator type is not specified. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_P100 - Accelerator type is Nvidia Tesla P100. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Accelerator type is Nvidia Tesla V100. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Accelerator type is Nvidia Tesla P4. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Accelerator type is Nvidia Tesla T4. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Accelerator type is Nvidia Tesla A100 - 40GB. */
  NVIDIA_TESLA_A100 = 11,
  /** NVIDIA_A100_80GB - Accelerator type is Nvidia Tesla A100 - 80GB. */
  NVIDIA_A100_80GB = 12,
  /** NVIDIA_L4 - Accelerator type is Nvidia Tesla L4. */
  NVIDIA_L4 = 13,
  /** NVIDIA_TESLA_T4_VWS - Accelerator type is NVIDIA Tesla T4 Virtual Workstations. */
  NVIDIA_TESLA_T4_VWS = 8,
  /** NVIDIA_TESLA_P100_VWS - Accelerator type is NVIDIA Tesla P100 Virtual Workstations. */
  NVIDIA_TESLA_P100_VWS = 9,
  /** NVIDIA_TESLA_P4_VWS - Accelerator type is NVIDIA Tesla P4 Virtual Workstations. */
  NVIDIA_TESLA_P4_VWS = 10,
  UNRECOGNIZED = -1,
}

export function acceleratorConfig_AcceleratorTypeFromJSON(object: any): AcceleratorConfig_AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return AcceleratorConfig_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 2:
    case "NVIDIA_TESLA_P100":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4;
    case 11:
    case "NVIDIA_TESLA_A100":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_A100;
    case 12:
    case "NVIDIA_A100_80GB":
      return AcceleratorConfig_AcceleratorType.NVIDIA_A100_80GB;
    case 13:
    case "NVIDIA_L4":
      return AcceleratorConfig_AcceleratorType.NVIDIA_L4;
    case 8:
    case "NVIDIA_TESLA_T4_VWS":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4_VWS;
    case 9:
    case "NVIDIA_TESLA_P100_VWS":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100_VWS;
    case 10:
    case "NVIDIA_TESLA_P4_VWS":
      return AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4_VWS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceleratorConfig_AcceleratorType.UNRECOGNIZED;
  }
}

export function acceleratorConfig_AcceleratorTypeToJSON(object: AcceleratorConfig_AcceleratorType): string {
  switch (object) {
    case AcceleratorConfig_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case AcceleratorConfig_AcceleratorType.NVIDIA_A100_80GB:
      return "NVIDIA_A100_80GB";
    case AcceleratorConfig_AcceleratorType.NVIDIA_L4:
      return "NVIDIA_L4";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_T4_VWS:
      return "NVIDIA_TESLA_T4_VWS";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P100_VWS:
      return "NVIDIA_TESLA_P100_VWS";
    case AcceleratorConfig_AcceleratorType.NVIDIA_TESLA_P4_VWS:
      return "NVIDIA_TESLA_P4_VWS";
    case AcceleratorConfig_AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A set of Shielded Instance options.
 * See [Images using supported Shielded VM
 * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
 * Not all combinations are valid.
 */
export interface ShieldedInstanceConfig {
  /**
   * Optional. Defines whether the VM instance has Secure Boot enabled.
   *
   * Secure Boot helps ensure that the system only runs authentic software by
   * verifying the digital signature of all boot components, and halting the
   * boot process if signature verification fails. Disabled by default.
   */
  enableSecureBoot: boolean;
  /**
   * Optional. Defines whether the VM instance has the vTPM enabled. Enabled by
   * default.
   */
  enableVtpm: boolean;
  /**
   * Optional. Defines whether the VM instance has integrity monitoring enabled.
   *
   * Enables monitoring and attestation of the boot integrity of the VM
   * instance. The attestation is performed against the integrity policy
   * baseline. This baseline is initially derived from the implicitly trusted
   * boot image when the VM instance is created. Enabled by default.
   */
  enableIntegrityMonitoring: boolean;
}

/** A GPU driver configuration */
export interface GPUDriverConfig {
  /**
   * Optional. Whether the end user authorizes Google Cloud to install GPU
   * driver on this VM instance. If this field is empty or set to false, the GPU
   * driver won't be installed. Only applicable to instances with GPUs.
   */
  enableGpuDriver: boolean;
  /**
   * Optional. Specify a custom Cloud Storage path where the GPU driver is
   * stored. If not specified, we'll automatically choose from official GPU
   * drivers.
   */
  customGpuDriverPath: string;
}

/** An instance-attached disk resource. */
export interface DataDisk {
  /**
   * Optional. The size of the disk in GB attached to this VM instance, up to a
   * maximum of 64000 GB (64 TB). If not specified, this defaults to 100.
   */
  diskSizeGb: Long;
  /** Optional. Input only. Indicates the type of the disk. */
  diskType: DiskType;
  /**
   * Optional. Input only. Disk encryption method used on the boot and data
   * disks, defaults to GMEK.
   */
  diskEncryption: DiskEncryption;
  /**
   * Optional. Input only. The KMS key used to encrypt the disks, only
   * applicable if disk_encryption is CMEK. Format:
   * `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
   *
   * Learn more about using your own encryption keys.
   */
  kmsKey: string;
}

/** The definition of a boot disk. */
export interface BootDisk {
  /**
   * Optional. The size of the boot disk in GB attached to this instance, up to
   * a maximum of 64000 GB (64 TB). If not specified, this defaults to the
   * recommended value of 150GB.
   */
  diskSizeGb: Long;
  /** Optional. Indicates the type of the disk. */
  diskType: DiskType;
  /**
   * Optional. Input only. Disk encryption method used on the boot and data
   * disks, defaults to GMEK.
   */
  diskEncryption: DiskEncryption;
  /**
   * Optional. Input only. The KMS key used to encrypt the disks, only
   * applicable if disk_encryption is CMEK. Format:
   * `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
   *
   * Learn more about using your own encryption keys.
   */
  kmsKey: string;
}

/** A service account that acts as an identity. */
export interface ServiceAccount {
  /** Optional. Email address of the service account. */
  email: string;
  /**
   * Output only. The list of scopes to be made available for this service
   * account. Set by the CLH to https://www.googleapis.com/auth/cloud-platform
   */
  scopes: string[];
}

/**
 * The definition of how to configure a VM instance outside of Resources and
 * Identity.
 */
export interface GceSetup {
  /**
   * Optional. The machine type of the VM instance.
   * https://cloud.google.com/compute/docs/machine-resource
   */
  machineType: string;
  /**
   * Optional. The hardware accelerators used on this instance. If you use
   * accelerators, make sure that your configuration has
   * [enough vCPUs and memory to support the `machine_type` you have
   * selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
   * Currently supports only one accelerator configuration.
   */
  acceleratorConfigs: AcceleratorConfig[];
  /**
   * Optional. The service account that serves as an identity for the VM
   * instance. Currently supports only one service account.
   */
  serviceAccounts: ServiceAccount[];
  /** Optional. Use a Compute Engine VM image to start the notebook instance. */
  vmImage?:
    | VmImage
    | undefined;
  /** Optional. Use a container image to start the notebook instance. */
  containerImage?:
    | ContainerImage
    | undefined;
  /** Optional. The boot disk for the VM. */
  bootDisk:
    | BootDisk
    | undefined;
  /**
   * Optional. Data disks attached to the VM instance.
   * Currently supports only one data disk.
   */
  dataDisks: DataDisk[];
  /**
   * Optional. Shielded VM configuration.
   * [Images using supported Shielded VM
   * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
   */
  shieldedInstanceConfig:
    | ShieldedInstanceConfig
    | undefined;
  /**
   * Optional. The network interfaces for the VM.
   * Supports only one interface.
   */
  networkInterfaces: NetworkInterface[];
  /** Optional. If true, no external IP will be assigned to this VM instance. */
  disablePublicIp: boolean;
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   */
  tags: string[];
  /** Optional. Custom metadata to apply to this instance. */
  metadata: { [key: string]: string };
  /**
   * Optional. Flag to enable ip forwarding or not, default false/off.
   * https://cloud.google.com/vpc/docs/using-routes#canipforward
   */
  enableIpForwarding: boolean;
  /** Optional. Configuration for GPU drivers. */
  gpuDriverConfig: GPUDriverConfig | undefined;
}

export interface GceSetup_MetadataEntry {
  key: string;
  value: string;
}

function createBaseNetworkInterface(): NetworkInterface {
  return { network: "", subnet: "", nicType: 0 };
}

export const NetworkInterface: MessageFns<NetworkInterface> = {
  encode(message: NetworkInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(18).string(message.subnet);
    }
    if (message.nicType !== 0) {
      writer.uint32(24).int32(message.nicType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nicType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInterface {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      nicType: isSet(object.nicType) ? networkInterface_NicTypeFromJSON(object.nicType) : 0,
    };
  },

  toJSON(message: NetworkInterface): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.nicType !== 0) {
      obj.nicType = networkInterface_NicTypeToJSON(message.nicType);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkInterface>): NetworkInterface {
    return NetworkInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkInterface>): NetworkInterface {
    const message = createBaseNetworkInterface();
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.nicType = object.nicType ?? 0;
    return message;
  },
};

function createBaseVmImage(): VmImage {
  return { project: "", name: undefined, family: undefined };
}

export const VmImage: MessageFns<VmImage> = {
  encode(message: VmImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.family !== undefined) {
      writer.uint32(26).string(message.family);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.family = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmImage {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      family: isSet(object.family) ? globalThis.String(object.family) : undefined,
    };
  },

  toJSON(message: VmImage): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.family !== undefined) {
      obj.family = message.family;
    }
    return obj;
  },

  create(base?: DeepPartial<VmImage>): VmImage {
    return VmImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmImage>): VmImage {
    const message = createBaseVmImage();
    message.project = object.project ?? "";
    message.name = object.name ?? undefined;
    message.family = object.family ?? undefined;
    return message;
  },
};

function createBaseContainerImage(): ContainerImage {
  return { repository: "", tag: "" };
}

export const ContainerImage: MessageFns<ContainerImage> = {
  encode(message: ContainerImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerImage {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: ContainerImage): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(base?: DeepPartial<ContainerImage>): ContainerImage {
    return ContainerImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContainerImage>): ContainerImage {
    const message = createBaseContainerImage();
    message.repository = object.repository ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return { type: 0, coreCount: Long.ZERO };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.coreCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.coreCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      type: isSet(object.type) ? acceleratorConfig_AcceleratorTypeFromJSON(object.type) : 0,
      coreCount: isSet(object.coreCount) ? Long.fromValue(object.coreCount) : Long.ZERO,
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = acceleratorConfig_AcceleratorTypeToJSON(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      obj.coreCount = (message.coreCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.type = object.type ?? 0;
    message.coreCount = (object.coreCount !== undefined && object.coreCount !== null)
      ? Long.fromValue(object.coreCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseShieldedInstanceConfig(): ShieldedInstanceConfig {
  return { enableSecureBoot: false, enableVtpm: false, enableIntegrityMonitoring: false };
}

export const ShieldedInstanceConfig: MessageFns<ShieldedInstanceConfig> = {
  encode(message: ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableVtpm !== false) {
      writer.uint32(16).bool(message.enableVtpm);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(24).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableVtpm = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableVtpm: isSet(object.enableVtpm) ? globalThis.Boolean(object.enableVtpm) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableVtpm !== false) {
      obj.enableVtpm = message.enableVtpm;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create(base?: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    return ShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    const message = createBaseShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableVtpm = object.enableVtpm ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseGPUDriverConfig(): GPUDriverConfig {
  return { enableGpuDriver: false, customGpuDriverPath: "" };
}

export const GPUDriverConfig: MessageFns<GPUDriverConfig> = {
  encode(message: GPUDriverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableGpuDriver !== false) {
      writer.uint32(8).bool(message.enableGpuDriver);
    }
    if (message.customGpuDriverPath !== "") {
      writer.uint32(18).string(message.customGpuDriverPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPUDriverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPUDriverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableGpuDriver = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customGpuDriverPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPUDriverConfig {
    return {
      enableGpuDriver: isSet(object.enableGpuDriver) ? globalThis.Boolean(object.enableGpuDriver) : false,
      customGpuDriverPath: isSet(object.customGpuDriverPath) ? globalThis.String(object.customGpuDriverPath) : "",
    };
  },

  toJSON(message: GPUDriverConfig): unknown {
    const obj: any = {};
    if (message.enableGpuDriver !== false) {
      obj.enableGpuDriver = message.enableGpuDriver;
    }
    if (message.customGpuDriverPath !== "") {
      obj.customGpuDriverPath = message.customGpuDriverPath;
    }
    return obj;
  },

  create(base?: DeepPartial<GPUDriverConfig>): GPUDriverConfig {
    return GPUDriverConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GPUDriverConfig>): GPUDriverConfig {
    const message = createBaseGPUDriverConfig();
    message.enableGpuDriver = object.enableGpuDriver ?? false;
    message.customGpuDriverPath = object.customGpuDriverPath ?? "";
    return message;
  },
};

function createBaseDataDisk(): DataDisk {
  return { diskSizeGb: Long.ZERO, diskType: 0, diskEncryption: 0, kmsKey: "" };
}

export const DataDisk: MessageFns<DataDisk> = {
  encode(message: DataDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.diskSizeGb.toString());
    }
    if (message.diskType !== 0) {
      writer.uint32(16).int32(message.diskType);
    }
    if (message.diskEncryption !== 0) {
      writer.uint32(40).int32(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      writer.uint32(50).string(message.kmsKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.diskType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.diskEncryption = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataDisk {
    return {
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      diskType: isSet(object.diskType) ? diskTypeFromJSON(object.diskType) : 0,
      diskEncryption: isSet(object.diskEncryption) ? diskEncryptionFromJSON(object.diskEncryption) : 0,
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
    };
  },

  toJSON(message: DataDisk): unknown {
    const obj: any = {};
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.diskType !== 0) {
      obj.diskType = diskTypeToJSON(message.diskType);
    }
    if (message.diskEncryption !== 0) {
      obj.diskEncryption = diskEncryptionToJSON(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    return obj;
  },

  create(base?: DeepPartial<DataDisk>): DataDisk {
    return DataDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataDisk>): DataDisk {
    const message = createBaseDataDisk();
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.diskType = object.diskType ?? 0;
    message.diskEncryption = object.diskEncryption ?? 0;
    message.kmsKey = object.kmsKey ?? "";
    return message;
  },
};

function createBaseBootDisk(): BootDisk {
  return { diskSizeGb: Long.ZERO, diskType: 0, diskEncryption: 0, kmsKey: "" };
}

export const BootDisk: MessageFns<BootDisk> = {
  encode(message: BootDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.diskSizeGb.toString());
    }
    if (message.diskType !== 0) {
      writer.uint32(16).int32(message.diskType);
    }
    if (message.diskEncryption !== 0) {
      writer.uint32(24).int32(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      writer.uint32(34).string(message.kmsKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BootDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.diskType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.diskEncryption = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BootDisk {
    return {
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      diskType: isSet(object.diskType) ? diskTypeFromJSON(object.diskType) : 0,
      diskEncryption: isSet(object.diskEncryption) ? diskEncryptionFromJSON(object.diskEncryption) : 0,
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
    };
  },

  toJSON(message: BootDisk): unknown {
    const obj: any = {};
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.diskType !== 0) {
      obj.diskType = diskTypeToJSON(message.diskType);
    }
    if (message.diskEncryption !== 0) {
      obj.diskEncryption = diskEncryptionToJSON(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    return obj;
  },

  create(base?: DeepPartial<BootDisk>): BootDisk {
    return BootDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BootDisk>): BootDisk {
    const message = createBaseBootDisk();
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.diskType = object.diskType ?? 0;
    message.diskEncryption = object.diskEncryption ?? 0;
    message.kmsKey = object.kmsKey ?? "";
    return message;
  },
};

function createBaseServiceAccount(): ServiceAccount {
  return { email: "", scopes: [] };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.email = object.email ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGceSetup(): GceSetup {
  return {
    machineType: "",
    acceleratorConfigs: [],
    serviceAccounts: [],
    vmImage: undefined,
    containerImage: undefined,
    bootDisk: undefined,
    dataDisks: [],
    shieldedInstanceConfig: undefined,
    networkInterfaces: [],
    disablePublicIp: false,
    tags: [],
    metadata: {},
    enableIpForwarding: false,
    gpuDriverConfig: undefined,
  };
}

export const GceSetup: MessageFns<GceSetup> = {
  encode(message: GceSetup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    for (const v of message.acceleratorConfigs) {
      AcceleratorConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.serviceAccounts) {
      ServiceAccount.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.vmImage !== undefined) {
      VmImage.encode(message.vmImage, writer.uint32(34).fork()).join();
    }
    if (message.containerImage !== undefined) {
      ContainerImage.encode(message.containerImage, writer.uint32(42).fork()).join();
    }
    if (message.bootDisk !== undefined) {
      BootDisk.encode(message.bootDisk, writer.uint32(50).fork()).join();
    }
    for (const v of message.dataDisks) {
      DataDisk.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(66).fork()).join();
    }
    for (const v of message.networkInterfaces) {
      NetworkInterface.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.disablePublicIp !== false) {
      writer.uint32(80).bool(message.disablePublicIp);
    }
    for (const v of message.tags) {
      writer.uint32(90).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GceSetup_MetadataEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.enableIpForwarding !== false) {
      writer.uint32(104).bool(message.enableIpForwarding);
    }
    if (message.gpuDriverConfig !== undefined) {
      GPUDriverConfig.encode(message.gpuDriverConfig, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GceSetup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGceSetup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.acceleratorConfigs.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceAccounts.push(ServiceAccount.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vmImage = VmImage.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.containerImage = ContainerImage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.bootDisk = BootDisk.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataDisks.push(DataDisk.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.shieldedInstanceConfig = ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.networkInterfaces.push(NetworkInterface.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.disablePublicIp = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = GceSetup_MetadataEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.metadata[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.enableIpForwarding = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gpuDriverConfig = GPUDriverConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GceSetup {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      acceleratorConfigs: globalThis.Array.isArray(object?.acceleratorConfigs)
        ? object.acceleratorConfigs.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      serviceAccounts: globalThis.Array.isArray(object?.serviceAccounts)
        ? object.serviceAccounts.map((e: any) => ServiceAccount.fromJSON(e))
        : [],
      vmImage: isSet(object.vmImage) ? VmImage.fromJSON(object.vmImage) : undefined,
      containerImage: isSet(object.containerImage) ? ContainerImage.fromJSON(object.containerImage) : undefined,
      bootDisk: isSet(object.bootDisk) ? BootDisk.fromJSON(object.bootDisk) : undefined,
      dataDisks: globalThis.Array.isArray(object?.dataDisks)
        ? object.dataDisks.map((e: any) => DataDisk.fromJSON(e))
        : [],
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      networkInterfaces: globalThis.Array.isArray(object?.networkInterfaces)
        ? object.networkInterfaces.map((e: any) => NetworkInterface.fromJSON(e))
        : [],
      disablePublicIp: isSet(object.disablePublicIp) ? globalThis.Boolean(object.disablePublicIp) : false,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      enableIpForwarding: isSet(object.enableIpForwarding) ? globalThis.Boolean(object.enableIpForwarding) : false,
      gpuDriverConfig: isSet(object.gpuDriverConfig) ? GPUDriverConfig.fromJSON(object.gpuDriverConfig) : undefined,
    };
  },

  toJSON(message: GceSetup): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.acceleratorConfigs?.length) {
      obj.acceleratorConfigs = message.acceleratorConfigs.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.serviceAccounts?.length) {
      obj.serviceAccounts = message.serviceAccounts.map((e) => ServiceAccount.toJSON(e));
    }
    if (message.vmImage !== undefined) {
      obj.vmImage = VmImage.toJSON(message.vmImage);
    }
    if (message.containerImage !== undefined) {
      obj.containerImage = ContainerImage.toJSON(message.containerImage);
    }
    if (message.bootDisk !== undefined) {
      obj.bootDisk = BootDisk.toJSON(message.bootDisk);
    }
    if (message.dataDisks?.length) {
      obj.dataDisks = message.dataDisks.map((e) => DataDisk.toJSON(e));
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.networkInterfaces?.length) {
      obj.networkInterfaces = message.networkInterfaces.map((e) => NetworkInterface.toJSON(e));
    }
    if (message.disablePublicIp !== false) {
      obj.disablePublicIp = message.disablePublicIp;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.enableIpForwarding !== false) {
      obj.enableIpForwarding = message.enableIpForwarding;
    }
    if (message.gpuDriverConfig !== undefined) {
      obj.gpuDriverConfig = GPUDriverConfig.toJSON(message.gpuDriverConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<GceSetup>): GceSetup {
    return GceSetup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GceSetup>): GceSetup {
    const message = createBaseGceSetup();
    message.machineType = object.machineType ?? "";
    message.acceleratorConfigs = object.acceleratorConfigs?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.serviceAccounts = object.serviceAccounts?.map((e) => ServiceAccount.fromPartial(e)) || [];
    message.vmImage = (object.vmImage !== undefined && object.vmImage !== null)
      ? VmImage.fromPartial(object.vmImage)
      : undefined;
    message.containerImage = (object.containerImage !== undefined && object.containerImage !== null)
      ? ContainerImage.fromPartial(object.containerImage)
      : undefined;
    message.bootDisk = (object.bootDisk !== undefined && object.bootDisk !== null)
      ? BootDisk.fromPartial(object.bootDisk)
      : undefined;
    message.dataDisks = object.dataDisks?.map((e) => DataDisk.fromPartial(e)) || [];
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.networkInterfaces = object.networkInterfaces?.map((e) => NetworkInterface.fromPartial(e)) || [];
    message.disablePublicIp = object.disablePublicIp ?? false;
    message.tags = object.tags?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.enableIpForwarding = object.enableIpForwarding ?? false;
    message.gpuDriverConfig = (object.gpuDriverConfig !== undefined && object.gpuDriverConfig !== null)
      ? GPUDriverConfig.fromPartial(object.gpuDriverConfig)
      : undefined;
    return message;
  },
};

function createBaseGceSetup_MetadataEntry(): GceSetup_MetadataEntry {
  return { key: "", value: "" };
}

export const GceSetup_MetadataEntry: MessageFns<GceSetup_MetadataEntry> = {
  encode(message: GceSetup_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GceSetup_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGceSetup_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GceSetup_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GceSetup_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GceSetup_MetadataEntry>): GceSetup_MetadataEntry {
    return GceSetup_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GceSetup_MetadataEntry>): GceSetup_MetadataEntry {
    const message = createBaseGceSetup_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
