// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/notebooks/v2/instance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { GceSetup } from "./gce_setup.js";

export const protobufPackage = "google.cloud.notebooks.v2";

/** The definition of the states of this instance. */
export enum State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTING - The control logic is starting the instance. */
  STARTING = 1,
  /**
   * PROVISIONING - The control logic is installing required frameworks and registering the
   * instance with notebook proxy
   */
  PROVISIONING = 2,
  /** ACTIVE - The instance is running. */
  ACTIVE = 3,
  /** STOPPING - The control logic is stopping the instance. */
  STOPPING = 4,
  /** STOPPED - The instance is stopped. */
  STOPPED = 5,
  /** DELETED - The instance is deleted. */
  DELETED = 6,
  /** UPGRADING - The instance is upgrading. */
  UPGRADING = 7,
  /** INITIALIZING - The instance is being created. */
  INITIALIZING = 8,
  /** SUSPENDING - The instance is suspending. */
  SUSPENDING = 9,
  /** SUSPENDED - The instance is suspended. */
  SUSPENDED = 10,
  UNRECOGNIZED = -1,
}

export function stateFromJSON(object: any): State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return State.STATE_UNSPECIFIED;
    case 1:
    case "STARTING":
      return State.STARTING;
    case 2:
    case "PROVISIONING":
      return State.PROVISIONING;
    case 3:
    case "ACTIVE":
      return State.ACTIVE;
    case 4:
    case "STOPPING":
      return State.STOPPING;
    case 5:
    case "STOPPED":
      return State.STOPPED;
    case 6:
    case "DELETED":
      return State.DELETED;
    case 7:
    case "UPGRADING":
      return State.UPGRADING;
    case 8:
    case "INITIALIZING":
      return State.INITIALIZING;
    case 9:
    case "SUSPENDING":
      return State.SUSPENDING;
    case 10:
    case "SUSPENDED":
      return State.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return State.UNRECOGNIZED;
  }
}

export function stateToJSON(object: State): string {
  switch (object) {
    case State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case State.STARTING:
      return "STARTING";
    case State.PROVISIONING:
      return "PROVISIONING";
    case State.ACTIVE:
      return "ACTIVE";
    case State.STOPPING:
      return "STOPPING";
    case State.STOPPED:
      return "STOPPED";
    case State.DELETED:
      return "DELETED";
    case State.UPGRADING:
      return "UPGRADING";
    case State.INITIALIZING:
      return "INITIALIZING";
    case State.SUSPENDING:
      return "SUSPENDING";
    case State.SUSPENDED:
      return "SUSPENDED";
    case State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The instance health state. */
export enum HealthState {
  /** HEALTH_STATE_UNSPECIFIED - The instance substate is unknown. */
  HEALTH_STATE_UNSPECIFIED = 0,
  /**
   * HEALTHY - The instance is known to be in an healthy state
   * (for example, critical daemons are running)
   * Applies to ACTIVE state.
   */
  HEALTHY = 1,
  /**
   * UNHEALTHY - The instance is known to be in an unhealthy state
   * (for example, critical daemons are not running)
   * Applies to ACTIVE state.
   */
  UNHEALTHY = 2,
  /**
   * AGENT_NOT_INSTALLED - The instance has not installed health monitoring agent.
   * Applies to ACTIVE state.
   */
  AGENT_NOT_INSTALLED = 3,
  /**
   * AGENT_NOT_RUNNING - The instance health monitoring agent is not running.
   * Applies to ACTIVE state.
   */
  AGENT_NOT_RUNNING = 4,
  UNRECOGNIZED = -1,
}

export function healthStateFromJSON(object: any): HealthState {
  switch (object) {
    case 0:
    case "HEALTH_STATE_UNSPECIFIED":
      return HealthState.HEALTH_STATE_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return HealthState.HEALTHY;
    case 2:
    case "UNHEALTHY":
      return HealthState.UNHEALTHY;
    case 3:
    case "AGENT_NOT_INSTALLED":
      return HealthState.AGENT_NOT_INSTALLED;
    case 4:
    case "AGENT_NOT_RUNNING":
      return HealthState.AGENT_NOT_RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthState.UNRECOGNIZED;
  }
}

export function healthStateToJSON(object: HealthState): string {
  switch (object) {
    case HealthState.HEALTH_STATE_UNSPECIFIED:
      return "HEALTH_STATE_UNSPECIFIED";
    case HealthState.HEALTHY:
      return "HEALTHY";
    case HealthState.UNHEALTHY:
      return "UNHEALTHY";
    case HealthState.AGENT_NOT_INSTALLED:
      return "AGENT_NOT_INSTALLED";
    case HealthState.AGENT_NOT_RUNNING:
      return "AGENT_NOT_RUNNING";
    case HealthState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The entry of VM image upgrade history. */
export interface UpgradeHistoryEntry {
  /**
   * Optional. The snapshot of the boot disk of this notebook instance before
   * upgrade.
   */
  snapshot: string;
  /** Optional. The VM image before this instance upgrade. */
  vmImage: string;
  /** Optional. The container image before this instance upgrade. */
  containerImage: string;
  /** Optional. The framework of this notebook instance. */
  framework: string;
  /** Optional. The version of the notebook instance before this upgrade. */
  version: string;
  /** Output only. The state of this instance upgrade history entry. */
  state: UpgradeHistoryEntry_State;
  /** Immutable. The time that this instance upgrade history entry is created. */
  createTime:
    | Date
    | undefined;
  /** Optional. Action. Rolloback or Upgrade. */
  action: UpgradeHistoryEntry_Action;
  /** Optional. Target VM Version, like m63. */
  targetVersion: string;
}

/** The definition of the states of this upgrade history entry. */
export enum UpgradeHistoryEntry_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - The instance upgrade is started. */
  STARTED = 1,
  /** SUCCEEDED - The instance upgrade is succeeded. */
  SUCCEEDED = 2,
  /** FAILED - The instance upgrade is failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function upgradeHistoryEntry_StateFromJSON(object: any): UpgradeHistoryEntry_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return UpgradeHistoryEntry_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return UpgradeHistoryEntry_State.STARTED;
    case 2:
    case "SUCCEEDED":
      return UpgradeHistoryEntry_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return UpgradeHistoryEntry_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeHistoryEntry_State.UNRECOGNIZED;
  }
}

export function upgradeHistoryEntry_StateToJSON(object: UpgradeHistoryEntry_State): string {
  switch (object) {
    case UpgradeHistoryEntry_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case UpgradeHistoryEntry_State.STARTED:
      return "STARTED";
    case UpgradeHistoryEntry_State.SUCCEEDED:
      return "SUCCEEDED";
    case UpgradeHistoryEntry_State.FAILED:
      return "FAILED";
    case UpgradeHistoryEntry_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of operations of this upgrade history entry. */
export enum UpgradeHistoryEntry_Action {
  /** ACTION_UNSPECIFIED - Operation is not specified. */
  ACTION_UNSPECIFIED = 0,
  /** UPGRADE - Upgrade. */
  UPGRADE = 1,
  /** ROLLBACK - Rollback. */
  ROLLBACK = 2,
  UNRECOGNIZED = -1,
}

export function upgradeHistoryEntry_ActionFromJSON(object: any): UpgradeHistoryEntry_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED;
    case 1:
    case "UPGRADE":
      return UpgradeHistoryEntry_Action.UPGRADE;
    case 2:
    case "ROLLBACK":
      return UpgradeHistoryEntry_Action.ROLLBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeHistoryEntry_Action.UNRECOGNIZED;
  }
}

export function upgradeHistoryEntry_ActionToJSON(object: UpgradeHistoryEntry_Action): string {
  switch (object) {
    case UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case UpgradeHistoryEntry_Action.UPGRADE:
      return "UPGRADE";
    case UpgradeHistoryEntry_Action.ROLLBACK:
      return "ROLLBACK";
    case UpgradeHistoryEntry_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of a notebook instance. */
export interface Instance {
  /**
   * Output only. The name of this notebook instance. Format:
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`
   */
  name: string;
  /**
   * Optional. Compute Engine setup for the notebook. Uses notebook-defined
   * fields.
   */
  gceSetup?:
    | GceSetup
    | undefined;
  /**
   * Output only. The proxy endpoint that is used to access the Jupyter
   * notebook.
   */
  proxyUri: string;
  /**
   * Optional. Input only. The owner of this instance after creation. Format:
   * `alias@example.com`
   *
   * Currently supports one owner only. If not specified, all of the service
   * account users of your VM instance's service account can use
   * the instance.
   */
  instanceOwners: string[];
  /**
   * Output only. Email address of entity that sent original CreateInstance
   * request.
   */
  creator: string;
  /** Output only. The state of this instance. */
  state: State;
  /** Output only. The upgrade history of this instance. */
  upgradeHistory: UpgradeHistoryEntry[];
  /** Output only. Unique ID of the resource. */
  id: string;
  /** Output only. Instance health_state. */
  healthState: HealthState;
  /**
   * Output only. Additional information about instance health.
   * Example:
   *
   *     healthInfo": {
   *       "docker_proxy_agent_status": "1",
   *       "docker_status": "1",
   *       "jupyterlab_api_status": "-1",
   *       "jupyterlab_status": "-1",
   *       "updated": "2020-10-18 09:40:03.573409"
   *     }
   */
  healthInfo: { [key: string]: string };
  /** Output only. Instance creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. Instance update time. */
  updateTime:
    | Date
    | undefined;
  /** Optional. If true, the notebook instance will not register with the proxy. */
  disableProxyAccess: boolean;
  /**
   * Optional. Labels to apply to this instance.
   * These can be later modified by the UpdateInstance method.
   */
  labels: { [key: string]: string };
}

export interface Instance_HealthInfoEntry {
  key: string;
  value: string;
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

function createBaseUpgradeHistoryEntry(): UpgradeHistoryEntry {
  return {
    snapshot: "",
    vmImage: "",
    containerImage: "",
    framework: "",
    version: "",
    state: 0,
    createTime: undefined,
    action: 0,
    targetVersion: "",
  };
}

export const UpgradeHistoryEntry: MessageFns<UpgradeHistoryEntry> = {
  encode(message: UpgradeHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshot !== "") {
      writer.uint32(10).string(message.snapshot);
    }
    if (message.vmImage !== "") {
      writer.uint32(18).string(message.vmImage);
    }
    if (message.containerImage !== "") {
      writer.uint32(26).string(message.containerImage);
    }
    if (message.framework !== "") {
      writer.uint32(34).string(message.framework);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(64).int32(message.action);
    }
    if (message.targetVersion !== "") {
      writer.uint32(74).string(message.targetVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snapshot = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vmImage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.framework = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeHistoryEntry {
    return {
      snapshot: isSet(object.snapshot) ? globalThis.String(object.snapshot) : "",
      vmImage: isSet(object.vmImage) ? globalThis.String(object.vmImage) : "",
      containerImage: isSet(object.containerImage) ? globalThis.String(object.containerImage) : "",
      framework: isSet(object.framework) ? globalThis.String(object.framework) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? upgradeHistoryEntry_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      action: isSet(object.action) ? upgradeHistoryEntry_ActionFromJSON(object.action) : 0,
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
    };
  },

  toJSON(message: UpgradeHistoryEntry): unknown {
    const obj: any = {};
    if (message.snapshot !== "") {
      obj.snapshot = message.snapshot;
    }
    if (message.vmImage !== "") {
      obj.vmImage = message.vmImage;
    }
    if (message.containerImage !== "") {
      obj.containerImage = message.containerImage;
    }
    if (message.framework !== "") {
      obj.framework = message.framework;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = upgradeHistoryEntry_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.action !== 0) {
      obj.action = upgradeHistoryEntry_ActionToJSON(message.action);
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeHistoryEntry>): UpgradeHistoryEntry {
    return UpgradeHistoryEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeHistoryEntry>): UpgradeHistoryEntry {
    const message = createBaseUpgradeHistoryEntry();
    message.snapshot = object.snapshot ?? "";
    message.vmImage = object.vmImage ?? "";
    message.containerImage = object.containerImage ?? "";
    message.framework = object.framework ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.action = object.action ?? 0;
    message.targetVersion = object.targetVersion ?? "";
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    gceSetup: undefined,
    proxyUri: "",
    instanceOwners: [],
    creator: "",
    state: 0,
    upgradeHistory: [],
    id: "",
    healthState: 0,
    healthInfo: {},
    createTime: undefined,
    updateTime: undefined,
    disableProxyAccess: false,
    labels: {},
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.gceSetup !== undefined) {
      GceSetup.encode(message.gceSetup, writer.uint32(18).fork()).join();
    }
    if (message.proxyUri !== "") {
      writer.uint32(26).string(message.proxyUri);
    }
    for (const v of message.instanceOwners) {
      writer.uint32(34).string(v!);
    }
    if (message.creator !== "") {
      writer.uint32(42).string(message.creator);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    for (const v of message.upgradeHistory) {
      UpgradeHistoryEntry.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.healthState !== 0) {
      writer.uint32(72).int32(message.healthState);
    }
    Object.entries(message.healthInfo).forEach(([key, value]) => {
      Instance_HealthInfoEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.disableProxyAccess !== false) {
      writer.uint32(104).bool(message.disableProxyAccess);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gceSetup = GceSetup.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proxyUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instanceOwners.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.upgradeHistory.push(UpgradeHistoryEntry.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.healthState = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Instance_HealthInfoEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.healthInfo[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.disableProxyAccess = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      gceSetup: isSet(object.gceSetup) ? GceSetup.fromJSON(object.gceSetup) : undefined,
      proxyUri: isSet(object.proxyUri) ? globalThis.String(object.proxyUri) : "",
      instanceOwners: globalThis.Array.isArray(object?.instanceOwners)
        ? object.instanceOwners.map((e: any) => globalThis.String(e))
        : [],
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : 0,
      upgradeHistory: globalThis.Array.isArray(object?.upgradeHistory)
        ? object.upgradeHistory.map((e: any) => UpgradeHistoryEntry.fromJSON(e))
        : [],
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      healthState: isSet(object.healthState) ? healthStateFromJSON(object.healthState) : 0,
      healthInfo: isObject(object.healthInfo)
        ? Object.entries(object.healthInfo).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      disableProxyAccess: isSet(object.disableProxyAccess) ? globalThis.Boolean(object.disableProxyAccess) : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.gceSetup !== undefined) {
      obj.gceSetup = GceSetup.toJSON(message.gceSetup);
    }
    if (message.proxyUri !== "") {
      obj.proxyUri = message.proxyUri;
    }
    if (message.instanceOwners?.length) {
      obj.instanceOwners = message.instanceOwners;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.state !== 0) {
      obj.state = stateToJSON(message.state);
    }
    if (message.upgradeHistory?.length) {
      obj.upgradeHistory = message.upgradeHistory.map((e) => UpgradeHistoryEntry.toJSON(e));
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.healthState !== 0) {
      obj.healthState = healthStateToJSON(message.healthState);
    }
    if (message.healthInfo) {
      const entries = Object.entries(message.healthInfo);
      if (entries.length > 0) {
        obj.healthInfo = {};
        entries.forEach(([k, v]) => {
          obj.healthInfo[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.disableProxyAccess !== false) {
      obj.disableProxyAccess = message.disableProxyAccess;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.gceSetup = (object.gceSetup !== undefined && object.gceSetup !== null)
      ? GceSetup.fromPartial(object.gceSetup)
      : undefined;
    message.proxyUri = object.proxyUri ?? "";
    message.instanceOwners = object.instanceOwners?.map((e) => e) || [];
    message.creator = object.creator ?? "";
    message.state = object.state ?? 0;
    message.upgradeHistory = object.upgradeHistory?.map((e) => UpgradeHistoryEntry.fromPartial(e)) || [];
    message.id = object.id ?? "";
    message.healthState = object.healthState ?? 0;
    message.healthInfo = Object.entries(object.healthInfo ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.disableProxyAccess = object.disableProxyAccess ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseInstance_HealthInfoEntry(): Instance_HealthInfoEntry {
  return { key: "", value: "" };
}

export const Instance_HealthInfoEntry: MessageFns<Instance_HealthInfoEntry> = {
  encode(message: Instance_HealthInfoEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_HealthInfoEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_HealthInfoEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_HealthInfoEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_HealthInfoEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_HealthInfoEntry>): Instance_HealthInfoEntry {
    return Instance_HealthInfoEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_HealthInfoEntry>): Instance_HealthInfoEntry {
    const message = createBaseInstance_HealthInfoEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
