// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/notebooks/v1/instance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { ContainerImage, VmImage } from "./environment.js";

export const protobufPackage = "google.cloud.notebooks.v1";

/** Reservation Affinity for consuming Zonal reservation. */
export interface ReservationAffinity {
  /** Optional. Type of reservation to consume */
  consumeReservationType: ReservationAffinity_Type;
  /** Optional. Corresponds to the label key of reservation resource. */
  key: string;
  /** Optional. Corresponds to the label values of reservation resource. */
  values: string[];
}

/** Indicates whether to consume capacity from an reservation or not. */
export enum ReservationAffinity_Type {
  /** TYPE_UNSPECIFIED - Default type. */
  TYPE_UNSPECIFIED = 0,
  /** NO_RESERVATION - Do not consume from any allocated capacity. */
  NO_RESERVATION = 1,
  /** ANY_RESERVATION - Consume any reservation available. */
  ANY_RESERVATION = 2,
  /**
   * SPECIFIC_RESERVATION - Must consume from a specific reservation. Must specify key value fields
   * for specifying the reservations.
   */
  SPECIFIC_RESERVATION = 3,
  UNRECOGNIZED = -1,
}

export function reservationAffinity_TypeFromJSON(object: any): ReservationAffinity_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ReservationAffinity_Type.TYPE_UNSPECIFIED;
    case 1:
    case "NO_RESERVATION":
      return ReservationAffinity_Type.NO_RESERVATION;
    case 2:
    case "ANY_RESERVATION":
      return ReservationAffinity_Type.ANY_RESERVATION;
    case 3:
    case "SPECIFIC_RESERVATION":
      return ReservationAffinity_Type.SPECIFIC_RESERVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReservationAffinity_Type.UNRECOGNIZED;
  }
}

export function reservationAffinity_TypeToJSON(object: ReservationAffinity_Type): string {
  switch (object) {
    case ReservationAffinity_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ReservationAffinity_Type.NO_RESERVATION:
      return "NO_RESERVATION";
    case ReservationAffinity_Type.ANY_RESERVATION:
      return "ANY_RESERVATION";
    case ReservationAffinity_Type.SPECIFIC_RESERVATION:
      return "SPECIFIC_RESERVATION";
    case ReservationAffinity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of a notebook instance. */
export interface Instance {
  /**
   * Output only. The name of this notebook instance. Format:
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`
   */
  name: string;
  /** Use a Compute Engine VM image to start the notebook instance. */
  vmImage?:
    | VmImage
    | undefined;
  /** Use a container image to start the notebook instance. */
  containerImage?:
    | ContainerImage
    | undefined;
  /**
   * Path to a Bash script that automatically runs after a notebook instance
   * fully boots up. The path must be a URL or
   * Cloud Storage path (`gs://path-to-file/file-name`).
   */
  postStartupScript: string;
  /** Output only. The proxy endpoint that is used to access the Jupyter notebook. */
  proxyUri: string;
  /**
   * Input only. The owner of this instance after creation. Format: `alias@example.com`
   *
   * Currently supports one owner only. If not specified, all of the service
   * account users of your VM instance's service account can use
   * the instance.
   */
  instanceOwners: string[];
  /**
   * The service account on this instance, giving access to other Google
   * Cloud services.
   * You can use any service account within the same project, but you
   * must have the service account user permission to use the instance.
   *
   * If not specified, the [Compute Engine default service
   * account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
   * is used.
   */
  serviceAccount: string;
  /**
   * Optional. The URIs of service account scopes to be included in
   * Compute Engine instances.
   *
   * If not specified, the following
   * [scopes](https://cloud.google.com/compute/docs/access/service-accounts#accesscopesiam)
   * are defined:
   *  - https://www.googleapis.com/auth/cloud-platform
   *  - https://www.googleapis.com/auth/userinfo.email
   * If not using default scopes, you need at least:
   *    https://www.googleapis.com/auth/compute
   */
  serviceAccountScopes: string[];
  /**
   * Required. The [Compute Engine machine
   * type](https://cloud.google.com/compute/docs/machine-types) of this
   * instance.
   */
  machineType: string;
  /**
   * The hardware accelerator used on this instance. If you use
   * accelerators, make sure that your configuration has
   * [enough vCPUs and memory to support the `machine_type` you have
   * selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
   */
  acceleratorConfig:
    | Instance_AcceleratorConfig
    | undefined;
  /** Output only. The state of this instance. */
  state: Instance_State;
  /**
   * Whether the end user authorizes Google Cloud to install GPU driver
   * on this instance.
   * If this field is empty or set to false, the GPU driver won't be installed.
   * Only applicable to instances with GPUs.
   */
  installGpuDriver: boolean;
  /**
   * Specify a custom Cloud Storage path where the GPU driver is stored.
   * If not specified, we'll automatically choose from official GPU drivers.
   */
  customGpuDriverPath: string;
  /**
   * Input only. The type of the boot disk attached to this instance, defaults to
   * standard persistent disk (`PD_STANDARD`).
   */
  bootDiskType: Instance_DiskType;
  /**
   * Input only. The size of the boot disk in GB attached to this instance, up to a maximum
   * of 64000 GB (64 TB). The minimum recommended value is 100 GB. If not
   * specified, this defaults to 100.
   */
  bootDiskSizeGb: Long;
  /**
   * Input only. The type of the data disk attached to this instance, defaults to
   * standard persistent disk (`PD_STANDARD`).
   */
  dataDiskType: Instance_DiskType;
  /**
   * Input only. The size of the data disk in GB attached to this instance, up to a maximum
   * of 64000 GB (64 TB). You can choose the size of the data disk based on how
   * big your notebooks and data are. If not specified, this defaults to 100.
   */
  dataDiskSizeGb: Long;
  /** Input only. If true, the data disk will not be auto deleted when deleting the instance. */
  noRemoveDataDisk: boolean;
  /** Input only. Disk encryption method used on the boot and data disks, defaults to GMEK. */
  diskEncryption: Instance_DiskEncryption;
  /**
   * Input only. The KMS key used to encrypt the disks, only applicable if disk_encryption
   * is CMEK.
   * Format:
   * `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
   *
   * Learn more about [using your own encryption keys](/kms/docs/quickstart).
   */
  kmsKey: string;
  /** Output only. Attached disks to notebook instance. */
  disks: Instance_Disk[];
  /**
   * Optional. Shielded VM configuration.
   * [Images using supported Shielded VM
   * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
   */
  shieldedInstanceConfig:
    | Instance_ShieldedInstanceConfig
    | undefined;
  /** If true, no public IP will be assigned to this instance. */
  noPublicIp: boolean;
  /** If true, the notebook instance will not register with the proxy. */
  noProxyAccess: boolean;
  /**
   * The name of the VPC that this instance is in.
   * Format:
   * `projects/{project_id}/global/networks/{network_id}`
   */
  network: string;
  /**
   * The name of the subnet that this instance is in.
   * Format:
   * `projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}`
   */
  subnet: string;
  /**
   * Labels to apply to this instance.
   * These can be later modified by the setLabels method.
   */
  labels: { [key: string]: string };
  /** Custom metadata to apply to this instance. */
  metadata: { [key: string]: string };
  /**
   * Optional. The Compute Engine tags to add to runtime (see [Tagging
   * instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
   */
  tags: string[];
  /** The upgrade history of this instance. */
  upgradeHistory: Instance_UpgradeHistoryEntry[];
  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC or
   * VirtioNet.
   */
  nicType: Instance_NicType;
  /**
   * Optional. The optional reservation affinity. Setting this field will apply
   * the specified [Zonal Compute
   * Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
   * to this notebook instance.
   */
  reservationAffinity:
    | ReservationAffinity
    | undefined;
  /** Output only. Email address of entity that sent original CreateInstance request. */
  creator: string;
  /**
   * Optional. Flag to enable ip forwarding or not, default false/off.
   * https://cloud.google.com/vpc/docs/using-routes#canipforward
   */
  canIpForward: boolean;
  /** Output only. Instance creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. Instance update time. */
  updateTime: Date | undefined;
}

/**
 * Definition of the types of hardware accelerators that can be used on this
 * instance.
 */
export enum Instance_AcceleratorType {
  /** ACCELERATOR_TYPE_UNSPECIFIED - Accelerator type is not specified. */
  ACCELERATOR_TYPE_UNSPECIFIED = 0,
  /** NVIDIA_TESLA_K80 - Accelerator type is Nvidia Tesla K80. */
  NVIDIA_TESLA_K80 = 1,
  /** NVIDIA_TESLA_P100 - Accelerator type is Nvidia Tesla P100. */
  NVIDIA_TESLA_P100 = 2,
  /** NVIDIA_TESLA_V100 - Accelerator type is Nvidia Tesla V100. */
  NVIDIA_TESLA_V100 = 3,
  /** NVIDIA_TESLA_P4 - Accelerator type is Nvidia Tesla P4. */
  NVIDIA_TESLA_P4 = 4,
  /** NVIDIA_TESLA_T4 - Accelerator type is Nvidia Tesla T4. */
  NVIDIA_TESLA_T4 = 5,
  /** NVIDIA_TESLA_A100 - Accelerator type is Nvidia Tesla A100. */
  NVIDIA_TESLA_A100 = 11,
  /** NVIDIA_TESLA_T4_VWS - Accelerator type is NVIDIA Tesla T4 Virtual Workstations. */
  NVIDIA_TESLA_T4_VWS = 8,
  /** NVIDIA_TESLA_P100_VWS - Accelerator type is NVIDIA Tesla P100 Virtual Workstations. */
  NVIDIA_TESLA_P100_VWS = 9,
  /** NVIDIA_TESLA_P4_VWS - Accelerator type is NVIDIA Tesla P4 Virtual Workstations. */
  NVIDIA_TESLA_P4_VWS = 10,
  /** TPU_V2 - (Coming soon) Accelerator type is TPU V2. */
  TPU_V2 = 6,
  /** TPU_V3 - (Coming soon) Accelerator type is TPU V3. */
  TPU_V3 = 7,
  UNRECOGNIZED = -1,
}

export function instance_AcceleratorTypeFromJSON(object: any): Instance_AcceleratorType {
  switch (object) {
    case 0:
    case "ACCELERATOR_TYPE_UNSPECIFIED":
      return Instance_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED;
    case 1:
    case "NVIDIA_TESLA_K80":
      return Instance_AcceleratorType.NVIDIA_TESLA_K80;
    case 2:
    case "NVIDIA_TESLA_P100":
      return Instance_AcceleratorType.NVIDIA_TESLA_P100;
    case 3:
    case "NVIDIA_TESLA_V100":
      return Instance_AcceleratorType.NVIDIA_TESLA_V100;
    case 4:
    case "NVIDIA_TESLA_P4":
      return Instance_AcceleratorType.NVIDIA_TESLA_P4;
    case 5:
    case "NVIDIA_TESLA_T4":
      return Instance_AcceleratorType.NVIDIA_TESLA_T4;
    case 11:
    case "NVIDIA_TESLA_A100":
      return Instance_AcceleratorType.NVIDIA_TESLA_A100;
    case 8:
    case "NVIDIA_TESLA_T4_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_T4_VWS;
    case 9:
    case "NVIDIA_TESLA_P100_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_P100_VWS;
    case 10:
    case "NVIDIA_TESLA_P4_VWS":
      return Instance_AcceleratorType.NVIDIA_TESLA_P4_VWS;
    case 6:
    case "TPU_V2":
      return Instance_AcceleratorType.TPU_V2;
    case 7:
    case "TPU_V3":
      return Instance_AcceleratorType.TPU_V3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_AcceleratorType.UNRECOGNIZED;
  }
}

export function instance_AcceleratorTypeToJSON(object: Instance_AcceleratorType): string {
  switch (object) {
    case Instance_AcceleratorType.ACCELERATOR_TYPE_UNSPECIFIED:
      return "ACCELERATOR_TYPE_UNSPECIFIED";
    case Instance_AcceleratorType.NVIDIA_TESLA_K80:
      return "NVIDIA_TESLA_K80";
    case Instance_AcceleratorType.NVIDIA_TESLA_P100:
      return "NVIDIA_TESLA_P100";
    case Instance_AcceleratorType.NVIDIA_TESLA_V100:
      return "NVIDIA_TESLA_V100";
    case Instance_AcceleratorType.NVIDIA_TESLA_P4:
      return "NVIDIA_TESLA_P4";
    case Instance_AcceleratorType.NVIDIA_TESLA_T4:
      return "NVIDIA_TESLA_T4";
    case Instance_AcceleratorType.NVIDIA_TESLA_A100:
      return "NVIDIA_TESLA_A100";
    case Instance_AcceleratorType.NVIDIA_TESLA_T4_VWS:
      return "NVIDIA_TESLA_T4_VWS";
    case Instance_AcceleratorType.NVIDIA_TESLA_P100_VWS:
      return "NVIDIA_TESLA_P100_VWS";
    case Instance_AcceleratorType.NVIDIA_TESLA_P4_VWS:
      return "NVIDIA_TESLA_P4_VWS";
    case Instance_AcceleratorType.TPU_V2:
      return "TPU_V2";
    case Instance_AcceleratorType.TPU_V3:
      return "TPU_V3";
    case Instance_AcceleratorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of the states of this instance. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTING - The control logic is starting the instance. */
  STARTING = 1,
  /**
   * PROVISIONING - The control logic is installing required frameworks and registering the
   * instance with notebook proxy
   */
  PROVISIONING = 2,
  /** ACTIVE - The instance is running. */
  ACTIVE = 3,
  /** STOPPING - The control logic is stopping the instance. */
  STOPPING = 4,
  /** STOPPED - The instance is stopped. */
  STOPPED = 5,
  /** DELETED - The instance is deleted. */
  DELETED = 6,
  /** UPGRADING - The instance is upgrading. */
  UPGRADING = 7,
  /** INITIALIZING - The instance is being created. */
  INITIALIZING = 8,
  /** REGISTERING - The instance is getting registered. */
  REGISTERING = 9,
  /** SUSPENDING - The instance is suspending. */
  SUSPENDING = 10,
  /** SUSPENDED - The instance is suspended. */
  SUSPENDED = 11,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTING":
      return Instance_State.STARTING;
    case 2:
    case "PROVISIONING":
      return Instance_State.PROVISIONING;
    case 3:
    case "ACTIVE":
      return Instance_State.ACTIVE;
    case 4:
    case "STOPPING":
      return Instance_State.STOPPING;
    case 5:
    case "STOPPED":
      return Instance_State.STOPPED;
    case 6:
    case "DELETED":
      return Instance_State.DELETED;
    case 7:
    case "UPGRADING":
      return Instance_State.UPGRADING;
    case 8:
    case "INITIALIZING":
      return Instance_State.INITIALIZING;
    case 9:
    case "REGISTERING":
      return Instance_State.REGISTERING;
    case 10:
    case "SUSPENDING":
      return Instance_State.SUSPENDING;
    case 11:
    case "SUSPENDED":
      return Instance_State.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.STARTING:
      return "STARTING";
    case Instance_State.PROVISIONING:
      return "PROVISIONING";
    case Instance_State.ACTIVE:
      return "ACTIVE";
    case Instance_State.STOPPING:
      return "STOPPING";
    case Instance_State.STOPPED:
      return "STOPPED";
    case Instance_State.DELETED:
      return "DELETED";
    case Instance_State.UPGRADING:
      return "UPGRADING";
    case Instance_State.INITIALIZING:
      return "INITIALIZING";
    case Instance_State.REGISTERING:
      return "REGISTERING";
    case Instance_State.SUSPENDING:
      return "SUSPENDING";
    case Instance_State.SUSPENDED:
      return "SUSPENDED";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible disk types for notebook instances. */
export enum Instance_DiskType {
  /** DISK_TYPE_UNSPECIFIED - Disk type not set. */
  DISK_TYPE_UNSPECIFIED = 0,
  /** PD_STANDARD - Standard persistent disk type. */
  PD_STANDARD = 1,
  /** PD_SSD - SSD persistent disk type. */
  PD_SSD = 2,
  /** PD_BALANCED - Balanced persistent disk type. */
  PD_BALANCED = 3,
  /** PD_EXTREME - Extreme persistent disk type. */
  PD_EXTREME = 4,
  UNRECOGNIZED = -1,
}

export function instance_DiskTypeFromJSON(object: any): Instance_DiskType {
  switch (object) {
    case 0:
    case "DISK_TYPE_UNSPECIFIED":
      return Instance_DiskType.DISK_TYPE_UNSPECIFIED;
    case 1:
    case "PD_STANDARD":
      return Instance_DiskType.PD_STANDARD;
    case 2:
    case "PD_SSD":
      return Instance_DiskType.PD_SSD;
    case 3:
    case "PD_BALANCED":
      return Instance_DiskType.PD_BALANCED;
    case 4:
    case "PD_EXTREME":
      return Instance_DiskType.PD_EXTREME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_DiskType.UNRECOGNIZED;
  }
}

export function instance_DiskTypeToJSON(object: Instance_DiskType): string {
  switch (object) {
    case Instance_DiskType.DISK_TYPE_UNSPECIFIED:
      return "DISK_TYPE_UNSPECIFIED";
    case Instance_DiskType.PD_STANDARD:
      return "PD_STANDARD";
    case Instance_DiskType.PD_SSD:
      return "PD_SSD";
    case Instance_DiskType.PD_BALANCED:
      return "PD_BALANCED";
    case Instance_DiskType.PD_EXTREME:
      return "PD_EXTREME";
    case Instance_DiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Definition of the disk encryption options. */
export enum Instance_DiskEncryption {
  /** DISK_ENCRYPTION_UNSPECIFIED - Disk encryption is not specified. */
  DISK_ENCRYPTION_UNSPECIFIED = 0,
  /** GMEK - Use Google managed encryption keys to encrypt the boot disk. */
  GMEK = 1,
  /** CMEK - Use customer managed encryption keys to encrypt the boot disk. */
  CMEK = 2,
  UNRECOGNIZED = -1,
}

export function instance_DiskEncryptionFromJSON(object: any): Instance_DiskEncryption {
  switch (object) {
    case 0:
    case "DISK_ENCRYPTION_UNSPECIFIED":
      return Instance_DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED;
    case 1:
    case "GMEK":
      return Instance_DiskEncryption.GMEK;
    case 2:
    case "CMEK":
      return Instance_DiskEncryption.CMEK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_DiskEncryption.UNRECOGNIZED;
  }
}

export function instance_DiskEncryptionToJSON(object: Instance_DiskEncryption): string {
  switch (object) {
    case Instance_DiskEncryption.DISK_ENCRYPTION_UNSPECIFIED:
      return "DISK_ENCRYPTION_UNSPECIFIED";
    case Instance_DiskEncryption.GMEK:
      return "GMEK";
    case Instance_DiskEncryption.CMEK:
      return "CMEK";
    case Instance_DiskEncryption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The type of vNIC driver.
 * Default should be UNSPECIFIED_NIC_TYPE.
 */
export enum Instance_NicType {
  /** UNSPECIFIED_NIC_TYPE - No type specified. */
  UNSPECIFIED_NIC_TYPE = 0,
  /** VIRTIO_NET - VIRTIO */
  VIRTIO_NET = 1,
  /** GVNIC - GVNIC */
  GVNIC = 2,
  UNRECOGNIZED = -1,
}

export function instance_NicTypeFromJSON(object: any): Instance_NicType {
  switch (object) {
    case 0:
    case "UNSPECIFIED_NIC_TYPE":
      return Instance_NicType.UNSPECIFIED_NIC_TYPE;
    case 1:
    case "VIRTIO_NET":
      return Instance_NicType.VIRTIO_NET;
    case 2:
    case "GVNIC":
      return Instance_NicType.GVNIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_NicType.UNRECOGNIZED;
  }
}

export function instance_NicTypeToJSON(object: Instance_NicType): string {
  switch (object) {
    case Instance_NicType.UNSPECIFIED_NIC_TYPE:
      return "UNSPECIFIED_NIC_TYPE";
    case Instance_NicType.VIRTIO_NET:
      return "VIRTIO_NET";
    case Instance_NicType.GVNIC:
      return "GVNIC";
    case Instance_NicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Definition of a hardware accelerator. Note that not all combinations
 * of `type` and `core_count` are valid. Check [GPUs on Compute
 * Engine](https://cloud.google.com/compute/docs/gpus/#gpus-list) to find a
 * valid combination. TPUs are not supported.
 */
export interface Instance_AcceleratorConfig {
  /** Type of this accelerator. */
  type: Instance_AcceleratorType;
  /** Count of cores of this accelerator. */
  coreCount: Long;
}

/** An instance-attached disk resource. */
export interface Instance_Disk {
  /**
   * Indicates whether the disk will be auto-deleted when the instance is
   * deleted (but not when the disk is detached from the instance).
   */
  autoDelete: boolean;
  /**
   * Indicates that this is a boot disk. The virtual machine will use the
   * first partition of the disk for its root filesystem.
   */
  boot: boolean;
  /**
   * Indicates a unique device name of your choice that is reflected into the
   * `/dev/disk/by-id/google-*` tree of a Linux operating system running
   * within the instance. This name can be used to reference the device for
   * mounting, resizing, and so on, from within the instance.
   *
   * If not specified, the server chooses a default device name to apply to
   * this disk, in the form persistent-disk-x, where x is a number assigned by
   * Google Compute Engine.This field is only applicable for persistent disks.
   */
  deviceName: string;
  /** Indicates the size of the disk in base-2 GB. */
  diskSizeGb: Long;
  /**
   * Indicates a list of features to enable on the guest operating system.
   * Applicable only for bootable images. Read  Enabling guest operating
   * system features to see a list of available options.
   */
  guestOsFeatures: Instance_Disk_GuestOsFeature[];
  /**
   * A zero-based index to this disk, where 0 is reserved for the
   * boot disk. If you have many disks attached to an instance, each disk
   * would have a unique index number.
   */
  index: Long;
  /**
   * Indicates the disk interface to use for attaching this disk, which is
   * either SCSI or NVME. The default is SCSI. Persistent disks must always
   * use SCSI and the request will fail if you attempt to attach a persistent
   * disk in any other format than SCSI. Local SSDs can use either NVME or
   * SCSI. For performance characteristics of SCSI over NVMe, see Local SSD
   * performance.
   * Valid values:
   *
   * * `NVME`
   * * `SCSI`
   */
  interface: string;
  /**
   * Type of the resource. Always compute#attachedDisk for attached
   * disks.
   */
  kind: string;
  /**
   * A list of publicly visible licenses. Reserved for Google's use.
   * A License represents billing and aggregate usage data for public
   * and marketplace images.
   */
  licenses: string[];
  /**
   * The mode in which to attach this disk, either `READ_WRITE` or
   * `READ_ONLY`. If not specified, the default is to attach the disk in
   * `READ_WRITE` mode. Valid values:
   *
   * * `READ_ONLY`
   * * `READ_WRITE`
   */
  mode: string;
  /**
   * Indicates a valid partial or full URL to an existing Persistent Disk
   * resource.
   */
  source: string;
  /**
   * Indicates the type of the disk, either `SCRATCH` or `PERSISTENT`.
   * Valid values:
   *
   * * `PERSISTENT`
   * * `SCRATCH`
   */
  type: string;
}

/** Guest OS features for boot disk. */
export interface Instance_Disk_GuestOsFeature {
  /**
   * The ID of a supported feature. Read  Enabling guest operating system
   * features to see a list of available options.
   * Valid values:
   *
   * * `FEATURE_TYPE_UNSPECIFIED`
   * * `MULTI_IP_SUBNET`
   * * `SECURE_BOOT`
   * * `UEFI_COMPATIBLE`
   * * `VIRTIO_SCSI_MULTIQUEUE`
   * * `WINDOWS`
   */
  type: string;
}

/**
 * A set of Shielded Instance options.
 * Check [Images using supported Shielded VM
 * features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
 * Not all combinations are valid.
 */
export interface Instance_ShieldedInstanceConfig {
  /**
   * Defines whether the instance has Secure Boot enabled.
   *
   * Secure Boot helps ensure that the system only runs authentic software by
   * verifying the digital signature of all boot components, and halting the
   * boot process if signature verification fails. Disabled by default.
   */
  enableSecureBoot: boolean;
  /** Defines whether the instance has the vTPM enabled. Enabled by default. */
  enableVtpm: boolean;
  /**
   * Defines whether the instance has integrity monitoring enabled.
   *
   * Enables monitoring and attestation of the boot integrity of the instance.
   * The attestation is performed against the integrity policy baseline. This
   * baseline is initially derived from the implicitly trusted boot image when
   * the instance is created. Enabled by default.
   */
  enableIntegrityMonitoring: boolean;
}

/** The entry of VM image upgrade history. */
export interface Instance_UpgradeHistoryEntry {
  /** The snapshot of the boot disk of this notebook instance before upgrade. */
  snapshot: string;
  /** The VM image before this instance upgrade. */
  vmImage: string;
  /** The container image before this instance upgrade. */
  containerImage: string;
  /** The framework of this notebook instance. */
  framework: string;
  /** The version of the notebook instance before this upgrade. */
  version: string;
  /** The state of this instance upgrade history entry. */
  state: Instance_UpgradeHistoryEntry_State;
  /** The time that this instance upgrade history entry is created. */
  createTime:
    | Date
    | undefined;
  /**
   * Target VM Image. Format: `ainotebooks-vm/project/image-name/name`.
   *
   * @deprecated
   */
  targetImage: string;
  /** Action. Rolloback or Upgrade. */
  action: Instance_UpgradeHistoryEntry_Action;
  /** Target VM Version, like m63. */
  targetVersion: string;
}

/** The definition of the states of this upgrade history entry. */
export enum Instance_UpgradeHistoryEntry_State {
  /** STATE_UNSPECIFIED - State is not specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - The instance upgrade is started. */
  STARTED = 1,
  /** SUCCEEDED - The instance upgrade is succeeded. */
  SUCCEEDED = 2,
  /** FAILED - The instance upgrade is failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function instance_UpgradeHistoryEntry_StateFromJSON(object: any): Instance_UpgradeHistoryEntry_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_UpgradeHistoryEntry_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return Instance_UpgradeHistoryEntry_State.STARTED;
    case 2:
    case "SUCCEEDED":
      return Instance_UpgradeHistoryEntry_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return Instance_UpgradeHistoryEntry_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_UpgradeHistoryEntry_State.UNRECOGNIZED;
  }
}

export function instance_UpgradeHistoryEntry_StateToJSON(object: Instance_UpgradeHistoryEntry_State): string {
  switch (object) {
    case Instance_UpgradeHistoryEntry_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_UpgradeHistoryEntry_State.STARTED:
      return "STARTED";
    case Instance_UpgradeHistoryEntry_State.SUCCEEDED:
      return "SUCCEEDED";
    case Instance_UpgradeHistoryEntry_State.FAILED:
      return "FAILED";
    case Instance_UpgradeHistoryEntry_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The definition of operations of this upgrade history entry. */
export enum Instance_UpgradeHistoryEntry_Action {
  /** ACTION_UNSPECIFIED - Operation is not specified. */
  ACTION_UNSPECIFIED = 0,
  /** UPGRADE - Upgrade. */
  UPGRADE = 1,
  /** ROLLBACK - Rollback. */
  ROLLBACK = 2,
  UNRECOGNIZED = -1,
}

export function instance_UpgradeHistoryEntry_ActionFromJSON(object: any): Instance_UpgradeHistoryEntry_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return Instance_UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED;
    case 1:
    case "UPGRADE":
      return Instance_UpgradeHistoryEntry_Action.UPGRADE;
    case 2:
    case "ROLLBACK":
      return Instance_UpgradeHistoryEntry_Action.ROLLBACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_UpgradeHistoryEntry_Action.UNRECOGNIZED;
  }
}

export function instance_UpgradeHistoryEntry_ActionToJSON(object: Instance_UpgradeHistoryEntry_Action): string {
  switch (object) {
    case Instance_UpgradeHistoryEntry_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case Instance_UpgradeHistoryEntry_Action.UPGRADE:
      return "UPGRADE";
    case Instance_UpgradeHistoryEntry_Action.ROLLBACK:
      return "ROLLBACK";
    case Instance_UpgradeHistoryEntry_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

export interface Instance_MetadataEntry {
  key: string;
  value: string;
}

function createBaseReservationAffinity(): ReservationAffinity {
  return { consumeReservationType: 0, key: "", values: [] };
}

export const ReservationAffinity: MessageFns<ReservationAffinity> = {
  encode(message: ReservationAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumeReservationType !== 0) {
      writer.uint32(8).int32(message.consumeReservationType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReservationAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservationAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.consumeReservationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReservationAffinity {
    return {
      consumeReservationType: isSet(object.consumeReservationType)
        ? reservationAffinity_TypeFromJSON(object.consumeReservationType)
        : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ReservationAffinity): unknown {
    const obj: any = {};
    if (message.consumeReservationType !== 0) {
      obj.consumeReservationType = reservationAffinity_TypeToJSON(message.consumeReservationType);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<ReservationAffinity>): ReservationAffinity {
    return ReservationAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReservationAffinity>): ReservationAffinity {
    const message = createBaseReservationAffinity();
    message.consumeReservationType = object.consumeReservationType ?? 0;
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    vmImage: undefined,
    containerImage: undefined,
    postStartupScript: "",
    proxyUri: "",
    instanceOwners: [],
    serviceAccount: "",
    serviceAccountScopes: [],
    machineType: "",
    acceleratorConfig: undefined,
    state: 0,
    installGpuDriver: false,
    customGpuDriverPath: "",
    bootDiskType: 0,
    bootDiskSizeGb: Long.ZERO,
    dataDiskType: 0,
    dataDiskSizeGb: Long.ZERO,
    noRemoveDataDisk: false,
    diskEncryption: 0,
    kmsKey: "",
    disks: [],
    shieldedInstanceConfig: undefined,
    noPublicIp: false,
    noProxyAccess: false,
    network: "",
    subnet: "",
    labels: {},
    metadata: {},
    tags: [],
    upgradeHistory: [],
    nicType: 0,
    reservationAffinity: undefined,
    creator: "",
    canIpForward: false,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vmImage !== undefined) {
      VmImage.encode(message.vmImage, writer.uint32(18).fork()).join();
    }
    if (message.containerImage !== undefined) {
      ContainerImage.encode(message.containerImage, writer.uint32(26).fork()).join();
    }
    if (message.postStartupScript !== "") {
      writer.uint32(34).string(message.postStartupScript);
    }
    if (message.proxyUri !== "") {
      writer.uint32(42).string(message.proxyUri);
    }
    for (const v of message.instanceOwners) {
      writer.uint32(50).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(58).string(message.serviceAccount);
    }
    for (const v of message.serviceAccountScopes) {
      writer.uint32(250).string(v!);
    }
    if (message.machineType !== "") {
      writer.uint32(66).string(message.machineType);
    }
    if (message.acceleratorConfig !== undefined) {
      Instance_AcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.installGpuDriver !== false) {
      writer.uint32(88).bool(message.installGpuDriver);
    }
    if (message.customGpuDriverPath !== "") {
      writer.uint32(98).string(message.customGpuDriverPath);
    }
    if (message.bootDiskType !== 0) {
      writer.uint32(104).int32(message.bootDiskType);
    }
    if (!message.bootDiskSizeGb.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.bootDiskSizeGb.toString());
    }
    if (message.dataDiskType !== 0) {
      writer.uint32(200).int32(message.dataDiskType);
    }
    if (!message.dataDiskSizeGb.equals(Long.ZERO)) {
      writer.uint32(208).int64(message.dataDiskSizeGb.toString());
    }
    if (message.noRemoveDataDisk !== false) {
      writer.uint32(216).bool(message.noRemoveDataDisk);
    }
    if (message.diskEncryption !== 0) {
      writer.uint32(120).int32(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      writer.uint32(130).string(message.kmsKey);
    }
    for (const v of message.disks) {
      Instance_Disk.encode(v!, writer.uint32(226).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      Instance_ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(242).fork()).join();
    }
    if (message.noPublicIp !== false) {
      writer.uint32(136).bool(message.noPublicIp);
    }
    if (message.noProxyAccess !== false) {
      writer.uint32(144).bool(message.noProxyAccess);
    }
    if (message.network !== "") {
      writer.uint32(154).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(162).string(message.subnet);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(170).fork()).join();
    });
    Object.entries(message.metadata).forEach(([key, value]) => {
      Instance_MetadataEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    for (const v of message.tags) {
      writer.uint32(258).string(v!);
    }
    for (const v of message.upgradeHistory) {
      Instance_UpgradeHistoryEntry.encode(v!, writer.uint32(234).fork()).join();
    }
    if (message.nicType !== 0) {
      writer.uint32(264).int32(message.nicType);
    }
    if (message.reservationAffinity !== undefined) {
      ReservationAffinity.encode(message.reservationAffinity, writer.uint32(274).fork()).join();
    }
    if (message.creator !== "") {
      writer.uint32(290).string(message.creator);
    }
    if (message.canIpForward !== false) {
      writer.uint32(312).bool(message.canIpForward);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(186).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vmImage = VmImage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.containerImage = ContainerImage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postStartupScript = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.proxyUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.instanceOwners.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.serviceAccountScopes.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.acceleratorConfig = Instance_AcceleratorConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.installGpuDriver = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.customGpuDriverPath = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.bootDiskType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.bootDiskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.dataDiskType = reader.int32() as any;
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.dataDiskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.noRemoveDataDisk = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.diskEncryption = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.disks.push(Instance_Disk.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.shieldedInstanceConfig = Instance_ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.noPublicIp = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.noProxyAccess = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.network = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.subnet = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          const entry21 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            message.labels[entry21.key] = entry21.value;
          }
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = Instance_MetadataEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.metadata[entry22.key] = entry22.value;
          }
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.upgradeHistory.push(Instance_UpgradeHistoryEntry.decode(reader, reader.uint32()));
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.nicType = reader.int32() as any;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.reservationAffinity = ReservationAffinity.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.creator = reader.string();
          continue;
        case 39:
          if (tag !== 312) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vmImage: isSet(object.vmImage) ? VmImage.fromJSON(object.vmImage) : undefined,
      containerImage: isSet(object.containerImage) ? ContainerImage.fromJSON(object.containerImage) : undefined,
      postStartupScript: isSet(object.postStartupScript) ? globalThis.String(object.postStartupScript) : "",
      proxyUri: isSet(object.proxyUri) ? globalThis.String(object.proxyUri) : "",
      instanceOwners: globalThis.Array.isArray(object?.instanceOwners)
        ? object.instanceOwners.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      serviceAccountScopes: globalThis.Array.isArray(object?.serviceAccountScopes)
        ? object.serviceAccountScopes.map((e: any) => globalThis.String(e))
        : [],
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? Instance_AcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      installGpuDriver: isSet(object.installGpuDriver) ? globalThis.Boolean(object.installGpuDriver) : false,
      customGpuDriverPath: isSet(object.customGpuDriverPath) ? globalThis.String(object.customGpuDriverPath) : "",
      bootDiskType: isSet(object.bootDiskType) ? instance_DiskTypeFromJSON(object.bootDiskType) : 0,
      bootDiskSizeGb: isSet(object.bootDiskSizeGb) ? Long.fromValue(object.bootDiskSizeGb) : Long.ZERO,
      dataDiskType: isSet(object.dataDiskType) ? instance_DiskTypeFromJSON(object.dataDiskType) : 0,
      dataDiskSizeGb: isSet(object.dataDiskSizeGb) ? Long.fromValue(object.dataDiskSizeGb) : Long.ZERO,
      noRemoveDataDisk: isSet(object.noRemoveDataDisk) ? globalThis.Boolean(object.noRemoveDataDisk) : false,
      diskEncryption: isSet(object.diskEncryption) ? instance_DiskEncryptionFromJSON(object.diskEncryption) : 0,
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      disks: globalThis.Array.isArray(object?.disks) ? object.disks.map((e: any) => Instance_Disk.fromJSON(e)) : [],
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? Instance_ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      noPublicIp: isSet(object.noPublicIp) ? globalThis.Boolean(object.noPublicIp) : false,
      noProxyAccess: isSet(object.noProxyAccess) ? globalThis.Boolean(object.noProxyAccess) : false,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => globalThis.String(e))
        : [],
      upgradeHistory: globalThis.Array.isArray(object?.upgradeHistory)
        ? object.upgradeHistory.map((e: any) => Instance_UpgradeHistoryEntry.fromJSON(e))
        : [],
      nicType: isSet(object.nicType) ? instance_NicTypeFromJSON(object.nicType) : 0,
      reservationAffinity: isSet(object.reservationAffinity)
        ? ReservationAffinity.fromJSON(object.reservationAffinity)
        : undefined,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vmImage !== undefined) {
      obj.vmImage = VmImage.toJSON(message.vmImage);
    }
    if (message.containerImage !== undefined) {
      obj.containerImage = ContainerImage.toJSON(message.containerImage);
    }
    if (message.postStartupScript !== "") {
      obj.postStartupScript = message.postStartupScript;
    }
    if (message.proxyUri !== "") {
      obj.proxyUri = message.proxyUri;
    }
    if (message.instanceOwners?.length) {
      obj.instanceOwners = message.instanceOwners;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.serviceAccountScopes?.length) {
      obj.serviceAccountScopes = message.serviceAccountScopes;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = Instance_AcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.installGpuDriver !== false) {
      obj.installGpuDriver = message.installGpuDriver;
    }
    if (message.customGpuDriverPath !== "") {
      obj.customGpuDriverPath = message.customGpuDriverPath;
    }
    if (message.bootDiskType !== 0) {
      obj.bootDiskType = instance_DiskTypeToJSON(message.bootDiskType);
    }
    if (!message.bootDiskSizeGb.equals(Long.ZERO)) {
      obj.bootDiskSizeGb = (message.bootDiskSizeGb || Long.ZERO).toString();
    }
    if (message.dataDiskType !== 0) {
      obj.dataDiskType = instance_DiskTypeToJSON(message.dataDiskType);
    }
    if (!message.dataDiskSizeGb.equals(Long.ZERO)) {
      obj.dataDiskSizeGb = (message.dataDiskSizeGb || Long.ZERO).toString();
    }
    if (message.noRemoveDataDisk !== false) {
      obj.noRemoveDataDisk = message.noRemoveDataDisk;
    }
    if (message.diskEncryption !== 0) {
      obj.diskEncryption = instance_DiskEncryptionToJSON(message.diskEncryption);
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.disks?.length) {
      obj.disks = message.disks.map((e) => Instance_Disk.toJSON(e));
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = Instance_ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.noPublicIp !== false) {
      obj.noPublicIp = message.noPublicIp;
    }
    if (message.noProxyAccess !== false) {
      obj.noProxyAccess = message.noProxyAccess;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.upgradeHistory?.length) {
      obj.upgradeHistory = message.upgradeHistory.map((e) => Instance_UpgradeHistoryEntry.toJSON(e));
    }
    if (message.nicType !== 0) {
      obj.nicType = instance_NicTypeToJSON(message.nicType);
    }
    if (message.reservationAffinity !== undefined) {
      obj.reservationAffinity = ReservationAffinity.toJSON(message.reservationAffinity);
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.canIpForward !== false) {
      obj.canIpForward = message.canIpForward;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.vmImage = (object.vmImage !== undefined && object.vmImage !== null)
      ? VmImage.fromPartial(object.vmImage)
      : undefined;
    message.containerImage = (object.containerImage !== undefined && object.containerImage !== null)
      ? ContainerImage.fromPartial(object.containerImage)
      : undefined;
    message.postStartupScript = object.postStartupScript ?? "";
    message.proxyUri = object.proxyUri ?? "";
    message.instanceOwners = object.instanceOwners?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.serviceAccountScopes = object.serviceAccountScopes?.map((e) => e) || [];
    message.machineType = object.machineType ?? "";
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? Instance_AcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.installGpuDriver = object.installGpuDriver ?? false;
    message.customGpuDriverPath = object.customGpuDriverPath ?? "";
    message.bootDiskType = object.bootDiskType ?? 0;
    message.bootDiskSizeGb = (object.bootDiskSizeGb !== undefined && object.bootDiskSizeGb !== null)
      ? Long.fromValue(object.bootDiskSizeGb)
      : Long.ZERO;
    message.dataDiskType = object.dataDiskType ?? 0;
    message.dataDiskSizeGb = (object.dataDiskSizeGb !== undefined && object.dataDiskSizeGb !== null)
      ? Long.fromValue(object.dataDiskSizeGb)
      : Long.ZERO;
    message.noRemoveDataDisk = object.noRemoveDataDisk ?? false;
    message.diskEncryption = object.diskEncryption ?? 0;
    message.kmsKey = object.kmsKey ?? "";
    message.disks = object.disks?.map((e) => Instance_Disk.fromPartial(e)) || [];
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? Instance_ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.noPublicIp = object.noPublicIp ?? false;
    message.noProxyAccess = object.noProxyAccess ?? false;
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tags = object.tags?.map((e) => e) || [];
    message.upgradeHistory = object.upgradeHistory?.map((e) => Instance_UpgradeHistoryEntry.fromPartial(e)) || [];
    message.nicType = object.nicType ?? 0;
    message.reservationAffinity = (object.reservationAffinity !== undefined && object.reservationAffinity !== null)
      ? ReservationAffinity.fromPartial(object.reservationAffinity)
      : undefined;
    message.creator = object.creator ?? "";
    message.canIpForward = object.canIpForward ?? false;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseInstance_AcceleratorConfig(): Instance_AcceleratorConfig {
  return { type: 0, coreCount: Long.ZERO };
}

export const Instance_AcceleratorConfig: MessageFns<Instance_AcceleratorConfig> = {
  encode(message: Instance_AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.coreCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_AcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.coreCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_AcceleratorConfig {
    return {
      type: isSet(object.type) ? instance_AcceleratorTypeFromJSON(object.type) : 0,
      coreCount: isSet(object.coreCount) ? Long.fromValue(object.coreCount) : Long.ZERO,
    };
  },

  toJSON(message: Instance_AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = instance_AcceleratorTypeToJSON(message.type);
    }
    if (!message.coreCount.equals(Long.ZERO)) {
      obj.coreCount = (message.coreCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_AcceleratorConfig>): Instance_AcceleratorConfig {
    return Instance_AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_AcceleratorConfig>): Instance_AcceleratorConfig {
    const message = createBaseInstance_AcceleratorConfig();
    message.type = object.type ?? 0;
    message.coreCount = (object.coreCount !== undefined && object.coreCount !== null)
      ? Long.fromValue(object.coreCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseInstance_Disk(): Instance_Disk {
  return {
    autoDelete: false,
    boot: false,
    deviceName: "",
    diskSizeGb: Long.ZERO,
    guestOsFeatures: [],
    index: Long.ZERO,
    interface: "",
    kind: "",
    licenses: [],
    mode: "",
    source: "",
    type: "",
  };
}

export const Instance_Disk: MessageFns<Instance_Disk> = {
  encode(message: Instance_Disk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoDelete !== false) {
      writer.uint32(8).bool(message.autoDelete);
    }
    if (message.boot !== false) {
      writer.uint32(16).bool(message.boot);
    }
    if (message.deviceName !== "") {
      writer.uint32(26).string(message.deviceName);
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.diskSizeGb.toString());
    }
    for (const v of message.guestOsFeatures) {
      Instance_Disk_GuestOsFeature.encode(v!, writer.uint32(42).fork()).join();
    }
    if (!message.index.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.index.toString());
    }
    if (message.interface !== "") {
      writer.uint32(58).string(message.interface);
    }
    if (message.kind !== "") {
      writer.uint32(66).string(message.kind);
    }
    for (const v of message.licenses) {
      writer.uint32(74).string(v!);
    }
    if (message.mode !== "") {
      writer.uint32(82).string(message.mode);
    }
    if (message.source !== "") {
      writer.uint32(90).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(98).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_Disk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_Disk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.autoDelete = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.boot = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.guestOsFeatures.push(Instance_Disk_GuestOsFeature.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.index = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.interface = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.licenses.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.source = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_Disk {
    return {
      autoDelete: isSet(object.autoDelete) ? globalThis.Boolean(object.autoDelete) : false,
      boot: isSet(object.boot) ? globalThis.Boolean(object.boot) : false,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      guestOsFeatures: globalThis.Array.isArray(object?.guestOsFeatures)
        ? object.guestOsFeatures.map((e: any) => Instance_Disk_GuestOsFeature.fromJSON(e))
        : [],
      index: isSet(object.index) ? Long.fromValue(object.index) : Long.ZERO,
      interface: isSet(object.interface) ? globalThis.String(object.interface) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      licenses: globalThis.Array.isArray(object?.licenses) ? object.licenses.map((e: any) => globalThis.String(e)) : [],
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: Instance_Disk): unknown {
    const obj: any = {};
    if (message.autoDelete !== false) {
      obj.autoDelete = message.autoDelete;
    }
    if (message.boot !== false) {
      obj.boot = message.boot;
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.guestOsFeatures?.length) {
      obj.guestOsFeatures = message.guestOsFeatures.map((e) => Instance_Disk_GuestOsFeature.toJSON(e));
    }
    if (!message.index.equals(Long.ZERO)) {
      obj.index = (message.index || Long.ZERO).toString();
    }
    if (message.interface !== "") {
      obj.interface = message.interface;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_Disk>): Instance_Disk {
    return Instance_Disk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_Disk>): Instance_Disk {
    const message = createBaseInstance_Disk();
    message.autoDelete = object.autoDelete ?? false;
    message.boot = object.boot ?? false;
    message.deviceName = object.deviceName ?? "";
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.guestOsFeatures = object.guestOsFeatures?.map((e) => Instance_Disk_GuestOsFeature.fromPartial(e)) || [];
    message.index = (object.index !== undefined && object.index !== null) ? Long.fromValue(object.index) : Long.ZERO;
    message.interface = object.interface ?? "";
    message.kind = object.kind ?? "";
    message.licenses = object.licenses?.map((e) => e) || [];
    message.mode = object.mode ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseInstance_Disk_GuestOsFeature(): Instance_Disk_GuestOsFeature {
  return { type: "" };
}

export const Instance_Disk_GuestOsFeature: MessageFns<Instance_Disk_GuestOsFeature> = {
  encode(message: Instance_Disk_GuestOsFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_Disk_GuestOsFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_Disk_GuestOsFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_Disk_GuestOsFeature {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: Instance_Disk_GuestOsFeature): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_Disk_GuestOsFeature>): Instance_Disk_GuestOsFeature {
    return Instance_Disk_GuestOsFeature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_Disk_GuestOsFeature>): Instance_Disk_GuestOsFeature {
    const message = createBaseInstance_Disk_GuestOsFeature();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseInstance_ShieldedInstanceConfig(): Instance_ShieldedInstanceConfig {
  return { enableSecureBoot: false, enableVtpm: false, enableIntegrityMonitoring: false };
}

export const Instance_ShieldedInstanceConfig: MessageFns<Instance_ShieldedInstanceConfig> = {
  encode(message: Instance_ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableVtpm !== false) {
      writer.uint32(16).bool(message.enableVtpm);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(24).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_ShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableVtpm = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_ShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableVtpm: isSet(object.enableVtpm) ? globalThis.Boolean(object.enableVtpm) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: Instance_ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableVtpm !== false) {
      obj.enableVtpm = message.enableVtpm;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_ShieldedInstanceConfig>): Instance_ShieldedInstanceConfig {
    return Instance_ShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_ShieldedInstanceConfig>): Instance_ShieldedInstanceConfig {
    const message = createBaseInstance_ShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableVtpm = object.enableVtpm ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseInstance_UpgradeHistoryEntry(): Instance_UpgradeHistoryEntry {
  return {
    snapshot: "",
    vmImage: "",
    containerImage: "",
    framework: "",
    version: "",
    state: 0,
    createTime: undefined,
    targetImage: "",
    action: 0,
    targetVersion: "",
  };
}

export const Instance_UpgradeHistoryEntry: MessageFns<Instance_UpgradeHistoryEntry> = {
  encode(message: Instance_UpgradeHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshot !== "") {
      writer.uint32(10).string(message.snapshot);
    }
    if (message.vmImage !== "") {
      writer.uint32(18).string(message.vmImage);
    }
    if (message.containerImage !== "") {
      writer.uint32(26).string(message.containerImage);
    }
    if (message.framework !== "") {
      writer.uint32(34).string(message.framework);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.targetImage !== "") {
      writer.uint32(66).string(message.targetImage);
    }
    if (message.action !== 0) {
      writer.uint32(72).int32(message.action);
    }
    if (message.targetVersion !== "") {
      writer.uint32(82).string(message.targetVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_UpgradeHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_UpgradeHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snapshot = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vmImage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.framework = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.targetImage = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_UpgradeHistoryEntry {
    return {
      snapshot: isSet(object.snapshot) ? globalThis.String(object.snapshot) : "",
      vmImage: isSet(object.vmImage) ? globalThis.String(object.vmImage) : "",
      containerImage: isSet(object.containerImage) ? globalThis.String(object.containerImage) : "",
      framework: isSet(object.framework) ? globalThis.String(object.framework) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? instance_UpgradeHistoryEntry_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      targetImage: isSet(object.targetImage) ? globalThis.String(object.targetImage) : "",
      action: isSet(object.action) ? instance_UpgradeHistoryEntry_ActionFromJSON(object.action) : 0,
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
    };
  },

  toJSON(message: Instance_UpgradeHistoryEntry): unknown {
    const obj: any = {};
    if (message.snapshot !== "") {
      obj.snapshot = message.snapshot;
    }
    if (message.vmImage !== "") {
      obj.vmImage = message.vmImage;
    }
    if (message.containerImage !== "") {
      obj.containerImage = message.containerImage;
    }
    if (message.framework !== "") {
      obj.framework = message.framework;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = instance_UpgradeHistoryEntry_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.targetImage !== "") {
      obj.targetImage = message.targetImage;
    }
    if (message.action !== 0) {
      obj.action = instance_UpgradeHistoryEntry_ActionToJSON(message.action);
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_UpgradeHistoryEntry>): Instance_UpgradeHistoryEntry {
    return Instance_UpgradeHistoryEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_UpgradeHistoryEntry>): Instance_UpgradeHistoryEntry {
    const message = createBaseInstance_UpgradeHistoryEntry();
    message.snapshot = object.snapshot ?? "";
    message.vmImage = object.vmImage ?? "";
    message.containerImage = object.containerImage ?? "";
    message.framework = object.framework ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.targetImage = object.targetImage ?? "";
    message.action = object.action ?? 0;
    message.targetVersion = object.targetVersion ?? "";
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInstance_MetadataEntry(): Instance_MetadataEntry {
  return { key: "", value: "" };
}

export const Instance_MetadataEntry: MessageFns<Instance_MetadataEntry> = {
  encode(message: Instance_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_MetadataEntry>): Instance_MetadataEntry {
    return Instance_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_MetadataEntry>): Instance_MetadataEntry {
    const message = createBaseInstance_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
