// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/webrisk/v1/webrisk.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.webrisk.v1";

/**
 * The type of threat. This maps directly to the threat list a threat may
 * belong to.
 */
export enum ThreatType {
  /** THREAT_TYPE_UNSPECIFIED - No entries should match this threat type. This threat type is unused. */
  THREAT_TYPE_UNSPECIFIED = 0,
  /** MALWARE - Malware targeting any platform. */
  MALWARE = 1,
  /** SOCIAL_ENGINEERING - Social engineering targeting any platform. */
  SOCIAL_ENGINEERING = 2,
  /** UNWANTED_SOFTWARE - Unwanted software targeting any platform. */
  UNWANTED_SOFTWARE = 3,
  /**
   * SOCIAL_ENGINEERING_EXTENDED_COVERAGE - A list of extended coverage social engineering URIs targeting any
   * platform.
   */
  SOCIAL_ENGINEERING_EXTENDED_COVERAGE = 4,
  UNRECOGNIZED = -1,
}

export function threatTypeFromJSON(object: any): ThreatType {
  switch (object) {
    case 0:
    case "THREAT_TYPE_UNSPECIFIED":
      return ThreatType.THREAT_TYPE_UNSPECIFIED;
    case 1:
    case "MALWARE":
      return ThreatType.MALWARE;
    case 2:
    case "SOCIAL_ENGINEERING":
      return ThreatType.SOCIAL_ENGINEERING;
    case 3:
    case "UNWANTED_SOFTWARE":
      return ThreatType.UNWANTED_SOFTWARE;
    case 4:
    case "SOCIAL_ENGINEERING_EXTENDED_COVERAGE":
      return ThreatType.SOCIAL_ENGINEERING_EXTENDED_COVERAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThreatType.UNRECOGNIZED;
  }
}

export function threatTypeToJSON(object: ThreatType): string {
  switch (object) {
    case ThreatType.THREAT_TYPE_UNSPECIFIED:
      return "THREAT_TYPE_UNSPECIFIED";
    case ThreatType.MALWARE:
      return "MALWARE";
    case ThreatType.SOCIAL_ENGINEERING:
      return "SOCIAL_ENGINEERING";
    case ThreatType.UNWANTED_SOFTWARE:
      return "UNWANTED_SOFTWARE";
    case ThreatType.SOCIAL_ENGINEERING_EXTENDED_COVERAGE:
      return "SOCIAL_ENGINEERING_EXTENDED_COVERAGE";
    case ThreatType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The ways in which threat entry sets can be compressed. */
export enum CompressionType {
  /** COMPRESSION_TYPE_UNSPECIFIED - Unknown. */
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  /** RAW - Raw, uncompressed data. */
  RAW = 1,
  /** RICE - Rice-Golomb encoded data. */
  RICE = 2,
  UNRECOGNIZED = -1,
}

export function compressionTypeFromJSON(object: any): CompressionType {
  switch (object) {
    case 0:
    case "COMPRESSION_TYPE_UNSPECIFIED":
      return CompressionType.COMPRESSION_TYPE_UNSPECIFIED;
    case 1:
    case "RAW":
      return CompressionType.RAW;
    case 2:
    case "RICE":
      return CompressionType.RICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CompressionType.UNRECOGNIZED;
  }
}

export function compressionTypeToJSON(object: CompressionType): string {
  switch (object) {
    case CompressionType.COMPRESSION_TYPE_UNSPECIFIED:
      return "COMPRESSION_TYPE_UNSPECIFIED";
    case CompressionType.RAW:
      return "RAW";
    case CompressionType.RICE:
      return "RICE";
    case CompressionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes an API diff request. */
export interface ComputeThreatListDiffRequest {
  /**
   * Required. The threat list to update. Only a single ThreatType should be
   * specified per request. If you want to handle multiple ThreatTypes, you must
   * make one request per ThreatType.
   */
  threatType: ThreatType;
  /**
   * The current version token of the client for the requested list (the
   * client version that was received from the last successful diff).
   * If the client does not have a version token (this is the first time calling
   * ComputeThreatListDiff), this may be left empty and a full database
   * snapshot will be returned.
   */
  versionToken: Buffer;
  /** Required. The constraints associated with this request. */
  constraints: ComputeThreatListDiffRequest_Constraints | undefined;
}

/** The constraints for this diff. */
export interface ComputeThreatListDiffRequest_Constraints {
  /**
   * The maximum size in number of entries. The diff will not contain more
   * entries than this value.  This should be a power of 2 between 2**10 and
   * 2**20.  If zero, no diff size limit is set.
   */
  maxDiffEntries: number;
  /**
   * Sets the maximum number of entries that the client is willing to have
   * in the local database. This should be a power of 2 between 2**10 and
   * 2**20. If zero, no database size limit is set.
   */
  maxDatabaseEntries: number;
  /** The compression types supported by the client. */
  supportedCompressions: CompressionType[];
}

export interface ComputeThreatListDiffResponse {
  /**
   * The type of response. This may indicate that an action must be taken by the
   * client when the response is received.
   */
  responseType: ComputeThreatListDiffResponse_ResponseType;
  /** A set of entries to add to a local threat type's list. */
  additions:
    | ThreatEntryAdditions
    | undefined;
  /**
   * A set of entries to remove from a local threat type's list.
   * This field may be empty.
   */
  removals:
    | ThreatEntryRemovals
    | undefined;
  /**
   * The new opaque client version token. This should be retained by the client
   * and passed into the next call of ComputeThreatListDiff as 'version_token'.
   * A separate version token should be stored and used for each threatList.
   */
  newVersionToken: Buffer;
  /**
   * The expected SHA256 hash of the client state; that is, of the sorted list
   * of all hashes present in the database after applying the provided diff.
   * If the client state doesn't match the expected state, the client must
   * discard this diff and retry later.
   */
  checksum:
    | ComputeThreatListDiffResponse_Checksum
    | undefined;
  /**
   * The soonest the client should wait before issuing any diff
   * request. Querying sooner is unlikely to produce a meaningful diff.
   * Waiting longer is acceptable considering the use case.
   * If this field is not set clients may update as soon as they want.
   */
  recommendedNextDiff: Date | undefined;
}

/** The type of response sent to the client. */
export enum ComputeThreatListDiffResponse_ResponseType {
  /** RESPONSE_TYPE_UNSPECIFIED - Unknown. */
  RESPONSE_TYPE_UNSPECIFIED = 0,
  /** DIFF - Partial updates are applied to the client's existing local database. */
  DIFF = 1,
  /**
   * RESET - Full updates resets the client's entire local database. This means
   * that either the client had no state, was seriously out-of-date,
   * or the client is believed to be corrupt.
   */
  RESET = 2,
  UNRECOGNIZED = -1,
}

export function computeThreatListDiffResponse_ResponseTypeFromJSON(
  object: any,
): ComputeThreatListDiffResponse_ResponseType {
  switch (object) {
    case 0:
    case "RESPONSE_TYPE_UNSPECIFIED":
      return ComputeThreatListDiffResponse_ResponseType.RESPONSE_TYPE_UNSPECIFIED;
    case 1:
    case "DIFF":
      return ComputeThreatListDiffResponse_ResponseType.DIFF;
    case 2:
    case "RESET":
      return ComputeThreatListDiffResponse_ResponseType.RESET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeThreatListDiffResponse_ResponseType.UNRECOGNIZED;
  }
}

export function computeThreatListDiffResponse_ResponseTypeToJSON(
  object: ComputeThreatListDiffResponse_ResponseType,
): string {
  switch (object) {
    case ComputeThreatListDiffResponse_ResponseType.RESPONSE_TYPE_UNSPECIFIED:
      return "RESPONSE_TYPE_UNSPECIFIED";
    case ComputeThreatListDiffResponse_ResponseType.DIFF:
      return "DIFF";
    case ComputeThreatListDiffResponse_ResponseType.RESET:
      return "RESET";
    case ComputeThreatListDiffResponse_ResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The expected state of a client's local database. */
export interface ComputeThreatListDiffResponse_Checksum {
  /**
   * The SHA256 hash of the client state; that is, of the sorted list of all
   * hashes present in the database.
   */
  sha256: Buffer;
}

/** Request to check URI entries against threatLists. */
export interface SearchUrisRequest {
  /** Required. The URI to be checked for matches. */
  uri: string;
  /**
   * Required. The ThreatLists to search in. Multiple ThreatLists may be
   * specified.
   */
  threatTypes: ThreatType[];
}

export interface SearchUrisResponse {
  /** The threat list matches. This might be empty if the URI is on no list. */
  threat: SearchUrisResponse_ThreatUri | undefined;
}

/** Contains threat information on a matching uri. */
export interface SearchUrisResponse_ThreatUri {
  /** The ThreatList this threat belongs to. */
  threatTypes: ThreatType[];
  /**
   * The cache lifetime for the returned match. Clients must not cache this
   * response past this timestamp to avoid false positives.
   */
  expireTime: Date | undefined;
}

/** Request to return full hashes matched by the provided hash prefixes. */
export interface SearchHashesRequest {
  /**
   * A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
   * hash. For JSON requests, this field is base64-encoded.
   * Note that if this parameter is provided by a URI, it must be encoded using
   * the web safe base64 variant (RFC 4648).
   */
  hashPrefix: Buffer;
  /**
   * Required. The ThreatLists to search in. Multiple ThreatLists may be
   * specified.
   */
  threatTypes: ThreatType[];
}

export interface SearchHashesResponse {
  /**
   * The full hashes that matched the requested prefixes.
   * The hash will be populated in the key.
   */
  threats: SearchHashesResponse_ThreatHash[];
  /**
   * For requested entities that did not match the threat list, how long to
   * cache the response until.
   */
  negativeExpireTime: Date | undefined;
}

/** Contains threat information on a matching hash. */
export interface SearchHashesResponse_ThreatHash {
  /**
   * The ThreatList this threat belongs to.
   * This must contain at least one entry.
   */
  threatTypes: ThreatType[];
  /**
   * A 32 byte SHA256 hash. This field is in binary format. For JSON
   * requests, hashes are base64-encoded.
   */
  hash: Buffer;
  /**
   * The cache lifetime for the returned match. Clients must not cache this
   * response past this timestamp to avoid false positives.
   */
  expireTime: Date | undefined;
}

/**
 * Contains the set of entries to add to a local database.
 * May contain a combination of compressed and raw data in a single response.
 */
export interface ThreatEntryAdditions {
  /**
   * The raw SHA256-formatted entries.
   * Repeated to allow returning sets of hashes with different prefix sizes.
   */
  rawHashes: RawHashes[];
  /**
   * The encoded 4-byte prefixes of SHA256-formatted entries, using a
   * Golomb-Rice encoding. The hashes are converted to uint32, sorted in
   * ascending order, then delta encoded and stored as encoded_data.
   */
  riceHashes: RiceDeltaEncoding | undefined;
}

/** Contains the set of entries to remove from a local database. */
export interface ThreatEntryRemovals {
  /** The raw removal indices for a local list. */
  rawIndices:
    | RawIndices
    | undefined;
  /**
   * The encoded local, lexicographically-sorted list indices, using a
   * Golomb-Rice encoding. Used for sending compressed removal indices. The
   * removal indices (uint32) are sorted in ascending order, then delta encoded
   * and stored as encoded_data.
   */
  riceIndices: RiceDeltaEncoding | undefined;
}

/** A set of raw indices to remove from a local list. */
export interface RawIndices {
  /** The indices to remove from a lexicographically-sorted local list. */
  indices: number[];
}

/**
 * The uncompressed threat entries in hash format.
 * Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
 * bytes, but some hashes are lengthened if they collide with the hash of a
 * popular URI.
 *
 * Used for sending ThreatEntryAdditons to clients that do not support
 * compression, or when sending non-4-byte hashes to clients that do support
 * compression.
 */
export interface RawHashes {
  /**
   * The number of bytes for each prefix encoded below.  This field can be
   * anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
   * In practice this is almost always 4, except in exceptional circumstances.
   */
  prefixSize: number;
  /**
   * The hashes, in binary format, concatenated into one long string. Hashes are
   * sorted in lexicographic order. For JSON API users, hashes are
   * base64-encoded.
   */
  rawHashes: Buffer;
}

/**
 * The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
 * compressed removal indices.
 */
export interface RiceDeltaEncoding {
  /**
   * The offset of the first entry in the encoded data, or, if only a single
   * integer was encoded, that single integer's value. If the field is empty or
   * missing, assume zero.
   */
  firstValue: Long;
  /**
   * The Golomb-Rice parameter, which is a number between 2 and 28. This field
   * is missing (that is, zero) if `num_entries` is zero.
   */
  riceParameter: number;
  /**
   * The number of entries that are delta encoded in the encoded data. If only a
   * single integer was encoded, this will be zero and the single value will be
   * stored in `first_value`.
   */
  entryCount: number;
  /** The encoded deltas that are encoded using the Golomb-Rice coder. */
  encodedData: Buffer;
}

/** Wraps a URI that might be displaying malicious content. */
export interface Submission {
  /**
   * Required. The URI that is being reported for malicious content to be
   * analyzed.
   */
  uri: string;
  /**
   * Output only. ThreatTypes found to be associated with the submitted URI
   * after reviewing it. This might be empty if the URI was not added to any
   * list.
   */
  threatTypes: ThreatType[];
}

/**
 * Context about the submission including the type of abuse found on the URI and
 * supporting details.
 * option (google.api.message_visibility).restriction = "TRUSTED_TESTER";
 */
export interface ThreatInfo {
  /** The type of abuse. */
  abuseType: ThreatInfo_AbuseType;
  /** Confidence that the URI is unsafe. */
  threatConfidence:
    | ThreatInfo_Confidence
    | undefined;
  /** Context about why the URI is unsafe. */
  threatJustification: ThreatInfo_ThreatJustification | undefined;
}

/** The abuse type found on the URI. */
export enum ThreatInfo_AbuseType {
  /** ABUSE_TYPE_UNSPECIFIED - Default. */
  ABUSE_TYPE_UNSPECIFIED = 0,
  /** MALWARE - The URI contains malware. */
  MALWARE = 1,
  /** SOCIAL_ENGINEERING - The URI contains social engineering. */
  SOCIAL_ENGINEERING = 2,
  /** UNWANTED_SOFTWARE - The URI contains unwanted software. */
  UNWANTED_SOFTWARE = 3,
  UNRECOGNIZED = -1,
}

export function threatInfo_AbuseTypeFromJSON(object: any): ThreatInfo_AbuseType {
  switch (object) {
    case 0:
    case "ABUSE_TYPE_UNSPECIFIED":
      return ThreatInfo_AbuseType.ABUSE_TYPE_UNSPECIFIED;
    case 1:
    case "MALWARE":
      return ThreatInfo_AbuseType.MALWARE;
    case 2:
    case "SOCIAL_ENGINEERING":
      return ThreatInfo_AbuseType.SOCIAL_ENGINEERING;
    case 3:
    case "UNWANTED_SOFTWARE":
      return ThreatInfo_AbuseType.UNWANTED_SOFTWARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThreatInfo_AbuseType.UNRECOGNIZED;
  }
}

export function threatInfo_AbuseTypeToJSON(object: ThreatInfo_AbuseType): string {
  switch (object) {
    case ThreatInfo_AbuseType.ABUSE_TYPE_UNSPECIFIED:
      return "ABUSE_TYPE_UNSPECIFIED";
    case ThreatInfo_AbuseType.MALWARE:
      return "MALWARE";
    case ThreatInfo_AbuseType.SOCIAL_ENGINEERING:
      return "SOCIAL_ENGINEERING";
    case ThreatInfo_AbuseType.UNWANTED_SOFTWARE:
      return "UNWANTED_SOFTWARE";
    case ThreatInfo_AbuseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Confidence that a URI is unsafe. */
export interface ThreatInfo_Confidence {
  /**
   * A decimal representation of confidence in the range of 0
   * to 1 where 0 indicates no confidence and 1 indicates
   * complete confidence.
   */
  score?:
    | number
    | undefined;
  /** Enum representation of confidence. */
  level?: ThreatInfo_Confidence_ConfidenceLevel | undefined;
}

/** Enum representation of confidence. */
export enum ThreatInfo_Confidence_ConfidenceLevel {
  /** CONFIDENCE_LEVEL_UNSPECIFIED - Default. */
  CONFIDENCE_LEVEL_UNSPECIFIED = 0,
  /** LOW - Less than 60% confidence that the URI is unsafe. */
  LOW = 1,
  /** MEDIUM - Between 60% and 80% confidence that the URI is unsafe. */
  MEDIUM = 2,
  /** HIGH - Greater than 80% confidence that the URI is unsafe. */
  HIGH = 3,
  UNRECOGNIZED = -1,
}

export function threatInfo_Confidence_ConfidenceLevelFromJSON(object: any): ThreatInfo_Confidence_ConfidenceLevel {
  switch (object) {
    case 0:
    case "CONFIDENCE_LEVEL_UNSPECIFIED":
      return ThreatInfo_Confidence_ConfidenceLevel.CONFIDENCE_LEVEL_UNSPECIFIED;
    case 1:
    case "LOW":
      return ThreatInfo_Confidence_ConfidenceLevel.LOW;
    case 2:
    case "MEDIUM":
      return ThreatInfo_Confidence_ConfidenceLevel.MEDIUM;
    case 3:
    case "HIGH":
      return ThreatInfo_Confidence_ConfidenceLevel.HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThreatInfo_Confidence_ConfidenceLevel.UNRECOGNIZED;
  }
}

export function threatInfo_Confidence_ConfidenceLevelToJSON(object: ThreatInfo_Confidence_ConfidenceLevel): string {
  switch (object) {
    case ThreatInfo_Confidence_ConfidenceLevel.CONFIDENCE_LEVEL_UNSPECIFIED:
      return "CONFIDENCE_LEVEL_UNSPECIFIED";
    case ThreatInfo_Confidence_ConfidenceLevel.LOW:
      return "LOW";
    case ThreatInfo_Confidence_ConfidenceLevel.MEDIUM:
      return "MEDIUM";
    case ThreatInfo_Confidence_ConfidenceLevel.HIGH:
      return "HIGH";
    case ThreatInfo_Confidence_ConfidenceLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Context about why the URI is unsafe. */
export interface ThreatInfo_ThreatJustification {
  /** Labels associated with this URI that explain how it was classified. */
  labels: ThreatInfo_ThreatJustification_JustificationLabel[];
  /** Free-form context on why this URI is unsafe. */
  comments: string[];
}

/** Labels that explain how the URI was classified. */
export enum ThreatInfo_ThreatJustification_JustificationLabel {
  /** JUSTIFICATION_LABEL_UNSPECIFIED - Default. */
  JUSTIFICATION_LABEL_UNSPECIFIED = 0,
  /** MANUAL_VERIFICATION - The submitter manually verified that the submission is unsafe. */
  MANUAL_VERIFICATION = 1,
  /** USER_REPORT - The submitter received the submission from an end user. */
  USER_REPORT = 2,
  /** AUTOMATED_REPORT - The submitter received the submission from an automated system. */
  AUTOMATED_REPORT = 3,
  UNRECOGNIZED = -1,
}

export function threatInfo_ThreatJustification_JustificationLabelFromJSON(
  object: any,
): ThreatInfo_ThreatJustification_JustificationLabel {
  switch (object) {
    case 0:
    case "JUSTIFICATION_LABEL_UNSPECIFIED":
      return ThreatInfo_ThreatJustification_JustificationLabel.JUSTIFICATION_LABEL_UNSPECIFIED;
    case 1:
    case "MANUAL_VERIFICATION":
      return ThreatInfo_ThreatJustification_JustificationLabel.MANUAL_VERIFICATION;
    case 2:
    case "USER_REPORT":
      return ThreatInfo_ThreatJustification_JustificationLabel.USER_REPORT;
    case 3:
    case "AUTOMATED_REPORT":
      return ThreatInfo_ThreatJustification_JustificationLabel.AUTOMATED_REPORT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThreatInfo_ThreatJustification_JustificationLabel.UNRECOGNIZED;
  }
}

export function threatInfo_ThreatJustification_JustificationLabelToJSON(
  object: ThreatInfo_ThreatJustification_JustificationLabel,
): string {
  switch (object) {
    case ThreatInfo_ThreatJustification_JustificationLabel.JUSTIFICATION_LABEL_UNSPECIFIED:
      return "JUSTIFICATION_LABEL_UNSPECIFIED";
    case ThreatInfo_ThreatJustification_JustificationLabel.MANUAL_VERIFICATION:
      return "MANUAL_VERIFICATION";
    case ThreatInfo_ThreatJustification_JustificationLabel.USER_REPORT:
      return "USER_REPORT";
    case ThreatInfo_ThreatJustification_JustificationLabel.AUTOMATED_REPORT:
      return "AUTOMATED_REPORT";
    case ThreatInfo_ThreatJustification_JustificationLabel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about how the threat was discovered. */
export interface ThreatDiscovery {
  /** Platform on which the threat was discovered. */
  platform: ThreatDiscovery_Platform;
  /**
   * CLDR region code of the countries/regions the URI poses a threat ordered
   * from most impact to least impact. Example: "US" for United States.
   */
  regionCodes: string[];
}

/** Platform types. */
export enum ThreatDiscovery_Platform {
  /** PLATFORM_UNSPECIFIED - Default. */
  PLATFORM_UNSPECIFIED = 0,
  /** ANDROID - General Android platform. */
  ANDROID = 1,
  /** IOS - General iOS platform. */
  IOS = 2,
  /** MACOS - General macOS platform. */
  MACOS = 3,
  /** WINDOWS - General Windows platform. */
  WINDOWS = 4,
  UNRECOGNIZED = -1,
}

export function threatDiscovery_PlatformFromJSON(object: any): ThreatDiscovery_Platform {
  switch (object) {
    case 0:
    case "PLATFORM_UNSPECIFIED":
      return ThreatDiscovery_Platform.PLATFORM_UNSPECIFIED;
    case 1:
    case "ANDROID":
      return ThreatDiscovery_Platform.ANDROID;
    case 2:
    case "IOS":
      return ThreatDiscovery_Platform.IOS;
    case 3:
    case "MACOS":
      return ThreatDiscovery_Platform.MACOS;
    case 4:
    case "WINDOWS":
      return ThreatDiscovery_Platform.WINDOWS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ThreatDiscovery_Platform.UNRECOGNIZED;
  }
}

export function threatDiscovery_PlatformToJSON(object: ThreatDiscovery_Platform): string {
  switch (object) {
    case ThreatDiscovery_Platform.PLATFORM_UNSPECIFIED:
      return "PLATFORM_UNSPECIFIED";
    case ThreatDiscovery_Platform.ANDROID:
      return "ANDROID";
    case ThreatDiscovery_Platform.IOS:
      return "IOS";
    case ThreatDiscovery_Platform.MACOS:
      return "MACOS";
    case ThreatDiscovery_Platform.WINDOWS:
      return "WINDOWS";
    case ThreatDiscovery_Platform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to send a potentially phishy URI to WebRisk. */
export interface CreateSubmissionRequest {
  /**
   * Required. The name of the project that is making the submission. This
   * string is in the format "projects/{project_number}".
   */
  parent: string;
  /** Required. The submission that contains the content of the phishing report. */
  submission: Submission | undefined;
}

/** Request to send a potentially malicious URI to WebRisk. */
export interface SubmitUriRequest {
  /**
   * Required. The name of the project that is making the submission. This
   * string is in the format "projects/{project_number}".
   */
  parent: string;
  /** Required. The submission that contains the URI to be scanned. */
  submission:
    | Submission
    | undefined;
  /** Provides additional information about the submission. */
  threatInfo:
    | ThreatInfo
    | undefined;
  /** Provides additional information about how the submission was discovered. */
  threatDiscovery: ThreatDiscovery | undefined;
}

/**
 * Metadata for the Submit URI long-running operation.
 * option (google.api.message_visibility).restriction = "TRUSTED_TESTER";
 */
export interface SubmitUriMetadata {
  /** The state of the operation. */
  state: SubmitUriMetadata_State;
  /** Creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** Latest update time of the operation. */
  updateTime: Date | undefined;
}

/** Enum that represents the state of the long-running operation. */
export enum SubmitUriMetadata_State {
  /** STATE_UNSPECIFIED - Default unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** RUNNING - The operation is currently running. */
  RUNNING = 1,
  /** SUCCEEDED - The operation finished with a success status. */
  SUCCEEDED = 2,
  /** CANCELLED - The operation was cancelled. */
  CANCELLED = 3,
  /** FAILED - The operation finished with a failure status. */
  FAILED = 4,
  /** CLOSED - The operation was closed with no action taken. */
  CLOSED = 5,
  UNRECOGNIZED = -1,
}

export function submitUriMetadata_StateFromJSON(object: any): SubmitUriMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return SubmitUriMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "RUNNING":
      return SubmitUriMetadata_State.RUNNING;
    case 2:
    case "SUCCEEDED":
      return SubmitUriMetadata_State.SUCCEEDED;
    case 3:
    case "CANCELLED":
      return SubmitUriMetadata_State.CANCELLED;
    case 4:
    case "FAILED":
      return SubmitUriMetadata_State.FAILED;
    case 5:
    case "CLOSED":
      return SubmitUriMetadata_State.CLOSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubmitUriMetadata_State.UNRECOGNIZED;
  }
}

export function submitUriMetadata_StateToJSON(object: SubmitUriMetadata_State): string {
  switch (object) {
    case SubmitUriMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case SubmitUriMetadata_State.RUNNING:
      return "RUNNING";
    case SubmitUriMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case SubmitUriMetadata_State.CANCELLED:
      return "CANCELLED";
    case SubmitUriMetadata_State.FAILED:
      return "FAILED";
    case SubmitUriMetadata_State.CLOSED:
      return "CLOSED";
    case SubmitUriMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseComputeThreatListDiffRequest(): ComputeThreatListDiffRequest {
  return { threatType: 0, versionToken: Buffer.alloc(0), constraints: undefined };
}

export const ComputeThreatListDiffRequest: MessageFns<ComputeThreatListDiffRequest> = {
  encode(message: ComputeThreatListDiffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threatType !== 0) {
      writer.uint32(8).int32(message.threatType);
    }
    if (message.versionToken.length !== 0) {
      writer.uint32(18).bytes(message.versionToken);
    }
    if (message.constraints !== undefined) {
      ComputeThreatListDiffRequest_Constraints.encode(message.constraints, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeThreatListDiffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeThreatListDiffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threatType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versionToken = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constraints = ComputeThreatListDiffRequest_Constraints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeThreatListDiffRequest {
    return {
      threatType: isSet(object.threatType) ? threatTypeFromJSON(object.threatType) : 0,
      versionToken: isSet(object.versionToken) ? Buffer.from(bytesFromBase64(object.versionToken)) : Buffer.alloc(0),
      constraints: isSet(object.constraints)
        ? ComputeThreatListDiffRequest_Constraints.fromJSON(object.constraints)
        : undefined,
    };
  },

  toJSON(message: ComputeThreatListDiffRequest): unknown {
    const obj: any = {};
    if (message.threatType !== 0) {
      obj.threatType = threatTypeToJSON(message.threatType);
    }
    if (message.versionToken.length !== 0) {
      obj.versionToken = base64FromBytes(message.versionToken);
    }
    if (message.constraints !== undefined) {
      obj.constraints = ComputeThreatListDiffRequest_Constraints.toJSON(message.constraints);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeThreatListDiffRequest>): ComputeThreatListDiffRequest {
    return ComputeThreatListDiffRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeThreatListDiffRequest>): ComputeThreatListDiffRequest {
    const message = createBaseComputeThreatListDiffRequest();
    message.threatType = object.threatType ?? 0;
    message.versionToken = object.versionToken ?? Buffer.alloc(0);
    message.constraints = (object.constraints !== undefined && object.constraints !== null)
      ? ComputeThreatListDiffRequest_Constraints.fromPartial(object.constraints)
      : undefined;
    return message;
  },
};

function createBaseComputeThreatListDiffRequest_Constraints(): ComputeThreatListDiffRequest_Constraints {
  return { maxDiffEntries: 0, maxDatabaseEntries: 0, supportedCompressions: [] };
}

export const ComputeThreatListDiffRequest_Constraints: MessageFns<ComputeThreatListDiffRequest_Constraints> = {
  encode(message: ComputeThreatListDiffRequest_Constraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxDiffEntries !== 0) {
      writer.uint32(8).int32(message.maxDiffEntries);
    }
    if (message.maxDatabaseEntries !== 0) {
      writer.uint32(16).int32(message.maxDatabaseEntries);
    }
    writer.uint32(26).fork();
    for (const v of message.supportedCompressions) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeThreatListDiffRequest_Constraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeThreatListDiffRequest_Constraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxDiffEntries = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxDatabaseEntries = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.supportedCompressions.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedCompressions.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeThreatListDiffRequest_Constraints {
    return {
      maxDiffEntries: isSet(object.maxDiffEntries) ? globalThis.Number(object.maxDiffEntries) : 0,
      maxDatabaseEntries: isSet(object.maxDatabaseEntries) ? globalThis.Number(object.maxDatabaseEntries) : 0,
      supportedCompressions: globalThis.Array.isArray(object?.supportedCompressions)
        ? object.supportedCompressions.map((e: any) => compressionTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: ComputeThreatListDiffRequest_Constraints): unknown {
    const obj: any = {};
    if (message.maxDiffEntries !== 0) {
      obj.maxDiffEntries = Math.round(message.maxDiffEntries);
    }
    if (message.maxDatabaseEntries !== 0) {
      obj.maxDatabaseEntries = Math.round(message.maxDatabaseEntries);
    }
    if (message.supportedCompressions?.length) {
      obj.supportedCompressions = message.supportedCompressions.map((e) => compressionTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeThreatListDiffRequest_Constraints>): ComputeThreatListDiffRequest_Constraints {
    return ComputeThreatListDiffRequest_Constraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeThreatListDiffRequest_Constraints>): ComputeThreatListDiffRequest_Constraints {
    const message = createBaseComputeThreatListDiffRequest_Constraints();
    message.maxDiffEntries = object.maxDiffEntries ?? 0;
    message.maxDatabaseEntries = object.maxDatabaseEntries ?? 0;
    message.supportedCompressions = object.supportedCompressions?.map((e) => e) || [];
    return message;
  },
};

function createBaseComputeThreatListDiffResponse(): ComputeThreatListDiffResponse {
  return {
    responseType: 0,
    additions: undefined,
    removals: undefined,
    newVersionToken: Buffer.alloc(0),
    checksum: undefined,
    recommendedNextDiff: undefined,
  };
}

export const ComputeThreatListDiffResponse: MessageFns<ComputeThreatListDiffResponse> = {
  encode(message: ComputeThreatListDiffResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseType !== 0) {
      writer.uint32(32).int32(message.responseType);
    }
    if (message.additions !== undefined) {
      ThreatEntryAdditions.encode(message.additions, writer.uint32(42).fork()).join();
    }
    if (message.removals !== undefined) {
      ThreatEntryRemovals.encode(message.removals, writer.uint32(50).fork()).join();
    }
    if (message.newVersionToken.length !== 0) {
      writer.uint32(58).bytes(message.newVersionToken);
    }
    if (message.checksum !== undefined) {
      ComputeThreatListDiffResponse_Checksum.encode(message.checksum, writer.uint32(66).fork()).join();
    }
    if (message.recommendedNextDiff !== undefined) {
      Timestamp.encode(toTimestamp(message.recommendedNextDiff), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeThreatListDiffResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeThreatListDiffResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.responseType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additions = ThreatEntryAdditions.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.removals = ThreatEntryRemovals.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.newVersionToken = Buffer.from(reader.bytes());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.checksum = ComputeThreatListDiffResponse_Checksum.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recommendedNextDiff = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeThreatListDiffResponse {
    return {
      responseType: isSet(object.responseType)
        ? computeThreatListDiffResponse_ResponseTypeFromJSON(object.responseType)
        : 0,
      additions: isSet(object.additions) ? ThreatEntryAdditions.fromJSON(object.additions) : undefined,
      removals: isSet(object.removals) ? ThreatEntryRemovals.fromJSON(object.removals) : undefined,
      newVersionToken: isSet(object.newVersionToken)
        ? Buffer.from(bytesFromBase64(object.newVersionToken))
        : Buffer.alloc(0),
      checksum: isSet(object.checksum) ? ComputeThreatListDiffResponse_Checksum.fromJSON(object.checksum) : undefined,
      recommendedNextDiff: isSet(object.recommendedNextDiff)
        ? fromJsonTimestamp(object.recommendedNextDiff)
        : undefined,
    };
  },

  toJSON(message: ComputeThreatListDiffResponse): unknown {
    const obj: any = {};
    if (message.responseType !== 0) {
      obj.responseType = computeThreatListDiffResponse_ResponseTypeToJSON(message.responseType);
    }
    if (message.additions !== undefined) {
      obj.additions = ThreatEntryAdditions.toJSON(message.additions);
    }
    if (message.removals !== undefined) {
      obj.removals = ThreatEntryRemovals.toJSON(message.removals);
    }
    if (message.newVersionToken.length !== 0) {
      obj.newVersionToken = base64FromBytes(message.newVersionToken);
    }
    if (message.checksum !== undefined) {
      obj.checksum = ComputeThreatListDiffResponse_Checksum.toJSON(message.checksum);
    }
    if (message.recommendedNextDiff !== undefined) {
      obj.recommendedNextDiff = message.recommendedNextDiff.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeThreatListDiffResponse>): ComputeThreatListDiffResponse {
    return ComputeThreatListDiffResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeThreatListDiffResponse>): ComputeThreatListDiffResponse {
    const message = createBaseComputeThreatListDiffResponse();
    message.responseType = object.responseType ?? 0;
    message.additions = (object.additions !== undefined && object.additions !== null)
      ? ThreatEntryAdditions.fromPartial(object.additions)
      : undefined;
    message.removals = (object.removals !== undefined && object.removals !== null)
      ? ThreatEntryRemovals.fromPartial(object.removals)
      : undefined;
    message.newVersionToken = object.newVersionToken ?? Buffer.alloc(0);
    message.checksum = (object.checksum !== undefined && object.checksum !== null)
      ? ComputeThreatListDiffResponse_Checksum.fromPartial(object.checksum)
      : undefined;
    message.recommendedNextDiff = object.recommendedNextDiff ?? undefined;
    return message;
  },
};

function createBaseComputeThreatListDiffResponse_Checksum(): ComputeThreatListDiffResponse_Checksum {
  return { sha256: Buffer.alloc(0) };
}

export const ComputeThreatListDiffResponse_Checksum: MessageFns<ComputeThreatListDiffResponse_Checksum> = {
  encode(message: ComputeThreatListDiffResponse_Checksum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sha256.length !== 0) {
      writer.uint32(10).bytes(message.sha256);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeThreatListDiffResponse_Checksum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeThreatListDiffResponse_Checksum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sha256 = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeThreatListDiffResponse_Checksum {
    return { sha256: isSet(object.sha256) ? Buffer.from(bytesFromBase64(object.sha256)) : Buffer.alloc(0) };
  },

  toJSON(message: ComputeThreatListDiffResponse_Checksum): unknown {
    const obj: any = {};
    if (message.sha256.length !== 0) {
      obj.sha256 = base64FromBytes(message.sha256);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeThreatListDiffResponse_Checksum>): ComputeThreatListDiffResponse_Checksum {
    return ComputeThreatListDiffResponse_Checksum.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeThreatListDiffResponse_Checksum>): ComputeThreatListDiffResponse_Checksum {
    const message = createBaseComputeThreatListDiffResponse_Checksum();
    message.sha256 = object.sha256 ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSearchUrisRequest(): SearchUrisRequest {
  return { uri: "", threatTypes: [] };
}

export const SearchUrisRequest: MessageFns<SearchUrisRequest> = {
  encode(message: SearchUrisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    writer.uint32(18).fork();
    for (const v of message.threatTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchUrisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUrisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.threatTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.threatTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchUrisRequest {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      threatTypes: globalThis.Array.isArray(object?.threatTypes)
        ? object.threatTypes.map((e: any) => threatTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchUrisRequest): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.threatTypes?.length) {
      obj.threatTypes = message.threatTypes.map((e) => threatTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchUrisRequest>): SearchUrisRequest {
    return SearchUrisRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchUrisRequest>): SearchUrisRequest {
    const message = createBaseSearchUrisRequest();
    message.uri = object.uri ?? "";
    message.threatTypes = object.threatTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchUrisResponse(): SearchUrisResponse {
  return { threat: undefined };
}

export const SearchUrisResponse: MessageFns<SearchUrisResponse> = {
  encode(message: SearchUrisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threat !== undefined) {
      SearchUrisResponse_ThreatUri.encode(message.threat, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchUrisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUrisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threat = SearchUrisResponse_ThreatUri.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchUrisResponse {
    return { threat: isSet(object.threat) ? SearchUrisResponse_ThreatUri.fromJSON(object.threat) : undefined };
  },

  toJSON(message: SearchUrisResponse): unknown {
    const obj: any = {};
    if (message.threat !== undefined) {
      obj.threat = SearchUrisResponse_ThreatUri.toJSON(message.threat);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchUrisResponse>): SearchUrisResponse {
    return SearchUrisResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchUrisResponse>): SearchUrisResponse {
    const message = createBaseSearchUrisResponse();
    message.threat = (object.threat !== undefined && object.threat !== null)
      ? SearchUrisResponse_ThreatUri.fromPartial(object.threat)
      : undefined;
    return message;
  },
};

function createBaseSearchUrisResponse_ThreatUri(): SearchUrisResponse_ThreatUri {
  return { threatTypes: [], expireTime: undefined };
}

export const SearchUrisResponse_ThreatUri: MessageFns<SearchUrisResponse_ThreatUri> = {
  encode(message: SearchUrisResponse_ThreatUri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.threatTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchUrisResponse_ThreatUri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchUrisResponse_ThreatUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.threatTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.threatTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchUrisResponse_ThreatUri {
    return {
      threatTypes: globalThis.Array.isArray(object?.threatTypes)
        ? object.threatTypes.map((e: any) => threatTypeFromJSON(e))
        : [],
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: SearchUrisResponse_ThreatUri): unknown {
    const obj: any = {};
    if (message.threatTypes?.length) {
      obj.threatTypes = message.threatTypes.map((e) => threatTypeToJSON(e));
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchUrisResponse_ThreatUri>): SearchUrisResponse_ThreatUri {
    return SearchUrisResponse_ThreatUri.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchUrisResponse_ThreatUri>): SearchUrisResponse_ThreatUri {
    const message = createBaseSearchUrisResponse_ThreatUri();
    message.threatTypes = object.threatTypes?.map((e) => e) || [];
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseSearchHashesRequest(): SearchHashesRequest {
  return { hashPrefix: Buffer.alloc(0), threatTypes: [] };
}

export const SearchHashesRequest: MessageFns<SearchHashesRequest> = {
  encode(message: SearchHashesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hashPrefix.length !== 0) {
      writer.uint32(10).bytes(message.hashPrefix);
    }
    writer.uint32(18).fork();
    for (const v of message.threatTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHashesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHashesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hashPrefix = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag === 16) {
            message.threatTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.threatTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHashesRequest {
    return {
      hashPrefix: isSet(object.hashPrefix) ? Buffer.from(bytesFromBase64(object.hashPrefix)) : Buffer.alloc(0),
      threatTypes: globalThis.Array.isArray(object?.threatTypes)
        ? object.threatTypes.map((e: any) => threatTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchHashesRequest): unknown {
    const obj: any = {};
    if (message.hashPrefix.length !== 0) {
      obj.hashPrefix = base64FromBytes(message.hashPrefix);
    }
    if (message.threatTypes?.length) {
      obj.threatTypes = message.threatTypes.map((e) => threatTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHashesRequest>): SearchHashesRequest {
    return SearchHashesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHashesRequest>): SearchHashesRequest {
    const message = createBaseSearchHashesRequest();
    message.hashPrefix = object.hashPrefix ?? Buffer.alloc(0);
    message.threatTypes = object.threatTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchHashesResponse(): SearchHashesResponse {
  return { threats: [], negativeExpireTime: undefined };
}

export const SearchHashesResponse: MessageFns<SearchHashesResponse> = {
  encode(message: SearchHashesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.threats) {
      SearchHashesResponse_ThreatHash.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.negativeExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.negativeExpireTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHashesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHashesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.threats.push(SearchHashesResponse_ThreatHash.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.negativeExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHashesResponse {
    return {
      threats: globalThis.Array.isArray(object?.threats)
        ? object.threats.map((e: any) => SearchHashesResponse_ThreatHash.fromJSON(e))
        : [],
      negativeExpireTime: isSet(object.negativeExpireTime) ? fromJsonTimestamp(object.negativeExpireTime) : undefined,
    };
  },

  toJSON(message: SearchHashesResponse): unknown {
    const obj: any = {};
    if (message.threats?.length) {
      obj.threats = message.threats.map((e) => SearchHashesResponse_ThreatHash.toJSON(e));
    }
    if (message.negativeExpireTime !== undefined) {
      obj.negativeExpireTime = message.negativeExpireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHashesResponse>): SearchHashesResponse {
    return SearchHashesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHashesResponse>): SearchHashesResponse {
    const message = createBaseSearchHashesResponse();
    message.threats = object.threats?.map((e) => SearchHashesResponse_ThreatHash.fromPartial(e)) || [];
    message.negativeExpireTime = object.negativeExpireTime ?? undefined;
    return message;
  },
};

function createBaseSearchHashesResponse_ThreatHash(): SearchHashesResponse_ThreatHash {
  return { threatTypes: [], hash: Buffer.alloc(0), expireTime: undefined };
}

export const SearchHashesResponse_ThreatHash: MessageFns<SearchHashesResponse_ThreatHash> = {
  encode(message: SearchHashesResponse_ThreatHash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.threatTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchHashesResponse_ThreatHash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchHashesResponse_ThreatHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.threatTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.threatTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchHashesResponse_ThreatHash {
    return {
      threatTypes: globalThis.Array.isArray(object?.threatTypes)
        ? object.threatTypes.map((e: any) => threatTypeFromJSON(e))
        : [],
      hash: isSet(object.hash) ? Buffer.from(bytesFromBase64(object.hash)) : Buffer.alloc(0),
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: SearchHashesResponse_ThreatHash): unknown {
    const obj: any = {};
    if (message.threatTypes?.length) {
      obj.threatTypes = message.threatTypes.map((e) => threatTypeToJSON(e));
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchHashesResponse_ThreatHash>): SearchHashesResponse_ThreatHash {
    return SearchHashesResponse_ThreatHash.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchHashesResponse_ThreatHash>): SearchHashesResponse_ThreatHash {
    const message = createBaseSearchHashesResponse_ThreatHash();
    message.threatTypes = object.threatTypes?.map((e) => e) || [];
    message.hash = object.hash ?? Buffer.alloc(0);
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseThreatEntryAdditions(): ThreatEntryAdditions {
  return { rawHashes: [], riceHashes: undefined };
}

export const ThreatEntryAdditions: MessageFns<ThreatEntryAdditions> = {
  encode(message: ThreatEntryAdditions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rawHashes) {
      RawHashes.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.riceHashes !== undefined) {
      RiceDeltaEncoding.encode(message.riceHashes, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatEntryAdditions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatEntryAdditions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawHashes.push(RawHashes.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.riceHashes = RiceDeltaEncoding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatEntryAdditions {
    return {
      rawHashes: globalThis.Array.isArray(object?.rawHashes)
        ? object.rawHashes.map((e: any) => RawHashes.fromJSON(e))
        : [],
      riceHashes: isSet(object.riceHashes) ? RiceDeltaEncoding.fromJSON(object.riceHashes) : undefined,
    };
  },

  toJSON(message: ThreatEntryAdditions): unknown {
    const obj: any = {};
    if (message.rawHashes?.length) {
      obj.rawHashes = message.rawHashes.map((e) => RawHashes.toJSON(e));
    }
    if (message.riceHashes !== undefined) {
      obj.riceHashes = RiceDeltaEncoding.toJSON(message.riceHashes);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatEntryAdditions>): ThreatEntryAdditions {
    return ThreatEntryAdditions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatEntryAdditions>): ThreatEntryAdditions {
    const message = createBaseThreatEntryAdditions();
    message.rawHashes = object.rawHashes?.map((e) => RawHashes.fromPartial(e)) || [];
    message.riceHashes = (object.riceHashes !== undefined && object.riceHashes !== null)
      ? RiceDeltaEncoding.fromPartial(object.riceHashes)
      : undefined;
    return message;
  },
};

function createBaseThreatEntryRemovals(): ThreatEntryRemovals {
  return { rawIndices: undefined, riceIndices: undefined };
}

export const ThreatEntryRemovals: MessageFns<ThreatEntryRemovals> = {
  encode(message: ThreatEntryRemovals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawIndices !== undefined) {
      RawIndices.encode(message.rawIndices, writer.uint32(10).fork()).join();
    }
    if (message.riceIndices !== undefined) {
      RiceDeltaEncoding.encode(message.riceIndices, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatEntryRemovals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatEntryRemovals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawIndices = RawIndices.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.riceIndices = RiceDeltaEncoding.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatEntryRemovals {
    return {
      rawIndices: isSet(object.rawIndices) ? RawIndices.fromJSON(object.rawIndices) : undefined,
      riceIndices: isSet(object.riceIndices) ? RiceDeltaEncoding.fromJSON(object.riceIndices) : undefined,
    };
  },

  toJSON(message: ThreatEntryRemovals): unknown {
    const obj: any = {};
    if (message.rawIndices !== undefined) {
      obj.rawIndices = RawIndices.toJSON(message.rawIndices);
    }
    if (message.riceIndices !== undefined) {
      obj.riceIndices = RiceDeltaEncoding.toJSON(message.riceIndices);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatEntryRemovals>): ThreatEntryRemovals {
    return ThreatEntryRemovals.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatEntryRemovals>): ThreatEntryRemovals {
    const message = createBaseThreatEntryRemovals();
    message.rawIndices = (object.rawIndices !== undefined && object.rawIndices !== null)
      ? RawIndices.fromPartial(object.rawIndices)
      : undefined;
    message.riceIndices = (object.riceIndices !== undefined && object.riceIndices !== null)
      ? RiceDeltaEncoding.fromPartial(object.riceIndices)
      : undefined;
    return message;
  },
};

function createBaseRawIndices(): RawIndices {
  return { indices: [] };
}

export const RawIndices: MessageFns<RawIndices> = {
  encode(message: RawIndices, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.indices) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawIndices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawIndices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.indices.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.indices.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawIndices {
    return {
      indices: globalThis.Array.isArray(object?.indices) ? object.indices.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: RawIndices): unknown {
    const obj: any = {};
    if (message.indices?.length) {
      obj.indices = message.indices.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RawIndices>): RawIndices {
    return RawIndices.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawIndices>): RawIndices {
    const message = createBaseRawIndices();
    message.indices = object.indices?.map((e) => e) || [];
    return message;
  },
};

function createBaseRawHashes(): RawHashes {
  return { prefixSize: 0, rawHashes: Buffer.alloc(0) };
}

export const RawHashes: MessageFns<RawHashes> = {
  encode(message: RawHashes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prefixSize !== 0) {
      writer.uint32(8).int32(message.prefixSize);
    }
    if (message.rawHashes.length !== 0) {
      writer.uint32(18).bytes(message.rawHashes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RawHashes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRawHashes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.prefixSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rawHashes = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RawHashes {
    return {
      prefixSize: isSet(object.prefixSize) ? globalThis.Number(object.prefixSize) : 0,
      rawHashes: isSet(object.rawHashes) ? Buffer.from(bytesFromBase64(object.rawHashes)) : Buffer.alloc(0),
    };
  },

  toJSON(message: RawHashes): unknown {
    const obj: any = {};
    if (message.prefixSize !== 0) {
      obj.prefixSize = Math.round(message.prefixSize);
    }
    if (message.rawHashes.length !== 0) {
      obj.rawHashes = base64FromBytes(message.rawHashes);
    }
    return obj;
  },

  create(base?: DeepPartial<RawHashes>): RawHashes {
    return RawHashes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RawHashes>): RawHashes {
    const message = createBaseRawHashes();
    message.prefixSize = object.prefixSize ?? 0;
    message.rawHashes = object.rawHashes ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseRiceDeltaEncoding(): RiceDeltaEncoding {
  return { firstValue: Long.ZERO, riceParameter: 0, entryCount: 0, encodedData: Buffer.alloc(0) };
}

export const RiceDeltaEncoding: MessageFns<RiceDeltaEncoding> = {
  encode(message: RiceDeltaEncoding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.firstValue.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.firstValue.toString());
    }
    if (message.riceParameter !== 0) {
      writer.uint32(16).int32(message.riceParameter);
    }
    if (message.entryCount !== 0) {
      writer.uint32(24).int32(message.entryCount);
    }
    if (message.encodedData.length !== 0) {
      writer.uint32(34).bytes(message.encodedData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RiceDeltaEncoding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRiceDeltaEncoding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.firstValue = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.riceParameter = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.entryCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.encodedData = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RiceDeltaEncoding {
    return {
      firstValue: isSet(object.firstValue) ? Long.fromValue(object.firstValue) : Long.ZERO,
      riceParameter: isSet(object.riceParameter) ? globalThis.Number(object.riceParameter) : 0,
      entryCount: isSet(object.entryCount) ? globalThis.Number(object.entryCount) : 0,
      encodedData: isSet(object.encodedData) ? Buffer.from(bytesFromBase64(object.encodedData)) : Buffer.alloc(0),
    };
  },

  toJSON(message: RiceDeltaEncoding): unknown {
    const obj: any = {};
    if (!message.firstValue.equals(Long.ZERO)) {
      obj.firstValue = (message.firstValue || Long.ZERO).toString();
    }
    if (message.riceParameter !== 0) {
      obj.riceParameter = Math.round(message.riceParameter);
    }
    if (message.entryCount !== 0) {
      obj.entryCount = Math.round(message.entryCount);
    }
    if (message.encodedData.length !== 0) {
      obj.encodedData = base64FromBytes(message.encodedData);
    }
    return obj;
  },

  create(base?: DeepPartial<RiceDeltaEncoding>): RiceDeltaEncoding {
    return RiceDeltaEncoding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RiceDeltaEncoding>): RiceDeltaEncoding {
    const message = createBaseRiceDeltaEncoding();
    message.firstValue = (object.firstValue !== undefined && object.firstValue !== null)
      ? Long.fromValue(object.firstValue)
      : Long.ZERO;
    message.riceParameter = object.riceParameter ?? 0;
    message.entryCount = object.entryCount ?? 0;
    message.encodedData = object.encodedData ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseSubmission(): Submission {
  return { uri: "", threatTypes: [] };
}

export const Submission: MessageFns<Submission> = {
  encode(message: Submission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    writer.uint32(18).fork();
    for (const v of message.threatTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Submission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.threatTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.threatTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Submission {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      threatTypes: globalThis.Array.isArray(object?.threatTypes)
        ? object.threatTypes.map((e: any) => threatTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: Submission): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.threatTypes?.length) {
      obj.threatTypes = message.threatTypes.map((e) => threatTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Submission>): Submission {
    return Submission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Submission>): Submission {
    const message = createBaseSubmission();
    message.uri = object.uri ?? "";
    message.threatTypes = object.threatTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseThreatInfo(): ThreatInfo {
  return { abuseType: 0, threatConfidence: undefined, threatJustification: undefined };
}

export const ThreatInfo: MessageFns<ThreatInfo> = {
  encode(message: ThreatInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.abuseType !== 0) {
      writer.uint32(8).int32(message.abuseType);
    }
    if (message.threatConfidence !== undefined) {
      ThreatInfo_Confidence.encode(message.threatConfidence, writer.uint32(18).fork()).join();
    }
    if (message.threatJustification !== undefined) {
      ThreatInfo_ThreatJustification.encode(message.threatJustification, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.abuseType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threatConfidence = ThreatInfo_Confidence.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.threatJustification = ThreatInfo_ThreatJustification.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatInfo {
    return {
      abuseType: isSet(object.abuseType) ? threatInfo_AbuseTypeFromJSON(object.abuseType) : 0,
      threatConfidence: isSet(object.threatConfidence)
        ? ThreatInfo_Confidence.fromJSON(object.threatConfidence)
        : undefined,
      threatJustification: isSet(object.threatJustification)
        ? ThreatInfo_ThreatJustification.fromJSON(object.threatJustification)
        : undefined,
    };
  },

  toJSON(message: ThreatInfo): unknown {
    const obj: any = {};
    if (message.abuseType !== 0) {
      obj.abuseType = threatInfo_AbuseTypeToJSON(message.abuseType);
    }
    if (message.threatConfidence !== undefined) {
      obj.threatConfidence = ThreatInfo_Confidence.toJSON(message.threatConfidence);
    }
    if (message.threatJustification !== undefined) {
      obj.threatJustification = ThreatInfo_ThreatJustification.toJSON(message.threatJustification);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatInfo>): ThreatInfo {
    return ThreatInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatInfo>): ThreatInfo {
    const message = createBaseThreatInfo();
    message.abuseType = object.abuseType ?? 0;
    message.threatConfidence = (object.threatConfidence !== undefined && object.threatConfidence !== null)
      ? ThreatInfo_Confidence.fromPartial(object.threatConfidence)
      : undefined;
    message.threatJustification = (object.threatJustification !== undefined && object.threatJustification !== null)
      ? ThreatInfo_ThreatJustification.fromPartial(object.threatJustification)
      : undefined;
    return message;
  },
};

function createBaseThreatInfo_Confidence(): ThreatInfo_Confidence {
  return { score: undefined, level: undefined };
}

export const ThreatInfo_Confidence: MessageFns<ThreatInfo_Confidence> = {
  encode(message: ThreatInfo_Confidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(13).float(message.score);
    }
    if (message.level !== undefined) {
      writer.uint32(16).int32(message.level);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatInfo_Confidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatInfo_Confidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.score = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatInfo_Confidence {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      level: isSet(object.level) ? threatInfo_Confidence_ConfidenceLevelFromJSON(object.level) : undefined,
    };
  },

  toJSON(message: ThreatInfo_Confidence): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.level !== undefined) {
      obj.level = threatInfo_Confidence_ConfidenceLevelToJSON(message.level);
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatInfo_Confidence>): ThreatInfo_Confidence {
    return ThreatInfo_Confidence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatInfo_Confidence>): ThreatInfo_Confidence {
    const message = createBaseThreatInfo_Confidence();
    message.score = object.score ?? undefined;
    message.level = object.level ?? undefined;
    return message;
  },
};

function createBaseThreatInfo_ThreatJustification(): ThreatInfo_ThreatJustification {
  return { labels: [], comments: [] };
}

export const ThreatInfo_ThreatJustification: MessageFns<ThreatInfo_ThreatJustification> = {
  encode(message: ThreatInfo_ThreatJustification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.labels) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.comments) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatInfo_ThreatJustification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatInfo_ThreatJustification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.labels.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.labels.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comments.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatInfo_ThreatJustification {
    return {
      labels: globalThis.Array.isArray(object?.labels)
        ? object.labels.map((e: any) => threatInfo_ThreatJustification_JustificationLabelFromJSON(e))
        : [],
      comments: globalThis.Array.isArray(object?.comments) ? object.comments.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ThreatInfo_ThreatJustification): unknown {
    const obj: any = {};
    if (message.labels?.length) {
      obj.labels = message.labels.map((e) => threatInfo_ThreatJustification_JustificationLabelToJSON(e));
    }
    if (message.comments?.length) {
      obj.comments = message.comments;
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatInfo_ThreatJustification>): ThreatInfo_ThreatJustification {
    return ThreatInfo_ThreatJustification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatInfo_ThreatJustification>): ThreatInfo_ThreatJustification {
    const message = createBaseThreatInfo_ThreatJustification();
    message.labels = object.labels?.map((e) => e) || [];
    message.comments = object.comments?.map((e) => e) || [];
    return message;
  },
};

function createBaseThreatDiscovery(): ThreatDiscovery {
  return { platform: 0, regionCodes: [] };
}

export const ThreatDiscovery: MessageFns<ThreatDiscovery> = {
  encode(message: ThreatDiscovery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platform !== 0) {
      writer.uint32(8).int32(message.platform);
    }
    for (const v of message.regionCodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ThreatDiscovery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreatDiscovery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regionCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ThreatDiscovery {
    return {
      platform: isSet(object.platform) ? threatDiscovery_PlatformFromJSON(object.platform) : 0,
      regionCodes: globalThis.Array.isArray(object?.regionCodes)
        ? object.regionCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ThreatDiscovery): unknown {
    const obj: any = {};
    if (message.platform !== 0) {
      obj.platform = threatDiscovery_PlatformToJSON(message.platform);
    }
    if (message.regionCodes?.length) {
      obj.regionCodes = message.regionCodes;
    }
    return obj;
  },

  create(base?: DeepPartial<ThreatDiscovery>): ThreatDiscovery {
    return ThreatDiscovery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ThreatDiscovery>): ThreatDiscovery {
    const message = createBaseThreatDiscovery();
    message.platform = object.platform ?? 0;
    message.regionCodes = object.regionCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateSubmissionRequest(): CreateSubmissionRequest {
  return { parent: "", submission: undefined };
}

export const CreateSubmissionRequest: MessageFns<CreateSubmissionRequest> = {
  encode(message: CreateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.submission !== undefined) {
      Submission.encode(message.submission, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submission = Submission.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSubmissionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      submission: isSet(object.submission) ? Submission.fromJSON(object.submission) : undefined,
    };
  },

  toJSON(message: CreateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.submission !== undefined) {
      obj.submission = Submission.toJSON(message.submission);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSubmissionRequest>): CreateSubmissionRequest {
    return CreateSubmissionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSubmissionRequest>): CreateSubmissionRequest {
    const message = createBaseCreateSubmissionRequest();
    message.parent = object.parent ?? "";
    message.submission = (object.submission !== undefined && object.submission !== null)
      ? Submission.fromPartial(object.submission)
      : undefined;
    return message;
  },
};

function createBaseSubmitUriRequest(): SubmitUriRequest {
  return { parent: "", submission: undefined, threatInfo: undefined, threatDiscovery: undefined };
}

export const SubmitUriRequest: MessageFns<SubmitUriRequest> = {
  encode(message: SubmitUriRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.submission !== undefined) {
      Submission.encode(message.submission, writer.uint32(18).fork()).join();
    }
    if (message.threatInfo !== undefined) {
      ThreatInfo.encode(message.threatInfo, writer.uint32(26).fork()).join();
    }
    if (message.threatDiscovery !== undefined) {
      ThreatDiscovery.encode(message.threatDiscovery, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitUriRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitUriRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.submission = Submission.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.threatInfo = ThreatInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.threatDiscovery = ThreatDiscovery.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitUriRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      submission: isSet(object.submission) ? Submission.fromJSON(object.submission) : undefined,
      threatInfo: isSet(object.threatInfo) ? ThreatInfo.fromJSON(object.threatInfo) : undefined,
      threatDiscovery: isSet(object.threatDiscovery) ? ThreatDiscovery.fromJSON(object.threatDiscovery) : undefined,
    };
  },

  toJSON(message: SubmitUriRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.submission !== undefined) {
      obj.submission = Submission.toJSON(message.submission);
    }
    if (message.threatInfo !== undefined) {
      obj.threatInfo = ThreatInfo.toJSON(message.threatInfo);
    }
    if (message.threatDiscovery !== undefined) {
      obj.threatDiscovery = ThreatDiscovery.toJSON(message.threatDiscovery);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitUriRequest>): SubmitUriRequest {
    return SubmitUriRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitUriRequest>): SubmitUriRequest {
    const message = createBaseSubmitUriRequest();
    message.parent = object.parent ?? "";
    message.submission = (object.submission !== undefined && object.submission !== null)
      ? Submission.fromPartial(object.submission)
      : undefined;
    message.threatInfo = (object.threatInfo !== undefined && object.threatInfo !== null)
      ? ThreatInfo.fromPartial(object.threatInfo)
      : undefined;
    message.threatDiscovery = (object.threatDiscovery !== undefined && object.threatDiscovery !== null)
      ? ThreatDiscovery.fromPartial(object.threatDiscovery)
      : undefined;
    return message;
  },
};

function createBaseSubmitUriMetadata(): SubmitUriMetadata {
  return { state: 0, createTime: undefined, updateTime: undefined };
}

export const SubmitUriMetadata: MessageFns<SubmitUriMetadata> = {
  encode(message: SubmitUriMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitUriMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitUriMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitUriMetadata {
    return {
      state: isSet(object.state) ? submitUriMetadata_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: SubmitUriMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = submitUriMetadata_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitUriMetadata>): SubmitUriMetadata {
    return SubmitUriMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitUriMetadata>): SubmitUriMetadata {
    const message = createBaseSubmitUriMetadata();
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

/**
 * Web Risk API defines an interface to detect malicious URLs on your
 * website and in client applications.
 */
export type WebRiskServiceDefinition = typeof WebRiskServiceDefinition;
export const WebRiskServiceDefinition = {
  name: "WebRiskService",
  fullName: "google.cloud.webrisk.v1.WebRiskService",
  methods: {
    /**
     * Gets the most recent threat list diffs. These diffs should be applied to
     * a local database of hashes to keep it up-to-date. If the local database is
     * empty or excessively out-of-date, a complete snapshot of the database will
     * be returned. This Method only updates a single ThreatList at a time. To
     * update multiple ThreatList databases, this method needs to be called once
     * for each list.
     */
    computeThreatListDiff: {
      name: "ComputeThreatListDiff",
      requestType: ComputeThreatListDiffRequest,
      requestStream: false,
      responseType: ComputeThreatListDiffResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              37,
              116,
              104,
              114,
              101,
              97,
              116,
              95,
              116,
              121,
              112,
              101,
              44,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
              95,
              116,
              111,
              107,
              101,
              110,
              44,
              99,
              111,
              110,
              115,
              116,
              114,
              97,
              105,
              110,
              116,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              29,
              18,
              27,
              47,
              118,
              49,
              47,
              116,
              104,
              114,
              101,
              97,
              116,
              76,
              105,
              115,
              116,
              115,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              68,
              105,
              102,
              102,
            ]),
          ],
        },
      },
    },
    /**
     * This method is used to check whether a URI is on a given threatList.
     * Multiple threatLists may be searched in a single query.
     * The response will list all requested threatLists the URI was found to
     * match. If the URI is not found on any of the requested ThreatList an
     * empty response will be returned.
     */
    searchUris: {
      name: "SearchUris",
      requestType: SearchUrisRequest,
      requestStream: false,
      responseType: SearchUrisResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 117, 114, 105, 44, 116, 104, 114, 101, 97, 116, 95, 116, 121, 112, 101, 115])],
          578365826: [Buffer.from([17, 18, 15, 47, 118, 49, 47, 117, 114, 105, 115, 58, 115, 101, 97, 114, 99, 104])],
        },
      },
    },
    /**
     * Gets the full hashes that match the requested hash prefix.
     * This is used after a hash prefix is looked up in a threatList
     * and there is a match. The client side threatList only holds partial hashes
     * so the client must query this method to determine if there is a full
     * hash match of a threat.
     */
    searchHashes: {
      name: "SearchHashes",
      requestType: SearchHashesRequest,
      requestStream: false,
      responseType: SearchHashesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              24,
              104,
              97,
              115,
              104,
              95,
              112,
              114,
              101,
              102,
              105,
              120,
              44,
              116,
              104,
              114,
              101,
              97,
              116,
              95,
              116,
              121,
              112,
              101,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([19, 18, 17, 47, 118, 49, 47, 104, 97, 115, 104, 101, 115, 58, 115, 101, 97, 114, 99, 104]),
          ],
        },
      },
    },
    /**
     * Creates a Submission of a URI suspected of containing phishing content to
     * be reviewed. If the result verifies the existence of malicious phishing
     * content, the site will be added to the [Google's Social Engineering
     * lists](https://support.google.com/webmasters/answer/6350487/) in order to
     * protect users that could get exposed to this threat in the future. Only
     * allowlisted projects can use this method during Early Access. Please reach
     * out to Sales or your customer engineer to obtain access.
     */
    createSubmission: {
      name: "CreateSubmission",
      requestType: CreateSubmissionRequest,
      requestStream: false,
      responseType: Submission,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 112, 97, 114, 101, 110, 116, 44, 115, 117, 98, 109, 105, 115, 115, 105, 111, 110])],
          578365826: [
            Buffer.from([
              49,
              58,
              10,
              115,
              117,
              98,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              34,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Submits a URI suspected of containing malicious content to be reviewed.
     * Returns a google.longrunning.Operation which, once the review is complete,
     * is updated with its result. You can use the [Pub/Sub API]
     * (https://cloud.google.com/pubsub) to receive notifications for the returned
     * Operation. If the result verifies the existence of malicious content, the
     * site will be added to the [Google's Social Engineering lists]
     * (https://support.google.com/webmasters/answer/6350487/) in order to
     * protect users that could get exposed to this threat in the future. Only
     * allowlisted projects can use this method during Early Access. Please reach
     * out to Sales or your customer engineer to obtain access.
     */
    submitUri: {
      name: "SubmitUri",
      requestType: SubmitUriRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              83,
              117,
              98,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              18,
              17,
              83,
              117,
              98,
              109,
              105,
              116,
              85,
              114,
              105,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              40,
              58,
              1,
              42,
              34,
              35,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              117,
              114,
              105,
              115,
              58,
              115,
              117,
              98,
              109,
              105,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface WebRiskServiceImplementation<CallContextExt = {}> {
  /**
   * Gets the most recent threat list diffs. These diffs should be applied to
   * a local database of hashes to keep it up-to-date. If the local database is
   * empty or excessively out-of-date, a complete snapshot of the database will
   * be returned. This Method only updates a single ThreatList at a time. To
   * update multiple ThreatList databases, this method needs to be called once
   * for each list.
   */
  computeThreatListDiff(
    request: ComputeThreatListDiffRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeThreatListDiffResponse>>;
  /**
   * This method is used to check whether a URI is on a given threatList.
   * Multiple threatLists may be searched in a single query.
   * The response will list all requested threatLists the URI was found to
   * match. If the URI is not found on any of the requested ThreatList an
   * empty response will be returned.
   */
  searchUris(
    request: SearchUrisRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchUrisResponse>>;
  /**
   * Gets the full hashes that match the requested hash prefix.
   * This is used after a hash prefix is looked up in a threatList
   * and there is a match. The client side threatList only holds partial hashes
   * so the client must query this method to determine if there is a full
   * hash match of a threat.
   */
  searchHashes(
    request: SearchHashesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchHashesResponse>>;
  /**
   * Creates a Submission of a URI suspected of containing phishing content to
   * be reviewed. If the result verifies the existence of malicious phishing
   * content, the site will be added to the [Google's Social Engineering
   * lists](https://support.google.com/webmasters/answer/6350487/) in order to
   * protect users that could get exposed to this threat in the future. Only
   * allowlisted projects can use this method during Early Access. Please reach
   * out to Sales or your customer engineer to obtain access.
   */
  createSubmission(
    request: CreateSubmissionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Submission>>;
  /**
   * Submits a URI suspected of containing malicious content to be reviewed.
   * Returns a google.longrunning.Operation which, once the review is complete,
   * is updated with its result. You can use the [Pub/Sub API]
   * (https://cloud.google.com/pubsub) to receive notifications for the returned
   * Operation. If the result verifies the existence of malicious content, the
   * site will be added to the [Google's Social Engineering lists]
   * (https://support.google.com/webmasters/answer/6350487/) in order to
   * protect users that could get exposed to this threat in the future. Only
   * allowlisted projects can use this method during Early Access. Please reach
   * out to Sales or your customer engineer to obtain access.
   */
  submitUri(request: SubmitUriRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface WebRiskServiceClient<CallOptionsExt = {}> {
  /**
   * Gets the most recent threat list diffs. These diffs should be applied to
   * a local database of hashes to keep it up-to-date. If the local database is
   * empty or excessively out-of-date, a complete snapshot of the database will
   * be returned. This Method only updates a single ThreatList at a time. To
   * update multiple ThreatList databases, this method needs to be called once
   * for each list.
   */
  computeThreatListDiff(
    request: DeepPartial<ComputeThreatListDiffRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeThreatListDiffResponse>;
  /**
   * This method is used to check whether a URI is on a given threatList.
   * Multiple threatLists may be searched in a single query.
   * The response will list all requested threatLists the URI was found to
   * match. If the URI is not found on any of the requested ThreatList an
   * empty response will be returned.
   */
  searchUris(
    request: DeepPartial<SearchUrisRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchUrisResponse>;
  /**
   * Gets the full hashes that match the requested hash prefix.
   * This is used after a hash prefix is looked up in a threatList
   * and there is a match. The client side threatList only holds partial hashes
   * so the client must query this method to determine if there is a full
   * hash match of a threat.
   */
  searchHashes(
    request: DeepPartial<SearchHashesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchHashesResponse>;
  /**
   * Creates a Submission of a URI suspected of containing phishing content to
   * be reviewed. If the result verifies the existence of malicious phishing
   * content, the site will be added to the [Google's Social Engineering
   * lists](https://support.google.com/webmasters/answer/6350487/) in order to
   * protect users that could get exposed to this threat in the future. Only
   * allowlisted projects can use this method during Early Access. Please reach
   * out to Sales or your customer engineer to obtain access.
   */
  createSubmission(
    request: DeepPartial<CreateSubmissionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Submission>;
  /**
   * Submits a URI suspected of containing malicious content to be reviewed.
   * Returns a google.longrunning.Operation which, once the review is complete,
   * is updated with its result. You can use the [Pub/Sub API]
   * (https://cloud.google.com/pubsub) to receive notifications for the returned
   * Operation. If the result verifies the existence of malicious content, the
   * site will be added to the [Google's Social Engineering lists]
   * (https://support.google.com/webmasters/answer/6350487/) in order to
   * protect users that could get exposed to this threat in the future. Only
   * allowlisted projects can use this method during Early Access. Please reach
   * out to Sales or your customer engineer to obtain access.
   */
  submitUri(request: DeepPartial<SubmitUriRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
