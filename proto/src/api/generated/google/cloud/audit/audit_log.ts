// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/audit/audit_log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../protobuf/any.js";
import { Struct } from "../../protobuf/struct.js";
import {
  AttributeContext_Peer,
  AttributeContext_Request,
  AttributeContext_Resource,
} from "../../rpc/context/attribute_context.js";
import { Status } from "../../rpc/status.js";

export const protobufPackage = "google.cloud.audit";

/** Common audit log format for Google Cloud Platform API operations. */
export interface AuditLog {
  /**
   * The name of the API service performing the operation. For example,
   * `"compute.googleapis.com"`.
   */
  serviceName: string;
  /**
   * The name of the service method or operation.
   * For API calls, this should be the name of the API method.
   * For example,
   *
   *     "google.cloud.bigquery.v2.TableService.InsertTable"
   *     "google.logging.v2.ConfigServiceV2.CreateSink"
   */
  methodName: string;
  /**
   * The resource or collection that is the target of the operation.
   * The name is a scheme-less URI, not including the API service name.
   * For example:
   *
   *     "projects/PROJECT_ID/zones/us-central1-a/instances"
   *     "projects/PROJECT_ID/datasets/DATASET_ID"
   */
  resourceName: string;
  /** The resource location information. */
  resourceLocation:
    | ResourceLocation
    | undefined;
  /**
   * The resource's original state before mutation. Present only for
   * operations which have successfully modified the targeted resource(s).
   * In general, this field should contain all changed fields, except those
   * that are already been included in `request`, `response`, `metadata` or
   * `service_data` fields.
   * When the JSON object represented here has a proto equivalent,
   * the proto name will be indicated in the `@type` property.
   */
  resourceOriginalState:
    | { [key: string]: any }
    | undefined;
  /**
   * The number of items returned from a List or Query API method,
   * if applicable.
   */
  numResponseItems: Long;
  /** The status of the overall operation. */
  status:
    | Status
    | undefined;
  /** Authentication information. */
  authenticationInfo:
    | AuthenticationInfo
    | undefined;
  /**
   * Authorization information. If there are multiple
   * resources or permissions involved, then there is
   * one AuthorizationInfo element for each {resource, permission} tuple.
   */
  authorizationInfo: AuthorizationInfo[];
  /**
   * Indicates the policy violations for this request. If the request
   * is denied by the policy, violation information will be logged
   * here.
   */
  policyViolationInfo:
    | PolicyViolationInfo
    | undefined;
  /** Metadata about the operation. */
  requestMetadata:
    | RequestMetadata
    | undefined;
  /**
   * The operation request. This may not include all request parameters,
   * such as those that are too large, privacy-sensitive, or duplicated
   * elsewhere in the log record.
   * It should never include user-generated data, such as file contents.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  request:
    | { [key: string]: any }
    | undefined;
  /**
   * The operation response. This may not include all response elements,
   * such as those that are too large, privacy-sensitive, or duplicated
   * elsewhere in the log record.
   * It should never include user-generated data, such as file contents.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  response:
    | { [key: string]: any }
    | undefined;
  /**
   * Other service-specific data about the request, response, and other
   * information associated with the current audited event.
   */
  metadata:
    | { [key: string]: any }
    | undefined;
  /**
   * Deprecated. Use the `metadata` field instead.
   * Other service-specific data about the request, response, and other
   * activities.
   *
   * @deprecated
   */
  serviceData: Any | undefined;
}

/** Authentication information for the operation. */
export interface AuthenticationInfo {
  /**
   * The email address of the authenticated user (or service account on behalf
   * of third party principal) making the request. For third party identity
   * callers, the `principal_subject` field is populated instead of this field.
   * For privacy reasons, the principal email address is sometimes redacted.
   * For more information, see [Caller identities in audit
   * logs](https://cloud.google.com/logging/docs/audit#user-id).
   */
  principalEmail: string;
  /**
   * The authority selector specified by the requestor, if any.
   * It is not guaranteed that the principal was allowed to use this authority.
   */
  authoritySelector: string;
  /**
   * The third party identification (if any) of the authenticated user making
   * the request.
   * When the JSON object represented here has a proto equivalent, the proto
   * name will be indicated in the `@type` property.
   */
  thirdPartyPrincipal:
    | { [key: string]: any }
    | undefined;
  /**
   * The name of the service account key used to create or exchange
   * credentials for authenticating the service account making the request.
   * This is a scheme-less URI full resource name. For example:
   *
   * "//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}"
   */
  serviceAccountKeyName: string;
  /**
   * Identity delegation history of an authenticated service account that makes
   * the request. It contains information on the real authorities that try to
   * access GCP resources by delegating on a service account. When multiple
   * authorities present, they are guaranteed to be sorted based on the original
   * ordering of the identity delegation events.
   */
  serviceAccountDelegationInfo: ServiceAccountDelegationInfo[];
  /**
   * String representation of identity of requesting party.
   * Populated for both first and third party identities.
   */
  principalSubject: string;
}

/** Authorization information for the operation. */
export interface AuthorizationInfo {
  /**
   * The resource being accessed, as a REST-style or cloud resource string.
   * For example:
   *
   *     bigquery.googleapis.com/projects/PROJECTID/datasets/DATASETID
   * or
   *     projects/PROJECTID/datasets/DATASETID
   */
  resource: string;
  /** The required IAM permission. */
  permission: string;
  /**
   * Whether or not authorization for `resource` and `permission`
   * was granted.
   */
  granted: boolean;
  /**
   * Resource attributes used in IAM condition evaluation. This field contains
   * resource attributes like resource type and resource name.
   *
   * To get the whole view of the attributes used in IAM
   * condition evaluation, the user must also look into
   * `AuditLog.request_metadata.request_attributes`.
   */
  resourceAttributes: AttributeContext_Resource | undefined;
}

/** Metadata about the request. */
export interface RequestMetadata {
  /**
   * The IP address of the caller.
   * For a caller from the internet, this will be the public IPv4 or IPv6
   * address. For calls made from inside Google's internal production network
   * from one GCP service to another, `caller_ip` will be redacted to "private".
   * For a caller from a Compute Engine VM with a external IP address,
   * `caller_ip` will be the VM's external IP address. For a caller from a
   * Compute Engine VM without a external IP address, if the VM is in the same
   * organization (or project) as the accessed resource, `caller_ip` will be the
   * VM's internal IPv4 address, otherwise `caller_ip` will be redacted to
   * "gce-internal-ip". See https://cloud.google.com/compute/docs/vpc/ for more
   * information.
   */
  callerIp: string;
  /**
   * The user agent of the caller.
   * This information is not authenticated and should be treated accordingly.
   * For example:
   *
   * +   `google-api-python-client/1.4.0`:
   *     The request was made by the Google API client for Python.
   * +   `Cloud SDK Command Line Tool apitools-client/1.0 gcloud/0.9.62`:
   *     The request was made by the Google Cloud SDK CLI (gcloud).
   * +   `AppEngine-Google; (+http://code.google.com/appengine; appid:
   * s~my-project`:
   *     The request was made from the `my-project` App Engine app.
   */
  callerSuppliedUserAgent: string;
  /**
   * The network of the caller.
   * Set only if the network host project is part of the same GCP organization
   * (or project) as the accessed resource.
   * See https://cloud.google.com/compute/docs/vpc/ for more information.
   * This is a scheme-less URI full resource name. For example:
   *
   *     "//compute.googleapis.com/projects/PROJECT_ID/global/networks/NETWORK_ID"
   */
  callerNetwork: string;
  /**
   * Request attributes used in IAM condition evaluation. This field contains
   * request attributes like request time and access levels associated with
   * the request.
   *
   * To get the whole view of the attributes used in IAM
   * condition evaluation, the user must also look into
   * `AuditLog.authentication_info.resource_attributes`.
   */
  requestAttributes:
    | AttributeContext_Request
    | undefined;
  /**
   * The destination of a network activity, such as accepting a TCP connection.
   * In a multi hop network activity, the destination represents the receiver of
   * the last hop. Only two fields are used in this message, Peer.port and
   * Peer.ip. These fields are optionally populated by those services utilizing
   * the IAM condition feature.
   */
  destinationAttributes: AttributeContext_Peer | undefined;
}

/** Location information about a resource. */
export interface ResourceLocation {
  /**
   * The locations of a resource after the execution of the operation.
   * Requests to create or delete a location based resource must populate
   * the 'current_locations' field and not the 'original_locations' field.
   * For example:
   *
   *     "europe-west1-a"
   *     "us-east1"
   *     "nam3"
   */
  currentLocations: string[];
  /**
   * The locations of a resource prior to the execution of the operation.
   * Requests that mutate the resource's location must populate both the
   * 'original_locations' as well as the 'current_locations' fields.
   * For example:
   *
   *     "europe-west1-a"
   *     "us-east1"
   *     "nam3"
   */
  originalLocations: string[];
}

/** Identity delegation history of an authenticated service account. */
export interface ServiceAccountDelegationInfo {
  /**
   * A string representing the principal_subject associated with the identity.
   * For most identities, the format will be
   * `principal://iam.googleapis.com/{identity pool name}/subject/{subject)`
   * except for some GKE identities (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD)
   * that are still in the legacy format `serviceAccount:{identity pool
   * name}[{subject}]`
   */
  principalSubject: string;
  /** First party (Google) identity as the real authority. */
  firstPartyPrincipal?:
    | ServiceAccountDelegationInfo_FirstPartyPrincipal
    | undefined;
  /** Third party identity as the real authority. */
  thirdPartyPrincipal?: ServiceAccountDelegationInfo_ThirdPartyPrincipal | undefined;
}

/** First party identity principal. */
export interface ServiceAccountDelegationInfo_FirstPartyPrincipal {
  /** The email address of a Google account. */
  principalEmail: string;
  /** Metadata about the service that uses the service account. */
  serviceMetadata: { [key: string]: any } | undefined;
}

/** Third party identity principal. */
export interface ServiceAccountDelegationInfo_ThirdPartyPrincipal {
  /** Metadata about third party identity. */
  thirdPartyClaims: { [key: string]: any } | undefined;
}

/** Information related to policy violations for this request. */
export interface PolicyViolationInfo {
  /** Indicates the orgpolicy violations for this resource. */
  orgPolicyViolationInfo: OrgPolicyViolationInfo | undefined;
}

/** Represents OrgPolicy Violation information. */
export interface OrgPolicyViolationInfo {
  /**
   * Optional. Resource payload that is currently in scope and is subjected to orgpolicy
   * conditions. This payload may be the subset of the actual Resource that may
   * come in the request. This payload should not contain any core content.
   */
  payload:
    | { [key: string]: any }
    | undefined;
  /**
   * Optional. Resource type that the orgpolicy is checked against.
   * Example: compute.googleapis.com/Instance, store.googleapis.com/bucket
   */
  resourceType: string;
  /**
   * Optional. Tags referenced on the resource at the time of evaluation. These also
   * include the federated tags, if they are supplied in the CheckOrgPolicy
   * or CheckCustomConstraints Requests.
   *
   * Optional field as of now. These tags are the Cloud tags that are
   * available on the resource during the policy evaluation and will
   * be available as part of the OrgPolicy check response for logging purposes.
   */
  resourceTags: { [key: string]: string };
  /** Optional. Policy violations */
  violationInfo: ViolationInfo[];
}

export interface OrgPolicyViolationInfo_ResourceTagsEntry {
  key: string;
  value: string;
}

/** Provides information about the Policy violation info for this request. */
export interface ViolationInfo {
  /** Optional. Constraint name */
  constraint: string;
  /** Optional. Error message that policy is indicating. */
  errorMessage: string;
  /**
   * Optional. Value that is being checked for the policy.
   * This could be in encrypted form (if pii sensitive).
   * This field will only be emitted in LIST_POLICY types
   */
  checkedValue: string;
  /** Optional. Indicates the type of the policy. */
  policyType: ViolationInfo_PolicyType;
}

/** Policy Type enum */
export enum ViolationInfo_PolicyType {
  /** POLICY_TYPE_UNSPECIFIED - Default value. This value should not be used. */
  POLICY_TYPE_UNSPECIFIED = 0,
  /** BOOLEAN_CONSTRAINT - Indicates boolean policy constraint */
  BOOLEAN_CONSTRAINT = 1,
  /** LIST_CONSTRAINT - Indicates list policy constraint */
  LIST_CONSTRAINT = 2,
  /** CUSTOM_CONSTRAINT - Indicates custom policy constraint */
  CUSTOM_CONSTRAINT = 3,
  UNRECOGNIZED = -1,
}

export function violationInfo_PolicyTypeFromJSON(object: any): ViolationInfo_PolicyType {
  switch (object) {
    case 0:
    case "POLICY_TYPE_UNSPECIFIED":
      return ViolationInfo_PolicyType.POLICY_TYPE_UNSPECIFIED;
    case 1:
    case "BOOLEAN_CONSTRAINT":
      return ViolationInfo_PolicyType.BOOLEAN_CONSTRAINT;
    case 2:
    case "LIST_CONSTRAINT":
      return ViolationInfo_PolicyType.LIST_CONSTRAINT;
    case 3:
    case "CUSTOM_CONSTRAINT":
      return ViolationInfo_PolicyType.CUSTOM_CONSTRAINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ViolationInfo_PolicyType.UNRECOGNIZED;
  }
}

export function violationInfo_PolicyTypeToJSON(object: ViolationInfo_PolicyType): string {
  switch (object) {
    case ViolationInfo_PolicyType.POLICY_TYPE_UNSPECIFIED:
      return "POLICY_TYPE_UNSPECIFIED";
    case ViolationInfo_PolicyType.BOOLEAN_CONSTRAINT:
      return "BOOLEAN_CONSTRAINT";
    case ViolationInfo_PolicyType.LIST_CONSTRAINT:
      return "LIST_CONSTRAINT";
    case ViolationInfo_PolicyType.CUSTOM_CONSTRAINT:
      return "CUSTOM_CONSTRAINT";
    case ViolationInfo_PolicyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAuditLog(): AuditLog {
  return {
    serviceName: "",
    methodName: "",
    resourceName: "",
    resourceLocation: undefined,
    resourceOriginalState: undefined,
    numResponseItems: Long.ZERO,
    status: undefined,
    authenticationInfo: undefined,
    authorizationInfo: [],
    policyViolationInfo: undefined,
    requestMetadata: undefined,
    request: undefined,
    response: undefined,
    metadata: undefined,
    serviceData: undefined,
  };
}

export const AuditLog: MessageFns<AuditLog> = {
  encode(message: AuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(58).string(message.serviceName);
    }
    if (message.methodName !== "") {
      writer.uint32(66).string(message.methodName);
    }
    if (message.resourceName !== "") {
      writer.uint32(90).string(message.resourceName);
    }
    if (message.resourceLocation !== undefined) {
      ResourceLocation.encode(message.resourceLocation, writer.uint32(162).fork()).join();
    }
    if (message.resourceOriginalState !== undefined) {
      Struct.encode(Struct.wrap(message.resourceOriginalState), writer.uint32(154).fork()).join();
    }
    if (!message.numResponseItems.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.numResponseItems.toString());
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    if (message.authenticationInfo !== undefined) {
      AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.authorizationInfo) {
      AuthorizationInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.policyViolationInfo !== undefined) {
      PolicyViolationInfo.encode(message.policyViolationInfo, writer.uint32(202).fork()).join();
    }
    if (message.requestMetadata !== undefined) {
      RequestMetadata.encode(message.requestMetadata, writer.uint32(34).fork()).join();
    }
    if (message.request !== undefined) {
      Struct.encode(Struct.wrap(message.request), writer.uint32(130).fork()).join();
    }
    if (message.response !== undefined) {
      Struct.encode(Struct.wrap(message.response), writer.uint32(138).fork()).join();
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(146).fork()).join();
    }
    if (message.serviceData !== undefined) {
      Any.encode(message.serviceData, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.resourceLocation = ResourceLocation.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.resourceOriginalState = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.numResponseItems = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authenticationInfo = AuthenticationInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.authorizationInfo.push(AuthorizationInfo.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.policyViolationInfo = PolicyViolationInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestMetadata = RequestMetadata.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.request = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.response = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.serviceData = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuditLog {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      resourceLocation: isSet(object.resourceLocation) ? ResourceLocation.fromJSON(object.resourceLocation) : undefined,
      resourceOriginalState: isObject(object.resourceOriginalState) ? object.resourceOriginalState : undefined,
      numResponseItems: isSet(object.numResponseItems) ? Long.fromValue(object.numResponseItems) : Long.ZERO,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      authenticationInfo: isSet(object.authenticationInfo)
        ? AuthenticationInfo.fromJSON(object.authenticationInfo)
        : undefined,
      authorizationInfo: globalThis.Array.isArray(object?.authorizationInfo)
        ? object.authorizationInfo.map((e: any) => AuthorizationInfo.fromJSON(e))
        : [],
      policyViolationInfo: isSet(object.policyViolationInfo)
        ? PolicyViolationInfo.fromJSON(object.policyViolationInfo)
        : undefined,
      requestMetadata: isSet(object.requestMetadata) ? RequestMetadata.fromJSON(object.requestMetadata) : undefined,
      request: isObject(object.request) ? object.request : undefined,
      response: isObject(object.response) ? object.response : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      serviceData: isSet(object.serviceData) ? Any.fromJSON(object.serviceData) : undefined,
    };
  },

  toJSON(message: AuditLog): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.resourceLocation !== undefined) {
      obj.resourceLocation = ResourceLocation.toJSON(message.resourceLocation);
    }
    if (message.resourceOriginalState !== undefined) {
      obj.resourceOriginalState = message.resourceOriginalState;
    }
    if (!message.numResponseItems.equals(Long.ZERO)) {
      obj.numResponseItems = (message.numResponseItems || Long.ZERO).toString();
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.authenticationInfo !== undefined) {
      obj.authenticationInfo = AuthenticationInfo.toJSON(message.authenticationInfo);
    }
    if (message.authorizationInfo?.length) {
      obj.authorizationInfo = message.authorizationInfo.map((e) => AuthorizationInfo.toJSON(e));
    }
    if (message.policyViolationInfo !== undefined) {
      obj.policyViolationInfo = PolicyViolationInfo.toJSON(message.policyViolationInfo);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = RequestMetadata.toJSON(message.requestMetadata);
    }
    if (message.request !== undefined) {
      obj.request = message.request;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.serviceData !== undefined) {
      obj.serviceData = Any.toJSON(message.serviceData);
    }
    return obj;
  },

  create(base?: DeepPartial<AuditLog>): AuditLog {
    return AuditLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuditLog>): AuditLog {
    const message = createBaseAuditLog();
    message.serviceName = object.serviceName ?? "";
    message.methodName = object.methodName ?? "";
    message.resourceName = object.resourceName ?? "";
    message.resourceLocation = (object.resourceLocation !== undefined && object.resourceLocation !== null)
      ? ResourceLocation.fromPartial(object.resourceLocation)
      : undefined;
    message.resourceOriginalState = object.resourceOriginalState ?? undefined;
    message.numResponseItems = (object.numResponseItems !== undefined && object.numResponseItems !== null)
      ? Long.fromValue(object.numResponseItems)
      : Long.ZERO;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.authenticationInfo = (object.authenticationInfo !== undefined && object.authenticationInfo !== null)
      ? AuthenticationInfo.fromPartial(object.authenticationInfo)
      : undefined;
    message.authorizationInfo = object.authorizationInfo?.map((e) => AuthorizationInfo.fromPartial(e)) || [];
    message.policyViolationInfo = (object.policyViolationInfo !== undefined && object.policyViolationInfo !== null)
      ? PolicyViolationInfo.fromPartial(object.policyViolationInfo)
      : undefined;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? RequestMetadata.fromPartial(object.requestMetadata)
      : undefined;
    message.request = object.request ?? undefined;
    message.response = object.response ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.serviceData = (object.serviceData !== undefined && object.serviceData !== null)
      ? Any.fromPartial(object.serviceData)
      : undefined;
    return message;
  },
};

function createBaseAuthenticationInfo(): AuthenticationInfo {
  return {
    principalEmail: "",
    authoritySelector: "",
    thirdPartyPrincipal: undefined,
    serviceAccountKeyName: "",
    serviceAccountDelegationInfo: [],
    principalSubject: "",
  };
}

export const AuthenticationInfo: MessageFns<AuthenticationInfo> = {
  encode(message: AuthenticationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.authoritySelector !== "") {
      writer.uint32(18).string(message.authoritySelector);
    }
    if (message.thirdPartyPrincipal !== undefined) {
      Struct.encode(Struct.wrap(message.thirdPartyPrincipal), writer.uint32(34).fork()).join();
    }
    if (message.serviceAccountKeyName !== "") {
      writer.uint32(42).string(message.serviceAccountKeyName);
    }
    for (const v of message.serviceAccountDelegationInfo) {
      ServiceAccountDelegationInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.principalSubject !== "") {
      writer.uint32(66).string(message.principalSubject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.authoritySelector = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.thirdPartyPrincipal = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceAccountKeyName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.serviceAccountDelegationInfo.push(ServiceAccountDelegationInfo.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.principalSubject = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationInfo {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      authoritySelector: isSet(object.authoritySelector) ? globalThis.String(object.authoritySelector) : "",
      thirdPartyPrincipal: isObject(object.thirdPartyPrincipal) ? object.thirdPartyPrincipal : undefined,
      serviceAccountKeyName: isSet(object.serviceAccountKeyName) ? globalThis.String(object.serviceAccountKeyName) : "",
      serviceAccountDelegationInfo: globalThis.Array.isArray(object?.serviceAccountDelegationInfo)
        ? object.serviceAccountDelegationInfo.map((e: any) => ServiceAccountDelegationInfo.fromJSON(e))
        : [],
      principalSubject: isSet(object.principalSubject) ? globalThis.String(object.principalSubject) : "",
    };
  },

  toJSON(message: AuthenticationInfo): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.authoritySelector !== "") {
      obj.authoritySelector = message.authoritySelector;
    }
    if (message.thirdPartyPrincipal !== undefined) {
      obj.thirdPartyPrincipal = message.thirdPartyPrincipal;
    }
    if (message.serviceAccountKeyName !== "") {
      obj.serviceAccountKeyName = message.serviceAccountKeyName;
    }
    if (message.serviceAccountDelegationInfo?.length) {
      obj.serviceAccountDelegationInfo = message.serviceAccountDelegationInfo.map((e) =>
        ServiceAccountDelegationInfo.toJSON(e)
      );
    }
    if (message.principalSubject !== "") {
      obj.principalSubject = message.principalSubject;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthenticationInfo>): AuthenticationInfo {
    return AuthenticationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticationInfo>): AuthenticationInfo {
    const message = createBaseAuthenticationInfo();
    message.principalEmail = object.principalEmail ?? "";
    message.authoritySelector = object.authoritySelector ?? "";
    message.thirdPartyPrincipal = object.thirdPartyPrincipal ?? undefined;
    message.serviceAccountKeyName = object.serviceAccountKeyName ?? "";
    message.serviceAccountDelegationInfo =
      object.serviceAccountDelegationInfo?.map((e) => ServiceAccountDelegationInfo.fromPartial(e)) || [];
    message.principalSubject = object.principalSubject ?? "";
    return message;
  },
};

function createBaseAuthorizationInfo(): AuthorizationInfo {
  return { resource: "", permission: "", granted: false, resourceAttributes: undefined };
}

export const AuthorizationInfo: MessageFns<AuthorizationInfo> = {
  encode(message: AuthorizationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.permission !== "") {
      writer.uint32(18).string(message.permission);
    }
    if (message.granted !== false) {
      writer.uint32(24).bool(message.granted);
    }
    if (message.resourceAttributes !== undefined) {
      AttributeContext_Resource.encode(message.resourceAttributes, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.granted = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resourceAttributes = AttributeContext_Resource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationInfo {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      permission: isSet(object.permission) ? globalThis.String(object.permission) : "",
      granted: isSet(object.granted) ? globalThis.Boolean(object.granted) : false,
      resourceAttributes: isSet(object.resourceAttributes)
        ? AttributeContext_Resource.fromJSON(object.resourceAttributes)
        : undefined,
    };
  },

  toJSON(message: AuthorizationInfo): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.permission !== "") {
      obj.permission = message.permission;
    }
    if (message.granted !== false) {
      obj.granted = message.granted;
    }
    if (message.resourceAttributes !== undefined) {
      obj.resourceAttributes = AttributeContext_Resource.toJSON(message.resourceAttributes);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthorizationInfo>): AuthorizationInfo {
    return AuthorizationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthorizationInfo>): AuthorizationInfo {
    const message = createBaseAuthorizationInfo();
    message.resource = object.resource ?? "";
    message.permission = object.permission ?? "";
    message.granted = object.granted ?? false;
    message.resourceAttributes = (object.resourceAttributes !== undefined && object.resourceAttributes !== null)
      ? AttributeContext_Resource.fromPartial(object.resourceAttributes)
      : undefined;
    return message;
  },
};

function createBaseRequestMetadata(): RequestMetadata {
  return {
    callerIp: "",
    callerSuppliedUserAgent: "",
    callerNetwork: "",
    requestAttributes: undefined,
    destinationAttributes: undefined,
  };
}

export const RequestMetadata: MessageFns<RequestMetadata> = {
  encode(message: RequestMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callerIp !== "") {
      writer.uint32(10).string(message.callerIp);
    }
    if (message.callerSuppliedUserAgent !== "") {
      writer.uint32(18).string(message.callerSuppliedUserAgent);
    }
    if (message.callerNetwork !== "") {
      writer.uint32(26).string(message.callerNetwork);
    }
    if (message.requestAttributes !== undefined) {
      AttributeContext_Request.encode(message.requestAttributes, writer.uint32(58).fork()).join();
    }
    if (message.destinationAttributes !== undefined) {
      AttributeContext_Peer.encode(message.destinationAttributes, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callerIp = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callerSuppliedUserAgent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.callerNetwork = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.requestAttributes = AttributeContext_Request.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.destinationAttributes = AttributeContext_Peer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return {
      callerIp: isSet(object.callerIp) ? globalThis.String(object.callerIp) : "",
      callerSuppliedUserAgent: isSet(object.callerSuppliedUserAgent)
        ? globalThis.String(object.callerSuppliedUserAgent)
        : "",
      callerNetwork: isSet(object.callerNetwork) ? globalThis.String(object.callerNetwork) : "",
      requestAttributes: isSet(object.requestAttributes)
        ? AttributeContext_Request.fromJSON(object.requestAttributes)
        : undefined,
      destinationAttributes: isSet(object.destinationAttributes)
        ? AttributeContext_Peer.fromJSON(object.destinationAttributes)
        : undefined,
    };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.callerIp !== "") {
      obj.callerIp = message.callerIp;
    }
    if (message.callerSuppliedUserAgent !== "") {
      obj.callerSuppliedUserAgent = message.callerSuppliedUserAgent;
    }
    if (message.callerNetwork !== "") {
      obj.callerNetwork = message.callerNetwork;
    }
    if (message.requestAttributes !== undefined) {
      obj.requestAttributes = AttributeContext_Request.toJSON(message.requestAttributes);
    }
    if (message.destinationAttributes !== undefined) {
      obj.destinationAttributes = AttributeContext_Peer.toJSON(message.destinationAttributes);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata>): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata>): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.callerIp = object.callerIp ?? "";
    message.callerSuppliedUserAgent = object.callerSuppliedUserAgent ?? "";
    message.callerNetwork = object.callerNetwork ?? "";
    message.requestAttributes = (object.requestAttributes !== undefined && object.requestAttributes !== null)
      ? AttributeContext_Request.fromPartial(object.requestAttributes)
      : undefined;
    message.destinationAttributes =
      (object.destinationAttributes !== undefined && object.destinationAttributes !== null)
        ? AttributeContext_Peer.fromPartial(object.destinationAttributes)
        : undefined;
    return message;
  },
};

function createBaseResourceLocation(): ResourceLocation {
  return { currentLocations: [], originalLocations: [] };
}

export const ResourceLocation: MessageFns<ResourceLocation> = {
  encode(message: ResourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.currentLocations) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.originalLocations) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentLocations.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLocation {
    return {
      currentLocations: globalThis.Array.isArray(object?.currentLocations)
        ? object.currentLocations.map((e: any) => globalThis.String(e))
        : [],
      originalLocations: globalThis.Array.isArray(object?.originalLocations)
        ? object.originalLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ResourceLocation): unknown {
    const obj: any = {};
    if (message.currentLocations?.length) {
      obj.currentLocations = message.currentLocations;
    }
    if (message.originalLocations?.length) {
      obj.originalLocations = message.originalLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceLocation>): ResourceLocation {
    return ResourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceLocation>): ResourceLocation {
    const message = createBaseResourceLocation();
    message.currentLocations = object.currentLocations?.map((e) => e) || [];
    message.originalLocations = object.originalLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseServiceAccountDelegationInfo(): ServiceAccountDelegationInfo {
  return { principalSubject: "", firstPartyPrincipal: undefined, thirdPartyPrincipal: undefined };
}

export const ServiceAccountDelegationInfo: MessageFns<ServiceAccountDelegationInfo> = {
  encode(message: ServiceAccountDelegationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalSubject !== "") {
      writer.uint32(26).string(message.principalSubject);
    }
    if (message.firstPartyPrincipal !== undefined) {
      ServiceAccountDelegationInfo_FirstPartyPrincipal.encode(message.firstPartyPrincipal, writer.uint32(10).fork())
        .join();
    }
    if (message.thirdPartyPrincipal !== undefined) {
      ServiceAccountDelegationInfo_ThirdPartyPrincipal.encode(message.thirdPartyPrincipal, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.principalSubject = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firstPartyPrincipal = ServiceAccountDelegationInfo_FirstPartyPrincipal.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.thirdPartyPrincipal = ServiceAccountDelegationInfo_ThirdPartyPrincipal.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo {
    return {
      principalSubject: isSet(object.principalSubject) ? globalThis.String(object.principalSubject) : "",
      firstPartyPrincipal: isSet(object.firstPartyPrincipal)
        ? ServiceAccountDelegationInfo_FirstPartyPrincipal.fromJSON(object.firstPartyPrincipal)
        : undefined,
      thirdPartyPrincipal: isSet(object.thirdPartyPrincipal)
        ? ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromJSON(object.thirdPartyPrincipal)
        : undefined,
    };
  },

  toJSON(message: ServiceAccountDelegationInfo): unknown {
    const obj: any = {};
    if (message.principalSubject !== "") {
      obj.principalSubject = message.principalSubject;
    }
    if (message.firstPartyPrincipal !== undefined) {
      obj.firstPartyPrincipal = ServiceAccountDelegationInfo_FirstPartyPrincipal.toJSON(message.firstPartyPrincipal);
    }
    if (message.thirdPartyPrincipal !== undefined) {
      obj.thirdPartyPrincipal = ServiceAccountDelegationInfo_ThirdPartyPrincipal.toJSON(message.thirdPartyPrincipal);
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccountDelegationInfo>): ServiceAccountDelegationInfo {
    return ServiceAccountDelegationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccountDelegationInfo>): ServiceAccountDelegationInfo {
    const message = createBaseServiceAccountDelegationInfo();
    message.principalSubject = object.principalSubject ?? "";
    message.firstPartyPrincipal = (object.firstPartyPrincipal !== undefined && object.firstPartyPrincipal !== null)
      ? ServiceAccountDelegationInfo_FirstPartyPrincipal.fromPartial(object.firstPartyPrincipal)
      : undefined;
    message.thirdPartyPrincipal = (object.thirdPartyPrincipal !== undefined && object.thirdPartyPrincipal !== null)
      ? ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromPartial(object.thirdPartyPrincipal)
      : undefined;
    return message;
  },
};

function createBaseServiceAccountDelegationInfo_FirstPartyPrincipal(): ServiceAccountDelegationInfo_FirstPartyPrincipal {
  return { principalEmail: "", serviceMetadata: undefined };
}

export const ServiceAccountDelegationInfo_FirstPartyPrincipal: MessageFns<
  ServiceAccountDelegationInfo_FirstPartyPrincipal
> = {
  encode(
    message: ServiceAccountDelegationInfo_FirstPartyPrincipal,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.serviceMetadata !== undefined) {
      Struct.encode(Struct.wrap(message.serviceMetadata), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo_FirstPartyPrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceMetadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      serviceMetadata: isObject(object.serviceMetadata) ? object.serviceMetadata : undefined,
    };
  },

  toJSON(message: ServiceAccountDelegationInfo_FirstPartyPrincipal): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.serviceMetadata !== undefined) {
      obj.serviceMetadata = message.serviceMetadata;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ServiceAccountDelegationInfo_FirstPartyPrincipal>,
  ): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    return ServiceAccountDelegationInfo_FirstPartyPrincipal.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ServiceAccountDelegationInfo_FirstPartyPrincipal>,
  ): ServiceAccountDelegationInfo_FirstPartyPrincipal {
    const message = createBaseServiceAccountDelegationInfo_FirstPartyPrincipal();
    message.principalEmail = object.principalEmail ?? "";
    message.serviceMetadata = object.serviceMetadata ?? undefined;
    return message;
  },
};

function createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal(): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
  return { thirdPartyClaims: undefined };
}

export const ServiceAccountDelegationInfo_ThirdPartyPrincipal: MessageFns<
  ServiceAccountDelegationInfo_ThirdPartyPrincipal
> = {
  encode(
    message: ServiceAccountDelegationInfo_ThirdPartyPrincipal,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.thirdPartyClaims !== undefined) {
      Struct.encode(Struct.wrap(message.thirdPartyClaims), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thirdPartyClaims = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    return { thirdPartyClaims: isObject(object.thirdPartyClaims) ? object.thirdPartyClaims : undefined };
  },

  toJSON(message: ServiceAccountDelegationInfo_ThirdPartyPrincipal): unknown {
    const obj: any = {};
    if (message.thirdPartyClaims !== undefined) {
      obj.thirdPartyClaims = message.thirdPartyClaims;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ServiceAccountDelegationInfo_ThirdPartyPrincipal>,
  ): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    return ServiceAccountDelegationInfo_ThirdPartyPrincipal.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ServiceAccountDelegationInfo_ThirdPartyPrincipal>,
  ): ServiceAccountDelegationInfo_ThirdPartyPrincipal {
    const message = createBaseServiceAccountDelegationInfo_ThirdPartyPrincipal();
    message.thirdPartyClaims = object.thirdPartyClaims ?? undefined;
    return message;
  },
};

function createBasePolicyViolationInfo(): PolicyViolationInfo {
  return { orgPolicyViolationInfo: undefined };
}

export const PolicyViolationInfo: MessageFns<PolicyViolationInfo> = {
  encode(message: PolicyViolationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orgPolicyViolationInfo !== undefined) {
      OrgPolicyViolationInfo.encode(message.orgPolicyViolationInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyViolationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyViolationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orgPolicyViolationInfo = OrgPolicyViolationInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyViolationInfo {
    return {
      orgPolicyViolationInfo: isSet(object.orgPolicyViolationInfo)
        ? OrgPolicyViolationInfo.fromJSON(object.orgPolicyViolationInfo)
        : undefined,
    };
  },

  toJSON(message: PolicyViolationInfo): unknown {
    const obj: any = {};
    if (message.orgPolicyViolationInfo !== undefined) {
      obj.orgPolicyViolationInfo = OrgPolicyViolationInfo.toJSON(message.orgPolicyViolationInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyViolationInfo>): PolicyViolationInfo {
    return PolicyViolationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyViolationInfo>): PolicyViolationInfo {
    const message = createBasePolicyViolationInfo();
    message.orgPolicyViolationInfo =
      (object.orgPolicyViolationInfo !== undefined && object.orgPolicyViolationInfo !== null)
        ? OrgPolicyViolationInfo.fromPartial(object.orgPolicyViolationInfo)
        : undefined;
    return message;
  },
};

function createBaseOrgPolicyViolationInfo(): OrgPolicyViolationInfo {
  return { payload: undefined, resourceType: "", resourceTags: {}, violationInfo: [] };
}

export const OrgPolicyViolationInfo: MessageFns<OrgPolicyViolationInfo> = {
  encode(message: OrgPolicyViolationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload !== undefined) {
      Struct.encode(Struct.wrap(message.payload), writer.uint32(10).fork()).join();
    }
    if (message.resourceType !== "") {
      writer.uint32(18).string(message.resourceType);
    }
    Object.entries(message.resourceTags).forEach(([key, value]) => {
      OrgPolicyViolationInfo_ResourceTagsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    for (const v of message.violationInfo) {
      ViolationInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgPolicyViolationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgPolicyViolationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = OrgPolicyViolationInfo_ResourceTagsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.resourceTags[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.violationInfo.push(ViolationInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgPolicyViolationInfo {
    return {
      payload: isObject(object.payload) ? object.payload : undefined,
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      resourceTags: isObject(object.resourceTags)
        ? Object.entries(object.resourceTags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      violationInfo: globalThis.Array.isArray(object?.violationInfo)
        ? object.violationInfo.map((e: any) => ViolationInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrgPolicyViolationInfo): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = message.payload;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.resourceTags) {
      const entries = Object.entries(message.resourceTags);
      if (entries.length > 0) {
        obj.resourceTags = {};
        entries.forEach(([k, v]) => {
          obj.resourceTags[k] = v;
        });
      }
    }
    if (message.violationInfo?.length) {
      obj.violationInfo = message.violationInfo.map((e) => ViolationInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OrgPolicyViolationInfo>): OrgPolicyViolationInfo {
    return OrgPolicyViolationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrgPolicyViolationInfo>): OrgPolicyViolationInfo {
    const message = createBaseOrgPolicyViolationInfo();
    message.payload = object.payload ?? undefined;
    message.resourceType = object.resourceType ?? "";
    message.resourceTags = Object.entries(object.resourceTags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.violationInfo = object.violationInfo?.map((e) => ViolationInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrgPolicyViolationInfo_ResourceTagsEntry(): OrgPolicyViolationInfo_ResourceTagsEntry {
  return { key: "", value: "" };
}

export const OrgPolicyViolationInfo_ResourceTagsEntry: MessageFns<OrgPolicyViolationInfo_ResourceTagsEntry> = {
  encode(message: OrgPolicyViolationInfo_ResourceTagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrgPolicyViolationInfo_ResourceTagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrgPolicyViolationInfo_ResourceTagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrgPolicyViolationInfo_ResourceTagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OrgPolicyViolationInfo_ResourceTagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OrgPolicyViolationInfo_ResourceTagsEntry>): OrgPolicyViolationInfo_ResourceTagsEntry {
    return OrgPolicyViolationInfo_ResourceTagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrgPolicyViolationInfo_ResourceTagsEntry>): OrgPolicyViolationInfo_ResourceTagsEntry {
    const message = createBaseOrgPolicyViolationInfo_ResourceTagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseViolationInfo(): ViolationInfo {
  return { constraint: "", errorMessage: "", checkedValue: "", policyType: 0 };
}

export const ViolationInfo: MessageFns<ViolationInfo> = {
  encode(message: ViolationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constraint !== "") {
      writer.uint32(10).string(message.constraint);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.checkedValue !== "") {
      writer.uint32(26).string(message.checkedValue);
    }
    if (message.policyType !== 0) {
      writer.uint32(32).int32(message.policyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViolationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.constraint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.checkedValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.policyType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViolationInfo {
    return {
      constraint: isSet(object.constraint) ? globalThis.String(object.constraint) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      checkedValue: isSet(object.checkedValue) ? globalThis.String(object.checkedValue) : "",
      policyType: isSet(object.policyType) ? violationInfo_PolicyTypeFromJSON(object.policyType) : 0,
    };
  },

  toJSON(message: ViolationInfo): unknown {
    const obj: any = {};
    if (message.constraint !== "") {
      obj.constraint = message.constraint;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.checkedValue !== "") {
      obj.checkedValue = message.checkedValue;
    }
    if (message.policyType !== 0) {
      obj.policyType = violationInfo_PolicyTypeToJSON(message.policyType);
    }
    return obj;
  },

  create(base?: DeepPartial<ViolationInfo>): ViolationInfo {
    return ViolationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViolationInfo>): ViolationInfo {
    const message = createBaseViolationInfo();
    message.constraint = object.constraint ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.checkedValue = object.checkedValue ?? "";
    message.policyType = object.policyType ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
