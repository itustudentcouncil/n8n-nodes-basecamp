// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/commerce/consumer/procurement/v1alpha1/order.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.commerce.consumer.procurement.v1alpha1";

/** Type of a line item change. */
export enum LineItemChangeType {
  /** LINE_ITEM_CHANGE_TYPE_UNSPECIFIED - Sentinel value. Do not use. */
  LINE_ITEM_CHANGE_TYPE_UNSPECIFIED = 0,
  /** LINE_ITEM_CHANGE_TYPE_CREATE - The change is to create a new line item. */
  LINE_ITEM_CHANGE_TYPE_CREATE = 1,
  /** LINE_ITEM_CHANGE_TYPE_UPDATE - The change is to update an existing line item. */
  LINE_ITEM_CHANGE_TYPE_UPDATE = 2,
  /** LINE_ITEM_CHANGE_TYPE_CANCEL - The change is to cancel an existing line item. */
  LINE_ITEM_CHANGE_TYPE_CANCEL = 3,
  /** LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION - The change is to revert a cancellation. */
  LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION = 4,
  UNRECOGNIZED = -1,
}

export function lineItemChangeTypeFromJSON(object: any): LineItemChangeType {
  switch (object) {
    case 0:
    case "LINE_ITEM_CHANGE_TYPE_UNSPECIFIED":
      return LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "LINE_ITEM_CHANGE_TYPE_CREATE":
      return LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CREATE;
    case 2:
    case "LINE_ITEM_CHANGE_TYPE_UPDATE":
      return LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE;
    case 3:
    case "LINE_ITEM_CHANGE_TYPE_CANCEL":
      return LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CANCEL;
    case 4:
    case "LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION":
      return LineItemChangeType.LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LineItemChangeType.UNRECOGNIZED;
  }
}

export function lineItemChangeTypeToJSON(object: LineItemChangeType): string {
  switch (object) {
    case LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UNSPECIFIED:
      return "LINE_ITEM_CHANGE_TYPE_UNSPECIFIED";
    case LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CREATE:
      return "LINE_ITEM_CHANGE_TYPE_CREATE";
    case LineItemChangeType.LINE_ITEM_CHANGE_TYPE_UPDATE:
      return "LINE_ITEM_CHANGE_TYPE_UPDATE";
    case LineItemChangeType.LINE_ITEM_CHANGE_TYPE_CANCEL:
      return "LINE_ITEM_CHANGE_TYPE_CANCEL";
    case LineItemChangeType.LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION:
      return "LINE_ITEM_CHANGE_TYPE_REVERT_CANCELLATION";
    case LineItemChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** State of a change. */
export enum LineItemChangeState {
  /** LINE_ITEM_CHANGE_STATE_UNSPECIFIED - Sentinel value. Do not use. */
  LINE_ITEM_CHANGE_STATE_UNSPECIFIED = 0,
  /**
   * LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL - Change is in this state when a change is initiated and waiting for
   * partner approval.
   */
  LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL = 1,
  /**
   * LINE_ITEM_CHANGE_STATE_APPROVED - Change is in this state after it's approved by the partner or auto-approved
   * but before it takes effect. The change can be overwritten
   * or cancelled depending on the new line item info property (pending Private
   * Offer change cannot be cancelled and can only be overwritten by another
   * Private Offer).
   */
  LINE_ITEM_CHANGE_STATE_APPROVED = 2,
  /** LINE_ITEM_CHANGE_STATE_COMPLETED - Change is in this state after it's been activated. */
  LINE_ITEM_CHANGE_STATE_COMPLETED = 3,
  /** LINE_ITEM_CHANGE_STATE_REJECTED - Change is in this state if it was rejected by the partner. */
  LINE_ITEM_CHANGE_STATE_REJECTED = 4,
  /** LINE_ITEM_CHANGE_STATE_ABANDONED - Change is in this state if it was abandoned by the user. */
  LINE_ITEM_CHANGE_STATE_ABANDONED = 5,
  /**
   * LINE_ITEM_CHANGE_STATE_ACTIVATING - Change is in this state if it's currently being provisioned downstream. The
   * change can't be overwritten or cancelled when it's in this state.
   */
  LINE_ITEM_CHANGE_STATE_ACTIVATING = 6,
  UNRECOGNIZED = -1,
}

export function lineItemChangeStateFromJSON(object: any): LineItemChangeState {
  switch (object) {
    case 0:
    case "LINE_ITEM_CHANGE_STATE_UNSPECIFIED":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_UNSPECIFIED;
    case 1:
    case "LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL;
    case 2:
    case "LINE_ITEM_CHANGE_STATE_APPROVED":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_APPROVED;
    case 3:
    case "LINE_ITEM_CHANGE_STATE_COMPLETED":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_COMPLETED;
    case 4:
    case "LINE_ITEM_CHANGE_STATE_REJECTED":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_REJECTED;
    case 5:
    case "LINE_ITEM_CHANGE_STATE_ABANDONED":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_ABANDONED;
    case 6:
    case "LINE_ITEM_CHANGE_STATE_ACTIVATING":
      return LineItemChangeState.LINE_ITEM_CHANGE_STATE_ACTIVATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LineItemChangeState.UNRECOGNIZED;
  }
}

export function lineItemChangeStateToJSON(object: LineItemChangeState): string {
  switch (object) {
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_UNSPECIFIED:
      return "LINE_ITEM_CHANGE_STATE_UNSPECIFIED";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL:
      return "LINE_ITEM_CHANGE_STATE_PENDING_APPROVAL";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_APPROVED:
      return "LINE_ITEM_CHANGE_STATE_APPROVED";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_COMPLETED:
      return "LINE_ITEM_CHANGE_STATE_COMPLETED";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_REJECTED:
      return "LINE_ITEM_CHANGE_STATE_REJECTED";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_ABANDONED:
      return "LINE_ITEM_CHANGE_STATE_ABANDONED";
    case LineItemChangeState.LINE_ITEM_CHANGE_STATE_ACTIVATING:
      return "LINE_ITEM_CHANGE_STATE_ACTIVATING";
    case LineItemChangeState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Predefined types for line item change state reason. */
export enum LineItemChangeStateReasonType {
  /**
   * LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED - Default value, indicating there's no predefined type for change state
   * reason.
   */
  LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED = 0,
  /** LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED - Change is in current state due to term expiration. */
  LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED = 1,
  /** LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED - Change is in current state due to user-initiated cancellation. */
  LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED = 2,
  /** LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED - Change is in current state due to system-initiated cancellation. */
  LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED = 3,
  UNRECOGNIZED = -1,
}

export function lineItemChangeStateReasonTypeFromJSON(object: any): LineItemChangeStateReasonType {
  switch (object) {
    case 0:
    case "LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED":
      return LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED;
    case 1:
    case "LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED":
      return LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED;
    case 2:
    case "LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED":
      return LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED;
    case 3:
    case "LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED":
      return LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LineItemChangeStateReasonType.UNRECOGNIZED;
  }
}

export function lineItemChangeStateReasonTypeToJSON(object: LineItemChangeStateReasonType): string {
  switch (object) {
    case LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED:
      return "LINE_ITEM_CHANGE_STATE_REASON_TYPE_UNSPECIFIED";
    case LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED:
      return "LINE_ITEM_CHANGE_STATE_REASON_TYPE_EXPIRED";
    case LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED:
      return "LINE_ITEM_CHANGE_STATE_REASON_TYPE_USER_CANCELLED";
    case LineItemChangeStateReasonType.LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED:
      return "LINE_ITEM_CHANGE_STATE_REASON_TYPE_SYSTEM_CANCELLED";
    case LineItemChangeStateReasonType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a purchase made by a customer on Cloud Marketplace.
 * Creating an order makes sure that both the Google backend systems
 * as well as external service provider's systems (if needed) allow use of
 * purchased products and ensures the appropriate billing events occur.
 *
 * An Order can be made against one Product with multiple add-ons (optional) or
 * one Quote which might reference multiple products.
 *
 * Customers typically choose a price plan for each Product purchased when
 * they create an order and can change their plan later, if the product allows.
 */
export interface Order {
  /**
   * Output only. The resource name of the order.
   * Has the form
   * `billingAccounts/{billing_account}/orders/{order}`.
   */
  name: string;
  /** Required. The user-specified name of the order. */
  displayName: string;
  /** Output only. The items being purchased. */
  lineItems: LineItem[];
  /** Output only. Line items that were cancelled. */
  cancelledLineItems: LineItem[];
  /** Output only. The creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** The weak etag of the order. */
  etag: string;
}

/** A single item within an order. */
export interface LineItem {
  /** Output only. Line item ID. */
  lineItemId: string;
  /**
   * Output only. Current state and information of this item. It tells what,
   * e.g. which offer, is currently effective.
   */
  lineItemInfo:
    | LineItemInfo
    | undefined;
  /**
   * Output only. A change made on the item which is pending and not yet
   * effective. Absence of this field indicates the line item is not undergoing
   * a change.
   */
  pendingChange:
    | LineItemChange
    | undefined;
  /**
   * Output only. Changes made on the item that are not pending anymore which
   * might be because they already took effect, were reverted by the customer,
   * or were rejected by the partner. No more operations are allowed on these
   * changes.
   */
  changeHistory: LineItemChange[];
}

/** A change made on a line item. */
export interface LineItemChange {
  /**
   * Output only. Change ID.
   * All changes made within one order update operation have the same change_id.
   */
  changeId: string;
  /** Required. Type of the change to make. */
  changeType: LineItemChangeType;
  /** Output only. Line item info before the change. */
  oldLineItemInfo:
    | LineItemInfo
    | undefined;
  /** Line item info after the change. */
  newLineItemInfo:
    | LineItemInfo
    | undefined;
  /** Output only. State of the change. */
  changeState: LineItemChangeState;
  /**
   * Output only. Provider-supplied message explaining the LineItemChange's
   * state. Mainly used to communicate progress and ETA for provisioning in the
   * case of `PENDING_APPROVAL`, and to explain why the change request was
   * denied or canceled in the case of `REJECTED` and `CANCELED` states.
   */
  stateReason: string;
  /**
   * Output only. Predefined enum types for why this line item change is in
   * current state. For example, a line item change's state could be
   * `LINE_ITEM_CHANGE_STATE_COMPLETED` because of end-of-term expiration,
   * immediate cancellation initiated by the user, or system-initiated
   * cancellation.
   */
  changeStateReasonType: LineItemChangeStateReasonType;
  /**
   * Output only. A time at which the change became or will become (in case of
   * pending change) effective.
   */
  changeEffectiveTime:
    | Date
    | undefined;
  /** Output only. The time when change was initiated. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time when change was updated, e.g. approved/rejected by
   * partners or cancelled by the user.
   */
  updateTime: Date | undefined;
}

/** Line item information. */
export interface LineItemInfo {
  /**
   * Optional. The name of the offer can have either of these formats:
   * 'billingAccounts/{billing_account}/offers/{offer}',
   * or 'services/{service}/standardOffers/{offer}'.
   */
  offer: string;
  /** Optional. User-provided parameters. */
  parameters: Parameter[];
  /** Output only. Information about the subscription created, if applicable. */
  subscription: Subscription | undefined;
}

/** User-provided Parameters. */
export interface Parameter {
  /** Name of the parameter. */
  name: string;
  /** Value of parameter. */
  value: Parameter_Value | undefined;
}

export interface Parameter_Value {
  /** Represents an int64 value. */
  int64Value?:
    | Long
    | undefined;
  /** Represents a string value. */
  stringValue?:
    | string
    | undefined;
  /** Represents a double value. */
  doubleValue?: number | undefined;
}

/** Subscription information. */
export interface Subscription {
  /** The timestamp when the subscription begins, if applicable. */
  startTime:
    | Date
    | undefined;
  /** The timestamp when the subscription ends, if applicable. */
  endTime:
    | Date
    | undefined;
  /**
   * Whether auto renewal is enabled by user choice on current subscription.
   * This field indicates order/subscription status after pending plan change is
   * cancelled or rejected.
   */
  autoRenewalEnabled: boolean;
}

function createBaseOrder(): Order {
  return {
    name: "",
    displayName: "",
    lineItems: [],
    cancelledLineItems: [],
    createTime: undefined,
    updateTime: undefined,
    etag: "",
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(82).string(message.displayName);
    }
    for (const v of message.lineItems) {
      LineItem.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.cancelledLineItems) {
      LineItem.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(90).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cancelledLineItems.push(LineItem.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      lineItems: globalThis.Array.isArray(object?.lineItems)
        ? object.lineItems.map((e: any) => LineItem.fromJSON(e))
        : [],
      cancelledLineItems: globalThis.Array.isArray(object?.cancelledLineItems)
        ? object.cancelledLineItems.map((e: any) => LineItem.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.lineItems?.length) {
      obj.lineItems = message.lineItems.map((e) => LineItem.toJSON(e));
    }
    if (message.cancelledLineItems?.length) {
      obj.cancelledLineItems = message.cancelledLineItems.map((e) => LineItem.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Order>): Order {
    return Order.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Order>): Order {
    const message = createBaseOrder();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.lineItems = object.lineItems?.map((e) => LineItem.fromPartial(e)) || [];
    message.cancelledLineItems = object.cancelledLineItems?.map((e) => LineItem.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseLineItem(): LineItem {
  return { lineItemId: "", lineItemInfo: undefined, pendingChange: undefined, changeHistory: [] };
}

export const LineItem: MessageFns<LineItem> = {
  encode(message: LineItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lineItemId !== "") {
      writer.uint32(10).string(message.lineItemId);
    }
    if (message.lineItemInfo !== undefined) {
      LineItemInfo.encode(message.lineItemInfo, writer.uint32(18).fork()).join();
    }
    if (message.pendingChange !== undefined) {
      LineItemChange.encode(message.pendingChange, writer.uint32(26).fork()).join();
    }
    for (const v of message.changeHistory) {
      LineItemChange.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lineItemId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lineItemInfo = LineItemInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pendingChange = LineItemChange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.changeHistory.push(LineItemChange.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItem {
    return {
      lineItemId: isSet(object.lineItemId) ? globalThis.String(object.lineItemId) : "",
      lineItemInfo: isSet(object.lineItemInfo) ? LineItemInfo.fromJSON(object.lineItemInfo) : undefined,
      pendingChange: isSet(object.pendingChange) ? LineItemChange.fromJSON(object.pendingChange) : undefined,
      changeHistory: globalThis.Array.isArray(object?.changeHistory)
        ? object.changeHistory.map((e: any) => LineItemChange.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LineItem): unknown {
    const obj: any = {};
    if (message.lineItemId !== "") {
      obj.lineItemId = message.lineItemId;
    }
    if (message.lineItemInfo !== undefined) {
      obj.lineItemInfo = LineItemInfo.toJSON(message.lineItemInfo);
    }
    if (message.pendingChange !== undefined) {
      obj.pendingChange = LineItemChange.toJSON(message.pendingChange);
    }
    if (message.changeHistory?.length) {
      obj.changeHistory = message.changeHistory.map((e) => LineItemChange.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LineItem>): LineItem {
    return LineItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LineItem>): LineItem {
    const message = createBaseLineItem();
    message.lineItemId = object.lineItemId ?? "";
    message.lineItemInfo = (object.lineItemInfo !== undefined && object.lineItemInfo !== null)
      ? LineItemInfo.fromPartial(object.lineItemInfo)
      : undefined;
    message.pendingChange = (object.pendingChange !== undefined && object.pendingChange !== null)
      ? LineItemChange.fromPartial(object.pendingChange)
      : undefined;
    message.changeHistory = object.changeHistory?.map((e) => LineItemChange.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLineItemChange(): LineItemChange {
  return {
    changeId: "",
    changeType: 0,
    oldLineItemInfo: undefined,
    newLineItemInfo: undefined,
    changeState: 0,
    stateReason: "",
    changeStateReasonType: 0,
    changeEffectiveTime: undefined,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const LineItemChange: MessageFns<LineItemChange> = {
  encode(message: LineItemChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.changeId !== "") {
      writer.uint32(10).string(message.changeId);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.oldLineItemInfo !== undefined) {
      LineItemInfo.encode(message.oldLineItemInfo, writer.uint32(26).fork()).join();
    }
    if (message.newLineItemInfo !== undefined) {
      LineItemInfo.encode(message.newLineItemInfo, writer.uint32(34).fork()).join();
    }
    if (message.changeState !== 0) {
      writer.uint32(40).int32(message.changeState);
    }
    if (message.stateReason !== "") {
      writer.uint32(50).string(message.stateReason);
    }
    if (message.changeStateReasonType !== 0) {
      writer.uint32(80).int32(message.changeStateReasonType);
    }
    if (message.changeEffectiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.changeEffectiveTime), writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItemChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItemChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.changeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oldLineItemInfo = LineItemInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.newLineItemInfo = LineItemInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.changeState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stateReason = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.changeStateReasonType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.changeEffectiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItemChange {
    return {
      changeId: isSet(object.changeId) ? globalThis.String(object.changeId) : "",
      changeType: isSet(object.changeType) ? lineItemChangeTypeFromJSON(object.changeType) : 0,
      oldLineItemInfo: isSet(object.oldLineItemInfo) ? LineItemInfo.fromJSON(object.oldLineItemInfo) : undefined,
      newLineItemInfo: isSet(object.newLineItemInfo) ? LineItemInfo.fromJSON(object.newLineItemInfo) : undefined,
      changeState: isSet(object.changeState) ? lineItemChangeStateFromJSON(object.changeState) : 0,
      stateReason: isSet(object.stateReason) ? globalThis.String(object.stateReason) : "",
      changeStateReasonType: isSet(object.changeStateReasonType)
        ? lineItemChangeStateReasonTypeFromJSON(object.changeStateReasonType)
        : 0,
      changeEffectiveTime: isSet(object.changeEffectiveTime)
        ? fromJsonTimestamp(object.changeEffectiveTime)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: LineItemChange): unknown {
    const obj: any = {};
    if (message.changeId !== "") {
      obj.changeId = message.changeId;
    }
    if (message.changeType !== 0) {
      obj.changeType = lineItemChangeTypeToJSON(message.changeType);
    }
    if (message.oldLineItemInfo !== undefined) {
      obj.oldLineItemInfo = LineItemInfo.toJSON(message.oldLineItemInfo);
    }
    if (message.newLineItemInfo !== undefined) {
      obj.newLineItemInfo = LineItemInfo.toJSON(message.newLineItemInfo);
    }
    if (message.changeState !== 0) {
      obj.changeState = lineItemChangeStateToJSON(message.changeState);
    }
    if (message.stateReason !== "") {
      obj.stateReason = message.stateReason;
    }
    if (message.changeStateReasonType !== 0) {
      obj.changeStateReasonType = lineItemChangeStateReasonTypeToJSON(message.changeStateReasonType);
    }
    if (message.changeEffectiveTime !== undefined) {
      obj.changeEffectiveTime = message.changeEffectiveTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LineItemChange>): LineItemChange {
    return LineItemChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LineItemChange>): LineItemChange {
    const message = createBaseLineItemChange();
    message.changeId = object.changeId ?? "";
    message.changeType = object.changeType ?? 0;
    message.oldLineItemInfo = (object.oldLineItemInfo !== undefined && object.oldLineItemInfo !== null)
      ? LineItemInfo.fromPartial(object.oldLineItemInfo)
      : undefined;
    message.newLineItemInfo = (object.newLineItemInfo !== undefined && object.newLineItemInfo !== null)
      ? LineItemInfo.fromPartial(object.newLineItemInfo)
      : undefined;
    message.changeState = object.changeState ?? 0;
    message.stateReason = object.stateReason ?? "";
    message.changeStateReasonType = object.changeStateReasonType ?? 0;
    message.changeEffectiveTime = object.changeEffectiveTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseLineItemInfo(): LineItemInfo {
  return { offer: "", parameters: [], subscription: undefined };
}

export const LineItemInfo: MessageFns<LineItemInfo> = {
  encode(message: LineItemInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offer !== "") {
      writer.uint32(106).string(message.offer);
    }
    for (const v of message.parameters) {
      Parameter.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.subscription !== undefined) {
      Subscription.encode(message.subscription, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LineItemInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLineItemInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 13:
          if (tag !== 106) {
            break;
          }

          message.offer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parameters.push(Parameter.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.subscription = Subscription.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LineItemInfo {
    return {
      offer: isSet(object.offer) ? globalThis.String(object.offer) : "",
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Parameter.fromJSON(e))
        : [],
      subscription: isSet(object.subscription) ? Subscription.fromJSON(object.subscription) : undefined,
    };
  },

  toJSON(message: LineItemInfo): unknown {
    const obj: any = {};
    if (message.offer !== "") {
      obj.offer = message.offer;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Parameter.toJSON(e));
    }
    if (message.subscription !== undefined) {
      obj.subscription = Subscription.toJSON(message.subscription);
    }
    return obj;
  },

  create(base?: DeepPartial<LineItemInfo>): LineItemInfo {
    return LineItemInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LineItemInfo>): LineItemInfo {
    const message = createBaseLineItemInfo();
    message.offer = object.offer ?? "";
    message.parameters = object.parameters?.map((e) => Parameter.fromPartial(e)) || [];
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? Subscription.fromPartial(object.subscription)
      : undefined;
    return message;
  },
};

function createBaseParameter(): Parameter {
  return { name: "", value: undefined };
}

export const Parameter: MessageFns<Parameter> = {
  encode(message: Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Parameter_Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Parameter_Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Parameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Parameter_Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Parameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Parameter_Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Parameter>): Parameter {
    return Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Parameter>): Parameter {
    const message = createBaseParameter();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Parameter_Value.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseParameter_Value(): Parameter_Value {
  return { int64Value: undefined, stringValue: undefined, doubleValue: undefined };
}

export const Parameter_Value: MessageFns<Parameter_Value> = {
  encode(message: Parameter_Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int64Value !== undefined) {
      writer.uint32(24).int64(message.int64Value.toString());
    }
    if (message.stringValue !== undefined) {
      writer.uint32(34).string(message.stringValue);
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(41).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Parameter_Value {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameter_Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Parameter_Value {
    return {
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: Parameter_Value): unknown {
    const obj: any = {};
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create(base?: DeepPartial<Parameter_Value>): Parameter_Value {
    return Parameter_Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Parameter_Value>): Parameter_Value {
    const message = createBaseParameter_Value();
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return { startTime: undefined, endTime: undefined, autoRenewalEnabled: false };
}

export const Subscription: MessageFns<Subscription> = {
  encode(message: Subscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(26).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(10).fork()).join();
    }
    if (message.autoRenewalEnabled !== false) {
      writer.uint32(16).bool(message.autoRenewalEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.autoRenewalEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      autoRenewalEnabled: isSet(object.autoRenewalEnabled) ? globalThis.Boolean(object.autoRenewalEnabled) : false,
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.autoRenewalEnabled !== false) {
      obj.autoRenewalEnabled = message.autoRenewalEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<Subscription>): Subscription {
    return Subscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subscription>): Subscription {
    const message = createBaseSubscription();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.autoRenewalEnabled = object.autoRenewalEnabled ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
