// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/edgecontainer/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.edgecontainer.v1";

/**
 * Represents the accessibility state of a customer-managed KMS key used for
 * CMEK integration.
 */
export enum KmsKeyState {
  /** KMS_KEY_STATE_UNSPECIFIED - Unspecified. */
  KMS_KEY_STATE_UNSPECIFIED = 0,
  /** KMS_KEY_STATE_KEY_AVAILABLE - The key is available for use, and dependent resources should be accessible. */
  KMS_KEY_STATE_KEY_AVAILABLE = 1,
  /**
   * KMS_KEY_STATE_KEY_UNAVAILABLE - The key is unavailable for an unspecified reason. Dependent resources may
   * be inaccessible.
   */
  KMS_KEY_STATE_KEY_UNAVAILABLE = 2,
  UNRECOGNIZED = -1,
}

export function kmsKeyStateFromJSON(object: any): KmsKeyState {
  switch (object) {
    case 0:
    case "KMS_KEY_STATE_UNSPECIFIED":
      return KmsKeyState.KMS_KEY_STATE_UNSPECIFIED;
    case 1:
    case "KMS_KEY_STATE_KEY_AVAILABLE":
      return KmsKeyState.KMS_KEY_STATE_KEY_AVAILABLE;
    case 2:
    case "KMS_KEY_STATE_KEY_UNAVAILABLE":
      return KmsKeyState.KMS_KEY_STATE_KEY_UNAVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KmsKeyState.UNRECOGNIZED;
  }
}

export function kmsKeyStateToJSON(object: KmsKeyState): string {
  switch (object) {
    case KmsKeyState.KMS_KEY_STATE_UNSPECIFIED:
      return "KMS_KEY_STATE_UNSPECIFIED";
    case KmsKeyState.KMS_KEY_STATE_KEY_AVAILABLE:
      return "KMS_KEY_STATE_KEY_AVAILABLE";
    case KmsKeyState.KMS_KEY_STATE_KEY_UNAVAILABLE:
      return "KMS_KEY_STATE_KEY_UNAVAILABLE";
    case KmsKeyState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Google Distributed Cloud Edge Kubernetes cluster. */
export interface Cluster {
  /** Required. The resource name of the cluster. */
  name: string;
  /** Output only. The time when the cluster was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the cluster was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /** Required. Fleet configuration. */
  fleet:
    | Fleet
    | undefined;
  /** Required. Cluster-wide networking configuration. */
  networking:
    | ClusterNetworking
    | undefined;
  /** Required. Immutable. RBAC policy that will be applied and managed by GEC. */
  authorization:
    | Authorization
    | undefined;
  /**
   * Optional. The default maximum number of pods per node used if a maximum
   * value is not specified explicitly for a node pool in this cluster. If
   * unspecified, the Kubernetes default value will be used.
   */
  defaultMaxPodsPerNode: number;
  /** Output only. The IP address of the Kubernetes API server. */
  endpoint: string;
  /** Output only. The port number of the Kubernetes API server. */
  port: number;
  /** Output only. The PEM-encoded public certificate of the cluster's CA. */
  clusterCaCertificate: string;
  /** Optional. Cluster-wide maintenance policy configuration. */
  maintenancePolicy:
    | MaintenancePolicy
    | undefined;
  /** Output only. The control plane release version */
  controlPlaneVersion: string;
  /**
   * Output only. The lowest release version among all worker nodes. This field
   * can be empty if the cluster does not have any worker nodes.
   */
  nodeVersion: string;
  /** Optional. The configuration of the cluster control plane. */
  controlPlane:
    | Cluster_ControlPlane
    | undefined;
  /** Optional. The configuration of the system add-ons. */
  systemAddonsConfig:
    | Cluster_SystemAddonsConfig
    | undefined;
  /**
   * Optional. IPv4 address pools for cluster data plane external load
   * balancing.
   */
  externalLoadBalancerIpv4AddressPools: string[];
  /**
   * Optional. Remote control plane disk encryption options. This field is only
   * used when enabling CMEK support.
   */
  controlPlaneEncryption:
    | Cluster_ControlPlaneEncryption
    | undefined;
  /** Output only. The current status of the cluster. */
  status: Cluster_Status;
  /**
   * Output only. All the maintenance events scheduled for the cluster,
   * including the ones ongoing, planned for the future and done in the past (up
   * to 90 days).
   */
  maintenanceEvents: Cluster_MaintenanceEvent[];
  /** Optional. The target cluster version. For example: "1.5.0". */
  targetVersion: string;
  /** Optional. The release channel a cluster is subscribed to. */
  releaseChannel: Cluster_ReleaseChannel;
  /**
   * Optional. Configuration of the cluster survivability, e.g., for the case
   * when network connectivity is lost. Note: This only applies to local control
   * plane clusters.
   */
  survivabilityConfig:
    | Cluster_SurvivabilityConfig
    | undefined;
  /**
   * Optional. IPv6 address pools for cluster data plane external load
   * balancing.
   */
  externalLoadBalancerIpv6AddressPools: string[];
}

/** Indicates the status of the cluster. */
export enum Cluster_Status {
  /** STATUS_UNSPECIFIED - Status unknown. */
  STATUS_UNSPECIFIED = 0,
  /** PROVISIONING - The cluster is being created. */
  PROVISIONING = 1,
  /** RUNNING - The cluster is created and fully usable. */
  RUNNING = 2,
  /** DELETING - The cluster is being deleted. */
  DELETING = 3,
  /**
   * ERROR - The status indicates that some errors occurred while reconciling/deleting
   * the cluster.
   */
  ERROR = 4,
  /** RECONCILING - The cluster is undergoing some work such as version upgrades, etc. */
  RECONCILING = 5,
  UNRECOGNIZED = -1,
}

export function cluster_StatusFromJSON(object: any): Cluster_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Cluster_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Cluster_Status.PROVISIONING;
    case 2:
    case "RUNNING":
      return Cluster_Status.RUNNING;
    case 3:
    case "DELETING":
      return Cluster_Status.DELETING;
    case 4:
    case "ERROR":
      return Cluster_Status.ERROR;
    case 5:
    case "RECONCILING":
      return Cluster_Status.RECONCILING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_Status.UNRECOGNIZED;
  }
}

export function cluster_StatusToJSON(object: Cluster_Status): string {
  switch (object) {
    case Cluster_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Cluster_Status.PROVISIONING:
      return "PROVISIONING";
    case Cluster_Status.RUNNING:
      return "RUNNING";
    case Cluster_Status.DELETING:
      return "DELETING";
    case Cluster_Status.ERROR:
      return "ERROR";
    case Cluster_Status.RECONCILING:
      return "RECONCILING";
    case Cluster_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The release channel a cluster is subscribed to. */
export enum Cluster_ReleaseChannel {
  /** RELEASE_CHANNEL_UNSPECIFIED - Unspecified release channel. This will default to the REGULAR channel. */
  RELEASE_CHANNEL_UNSPECIFIED = 0,
  /** NONE - No release channel. */
  NONE = 1,
  /** REGULAR - Regular release channel. */
  REGULAR = 2,
  UNRECOGNIZED = -1,
}

export function cluster_ReleaseChannelFromJSON(object: any): Cluster_ReleaseChannel {
  switch (object) {
    case 0:
    case "RELEASE_CHANNEL_UNSPECIFIED":
      return Cluster_ReleaseChannel.RELEASE_CHANNEL_UNSPECIFIED;
    case 1:
    case "NONE":
      return Cluster_ReleaseChannel.NONE;
    case 2:
    case "REGULAR":
      return Cluster_ReleaseChannel.REGULAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_ReleaseChannel.UNRECOGNIZED;
  }
}

export function cluster_ReleaseChannelToJSON(object: Cluster_ReleaseChannel): string {
  switch (object) {
    case Cluster_ReleaseChannel.RELEASE_CHANNEL_UNSPECIFIED:
      return "RELEASE_CHANNEL_UNSPECIFIED";
    case Cluster_ReleaseChannel.NONE:
      return "NONE";
    case Cluster_ReleaseChannel.REGULAR:
      return "REGULAR";
    case Cluster_ReleaseChannel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration of the cluster control plane. */
export interface Cluster_ControlPlane {
  /** Remote control plane configuration. */
  remote?:
    | Cluster_ControlPlane_Remote
    | undefined;
  /**
   * Local control plane configuration.
   *
   * Warning: Local control plane clusters must be created in their own
   * project. Local control plane clusters cannot coexist in the same
   * project with any other type of clusters, including non-GDCE clusters.
   * Mixing local control plane GDCE clusters with any other type of
   * clusters in the same project can result in data loss.
   */
  local?: Cluster_ControlPlane_Local | undefined;
}

/**
 * Represents the policy configuration about how user applications are
 * deployed.
 */
export enum Cluster_ControlPlane_SharedDeploymentPolicy {
  /** SHARED_DEPLOYMENT_POLICY_UNSPECIFIED - Unspecified. */
  SHARED_DEPLOYMENT_POLICY_UNSPECIFIED = 0,
  /**
   * ALLOWED - User applications can be deployed both on control plane and worker
   * nodes.
   */
  ALLOWED = 1,
  /**
   * DISALLOWED - User applications can not be deployed on control plane nodes and can
   * only be deployed on worker nodes.
   */
  DISALLOWED = 2,
  UNRECOGNIZED = -1,
}

export function cluster_ControlPlane_SharedDeploymentPolicyFromJSON(
  object: any,
): Cluster_ControlPlane_SharedDeploymentPolicy {
  switch (object) {
    case 0:
    case "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED":
      return Cluster_ControlPlane_SharedDeploymentPolicy.SHARED_DEPLOYMENT_POLICY_UNSPECIFIED;
    case 1:
    case "ALLOWED":
      return Cluster_ControlPlane_SharedDeploymentPolicy.ALLOWED;
    case 2:
    case "DISALLOWED":
      return Cluster_ControlPlane_SharedDeploymentPolicy.DISALLOWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_ControlPlane_SharedDeploymentPolicy.UNRECOGNIZED;
  }
}

export function cluster_ControlPlane_SharedDeploymentPolicyToJSON(
  object: Cluster_ControlPlane_SharedDeploymentPolicy,
): string {
  switch (object) {
    case Cluster_ControlPlane_SharedDeploymentPolicy.SHARED_DEPLOYMENT_POLICY_UNSPECIFIED:
      return "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED";
    case Cluster_ControlPlane_SharedDeploymentPolicy.ALLOWED:
      return "ALLOWED";
    case Cluster_ControlPlane_SharedDeploymentPolicy.DISALLOWED:
      return "DISALLOWED";
    case Cluster_ControlPlane_SharedDeploymentPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration specific to clusters with a control plane hosted remotely. */
export interface Cluster_ControlPlane_Remote {
}

/**
 * Configuration specific to clusters with a control plane hosted locally.
 *
 * Warning: Local control plane clusters must be created in their own
 * project. Local control plane clusters cannot coexist in the same
 * project with any other type of clusters, including non-GDCE clusters.
 * Mixing local control plane GDCE clusters with any other type of
 * clusters in the same project can result in data loss.
 */
export interface Cluster_ControlPlane_Local {
  /**
   * Name of the Google Distributed Cloud Edge zones where this node pool
   * will be created. For example: `us-central1-edge-customer-a`.
   */
  nodeLocation: string;
  /** The number of nodes to serve as replicas of the Control Plane. */
  nodeCount: number;
  /**
   * Only machines matching this filter will be allowed to host control
   * plane nodes. The filtering language accepts strings like "name=<name>",
   * and is documented here: [AIP-160](https://google.aip.dev/160).
   */
  machineFilter: string;
  /** Policy configuration about how user applications are deployed. */
  sharedDeploymentPolicy: Cluster_ControlPlane_SharedDeploymentPolicy;
}

/** Config that customers are allowed to define for GDCE system add-ons. */
export interface Cluster_SystemAddonsConfig {
  /** Optional. Config for Ingress. */
  ingress: Cluster_SystemAddonsConfig_Ingress | undefined;
}

/**
 * Config for the Ingress add-on which allows customers to create an Ingress
 * object to manage external access to the servers in a cluster. The add-on
 * consists of istiod and istio-ingress.
 */
export interface Cluster_SystemAddonsConfig_Ingress {
  /** Optional. Whether Ingress is disabled. */
  disabled: boolean;
  /** Optional. Ingress VIP. */
  ipv4Vip: string;
}

/**
 * Configuration for Customer-managed KMS key support for remote control plane
 * cluster disk encryption.
 */
export interface Cluster_ControlPlaneEncryption {
  /**
   * Immutable. The Cloud KMS CryptoKey e.g.
   * projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
   * to use for protecting control plane disks. If not specified, a
   * Google-managed key will be used instead.
   */
  kmsKey: string;
  /**
   * Output only. The Cloud KMS CryptoKeyVersion currently in use for
   * protecting control plane disks. Only applicable if kms_key is set.
   */
  kmsKeyActiveVersion: string;
  /**
   * Output only. Availability of the Cloud KMS CryptoKey. If not
   * `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
   * local data. This can be caused by a lack of permissions to use the key,
   * or if the key is disabled or deleted.
   */
  kmsKeyState: KmsKeyState;
  /**
   * Output only. Error status returned by Cloud KMS when using this key. This
   * field may be populated only if `kms_key_state` is not
   * `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
   * error status reported by Cloud KMS.
   */
  kmsStatus: Status | undefined;
}

/**
 * A Maintenance Event is an operation that could cause temporary disruptions
 * to the cluster workloads, including Google-driven or user-initiated cluster
 * upgrades, user-initiated cluster configuration changes that require
 * restarting nodes, etc.
 */
export interface Cluster_MaintenanceEvent {
  /** Output only. UUID of the maintenance event. */
  uuid: string;
  /** Output only. The target version of the cluster. */
  targetVersion: string;
  /**
   * Output only. The operation for running the maintenance event. Specified
   * in the format projects/* /locations/* /operations/*. If the maintenance
   * event is split into multiple operations (e.g. due to maintenance
   * windows), the latest one is recorded.
   */
  operation: string;
  /** Output only. The type of the maintenance event. */
  type: Cluster_MaintenanceEvent_Type;
  /** Output only. The schedule of the maintenance event. */
  schedule: Cluster_MaintenanceEvent_Schedule;
  /** Output only. The state of the maintenance event. */
  state: Cluster_MaintenanceEvent_State;
  /** Output only. The time when the maintenance event request was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the maintenance event started. */
  startTime:
    | Date
    | undefined;
  /**
   * Output only. The time when the maintenance event ended, either
   * successfully or not. If the maintenance event is split into multiple
   * maintenance windows, end_time is only updated when the whole flow ends.
   */
  endTime:
    | Date
    | undefined;
  /** Output only. The time when the maintenance event message was updated. */
  updateTime: Date | undefined;
}

/** Indicates the maintenance event type. */
export enum Cluster_MaintenanceEvent_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** USER_INITIATED_UPGRADE - Upgrade initiated by users. */
  USER_INITIATED_UPGRADE = 1,
  /** GOOGLE_DRIVEN_UPGRADE - Upgrade driven by Google. */
  GOOGLE_DRIVEN_UPGRADE = 2,
  UNRECOGNIZED = -1,
}

export function cluster_MaintenanceEvent_TypeFromJSON(object: any): Cluster_MaintenanceEvent_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Cluster_MaintenanceEvent_Type.TYPE_UNSPECIFIED;
    case 1:
    case "USER_INITIATED_UPGRADE":
      return Cluster_MaintenanceEvent_Type.USER_INITIATED_UPGRADE;
    case 2:
    case "GOOGLE_DRIVEN_UPGRADE":
      return Cluster_MaintenanceEvent_Type.GOOGLE_DRIVEN_UPGRADE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_MaintenanceEvent_Type.UNRECOGNIZED;
  }
}

export function cluster_MaintenanceEvent_TypeToJSON(object: Cluster_MaintenanceEvent_Type): string {
  switch (object) {
    case Cluster_MaintenanceEvent_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Cluster_MaintenanceEvent_Type.USER_INITIATED_UPGRADE:
      return "USER_INITIATED_UPGRADE";
    case Cluster_MaintenanceEvent_Type.GOOGLE_DRIVEN_UPGRADE:
      return "GOOGLE_DRIVEN_UPGRADE";
    case Cluster_MaintenanceEvent_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates when the maintenance event should be performed. */
export enum Cluster_MaintenanceEvent_Schedule {
  /** SCHEDULE_UNSPECIFIED - Unspecified. */
  SCHEDULE_UNSPECIFIED = 0,
  /** IMMEDIATELY - Immediately after receiving the request. */
  IMMEDIATELY = 1,
  UNRECOGNIZED = -1,
}

export function cluster_MaintenanceEvent_ScheduleFromJSON(object: any): Cluster_MaintenanceEvent_Schedule {
  switch (object) {
    case 0:
    case "SCHEDULE_UNSPECIFIED":
      return Cluster_MaintenanceEvent_Schedule.SCHEDULE_UNSPECIFIED;
    case 1:
    case "IMMEDIATELY":
      return Cluster_MaintenanceEvent_Schedule.IMMEDIATELY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_MaintenanceEvent_Schedule.UNRECOGNIZED;
  }
}

export function cluster_MaintenanceEvent_ScheduleToJSON(object: Cluster_MaintenanceEvent_Schedule): string {
  switch (object) {
    case Cluster_MaintenanceEvent_Schedule.SCHEDULE_UNSPECIFIED:
      return "SCHEDULE_UNSPECIFIED";
    case Cluster_MaintenanceEvent_Schedule.IMMEDIATELY:
      return "IMMEDIATELY";
    case Cluster_MaintenanceEvent_Schedule.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates the maintenance event state. */
export enum Cluster_MaintenanceEvent_State {
  /** STATE_UNSPECIFIED - Unspecified. */
  STATE_UNSPECIFIED = 0,
  /** RECONCILING - The maintenance event is ongoing. The cluster might be unusable. */
  RECONCILING = 1,
  /** SUCCEEDED - The maintenance event succeeded. */
  SUCCEEDED = 2,
  /** FAILED - The maintenance event failed. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function cluster_MaintenanceEvent_StateFromJSON(object: any): Cluster_MaintenanceEvent_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Cluster_MaintenanceEvent_State.STATE_UNSPECIFIED;
    case 1:
    case "RECONCILING":
      return Cluster_MaintenanceEvent_State.RECONCILING;
    case 2:
    case "SUCCEEDED":
      return Cluster_MaintenanceEvent_State.SUCCEEDED;
    case 3:
    case "FAILED":
      return Cluster_MaintenanceEvent_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_MaintenanceEvent_State.UNRECOGNIZED;
  }
}

export function cluster_MaintenanceEvent_StateToJSON(object: Cluster_MaintenanceEvent_State): string {
  switch (object) {
    case Cluster_MaintenanceEvent_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Cluster_MaintenanceEvent_State.RECONCILING:
      return "RECONCILING";
    case Cluster_MaintenanceEvent_State.SUCCEEDED:
      return "SUCCEEDED";
    case Cluster_MaintenanceEvent_State.FAILED:
      return "FAILED";
    case Cluster_MaintenanceEvent_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Configuration of the cluster survivability, e.g., for the case when network
 * connectivity is lost.
 */
export interface Cluster_SurvivabilityConfig {
  /**
   * Optional. Time period that allows the cluster nodes to be rebooted and
   * become functional without network connectivity to Google. The default 0
   * means not allowed. The maximum is 7 days.
   */
  offlineRebootTtl: Duration | undefined;
}

export interface Cluster_LabelsEntry {
  key: string;
  value: string;
}

/** Cluster-wide networking configuration. */
export interface ClusterNetworking {
  /**
   * Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
   * these blocks. Only a single block is supported. This field cannot be
   * changed after creation.
   */
  clusterIpv4CidrBlocks: string[];
  /**
   * Required. All services in the cluster are assigned an RFC1918 IPv4 address
   * from these blocks. Only a single block is supported. This field cannot be
   * changed after creation.
   */
  servicesIpv4CidrBlocks: string[];
}

/**
 * Fleet related configuration.
 *
 * Fleets are a Google Cloud concept for logically organizing clusters,
 * letting you use and manage multi-cluster capabilities and apply
 * consistent policies across your systems.
 */
export interface Fleet {
  /**
   * Required. The name of the Fleet host project where this cluster will be
   * registered.
   *
   * Project names are formatted as
   * `projects/<project-number>`.
   */
  project: string;
  /**
   * Output only. The name of the managed Hub Membership resource associated to
   * this cluster.
   *
   * Membership names are formatted as
   * `projects/<project-number>/locations/global/membership/<cluster-id>`.
   */
  membership: string;
}

/** A user principal for an RBAC policy. */
export interface ClusterUser {
  /** Required. An active Google username. */
  username: string;
}

/** RBAC policy that will be applied and managed by GEC. */
export interface Authorization {
  /**
   * Required. User that will be granted the cluster-admin role on the cluster,
   * providing full access to the cluster. Currently, this is a singular field,
   * but will be expanded to allow multiple admins in the future.
   */
  adminUsers: ClusterUser | undefined;
}

/**
 * A set of Kubernetes nodes in a cluster with common configuration and
 * specification.
 */
export interface NodePool {
  /** Required. The resource name of the node pool. */
  name: string;
  /** Output only. The time when the node pool was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the node pool was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Name of the Google Distributed Cloud Edge zone where this node pool will be
   * created. For example: `us-central1-edge-customer-a`.
   */
  nodeLocation: string;
  /** Required. The number of nodes in the pool. */
  nodeCount: number;
  /**
   * Only machines matching this filter will be allowed to join the node pool.
   * The filtering language accepts strings like "name=<name>", and is
   * documented in more detail in [AIP-160](https://google.aip.dev/160).
   */
  machineFilter: string;
  /**
   * Optional. Local disk encryption options. This field is only used when
   * enabling CMEK support.
   */
  localDiskEncryption:
    | NodePool_LocalDiskEncryption
    | undefined;
  /** Output only. The lowest release version among all worker nodes. */
  nodeVersion: string;
  /** Optional. Configuration for each node in the NodePool */
  nodeConfig: NodePool_NodeConfig | undefined;
}

/** Configuration for CMEK support for edge machine local disk encryption. */
export interface NodePool_LocalDiskEncryption {
  /**
   * Immutable. The Cloud KMS CryptoKey e.g.
   * projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
   * to use for protecting node local disks. If not specified, a
   * Google-managed key will be used instead.
   */
  kmsKey: string;
  /**
   * Output only. The Cloud KMS CryptoKeyVersion currently in use for
   * protecting node local disks. Only applicable if kms_key is set.
   */
  kmsKeyActiveVersion: string;
  /**
   * Output only. Availability of the Cloud KMS CryptoKey. If not
   * `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
   * local data. This can be caused by a lack of permissions to use the key,
   * or if the key is disabled or deleted.
   */
  kmsKeyState: KmsKeyState;
  /**
   * Output only. Error status returned by Cloud KMS when using this key. This
   * field may be populated only if `kms_key_state` is not
   * `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
   * error status reported by Cloud KMS.
   */
  kmsStatus: Status | undefined;
}

/** Configuration for each node in the NodePool */
export interface NodePool_NodeConfig {
  /** Optional. The Kubernetes node labels */
  labels: { [key: string]: string };
}

export interface NodePool_NodeConfig_LabelsEntry {
  key: string;
  value: string;
}

export interface NodePool_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A Google Distributed Cloud Edge machine capable of acting as a Kubernetes
 * node.
 */
export interface Machine {
  /** Required. The resource name of the machine. */
  name: string;
  /** Output only. The time when the node pool was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the node pool was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * Canonical resource name of the node that this machine is responsible for
   * hosting e.g.
   * projects/{project}/locations/{location}/clusters/{cluster_id}/nodePools/{pool_id}/{node},
   * Or empty if the machine is not assigned to assume the role of a node.
   *
   * For control plane nodes hosted on edge machines, this will return
   * the following format:
   *   "projects/{project}/locations/{location}/clusters/{cluster_id}/controlPlaneNodes/{node}".
   */
  hostedNode: string;
  /** The Google Distributed Cloud Edge zone of this machine. */
  zone: string;
  /** Output only. The software version of the machine. */
  version: string;
  /**
   * Output only. Whether the machine is disabled. If disabled, the machine is
   * unable to enter service.
   */
  disabled: boolean;
}

export interface Machine_LabelsEntry {
  key: string;
  value: string;
}

/** A VPN connection . */
export interface VpnConnection {
  /** Required. The resource name of VPN connection */
  name: string;
  /** Output only. The time when the VPN connection was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the VPN connection was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Labels associated with this resource. */
  labels: { [key: string]: string };
  /**
   * NAT gateway IP, or WAN IP address. If a customer has multiple NAT IPs, the
   * customer needs to configure NAT such that only one external IP maps to the
   * GMEC Anthos cluster. This is empty if NAT is not used.
   */
  natGatewayIp: string;
  /**
   * Dynamic routing mode of the VPC network, `regional` or `global`.
   *
   * @deprecated
   */
  bgpRoutingMode: VpnConnection_BgpRoutingMode;
  /**
   * The canonical Cluster name to connect to. It is in the form of
   * projects/{project}/locations/{location}/clusters/{cluster}.
   */
  cluster: string;
  /** The network ID of VPC to connect to. */
  vpc: string;
  /**
   * Optional. Project detail of the VPC network. Required if VPC is in a
   * different project than the cluster project.
   */
  vpcProject:
    | VpnConnection_VpcProject
    | undefined;
  /**
   * Whether this VPN connection has HA enabled on cluster side. If enabled,
   * when creating VPN connection we will attempt to use 2 ANG floating IPs.
   */
  enableHighAvailability: boolean;
  /** Optional. The VPN connection Cloud Router name. */
  router: string;
  /** Output only. The created connection details. */
  details: VpnConnection_Details | undefined;
}

/** Routing mode. */
export enum VpnConnection_BgpRoutingMode {
  /** BGP_ROUTING_MODE_UNSPECIFIED - Unknown. */
  BGP_ROUTING_MODE_UNSPECIFIED = 0,
  /** REGIONAL - Regional mode. */
  REGIONAL = 1,
  /** GLOBAL - Global mode. */
  GLOBAL = 2,
  UNRECOGNIZED = -1,
}

export function vpnConnection_BgpRoutingModeFromJSON(object: any): VpnConnection_BgpRoutingMode {
  switch (object) {
    case 0:
    case "BGP_ROUTING_MODE_UNSPECIFIED":
      return VpnConnection_BgpRoutingMode.BGP_ROUTING_MODE_UNSPECIFIED;
    case 1:
    case "REGIONAL":
      return VpnConnection_BgpRoutingMode.REGIONAL;
    case 2:
    case "GLOBAL":
      return VpnConnection_BgpRoutingMode.GLOBAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VpnConnection_BgpRoutingMode.UNRECOGNIZED;
  }
}

export function vpnConnection_BgpRoutingModeToJSON(object: VpnConnection_BgpRoutingMode): string {
  switch (object) {
    case VpnConnection_BgpRoutingMode.BGP_ROUTING_MODE_UNSPECIFIED:
      return "BGP_ROUTING_MODE_UNSPECIFIED";
    case VpnConnection_BgpRoutingMode.REGIONAL:
      return "REGIONAL";
    case VpnConnection_BgpRoutingMode.GLOBAL:
      return "GLOBAL";
    case VpnConnection_BgpRoutingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Project detail of the VPC network. */
export interface VpnConnection_VpcProject {
  /**
   * The project of the VPC to connect to. If not specified, it is the same as
   * the cluster project.
   */
  projectId: string;
  /**
   * Optional. The service account in the VPC project configured by user. It
   * is used to create/delete Cloud Router and Cloud HA VPNs for VPN
   * connection. If this SA is changed during/after a VPN connection is
   * created, you need to remove the Cloud Router and Cloud VPN resources in
   * |project_id|. It is in the form of
   * service-{project_number}@gcp-sa-edgecontainer.iam.gserviceaccount.com.
   *
   * @deprecated
   */
  serviceAccount: string;
}

/** The created connection details. */
export interface VpnConnection_Details {
  /** The state of this connection. */
  state: VpnConnection_Details_State;
  /** The error message. This is only populated when state=ERROR. */
  error: string;
  /** The Cloud Router info. */
  cloudRouter:
    | VpnConnection_Details_CloudRouter
    | undefined;
  /** Each connection has multiple Cloud VPN gateways. */
  cloudVpns: VpnConnection_Details_CloudVpn[];
}

/** The current connection state. */
export enum VpnConnection_Details_State {
  /** STATE_UNSPECIFIED - Unknown. */
  STATE_UNSPECIFIED = 0,
  /** STATE_CONNECTED - Connected. */
  STATE_CONNECTED = 1,
  /** STATE_CONNECTING - Still connecting. */
  STATE_CONNECTING = 2,
  /** STATE_ERROR - Error occurred. */
  STATE_ERROR = 3,
  UNRECOGNIZED = -1,
}

export function vpnConnection_Details_StateFromJSON(object: any): VpnConnection_Details_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return VpnConnection_Details_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_CONNECTED":
      return VpnConnection_Details_State.STATE_CONNECTED;
    case 2:
    case "STATE_CONNECTING":
      return VpnConnection_Details_State.STATE_CONNECTING;
    case 3:
    case "STATE_ERROR":
      return VpnConnection_Details_State.STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VpnConnection_Details_State.UNRECOGNIZED;
  }
}

export function vpnConnection_Details_StateToJSON(object: VpnConnection_Details_State): string {
  switch (object) {
    case VpnConnection_Details_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case VpnConnection_Details_State.STATE_CONNECTED:
      return "STATE_CONNECTED";
    case VpnConnection_Details_State.STATE_CONNECTING:
      return "STATE_CONNECTING";
    case VpnConnection_Details_State.STATE_ERROR:
      return "STATE_ERROR";
    case VpnConnection_Details_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The Cloud Router info. */
export interface VpnConnection_Details_CloudRouter {
  /** The associated Cloud Router name. */
  name: string;
}

/** The Cloud VPN info. */
export interface VpnConnection_Details_CloudVpn {
  /** The created Cloud VPN gateway name. */
  gateway: string;
}

export interface VpnConnection_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Metadata for a given
 * [google.cloud.location.Location][google.cloud.location.Location].
 */
export interface LocationMetadata {
  /**
   * The set of available Google Distributed Cloud Edge zones in the location.
   * The map is keyed by the lowercase ID of each zone.
   */
  availableZones: { [key: string]: ZoneMetadata };
}

export interface LocationMetadata_AvailableZonesEntry {
  key: string;
  value: ZoneMetadata | undefined;
}

/** A Google Distributed Cloud Edge zone where edge machines are located. */
export interface ZoneMetadata {
  /** Quota for resources in this zone. */
  quota: Quota[];
  /** The map keyed by rack name and has value of RackType. */
  rackTypes: { [key: string]: ZoneMetadata_RackType };
}

/** Type of the rack. */
export enum ZoneMetadata_RackType {
  /** RACK_TYPE_UNSPECIFIED - Unspecified rack type, single rack also belongs to this type. */
  RACK_TYPE_UNSPECIFIED = 0,
  /**
   * BASE - Base rack type, a pair of two modified Config-1 racks containing
   * Aggregation switches.
   */
  BASE = 1,
  /**
   * EXPANSION - Expansion rack type, also known as standalone racks,
   * added by customers on demand.
   */
  EXPANSION = 2,
  UNRECOGNIZED = -1,
}

export function zoneMetadata_RackTypeFromJSON(object: any): ZoneMetadata_RackType {
  switch (object) {
    case 0:
    case "RACK_TYPE_UNSPECIFIED":
      return ZoneMetadata_RackType.RACK_TYPE_UNSPECIFIED;
    case 1:
    case "BASE":
      return ZoneMetadata_RackType.BASE;
    case 2:
    case "EXPANSION":
      return ZoneMetadata_RackType.EXPANSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ZoneMetadata_RackType.UNRECOGNIZED;
  }
}

export function zoneMetadata_RackTypeToJSON(object: ZoneMetadata_RackType): string {
  switch (object) {
    case ZoneMetadata_RackType.RACK_TYPE_UNSPECIFIED:
      return "RACK_TYPE_UNSPECIFIED";
    case ZoneMetadata_RackType.BASE:
      return "BASE";
    case ZoneMetadata_RackType.EXPANSION:
      return "EXPANSION";
    case ZoneMetadata_RackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ZoneMetadata_RackTypesEntry {
  key: string;
  value: ZoneMetadata_RackType;
}

/** Represents quota for Edge Container resources. */
export interface Quota {
  /** Name of the quota metric. */
  metric: string;
  /** Quota limit for this metric. */
  limit: number;
  /** Current usage of this metric. */
  usage: number;
}

/** Maintenance policy configuration. */
export interface MaintenancePolicy {
  /** Specifies the maintenance window in which maintenance may be performed. */
  window: MaintenanceWindow | undefined;
}

/** Maintenance window configuration */
export interface MaintenanceWindow {
  /** Configuration of a recurring maintenance window. */
  recurringWindow: RecurringTimeWindow | undefined;
}

/** Represents an arbitrary window of time that recurs. */
export interface RecurringTimeWindow {
  /** The window of the first recurrence. */
  window:
    | TimeWindow
    | undefined;
  /**
   * An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how
   * this window recurs. They go on for the span of time between the start and
   * end time.
   */
  recurrence: string;
}

/** Represents an arbitrary window of time. */
export interface TimeWindow {
  /** The time that the window first starts. */
  startTime:
    | Date
    | undefined;
  /**
   * The time that the window ends. The end time must take place after the
   * start time.
   */
  endTime: Date | undefined;
}

/** Server configuration for supported versions and release channels. */
export interface ServerConfig {
  /** Output only. Mapping from release channel to channel config. */
  channels: { [key: string]: ChannelConfig };
  /** Output only. Supported versions, e.g.: ["1.4.0", "1.5.0"]. */
  versions: Version[];
  /** Output only. Default version, e.g.: "1.4.0". */
  defaultVersion: string;
}

export interface ServerConfig_ChannelsEntry {
  key: string;
  value: ChannelConfig | undefined;
}

/** Configuration for a release channel. */
export interface ChannelConfig {
  /** Output only. Default version for this release channel, e.g.: "1.4.0". */
  defaultVersion: string;
}

/** Version of a cluster. */
export interface Version {
  /** Output only. Name of the version, e.g.: "1.4.0". */
  name: string;
}

function createBaseCluster(): Cluster {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    fleet: undefined,
    networking: undefined,
    authorization: undefined,
    defaultMaxPodsPerNode: 0,
    endpoint: "",
    port: 0,
    clusterCaCertificate: "",
    maintenancePolicy: undefined,
    controlPlaneVersion: "",
    nodeVersion: "",
    controlPlane: undefined,
    systemAddonsConfig: undefined,
    externalLoadBalancerIpv4AddressPools: [],
    controlPlaneEncryption: undefined,
    status: 0,
    maintenanceEvents: [],
    targetVersion: "",
    releaseChannel: 0,
    survivabilityConfig: undefined,
    externalLoadBalancerIpv6AddressPools: [],
  };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Cluster_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.fleet !== undefined) {
      Fleet.encode(message.fleet, writer.uint32(90).fork()).join();
    }
    if (message.networking !== undefined) {
      ClusterNetworking.encode(message.networking, writer.uint32(58).fork()).join();
    }
    if (message.authorization !== undefined) {
      Authorization.encode(message.authorization, writer.uint32(74).fork()).join();
    }
    if (message.defaultMaxPodsPerNode !== 0) {
      writer.uint32(64).int32(message.defaultMaxPodsPerNode);
    }
    if (message.endpoint !== "") {
      writer.uint32(50).string(message.endpoint);
    }
    if (message.port !== 0) {
      writer.uint32(152).int32(message.port);
    }
    if (message.clusterCaCertificate !== "") {
      writer.uint32(82).string(message.clusterCaCertificate);
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(98).fork()).join();
    }
    if (message.controlPlaneVersion !== "") {
      writer.uint32(106).string(message.controlPlaneVersion);
    }
    if (message.nodeVersion !== "") {
      writer.uint32(114).string(message.nodeVersion);
    }
    if (message.controlPlane !== undefined) {
      Cluster_ControlPlane.encode(message.controlPlane, writer.uint32(122).fork()).join();
    }
    if (message.systemAddonsConfig !== undefined) {
      Cluster_SystemAddonsConfig.encode(message.systemAddonsConfig, writer.uint32(130).fork()).join();
    }
    for (const v of message.externalLoadBalancerIpv4AddressPools) {
      writer.uint32(138).string(v!);
    }
    if (message.controlPlaneEncryption !== undefined) {
      Cluster_ControlPlaneEncryption.encode(message.controlPlaneEncryption, writer.uint32(146).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(160).int32(message.status);
    }
    for (const v of message.maintenanceEvents) {
      Cluster_MaintenanceEvent.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.targetVersion !== "") {
      writer.uint32(178).string(message.targetVersion);
    }
    if (message.releaseChannel !== 0) {
      writer.uint32(184).int32(message.releaseChannel);
    }
    if (message.survivabilityConfig !== undefined) {
      Cluster_SurvivabilityConfig.encode(message.survivabilityConfig, writer.uint32(194).fork()).join();
    }
    for (const v of message.externalLoadBalancerIpv6AddressPools) {
      writer.uint32(202).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Cluster_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.fleet = Fleet.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networking = ClusterNetworking.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.authorization = Authorization.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.defaultMaxPodsPerNode = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.clusterCaCertificate = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.controlPlaneVersion = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.nodeVersion = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.controlPlane = Cluster_ControlPlane.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.systemAddonsConfig = Cluster_SystemAddonsConfig.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.externalLoadBalancerIpv4AddressPools.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.controlPlaneEncryption = Cluster_ControlPlaneEncryption.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.maintenanceEvents.push(Cluster_MaintenanceEvent.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.releaseChannel = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.survivabilityConfig = Cluster_SurvivabilityConfig.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.externalLoadBalancerIpv6AddressPools.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      fleet: isSet(object.fleet) ? Fleet.fromJSON(object.fleet) : undefined,
      networking: isSet(object.networking) ? ClusterNetworking.fromJSON(object.networking) : undefined,
      authorization: isSet(object.authorization) ? Authorization.fromJSON(object.authorization) : undefined,
      defaultMaxPodsPerNode: isSet(object.defaultMaxPodsPerNode) ? globalThis.Number(object.defaultMaxPodsPerNode) : 0,
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      clusterCaCertificate: isSet(object.clusterCaCertificate) ? globalThis.String(object.clusterCaCertificate) : "",
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      controlPlaneVersion: isSet(object.controlPlaneVersion) ? globalThis.String(object.controlPlaneVersion) : "",
      nodeVersion: isSet(object.nodeVersion) ? globalThis.String(object.nodeVersion) : "",
      controlPlane: isSet(object.controlPlane) ? Cluster_ControlPlane.fromJSON(object.controlPlane) : undefined,
      systemAddonsConfig: isSet(object.systemAddonsConfig)
        ? Cluster_SystemAddonsConfig.fromJSON(object.systemAddonsConfig)
        : undefined,
      externalLoadBalancerIpv4AddressPools: globalThis.Array.isArray(object?.externalLoadBalancerIpv4AddressPools)
        ? object.externalLoadBalancerIpv4AddressPools.map((e: any) => globalThis.String(e))
        : [],
      controlPlaneEncryption: isSet(object.controlPlaneEncryption)
        ? Cluster_ControlPlaneEncryption.fromJSON(object.controlPlaneEncryption)
        : undefined,
      status: isSet(object.status) ? cluster_StatusFromJSON(object.status) : 0,
      maintenanceEvents: globalThis.Array.isArray(object?.maintenanceEvents)
        ? object.maintenanceEvents.map((e: any) => Cluster_MaintenanceEvent.fromJSON(e))
        : [],
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
      releaseChannel: isSet(object.releaseChannel) ? cluster_ReleaseChannelFromJSON(object.releaseChannel) : 0,
      survivabilityConfig: isSet(object.survivabilityConfig)
        ? Cluster_SurvivabilityConfig.fromJSON(object.survivabilityConfig)
        : undefined,
      externalLoadBalancerIpv6AddressPools: globalThis.Array.isArray(object?.externalLoadBalancerIpv6AddressPools)
        ? object.externalLoadBalancerIpv6AddressPools.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.fleet !== undefined) {
      obj.fleet = Fleet.toJSON(message.fleet);
    }
    if (message.networking !== undefined) {
      obj.networking = ClusterNetworking.toJSON(message.networking);
    }
    if (message.authorization !== undefined) {
      obj.authorization = Authorization.toJSON(message.authorization);
    }
    if (message.defaultMaxPodsPerNode !== 0) {
      obj.defaultMaxPodsPerNode = Math.round(message.defaultMaxPodsPerNode);
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.clusterCaCertificate !== "") {
      obj.clusterCaCertificate = message.clusterCaCertificate;
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.controlPlaneVersion !== "") {
      obj.controlPlaneVersion = message.controlPlaneVersion;
    }
    if (message.nodeVersion !== "") {
      obj.nodeVersion = message.nodeVersion;
    }
    if (message.controlPlane !== undefined) {
      obj.controlPlane = Cluster_ControlPlane.toJSON(message.controlPlane);
    }
    if (message.systemAddonsConfig !== undefined) {
      obj.systemAddonsConfig = Cluster_SystemAddonsConfig.toJSON(message.systemAddonsConfig);
    }
    if (message.externalLoadBalancerIpv4AddressPools?.length) {
      obj.externalLoadBalancerIpv4AddressPools = message.externalLoadBalancerIpv4AddressPools;
    }
    if (message.controlPlaneEncryption !== undefined) {
      obj.controlPlaneEncryption = Cluster_ControlPlaneEncryption.toJSON(message.controlPlaneEncryption);
    }
    if (message.status !== 0) {
      obj.status = cluster_StatusToJSON(message.status);
    }
    if (message.maintenanceEvents?.length) {
      obj.maintenanceEvents = message.maintenanceEvents.map((e) => Cluster_MaintenanceEvent.toJSON(e));
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    if (message.releaseChannel !== 0) {
      obj.releaseChannel = cluster_ReleaseChannelToJSON(message.releaseChannel);
    }
    if (message.survivabilityConfig !== undefined) {
      obj.survivabilityConfig = Cluster_SurvivabilityConfig.toJSON(message.survivabilityConfig);
    }
    if (message.externalLoadBalancerIpv6AddressPools?.length) {
      obj.externalLoadBalancerIpv6AddressPools = message.externalLoadBalancerIpv6AddressPools;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster>): Cluster {
    return Cluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster>): Cluster {
    const message = createBaseCluster();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.fleet = (object.fleet !== undefined && object.fleet !== null) ? Fleet.fromPartial(object.fleet) : undefined;
    message.networking = (object.networking !== undefined && object.networking !== null)
      ? ClusterNetworking.fromPartial(object.networking)
      : undefined;
    message.authorization = (object.authorization !== undefined && object.authorization !== null)
      ? Authorization.fromPartial(object.authorization)
      : undefined;
    message.defaultMaxPodsPerNode = object.defaultMaxPodsPerNode ?? 0;
    message.endpoint = object.endpoint ?? "";
    message.port = object.port ?? 0;
    message.clusterCaCertificate = object.clusterCaCertificate ?? "";
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.controlPlaneVersion = object.controlPlaneVersion ?? "";
    message.nodeVersion = object.nodeVersion ?? "";
    message.controlPlane = (object.controlPlane !== undefined && object.controlPlane !== null)
      ? Cluster_ControlPlane.fromPartial(object.controlPlane)
      : undefined;
    message.systemAddonsConfig = (object.systemAddonsConfig !== undefined && object.systemAddonsConfig !== null)
      ? Cluster_SystemAddonsConfig.fromPartial(object.systemAddonsConfig)
      : undefined;
    message.externalLoadBalancerIpv4AddressPools = object.externalLoadBalancerIpv4AddressPools?.map((e) => e) || [];
    message.controlPlaneEncryption =
      (object.controlPlaneEncryption !== undefined && object.controlPlaneEncryption !== null)
        ? Cluster_ControlPlaneEncryption.fromPartial(object.controlPlaneEncryption)
        : undefined;
    message.status = object.status ?? 0;
    message.maintenanceEvents = object.maintenanceEvents?.map((e) => Cluster_MaintenanceEvent.fromPartial(e)) || [];
    message.targetVersion = object.targetVersion ?? "";
    message.releaseChannel = object.releaseChannel ?? 0;
    message.survivabilityConfig = (object.survivabilityConfig !== undefined && object.survivabilityConfig !== null)
      ? Cluster_SurvivabilityConfig.fromPartial(object.survivabilityConfig)
      : undefined;
    message.externalLoadBalancerIpv6AddressPools = object.externalLoadBalancerIpv6AddressPools?.map((e) => e) || [];
    return message;
  },
};

function createBaseCluster_ControlPlane(): Cluster_ControlPlane {
  return { remote: undefined, local: undefined };
}

export const Cluster_ControlPlane: MessageFns<Cluster_ControlPlane> = {
  encode(message: Cluster_ControlPlane, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remote !== undefined) {
      Cluster_ControlPlane_Remote.encode(message.remote, writer.uint32(10).fork()).join();
    }
    if (message.local !== undefined) {
      Cluster_ControlPlane_Local.encode(message.local, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ControlPlane {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ControlPlane();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.remote = Cluster_ControlPlane_Remote.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.local = Cluster_ControlPlane_Local.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_ControlPlane {
    return {
      remote: isSet(object.remote) ? Cluster_ControlPlane_Remote.fromJSON(object.remote) : undefined,
      local: isSet(object.local) ? Cluster_ControlPlane_Local.fromJSON(object.local) : undefined,
    };
  },

  toJSON(message: Cluster_ControlPlane): unknown {
    const obj: any = {};
    if (message.remote !== undefined) {
      obj.remote = Cluster_ControlPlane_Remote.toJSON(message.remote);
    }
    if (message.local !== undefined) {
      obj.local = Cluster_ControlPlane_Local.toJSON(message.local);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_ControlPlane>): Cluster_ControlPlane {
    return Cluster_ControlPlane.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_ControlPlane>): Cluster_ControlPlane {
    const message = createBaseCluster_ControlPlane();
    message.remote = (object.remote !== undefined && object.remote !== null)
      ? Cluster_ControlPlane_Remote.fromPartial(object.remote)
      : undefined;
    message.local = (object.local !== undefined && object.local !== null)
      ? Cluster_ControlPlane_Local.fromPartial(object.local)
      : undefined;
    return message;
  },
};

function createBaseCluster_ControlPlane_Remote(): Cluster_ControlPlane_Remote {
  return {};
}

export const Cluster_ControlPlane_Remote: MessageFns<Cluster_ControlPlane_Remote> = {
  encode(_: Cluster_ControlPlane_Remote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ControlPlane_Remote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ControlPlane_Remote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Cluster_ControlPlane_Remote {
    return {};
  },

  toJSON(_: Cluster_ControlPlane_Remote): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Cluster_ControlPlane_Remote>): Cluster_ControlPlane_Remote {
    return Cluster_ControlPlane_Remote.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Cluster_ControlPlane_Remote>): Cluster_ControlPlane_Remote {
    const message = createBaseCluster_ControlPlane_Remote();
    return message;
  },
};

function createBaseCluster_ControlPlane_Local(): Cluster_ControlPlane_Local {
  return { nodeLocation: "", nodeCount: 0, machineFilter: "", sharedDeploymentPolicy: 0 };
}

export const Cluster_ControlPlane_Local: MessageFns<Cluster_ControlPlane_Local> = {
  encode(message: Cluster_ControlPlane_Local, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeLocation !== "") {
      writer.uint32(10).string(message.nodeLocation);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(16).int32(message.nodeCount);
    }
    if (message.machineFilter !== "") {
      writer.uint32(26).string(message.machineFilter);
    }
    if (message.sharedDeploymentPolicy !== 0) {
      writer.uint32(32).int32(message.sharedDeploymentPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ControlPlane_Local {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ControlPlane_Local();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeLocation = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machineFilter = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sharedDeploymentPolicy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_ControlPlane_Local {
    return {
      nodeLocation: isSet(object.nodeLocation) ? globalThis.String(object.nodeLocation) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      machineFilter: isSet(object.machineFilter) ? globalThis.String(object.machineFilter) : "",
      sharedDeploymentPolicy: isSet(object.sharedDeploymentPolicy)
        ? cluster_ControlPlane_SharedDeploymentPolicyFromJSON(object.sharedDeploymentPolicy)
        : 0,
    };
  },

  toJSON(message: Cluster_ControlPlane_Local): unknown {
    const obj: any = {};
    if (message.nodeLocation !== "") {
      obj.nodeLocation = message.nodeLocation;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.machineFilter !== "") {
      obj.machineFilter = message.machineFilter;
    }
    if (message.sharedDeploymentPolicy !== 0) {
      obj.sharedDeploymentPolicy = cluster_ControlPlane_SharedDeploymentPolicyToJSON(message.sharedDeploymentPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_ControlPlane_Local>): Cluster_ControlPlane_Local {
    return Cluster_ControlPlane_Local.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_ControlPlane_Local>): Cluster_ControlPlane_Local {
    const message = createBaseCluster_ControlPlane_Local();
    message.nodeLocation = object.nodeLocation ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.machineFilter = object.machineFilter ?? "";
    message.sharedDeploymentPolicy = object.sharedDeploymentPolicy ?? 0;
    return message;
  },
};

function createBaseCluster_SystemAddonsConfig(): Cluster_SystemAddonsConfig {
  return { ingress: undefined };
}

export const Cluster_SystemAddonsConfig: MessageFns<Cluster_SystemAddonsConfig> = {
  encode(message: Cluster_SystemAddonsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ingress !== undefined) {
      Cluster_SystemAddonsConfig_Ingress.encode(message.ingress, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_SystemAddonsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_SystemAddonsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingress = Cluster_SystemAddonsConfig_Ingress.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_SystemAddonsConfig {
    return { ingress: isSet(object.ingress) ? Cluster_SystemAddonsConfig_Ingress.fromJSON(object.ingress) : undefined };
  },

  toJSON(message: Cluster_SystemAddonsConfig): unknown {
    const obj: any = {};
    if (message.ingress !== undefined) {
      obj.ingress = Cluster_SystemAddonsConfig_Ingress.toJSON(message.ingress);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_SystemAddonsConfig>): Cluster_SystemAddonsConfig {
    return Cluster_SystemAddonsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_SystemAddonsConfig>): Cluster_SystemAddonsConfig {
    const message = createBaseCluster_SystemAddonsConfig();
    message.ingress = (object.ingress !== undefined && object.ingress !== null)
      ? Cluster_SystemAddonsConfig_Ingress.fromPartial(object.ingress)
      : undefined;
    return message;
  },
};

function createBaseCluster_SystemAddonsConfig_Ingress(): Cluster_SystemAddonsConfig_Ingress {
  return { disabled: false, ipv4Vip: "" };
}

export const Cluster_SystemAddonsConfig_Ingress: MessageFns<Cluster_SystemAddonsConfig_Ingress> = {
  encode(message: Cluster_SystemAddonsConfig_Ingress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    if (message.ipv4Vip !== "") {
      writer.uint32(18).string(message.ipv4Vip);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_SystemAddonsConfig_Ingress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_SystemAddonsConfig_Ingress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipv4Vip = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_SystemAddonsConfig_Ingress {
    return {
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      ipv4Vip: isSet(object.ipv4Vip) ? globalThis.String(object.ipv4Vip) : "",
    };
  },

  toJSON(message: Cluster_SystemAddonsConfig_Ingress): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.ipv4Vip !== "") {
      obj.ipv4Vip = message.ipv4Vip;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_SystemAddonsConfig_Ingress>): Cluster_SystemAddonsConfig_Ingress {
    return Cluster_SystemAddonsConfig_Ingress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_SystemAddonsConfig_Ingress>): Cluster_SystemAddonsConfig_Ingress {
    const message = createBaseCluster_SystemAddonsConfig_Ingress();
    message.disabled = object.disabled ?? false;
    message.ipv4Vip = object.ipv4Vip ?? "";
    return message;
  },
};

function createBaseCluster_ControlPlaneEncryption(): Cluster_ControlPlaneEncryption {
  return { kmsKey: "", kmsKeyActiveVersion: "", kmsKeyState: 0, kmsStatus: undefined };
}

export const Cluster_ControlPlaneEncryption: MessageFns<Cluster_ControlPlaneEncryption> = {
  encode(message: Cluster_ControlPlaneEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKey !== "") {
      writer.uint32(10).string(message.kmsKey);
    }
    if (message.kmsKeyActiveVersion !== "") {
      writer.uint32(18).string(message.kmsKeyActiveVersion);
    }
    if (message.kmsKeyState !== 0) {
      writer.uint32(24).int32(message.kmsKeyState);
    }
    if (message.kmsStatus !== undefined) {
      Status.encode(message.kmsStatus, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ControlPlaneEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ControlPlaneEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kmsKeyActiveVersion = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kmsKeyState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kmsStatus = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_ControlPlaneEncryption {
    return {
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      kmsKeyActiveVersion: isSet(object.kmsKeyActiveVersion) ? globalThis.String(object.kmsKeyActiveVersion) : "",
      kmsKeyState: isSet(object.kmsKeyState) ? kmsKeyStateFromJSON(object.kmsKeyState) : 0,
      kmsStatus: isSet(object.kmsStatus) ? Status.fromJSON(object.kmsStatus) : undefined,
    };
  },

  toJSON(message: Cluster_ControlPlaneEncryption): unknown {
    const obj: any = {};
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.kmsKeyActiveVersion !== "") {
      obj.kmsKeyActiveVersion = message.kmsKeyActiveVersion;
    }
    if (message.kmsKeyState !== 0) {
      obj.kmsKeyState = kmsKeyStateToJSON(message.kmsKeyState);
    }
    if (message.kmsStatus !== undefined) {
      obj.kmsStatus = Status.toJSON(message.kmsStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_ControlPlaneEncryption>): Cluster_ControlPlaneEncryption {
    return Cluster_ControlPlaneEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_ControlPlaneEncryption>): Cluster_ControlPlaneEncryption {
    const message = createBaseCluster_ControlPlaneEncryption();
    message.kmsKey = object.kmsKey ?? "";
    message.kmsKeyActiveVersion = object.kmsKeyActiveVersion ?? "";
    message.kmsKeyState = object.kmsKeyState ?? 0;
    message.kmsStatus = (object.kmsStatus !== undefined && object.kmsStatus !== null)
      ? Status.fromPartial(object.kmsStatus)
      : undefined;
    return message;
  },
};

function createBaseCluster_MaintenanceEvent(): Cluster_MaintenanceEvent {
  return {
    uuid: "",
    targetVersion: "",
    operation: "",
    type: 0,
    schedule: 0,
    state: 0,
    createTime: undefined,
    startTime: undefined,
    endTime: undefined,
    updateTime: undefined,
  };
}

export const Cluster_MaintenanceEvent: MessageFns<Cluster_MaintenanceEvent> = {
  encode(message: Cluster_MaintenanceEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.targetVersion !== "") {
      writer.uint32(18).string(message.targetVersion);
    }
    if (message.operation !== "") {
      writer.uint32(26).string(message.operation);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.schedule !== 0) {
      writer.uint32(40).int32(message.schedule);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(66).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_MaintenanceEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_MaintenanceEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.schedule = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_MaintenanceEvent {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      type: isSet(object.type) ? cluster_MaintenanceEvent_TypeFromJSON(object.type) : 0,
      schedule: isSet(object.schedule) ? cluster_MaintenanceEvent_ScheduleFromJSON(object.schedule) : 0,
      state: isSet(object.state) ? cluster_MaintenanceEvent_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Cluster_MaintenanceEvent): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.type !== 0) {
      obj.type = cluster_MaintenanceEvent_TypeToJSON(message.type);
    }
    if (message.schedule !== 0) {
      obj.schedule = cluster_MaintenanceEvent_ScheduleToJSON(message.schedule);
    }
    if (message.state !== 0) {
      obj.state = cluster_MaintenanceEvent_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_MaintenanceEvent>): Cluster_MaintenanceEvent {
    return Cluster_MaintenanceEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_MaintenanceEvent>): Cluster_MaintenanceEvent {
    const message = createBaseCluster_MaintenanceEvent();
    message.uuid = object.uuid ?? "";
    message.targetVersion = object.targetVersion ?? "";
    message.operation = object.operation ?? "";
    message.type = object.type ?? 0;
    message.schedule = object.schedule ?? 0;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseCluster_SurvivabilityConfig(): Cluster_SurvivabilityConfig {
  return { offlineRebootTtl: undefined };
}

export const Cluster_SurvivabilityConfig: MessageFns<Cluster_SurvivabilityConfig> = {
  encode(message: Cluster_SurvivabilityConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offlineRebootTtl !== undefined) {
      Duration.encode(message.offlineRebootTtl, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_SurvivabilityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_SurvivabilityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offlineRebootTtl = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_SurvivabilityConfig {
    return {
      offlineRebootTtl: isSet(object.offlineRebootTtl) ? Duration.fromJSON(object.offlineRebootTtl) : undefined,
    };
  },

  toJSON(message: Cluster_SurvivabilityConfig): unknown {
    const obj: any = {};
    if (message.offlineRebootTtl !== undefined) {
      obj.offlineRebootTtl = Duration.toJSON(message.offlineRebootTtl);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_SurvivabilityConfig>): Cluster_SurvivabilityConfig {
    return Cluster_SurvivabilityConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_SurvivabilityConfig>): Cluster_SurvivabilityConfig {
    const message = createBaseCluster_SurvivabilityConfig();
    message.offlineRebootTtl = (object.offlineRebootTtl !== undefined && object.offlineRebootTtl !== null)
      ? Duration.fromPartial(object.offlineRebootTtl)
      : undefined;
    return message;
  },
};

function createBaseCluster_LabelsEntry(): Cluster_LabelsEntry {
  return { key: "", value: "" };
}

export const Cluster_LabelsEntry: MessageFns<Cluster_LabelsEntry> = {
  encode(message: Cluster_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Cluster_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_LabelsEntry>): Cluster_LabelsEntry {
    return Cluster_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_LabelsEntry>): Cluster_LabelsEntry {
    const message = createBaseCluster_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClusterNetworking(): ClusterNetworking {
  return { clusterIpv4CidrBlocks: [], servicesIpv4CidrBlocks: [] };
}

export const ClusterNetworking: MessageFns<ClusterNetworking> = {
  encode(message: ClusterNetworking, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clusterIpv4CidrBlocks) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.servicesIpv4CidrBlocks) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterNetworking {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterNetworking();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusterIpv4CidrBlocks.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.servicesIpv4CidrBlocks.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterNetworking {
    return {
      clusterIpv4CidrBlocks: globalThis.Array.isArray(object?.clusterIpv4CidrBlocks)
        ? object.clusterIpv4CidrBlocks.map((e: any) => globalThis.String(e))
        : [],
      servicesIpv4CidrBlocks: globalThis.Array.isArray(object?.servicesIpv4CidrBlocks)
        ? object.servicesIpv4CidrBlocks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ClusterNetworking): unknown {
    const obj: any = {};
    if (message.clusterIpv4CidrBlocks?.length) {
      obj.clusterIpv4CidrBlocks = message.clusterIpv4CidrBlocks;
    }
    if (message.servicesIpv4CidrBlocks?.length) {
      obj.servicesIpv4CidrBlocks = message.servicesIpv4CidrBlocks;
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterNetworking>): ClusterNetworking {
    return ClusterNetworking.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterNetworking>): ClusterNetworking {
    const message = createBaseClusterNetworking();
    message.clusterIpv4CidrBlocks = object.clusterIpv4CidrBlocks?.map((e) => e) || [];
    message.servicesIpv4CidrBlocks = object.servicesIpv4CidrBlocks?.map((e) => e) || [];
    return message;
  },
};

function createBaseFleet(): Fleet {
  return { project: "", membership: "" };
}

export const Fleet: MessageFns<Fleet> = {
  encode(message: Fleet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.membership !== "") {
      writer.uint32(18).string(message.membership);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fleet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFleet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membership = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fleet {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      membership: isSet(object.membership) ? globalThis.String(object.membership) : "",
    };
  },

  toJSON(message: Fleet): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.membership !== "") {
      obj.membership = message.membership;
    }
    return obj;
  },

  create(base?: DeepPartial<Fleet>): Fleet {
    return Fleet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fleet>): Fleet {
    const message = createBaseFleet();
    message.project = object.project ?? "";
    message.membership = object.membership ?? "";
    return message;
  },
};

function createBaseClusterUser(): ClusterUser {
  return { username: "" };
}

export const ClusterUser: MessageFns<ClusterUser> = {
  encode(message: ClusterUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterUser {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: ClusterUser): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterUser>): ClusterUser {
    return ClusterUser.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterUser>): ClusterUser {
    const message = createBaseClusterUser();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthorization(): Authorization {
  return { adminUsers: undefined };
}

export const Authorization: MessageFns<Authorization> = {
  encode(message: Authorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adminUsers !== undefined) {
      ClusterUser.encode(message.adminUsers, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adminUsers = ClusterUser.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authorization {
    return { adminUsers: isSet(object.adminUsers) ? ClusterUser.fromJSON(object.adminUsers) : undefined };
  },

  toJSON(message: Authorization): unknown {
    const obj: any = {};
    if (message.adminUsers !== undefined) {
      obj.adminUsers = ClusterUser.toJSON(message.adminUsers);
    }
    return obj;
  },

  create(base?: DeepPartial<Authorization>): Authorization {
    return Authorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authorization>): Authorization {
    const message = createBaseAuthorization();
    message.adminUsers = (object.adminUsers !== undefined && object.adminUsers !== null)
      ? ClusterUser.fromPartial(object.adminUsers)
      : undefined;
    return message;
  },
};

function createBaseNodePool(): NodePool {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    nodeLocation: "",
    nodeCount: 0,
    machineFilter: "",
    localDiskEncryption: undefined,
    nodeVersion: "",
    nodeConfig: undefined,
  };
}

export const NodePool: MessageFns<NodePool> = {
  encode(message: NodePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NodePool_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.nodeLocation !== "") {
      writer.uint32(66).string(message.nodeLocation);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(48).int32(message.nodeCount);
    }
    if (message.machineFilter !== "") {
      writer.uint32(58).string(message.machineFilter);
    }
    if (message.localDiskEncryption !== undefined) {
      NodePool_LocalDiskEncryption.encode(message.localDiskEncryption, writer.uint32(74).fork()).join();
    }
    if (message.nodeVersion !== "") {
      writer.uint32(82).string(message.nodeVersion);
    }
    if (message.nodeConfig !== undefined) {
      NodePool_NodeConfig.encode(message.nodeConfig, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = NodePool_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nodeLocation = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.machineFilter = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.localDiskEncryption = NodePool_LocalDiskEncryption.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nodeVersion = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.nodeConfig = NodePool_NodeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      nodeLocation: isSet(object.nodeLocation) ? globalThis.String(object.nodeLocation) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      machineFilter: isSet(object.machineFilter) ? globalThis.String(object.machineFilter) : "",
      localDiskEncryption: isSet(object.localDiskEncryption)
        ? NodePool_LocalDiskEncryption.fromJSON(object.localDiskEncryption)
        : undefined,
      nodeVersion: isSet(object.nodeVersion) ? globalThis.String(object.nodeVersion) : "",
      nodeConfig: isSet(object.nodeConfig) ? NodePool_NodeConfig.fromJSON(object.nodeConfig) : undefined,
    };
  },

  toJSON(message: NodePool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.nodeLocation !== "") {
      obj.nodeLocation = message.nodeLocation;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.machineFilter !== "") {
      obj.machineFilter = message.machineFilter;
    }
    if (message.localDiskEncryption !== undefined) {
      obj.localDiskEncryption = NodePool_LocalDiskEncryption.toJSON(message.localDiskEncryption);
    }
    if (message.nodeVersion !== "") {
      obj.nodeVersion = message.nodeVersion;
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodePool_NodeConfig.toJSON(message.nodeConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool>): NodePool {
    return NodePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool>): NodePool {
    const message = createBaseNodePool();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.nodeLocation = object.nodeLocation ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.machineFilter = object.machineFilter ?? "";
    message.localDiskEncryption = (object.localDiskEncryption !== undefined && object.localDiskEncryption !== null)
      ? NodePool_LocalDiskEncryption.fromPartial(object.localDiskEncryption)
      : undefined;
    message.nodeVersion = object.nodeVersion ?? "";
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodePool_NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    return message;
  },
};

function createBaseNodePool_LocalDiskEncryption(): NodePool_LocalDiskEncryption {
  return { kmsKey: "", kmsKeyActiveVersion: "", kmsKeyState: 0, kmsStatus: undefined };
}

export const NodePool_LocalDiskEncryption: MessageFns<NodePool_LocalDiskEncryption> = {
  encode(message: NodePool_LocalDiskEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKey !== "") {
      writer.uint32(10).string(message.kmsKey);
    }
    if (message.kmsKeyActiveVersion !== "") {
      writer.uint32(18).string(message.kmsKeyActiveVersion);
    }
    if (message.kmsKeyState !== 0) {
      writer.uint32(24).int32(message.kmsKeyState);
    }
    if (message.kmsStatus !== undefined) {
      Status.encode(message.kmsStatus, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_LocalDiskEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_LocalDiskEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kmsKeyActiveVersion = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.kmsKeyState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kmsStatus = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_LocalDiskEncryption {
    return {
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      kmsKeyActiveVersion: isSet(object.kmsKeyActiveVersion) ? globalThis.String(object.kmsKeyActiveVersion) : "",
      kmsKeyState: isSet(object.kmsKeyState) ? kmsKeyStateFromJSON(object.kmsKeyState) : 0,
      kmsStatus: isSet(object.kmsStatus) ? Status.fromJSON(object.kmsStatus) : undefined,
    };
  },

  toJSON(message: NodePool_LocalDiskEncryption): unknown {
    const obj: any = {};
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.kmsKeyActiveVersion !== "") {
      obj.kmsKeyActiveVersion = message.kmsKeyActiveVersion;
    }
    if (message.kmsKeyState !== 0) {
      obj.kmsKeyState = kmsKeyStateToJSON(message.kmsKeyState);
    }
    if (message.kmsStatus !== undefined) {
      obj.kmsStatus = Status.toJSON(message.kmsStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_LocalDiskEncryption>): NodePool_LocalDiskEncryption {
    return NodePool_LocalDiskEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_LocalDiskEncryption>): NodePool_LocalDiskEncryption {
    const message = createBaseNodePool_LocalDiskEncryption();
    message.kmsKey = object.kmsKey ?? "";
    message.kmsKeyActiveVersion = object.kmsKeyActiveVersion ?? "";
    message.kmsKeyState = object.kmsKeyState ?? 0;
    message.kmsStatus = (object.kmsStatus !== undefined && object.kmsStatus !== null)
      ? Status.fromPartial(object.kmsStatus)
      : undefined;
    return message;
  },
};

function createBaseNodePool_NodeConfig(): NodePool_NodeConfig {
  return { labels: {} };
}

export const NodePool_NodeConfig: MessageFns<NodePool_NodeConfig> = {
  encode(message: NodePool_NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      NodePool_NodeConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_NodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = NodePool_NodeConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_NodeConfig {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NodePool_NodeConfig): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_NodeConfig>): NodePool_NodeConfig {
    return NodePool_NodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_NodeConfig>): NodePool_NodeConfig {
    const message = createBaseNodePool_NodeConfig();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseNodePool_NodeConfig_LabelsEntry(): NodePool_NodeConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const NodePool_NodeConfig_LabelsEntry: MessageFns<NodePool_NodeConfig_LabelsEntry> = {
  encode(message: NodePool_NodeConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_NodeConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_NodeConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_NodeConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodePool_NodeConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_NodeConfig_LabelsEntry>): NodePool_NodeConfig_LabelsEntry {
    return NodePool_NodeConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_NodeConfig_LabelsEntry>): NodePool_NodeConfig_LabelsEntry {
    const message = createBaseNodePool_NodeConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodePool_LabelsEntry(): NodePool_LabelsEntry {
  return { key: "", value: "" };
}

export const NodePool_LabelsEntry: MessageFns<NodePool_LabelsEntry> = {
  encode(message: NodePool_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodePool_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_LabelsEntry>): NodePool_LabelsEntry {
    return NodePool_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_LabelsEntry>): NodePool_LabelsEntry {
    const message = createBaseNodePool_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMachine(): Machine {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    hostedNode: "",
    zone: "",
    version: "",
    disabled: false,
  };
}

export const Machine: MessageFns<Machine> = {
  encode(message: Machine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Machine_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hostedNode !== "") {
      writer.uint32(42).string(message.hostedNode);
    }
    if (message.zone !== "") {
      writer.uint32(50).string(message.zone);
    }
    if (message.version !== "") {
      writer.uint32(58).string(message.version);
    }
    if (message.disabled !== false) {
      writer.uint32(64).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Machine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Machine_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostedNode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.version = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Machine {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      hostedNode: isSet(object.hostedNode) ? globalThis.String(object.hostedNode) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: Machine): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.hostedNode !== "") {
      obj.hostedNode = message.hostedNode;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<Machine>): Machine {
    return Machine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Machine>): Machine {
    const message = createBaseMachine();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.hostedNode = object.hostedNode ?? "";
    message.zone = object.zone ?? "";
    message.version = object.version ?? "";
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseMachine_LabelsEntry(): Machine_LabelsEntry {
  return { key: "", value: "" };
}

export const Machine_LabelsEntry: MessageFns<Machine_LabelsEntry> = {
  encode(message: Machine_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Machine_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMachine_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Machine_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Machine_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Machine_LabelsEntry>): Machine_LabelsEntry {
    return Machine_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Machine_LabelsEntry>): Machine_LabelsEntry {
    const message = createBaseMachine_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVpnConnection(): VpnConnection {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    natGatewayIp: "",
    bgpRoutingMode: 0,
    cluster: "",
    vpc: "",
    vpcProject: undefined,
    enableHighAvailability: false,
    router: "",
    details: undefined,
  };
}

export const VpnConnection: MessageFns<VpnConnection> = {
  encode(message: VpnConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      VpnConnection_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.natGatewayIp !== "") {
      writer.uint32(42).string(message.natGatewayIp);
    }
    if (message.bgpRoutingMode !== 0) {
      writer.uint32(48).int32(message.bgpRoutingMode);
    }
    if (message.cluster !== "") {
      writer.uint32(58).string(message.cluster);
    }
    if (message.vpc !== "") {
      writer.uint32(66).string(message.vpc);
    }
    if (message.vpcProject !== undefined) {
      VpnConnection_VpcProject.encode(message.vpcProject, writer.uint32(90).fork()).join();
    }
    if (message.enableHighAvailability !== false) {
      writer.uint32(72).bool(message.enableHighAvailability);
    }
    if (message.router !== "") {
      writer.uint32(98).string(message.router);
    }
    if (message.details !== undefined) {
      VpnConnection_Details.encode(message.details, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = VpnConnection_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.natGatewayIp = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.bgpRoutingMode = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vpc = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.vpcProject = VpnConnection_VpcProject.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enableHighAvailability = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.router = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.details = VpnConnection_Details.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      natGatewayIp: isSet(object.natGatewayIp) ? globalThis.String(object.natGatewayIp) : "",
      bgpRoutingMode: isSet(object.bgpRoutingMode) ? vpnConnection_BgpRoutingModeFromJSON(object.bgpRoutingMode) : 0,
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      vpc: isSet(object.vpc) ? globalThis.String(object.vpc) : "",
      vpcProject: isSet(object.vpcProject) ? VpnConnection_VpcProject.fromJSON(object.vpcProject) : undefined,
      enableHighAvailability: isSet(object.enableHighAvailability)
        ? globalThis.Boolean(object.enableHighAvailability)
        : false,
      router: isSet(object.router) ? globalThis.String(object.router) : "",
      details: isSet(object.details) ? VpnConnection_Details.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: VpnConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.natGatewayIp !== "") {
      obj.natGatewayIp = message.natGatewayIp;
    }
    if (message.bgpRoutingMode !== 0) {
      obj.bgpRoutingMode = vpnConnection_BgpRoutingModeToJSON(message.bgpRoutingMode);
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.vpc !== "") {
      obj.vpc = message.vpc;
    }
    if (message.vpcProject !== undefined) {
      obj.vpcProject = VpnConnection_VpcProject.toJSON(message.vpcProject);
    }
    if (message.enableHighAvailability !== false) {
      obj.enableHighAvailability = message.enableHighAvailability;
    }
    if (message.router !== "") {
      obj.router = message.router;
    }
    if (message.details !== undefined) {
      obj.details = VpnConnection_Details.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection>): VpnConnection {
    return VpnConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection>): VpnConnection {
    const message = createBaseVpnConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.natGatewayIp = object.natGatewayIp ?? "";
    message.bgpRoutingMode = object.bgpRoutingMode ?? 0;
    message.cluster = object.cluster ?? "";
    message.vpc = object.vpc ?? "";
    message.vpcProject = (object.vpcProject !== undefined && object.vpcProject !== null)
      ? VpnConnection_VpcProject.fromPartial(object.vpcProject)
      : undefined;
    message.enableHighAvailability = object.enableHighAvailability ?? false;
    message.router = object.router ?? "";
    message.details = (object.details !== undefined && object.details !== null)
      ? VpnConnection_Details.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseVpnConnection_VpcProject(): VpnConnection_VpcProject {
  return { projectId: "", serviceAccount: "" };
}

export const VpnConnection_VpcProject: MessageFns<VpnConnection_VpcProject> = {
  encode(message: VpnConnection_VpcProject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection_VpcProject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection_VpcProject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection_VpcProject {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
    };
  },

  toJSON(message: VpnConnection_VpcProject): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection_VpcProject>): VpnConnection_VpcProject {
    return VpnConnection_VpcProject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection_VpcProject>): VpnConnection_VpcProject {
    const message = createBaseVpnConnection_VpcProject();
    message.projectId = object.projectId ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    return message;
  },
};

function createBaseVpnConnection_Details(): VpnConnection_Details {
  return { state: 0, error: "", cloudRouter: undefined, cloudVpns: [] };
}

export const VpnConnection_Details: MessageFns<VpnConnection_Details> = {
  encode(message: VpnConnection_Details, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.cloudRouter !== undefined) {
      VpnConnection_Details_CloudRouter.encode(message.cloudRouter, writer.uint32(26).fork()).join();
    }
    for (const v of message.cloudVpns) {
      VpnConnection_Details_CloudVpn.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection_Details {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection_Details();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudRouter = VpnConnection_Details_CloudRouter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cloudVpns.push(VpnConnection_Details_CloudVpn.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection_Details {
    return {
      state: isSet(object.state) ? vpnConnection_Details_StateFromJSON(object.state) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      cloudRouter: isSet(object.cloudRouter)
        ? VpnConnection_Details_CloudRouter.fromJSON(object.cloudRouter)
        : undefined,
      cloudVpns: globalThis.Array.isArray(object?.cloudVpns)
        ? object.cloudVpns.map((e: any) => VpnConnection_Details_CloudVpn.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VpnConnection_Details): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = vpnConnection_Details_StateToJSON(message.state);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.cloudRouter !== undefined) {
      obj.cloudRouter = VpnConnection_Details_CloudRouter.toJSON(message.cloudRouter);
    }
    if (message.cloudVpns?.length) {
      obj.cloudVpns = message.cloudVpns.map((e) => VpnConnection_Details_CloudVpn.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection_Details>): VpnConnection_Details {
    return VpnConnection_Details.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection_Details>): VpnConnection_Details {
    const message = createBaseVpnConnection_Details();
    message.state = object.state ?? 0;
    message.error = object.error ?? "";
    message.cloudRouter = (object.cloudRouter !== undefined && object.cloudRouter !== null)
      ? VpnConnection_Details_CloudRouter.fromPartial(object.cloudRouter)
      : undefined;
    message.cloudVpns = object.cloudVpns?.map((e) => VpnConnection_Details_CloudVpn.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVpnConnection_Details_CloudRouter(): VpnConnection_Details_CloudRouter {
  return { name: "" };
}

export const VpnConnection_Details_CloudRouter: MessageFns<VpnConnection_Details_CloudRouter> = {
  encode(message: VpnConnection_Details_CloudRouter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection_Details_CloudRouter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection_Details_CloudRouter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection_Details_CloudRouter {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: VpnConnection_Details_CloudRouter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection_Details_CloudRouter>): VpnConnection_Details_CloudRouter {
    return VpnConnection_Details_CloudRouter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection_Details_CloudRouter>): VpnConnection_Details_CloudRouter {
    const message = createBaseVpnConnection_Details_CloudRouter();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseVpnConnection_Details_CloudVpn(): VpnConnection_Details_CloudVpn {
  return { gateway: "" };
}

export const VpnConnection_Details_CloudVpn: MessageFns<VpnConnection_Details_CloudVpn> = {
  encode(message: VpnConnection_Details_CloudVpn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gateway !== "") {
      writer.uint32(10).string(message.gateway);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection_Details_CloudVpn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection_Details_CloudVpn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gateway = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection_Details_CloudVpn {
    return { gateway: isSet(object.gateway) ? globalThis.String(object.gateway) : "" };
  },

  toJSON(message: VpnConnection_Details_CloudVpn): unknown {
    const obj: any = {};
    if (message.gateway !== "") {
      obj.gateway = message.gateway;
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection_Details_CloudVpn>): VpnConnection_Details_CloudVpn {
    return VpnConnection_Details_CloudVpn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection_Details_CloudVpn>): VpnConnection_Details_CloudVpn {
    const message = createBaseVpnConnection_Details_CloudVpn();
    message.gateway = object.gateway ?? "";
    return message;
  },
};

function createBaseVpnConnection_LabelsEntry(): VpnConnection_LabelsEntry {
  return { key: "", value: "" };
}

export const VpnConnection_LabelsEntry: MessageFns<VpnConnection_LabelsEntry> = {
  encode(message: VpnConnection_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpnConnection_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpnConnection_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpnConnection_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VpnConnection_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VpnConnection_LabelsEntry>): VpnConnection_LabelsEntry {
    return VpnConnection_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpnConnection_LabelsEntry>): VpnConnection_LabelsEntry {
    const message = createBaseVpnConnection_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseLocationMetadata(): LocationMetadata {
  return { availableZones: {} };
}

export const LocationMetadata: MessageFns<LocationMetadata> = {
  encode(message: LocationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.availableZones).forEach(([key, value]) => {
      LocationMetadata_AvailableZonesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = LocationMetadata_AvailableZonesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.availableZones[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationMetadata {
    return {
      availableZones: isObject(object.availableZones)
        ? Object.entries(object.availableZones).reduce<{ [key: string]: ZoneMetadata }>((acc, [key, value]) => {
          acc[key] = ZoneMetadata.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LocationMetadata): unknown {
    const obj: any = {};
    if (message.availableZones) {
      const entries = Object.entries(message.availableZones);
      if (entries.length > 0) {
        obj.availableZones = {};
        entries.forEach(([k, v]) => {
          obj.availableZones[k] = ZoneMetadata.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<LocationMetadata>): LocationMetadata {
    return LocationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationMetadata>): LocationMetadata {
    const message = createBaseLocationMetadata();
    message.availableZones = Object.entries(object.availableZones ?? {}).reduce<{ [key: string]: ZoneMetadata }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ZoneMetadata.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLocationMetadata_AvailableZonesEntry(): LocationMetadata_AvailableZonesEntry {
  return { key: "", value: undefined };
}

export const LocationMetadata_AvailableZonesEntry: MessageFns<LocationMetadata_AvailableZonesEntry> = {
  encode(message: LocationMetadata_AvailableZonesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ZoneMetadata.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationMetadata_AvailableZonesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationMetadata_AvailableZonesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ZoneMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationMetadata_AvailableZonesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ZoneMetadata.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: LocationMetadata_AvailableZonesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ZoneMetadata.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationMetadata_AvailableZonesEntry>): LocationMetadata_AvailableZonesEntry {
    return LocationMetadata_AvailableZonesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationMetadata_AvailableZonesEntry>): LocationMetadata_AvailableZonesEntry {
    const message = createBaseLocationMetadata_AvailableZonesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ZoneMetadata.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseZoneMetadata(): ZoneMetadata {
  return { quota: [], rackTypes: {} };
}

export const ZoneMetadata: MessageFns<ZoneMetadata> = {
  encode(message: ZoneMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.quota) {
      Quota.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.rackTypes).forEach(([key, value]) => {
      ZoneMetadata_RackTypesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZoneMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoneMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.quota.push(Quota.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = ZoneMetadata_RackTypesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.rackTypes[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoneMetadata {
    return {
      quota: globalThis.Array.isArray(object?.quota) ? object.quota.map((e: any) => Quota.fromJSON(e)) : [],
      rackTypes: isObject(object.rackTypes)
        ? Object.entries(object.rackTypes).reduce<{ [key: string]: ZoneMetadata_RackType }>((acc, [key, value]) => {
          acc[key] = zoneMetadata_RackTypeFromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ZoneMetadata): unknown {
    const obj: any = {};
    if (message.quota?.length) {
      obj.quota = message.quota.map((e) => Quota.toJSON(e));
    }
    if (message.rackTypes) {
      const entries = Object.entries(message.rackTypes);
      if (entries.length > 0) {
        obj.rackTypes = {};
        entries.forEach(([k, v]) => {
          obj.rackTypes[k] = zoneMetadata_RackTypeToJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ZoneMetadata>): ZoneMetadata {
    return ZoneMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZoneMetadata>): ZoneMetadata {
    const message = createBaseZoneMetadata();
    message.quota = object.quota?.map((e) => Quota.fromPartial(e)) || [];
    message.rackTypes = Object.entries(object.rackTypes ?? {}).reduce<{ [key: string]: ZoneMetadata_RackType }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value as ZoneMetadata_RackType;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseZoneMetadata_RackTypesEntry(): ZoneMetadata_RackTypesEntry {
  return { key: "", value: 0 };
}

export const ZoneMetadata_RackTypesEntry: MessageFns<ZoneMetadata_RackTypesEntry> = {
  encode(message: ZoneMetadata_RackTypesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZoneMetadata_RackTypesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoneMetadata_RackTypesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoneMetadata_RackTypesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? zoneMetadata_RackTypeFromJSON(object.value) : 0,
    };
  },

  toJSON(message: ZoneMetadata_RackTypesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = zoneMetadata_RackTypeToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ZoneMetadata_RackTypesEntry>): ZoneMetadata_RackTypesEntry {
    return ZoneMetadata_RackTypesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZoneMetadata_RackTypesEntry>): ZoneMetadata_RackTypesEntry {
    const message = createBaseZoneMetadata_RackTypesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseQuota(): Quota {
  return { metric: "", limit: 0, usage: 0 };
}

export const Quota: MessageFns<Quota> = {
  encode(message: Quota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== "") {
      writer.uint32(10).string(message.metric);
    }
    if (message.limit !== 0) {
      writer.uint32(17).double(message.limit);
    }
    if (message.usage !== 0) {
      writer.uint32(25).double(message.usage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Quota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metric = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.limit = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.usage = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Quota {
    return {
      metric: isSet(object.metric) ? globalThis.String(object.metric) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      usage: isSet(object.usage) ? globalThis.Number(object.usage) : 0,
    };
  },

  toJSON(message: Quota): unknown {
    const obj: any = {};
    if (message.metric !== "") {
      obj.metric = message.metric;
    }
    if (message.limit !== 0) {
      obj.limit = message.limit;
    }
    if (message.usage !== 0) {
      obj.usage = message.usage;
    }
    return obj;
  },

  create(base?: DeepPartial<Quota>): Quota {
    return Quota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Quota>): Quota {
    const message = createBaseQuota();
    message.metric = object.metric ?? "";
    message.limit = object.limit ?? 0;
    message.usage = object.usage ?? 0;
    return message;
  },
};

function createBaseMaintenancePolicy(): MaintenancePolicy {
  return { window: undefined };
}

export const MaintenancePolicy: MessageFns<MaintenancePolicy> = {
  encode(message: MaintenancePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      MaintenanceWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenancePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenancePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = MaintenanceWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenancePolicy {
    return { window: isSet(object.window) ? MaintenanceWindow.fromJSON(object.window) : undefined };
  },

  toJSON(message: MaintenancePolicy): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = MaintenanceWindow.toJSON(message.window);
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    return MaintenancePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    const message = createBaseMaintenancePolicy();
    message.window = (object.window !== undefined && object.window !== null)
      ? MaintenanceWindow.fromPartial(object.window)
      : undefined;
    return message;
  },
};

function createBaseMaintenanceWindow(): MaintenanceWindow {
  return { recurringWindow: undefined };
}

export const MaintenanceWindow: MessageFns<MaintenanceWindow> = {
  encode(message: MaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recurringWindow !== undefined) {
      RecurringTimeWindow.encode(message.recurringWindow, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recurringWindow = RecurringTimeWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceWindow {
    return {
      recurringWindow: isSet(object.recurringWindow) ? RecurringTimeWindow.fromJSON(object.recurringWindow) : undefined,
    };
  },

  toJSON(message: MaintenanceWindow): unknown {
    const obj: any = {};
    if (message.recurringWindow !== undefined) {
      obj.recurringWindow = RecurringTimeWindow.toJSON(message.recurringWindow);
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    return MaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    const message = createBaseMaintenanceWindow();
    message.recurringWindow = (object.recurringWindow !== undefined && object.recurringWindow !== null)
      ? RecurringTimeWindow.fromPartial(object.recurringWindow)
      : undefined;
    return message;
  },
};

function createBaseRecurringTimeWindow(): RecurringTimeWindow {
  return { window: undefined, recurrence: "" };
}

export const RecurringTimeWindow: MessageFns<RecurringTimeWindow> = {
  encode(message: RecurringTimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      TimeWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    if (message.recurrence !== "") {
      writer.uint32(18).string(message.recurrence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurringTimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurringTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = TimeWindow.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recurrence = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecurringTimeWindow {
    return {
      window: isSet(object.window) ? TimeWindow.fromJSON(object.window) : undefined,
      recurrence: isSet(object.recurrence) ? globalThis.String(object.recurrence) : "",
    };
  },

  toJSON(message: RecurringTimeWindow): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = TimeWindow.toJSON(message.window);
    }
    if (message.recurrence !== "") {
      obj.recurrence = message.recurrence;
    }
    return obj;
  },

  create(base?: DeepPartial<RecurringTimeWindow>): RecurringTimeWindow {
    return RecurringTimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecurringTimeWindow>): RecurringTimeWindow {
    const message = createBaseRecurringTimeWindow();
    message.window = (object.window !== undefined && object.window !== null)
      ? TimeWindow.fromPartial(object.window)
      : undefined;
    message.recurrence = object.recurrence ?? "";
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return { startTime: undefined, endTime: undefined };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return { channels: {}, versions: [], defaultVersion: "" };
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.channels).forEach(([key, value]) => {
      ServerConfig_ChannelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    for (const v of message.versions) {
      Version.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.defaultVersion !== "") {
      writer.uint32(26).string(message.defaultVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ServerConfig_ChannelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.channels[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versions.push(Version.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.defaultVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      channels: isObject(object.channels)
        ? Object.entries(object.channels).reduce<{ [key: string]: ChannelConfig }>((acc, [key, value]) => {
          acc[key] = ChannelConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e: any) => Version.fromJSON(e)) : [],
      defaultVersion: isSet(object.defaultVersion) ? globalThis.String(object.defaultVersion) : "",
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.channels) {
      const entries = Object.entries(message.channels);
      if (entries.length > 0) {
        obj.channels = {};
        entries.forEach(([k, v]) => {
          obj.channels[k] = ChannelConfig.toJSON(v);
        });
      }
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => Version.toJSON(e));
    }
    if (message.defaultVersion !== "") {
      obj.defaultVersion = message.defaultVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig>): ServerConfig {
    return ServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig>): ServerConfig {
    const message = createBaseServerConfig();
    message.channels = Object.entries(object.channels ?? {}).reduce<{ [key: string]: ChannelConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ChannelConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.versions = object.versions?.map((e) => Version.fromPartial(e)) || [];
    message.defaultVersion = object.defaultVersion ?? "";
    return message;
  },
};

function createBaseServerConfig_ChannelsEntry(): ServerConfig_ChannelsEntry {
  return { key: "", value: undefined };
}

export const ServerConfig_ChannelsEntry: MessageFns<ServerConfig_ChannelsEntry> = {
  encode(message: ServerConfig_ChannelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ChannelConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig_ChannelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig_ChannelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ChannelConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig_ChannelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ChannelConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ServerConfig_ChannelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ChannelConfig.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig_ChannelsEntry>): ServerConfig_ChannelsEntry {
    return ServerConfig_ChannelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig_ChannelsEntry>): ServerConfig_ChannelsEntry {
    const message = createBaseServerConfig_ChannelsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ChannelConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseChannelConfig(): ChannelConfig {
  return { defaultVersion: "" };
}

export const ChannelConfig: MessageFns<ChannelConfig> = {
  encode(message: ChannelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultVersion !== "") {
      writer.uint32(10).string(message.defaultVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelConfig {
    return { defaultVersion: isSet(object.defaultVersion) ? globalThis.String(object.defaultVersion) : "" };
  },

  toJSON(message: ChannelConfig): unknown {
    const obj: any = {};
    if (message.defaultVersion !== "") {
      obj.defaultVersion = message.defaultVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ChannelConfig>): ChannelConfig {
    return ChannelConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChannelConfig>): ChannelConfig {
    const message = createBaseChannelConfig();
    message.defaultVersion = object.defaultVersion ?? "";
    return message;
  },
};

function createBaseVersion(): Version {
  return { name: "" };
}

export const Version: MessageFns<Version> = {
  encode(message: Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Version): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Version>): Version {
    return Version.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version>): Version {
    const message = createBaseVersion();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
