// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/securitycenter/v1/access.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.securitycenter.v1";

/** Represents an access event. */
export interface Access {
  /**
   * Associated email, such as "foo@google.com".
   *
   * The email address of the authenticated user or a service account acting on
   * behalf of a third party principal making the request. For third party
   * identity callers, the `principal_subject` field is populated instead of
   * this field. For privacy reasons, the principal email address is sometimes
   * redacted. For more information, see [Caller identities in audit
   * logs](https://cloud.google.com/logging/docs/audit#user-id).
   */
  principalEmail: string;
  /** Caller's IP address, such as "1.1.1.1". */
  callerIp: string;
  /** The caller IP's geolocation, which identifies where the call came from. */
  callerIpGeo:
    | Geolocation
    | undefined;
  /**
   * Type of user agent associated with the finding. For example, an operating
   * system shell or an embedded or standalone application.
   */
  userAgentFamily: string;
  /** The caller's user agent string associated with the finding. */
  userAgent: string;
  /**
   * This is the API service that the service account made a call to, e.g.
   * "iam.googleapis.com"
   */
  serviceName: string;
  /** The method that the service account called, e.g. "SetIamPolicy". */
  methodName: string;
  /**
   * A string that represents the principal_subject that is associated with the
   * identity. Unlike `principal_email`, `principal_subject` supports principals
   * that aren't associated with email addresses, such as third party
   * principals. For most identities, the format is
   * `principal://iam.googleapis.com/{identity pool name}/subject/{subject}`.
   * Some GKE identities, such as GKE_WORKLOAD, FREEFORM, and GKE_HUB_WORKLOAD,
   * still use the legacy format `serviceAccount:{identity pool
   * name}[{subject}]`.
   */
  principalSubject: string;
  /**
   * The name of the service account key that was used to create or exchange
   * credentials when authenticating the service account that made the request.
   * This is a scheme-less URI full resource name. For example:
   *
   * "//iam.googleapis.com/projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}".
   */
  serviceAccountKeyName: string;
  /**
   * The identity delegation history of an authenticated service account that
   * made the request. The `serviceAccountDelegationInfo[]` object contains
   * information about the real authorities that try to access Google Cloud
   * resources by delegating on a service account. When multiple authorities are
   * present, they are guaranteed to be sorted based on the original ordering of
   * the identity delegation events.
   */
  serviceAccountDelegationInfo: ServiceAccountDelegationInfo[];
  /**
   * A string that represents a username. The username provided depends on the
   * type of the finding and is likely not an IAM principal. For example, this
   * can be a system username if the finding is related to a virtual machine, or
   * it can be an application login username.
   */
  userName: string;
}

/** Identity delegation history of an authenticated service account. */
export interface ServiceAccountDelegationInfo {
  /** The email address of a Google account. */
  principalEmail: string;
  /**
   * A string representing the principal_subject associated with the identity.
   * As compared to `principal_email`, supports principals that aren't
   * associated with email addresses, such as third party principals. For most
   * identities, the format will be `principal://iam.googleapis.com/{identity
   * pool name}/subjects/{subject}` except for some GKE identities
   * (GKE_WORKLOAD, FREEFORM, GKE_HUB_WORKLOAD) that are still in the legacy
   * format `serviceAccount:{identity pool name}[{subject}]`
   */
  principalSubject: string;
}

/** Represents a geographical location for a given access. */
export interface Geolocation {
  /** A CLDR. */
  regionCode: string;
}

function createBaseAccess(): Access {
  return {
    principalEmail: "",
    callerIp: "",
    callerIpGeo: undefined,
    userAgentFamily: "",
    userAgent: "",
    serviceName: "",
    methodName: "",
    principalSubject: "",
    serviceAccountKeyName: "",
    serviceAccountDelegationInfo: [],
    userName: "",
  };
}

export const Access: MessageFns<Access> = {
  encode(message: Access, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.callerIp !== "") {
      writer.uint32(18).string(message.callerIp);
    }
    if (message.callerIpGeo !== undefined) {
      Geolocation.encode(message.callerIpGeo, writer.uint32(26).fork()).join();
    }
    if (message.userAgentFamily !== "") {
      writer.uint32(34).string(message.userAgentFamily);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.serviceName !== "") {
      writer.uint32(42).string(message.serviceName);
    }
    if (message.methodName !== "") {
      writer.uint32(50).string(message.methodName);
    }
    if (message.principalSubject !== "") {
      writer.uint32(58).string(message.principalSubject);
    }
    if (message.serviceAccountKeyName !== "") {
      writer.uint32(66).string(message.serviceAccountKeyName);
    }
    for (const v of message.serviceAccountDelegationInfo) {
      ServiceAccountDelegationInfo.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.userName !== "") {
      writer.uint32(90).string(message.userName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Access {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callerIp = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.callerIpGeo = Geolocation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userAgentFamily = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.principalSubject = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAccountKeyName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.serviceAccountDelegationInfo.push(ServiceAccountDelegationInfo.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.userName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Access {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      callerIp: isSet(object.callerIp) ? globalThis.String(object.callerIp) : "",
      callerIpGeo: isSet(object.callerIpGeo) ? Geolocation.fromJSON(object.callerIpGeo) : undefined,
      userAgentFamily: isSet(object.userAgentFamily) ? globalThis.String(object.userAgentFamily) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      principalSubject: isSet(object.principalSubject) ? globalThis.String(object.principalSubject) : "",
      serviceAccountKeyName: isSet(object.serviceAccountKeyName) ? globalThis.String(object.serviceAccountKeyName) : "",
      serviceAccountDelegationInfo: globalThis.Array.isArray(object?.serviceAccountDelegationInfo)
        ? object.serviceAccountDelegationInfo.map((e: any) => ServiceAccountDelegationInfo.fromJSON(e))
        : [],
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
    };
  },

  toJSON(message: Access): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.callerIp !== "") {
      obj.callerIp = message.callerIp;
    }
    if (message.callerIpGeo !== undefined) {
      obj.callerIpGeo = Geolocation.toJSON(message.callerIpGeo);
    }
    if (message.userAgentFamily !== "") {
      obj.userAgentFamily = message.userAgentFamily;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.principalSubject !== "") {
      obj.principalSubject = message.principalSubject;
    }
    if (message.serviceAccountKeyName !== "") {
      obj.serviceAccountKeyName = message.serviceAccountKeyName;
    }
    if (message.serviceAccountDelegationInfo?.length) {
      obj.serviceAccountDelegationInfo = message.serviceAccountDelegationInfo.map((e) =>
        ServiceAccountDelegationInfo.toJSON(e)
      );
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    return obj;
  },

  create(base?: DeepPartial<Access>): Access {
    return Access.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Access>): Access {
    const message = createBaseAccess();
    message.principalEmail = object.principalEmail ?? "";
    message.callerIp = object.callerIp ?? "";
    message.callerIpGeo = (object.callerIpGeo !== undefined && object.callerIpGeo !== null)
      ? Geolocation.fromPartial(object.callerIpGeo)
      : undefined;
    message.userAgentFamily = object.userAgentFamily ?? "";
    message.userAgent = object.userAgent ?? "";
    message.serviceName = object.serviceName ?? "";
    message.methodName = object.methodName ?? "";
    message.principalSubject = object.principalSubject ?? "";
    message.serviceAccountKeyName = object.serviceAccountKeyName ?? "";
    message.serviceAccountDelegationInfo =
      object.serviceAccountDelegationInfo?.map((e) => ServiceAccountDelegationInfo.fromPartial(e)) || [];
    message.userName = object.userName ?? "";
    return message;
  },
};

function createBaseServiceAccountDelegationInfo(): ServiceAccountDelegationInfo {
  return { principalEmail: "", principalSubject: "" };
}

export const ServiceAccountDelegationInfo: MessageFns<ServiceAccountDelegationInfo> = {
  encode(message: ServiceAccountDelegationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalEmail !== "") {
      writer.uint32(10).string(message.principalEmail);
    }
    if (message.principalSubject !== "") {
      writer.uint32(18).string(message.principalSubject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccountDelegationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccountDelegationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principalEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.principalSubject = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccountDelegationInfo {
    return {
      principalEmail: isSet(object.principalEmail) ? globalThis.String(object.principalEmail) : "",
      principalSubject: isSet(object.principalSubject) ? globalThis.String(object.principalSubject) : "",
    };
  },

  toJSON(message: ServiceAccountDelegationInfo): unknown {
    const obj: any = {};
    if (message.principalEmail !== "") {
      obj.principalEmail = message.principalEmail;
    }
    if (message.principalSubject !== "") {
      obj.principalSubject = message.principalSubject;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccountDelegationInfo>): ServiceAccountDelegationInfo {
    return ServiceAccountDelegationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccountDelegationInfo>): ServiceAccountDelegationInfo {
    const message = createBaseServiceAccountDelegationInfo();
    message.principalEmail = object.principalEmail ?? "";
    message.principalSubject = object.principalSubject ?? "";
    return message;
  },
};

function createBaseGeolocation(): Geolocation {
  return { regionCode: "" };
}

export const Geolocation: MessageFns<Geolocation> = {
  encode(message: Geolocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regionCode !== "") {
      writer.uint32(10).string(message.regionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Geolocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeolocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.regionCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Geolocation {
    return { regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "" };
  },

  toJSON(message: Geolocation): unknown {
    const obj: any = {};
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Geolocation>): Geolocation {
    return Geolocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Geolocation>): Geolocation {
    const message = createBaseGeolocation();
    message.regionCode = object.regionCode ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
