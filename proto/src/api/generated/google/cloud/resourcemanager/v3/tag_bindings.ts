// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/resourcemanager/v3/tag_bindings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";

export const protobufPackage = "google.cloud.resourcemanager.v3";

/**
 * A TagBinding represents a connection between a TagValue and a cloud
 * resource Once a TagBinding is created, the TagValue is applied to all the
 * descendants of the Google Cloud resource.
 */
export interface TagBinding {
  /**
   * Output only. The name of the TagBinding. This is a String of the form:
   * `tagBindings/{full-resource-name}/{tag-value-name}` (e.g.
   * `tagBindings/%2F%2Fcloudresourcemanager.googleapis.com%2Fprojects%2F123/tagValues/456`).
   */
  name: string;
  /**
   * The full resource name of the resource the TagValue is bound to.
   * E.g. `//cloudresourcemanager.googleapis.com/projects/123`
   */
  parent: string;
  /**
   * The TagValue of the TagBinding.
   * Must be of the form `tagValues/456`.
   */
  tagValue: string;
  /**
   * The namespaced name for the TagValue of the TagBinding.
   * Must be in the format
   * `{parent_id}/{tag_key_short_name}/{short_name}`.
   *
   * For methods that support TagValue namespaced name, only one of
   * tag_value_namespaced_name or tag_value may be filled. Requests with both
   * fields will be rejected.
   */
  tagValueNamespacedName: string;
}

/** Runtime operation information for creating a TagValue. */
export interface CreateTagBindingMetadata {
}

/** The request message to create a TagBinding. */
export interface CreateTagBindingRequest {
  /** Required. The TagBinding to be created. */
  tagBinding:
    | TagBinding
    | undefined;
  /**
   * Optional. Set to true to perform the validations necessary for creating the
   * resource, but not actually perform the action.
   */
  validateOnly: boolean;
}

/** Runtime operation information for deleting a TagBinding. */
export interface DeleteTagBindingMetadata {
}

/** The request message to delete a TagBinding. */
export interface DeleteTagBindingRequest {
  /**
   * Required. The name of the TagBinding. This is a String of the form:
   * `tagBindings/{id}` (e.g.
   * `tagBindings/%2F%2Fcloudresourcemanager.googleapis.com%2Fprojects%2F123/tagValues/456`).
   */
  name: string;
}

/** The request message to list all TagBindings for a parent. */
export interface ListTagBindingsRequest {
  /**
   * Required. The full resource name of a resource for which you want to list
   * existing TagBindings. E.g.
   * "//cloudresourcemanager.googleapis.com/projects/123"
   */
  parent: string;
  /**
   * Optional. The maximum number of TagBindings to return in the response. The
   * server allows a maximum of 300 TagBindings to return. If unspecified, the
   * server will use 100 as the default.
   */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to
   * `ListTagBindings` that indicates where this listing should continue from.
   */
  pageToken: string;
}

/** The ListTagBindings response. */
export interface ListTagBindingsResponse {
  /** A possibly paginated list of TagBindings for the specified resource. */
  tagBindings: TagBinding[];
  /**
   * Pagination token.
   *
   * If the result set is too large to fit in a single response, this token
   * is returned. It encodes the position of the current result cursor.
   * Feeding this value into a new list request with the `page_token` parameter
   * gives the next page of the results.
   *
   * When `next_page_token` is not filled in, there is no next page and
   * the list returned is the last page in the result set.
   *
   * Pagination tokens have a limited lifetime.
   */
  nextPageToken: string;
}

/** The request message to ListEffectiveTags */
export interface ListEffectiveTagsRequest {
  /**
   * Required. The full resource name of a resource for which you want to list
   * the effective tags. E.g.
   * "//cloudresourcemanager.googleapis.com/projects/123"
   */
  parent: string;
  /**
   * Optional. The maximum number of effective tags to return in the response.
   * The server allows a maximum of 300 effective tags to return in a single
   * page. If unspecified, the server will use 100 as the default.
   */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to
   * `ListEffectiveTags` that indicates from where this listing should continue.
   */
  pageToken: string;
}

/** The response of ListEffectiveTags. */
export interface ListEffectiveTagsResponse {
  /** A possibly paginated list of effective tags for the specified resource. */
  effectiveTags: EffectiveTag[];
  /**
   * Pagination token.
   *
   * If the result set is too large to fit in a single response, this token
   * is returned. It encodes the position of the current result cursor.
   * Feeding this value into a new list request with the `page_token` parameter
   * gives the next page of the results.
   *
   * When `next_page_token` is not filled in, there is no next page and
   * the list returned is the last page in the result set.
   *
   * Pagination tokens have a limited lifetime.
   */
  nextPageToken: string;
}

/**
 * An EffectiveTag represents a tag that applies to a resource during policy
 * evaluation. Tags can be either directly bound to a resource or inherited from
 * its ancestor. EffectiveTag contains the name and
 * namespaced_name of the tag value and tag key, with additional fields of
 * `inherited` to indicate the inheritance status of the effective tag.
 */
export interface EffectiveTag {
  /** Resource name for TagValue in the format `tagValues/456`. */
  tagValue: string;
  /**
   * The namespaced name of the TagValue. Can be in the form
   * `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.
   */
  namespacedTagValue: string;
  /**
   * The name of the TagKey, in the format `tagKeys/{id}`, such as
   * `tagKeys/123`.
   */
  tagKey: string;
  /**
   * The namespaced name of the TagKey. Can be in the form
   * `{organization_id}/{tag_key_short_name}` or
   * `{project_id}/{tag_key_short_name}` or
   * `{project_number}/{tag_key_short_name}`.
   */
  namespacedTagKey: string;
  /**
   * The parent name of the tag key.
   * Must be in the format `organizations/{organization_id}` or
   * `projects/{project_number}`
   */
  tagKeyParentName: string;
  /**
   * Indicates the inheritance status of a tag value
   * attached to the given resource. If the tag value is inherited from one of
   * the resource's ancestors, inherited will be true. If false, then the tag
   * value is directly attached to the resource, inherited will be false.
   */
  inherited: boolean;
}

function createBaseTagBinding(): TagBinding {
  return { name: "", parent: "", tagValue: "", tagValueNamespacedName: "" };
}

export const TagBinding: MessageFns<TagBinding> = {
  encode(message: TagBinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.tagValue !== "") {
      writer.uint32(26).string(message.tagValue);
    }
    if (message.tagValueNamespacedName !== "") {
      writer.uint32(34).string(message.tagValueNamespacedName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagBinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tagValueNamespacedName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagBinding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      tagValue: isSet(object.tagValue) ? globalThis.String(object.tagValue) : "",
      tagValueNamespacedName: isSet(object.tagValueNamespacedName)
        ? globalThis.String(object.tagValueNamespacedName)
        : "",
    };
  },

  toJSON(message: TagBinding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.tagValue !== "") {
      obj.tagValue = message.tagValue;
    }
    if (message.tagValueNamespacedName !== "") {
      obj.tagValueNamespacedName = message.tagValueNamespacedName;
    }
    return obj;
  },

  create(base?: DeepPartial<TagBinding>): TagBinding {
    return TagBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagBinding>): TagBinding {
    const message = createBaseTagBinding();
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.tagValue = object.tagValue ?? "";
    message.tagValueNamespacedName = object.tagValueNamespacedName ?? "";
    return message;
  },
};

function createBaseCreateTagBindingMetadata(): CreateTagBindingMetadata {
  return {};
}

export const CreateTagBindingMetadata: MessageFns<CreateTagBindingMetadata> = {
  encode(_: CreateTagBindingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTagBindingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTagBindingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateTagBindingMetadata {
    return {};
  },

  toJSON(_: CreateTagBindingMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateTagBindingMetadata>): CreateTagBindingMetadata {
    return CreateTagBindingMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateTagBindingMetadata>): CreateTagBindingMetadata {
    const message = createBaseCreateTagBindingMetadata();
    return message;
  },
};

function createBaseCreateTagBindingRequest(): CreateTagBindingRequest {
  return { tagBinding: undefined, validateOnly: false };
}

export const CreateTagBindingRequest: MessageFns<CreateTagBindingRequest> = {
  encode(message: CreateTagBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagBinding !== undefined) {
      TagBinding.encode(message.tagBinding, writer.uint32(10).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTagBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTagBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagBinding = TagBinding.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTagBindingRequest {
    return {
      tagBinding: isSet(object.tagBinding) ? TagBinding.fromJSON(object.tagBinding) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateTagBindingRequest): unknown {
    const obj: any = {};
    if (message.tagBinding !== undefined) {
      obj.tagBinding = TagBinding.toJSON(message.tagBinding);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTagBindingRequest>): CreateTagBindingRequest {
    return CreateTagBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTagBindingRequest>): CreateTagBindingRequest {
    const message = createBaseCreateTagBindingRequest();
    message.tagBinding = (object.tagBinding !== undefined && object.tagBinding !== null)
      ? TagBinding.fromPartial(object.tagBinding)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteTagBindingMetadata(): DeleteTagBindingMetadata {
  return {};
}

export const DeleteTagBindingMetadata: MessageFns<DeleteTagBindingMetadata> = {
  encode(_: DeleteTagBindingMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTagBindingMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTagBindingMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteTagBindingMetadata {
    return {};
  },

  toJSON(_: DeleteTagBindingMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteTagBindingMetadata>): DeleteTagBindingMetadata {
    return DeleteTagBindingMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteTagBindingMetadata>): DeleteTagBindingMetadata {
    const message = createBaseDeleteTagBindingMetadata();
    return message;
  },
};

function createBaseDeleteTagBindingRequest(): DeleteTagBindingRequest {
  return { name: "" };
}

export const DeleteTagBindingRequest: MessageFns<DeleteTagBindingRequest> = {
  encode(message: DeleteTagBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTagBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTagBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTagBindingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTagBindingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTagBindingRequest>): DeleteTagBindingRequest {
    return DeleteTagBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTagBindingRequest>): DeleteTagBindingRequest {
    const message = createBaseDeleteTagBindingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTagBindingsRequest(): ListTagBindingsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListTagBindingsRequest: MessageFns<ListTagBindingsRequest> = {
  encode(message: ListTagBindingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTagBindingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTagBindingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTagBindingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTagBindingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTagBindingsRequest>): ListTagBindingsRequest {
    return ListTagBindingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTagBindingsRequest>): ListTagBindingsRequest {
    const message = createBaseListTagBindingsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTagBindingsResponse(): ListTagBindingsResponse {
  return { tagBindings: [], nextPageToken: "" };
}

export const ListTagBindingsResponse: MessageFns<ListTagBindingsResponse> = {
  encode(message: ListTagBindingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tagBindings) {
      TagBinding.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTagBindingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTagBindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagBindings.push(TagBinding.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTagBindingsResponse {
    return {
      tagBindings: globalThis.Array.isArray(object?.tagBindings)
        ? object.tagBindings.map((e: any) => TagBinding.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTagBindingsResponse): unknown {
    const obj: any = {};
    if (message.tagBindings?.length) {
      obj.tagBindings = message.tagBindings.map((e) => TagBinding.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTagBindingsResponse>): ListTagBindingsResponse {
    return ListTagBindingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTagBindingsResponse>): ListTagBindingsResponse {
    const message = createBaseListTagBindingsResponse();
    message.tagBindings = object.tagBindings?.map((e) => TagBinding.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListEffectiveTagsRequest(): ListEffectiveTagsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListEffectiveTagsRequest: MessageFns<ListEffectiveTagsRequest> = {
  encode(message: ListEffectiveTagsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEffectiveTagsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEffectiveTagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEffectiveTagsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListEffectiveTagsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEffectiveTagsRequest>): ListEffectiveTagsRequest {
    return ListEffectiveTagsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEffectiveTagsRequest>): ListEffectiveTagsRequest {
    const message = createBaseListEffectiveTagsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListEffectiveTagsResponse(): ListEffectiveTagsResponse {
  return { effectiveTags: [], nextPageToken: "" };
}

export const ListEffectiveTagsResponse: MessageFns<ListEffectiveTagsResponse> = {
  encode(message: ListEffectiveTagsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.effectiveTags) {
      EffectiveTag.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEffectiveTagsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEffectiveTagsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.effectiveTags.push(EffectiveTag.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEffectiveTagsResponse {
    return {
      effectiveTags: globalThis.Array.isArray(object?.effectiveTags)
        ? object.effectiveTags.map((e: any) => EffectiveTag.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEffectiveTagsResponse): unknown {
    const obj: any = {};
    if (message.effectiveTags?.length) {
      obj.effectiveTags = message.effectiveTags.map((e) => EffectiveTag.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEffectiveTagsResponse>): ListEffectiveTagsResponse {
    return ListEffectiveTagsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEffectiveTagsResponse>): ListEffectiveTagsResponse {
    const message = createBaseListEffectiveTagsResponse();
    message.effectiveTags = object.effectiveTags?.map((e) => EffectiveTag.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseEffectiveTag(): EffectiveTag {
  return {
    tagValue: "",
    namespacedTagValue: "",
    tagKey: "",
    namespacedTagKey: "",
    tagKeyParentName: "",
    inherited: false,
  };
}

export const EffectiveTag: MessageFns<EffectiveTag> = {
  encode(message: EffectiveTag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagValue !== "") {
      writer.uint32(10).string(message.tagValue);
    }
    if (message.namespacedTagValue !== "") {
      writer.uint32(18).string(message.namespacedTagValue);
    }
    if (message.tagKey !== "") {
      writer.uint32(26).string(message.tagKey);
    }
    if (message.namespacedTagKey !== "") {
      writer.uint32(34).string(message.namespacedTagKey);
    }
    if (message.tagKeyParentName !== "") {
      writer.uint32(50).string(message.tagKeyParentName);
    }
    if (message.inherited !== false) {
      writer.uint32(40).bool(message.inherited);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveTag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.namespacedTagValue = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tagKey = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespacedTagKey = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tagKeyParentName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.inherited = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveTag {
    return {
      tagValue: isSet(object.tagValue) ? globalThis.String(object.tagValue) : "",
      namespacedTagValue: isSet(object.namespacedTagValue) ? globalThis.String(object.namespacedTagValue) : "",
      tagKey: isSet(object.tagKey) ? globalThis.String(object.tagKey) : "",
      namespacedTagKey: isSet(object.namespacedTagKey) ? globalThis.String(object.namespacedTagKey) : "",
      tagKeyParentName: isSet(object.tagKeyParentName) ? globalThis.String(object.tagKeyParentName) : "",
      inherited: isSet(object.inherited) ? globalThis.Boolean(object.inherited) : false,
    };
  },

  toJSON(message: EffectiveTag): unknown {
    const obj: any = {};
    if (message.tagValue !== "") {
      obj.tagValue = message.tagValue;
    }
    if (message.namespacedTagValue !== "") {
      obj.namespacedTagValue = message.namespacedTagValue;
    }
    if (message.tagKey !== "") {
      obj.tagKey = message.tagKey;
    }
    if (message.namespacedTagKey !== "") {
      obj.namespacedTagKey = message.namespacedTagKey;
    }
    if (message.tagKeyParentName !== "") {
      obj.tagKeyParentName = message.tagKeyParentName;
    }
    if (message.inherited !== false) {
      obj.inherited = message.inherited;
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveTag>): EffectiveTag {
    return EffectiveTag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveTag>): EffectiveTag {
    const message = createBaseEffectiveTag();
    message.tagValue = object.tagValue ?? "";
    message.namespacedTagValue = object.namespacedTagValue ?? "";
    message.tagKey = object.tagKey ?? "";
    message.namespacedTagKey = object.namespacedTagKey ?? "";
    message.tagKeyParentName = object.tagKeyParentName ?? "";
    message.inherited = object.inherited ?? false;
    return message;
  },
};

/**
 * Allow users to create and manage TagBindings between TagValues and
 * different Google Cloud resources throughout the GCP resource hierarchy.
 */
export type TagBindingsDefinition = typeof TagBindingsDefinition;
export const TagBindingsDefinition = {
  name: "TagBindings",
  fullName: "google.cloud.resourcemanager.v3.TagBindings",
  methods: {
    /**
     * Lists the TagBindings for the given Google Cloud resource, as specified
     * with `parent`.
     *
     * NOTE: The `parent` field is expected to be a full resource name:
     * https://cloud.google.com/apis/design/resource_names#full_resource_name
     */
    listTagBindings: {
      name: "ListTagBindings",
      requestType: ListTagBindingsRequest,
      requestStream: false,
      responseType: ListTagBindingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [Buffer.from([17, 18, 15, 47, 118, 51, 47, 116, 97, 103, 66, 105, 110, 100, 105, 110, 103, 115])],
        },
      },
    },
    /** Creates a TagBinding between a TagValue and a Google Cloud resource. */
    createTagBinding: {
      name: "CreateTagBinding",
      requestType: CreateTagBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              10,
              84,
              97,
              103,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              18,
              24,
              67,
              114,
              101,
              97,
              116,
              101,
              84,
              97,
              103,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([11, 116, 97, 103, 95, 98, 105, 110, 100, 105, 110, 103])],
          578365826: [
            Buffer.from([
              30,
              58,
              11,
              116,
              97,
              103,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              34,
              15,
              47,
              118,
              51,
              47,
              116,
              97,
              103,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a TagBinding. */
    deleteTagBinding: {
      name: "DeleteTagBinding",
      requestType: DeleteTagBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              24,
              68,
              101,
              108,
              101,
              116,
              101,
              84,
              97,
              103,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              27,
              42,
              25,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              116,
              97,
              103,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Return a list of effective tags for the given Google Cloud resource, as
     * specified in `parent`.
     */
    listEffectiveTags: {
      name: "ListEffectiveTags",
      requestType: ListEffectiveTagsRequest,
      requestStream: false,
      responseType: ListEffectiveTagsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([19, 18, 17, 47, 118, 51, 47, 101, 102, 102, 101, 99, 116, 105, 118, 101, 84, 97, 103, 115]),
          ],
        },
      },
    },
  },
} as const;

export interface TagBindingsServiceImplementation<CallContextExt = {}> {
  /**
   * Lists the TagBindings for the given Google Cloud resource, as specified
   * with `parent`.
   *
   * NOTE: The `parent` field is expected to be a full resource name:
   * https://cloud.google.com/apis/design/resource_names#full_resource_name
   */
  listTagBindings(
    request: ListTagBindingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTagBindingsResponse>>;
  /** Creates a TagBinding between a TagValue and a Google Cloud resource. */
  createTagBinding(
    request: CreateTagBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a TagBinding. */
  deleteTagBinding(
    request: DeleteTagBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Return a list of effective tags for the given Google Cloud resource, as
   * specified in `parent`.
   */
  listEffectiveTags(
    request: ListEffectiveTagsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEffectiveTagsResponse>>;
}

export interface TagBindingsClient<CallOptionsExt = {}> {
  /**
   * Lists the TagBindings for the given Google Cloud resource, as specified
   * with `parent`.
   *
   * NOTE: The `parent` field is expected to be a full resource name:
   * https://cloud.google.com/apis/design/resource_names#full_resource_name
   */
  listTagBindings(
    request: DeepPartial<ListTagBindingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTagBindingsResponse>;
  /** Creates a TagBinding between a TagValue and a Google Cloud resource. */
  createTagBinding(
    request: DeepPartial<CreateTagBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a TagBinding. */
  deleteTagBinding(
    request: DeepPartial<DeleteTagBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Return a list of effective tags for the given Google Cloud resource, as
   * specified in `parent`.
   */
  listEffectiveTags(
    request: DeepPartial<ListEffectiveTagsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEffectiveTagsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
