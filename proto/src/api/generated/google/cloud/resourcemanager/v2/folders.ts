// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/resourcemanager/v2/folders.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  GetIamPolicyRequest,
  SetIamPolicyRequest,
  TestIamPermissionsRequest,
  TestIamPermissionsResponse,
} from "../../../iam/v1/iam_policy.js";
import { Policy } from "../../../iam/v1/policy.js";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.resourcemanager.v2";

/**
 * A Folder in an Organization's resource hierarchy, used to
 * organize that Organization's resources.
 */
export interface Folder {
  /**
   * Output only. The resource name of the Folder.
   * Its format is `folders/{folder_id}`, for example: "folders/1234".
   */
  name: string;
  /**
   * Required. The Folder’s parent's resource name.
   * Updates to the folder's parent must be performed via
   * [MoveFolder][google.cloud.resourcemanager.v2.Folders.MoveFolder].
   */
  parent: string;
  /**
   * The folder’s display name.
   * A folder’s display name must be unique amongst its siblings, e.g.
   * no two folders with the same parent can share the same display name.
   * The display name must start and end with a letter or digit, may contain
   * letters, digits, spaces, hyphens and underscores and can be no longer
   * than 30 characters. This is captured by the regular expression:
   * [\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?.
   */
  displayName: string;
  /**
   * Output only. The lifecycle state of the folder.
   * Updates to the lifecycle_state must be performed via
   * [DeleteFolder][google.cloud.resourcemanager.v2.Folders.DeleteFolder] and
   * [UndeleteFolder][google.cloud.resourcemanager.v2.Folders.UndeleteFolder].
   */
  lifecycleState: Folder_LifecycleState;
  /** Output only. Timestamp when the Folder was created. Assigned by the server. */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp when the Folder was last modified. */
  updateTime: Date | undefined;
}

/** Folder lifecycle states. */
export enum Folder_LifecycleState {
  /** LIFECYCLE_STATE_UNSPECIFIED - Unspecified state. */
  LIFECYCLE_STATE_UNSPECIFIED = 0,
  /** ACTIVE - The normal and active state. */
  ACTIVE = 1,
  /** DELETE_REQUESTED - The folder has been marked for deletion by the user. */
  DELETE_REQUESTED = 2,
  UNRECOGNIZED = -1,
}

export function folder_LifecycleStateFromJSON(object: any): Folder_LifecycleState {
  switch (object) {
    case 0:
    case "LIFECYCLE_STATE_UNSPECIFIED":
      return Folder_LifecycleState.LIFECYCLE_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Folder_LifecycleState.ACTIVE;
    case 2:
    case "DELETE_REQUESTED":
      return Folder_LifecycleState.DELETE_REQUESTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Folder_LifecycleState.UNRECOGNIZED;
  }
}

export function folder_LifecycleStateToJSON(object: Folder_LifecycleState): string {
  switch (object) {
    case Folder_LifecycleState.LIFECYCLE_STATE_UNSPECIFIED:
      return "LIFECYCLE_STATE_UNSPECIFIED";
    case Folder_LifecycleState.ACTIVE:
      return "ACTIVE";
    case Folder_LifecycleState.DELETE_REQUESTED:
      return "DELETE_REQUESTED";
    case Folder_LifecycleState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The ListFolders request message. */
export interface ListFoldersRequest {
  /**
   * Required. The resource name of the Organization or Folder whose Folders are
   * being listed.
   * Must be of the form `folders/{folder_id}` or `organizations/{org_id}`.
   * Access to this method is controlled by checking the
   * `resourcemanager.folders.list` permission on the `parent`.
   */
  parent: string;
  /** Optional. The maximum number of Folders to return in the response. */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to `ListFolders`
   * that indicates where this listing should continue from.
   */
  pageToken: string;
  /**
   * Optional. Controls whether Folders in the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED]
   * state should be returned. Defaults to false.
   */
  showDeleted: boolean;
}

/** The ListFolders response message. */
export interface ListFoldersResponse {
  /**
   * A possibly paginated list of Folders that are direct descendants of
   * the specified parent resource.
   */
  folders: Folder[];
  /**
   * A pagination token returned from a previous call to `ListFolders`
   * that indicates from where listing should continue.
   */
  nextPageToken: string;
}

/** The request message for searching folders. */
export interface SearchFoldersRequest {
  /** Optional. The maximum number of folders to return in the response. */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to `SearchFolders`
   * that indicates from where search should continue.
   */
  pageToken: string;
  /**
   * Search criteria used to select the Folders to return.
   * If no search criteria is specified then all accessible folders will be
   * returned.
   *
   * Query expressions can be used to restrict results based upon displayName,
   * lifecycleState and parent, where the operators `=`, `NOT`, `AND` and `OR`
   * can be used along with the suffix wildcard symbol `*`.
   *
   * The displayName field in a query expression should use escaped quotes
   * for values that include whitespace to prevent unexpected behavior.
   *
   * Some example queries are:
   *
   * * Query `displayName=Test*` returns Folder resources whose display name
   * starts with "Test".
   * * Query `lifecycleState=ACTIVE` returns Folder resources with
   * `lifecycleState` set to `ACTIVE`.
   * * Query `parent=folders/123` returns Folder resources that have
   * `folders/123` as a parent resource.
   * * Query `parent=folders/123 AND lifecycleState=ACTIVE` returns active
   * Folder resources that have `folders/123` as a parent resource.
   * * Query `displayName=\\"Test String\\"` returns Folder resources with
   * display names that include both "Test" and "String".
   */
  query: string;
}

/** The response message for searching folders. */
export interface SearchFoldersResponse {
  /**
   * A possibly paginated folder search results.
   * the specified parent resource.
   */
  folders: Folder[];
  /**
   * A pagination token returned from a previous call to `SearchFolders`
   * that indicates from where searching should continue.
   */
  nextPageToken: string;
}

/** The GetFolder request message. */
export interface GetFolderRequest {
  /**
   * Required. The resource name of the Folder to retrieve.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
}

/** The CreateFolder request message. */
export interface CreateFolderRequest {
  /**
   * Required. The resource name of the new Folder's parent.
   * Must be of the form `folders/{folder_id}` or `organizations/{org_id}`.
   */
  parent: string;
  /**
   * Required. The Folder being created, only the display name will be consulted.
   * All other fields will be ignored.
   */
  folder: Folder | undefined;
}

/** The MoveFolder request message. */
export interface MoveFolderRequest {
  /**
   * Required. The resource name of the Folder to move.
   * Must be of the form folders/{folder_id}
   */
  name: string;
  /**
   * Required. The resource name of the Folder or Organization to reparent
   * the folder under.
   * Must be of the form `folders/{folder_id}` or `organizations/{org_id}`.
   */
  destinationParent: string;
}

/** The request message for updating a folder's display name. */
export interface UpdateFolderRequest {
  /**
   * Required. The new definition of the Folder. It must include a
   * a `name` and `display_name` field. The other fields
   * will be ignored.
   */
  folder:
    | Folder
    | undefined;
  /**
   * Required. Fields to be updated.
   * Only the `display_name` can be updated.
   */
  updateMask: string[] | undefined;
}

/** The DeleteFolder request message. */
export interface DeleteFolderRequest {
  /**
   * Required. The resource name of the Folder to be deleted.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
  /**
   * Instructs DeleteFolderAction to delete a folder even when the folder is not
   * empty.
   */
  recursiveDelete: boolean;
}

/** The UndeleteFolder request message. */
export interface UndeleteFolderRequest {
  /**
   * Required. The resource name of the Folder to undelete.
   * Must be of the form `folders/{folder_id}`.
   */
  name: string;
}

/** Metadata describing a long running folder operation */
export interface FolderOperation {
  /** The display name of the folder. */
  displayName: string;
  /** The type of this operation. */
  operationType: FolderOperation_OperationType;
  /**
   * The resource name of the folder's parent.
   * Only applicable when the operation_type is MOVE.
   */
  sourceParent: string;
  /**
   * The resource name of the folder or organization we are either creating
   * the folder under or moving the folder to.
   */
  destinationParent: string;
}

/** The type of operation that failed. */
export enum FolderOperation_OperationType {
  /** OPERATION_TYPE_UNSPECIFIED - Operation type not specified. */
  OPERATION_TYPE_UNSPECIFIED = 0,
  /** CREATE - A create folder operation. */
  CREATE = 1,
  /** MOVE - A move folder operation. */
  MOVE = 2,
  UNRECOGNIZED = -1,
}

export function folderOperation_OperationTypeFromJSON(object: any): FolderOperation_OperationType {
  switch (object) {
    case 0:
    case "OPERATION_TYPE_UNSPECIFIED":
      return FolderOperation_OperationType.OPERATION_TYPE_UNSPECIFIED;
    case 1:
    case "CREATE":
      return FolderOperation_OperationType.CREATE;
    case 2:
    case "MOVE":
      return FolderOperation_OperationType.MOVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FolderOperation_OperationType.UNRECOGNIZED;
  }
}

export function folderOperation_OperationTypeToJSON(object: FolderOperation_OperationType): string {
  switch (object) {
    case FolderOperation_OperationType.OPERATION_TYPE_UNSPECIFIED:
      return "OPERATION_TYPE_UNSPECIFIED";
    case FolderOperation_OperationType.CREATE:
      return "CREATE";
    case FolderOperation_OperationType.MOVE:
      return "MOVE";
    case FolderOperation_OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseFolder(): Folder {
  return { name: "", parent: "", displayName: "", lifecycleState: 0, createTime: undefined, updateTime: undefined };
}

export const Folder: MessageFns<Folder> = {
  encode(message: Folder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.lifecycleState !== 0) {
      writer.uint32(32).int32(message.lifecycleState);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Folder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lifecycleState = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Folder {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      lifecycleState: isSet(object.lifecycleState) ? folder_LifecycleStateFromJSON(object.lifecycleState) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Folder): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.lifecycleState !== 0) {
      obj.lifecycleState = folder_LifecycleStateToJSON(message.lifecycleState);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Folder>): Folder {
    return Folder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Folder>): Folder {
    const message = createBaseFolder();
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.displayName = object.displayName ?? "";
    message.lifecycleState = object.lifecycleState ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseListFoldersRequest(): ListFoldersRequest {
  return { parent: "", pageSize: 0, pageToken: "", showDeleted: false };
}

export const ListFoldersRequest: MessageFns<ListFoldersRequest> = {
  encode(message: ListFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(32).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListFoldersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    return ListFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    const message = createBaseListFoldersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListFoldersResponse(): ListFoldersResponse {
  return { folders: [], nextPageToken: "" };
}

export const ListFoldersResponse: MessageFns<ListFoldersResponse> = {
  encode(message: ListFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      Folder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(Folder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersResponse {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => Folder.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFoldersResponse): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders.map((e) => Folder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    return ListFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    const message = createBaseListFoldersResponse();
    message.folders = object.folders?.map((e) => Folder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchFoldersRequest(): SearchFoldersRequest {
  return { pageSize: 0, pageToken: "", query: "" };
}

export const SearchFoldersRequest: MessageFns<SearchFoldersRequest> = {
  encode(message: SearchFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFoldersRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
    };
  },

  toJSON(message: SearchFoldersRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchFoldersRequest>): SearchFoldersRequest {
    return SearchFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchFoldersRequest>): SearchFoldersRequest {
    const message = createBaseSearchFoldersRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSearchFoldersResponse(): SearchFoldersResponse {
  return { folders: [], nextPageToken: "" };
}

export const SearchFoldersResponse: MessageFns<SearchFoldersResponse> = {
  encode(message: SearchFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      Folder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(Folder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFoldersResponse {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => Folder.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchFoldersResponse): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders.map((e) => Folder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchFoldersResponse>): SearchFoldersResponse {
    return SearchFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchFoldersResponse>): SearchFoldersResponse {
    const message = createBaseSearchFoldersResponse();
    message.folders = object.folders?.map((e) => Folder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetFolderRequest(): GetFolderRequest {
  return { name: "" };
}

export const GetFolderRequest: MessageFns<GetFolderRequest> = {
  encode(message: GetFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFolderRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFolderRequest>): GetFolderRequest {
    return GetFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFolderRequest>): GetFolderRequest {
    const message = createBaseGetFolderRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateFolderRequest(): CreateFolderRequest {
  return { parent: "", folder: undefined };
}

export const CreateFolderRequest: MessageFns<CreateFolderRequest> = {
  encode(message: CreateFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.folder !== undefined) {
      Folder.encode(message.folder, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.folder = Folder.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFolderRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      folder: isSet(object.folder) ? Folder.fromJSON(object.folder) : undefined,
    };
  },

  toJSON(message: CreateFolderRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.folder !== undefined) {
      obj.folder = Folder.toJSON(message.folder);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    return CreateFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    const message = createBaseCreateFolderRequest();
    message.parent = object.parent ?? "";
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? Folder.fromPartial(object.folder)
      : undefined;
    return message;
  },
};

function createBaseMoveFolderRequest(): MoveFolderRequest {
  return { name: "", destinationParent: "" };
}

export const MoveFolderRequest: MessageFns<MoveFolderRequest> = {
  encode(message: MoveFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.destinationParent !== "") {
      writer.uint32(18).string(message.destinationParent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationParent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationParent: isSet(object.destinationParent) ? globalThis.String(object.destinationParent) : "",
    };
  },

  toJSON(message: MoveFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationParent !== "") {
      obj.destinationParent = message.destinationParent;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveFolderRequest>): MoveFolderRequest {
    return MoveFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveFolderRequest>): MoveFolderRequest {
    const message = createBaseMoveFolderRequest();
    message.name = object.name ?? "";
    message.destinationParent = object.destinationParent ?? "";
    return message;
  },
};

function createBaseUpdateFolderRequest(): UpdateFolderRequest {
  return { folder: undefined, updateMask: undefined };
}

export const UpdateFolderRequest: MessageFns<UpdateFolderRequest> = {
  encode(message: UpdateFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.folder !== undefined) {
      Folder.encode(message.folder, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folder = Folder.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFolderRequest {
    return {
      folder: isSet(object.folder) ? Folder.fromJSON(object.folder) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateFolderRequest): unknown {
    const obj: any = {};
    if (message.folder !== undefined) {
      obj.folder = Folder.toJSON(message.folder);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFolderRequest>): UpdateFolderRequest {
    return UpdateFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFolderRequest>): UpdateFolderRequest {
    const message = createBaseUpdateFolderRequest();
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? Folder.fromPartial(object.folder)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteFolderRequest(): DeleteFolderRequest {
  return { name: "", recursiveDelete: false };
}

export const DeleteFolderRequest: MessageFns<DeleteFolderRequest> = {
  encode(message: DeleteFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.recursiveDelete !== false) {
      writer.uint32(16).bool(message.recursiveDelete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.recursiveDelete = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      recursiveDelete: isSet(object.recursiveDelete) ? globalThis.Boolean(object.recursiveDelete) : false,
    };
  },

  toJSON(message: DeleteFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.recursiveDelete !== false) {
      obj.recursiveDelete = message.recursiveDelete;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    return DeleteFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    const message = createBaseDeleteFolderRequest();
    message.name = object.name ?? "";
    message.recursiveDelete = object.recursiveDelete ?? false;
    return message;
  },
};

function createBaseUndeleteFolderRequest(): UndeleteFolderRequest {
  return { name: "" };
}

export const UndeleteFolderRequest: MessageFns<UndeleteFolderRequest> = {
  encode(message: UndeleteFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteFolderRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteFolderRequest>): UndeleteFolderRequest {
    return UndeleteFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteFolderRequest>): UndeleteFolderRequest {
    const message = createBaseUndeleteFolderRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFolderOperation(): FolderOperation {
  return { displayName: "", operationType: 0, sourceParent: "", destinationParent: "" };
}

export const FolderOperation: MessageFns<FolderOperation> = {
  encode(message: FolderOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.operationType !== 0) {
      writer.uint32(16).int32(message.operationType);
    }
    if (message.sourceParent !== "") {
      writer.uint32(26).string(message.sourceParent);
    }
    if (message.destinationParent !== "") {
      writer.uint32(34).string(message.destinationParent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FolderOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFolderOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceParent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationParent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FolderOperation {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      operationType: isSet(object.operationType) ? folderOperation_OperationTypeFromJSON(object.operationType) : 0,
      sourceParent: isSet(object.sourceParent) ? globalThis.String(object.sourceParent) : "",
      destinationParent: isSet(object.destinationParent) ? globalThis.String(object.destinationParent) : "",
    };
  },

  toJSON(message: FolderOperation): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.operationType !== 0) {
      obj.operationType = folderOperation_OperationTypeToJSON(message.operationType);
    }
    if (message.sourceParent !== "") {
      obj.sourceParent = message.sourceParent;
    }
    if (message.destinationParent !== "") {
      obj.destinationParent = message.destinationParent;
    }
    return obj;
  },

  create(base?: DeepPartial<FolderOperation>): FolderOperation {
    return FolderOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FolderOperation>): FolderOperation {
    const message = createBaseFolderOperation();
    message.displayName = object.displayName ?? "";
    message.operationType = object.operationType ?? 0;
    message.sourceParent = object.sourceParent ?? "";
    message.destinationParent = object.destinationParent ?? "";
    return message;
  },
};

/**
 * Manages Cloud Resource Folders.
 * Cloud Resource Folders can be used to organize the resources under an
 * organization and to control the IAM policies applied to groups of resources.
 */
export type FoldersDefinition = typeof FoldersDefinition;
export const FoldersDefinition = {
  name: "Folders",
  fullName: "google.cloud.resourcemanager.v2.Folders",
  methods: {
    /**
     * Lists the Folders that are direct descendants of supplied parent resource.
     * List provides a strongly consistent view of the Folders underneath
     * the specified parent resource.
     * List returns Folders sorted based upon the (ascending) lexical ordering
     * of their display_name.
     * The caller must have `resourcemanager.folders.list` permission on the
     * identified parent.
     */
    listFolders: {
      name: "ListFolders",
      requestType: ListFoldersRequest,
      requestStream: false,
      responseType: ListFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              104,
              111,
              119,
              95,
              100,
              101,
              108,
              101,
              116,
              101,
              100,
            ]),
          ],
          578365826: [Buffer.from([13, 18, 11, 47, 118, 50, 47, 102, 111, 108, 100, 101, 114, 115])],
        },
      },
    },
    /**
     * Search for folders that match specific filter criteria.
     * Search provides an eventually consistent view of the folders a user has
     * access to which meet the specified filter criteria.
     *
     * This will only return folders on which the caller has the
     * permission `resourcemanager.folders.get`.
     */
    searchFolders: {
      name: "SearchFolders",
      requestType: SearchFoldersRequest,
      requestStream: false,
      responseType: SearchFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              23,
              58,
              1,
              42,
              34,
              18,
              47,
              118,
              50,
              47,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a Folder identified by the supplied resource name.
     * Valid Folder resource names have the format `folders/{folder_id}`
     * (for example, `folders/1234`).
     * The caller must have `resourcemanager.folders.get` permission on the
     * identified folder.
     */
    getFolder: {
      name: "GetFolder",
      requestType: GetFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              22,
              18,
              20,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a Folder in the resource hierarchy.
     * Returns an Operation which can be used to track the progress of the
     * folder creation workflow.
     * Upon success the Operation.response field will be populated with the
     * created Folder.
     *
     * In order to succeed, the addition of this new Folder must not violate
     * the Folder naming, height or fanout constraints.
     *
     * + The Folder's display_name must be distinct from all other Folder's that
     * share its parent.
     * + The addition of the Folder must not cause the active Folder hierarchy
     * to exceed a height of 4. Note, the full active + deleted Folder hierarchy
     * is allowed to reach a height of 8; this provides additional headroom when
     * moving folders that contain deleted folders.
     * + The addition of the Folder must not cause the total number of Folders
     * under its parent to exceed 100.
     *
     * If the operation fails due to a folder constraint violation, some errors
     * may be returned by the CreateFolder request, with status code
     * FAILED_PRECONDITION and an error description. Other folder constraint
     * violations will be communicated in the Operation, with the specific
     * PreconditionFailure returned via the details list in the Operation.error
     * field.
     *
     * The caller must have `resourcemanager.folders.create` permission on the
     * identified parent.
     */
    createFolder: {
      name: "CreateFolder",
      requestType: CreateFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              15,
              70,
              111,
              108,
              100,
              101,
              114,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 102, 111, 108, 100, 101, 114])],
          578365826: [
            Buffer.from([
              21,
              58,
              6,
              102,
              111,
              108,
              100,
              101,
              114,
              34,
              11,
              47,
              118,
              50,
              47,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a Folder, changing its display_name.
     * Changes to the folder display_name will be rejected if they violate either
     * the display_name formatting rules or naming constraints described in
     * the [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
     *
     * The Folder's display name must start and end with a letter or digit,
     * may contain letters, digits, spaces, hyphens and underscores and can be
     * no longer than 30 characters. This is captured by the regular expression:
     * [\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?.
     * The caller must have `resourcemanager.folders.update` permission on the
     * identified folder.
     *
     * If the update fails due to the unique name constraint then a
     * PreconditionFailure explaining this violation will be returned
     * in the Status.details field.
     */
    updateFolder: {
      name: "UpdateFolder",
      requestType: UpdateFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 102, 111, 108, 100, 101, 114, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              37,
              58,
              6,
              102,
              111,
              108,
              100,
              101,
              114,
              50,
              27,
              47,
              118,
              50,
              47,
              123,
              102,
              111,
              108,
              100,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Moves a Folder under a new resource parent.
     * Returns an Operation which can be used to track the progress of the
     * folder move workflow.
     * Upon success the Operation.response field will be populated with the
     * moved Folder.
     * Upon failure, a FolderOperationError categorizing the failure cause will
     * be returned - if the failure occurs synchronously then the
     * FolderOperationError will be returned via the Status.details field
     * and if it occurs asynchronously then the FolderOperation will be returned
     * via the Operation.error field.
     * In addition, the Operation.metadata field will be populated with a
     * FolderOperation message as an aid to stateless clients.
     * Folder moves will be rejected if they violate either the naming, height
     * or fanout constraints described in the
     * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
     * The caller must have `resourcemanager.folders.move` permission on the
     * folder's current and proposed new parent.
     */
    moveFolder: {
      name: "MoveFolder",
      requestType: MoveFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              15,
              70,
              111,
              108,
              100,
              101,
              114,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              110,
              97,
              109,
              101,
              44,
              100,
              101,
              115,
              116,
              105,
              110,
              97,
              116,
              105,
              111,
              110,
              95,
              112,
              97,
              114,
              101,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              30,
              58,
              1,
              42,
              34,
              25,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Requests deletion of a Folder. The Folder is moved into the
     * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state
     * immediately, and is deleted approximately 30 days later. This method may
     * only be called on an empty Folder in the
     * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state, where a Folder is empty if
     * it doesn't contain any Folders or Projects in the
     * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
     * The caller must have `resourcemanager.folders.delete` permission on the
     * identified folder.
     */
    deleteFolder: {
      name: "DeleteFolder",
      requestType: DeleteFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([4, 110, 97, 109, 101]),
            Buffer.from([
              21,
              110,
              97,
              109,
              101,
              44,
              114,
              101,
              99,
              117,
              114,
              115,
              105,
              118,
              101,
              95,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              22,
              42,
              20,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Cancels the deletion request for a Folder. This method may only be
     * called on a Folder in the
     * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state.
     * In order to succeed, the Folder's parent must be in the
     * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
     * In addition, reintroducing the folder into the tree must not violate
     * folder naming, height and fanout constraints described in the
     * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
     * The caller must have `resourcemanager.folders.undelete` permission on the
     * identified folder.
     */
    undeleteFolder: {
      name: "UndeleteFolder",
      requestType: UndeleteFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              34,
              58,
              1,
              42,
              34,
              29,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the access control policy for a Folder. The returned policy may be
     * empty if no such policy or resource exists. The `resource` field should
     * be the Folder's resource name, e.g. "folders/1234".
     * The caller must have `resourcemanager.folders.getIamPolicy` permission
     * on the identified folder.
     */
    getIamPolicy: {
      name: "GetIamPolicy",
      requestType: GetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([8, 114, 101, 115, 111, 117, 114, 99, 101])],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the access control policy on a Folder, replacing any existing policy.
     * The `resource` field should be the Folder's resource name, e.g.
     * "folders/1234".
     * The caller must have `resourcemanager.folders.setIamPolicy` permission
     * on the identified folder.
     */
    setIamPolicy: {
      name: "SetIamPolicy",
      requestType: SetIamPolicyRequest,
      requestStream: false,
      responseType: Policy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 114, 101, 115, 111, 117, 114, 99, 101, 44, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              73,
              97,
              109,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Returns permissions that a caller has on the specified Folder.
     * The `resource` field should be the Folder's resource name,
     * e.g. "folders/1234".
     *
     * There are no permissions required for making this API call.
     */
    testIamPermissions: {
      name: "TestIamPermissions",
      requestType: TestIamPermissionsRequest,
      requestStream: false,
      responseType: TestIamPermissionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              112,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              48,
              58,
              1,
              42,
              34,
              43,
              47,
              118,
              50,
              47,
              123,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              116,
              101,
              115,
              116,
              73,
              97,
              109,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FoldersServiceImplementation<CallContextExt = {}> {
  /**
   * Lists the Folders that are direct descendants of supplied parent resource.
   * List provides a strongly consistent view of the Folders underneath
   * the specified parent resource.
   * List returns Folders sorted based upon the (ascending) lexical ordering
   * of their display_name.
   * The caller must have `resourcemanager.folders.list` permission on the
   * identified parent.
   */
  listFolders(
    request: ListFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFoldersResponse>>;
  /**
   * Search for folders that match specific filter criteria.
   * Search provides an eventually consistent view of the folders a user has
   * access to which meet the specified filter criteria.
   *
   * This will only return folders on which the caller has the
   * permission `resourcemanager.folders.get`.
   */
  searchFolders(
    request: SearchFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchFoldersResponse>>;
  /**
   * Retrieves a Folder identified by the supplied resource name.
   * Valid Folder resource names have the format `folders/{folder_id}`
   * (for example, `folders/1234`).
   * The caller must have `resourcemanager.folders.get` permission on the
   * identified folder.
   */
  getFolder(request: GetFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Creates a Folder in the resource hierarchy.
   * Returns an Operation which can be used to track the progress of the
   * folder creation workflow.
   * Upon success the Operation.response field will be populated with the
   * created Folder.
   *
   * In order to succeed, the addition of this new Folder must not violate
   * the Folder naming, height or fanout constraints.
   *
   * + The Folder's display_name must be distinct from all other Folder's that
   * share its parent.
   * + The addition of the Folder must not cause the active Folder hierarchy
   * to exceed a height of 4. Note, the full active + deleted Folder hierarchy
   * is allowed to reach a height of 8; this provides additional headroom when
   * moving folders that contain deleted folders.
   * + The addition of the Folder must not cause the total number of Folders
   * under its parent to exceed 100.
   *
   * If the operation fails due to a folder constraint violation, some errors
   * may be returned by the CreateFolder request, with status code
   * FAILED_PRECONDITION and an error description. Other folder constraint
   * violations will be communicated in the Operation, with the specific
   * PreconditionFailure returned via the details list in the Operation.error
   * field.
   *
   * The caller must have `resourcemanager.folders.create` permission on the
   * identified parent.
   */
  createFolder(request: CreateFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Updates a Folder, changing its display_name.
   * Changes to the folder display_name will be rejected if they violate either
   * the display_name formatting rules or naming constraints described in
   * the [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   *
   * The Folder's display name must start and end with a letter or digit,
   * may contain letters, digits, spaces, hyphens and underscores and can be
   * no longer than 30 characters. This is captured by the regular expression:
   * [\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?.
   * The caller must have `resourcemanager.folders.update` permission on the
   * identified folder.
   *
   * If the update fails due to the unique name constraint then a
   * PreconditionFailure explaining this violation will be returned
   * in the Status.details field.
   */
  updateFolder(request: UpdateFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Moves a Folder under a new resource parent.
   * Returns an Operation which can be used to track the progress of the
   * folder move workflow.
   * Upon success the Operation.response field will be populated with the
   * moved Folder.
   * Upon failure, a FolderOperationError categorizing the failure cause will
   * be returned - if the failure occurs synchronously then the
   * FolderOperationError will be returned via the Status.details field
   * and if it occurs asynchronously then the FolderOperation will be returned
   * via the Operation.error field.
   * In addition, the Operation.metadata field will be populated with a
   * FolderOperation message as an aid to stateless clients.
   * Folder moves will be rejected if they violate either the naming, height
   * or fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   * The caller must have `resourcemanager.folders.move` permission on the
   * folder's current and proposed new parent.
   */
  moveFolder(request: MoveFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Requests deletion of a Folder. The Folder is moved into the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state
   * immediately, and is deleted approximately 30 days later. This method may
   * only be called on an empty Folder in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state, where a Folder is empty if
   * it doesn't contain any Folders or Projects in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
   * The caller must have `resourcemanager.folders.delete` permission on the
   * identified folder.
   */
  deleteFolder(request: DeleteFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Cancels the deletion request for a Folder. This method may only be
   * called on a Folder in the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state.
   * In order to succeed, the Folder's parent must be in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
   * In addition, reintroducing the folder into the tree must not violate
   * folder naming, height and fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   * The caller must have `resourcemanager.folders.undelete` permission on the
   * identified folder.
   */
  undeleteFolder(request: UndeleteFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Gets the access control policy for a Folder. The returned policy may be
   * empty if no such policy or resource exists. The `resource` field should
   * be the Folder's resource name, e.g. "folders/1234".
   * The caller must have `resourcemanager.folders.getIamPolicy` permission
   * on the identified folder.
   */
  getIamPolicy(request: GetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Sets the access control policy on a Folder, replacing any existing policy.
   * The `resource` field should be the Folder's resource name, e.g.
   * "folders/1234".
   * The caller must have `resourcemanager.folders.setIamPolicy` permission
   * on the identified folder.
   */
  setIamPolicy(request: SetIamPolicyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Policy>>;
  /**
   * Returns permissions that a caller has on the specified Folder.
   * The `resource` field should be the Folder's resource name,
   * e.g. "folders/1234".
   *
   * There are no permissions required for making this API call.
   */
  testIamPermissions(
    request: TestIamPermissionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TestIamPermissionsResponse>>;
}

export interface FoldersClient<CallOptionsExt = {}> {
  /**
   * Lists the Folders that are direct descendants of supplied parent resource.
   * List provides a strongly consistent view of the Folders underneath
   * the specified parent resource.
   * List returns Folders sorted based upon the (ascending) lexical ordering
   * of their display_name.
   * The caller must have `resourcemanager.folders.list` permission on the
   * identified parent.
   */
  listFolders(
    request: DeepPartial<ListFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFoldersResponse>;
  /**
   * Search for folders that match specific filter criteria.
   * Search provides an eventually consistent view of the folders a user has
   * access to which meet the specified filter criteria.
   *
   * This will only return folders on which the caller has the
   * permission `resourcemanager.folders.get`.
   */
  searchFolders(
    request: DeepPartial<SearchFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchFoldersResponse>;
  /**
   * Retrieves a Folder identified by the supplied resource name.
   * Valid Folder resource names have the format `folders/{folder_id}`
   * (for example, `folders/1234`).
   * The caller must have `resourcemanager.folders.get` permission on the
   * identified folder.
   */
  getFolder(request: DeepPartial<GetFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Creates a Folder in the resource hierarchy.
   * Returns an Operation which can be used to track the progress of the
   * folder creation workflow.
   * Upon success the Operation.response field will be populated with the
   * created Folder.
   *
   * In order to succeed, the addition of this new Folder must not violate
   * the Folder naming, height or fanout constraints.
   *
   * + The Folder's display_name must be distinct from all other Folder's that
   * share its parent.
   * + The addition of the Folder must not cause the active Folder hierarchy
   * to exceed a height of 4. Note, the full active + deleted Folder hierarchy
   * is allowed to reach a height of 8; this provides additional headroom when
   * moving folders that contain deleted folders.
   * + The addition of the Folder must not cause the total number of Folders
   * under its parent to exceed 100.
   *
   * If the operation fails due to a folder constraint violation, some errors
   * may be returned by the CreateFolder request, with status code
   * FAILED_PRECONDITION and an error description. Other folder constraint
   * violations will be communicated in the Operation, with the specific
   * PreconditionFailure returned via the details list in the Operation.error
   * field.
   *
   * The caller must have `resourcemanager.folders.create` permission on the
   * identified parent.
   */
  createFolder(request: DeepPartial<CreateFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Updates a Folder, changing its display_name.
   * Changes to the folder display_name will be rejected if they violate either
   * the display_name formatting rules or naming constraints described in
   * the [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   *
   * The Folder's display name must start and end with a letter or digit,
   * may contain letters, digits, spaces, hyphens and underscores and can be
   * no longer than 30 characters. This is captured by the regular expression:
   * [\p{L}\p{N}]([\p{L}\p{N}_- ]{0,28}[\p{L}\p{N}])?.
   * The caller must have `resourcemanager.folders.update` permission on the
   * identified folder.
   *
   * If the update fails due to the unique name constraint then a
   * PreconditionFailure explaining this violation will be returned
   * in the Status.details field.
   */
  updateFolder(request: DeepPartial<UpdateFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Moves a Folder under a new resource parent.
   * Returns an Operation which can be used to track the progress of the
   * folder move workflow.
   * Upon success the Operation.response field will be populated with the
   * moved Folder.
   * Upon failure, a FolderOperationError categorizing the failure cause will
   * be returned - if the failure occurs synchronously then the
   * FolderOperationError will be returned via the Status.details field
   * and if it occurs asynchronously then the FolderOperation will be returned
   * via the Operation.error field.
   * In addition, the Operation.metadata field will be populated with a
   * FolderOperation message as an aid to stateless clients.
   * Folder moves will be rejected if they violate either the naming, height
   * or fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   * The caller must have `resourcemanager.folders.move` permission on the
   * folder's current and proposed new parent.
   */
  moveFolder(request: DeepPartial<MoveFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Requests deletion of a Folder. The Folder is moved into the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state
   * immediately, and is deleted approximately 30 days later. This method may
   * only be called on an empty Folder in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state, where a Folder is empty if
   * it doesn't contain any Folders or Projects in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
   * The caller must have `resourcemanager.folders.delete` permission on the
   * identified folder.
   */
  deleteFolder(request: DeepPartial<DeleteFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Cancels the deletion request for a Folder. This method may only be
   * called on a Folder in the
   * [DELETE_REQUESTED][google.cloud.resourcemanager.v2.Folder.LifecycleState.DELETE_REQUESTED] state.
   * In order to succeed, the Folder's parent must be in the
   * [ACTIVE][google.cloud.resourcemanager.v2.Folder.LifecycleState.ACTIVE] state.
   * In addition, reintroducing the folder into the tree must not violate
   * folder naming, height and fanout constraints described in the
   * [CreateFolder][google.cloud.resourcemanager.v2.Folders.CreateFolder] documentation.
   * The caller must have `resourcemanager.folders.undelete` permission on the
   * identified folder.
   */
  undeleteFolder(request: DeepPartial<UndeleteFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Gets the access control policy for a Folder. The returned policy may be
   * empty if no such policy or resource exists. The `resource` field should
   * be the Folder's resource name, e.g. "folders/1234".
   * The caller must have `resourcemanager.folders.getIamPolicy` permission
   * on the identified folder.
   */
  getIamPolicy(request: DeepPartial<GetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Sets the access control policy on a Folder, replacing any existing policy.
   * The `resource` field should be the Folder's resource name, e.g.
   * "folders/1234".
   * The caller must have `resourcemanager.folders.setIamPolicy` permission
   * on the identified folder.
   */
  setIamPolicy(request: DeepPartial<SetIamPolicyRequest>, options?: CallOptions & CallOptionsExt): Promise<Policy>;
  /**
   * Returns permissions that a caller has on the specified Folder.
   * The `resource` field should be the Folder's resource name,
   * e.g. "folders/1234".
   *
   * There are no permissions required for making this API call.
   */
  testIamPermissions(
    request: DeepPartial<TestIamPermissionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TestIamPermissionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
