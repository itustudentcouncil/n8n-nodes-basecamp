// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkehub/v1beta/configmanagement/configmanagement.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.gkehub.configmanagement.v1beta";

/** Enum representing the state of an ACM's deployment on a cluster */
export enum DeploymentState {
  /** DEPLOYMENT_STATE_UNSPECIFIED - Deployment's state cannot be determined */
  DEPLOYMENT_STATE_UNSPECIFIED = 0,
  /** NOT_INSTALLED - Deployment is not installed */
  NOT_INSTALLED = 1,
  /** INSTALLED - Deployment is installed */
  INSTALLED = 2,
  /** ERROR - Deployment was attempted to be installed, but has errors */
  ERROR = 3,
  UNRECOGNIZED = -1,
}

export function deploymentStateFromJSON(object: any): DeploymentState {
  switch (object) {
    case 0:
    case "DEPLOYMENT_STATE_UNSPECIFIED":
      return DeploymentState.DEPLOYMENT_STATE_UNSPECIFIED;
    case 1:
    case "NOT_INSTALLED":
      return DeploymentState.NOT_INSTALLED;
    case 2:
    case "INSTALLED":
      return DeploymentState.INSTALLED;
    case 3:
    case "ERROR":
      return DeploymentState.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeploymentState.UNRECOGNIZED;
  }
}

export function deploymentStateToJSON(object: DeploymentState): string {
  switch (object) {
    case DeploymentState.DEPLOYMENT_STATE_UNSPECIFIED:
      return "DEPLOYMENT_STATE_UNSPECIFIED";
    case DeploymentState.NOT_INSTALLED:
      return "NOT_INSTALLED";
    case DeploymentState.INSTALLED:
      return "INSTALLED";
    case DeploymentState.ERROR:
      return "ERROR";
    case DeploymentState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** *Anthos Config Management**: State for a single cluster. */
export interface MembershipState {
  /**
   * The user-defined name for the cluster used by ClusterSelectors to group
   * clusters together. This should match Membership's membership_name,
   * unless the user installed ACM on the cluster manually prior to enabling
   * the ACM hub feature.
   * Unique within a Anthos Config Management installation.
   */
  clusterName: string;
  /**
   * Membership configuration in the cluster. This represents the actual state
   * in the cluster, while the MembershipSpec in the FeatureSpec represents
   * the intended state
   */
  membershipSpec:
    | MembershipSpec
    | undefined;
  /** Current install status of ACM's Operator */
  operatorState:
    | OperatorState
    | undefined;
  /** Current sync status */
  configSyncState:
    | ConfigSyncState
    | undefined;
  /** PolicyController status */
  policyControllerState:
    | PolicyControllerState
    | undefined;
  /** Binauthz status */
  binauthzState:
    | BinauthzState
    | undefined;
  /** Hierarchy Controller status */
  hierarchyControllerState: HierarchyControllerState | undefined;
}

/**
 * *Anthos Config Management**: Configuration for a single cluster.
 * Intended to parallel the ConfigManagement CR.
 */
export interface MembershipSpec {
  /** Config Sync configuration for the cluster. */
  configSync:
    | ConfigSync
    | undefined;
  /** Policy Controller configuration for the cluster. */
  policyController:
    | PolicyController
    | undefined;
  /** Binauthz conifguration for the cluster. */
  binauthz:
    | BinauthzConfig
    | undefined;
  /** Hierarchy Controller configuration for the cluster. */
  hierarchyController:
    | HierarchyControllerConfig
    | undefined;
  /** Version of ACM installed. */
  version: string;
}

/** Configuration for Config Sync */
export interface ConfigSync {
  /** Git repo configuration for the cluster. */
  git:
    | GitConfig
    | undefined;
  /**
   * Specifies whether the Config Sync Repo is
   * in “hierarchical” or “unstructured” mode.
   */
  sourceFormat: string;
}

/** Git repo configuration for a single cluster. */
export interface GitConfig {
  /** The URL of the Git repository to use as the source of truth. */
  syncRepo: string;
  /** The branch of the repository to sync from. Default: master. */
  syncBranch: string;
  /**
   * The path within the Git repository that represents the top level of the
   * repo to sync. Default: the root directory of the repository.
   */
  policyDir: string;
  /** Period in seconds between consecutive syncs. Default: 15. */
  syncWaitSecs: Long;
  /** Git revision (tag or hash) to check out. Default HEAD. */
  syncRev: string;
  /** Type of secret configured for access to the Git repo. */
  secretType: string;
  /** URL for the HTTPS proxy to be used when communicating with the Git repo. */
  httpsProxy: string;
  /**
   * The GCP Service Account Email used for auth when secret_type is
   * gcpServiceAccount.
   */
  gcpServiceAccountEmail: string;
}

/** Configuration for Policy Controller */
export interface PolicyController {
  /**
   * Enables the installation of Policy Controller.
   * If false, the rest of PolicyController fields take no
   * effect.
   */
  enabled: boolean;
  /** Installs the default template library along with Policy Controller. */
  templateLibraryInstalled?:
    | boolean
    | undefined;
  /**
   * Sets the interval for Policy Controller Audit Scans (in seconds).
   * When set to 0, this disables audit functionality altogether.
   */
  auditIntervalSeconds?:
    | Long
    | undefined;
  /**
   * The set of namespaces that are excluded from Policy Controller checks.
   * Namespaces do not need to currently exist on the cluster.
   */
  exemptableNamespaces: string[];
  /**
   * Enables the ability to use Constraint Templates that reference to objects
   * other than the object currently being evaluated.
   */
  referentialRulesEnabled: boolean;
  /** Logs all denies and dry run failures. */
  logDeniesEnabled: boolean;
}

/** Configuration for Binauthz */
export interface BinauthzConfig {
  /** Whether binauthz is enabled in this cluster. */
  enabled: boolean;
}

/** Configuration for Hierarchy Controller */
export interface HierarchyControllerConfig {
  /** Whether Hierarchy Controller is enabled in this cluster. */
  enabled: boolean;
  /** Whether pod tree labels are enabled in this cluster. */
  enablePodTreeLabels: boolean;
  /** Whether hierarchical resource quota is enabled in this cluster. */
  enableHierarchicalResourceQuota: boolean;
}

/** Deployment state for Hierarchy Controller */
export interface HierarchyControllerDeploymentState {
  /** The deployment state for open source HNC (e.g. v0.7.0-hc.0) */
  hnc: DeploymentState;
  /** The deployment state for Hierarchy Controller extension (e.g. v0.7.0-hc.1) */
  extension: DeploymentState;
}

/** Version for Hierarchy Controller */
export interface HierarchyControllerVersion {
  /** Version for open source HNC */
  hnc: string;
  /** Version for Hierarchy Controller extension */
  extension: string;
}

/** State for Hierarchy Controller */
export interface HierarchyControllerState {
  /** The version for Hierarchy Controller */
  version:
    | HierarchyControllerVersion
    | undefined;
  /** The deployment state for Hierarchy Controller */
  state: HierarchyControllerDeploymentState | undefined;
}

/** State information for an ACM's Operator */
export interface OperatorState {
  /** The semenatic version number of the operator */
  version: string;
  /** The state of the Operator's deployment */
  deploymentState: DeploymentState;
  /** Install errors. */
  errors: InstallError[];
}

/** Errors pertaining to the installation of ACM */
export interface InstallError {
  /** A string representing the user facing error message */
  errorMessage: string;
}

/** State information for ConfigSync */
export interface ConfigSyncState {
  /** The version of ConfigSync deployed */
  version:
    | ConfigSyncVersion
    | undefined;
  /**
   * Information about the deployment of ConfigSync, including the version
   * of the various Pods deployed
   */
  deploymentState:
    | ConfigSyncDeploymentState
    | undefined;
  /** The state of ConfigSync's process to sync configs to a cluster */
  syncState: SyncState | undefined;
}

/** Specific versioning information pertaining to ConfigSync's Pods */
export interface ConfigSyncVersion {
  /** Version of the deployed importer pod */
  importer: string;
  /** Version of the deployed syncer pod */
  syncer: string;
  /** Version of the deployed git-sync pod */
  gitSync: string;
  /** Version of the deployed monitor pod */
  monitor: string;
  /** Version of the deployed reconciler-manager pod */
  reconcilerManager: string;
  /** Version of the deployed reconciler container in root-reconciler pod */
  rootReconciler: string;
}

/** The state of ConfigSync's deployment on a cluster */
export interface ConfigSyncDeploymentState {
  /** Deployment state of the importer pod */
  importer: DeploymentState;
  /** Deployment state of the syncer pod */
  syncer: DeploymentState;
  /** Deployment state of the git-sync pod */
  gitSync: DeploymentState;
  /** Deployment state of the monitor pod */
  monitor: DeploymentState;
  /** Deployment state of reconciler-manager pod */
  reconcilerManager: DeploymentState;
  /** Deployment state of root-reconciler */
  rootReconciler: DeploymentState;
}

/** State indicating an ACM's progress syncing configurations to a cluster */
export interface SyncState {
  /** Token indicating the state of the repo. */
  sourceToken: string;
  /** Token indicating the state of the importer. */
  importToken: string;
  /** Token indicating the state of the syncer. */
  syncToken: string;
  /**
   * Deprecated: use last_sync_time instead.
   * Timestamp of when ACM last successfully synced the repo
   * The time format is specified in https://golang.org/pkg/time/#Time.String
   *
   * @deprecated
   */
  lastSync: string;
  /** Timestamp type of when ACM last successfully synced the repo */
  lastSyncTime:
    | Date
    | undefined;
  /** Sync status code */
  code: SyncState_SyncCode;
  /**
   * A list of errors resulting from problematic configs.
   * This list will be truncated after 100 errors, although it is
   * unlikely for that many errors to simultaneously exist.
   */
  errors: SyncError[];
}

/** An enum representing an ACM's status syncing configs to a cluster */
export enum SyncState_SyncCode {
  /** SYNC_CODE_UNSPECIFIED - ACM cannot determine a sync code */
  SYNC_CODE_UNSPECIFIED = 0,
  /** SYNCED - ACM successfully synced the git Repo with the cluster */
  SYNCED = 1,
  /** PENDING - ACM is in the progress of syncing a new change */
  PENDING = 2,
  /** ERROR - Indicates an error configuring ACM, and user action is required */
  ERROR = 3,
  /**
   * NOT_CONFIGURED - ACM has been installed (operator manifest deployed),
   * but not configured.
   */
  NOT_CONFIGURED = 4,
  /** NOT_INSTALLED - ACM has not been installed (no operator pod found) */
  NOT_INSTALLED = 5,
  /** UNAUTHORIZED - Error authorizing with the cluster */
  UNAUTHORIZED = 6,
  /** UNREACHABLE - Cluster could not be reached */
  UNREACHABLE = 7,
  UNRECOGNIZED = -1,
}

export function syncState_SyncCodeFromJSON(object: any): SyncState_SyncCode {
  switch (object) {
    case 0:
    case "SYNC_CODE_UNSPECIFIED":
      return SyncState_SyncCode.SYNC_CODE_UNSPECIFIED;
    case 1:
    case "SYNCED":
      return SyncState_SyncCode.SYNCED;
    case 2:
    case "PENDING":
      return SyncState_SyncCode.PENDING;
    case 3:
    case "ERROR":
      return SyncState_SyncCode.ERROR;
    case 4:
    case "NOT_CONFIGURED":
      return SyncState_SyncCode.NOT_CONFIGURED;
    case 5:
    case "NOT_INSTALLED":
      return SyncState_SyncCode.NOT_INSTALLED;
    case 6:
    case "UNAUTHORIZED":
      return SyncState_SyncCode.UNAUTHORIZED;
    case 7:
    case "UNREACHABLE":
      return SyncState_SyncCode.UNREACHABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SyncState_SyncCode.UNRECOGNIZED;
  }
}

export function syncState_SyncCodeToJSON(object: SyncState_SyncCode): string {
  switch (object) {
    case SyncState_SyncCode.SYNC_CODE_UNSPECIFIED:
      return "SYNC_CODE_UNSPECIFIED";
    case SyncState_SyncCode.SYNCED:
      return "SYNCED";
    case SyncState_SyncCode.PENDING:
      return "PENDING";
    case SyncState_SyncCode.ERROR:
      return "ERROR";
    case SyncState_SyncCode.NOT_CONFIGURED:
      return "NOT_CONFIGURED";
    case SyncState_SyncCode.NOT_INSTALLED:
      return "NOT_INSTALLED";
    case SyncState_SyncCode.UNAUTHORIZED:
      return "UNAUTHORIZED";
    case SyncState_SyncCode.UNREACHABLE:
      return "UNREACHABLE";
    case SyncState_SyncCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An ACM created error representing a problem syncing configurations */
export interface SyncError {
  /** An ACM defined error code */
  code: string;
  /** A description of the error */
  errorMessage: string;
  /** A list of config(s) associated with the error, if any */
  errorResources: ErrorResource[];
}

/** Model for a config file in the git repo with an associated Sync error */
export interface ErrorResource {
  /** Path in the git repo of the erroneous config */
  sourcePath: string;
  /** Metadata name of the resource that is causing an error */
  resourceName: string;
  /** Namespace of the resource that is causing an error */
  resourceNamespace: string;
  /** Group/version/kind of the resource that is causing an error */
  resourceGvk: GroupVersionKind | undefined;
}

/** A Kubernetes object's GVK */
export interface GroupVersionKind {
  /** Kubernetes Group */
  group: string;
  /** Kubernetes Version */
  version: string;
  /** Kubernetes Kind */
  kind: string;
}

/** State for PolicyControllerState. */
export interface PolicyControllerState {
  /** The version of Gatekeeper Policy Controller deployed. */
  version:
    | PolicyControllerVersion
    | undefined;
  /** The state about the policy controller installation. */
  deploymentState: GatekeeperDeploymentState | undefined;
}

/** The build version of Gatekeeper Policy Controller is using. */
export interface PolicyControllerVersion {
  /**
   * The gatekeeper image tag that is composed of ACM version, git tag, build
   * number.
   */
  version: string;
}

/** State for Binauthz */
export interface BinauthzState {
  /** The state of the binauthz webhook. */
  webhook: DeploymentState;
  /** The version of binauthz that is installed. */
  version: BinauthzVersion | undefined;
}

/** The version of binauthz. */
export interface BinauthzVersion {
  /** The version of the binauthz webhook. */
  webhookVersion: string;
}

/** State of Policy Controller installation. */
export interface GatekeeperDeploymentState {
  /** Status of gatekeeper-controller-manager pod. */
  gatekeeperControllerManagerState: DeploymentState;
  /** Status of gatekeeper-audit deployment. */
  gatekeeperAudit: DeploymentState;
}

function createBaseMembershipState(): MembershipState {
  return {
    clusterName: "",
    membershipSpec: undefined,
    operatorState: undefined,
    configSyncState: undefined,
    policyControllerState: undefined,
    binauthzState: undefined,
    hierarchyControllerState: undefined,
  };
}

export const MembershipState: MessageFns<MembershipState> = {
  encode(message: MembershipState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterName !== "") {
      writer.uint32(10).string(message.clusterName);
    }
    if (message.membershipSpec !== undefined) {
      MembershipSpec.encode(message.membershipSpec, writer.uint32(18).fork()).join();
    }
    if (message.operatorState !== undefined) {
      OperatorState.encode(message.operatorState, writer.uint32(26).fork()).join();
    }
    if (message.configSyncState !== undefined) {
      ConfigSyncState.encode(message.configSyncState, writer.uint32(34).fork()).join();
    }
    if (message.policyControllerState !== undefined) {
      PolicyControllerState.encode(message.policyControllerState, writer.uint32(42).fork()).join();
    }
    if (message.binauthzState !== undefined) {
      BinauthzState.encode(message.binauthzState, writer.uint32(50).fork()).join();
    }
    if (message.hierarchyControllerState !== undefined) {
      HierarchyControllerState.encode(message.hierarchyControllerState, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusterName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membershipSpec = MembershipSpec.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operatorState = OperatorState.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.configSyncState = ConfigSyncState.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.policyControllerState = PolicyControllerState.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.binauthzState = BinauthzState.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hierarchyControllerState = HierarchyControllerState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipState {
    return {
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
      membershipSpec: isSet(object.membershipSpec) ? MembershipSpec.fromJSON(object.membershipSpec) : undefined,
      operatorState: isSet(object.operatorState) ? OperatorState.fromJSON(object.operatorState) : undefined,
      configSyncState: isSet(object.configSyncState) ? ConfigSyncState.fromJSON(object.configSyncState) : undefined,
      policyControllerState: isSet(object.policyControllerState)
        ? PolicyControllerState.fromJSON(object.policyControllerState)
        : undefined,
      binauthzState: isSet(object.binauthzState) ? BinauthzState.fromJSON(object.binauthzState) : undefined,
      hierarchyControllerState: isSet(object.hierarchyControllerState)
        ? HierarchyControllerState.fromJSON(object.hierarchyControllerState)
        : undefined,
    };
  },

  toJSON(message: MembershipState): unknown {
    const obj: any = {};
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    if (message.membershipSpec !== undefined) {
      obj.membershipSpec = MembershipSpec.toJSON(message.membershipSpec);
    }
    if (message.operatorState !== undefined) {
      obj.operatorState = OperatorState.toJSON(message.operatorState);
    }
    if (message.configSyncState !== undefined) {
      obj.configSyncState = ConfigSyncState.toJSON(message.configSyncState);
    }
    if (message.policyControllerState !== undefined) {
      obj.policyControllerState = PolicyControllerState.toJSON(message.policyControllerState);
    }
    if (message.binauthzState !== undefined) {
      obj.binauthzState = BinauthzState.toJSON(message.binauthzState);
    }
    if (message.hierarchyControllerState !== undefined) {
      obj.hierarchyControllerState = HierarchyControllerState.toJSON(message.hierarchyControllerState);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipState>): MembershipState {
    return MembershipState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipState>): MembershipState {
    const message = createBaseMembershipState();
    message.clusterName = object.clusterName ?? "";
    message.membershipSpec = (object.membershipSpec !== undefined && object.membershipSpec !== null)
      ? MembershipSpec.fromPartial(object.membershipSpec)
      : undefined;
    message.operatorState = (object.operatorState !== undefined && object.operatorState !== null)
      ? OperatorState.fromPartial(object.operatorState)
      : undefined;
    message.configSyncState = (object.configSyncState !== undefined && object.configSyncState !== null)
      ? ConfigSyncState.fromPartial(object.configSyncState)
      : undefined;
    message.policyControllerState =
      (object.policyControllerState !== undefined && object.policyControllerState !== null)
        ? PolicyControllerState.fromPartial(object.policyControllerState)
        : undefined;
    message.binauthzState = (object.binauthzState !== undefined && object.binauthzState !== null)
      ? BinauthzState.fromPartial(object.binauthzState)
      : undefined;
    message.hierarchyControllerState =
      (object.hierarchyControllerState !== undefined && object.hierarchyControllerState !== null)
        ? HierarchyControllerState.fromPartial(object.hierarchyControllerState)
        : undefined;
    return message;
  },
};

function createBaseMembershipSpec(): MembershipSpec {
  return {
    configSync: undefined,
    policyController: undefined,
    binauthz: undefined,
    hierarchyController: undefined,
    version: "",
  };
}

export const MembershipSpec: MessageFns<MembershipSpec> = {
  encode(message: MembershipSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.configSync !== undefined) {
      ConfigSync.encode(message.configSync, writer.uint32(10).fork()).join();
    }
    if (message.policyController !== undefined) {
      PolicyController.encode(message.policyController, writer.uint32(18).fork()).join();
    }
    if (message.binauthz !== undefined) {
      BinauthzConfig.encode(message.binauthz, writer.uint32(26).fork()).join();
    }
    if (message.hierarchyController !== undefined) {
      HierarchyControllerConfig.encode(message.hierarchyController, writer.uint32(34).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(82).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.configSync = ConfigSync.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policyController = PolicyController.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.binauthz = BinauthzConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hierarchyController = HierarchyControllerConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipSpec {
    return {
      configSync: isSet(object.configSync) ? ConfigSync.fromJSON(object.configSync) : undefined,
      policyController: isSet(object.policyController) ? PolicyController.fromJSON(object.policyController) : undefined,
      binauthz: isSet(object.binauthz) ? BinauthzConfig.fromJSON(object.binauthz) : undefined,
      hierarchyController: isSet(object.hierarchyController)
        ? HierarchyControllerConfig.fromJSON(object.hierarchyController)
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: MembershipSpec): unknown {
    const obj: any = {};
    if (message.configSync !== undefined) {
      obj.configSync = ConfigSync.toJSON(message.configSync);
    }
    if (message.policyController !== undefined) {
      obj.policyController = PolicyController.toJSON(message.policyController);
    }
    if (message.binauthz !== undefined) {
      obj.binauthz = BinauthzConfig.toJSON(message.binauthz);
    }
    if (message.hierarchyController !== undefined) {
      obj.hierarchyController = HierarchyControllerConfig.toJSON(message.hierarchyController);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipSpec>): MembershipSpec {
    return MembershipSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipSpec>): MembershipSpec {
    const message = createBaseMembershipSpec();
    message.configSync = (object.configSync !== undefined && object.configSync !== null)
      ? ConfigSync.fromPartial(object.configSync)
      : undefined;
    message.policyController = (object.policyController !== undefined && object.policyController !== null)
      ? PolicyController.fromPartial(object.policyController)
      : undefined;
    message.binauthz = (object.binauthz !== undefined && object.binauthz !== null)
      ? BinauthzConfig.fromPartial(object.binauthz)
      : undefined;
    message.hierarchyController = (object.hierarchyController !== undefined && object.hierarchyController !== null)
      ? HierarchyControllerConfig.fromPartial(object.hierarchyController)
      : undefined;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseConfigSync(): ConfigSync {
  return { git: undefined, sourceFormat: "" };
}

export const ConfigSync: MessageFns<ConfigSync> = {
  encode(message: ConfigSync, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.git !== undefined) {
      GitConfig.encode(message.git, writer.uint32(58).fork()).join();
    }
    if (message.sourceFormat !== "") {
      writer.uint32(66).string(message.sourceFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSync {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSync();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.git = GitConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sourceFormat = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSync {
    return {
      git: isSet(object.git) ? GitConfig.fromJSON(object.git) : undefined,
      sourceFormat: isSet(object.sourceFormat) ? globalThis.String(object.sourceFormat) : "",
    };
  },

  toJSON(message: ConfigSync): unknown {
    const obj: any = {};
    if (message.git !== undefined) {
      obj.git = GitConfig.toJSON(message.git);
    }
    if (message.sourceFormat !== "") {
      obj.sourceFormat = message.sourceFormat;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigSync>): ConfigSync {
    return ConfigSync.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigSync>): ConfigSync {
    const message = createBaseConfigSync();
    message.git = (object.git !== undefined && object.git !== null) ? GitConfig.fromPartial(object.git) : undefined;
    message.sourceFormat = object.sourceFormat ?? "";
    return message;
  },
};

function createBaseGitConfig(): GitConfig {
  return {
    syncRepo: "",
    syncBranch: "",
    policyDir: "",
    syncWaitSecs: Long.ZERO,
    syncRev: "",
    secretType: "",
    httpsProxy: "",
    gcpServiceAccountEmail: "",
  };
}

export const GitConfig: MessageFns<GitConfig> = {
  encode(message: GitConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.syncRepo !== "") {
      writer.uint32(10).string(message.syncRepo);
    }
    if (message.syncBranch !== "") {
      writer.uint32(18).string(message.syncBranch);
    }
    if (message.policyDir !== "") {
      writer.uint32(26).string(message.policyDir);
    }
    if (!message.syncWaitSecs.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.syncWaitSecs.toString());
    }
    if (message.syncRev !== "") {
      writer.uint32(42).string(message.syncRev);
    }
    if (message.secretType !== "") {
      writer.uint32(50).string(message.secretType);
    }
    if (message.httpsProxy !== "") {
      writer.uint32(58).string(message.httpsProxy);
    }
    if (message.gcpServiceAccountEmail !== "") {
      writer.uint32(66).string(message.gcpServiceAccountEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GitConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGitConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.syncRepo = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.syncBranch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyDir = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.syncWaitSecs = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.syncRev = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.secretType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.httpsProxy = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gcpServiceAccountEmail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GitConfig {
    return {
      syncRepo: isSet(object.syncRepo) ? globalThis.String(object.syncRepo) : "",
      syncBranch: isSet(object.syncBranch) ? globalThis.String(object.syncBranch) : "",
      policyDir: isSet(object.policyDir) ? globalThis.String(object.policyDir) : "",
      syncWaitSecs: isSet(object.syncWaitSecs) ? Long.fromValue(object.syncWaitSecs) : Long.ZERO,
      syncRev: isSet(object.syncRev) ? globalThis.String(object.syncRev) : "",
      secretType: isSet(object.secretType) ? globalThis.String(object.secretType) : "",
      httpsProxy: isSet(object.httpsProxy) ? globalThis.String(object.httpsProxy) : "",
      gcpServiceAccountEmail: isSet(object.gcpServiceAccountEmail)
        ? globalThis.String(object.gcpServiceAccountEmail)
        : "",
    };
  },

  toJSON(message: GitConfig): unknown {
    const obj: any = {};
    if (message.syncRepo !== "") {
      obj.syncRepo = message.syncRepo;
    }
    if (message.syncBranch !== "") {
      obj.syncBranch = message.syncBranch;
    }
    if (message.policyDir !== "") {
      obj.policyDir = message.policyDir;
    }
    if (!message.syncWaitSecs.equals(Long.ZERO)) {
      obj.syncWaitSecs = (message.syncWaitSecs || Long.ZERO).toString();
    }
    if (message.syncRev !== "") {
      obj.syncRev = message.syncRev;
    }
    if (message.secretType !== "") {
      obj.secretType = message.secretType;
    }
    if (message.httpsProxy !== "") {
      obj.httpsProxy = message.httpsProxy;
    }
    if (message.gcpServiceAccountEmail !== "") {
      obj.gcpServiceAccountEmail = message.gcpServiceAccountEmail;
    }
    return obj;
  },

  create(base?: DeepPartial<GitConfig>): GitConfig {
    return GitConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GitConfig>): GitConfig {
    const message = createBaseGitConfig();
    message.syncRepo = object.syncRepo ?? "";
    message.syncBranch = object.syncBranch ?? "";
    message.policyDir = object.policyDir ?? "";
    message.syncWaitSecs = (object.syncWaitSecs !== undefined && object.syncWaitSecs !== null)
      ? Long.fromValue(object.syncWaitSecs)
      : Long.ZERO;
    message.syncRev = object.syncRev ?? "";
    message.secretType = object.secretType ?? "";
    message.httpsProxy = object.httpsProxy ?? "";
    message.gcpServiceAccountEmail = object.gcpServiceAccountEmail ?? "";
    return message;
  },
};

function createBasePolicyController(): PolicyController {
  return {
    enabled: false,
    templateLibraryInstalled: undefined,
    auditIntervalSeconds: undefined,
    exemptableNamespaces: [],
    referentialRulesEnabled: false,
    logDeniesEnabled: false,
  };
}

export const PolicyController: MessageFns<PolicyController> = {
  encode(message: PolicyController, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.templateLibraryInstalled !== undefined) {
      writer.uint32(16).bool(message.templateLibraryInstalled);
    }
    if (message.auditIntervalSeconds !== undefined) {
      writer.uint32(24).int64(message.auditIntervalSeconds.toString());
    }
    for (const v of message.exemptableNamespaces) {
      writer.uint32(34).string(v!);
    }
    if (message.referentialRulesEnabled !== false) {
      writer.uint32(40).bool(message.referentialRulesEnabled);
    }
    if (message.logDeniesEnabled !== false) {
      writer.uint32(48).bool(message.logDeniesEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyController {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyController();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.templateLibraryInstalled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.auditIntervalSeconds = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exemptableNamespaces.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.referentialRulesEnabled = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.logDeniesEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyController {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      templateLibraryInstalled: isSet(object.templateLibraryInstalled)
        ? globalThis.Boolean(object.templateLibraryInstalled)
        : undefined,
      auditIntervalSeconds: isSet(object.auditIntervalSeconds)
        ? Long.fromValue(object.auditIntervalSeconds)
        : undefined,
      exemptableNamespaces: globalThis.Array.isArray(object?.exemptableNamespaces)
        ? object.exemptableNamespaces.map((e: any) => globalThis.String(e))
        : [],
      referentialRulesEnabled: isSet(object.referentialRulesEnabled)
        ? globalThis.Boolean(object.referentialRulesEnabled)
        : false,
      logDeniesEnabled: isSet(object.logDeniesEnabled) ? globalThis.Boolean(object.logDeniesEnabled) : false,
    };
  },

  toJSON(message: PolicyController): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.templateLibraryInstalled !== undefined) {
      obj.templateLibraryInstalled = message.templateLibraryInstalled;
    }
    if (message.auditIntervalSeconds !== undefined) {
      obj.auditIntervalSeconds = (message.auditIntervalSeconds || Long.ZERO).toString();
    }
    if (message.exemptableNamespaces?.length) {
      obj.exemptableNamespaces = message.exemptableNamespaces;
    }
    if (message.referentialRulesEnabled !== false) {
      obj.referentialRulesEnabled = message.referentialRulesEnabled;
    }
    if (message.logDeniesEnabled !== false) {
      obj.logDeniesEnabled = message.logDeniesEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyController>): PolicyController {
    return PolicyController.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyController>): PolicyController {
    const message = createBasePolicyController();
    message.enabled = object.enabled ?? false;
    message.templateLibraryInstalled = object.templateLibraryInstalled ?? undefined;
    message.auditIntervalSeconds = (object.auditIntervalSeconds !== undefined && object.auditIntervalSeconds !== null)
      ? Long.fromValue(object.auditIntervalSeconds)
      : undefined;
    message.exemptableNamespaces = object.exemptableNamespaces?.map((e) => e) || [];
    message.referentialRulesEnabled = object.referentialRulesEnabled ?? false;
    message.logDeniesEnabled = object.logDeniesEnabled ?? false;
    return message;
  },
};

function createBaseBinauthzConfig(): BinauthzConfig {
  return { enabled: false };
}

export const BinauthzConfig: MessageFns<BinauthzConfig> = {
  encode(message: BinauthzConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinauthzConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinauthzConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinauthzConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: BinauthzConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<BinauthzConfig>): BinauthzConfig {
    return BinauthzConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinauthzConfig>): BinauthzConfig {
    const message = createBaseBinauthzConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseHierarchyControllerConfig(): HierarchyControllerConfig {
  return { enabled: false, enablePodTreeLabels: false, enableHierarchicalResourceQuota: false };
}

export const HierarchyControllerConfig: MessageFns<HierarchyControllerConfig> = {
  encode(message: HierarchyControllerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.enablePodTreeLabels !== false) {
      writer.uint32(16).bool(message.enablePodTreeLabels);
    }
    if (message.enableHierarchicalResourceQuota !== false) {
      writer.uint32(24).bool(message.enableHierarchicalResourceQuota);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HierarchyControllerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHierarchyControllerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enablePodTreeLabels = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableHierarchicalResourceQuota = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HierarchyControllerConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      enablePodTreeLabels: isSet(object.enablePodTreeLabels) ? globalThis.Boolean(object.enablePodTreeLabels) : false,
      enableHierarchicalResourceQuota: isSet(object.enableHierarchicalResourceQuota)
        ? globalThis.Boolean(object.enableHierarchicalResourceQuota)
        : false,
    };
  },

  toJSON(message: HierarchyControllerConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.enablePodTreeLabels !== false) {
      obj.enablePodTreeLabels = message.enablePodTreeLabels;
    }
    if (message.enableHierarchicalResourceQuota !== false) {
      obj.enableHierarchicalResourceQuota = message.enableHierarchicalResourceQuota;
    }
    return obj;
  },

  create(base?: DeepPartial<HierarchyControllerConfig>): HierarchyControllerConfig {
    return HierarchyControllerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HierarchyControllerConfig>): HierarchyControllerConfig {
    const message = createBaseHierarchyControllerConfig();
    message.enabled = object.enabled ?? false;
    message.enablePodTreeLabels = object.enablePodTreeLabels ?? false;
    message.enableHierarchicalResourceQuota = object.enableHierarchicalResourceQuota ?? false;
    return message;
  },
};

function createBaseHierarchyControllerDeploymentState(): HierarchyControllerDeploymentState {
  return { hnc: 0, extension: 0 };
}

export const HierarchyControllerDeploymentState: MessageFns<HierarchyControllerDeploymentState> = {
  encode(message: HierarchyControllerDeploymentState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hnc !== 0) {
      writer.uint32(8).int32(message.hnc);
    }
    if (message.extension !== 0) {
      writer.uint32(16).int32(message.extension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HierarchyControllerDeploymentState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHierarchyControllerDeploymentState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hnc = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.extension = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HierarchyControllerDeploymentState {
    return {
      hnc: isSet(object.hnc) ? deploymentStateFromJSON(object.hnc) : 0,
      extension: isSet(object.extension) ? deploymentStateFromJSON(object.extension) : 0,
    };
  },

  toJSON(message: HierarchyControllerDeploymentState): unknown {
    const obj: any = {};
    if (message.hnc !== 0) {
      obj.hnc = deploymentStateToJSON(message.hnc);
    }
    if (message.extension !== 0) {
      obj.extension = deploymentStateToJSON(message.extension);
    }
    return obj;
  },

  create(base?: DeepPartial<HierarchyControllerDeploymentState>): HierarchyControllerDeploymentState {
    return HierarchyControllerDeploymentState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HierarchyControllerDeploymentState>): HierarchyControllerDeploymentState {
    const message = createBaseHierarchyControllerDeploymentState();
    message.hnc = object.hnc ?? 0;
    message.extension = object.extension ?? 0;
    return message;
  },
};

function createBaseHierarchyControllerVersion(): HierarchyControllerVersion {
  return { hnc: "", extension: "" };
}

export const HierarchyControllerVersion: MessageFns<HierarchyControllerVersion> = {
  encode(message: HierarchyControllerVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hnc !== "") {
      writer.uint32(10).string(message.hnc);
    }
    if (message.extension !== "") {
      writer.uint32(18).string(message.extension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HierarchyControllerVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHierarchyControllerVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hnc = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extension = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HierarchyControllerVersion {
    return {
      hnc: isSet(object.hnc) ? globalThis.String(object.hnc) : "",
      extension: isSet(object.extension) ? globalThis.String(object.extension) : "",
    };
  },

  toJSON(message: HierarchyControllerVersion): unknown {
    const obj: any = {};
    if (message.hnc !== "") {
      obj.hnc = message.hnc;
    }
    if (message.extension !== "") {
      obj.extension = message.extension;
    }
    return obj;
  },

  create(base?: DeepPartial<HierarchyControllerVersion>): HierarchyControllerVersion {
    return HierarchyControllerVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HierarchyControllerVersion>): HierarchyControllerVersion {
    const message = createBaseHierarchyControllerVersion();
    message.hnc = object.hnc ?? "";
    message.extension = object.extension ?? "";
    return message;
  },
};

function createBaseHierarchyControllerState(): HierarchyControllerState {
  return { version: undefined, state: undefined };
}

export const HierarchyControllerState: MessageFns<HierarchyControllerState> = {
  encode(message: HierarchyControllerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      HierarchyControllerVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      HierarchyControllerDeploymentState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HierarchyControllerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHierarchyControllerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = HierarchyControllerVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = HierarchyControllerDeploymentState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HierarchyControllerState {
    return {
      version: isSet(object.version) ? HierarchyControllerVersion.fromJSON(object.version) : undefined,
      state: isSet(object.state) ? HierarchyControllerDeploymentState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: HierarchyControllerState): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = HierarchyControllerVersion.toJSON(message.version);
    }
    if (message.state !== undefined) {
      obj.state = HierarchyControllerDeploymentState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<HierarchyControllerState>): HierarchyControllerState {
    return HierarchyControllerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HierarchyControllerState>): HierarchyControllerState {
    const message = createBaseHierarchyControllerState();
    message.version = (object.version !== undefined && object.version !== null)
      ? HierarchyControllerVersion.fromPartial(object.version)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? HierarchyControllerDeploymentState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseOperatorState(): OperatorState {
  return { version: "", deploymentState: 0, errors: [] };
}

export const OperatorState: MessageFns<OperatorState> = {
  encode(message: OperatorState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.deploymentState !== 0) {
      writer.uint32(16).int32(message.deploymentState);
    }
    for (const v of message.errors) {
      InstallError.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperatorState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperatorState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deploymentState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errors.push(InstallError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperatorState {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      deploymentState: isSet(object.deploymentState) ? deploymentStateFromJSON(object.deploymentState) : 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => InstallError.fromJSON(e)) : [],
    };
  },

  toJSON(message: OperatorState): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.deploymentState !== 0) {
      obj.deploymentState = deploymentStateToJSON(message.deploymentState);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => InstallError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OperatorState>): OperatorState {
    return OperatorState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperatorState>): OperatorState {
    const message = createBaseOperatorState();
    message.version = object.version ?? "";
    message.deploymentState = object.deploymentState ?? 0;
    message.errors = object.errors?.map((e) => InstallError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstallError(): InstallError {
  return { errorMessage: "" };
}

export const InstallError: MessageFns<InstallError> = {
  encode(message: InstallError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstallError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstallError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstallError {
    return { errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "" };
  },

  toJSON(message: InstallError): unknown {
    const obj: any = {};
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<InstallError>): InstallError {
    return InstallError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstallError>): InstallError {
    const message = createBaseInstallError();
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseConfigSyncState(): ConfigSyncState {
  return { version: undefined, deploymentState: undefined, syncState: undefined };
}

export const ConfigSyncState: MessageFns<ConfigSyncState> = {
  encode(message: ConfigSyncState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      ConfigSyncVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.deploymentState !== undefined) {
      ConfigSyncDeploymentState.encode(message.deploymentState, writer.uint32(18).fork()).join();
    }
    if (message.syncState !== undefined) {
      SyncState.encode(message.syncState, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSyncState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSyncState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = ConfigSyncVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deploymentState = ConfigSyncDeploymentState.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.syncState = SyncState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSyncState {
    return {
      version: isSet(object.version) ? ConfigSyncVersion.fromJSON(object.version) : undefined,
      deploymentState: isSet(object.deploymentState)
        ? ConfigSyncDeploymentState.fromJSON(object.deploymentState)
        : undefined,
      syncState: isSet(object.syncState) ? SyncState.fromJSON(object.syncState) : undefined,
    };
  },

  toJSON(message: ConfigSyncState): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = ConfigSyncVersion.toJSON(message.version);
    }
    if (message.deploymentState !== undefined) {
      obj.deploymentState = ConfigSyncDeploymentState.toJSON(message.deploymentState);
    }
    if (message.syncState !== undefined) {
      obj.syncState = SyncState.toJSON(message.syncState);
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigSyncState>): ConfigSyncState {
    return ConfigSyncState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigSyncState>): ConfigSyncState {
    const message = createBaseConfigSyncState();
    message.version = (object.version !== undefined && object.version !== null)
      ? ConfigSyncVersion.fromPartial(object.version)
      : undefined;
    message.deploymentState = (object.deploymentState !== undefined && object.deploymentState !== null)
      ? ConfigSyncDeploymentState.fromPartial(object.deploymentState)
      : undefined;
    message.syncState = (object.syncState !== undefined && object.syncState !== null)
      ? SyncState.fromPartial(object.syncState)
      : undefined;
    return message;
  },
};

function createBaseConfigSyncVersion(): ConfigSyncVersion {
  return { importer: "", syncer: "", gitSync: "", monitor: "", reconcilerManager: "", rootReconciler: "" };
}

export const ConfigSyncVersion: MessageFns<ConfigSyncVersion> = {
  encode(message: ConfigSyncVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importer !== "") {
      writer.uint32(10).string(message.importer);
    }
    if (message.syncer !== "") {
      writer.uint32(18).string(message.syncer);
    }
    if (message.gitSync !== "") {
      writer.uint32(26).string(message.gitSync);
    }
    if (message.monitor !== "") {
      writer.uint32(34).string(message.monitor);
    }
    if (message.reconcilerManager !== "") {
      writer.uint32(42).string(message.reconcilerManager);
    }
    if (message.rootReconciler !== "") {
      writer.uint32(50).string(message.rootReconciler);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSyncVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSyncVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.importer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.syncer = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gitSync = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monitor = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reconcilerManager = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rootReconciler = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSyncVersion {
    return {
      importer: isSet(object.importer) ? globalThis.String(object.importer) : "",
      syncer: isSet(object.syncer) ? globalThis.String(object.syncer) : "",
      gitSync: isSet(object.gitSync) ? globalThis.String(object.gitSync) : "",
      monitor: isSet(object.monitor) ? globalThis.String(object.monitor) : "",
      reconcilerManager: isSet(object.reconcilerManager) ? globalThis.String(object.reconcilerManager) : "",
      rootReconciler: isSet(object.rootReconciler) ? globalThis.String(object.rootReconciler) : "",
    };
  },

  toJSON(message: ConfigSyncVersion): unknown {
    const obj: any = {};
    if (message.importer !== "") {
      obj.importer = message.importer;
    }
    if (message.syncer !== "") {
      obj.syncer = message.syncer;
    }
    if (message.gitSync !== "") {
      obj.gitSync = message.gitSync;
    }
    if (message.monitor !== "") {
      obj.monitor = message.monitor;
    }
    if (message.reconcilerManager !== "") {
      obj.reconcilerManager = message.reconcilerManager;
    }
    if (message.rootReconciler !== "") {
      obj.rootReconciler = message.rootReconciler;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigSyncVersion>): ConfigSyncVersion {
    return ConfigSyncVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigSyncVersion>): ConfigSyncVersion {
    const message = createBaseConfigSyncVersion();
    message.importer = object.importer ?? "";
    message.syncer = object.syncer ?? "";
    message.gitSync = object.gitSync ?? "";
    message.monitor = object.monitor ?? "";
    message.reconcilerManager = object.reconcilerManager ?? "";
    message.rootReconciler = object.rootReconciler ?? "";
    return message;
  },
};

function createBaseConfigSyncDeploymentState(): ConfigSyncDeploymentState {
  return { importer: 0, syncer: 0, gitSync: 0, monitor: 0, reconcilerManager: 0, rootReconciler: 0 };
}

export const ConfigSyncDeploymentState: MessageFns<ConfigSyncDeploymentState> = {
  encode(message: ConfigSyncDeploymentState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.importer !== 0) {
      writer.uint32(8).int32(message.importer);
    }
    if (message.syncer !== 0) {
      writer.uint32(16).int32(message.syncer);
    }
    if (message.gitSync !== 0) {
      writer.uint32(24).int32(message.gitSync);
    }
    if (message.monitor !== 0) {
      writer.uint32(32).int32(message.monitor);
    }
    if (message.reconcilerManager !== 0) {
      writer.uint32(40).int32(message.reconcilerManager);
    }
    if (message.rootReconciler !== 0) {
      writer.uint32(48).int32(message.rootReconciler);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigSyncDeploymentState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigSyncDeploymentState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.importer = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.syncer = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gitSync = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.monitor = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reconcilerManager = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rootReconciler = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigSyncDeploymentState {
    return {
      importer: isSet(object.importer) ? deploymentStateFromJSON(object.importer) : 0,
      syncer: isSet(object.syncer) ? deploymentStateFromJSON(object.syncer) : 0,
      gitSync: isSet(object.gitSync) ? deploymentStateFromJSON(object.gitSync) : 0,
      monitor: isSet(object.monitor) ? deploymentStateFromJSON(object.monitor) : 0,
      reconcilerManager: isSet(object.reconcilerManager) ? deploymentStateFromJSON(object.reconcilerManager) : 0,
      rootReconciler: isSet(object.rootReconciler) ? deploymentStateFromJSON(object.rootReconciler) : 0,
    };
  },

  toJSON(message: ConfigSyncDeploymentState): unknown {
    const obj: any = {};
    if (message.importer !== 0) {
      obj.importer = deploymentStateToJSON(message.importer);
    }
    if (message.syncer !== 0) {
      obj.syncer = deploymentStateToJSON(message.syncer);
    }
    if (message.gitSync !== 0) {
      obj.gitSync = deploymentStateToJSON(message.gitSync);
    }
    if (message.monitor !== 0) {
      obj.monitor = deploymentStateToJSON(message.monitor);
    }
    if (message.reconcilerManager !== 0) {
      obj.reconcilerManager = deploymentStateToJSON(message.reconcilerManager);
    }
    if (message.rootReconciler !== 0) {
      obj.rootReconciler = deploymentStateToJSON(message.rootReconciler);
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigSyncDeploymentState>): ConfigSyncDeploymentState {
    return ConfigSyncDeploymentState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigSyncDeploymentState>): ConfigSyncDeploymentState {
    const message = createBaseConfigSyncDeploymentState();
    message.importer = object.importer ?? 0;
    message.syncer = object.syncer ?? 0;
    message.gitSync = object.gitSync ?? 0;
    message.monitor = object.monitor ?? 0;
    message.reconcilerManager = object.reconcilerManager ?? 0;
    message.rootReconciler = object.rootReconciler ?? 0;
    return message;
  },
};

function createBaseSyncState(): SyncState {
  return {
    sourceToken: "",
    importToken: "",
    syncToken: "",
    lastSync: "",
    lastSyncTime: undefined,
    code: 0,
    errors: [],
  };
}

export const SyncState: MessageFns<SyncState> = {
  encode(message: SyncState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceToken !== "") {
      writer.uint32(10).string(message.sourceToken);
    }
    if (message.importToken !== "") {
      writer.uint32(18).string(message.importToken);
    }
    if (message.syncToken !== "") {
      writer.uint32(26).string(message.syncToken);
    }
    if (message.lastSync !== "") {
      writer.uint32(34).string(message.lastSync);
    }
    if (message.lastSyncTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSyncTime), writer.uint32(58).fork()).join();
    }
    if (message.code !== 0) {
      writer.uint32(40).int32(message.code);
    }
    for (const v of message.errors) {
      SyncError.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.syncToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastSync = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lastSyncTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.errors.push(SyncError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncState {
    return {
      sourceToken: isSet(object.sourceToken) ? globalThis.String(object.sourceToken) : "",
      importToken: isSet(object.importToken) ? globalThis.String(object.importToken) : "",
      syncToken: isSet(object.syncToken) ? globalThis.String(object.syncToken) : "",
      lastSync: isSet(object.lastSync) ? globalThis.String(object.lastSync) : "",
      lastSyncTime: isSet(object.lastSyncTime) ? fromJsonTimestamp(object.lastSyncTime) : undefined,
      code: isSet(object.code) ? syncState_SyncCodeFromJSON(object.code) : 0,
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => SyncError.fromJSON(e)) : [],
    };
  },

  toJSON(message: SyncState): unknown {
    const obj: any = {};
    if (message.sourceToken !== "") {
      obj.sourceToken = message.sourceToken;
    }
    if (message.importToken !== "") {
      obj.importToken = message.importToken;
    }
    if (message.syncToken !== "") {
      obj.syncToken = message.syncToken;
    }
    if (message.lastSync !== "") {
      obj.lastSync = message.lastSync;
    }
    if (message.lastSyncTime !== undefined) {
      obj.lastSyncTime = message.lastSyncTime.toISOString();
    }
    if (message.code !== 0) {
      obj.code = syncState_SyncCodeToJSON(message.code);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => SyncError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SyncState>): SyncState {
    return SyncState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncState>): SyncState {
    const message = createBaseSyncState();
    message.sourceToken = object.sourceToken ?? "";
    message.importToken = object.importToken ?? "";
    message.syncToken = object.syncToken ?? "";
    message.lastSync = object.lastSync ?? "";
    message.lastSyncTime = object.lastSyncTime ?? undefined;
    message.code = object.code ?? 0;
    message.errors = object.errors?.map((e) => SyncError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncError(): SyncError {
  return { code: "", errorMessage: "", errorResources: [] };
}

export const SyncError: MessageFns<SyncError> = {
  encode(message: SyncError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    for (const v of message.errorResources) {
      ErrorResource.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errorResources.push(ErrorResource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorResources: globalThis.Array.isArray(object?.errorResources)
        ? object.errorResources.map((e: any) => ErrorResource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SyncError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorResources?.length) {
      obj.errorResources = message.errorResources.map((e) => ErrorResource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SyncError>): SyncError {
    return SyncError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncError>): SyncError {
    const message = createBaseSyncError();
    message.code = object.code ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.errorResources = object.errorResources?.map((e) => ErrorResource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorResource(): ErrorResource {
  return { sourcePath: "", resourceName: "", resourceNamespace: "", resourceGvk: undefined };
}

export const ErrorResource: MessageFns<ErrorResource> = {
  encode(message: ErrorResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourcePath !== "") {
      writer.uint32(10).string(message.sourcePath);
    }
    if (message.resourceName !== "") {
      writer.uint32(18).string(message.resourceName);
    }
    if (message.resourceNamespace !== "") {
      writer.uint32(26).string(message.resourceNamespace);
    }
    if (message.resourceGvk !== undefined) {
      GroupVersionKind.encode(message.resourceGvk, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceNamespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceGvk = GroupVersionKind.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResource {
    return {
      sourcePath: isSet(object.sourcePath) ? globalThis.String(object.sourcePath) : "",
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "",
      resourceNamespace: isSet(object.resourceNamespace) ? globalThis.String(object.resourceNamespace) : "",
      resourceGvk: isSet(object.resourceGvk) ? GroupVersionKind.fromJSON(object.resourceGvk) : undefined,
    };
  },

  toJSON(message: ErrorResource): unknown {
    const obj: any = {};
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    if (message.resourceNamespace !== "") {
      obj.resourceNamespace = message.resourceNamespace;
    }
    if (message.resourceGvk !== undefined) {
      obj.resourceGvk = GroupVersionKind.toJSON(message.resourceGvk);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorResource>): ErrorResource {
    return ErrorResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorResource>): ErrorResource {
    const message = createBaseErrorResource();
    message.sourcePath = object.sourcePath ?? "";
    message.resourceName = object.resourceName ?? "";
    message.resourceNamespace = object.resourceNamespace ?? "";
    message.resourceGvk = (object.resourceGvk !== undefined && object.resourceGvk !== null)
      ? GroupVersionKind.fromPartial(object.resourceGvk)
      : undefined;
    return message;
  },
};

function createBaseGroupVersionKind(): GroupVersionKind {
  return { group: "", version: "", kind: "" };
}

export const GroupVersionKind: MessageFns<GroupVersionKind> = {
  encode(message: GroupVersionKind, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.kind !== "") {
      writer.uint32(26).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupVersionKind {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupVersionKind();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupVersionKind {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: GroupVersionKind): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<GroupVersionKind>): GroupVersionKind {
    return GroupVersionKind.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupVersionKind>): GroupVersionKind {
    const message = createBaseGroupVersionKind();
    message.group = object.group ?? "";
    message.version = object.version ?? "";
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBasePolicyControllerState(): PolicyControllerState {
  return { version: undefined, deploymentState: undefined };
}

export const PolicyControllerState: MessageFns<PolicyControllerState> = {
  encode(message: PolicyControllerState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      PolicyControllerVersion.encode(message.version, writer.uint32(10).fork()).join();
    }
    if (message.deploymentState !== undefined) {
      GatekeeperDeploymentState.encode(message.deploymentState, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyControllerState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyControllerState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = PolicyControllerVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deploymentState = GatekeeperDeploymentState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyControllerState {
    return {
      version: isSet(object.version) ? PolicyControllerVersion.fromJSON(object.version) : undefined,
      deploymentState: isSet(object.deploymentState)
        ? GatekeeperDeploymentState.fromJSON(object.deploymentState)
        : undefined,
    };
  },

  toJSON(message: PolicyControllerState): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = PolicyControllerVersion.toJSON(message.version);
    }
    if (message.deploymentState !== undefined) {
      obj.deploymentState = GatekeeperDeploymentState.toJSON(message.deploymentState);
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyControllerState>): PolicyControllerState {
    return PolicyControllerState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyControllerState>): PolicyControllerState {
    const message = createBasePolicyControllerState();
    message.version = (object.version !== undefined && object.version !== null)
      ? PolicyControllerVersion.fromPartial(object.version)
      : undefined;
    message.deploymentState = (object.deploymentState !== undefined && object.deploymentState !== null)
      ? GatekeeperDeploymentState.fromPartial(object.deploymentState)
      : undefined;
    return message;
  },
};

function createBasePolicyControllerVersion(): PolicyControllerVersion {
  return { version: "" };
}

export const PolicyControllerVersion: MessageFns<PolicyControllerVersion> = {
  encode(message: PolicyControllerVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PolicyControllerVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicyControllerVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolicyControllerVersion {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: PolicyControllerVersion): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<PolicyControllerVersion>): PolicyControllerVersion {
    return PolicyControllerVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolicyControllerVersion>): PolicyControllerVersion {
    const message = createBasePolicyControllerVersion();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseBinauthzState(): BinauthzState {
  return { webhook: 0, version: undefined };
}

export const BinauthzState: MessageFns<BinauthzState> = {
  encode(message: BinauthzState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.webhook !== 0) {
      writer.uint32(8).int32(message.webhook);
    }
    if (message.version !== undefined) {
      BinauthzVersion.encode(message.version, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinauthzState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinauthzState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.webhook = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = BinauthzVersion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinauthzState {
    return {
      webhook: isSet(object.webhook) ? deploymentStateFromJSON(object.webhook) : 0,
      version: isSet(object.version) ? BinauthzVersion.fromJSON(object.version) : undefined,
    };
  },

  toJSON(message: BinauthzState): unknown {
    const obj: any = {};
    if (message.webhook !== 0) {
      obj.webhook = deploymentStateToJSON(message.webhook);
    }
    if (message.version !== undefined) {
      obj.version = BinauthzVersion.toJSON(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<BinauthzState>): BinauthzState {
    return BinauthzState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinauthzState>): BinauthzState {
    const message = createBaseBinauthzState();
    message.webhook = object.webhook ?? 0;
    message.version = (object.version !== undefined && object.version !== null)
      ? BinauthzVersion.fromPartial(object.version)
      : undefined;
    return message;
  },
};

function createBaseBinauthzVersion(): BinauthzVersion {
  return { webhookVersion: "" };
}

export const BinauthzVersion: MessageFns<BinauthzVersion> = {
  encode(message: BinauthzVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.webhookVersion !== "") {
      writer.uint32(10).string(message.webhookVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinauthzVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinauthzVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.webhookVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinauthzVersion {
    return { webhookVersion: isSet(object.webhookVersion) ? globalThis.String(object.webhookVersion) : "" };
  },

  toJSON(message: BinauthzVersion): unknown {
    const obj: any = {};
    if (message.webhookVersion !== "") {
      obj.webhookVersion = message.webhookVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<BinauthzVersion>): BinauthzVersion {
    return BinauthzVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinauthzVersion>): BinauthzVersion {
    const message = createBaseBinauthzVersion();
    message.webhookVersion = object.webhookVersion ?? "";
    return message;
  },
};

function createBaseGatekeeperDeploymentState(): GatekeeperDeploymentState {
  return { gatekeeperControllerManagerState: 0, gatekeeperAudit: 0 };
}

export const GatekeeperDeploymentState: MessageFns<GatekeeperDeploymentState> = {
  encode(message: GatekeeperDeploymentState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gatekeeperControllerManagerState !== 0) {
      writer.uint32(8).int32(message.gatekeeperControllerManagerState);
    }
    if (message.gatekeeperAudit !== 0) {
      writer.uint32(16).int32(message.gatekeeperAudit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatekeeperDeploymentState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatekeeperDeploymentState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gatekeeperControllerManagerState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gatekeeperAudit = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatekeeperDeploymentState {
    return {
      gatekeeperControllerManagerState: isSet(object.gatekeeperControllerManagerState)
        ? deploymentStateFromJSON(object.gatekeeperControllerManagerState)
        : 0,
      gatekeeperAudit: isSet(object.gatekeeperAudit) ? deploymentStateFromJSON(object.gatekeeperAudit) : 0,
    };
  },

  toJSON(message: GatekeeperDeploymentState): unknown {
    const obj: any = {};
    if (message.gatekeeperControllerManagerState !== 0) {
      obj.gatekeeperControllerManagerState = deploymentStateToJSON(message.gatekeeperControllerManagerState);
    }
    if (message.gatekeeperAudit !== 0) {
      obj.gatekeeperAudit = deploymentStateToJSON(message.gatekeeperAudit);
    }
    return obj;
  },

  create(base?: DeepPartial<GatekeeperDeploymentState>): GatekeeperDeploymentState {
    return GatekeeperDeploymentState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GatekeeperDeploymentState>): GatekeeperDeploymentState {
    const message = createBaseGatekeeperDeploymentState();
    message.gatekeeperControllerManagerState = object.gatekeeperControllerManagerState ?? 0;
    message.gatekeeperAudit = object.gatekeeperAudit ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
