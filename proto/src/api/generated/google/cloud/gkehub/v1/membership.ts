// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkehub/v1/membership.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.gkehub.v1";

/** Membership contains information about a member cluster. */
export interface Membership {
  /** Optional. Endpoint information to reach this member. */
  endpoint?:
    | MembershipEndpoint
    | undefined;
  /**
   * Output only. The full, unique name of this Membership resource in the
   * format `projects/* /locations/* /memberships/{membership_id}`, set during
   * creation.
   *
   * `membership_id` must be a valid RFC 1123 compliant DNS label:
   *
   *   1. At most 63 characters in length
   *   2. It must consist of lower case alphanumeric characters or `-`
   *   3. It must start and end with an alphanumeric character
   *
   * Which can be expressed as the regex: `[a-z0-9]([-a-z0-9]*[a-z0-9])?`,
   * with a maximum length of 63 characters.
   */
  name: string;
  /** Optional. Labels for this membership. */
  labels: { [key: string]: string };
  /**
   * Output only. Description of this membership, limited to 63 characters.
   * Must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.\ ]*`
   *
   * This field is present for legacy purposes.
   */
  description: string;
  /** Output only. State of the Membership resource. */
  state:
    | MembershipState
    | undefined;
  /** Output only. When the Membership was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. When the Membership was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. When the Membership was deleted. */
  deleteTime:
    | Date
    | undefined;
  /**
   * Optional. An externally-generated and managed ID for this Membership. This
   * ID may be modified after creation, but this is not recommended.
   *
   * The ID must match the regex: `[a-zA-Z0-9][a-zA-Z0-9_\-\.]*`
   *
   * If this Membership represents a Kubernetes cluster, this value should be
   * set to the UID of the `kube-system` namespace object.
   */
  externalId: string;
  /**
   * Output only. For clusters using Connect, the timestamp of the most recent
   * connection established with Google Cloud. This time is updated every
   * several minutes, not continuously. For clusters that do not use GKE
   * Connect, or that have never connected successfully, this field will be
   * unset.
   */
  lastConnectionTime:
    | Date
    | undefined;
  /**
   * Output only. Google-generated UUID for this resource. This is unique across
   * all Membership resources. If a Membership resource is deleted and another
   * resource with the same name is created, it gets a different unique_id.
   */
  uniqueId: string;
  /**
   * Optional. How to identify workloads from this Membership.
   * See the documentation on Workload Identity for more details:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
   */
  authority:
    | Authority
    | undefined;
  /** Optional. The monitoring config information for this membership. */
  monitoringConfig: MonitoringConfig | undefined;
}

export interface Membership_LabelsEntry {
  key: string;
  value: string;
}

/**
 * MembershipEndpoint contains information needed to contact a Kubernetes API,
 * endpoint and any additional Kubernetes metadata.
 */
export interface MembershipEndpoint {
  /** Optional. GKE-specific information. Only present if this Membership is a GKE cluster. */
  gkeCluster:
    | GkeCluster
    | undefined;
  /** Output only. Useful Kubernetes-specific metadata. */
  kubernetesMetadata:
    | KubernetesMetadata
    | undefined;
  /**
   * Optional. The in-cluster Kubernetes Resources that should be applied for a
   * correctly registered cluster, in the steady state. These resources:
   *
   *   * Ensure that the cluster is exclusively registered to one and only one
   *     Hub Membership.
   *   * Propagate Workload Pool Information available in the Membership
   *     Authority field.
   *   * Ensure proper initial configuration of default Hub Features.
   */
  kubernetesResource:
    | KubernetesResource
    | undefined;
  /**
   * Output only. Whether the lifecycle of this membership is managed by a
   * google cluster platform service.
   */
  googleManaged: boolean;
}

/**
 * KubernetesResource contains the YAML manifests and configuration for
 * Membership Kubernetes resources in the cluster. After CreateMembership or
 * UpdateMembership, these resources should be re-applied in the cluster.
 */
export interface KubernetesResource {
  /**
   * Input only. The YAML representation of the Membership CR. This field is
   * ignored for GKE clusters where Hub can read the CR directly.
   *
   * Callers should provide the CR that is currently present in the cluster
   * during CreateMembership or UpdateMembership, or leave this field empty if
   * none exists. The CR manifest is used to validate the cluster has not been
   * registered with another Membership.
   */
  membershipCrManifest: string;
  /**
   * Output only. Additional Kubernetes resources that need to be applied to the
   * cluster after Membership creation, and after every update.
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  membershipResources: ResourceManifest[];
  /**
   * Output only. The Kubernetes resources for installing the GKE Connect agent
   *
   * This field is only populated in the Membership returned from a successful
   * long-running operation from CreateMembership or UpdateMembership. It is not
   * populated during normal GetMembership or ListMemberships requests. To get
   * the resource manifest after the initial registration, the caller should
   * make a UpdateMembership call with an empty field mask.
   */
  connectResources: ResourceManifest[];
  /** Optional. Options for Kubernetes resource generation. */
  resourceOptions: ResourceOptions | undefined;
}

/** ResourceOptions represent options for Kubernetes resource generation. */
export interface ResourceOptions {
  /**
   * Optional. The Connect agent version to use for connect_resources. Defaults
   * to the latest GKE Connect version. The version must be a currently
   * supported version, obsolete versions will be rejected.
   */
  connectVersion: string;
  /**
   * Optional. Use `apiextensions/v1beta1` instead of `apiextensions/v1` for
   * CustomResourceDefinition resources.
   * This option should be set for clusters with Kubernetes apiserver versions
   * <1.16.
   */
  v1beta1Crd: boolean;
  /**
   * Optional. Major version of the Kubernetes cluster. This is only used to
   * determine which version to use for the CustomResourceDefinition resources,
   * `apiextensions/v1beta1` or`apiextensions/v1`.
   */
  k8sVersion: string;
}

/**
 * ResourceManifest represents a single Kubernetes resource to be applied to
 * the cluster.
 */
export interface ResourceManifest {
  /** YAML manifest of the resource. */
  manifest: string;
  /**
   * Whether the resource provided in the manifest is `cluster_scoped`.
   * If unset, the manifest is assumed to be namespace scoped.
   *
   * This field is used for REST mapping when applying the resource in a
   * cluster.
   */
  clusterScoped: boolean;
}

/** GkeCluster contains information specific to GKE clusters. */
export interface GkeCluster {
  /**
   * Immutable. Self-link of the Google Cloud resource for the GKE cluster. For
   * example:
   *
   * //container.googleapis.com/projects/my-project/locations/us-west1-a/clusters/my-cluster
   *
   * Zonal clusters are also supported.
   */
  resourceLink: string;
  /**
   * Output only. If cluster_missing is set then it denotes that the GKE cluster
   * no longer exists in the GKE Control Plane.
   */
  clusterMissing: boolean;
}

/**
 * KubernetesMetadata provides informational metadata for Memberships
 * representing Kubernetes clusters.
 */
export interface KubernetesMetadata {
  /**
   * Output only. Kubernetes API server version string as reported by
   * `/version`.
   */
  kubernetesApiServerVersion: string;
  /**
   * Output only. Node providerID as reported by the first node in the list of
   * nodes on the Kubernetes endpoint. On Kubernetes platforms that support
   * zero-node clusters (like GKE-on-GCP), the node_count will be zero and the
   * node_provider_id will be empty.
   */
  nodeProviderId: string;
  /** Output only. Node count as reported by Kubernetes nodes resources. */
  nodeCount: number;
  /** Output only. vCPU count as reported by Kubernetes nodes resources. */
  vcpuCount: number;
  /**
   * Output only. The total memory capacity as reported by the sum of all
   * Kubernetes nodes resources, defined in MB.
   */
  memoryMb: number;
  /**
   * Output only. The time at which these details were last updated. This
   * update_time is different from the Membership-level update_time since
   * EndpointDetails are updated internally for API consumers.
   */
  updateTime: Date | undefined;
}

/**
 * This field informs Fleet-based applications/services/UIs with the necessary
 * information for where each underlying Cluster reports its metrics.
 */
export interface MonitoringConfig {
  /** Immutable. Project used to report Metrics */
  projectId: string;
  /** Immutable. Location used to report Metrics */
  location: string;
  /**
   * Immutable. Cluster name used to report metrics.
   * For Anthos on VMWare/Baremetal, it would be in format
   * `memberClusters/cluster_name`; And for Anthos on MultiCloud, it would be in
   * format
   * `{azureClusters, awsClusters}/cluster_name`.
   */
  cluster: string;
  /**
   * Kubernetes system metrics, if available, are written to this prefix.
   * This defaults to kubernetes.io for GKE, and kubernetes.io/anthos for Anthos
   * eventually. Noted: Anthos MultiCloud will have kubernetes.io prefix today
   * but will migration to be under kubernetes.io/anthos
   */
  kubernetesMetricsPrefix: string;
  /**
   * Immutable. Cluster hash, this is a unique string generated by google code,
   * which does not contain any PII, which we can use to reference the cluster.
   * This is expected to be created by the monitoring stack and persisted into
   * the Cluster object as well as to GKE-Hub.
   */
  clusterHash: string;
}

/** MembershipState describes the state of a Membership resource. */
export interface MembershipState {
  /** Output only. The current state of the Membership resource. */
  code: MembershipState_Code;
}

/** Code describes the state of a Membership resource. */
export enum MembershipState_Code {
  /** CODE_UNSPECIFIED - The code is not set. */
  CODE_UNSPECIFIED = 0,
  /** CREATING - The cluster is being registered. */
  CREATING = 1,
  /** READY - The cluster is registered. */
  READY = 2,
  /** DELETING - The cluster is being unregistered. */
  DELETING = 3,
  /** UPDATING - The Membership is being updated. */
  UPDATING = 4,
  /** SERVICE_UPDATING - The Membership is being updated by the Hub Service. */
  SERVICE_UPDATING = 5,
  UNRECOGNIZED = -1,
}

export function membershipState_CodeFromJSON(object: any): MembershipState_Code {
  switch (object) {
    case 0:
    case "CODE_UNSPECIFIED":
      return MembershipState_Code.CODE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return MembershipState_Code.CREATING;
    case 2:
    case "READY":
      return MembershipState_Code.READY;
    case 3:
    case "DELETING":
      return MembershipState_Code.DELETING;
    case 4:
    case "UPDATING":
      return MembershipState_Code.UPDATING;
    case 5:
    case "SERVICE_UPDATING":
      return MembershipState_Code.SERVICE_UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MembershipState_Code.UNRECOGNIZED;
  }
}

export function membershipState_CodeToJSON(object: MembershipState_Code): string {
  switch (object) {
    case MembershipState_Code.CODE_UNSPECIFIED:
      return "CODE_UNSPECIFIED";
    case MembershipState_Code.CREATING:
      return "CREATING";
    case MembershipState_Code.READY:
      return "READY";
    case MembershipState_Code.DELETING:
      return "DELETING";
    case MembershipState_Code.UPDATING:
      return "UPDATING";
    case MembershipState_Code.SERVICE_UPDATING:
      return "SERVICE_UPDATING";
    case MembershipState_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Authority encodes how Google will recognize identities from this Membership.
 * See the workload identity documentation for more details:
 * https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity
 */
export interface Authority {
  /**
   * Optional. A JSON Web Token (JWT) issuer URI. `issuer` must start with
   * `https://` and be a valid URL with length <2000 characters.
   *
   * If set, then Google will allow valid OIDC tokens from this issuer to
   * authenticate within the workload_identity_pool. OIDC discovery will be
   * performed on this URI to validate tokens from the issuer.
   *
   * Clearing `issuer` disables Workload Identity. `issuer` cannot be directly
   * modified; it must be cleared (and Workload Identity disabled) before using
   * a new issuer (and re-enabling Workload Identity).
   */
  issuer: string;
  /**
   * Output only. The name of the workload identity pool in which `issuer` will
   * be recognized.
   *
   * There is a single Workload Identity Pool per Hub that is shared
   * between all Memberships that belong to that Hub. For a Hub hosted in
   * {PROJECT_ID}, the workload pool format is `{PROJECT_ID}.hub.id.goog`,
   * although this is subject to change in newer versions of this API.
   */
  workloadIdentityPool: string;
  /**
   * Output only. An identity provider that reflects the `issuer` in the
   * workload identity pool.
   */
  identityProvider: string;
  /**
   * Optional. OIDC verification keys for this Membership in JWKS format (RFC
   * 7517).
   *
   * When this field is set, OIDC discovery will NOT be performed on `issuer`,
   * and instead OIDC tokens will be validated using this field.
   */
  oidcJwks: Buffer;
}

function createBaseMembership(): Membership {
  return {
    endpoint: undefined,
    name: "",
    labels: {},
    description: "",
    state: undefined,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    externalId: "",
    lastConnectionTime: undefined,
    uniqueId: "",
    authority: undefined,
    monitoringConfig: undefined,
  };
}

export const Membership: MessageFns<Membership> = {
  encode(message: Membership, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== undefined) {
      MembershipEndpoint.encode(message.endpoint, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Membership_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.state !== undefined) {
      MembershipState.encode(message.state, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(66).fork()).join();
    }
    if (message.externalId !== "") {
      writer.uint32(74).string(message.externalId);
    }
    if (message.lastConnectionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastConnectionTime), writer.uint32(82).fork()).join();
    }
    if (message.uniqueId !== "") {
      writer.uint32(90).string(message.uniqueId);
    }
    if (message.authority !== undefined) {
      Authority.encode(message.authority, writer.uint32(98).fork()).join();
    }
    if (message.monitoringConfig !== undefined) {
      MonitoringConfig.encode(message.monitoringConfig, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endpoint = MembershipEndpoint.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Membership_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = MembershipState.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastConnectionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.authority = Authority.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.monitoringConfig = MonitoringConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership {
    return {
      endpoint: isSet(object.endpoint) ? MembershipEndpoint.fromJSON(object.endpoint) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? MembershipState.fromJSON(object.state) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      lastConnectionTime: isSet(object.lastConnectionTime) ? fromJsonTimestamp(object.lastConnectionTime) : undefined,
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      authority: isSet(object.authority) ? Authority.fromJSON(object.authority) : undefined,
      monitoringConfig: isSet(object.monitoringConfig) ? MonitoringConfig.fromJSON(object.monitoringConfig) : undefined,
    };
  },

  toJSON(message: Membership): unknown {
    const obj: any = {};
    if (message.endpoint !== undefined) {
      obj.endpoint = MembershipEndpoint.toJSON(message.endpoint);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== undefined) {
      obj.state = MembershipState.toJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.lastConnectionTime !== undefined) {
      obj.lastConnectionTime = message.lastConnectionTime.toISOString();
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.authority !== undefined) {
      obj.authority = Authority.toJSON(message.authority);
    }
    if (message.monitoringConfig !== undefined) {
      obj.monitoringConfig = MonitoringConfig.toJSON(message.monitoringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Membership>): Membership {
    return Membership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Membership>): Membership {
    const message = createBaseMembership();
    message.endpoint = (object.endpoint !== undefined && object.endpoint !== null)
      ? MembershipEndpoint.fromPartial(object.endpoint)
      : undefined;
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? MembershipState.fromPartial(object.state)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.externalId = object.externalId ?? "";
    message.lastConnectionTime = object.lastConnectionTime ?? undefined;
    message.uniqueId = object.uniqueId ?? "";
    message.authority = (object.authority !== undefined && object.authority !== null)
      ? Authority.fromPartial(object.authority)
      : undefined;
    message.monitoringConfig = (object.monitoringConfig !== undefined && object.monitoringConfig !== null)
      ? MonitoringConfig.fromPartial(object.monitoringConfig)
      : undefined;
    return message;
  },
};

function createBaseMembership_LabelsEntry(): Membership_LabelsEntry {
  return { key: "", value: "" };
}

export const Membership_LabelsEntry: MessageFns<Membership_LabelsEntry> = {
  encode(message: Membership_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Membership_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembership_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Membership_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Membership_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Membership_LabelsEntry>): Membership_LabelsEntry {
    return Membership_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Membership_LabelsEntry>): Membership_LabelsEntry {
    const message = createBaseMembership_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMembershipEndpoint(): MembershipEndpoint {
  return { gkeCluster: undefined, kubernetesMetadata: undefined, kubernetesResource: undefined, googleManaged: false };
}

export const MembershipEndpoint: MessageFns<MembershipEndpoint> = {
  encode(message: MembershipEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gkeCluster !== undefined) {
      GkeCluster.encode(message.gkeCluster, writer.uint32(10).fork()).join();
    }
    if (message.kubernetesMetadata !== undefined) {
      KubernetesMetadata.encode(message.kubernetesMetadata, writer.uint32(18).fork()).join();
    }
    if (message.kubernetesResource !== undefined) {
      KubernetesResource.encode(message.kubernetesResource, writer.uint32(26).fork()).join();
    }
    if (message.googleManaged !== false) {
      writer.uint32(64).bool(message.googleManaged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gkeCluster = GkeCluster.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kubernetesMetadata = KubernetesMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kubernetesResource = KubernetesResource.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.googleManaged = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipEndpoint {
    return {
      gkeCluster: isSet(object.gkeCluster) ? GkeCluster.fromJSON(object.gkeCluster) : undefined,
      kubernetesMetadata: isSet(object.kubernetesMetadata)
        ? KubernetesMetadata.fromJSON(object.kubernetesMetadata)
        : undefined,
      kubernetesResource: isSet(object.kubernetesResource)
        ? KubernetesResource.fromJSON(object.kubernetesResource)
        : undefined,
      googleManaged: isSet(object.googleManaged) ? globalThis.Boolean(object.googleManaged) : false,
    };
  },

  toJSON(message: MembershipEndpoint): unknown {
    const obj: any = {};
    if (message.gkeCluster !== undefined) {
      obj.gkeCluster = GkeCluster.toJSON(message.gkeCluster);
    }
    if (message.kubernetesMetadata !== undefined) {
      obj.kubernetesMetadata = KubernetesMetadata.toJSON(message.kubernetesMetadata);
    }
    if (message.kubernetesResource !== undefined) {
      obj.kubernetesResource = KubernetesResource.toJSON(message.kubernetesResource);
    }
    if (message.googleManaged !== false) {
      obj.googleManaged = message.googleManaged;
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipEndpoint>): MembershipEndpoint {
    return MembershipEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipEndpoint>): MembershipEndpoint {
    const message = createBaseMembershipEndpoint();
    message.gkeCluster = (object.gkeCluster !== undefined && object.gkeCluster !== null)
      ? GkeCluster.fromPartial(object.gkeCluster)
      : undefined;
    message.kubernetesMetadata = (object.kubernetesMetadata !== undefined && object.kubernetesMetadata !== null)
      ? KubernetesMetadata.fromPartial(object.kubernetesMetadata)
      : undefined;
    message.kubernetesResource = (object.kubernetesResource !== undefined && object.kubernetesResource !== null)
      ? KubernetesResource.fromPartial(object.kubernetesResource)
      : undefined;
    message.googleManaged = object.googleManaged ?? false;
    return message;
  },
};

function createBaseKubernetesResource(): KubernetesResource {
  return { membershipCrManifest: "", membershipResources: [], connectResources: [], resourceOptions: undefined };
}

export const KubernetesResource: MessageFns<KubernetesResource> = {
  encode(message: KubernetesResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membershipCrManifest !== "") {
      writer.uint32(10).string(message.membershipCrManifest);
    }
    for (const v of message.membershipResources) {
      ResourceManifest.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.connectResources) {
      ResourceManifest.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.resourceOptions !== undefined) {
      ResourceOptions.encode(message.resourceOptions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membershipCrManifest = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membershipResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connectResources.push(ResourceManifest.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceOptions = ResourceOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesResource {
    return {
      membershipCrManifest: isSet(object.membershipCrManifest) ? globalThis.String(object.membershipCrManifest) : "",
      membershipResources: globalThis.Array.isArray(object?.membershipResources)
        ? object.membershipResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      connectResources: globalThis.Array.isArray(object?.connectResources)
        ? object.connectResources.map((e: any) => ResourceManifest.fromJSON(e))
        : [],
      resourceOptions: isSet(object.resourceOptions) ? ResourceOptions.fromJSON(object.resourceOptions) : undefined,
    };
  },

  toJSON(message: KubernetesResource): unknown {
    const obj: any = {};
    if (message.membershipCrManifest !== "") {
      obj.membershipCrManifest = message.membershipCrManifest;
    }
    if (message.membershipResources?.length) {
      obj.membershipResources = message.membershipResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.connectResources?.length) {
      obj.connectResources = message.connectResources.map((e) => ResourceManifest.toJSON(e));
    }
    if (message.resourceOptions !== undefined) {
      obj.resourceOptions = ResourceOptions.toJSON(message.resourceOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesResource>): KubernetesResource {
    return KubernetesResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesResource>): KubernetesResource {
    const message = createBaseKubernetesResource();
    message.membershipCrManifest = object.membershipCrManifest ?? "";
    message.membershipResources = object.membershipResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.connectResources = object.connectResources?.map((e) => ResourceManifest.fromPartial(e)) || [];
    message.resourceOptions = (object.resourceOptions !== undefined && object.resourceOptions !== null)
      ? ResourceOptions.fromPartial(object.resourceOptions)
      : undefined;
    return message;
  },
};

function createBaseResourceOptions(): ResourceOptions {
  return { connectVersion: "", v1beta1Crd: false, k8sVersion: "" };
}

export const ResourceOptions: MessageFns<ResourceOptions> = {
  encode(message: ResourceOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectVersion !== "") {
      writer.uint32(10).string(message.connectVersion);
    }
    if (message.v1beta1Crd !== false) {
      writer.uint32(16).bool(message.v1beta1Crd);
    }
    if (message.k8sVersion !== "") {
      writer.uint32(26).string(message.k8sVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connectVersion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.v1beta1Crd = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.k8sVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceOptions {
    return {
      connectVersion: isSet(object.connectVersion) ? globalThis.String(object.connectVersion) : "",
      v1beta1Crd: isSet(object.v1beta1Crd) ? globalThis.Boolean(object.v1beta1Crd) : false,
      k8sVersion: isSet(object.k8sVersion) ? globalThis.String(object.k8sVersion) : "",
    };
  },

  toJSON(message: ResourceOptions): unknown {
    const obj: any = {};
    if (message.connectVersion !== "") {
      obj.connectVersion = message.connectVersion;
    }
    if (message.v1beta1Crd !== false) {
      obj.v1beta1Crd = message.v1beta1Crd;
    }
    if (message.k8sVersion !== "") {
      obj.k8sVersion = message.k8sVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceOptions>): ResourceOptions {
    return ResourceOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceOptions>): ResourceOptions {
    const message = createBaseResourceOptions();
    message.connectVersion = object.connectVersion ?? "";
    message.v1beta1Crd = object.v1beta1Crd ?? false;
    message.k8sVersion = object.k8sVersion ?? "";
    return message;
  },
};

function createBaseResourceManifest(): ResourceManifest {
  return { manifest: "", clusterScoped: false };
}

export const ResourceManifest: MessageFns<ResourceManifest> = {
  encode(message: ResourceManifest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manifest !== "") {
      writer.uint32(10).string(message.manifest);
    }
    if (message.clusterScoped !== false) {
      writer.uint32(16).bool(message.clusterScoped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceManifest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceManifest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manifest = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterScoped = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceManifest {
    return {
      manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "",
      clusterScoped: isSet(object.clusterScoped) ? globalThis.Boolean(object.clusterScoped) : false,
    };
  },

  toJSON(message: ResourceManifest): unknown {
    const obj: any = {};
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    if (message.clusterScoped !== false) {
      obj.clusterScoped = message.clusterScoped;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceManifest>): ResourceManifest {
    return ResourceManifest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceManifest>): ResourceManifest {
    const message = createBaseResourceManifest();
    message.manifest = object.manifest ?? "";
    message.clusterScoped = object.clusterScoped ?? false;
    return message;
  },
};

function createBaseGkeCluster(): GkeCluster {
  return { resourceLink: "", clusterMissing: false };
}

export const GkeCluster: MessageFns<GkeCluster> = {
  encode(message: GkeCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceLink !== "") {
      writer.uint32(10).string(message.resourceLink);
    }
    if (message.clusterMissing !== false) {
      writer.uint32(16).bool(message.clusterMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GkeCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGkeCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceLink = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GkeCluster {
    return {
      resourceLink: isSet(object.resourceLink) ? globalThis.String(object.resourceLink) : "",
      clusterMissing: isSet(object.clusterMissing) ? globalThis.Boolean(object.clusterMissing) : false,
    };
  },

  toJSON(message: GkeCluster): unknown {
    const obj: any = {};
    if (message.resourceLink !== "") {
      obj.resourceLink = message.resourceLink;
    }
    if (message.clusterMissing !== false) {
      obj.clusterMissing = message.clusterMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<GkeCluster>): GkeCluster {
    return GkeCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GkeCluster>): GkeCluster {
    const message = createBaseGkeCluster();
    message.resourceLink = object.resourceLink ?? "";
    message.clusterMissing = object.clusterMissing ?? false;
    return message;
  },
};

function createBaseKubernetesMetadata(): KubernetesMetadata {
  return {
    kubernetesApiServerVersion: "",
    nodeProviderId: "",
    nodeCount: 0,
    vcpuCount: 0,
    memoryMb: 0,
    updateTime: undefined,
  };
}

export const KubernetesMetadata: MessageFns<KubernetesMetadata> = {
  encode(message: KubernetesMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kubernetesApiServerVersion !== "") {
      writer.uint32(10).string(message.kubernetesApiServerVersion);
    }
    if (message.nodeProviderId !== "") {
      writer.uint32(18).string(message.nodeProviderId);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(24).int32(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      writer.uint32(32).int32(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      writer.uint32(40).int32(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kubernetesApiServerVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeProviderId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.vcpuCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memoryMb = reader.int32();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesMetadata {
    return {
      kubernetesApiServerVersion: isSet(object.kubernetesApiServerVersion)
        ? globalThis.String(object.kubernetesApiServerVersion)
        : "",
      nodeProviderId: isSet(object.nodeProviderId) ? globalThis.String(object.nodeProviderId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      vcpuCount: isSet(object.vcpuCount) ? globalThis.Number(object.vcpuCount) : 0,
      memoryMb: isSet(object.memoryMb) ? globalThis.Number(object.memoryMb) : 0,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: KubernetesMetadata): unknown {
    const obj: any = {};
    if (message.kubernetesApiServerVersion !== "") {
      obj.kubernetesApiServerVersion = message.kubernetesApiServerVersion;
    }
    if (message.nodeProviderId !== "") {
      obj.nodeProviderId = message.nodeProviderId;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.vcpuCount !== 0) {
      obj.vcpuCount = Math.round(message.vcpuCount);
    }
    if (message.memoryMb !== 0) {
      obj.memoryMb = Math.round(message.memoryMb);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesMetadata>): KubernetesMetadata {
    return KubernetesMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesMetadata>): KubernetesMetadata {
    const message = createBaseKubernetesMetadata();
    message.kubernetesApiServerVersion = object.kubernetesApiServerVersion ?? "";
    message.nodeProviderId = object.nodeProviderId ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.vcpuCount = object.vcpuCount ?? 0;
    message.memoryMb = object.memoryMb ?? 0;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseMonitoringConfig(): MonitoringConfig {
  return { projectId: "", location: "", cluster: "", kubernetesMetricsPrefix: "", clusterHash: "" };
}

export const MonitoringConfig: MessageFns<MonitoringConfig> = {
  encode(message: MonitoringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.cluster !== "") {
      writer.uint32(26).string(message.cluster);
    }
    if (message.kubernetesMetricsPrefix !== "") {
      writer.uint32(34).string(message.kubernetesMetricsPrefix);
    }
    if (message.clusterHash !== "") {
      writer.uint32(42).string(message.clusterHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kubernetesMetricsPrefix = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clusterHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoringConfig {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      kubernetesMetricsPrefix: isSet(object.kubernetesMetricsPrefix)
        ? globalThis.String(object.kubernetesMetricsPrefix)
        : "",
      clusterHash: isSet(object.clusterHash) ? globalThis.String(object.clusterHash) : "",
    };
  },

  toJSON(message: MonitoringConfig): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.kubernetesMetricsPrefix !== "") {
      obj.kubernetesMetricsPrefix = message.kubernetesMetricsPrefix;
    }
    if (message.clusterHash !== "") {
      obj.clusterHash = message.clusterHash;
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoringConfig>): MonitoringConfig {
    return MonitoringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoringConfig>): MonitoringConfig {
    const message = createBaseMonitoringConfig();
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    message.cluster = object.cluster ?? "";
    message.kubernetesMetricsPrefix = object.kubernetesMetricsPrefix ?? "";
    message.clusterHash = object.clusterHash ?? "";
    return message;
  },
};

function createBaseMembershipState(): MembershipState {
  return { code: 0 };
}

export const MembershipState: MessageFns<MembershipState> = {
  encode(message: MembershipState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipState {
    return { code: isSet(object.code) ? membershipState_CodeFromJSON(object.code) : 0 };
  },

  toJSON(message: MembershipState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = membershipState_CodeToJSON(message.code);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipState>): MembershipState {
    return MembershipState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipState>): MembershipState {
    const message = createBaseMembershipState();
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseAuthority(): Authority {
  return { issuer: "", workloadIdentityPool: "", identityProvider: "", oidcJwks: Buffer.alloc(0) };
}

export const Authority: MessageFns<Authority> = {
  encode(message: Authority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.workloadIdentityPool !== "") {
      writer.uint32(18).string(message.workloadIdentityPool);
    }
    if (message.identityProvider !== "") {
      writer.uint32(26).string(message.identityProvider);
    }
    if (message.oidcJwks.length !== 0) {
      writer.uint32(34).bytes(message.oidcJwks);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Authority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workloadIdentityPool = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.identityProvider = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.oidcJwks = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Authority {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      workloadIdentityPool: isSet(object.workloadIdentityPool) ? globalThis.String(object.workloadIdentityPool) : "",
      identityProvider: isSet(object.identityProvider) ? globalThis.String(object.identityProvider) : "",
      oidcJwks: isSet(object.oidcJwks) ? Buffer.from(bytesFromBase64(object.oidcJwks)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Authority): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.workloadIdentityPool !== "") {
      obj.workloadIdentityPool = message.workloadIdentityPool;
    }
    if (message.identityProvider !== "") {
      obj.identityProvider = message.identityProvider;
    }
    if (message.oidcJwks.length !== 0) {
      obj.oidcJwks = base64FromBytes(message.oidcJwks);
    }
    return obj;
  },

  create(base?: DeepPartial<Authority>): Authority {
    return Authority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Authority>): Authority {
    const message = createBaseAuthority();
    message.issuer = object.issuer ?? "";
    message.workloadIdentityPool = object.workloadIdentityPool ?? "";
    message.identityProvider = object.identityProvider ?? "";
    message.oidcJwks = object.oidcJwks ?? Buffer.alloc(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
