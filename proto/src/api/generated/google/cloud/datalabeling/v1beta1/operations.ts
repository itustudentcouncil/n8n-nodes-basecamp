// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datalabeling/v1beta1/operations.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { LabelStats, OutputConfig } from "./dataset.js";
import { HumanAnnotationConfig } from "./human_annotation_config.js";

export const protobufPackage = "google.cloud.datalabeling.v1beta1";

/** Response used for ImportData longrunning operation. */
export interface ImportDataOperationResponse {
  /** Ouptut only. The name of imported dataset. */
  dataset: string;
  /** Output only. Total number of examples requested to import */
  totalCount: number;
  /** Output only. Number of examples imported successfully. */
  importCount: number;
}

/** Response used for ExportDataset longrunning operation. */
export interface ExportDataOperationResponse {
  /**
   * Ouptut only. The name of dataset.
   * "projects/* /datasets/*"
   */
  dataset: string;
  /** Output only. Total number of examples requested to export */
  totalCount: number;
  /** Output only. Number of examples exported successfully. */
  exportCount: number;
  /** Output only. Statistic infos of labels in the exported dataset. */
  labelStats:
    | LabelStats
    | undefined;
  /** Output only. output_config in the ExportData request. */
  outputConfig: OutputConfig | undefined;
}

/** Metadata of an ImportData operation. */
export interface ImportDataOperationMetadata {
  /**
   * Output only. The name of imported dataset.
   * "projects/* /datasets/*"
   */
  dataset: string;
  /**
   * Output only. Partial failures encountered.
   * E.g. single files that couldn't be read.
   * Status details field will contain standard GCP error details.
   */
  partialFailures: Status[];
  /** Output only. Timestamp when import dataset request was created. */
  createTime: Date | undefined;
}

/** Metadata of an ExportData operation. */
export interface ExportDataOperationMetadata {
  /**
   * Output only. The name of dataset to be exported.
   * "projects/* /datasets/*"
   */
  dataset: string;
  /**
   * Output only. Partial failures encountered.
   * E.g. single files that couldn't be read.
   * Status details field will contain standard GCP error details.
   */
  partialFailures: Status[];
  /** Output only. Timestamp when export dataset request was created. */
  createTime: Date | undefined;
}

/**
 * Metadata of a labeling operation, such as LabelImage or LabelVideo.
 * Next tag: 20
 */
export interface LabelOperationMetadata {
  /** Details of label image classification operation. */
  imageClassificationDetails?:
    | LabelImageClassificationOperationMetadata
    | undefined;
  /** Details of label image bounding box operation. */
  imageBoundingBoxDetails?:
    | LabelImageBoundingBoxOperationMetadata
    | undefined;
  /** Details of label image bounding poly operation. */
  imageBoundingPolyDetails?:
    | LabelImageBoundingPolyOperationMetadata
    | undefined;
  /** Details of label image oriented bounding box operation. */
  imageOrientedBoundingBoxDetails?:
    | LabelImageOrientedBoundingBoxOperationMetadata
    | undefined;
  /** Details of label image polyline operation. */
  imagePolylineDetails?:
    | LabelImagePolylineOperationMetadata
    | undefined;
  /** Details of label image segmentation operation. */
  imageSegmentationDetails?:
    | LabelImageSegmentationOperationMetadata
    | undefined;
  /** Details of label video classification operation. */
  videoClassificationDetails?:
    | LabelVideoClassificationOperationMetadata
    | undefined;
  /** Details of label video object detection operation. */
  videoObjectDetectionDetails?:
    | LabelVideoObjectDetectionOperationMetadata
    | undefined;
  /** Details of label video object tracking operation. */
  videoObjectTrackingDetails?:
    | LabelVideoObjectTrackingOperationMetadata
    | undefined;
  /** Details of label video event operation. */
  videoEventDetails?:
    | LabelVideoEventOperationMetadata
    | undefined;
  /** Details of label text classification operation. */
  textClassificationDetails?:
    | LabelTextClassificationOperationMetadata
    | undefined;
  /** Details of label text entity extraction operation. */
  textEntityExtractionDetails?:
    | LabelTextEntityExtractionOperationMetadata
    | undefined;
  /** Output only. Progress of label operation. Range: [0, 100]. */
  progressPercent: number;
  /**
   * Output only. Partial failures encountered.
   * E.g. single files that couldn't be read.
   * Status details field will contain standard GCP error details.
   */
  partialFailures: Status[];
  /** Output only. Timestamp when labeling request was created. */
  createTime: Date | undefined;
}

/** Metadata of a LabelImageClassification operation. */
export interface LabelImageClassificationOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelImageBoundingBox operation metadata. */
export interface LabelImageBoundingBoxOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelImageOrientedBoundingBox operation metadata. */
export interface LabelImageOrientedBoundingBoxOperationMetadata {
  /** Basic human annotation config. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of LabelImageBoundingPoly operation metadata. */
export interface LabelImageBoundingPolyOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of LabelImagePolyline operation metadata. */
export interface LabelImagePolylineOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelImageSegmentation operation metadata. */
export interface LabelImageSegmentationOperationMetadata {
  /** Basic human annotation config. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelVideoClassification operation metadata. */
export interface LabelVideoClassificationOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelVideoObjectDetection operation metadata. */
export interface LabelVideoObjectDetectionOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelVideoObjectTracking operation metadata. */
export interface LabelVideoObjectTrackingOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelVideoEvent operation metadata. */
export interface LabelVideoEventOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelTextClassification operation metadata. */
export interface LabelTextClassificationOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Details of a LabelTextEntityExtraction operation metadata. */
export interface LabelTextEntityExtractionOperationMetadata {
  /** Basic human annotation config used in labeling request. */
  basicConfig: HumanAnnotationConfig | undefined;
}

/** Metadata of a CreateInstruction operation. */
export interface CreateInstructionMetadata {
  /**
   * The name of the created Instruction.
   * projects/{project_id}/instructions/{instruction_id}
   */
  instruction: string;
  /**
   * Partial failures encountered.
   * E.g. single files that couldn't be read.
   * Status details field will contain standard GCP error details.
   */
  partialFailures: Status[];
  /** Timestamp when create instruction request was created. */
  createTime: Date | undefined;
}

function createBaseImportDataOperationResponse(): ImportDataOperationResponse {
  return { dataset: "", totalCount: 0, importCount: 0 };
}

export const ImportDataOperationResponse: MessageFns<ImportDataOperationResponse> = {
  encode(message: ImportDataOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.importCount !== 0) {
      writer.uint32(24).int32(message.importCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDataOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDataOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.importCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDataOperationResponse {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      importCount: isSet(object.importCount) ? globalThis.Number(object.importCount) : 0,
    };
  },

  toJSON(message: ImportDataOperationResponse): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.importCount !== 0) {
      obj.importCount = Math.round(message.importCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDataOperationResponse>): ImportDataOperationResponse {
    return ImportDataOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDataOperationResponse>): ImportDataOperationResponse {
    const message = createBaseImportDataOperationResponse();
    message.dataset = object.dataset ?? "";
    message.totalCount = object.totalCount ?? 0;
    message.importCount = object.importCount ?? 0;
    return message;
  },
};

function createBaseExportDataOperationResponse(): ExportDataOperationResponse {
  return { dataset: "", totalCount: 0, exportCount: 0, labelStats: undefined, outputConfig: undefined };
}

export const ExportDataOperationResponse: MessageFns<ExportDataOperationResponse> = {
  encode(message: ExportDataOperationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.exportCount !== 0) {
      writer.uint32(24).int32(message.exportCount);
    }
    if (message.labelStats !== undefined) {
      LabelStats.encode(message.labelStats, writer.uint32(34).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDataOperationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDataOperationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.exportCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.labelStats = LabelStats.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDataOperationResponse {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      exportCount: isSet(object.exportCount) ? globalThis.Number(object.exportCount) : 0,
      labelStats: isSet(object.labelStats) ? LabelStats.fromJSON(object.labelStats) : undefined,
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
    };
  },

  toJSON(message: ExportDataOperationResponse): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.exportCount !== 0) {
      obj.exportCount = Math.round(message.exportCount);
    }
    if (message.labelStats !== undefined) {
      obj.labelStats = LabelStats.toJSON(message.labelStats);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDataOperationResponse>): ExportDataOperationResponse {
    return ExportDataOperationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDataOperationResponse>): ExportDataOperationResponse {
    const message = createBaseExportDataOperationResponse();
    message.dataset = object.dataset ?? "";
    message.totalCount = object.totalCount ?? 0;
    message.exportCount = object.exportCount ?? 0;
    message.labelStats = (object.labelStats !== undefined && object.labelStats !== null)
      ? LabelStats.fromPartial(object.labelStats)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    return message;
  },
};

function createBaseImportDataOperationMetadata(): ImportDataOperationMetadata {
  return { dataset: "", partialFailures: [], createTime: undefined };
}

export const ImportDataOperationMetadata: MessageFns<ImportDataOperationMetadata> = {
  encode(message: ImportDataOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    for (const v of message.partialFailures) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDataOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDataOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partialFailures.push(Status.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDataOperationMetadata {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      partialFailures: globalThis.Array.isArray(object?.partialFailures)
        ? object.partialFailures.map((e: any) => Status.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: ImportDataOperationMetadata): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.partialFailures?.length) {
      obj.partialFailures = message.partialFailures.map((e) => Status.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDataOperationMetadata>): ImportDataOperationMetadata {
    return ImportDataOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDataOperationMetadata>): ImportDataOperationMetadata {
    const message = createBaseImportDataOperationMetadata();
    message.dataset = object.dataset ?? "";
    message.partialFailures = object.partialFailures?.map((e) => Status.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseExportDataOperationMetadata(): ExportDataOperationMetadata {
  return { dataset: "", partialFailures: [], createTime: undefined };
}

export const ExportDataOperationMetadata: MessageFns<ExportDataOperationMetadata> = {
  encode(message: ExportDataOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== "") {
      writer.uint32(10).string(message.dataset);
    }
    for (const v of message.partialFailures) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDataOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDataOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partialFailures.push(Status.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDataOperationMetadata {
    return {
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      partialFailures: globalThis.Array.isArray(object?.partialFailures)
        ? object.partialFailures.map((e: any) => Status.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: ExportDataOperationMetadata): unknown {
    const obj: any = {};
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.partialFailures?.length) {
      obj.partialFailures = message.partialFailures.map((e) => Status.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDataOperationMetadata>): ExportDataOperationMetadata {
    return ExportDataOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDataOperationMetadata>): ExportDataOperationMetadata {
    const message = createBaseExportDataOperationMetadata();
    message.dataset = object.dataset ?? "";
    message.partialFailures = object.partialFailures?.map((e) => Status.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseLabelOperationMetadata(): LabelOperationMetadata {
  return {
    imageClassificationDetails: undefined,
    imageBoundingBoxDetails: undefined,
    imageBoundingPolyDetails: undefined,
    imageOrientedBoundingBoxDetails: undefined,
    imagePolylineDetails: undefined,
    imageSegmentationDetails: undefined,
    videoClassificationDetails: undefined,
    videoObjectDetectionDetails: undefined,
    videoObjectTrackingDetails: undefined,
    videoEventDetails: undefined,
    textClassificationDetails: undefined,
    textEntityExtractionDetails: undefined,
    progressPercent: 0,
    partialFailures: [],
    createTime: undefined,
  };
}

export const LabelOperationMetadata: MessageFns<LabelOperationMetadata> = {
  encode(message: LabelOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageClassificationDetails !== undefined) {
      LabelImageClassificationOperationMetadata.encode(message.imageClassificationDetails, writer.uint32(26).fork())
        .join();
    }
    if (message.imageBoundingBoxDetails !== undefined) {
      LabelImageBoundingBoxOperationMetadata.encode(message.imageBoundingBoxDetails, writer.uint32(34).fork()).join();
    }
    if (message.imageBoundingPolyDetails !== undefined) {
      LabelImageBoundingPolyOperationMetadata.encode(message.imageBoundingPolyDetails, writer.uint32(90).fork()).join();
    }
    if (message.imageOrientedBoundingBoxDetails !== undefined) {
      LabelImageOrientedBoundingBoxOperationMetadata.encode(
        message.imageOrientedBoundingBoxDetails,
        writer.uint32(114).fork(),
      ).join();
    }
    if (message.imagePolylineDetails !== undefined) {
      LabelImagePolylineOperationMetadata.encode(message.imagePolylineDetails, writer.uint32(98).fork()).join();
    }
    if (message.imageSegmentationDetails !== undefined) {
      LabelImageSegmentationOperationMetadata.encode(message.imageSegmentationDetails, writer.uint32(122).fork())
        .join();
    }
    if (message.videoClassificationDetails !== undefined) {
      LabelVideoClassificationOperationMetadata.encode(message.videoClassificationDetails, writer.uint32(42).fork())
        .join();
    }
    if (message.videoObjectDetectionDetails !== undefined) {
      LabelVideoObjectDetectionOperationMetadata.encode(message.videoObjectDetectionDetails, writer.uint32(50).fork())
        .join();
    }
    if (message.videoObjectTrackingDetails !== undefined) {
      LabelVideoObjectTrackingOperationMetadata.encode(message.videoObjectTrackingDetails, writer.uint32(58).fork())
        .join();
    }
    if (message.videoEventDetails !== undefined) {
      LabelVideoEventOperationMetadata.encode(message.videoEventDetails, writer.uint32(66).fork()).join();
    }
    if (message.textClassificationDetails !== undefined) {
      LabelTextClassificationOperationMetadata.encode(message.textClassificationDetails, writer.uint32(74).fork())
        .join();
    }
    if (message.textEntityExtractionDetails !== undefined) {
      LabelTextEntityExtractionOperationMetadata.encode(message.textEntityExtractionDetails, writer.uint32(106).fork())
        .join();
    }
    if (message.progressPercent !== 0) {
      writer.uint32(8).int32(message.progressPercent);
    }
    for (const v of message.partialFailures) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.imageClassificationDetails = LabelImageClassificationOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.imageBoundingBoxDetails = LabelImageBoundingBoxOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.imageBoundingPolyDetails = LabelImageBoundingPolyOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.imageOrientedBoundingBoxDetails = LabelImageOrientedBoundingBoxOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.imagePolylineDetails = LabelImagePolylineOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.imageSegmentationDetails = LabelImageSegmentationOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.videoClassificationDetails = LabelVideoClassificationOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.videoObjectDetectionDetails = LabelVideoObjectDetectionOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.videoObjectTrackingDetails = LabelVideoObjectTrackingOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.videoEventDetails = LabelVideoEventOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.textClassificationDetails = LabelTextClassificationOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.textEntityExtractionDetails = LabelTextEntityExtractionOperationMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.progressPercent = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partialFailures.push(Status.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelOperationMetadata {
    return {
      imageClassificationDetails: isSet(object.imageClassificationDetails)
        ? LabelImageClassificationOperationMetadata.fromJSON(object.imageClassificationDetails)
        : undefined,
      imageBoundingBoxDetails: isSet(object.imageBoundingBoxDetails)
        ? LabelImageBoundingBoxOperationMetadata.fromJSON(object.imageBoundingBoxDetails)
        : undefined,
      imageBoundingPolyDetails: isSet(object.imageBoundingPolyDetails)
        ? LabelImageBoundingPolyOperationMetadata.fromJSON(object.imageBoundingPolyDetails)
        : undefined,
      imageOrientedBoundingBoxDetails: isSet(object.imageOrientedBoundingBoxDetails)
        ? LabelImageOrientedBoundingBoxOperationMetadata.fromJSON(object.imageOrientedBoundingBoxDetails)
        : undefined,
      imagePolylineDetails: isSet(object.imagePolylineDetails)
        ? LabelImagePolylineOperationMetadata.fromJSON(object.imagePolylineDetails)
        : undefined,
      imageSegmentationDetails: isSet(object.imageSegmentationDetails)
        ? LabelImageSegmentationOperationMetadata.fromJSON(object.imageSegmentationDetails)
        : undefined,
      videoClassificationDetails: isSet(object.videoClassificationDetails)
        ? LabelVideoClassificationOperationMetadata.fromJSON(object.videoClassificationDetails)
        : undefined,
      videoObjectDetectionDetails: isSet(object.videoObjectDetectionDetails)
        ? LabelVideoObjectDetectionOperationMetadata.fromJSON(object.videoObjectDetectionDetails)
        : undefined,
      videoObjectTrackingDetails: isSet(object.videoObjectTrackingDetails)
        ? LabelVideoObjectTrackingOperationMetadata.fromJSON(object.videoObjectTrackingDetails)
        : undefined,
      videoEventDetails: isSet(object.videoEventDetails)
        ? LabelVideoEventOperationMetadata.fromJSON(object.videoEventDetails)
        : undefined,
      textClassificationDetails: isSet(object.textClassificationDetails)
        ? LabelTextClassificationOperationMetadata.fromJSON(object.textClassificationDetails)
        : undefined,
      textEntityExtractionDetails: isSet(object.textEntityExtractionDetails)
        ? LabelTextEntityExtractionOperationMetadata.fromJSON(object.textEntityExtractionDetails)
        : undefined,
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
      partialFailures: globalThis.Array.isArray(object?.partialFailures)
        ? object.partialFailures.map((e: any) => Status.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: LabelOperationMetadata): unknown {
    const obj: any = {};
    if (message.imageClassificationDetails !== undefined) {
      obj.imageClassificationDetails = LabelImageClassificationOperationMetadata.toJSON(
        message.imageClassificationDetails,
      );
    }
    if (message.imageBoundingBoxDetails !== undefined) {
      obj.imageBoundingBoxDetails = LabelImageBoundingBoxOperationMetadata.toJSON(message.imageBoundingBoxDetails);
    }
    if (message.imageBoundingPolyDetails !== undefined) {
      obj.imageBoundingPolyDetails = LabelImageBoundingPolyOperationMetadata.toJSON(message.imageBoundingPolyDetails);
    }
    if (message.imageOrientedBoundingBoxDetails !== undefined) {
      obj.imageOrientedBoundingBoxDetails = LabelImageOrientedBoundingBoxOperationMetadata.toJSON(
        message.imageOrientedBoundingBoxDetails,
      );
    }
    if (message.imagePolylineDetails !== undefined) {
      obj.imagePolylineDetails = LabelImagePolylineOperationMetadata.toJSON(message.imagePolylineDetails);
    }
    if (message.imageSegmentationDetails !== undefined) {
      obj.imageSegmentationDetails = LabelImageSegmentationOperationMetadata.toJSON(message.imageSegmentationDetails);
    }
    if (message.videoClassificationDetails !== undefined) {
      obj.videoClassificationDetails = LabelVideoClassificationOperationMetadata.toJSON(
        message.videoClassificationDetails,
      );
    }
    if (message.videoObjectDetectionDetails !== undefined) {
      obj.videoObjectDetectionDetails = LabelVideoObjectDetectionOperationMetadata.toJSON(
        message.videoObjectDetectionDetails,
      );
    }
    if (message.videoObjectTrackingDetails !== undefined) {
      obj.videoObjectTrackingDetails = LabelVideoObjectTrackingOperationMetadata.toJSON(
        message.videoObjectTrackingDetails,
      );
    }
    if (message.videoEventDetails !== undefined) {
      obj.videoEventDetails = LabelVideoEventOperationMetadata.toJSON(message.videoEventDetails);
    }
    if (message.textClassificationDetails !== undefined) {
      obj.textClassificationDetails = LabelTextClassificationOperationMetadata.toJSON(
        message.textClassificationDetails,
      );
    }
    if (message.textEntityExtractionDetails !== undefined) {
      obj.textEntityExtractionDetails = LabelTextEntityExtractionOperationMetadata.toJSON(
        message.textEntityExtractionDetails,
      );
    }
    if (message.progressPercent !== 0) {
      obj.progressPercent = Math.round(message.progressPercent);
    }
    if (message.partialFailures?.length) {
      obj.partialFailures = message.partialFailures.map((e) => Status.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LabelOperationMetadata>): LabelOperationMetadata {
    return LabelOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelOperationMetadata>): LabelOperationMetadata {
    const message = createBaseLabelOperationMetadata();
    message.imageClassificationDetails =
      (object.imageClassificationDetails !== undefined && object.imageClassificationDetails !== null)
        ? LabelImageClassificationOperationMetadata.fromPartial(object.imageClassificationDetails)
        : undefined;
    message.imageBoundingBoxDetails =
      (object.imageBoundingBoxDetails !== undefined && object.imageBoundingBoxDetails !== null)
        ? LabelImageBoundingBoxOperationMetadata.fromPartial(object.imageBoundingBoxDetails)
        : undefined;
    message.imageBoundingPolyDetails =
      (object.imageBoundingPolyDetails !== undefined && object.imageBoundingPolyDetails !== null)
        ? LabelImageBoundingPolyOperationMetadata.fromPartial(object.imageBoundingPolyDetails)
        : undefined;
    message.imageOrientedBoundingBoxDetails =
      (object.imageOrientedBoundingBoxDetails !== undefined && object.imageOrientedBoundingBoxDetails !== null)
        ? LabelImageOrientedBoundingBoxOperationMetadata.fromPartial(object.imageOrientedBoundingBoxDetails)
        : undefined;
    message.imagePolylineDetails = (object.imagePolylineDetails !== undefined && object.imagePolylineDetails !== null)
      ? LabelImagePolylineOperationMetadata.fromPartial(object.imagePolylineDetails)
      : undefined;
    message.imageSegmentationDetails =
      (object.imageSegmentationDetails !== undefined && object.imageSegmentationDetails !== null)
        ? LabelImageSegmentationOperationMetadata.fromPartial(object.imageSegmentationDetails)
        : undefined;
    message.videoClassificationDetails =
      (object.videoClassificationDetails !== undefined && object.videoClassificationDetails !== null)
        ? LabelVideoClassificationOperationMetadata.fromPartial(object.videoClassificationDetails)
        : undefined;
    message.videoObjectDetectionDetails =
      (object.videoObjectDetectionDetails !== undefined && object.videoObjectDetectionDetails !== null)
        ? LabelVideoObjectDetectionOperationMetadata.fromPartial(object.videoObjectDetectionDetails)
        : undefined;
    message.videoObjectTrackingDetails =
      (object.videoObjectTrackingDetails !== undefined && object.videoObjectTrackingDetails !== null)
        ? LabelVideoObjectTrackingOperationMetadata.fromPartial(object.videoObjectTrackingDetails)
        : undefined;
    message.videoEventDetails = (object.videoEventDetails !== undefined && object.videoEventDetails !== null)
      ? LabelVideoEventOperationMetadata.fromPartial(object.videoEventDetails)
      : undefined;
    message.textClassificationDetails =
      (object.textClassificationDetails !== undefined && object.textClassificationDetails !== null)
        ? LabelTextClassificationOperationMetadata.fromPartial(object.textClassificationDetails)
        : undefined;
    message.textEntityExtractionDetails =
      (object.textEntityExtractionDetails !== undefined && object.textEntityExtractionDetails !== null)
        ? LabelTextEntityExtractionOperationMetadata.fromPartial(object.textEntityExtractionDetails)
        : undefined;
    message.progressPercent = object.progressPercent ?? 0;
    message.partialFailures = object.partialFailures?.map((e) => Status.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseLabelImageClassificationOperationMetadata(): LabelImageClassificationOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImageClassificationOperationMetadata: MessageFns<LabelImageClassificationOperationMetadata> = {
  encode(message: LabelImageClassificationOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImageClassificationOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImageClassificationOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImageClassificationOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImageClassificationOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelImageClassificationOperationMetadata>): LabelImageClassificationOperationMetadata {
    return LabelImageClassificationOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelImageClassificationOperationMetadata>,
  ): LabelImageClassificationOperationMetadata {
    const message = createBaseLabelImageClassificationOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelImageBoundingBoxOperationMetadata(): LabelImageBoundingBoxOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImageBoundingBoxOperationMetadata: MessageFns<LabelImageBoundingBoxOperationMetadata> = {
  encode(message: LabelImageBoundingBoxOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImageBoundingBoxOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImageBoundingBoxOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImageBoundingBoxOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImageBoundingBoxOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelImageBoundingBoxOperationMetadata>): LabelImageBoundingBoxOperationMetadata {
    return LabelImageBoundingBoxOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelImageBoundingBoxOperationMetadata>): LabelImageBoundingBoxOperationMetadata {
    const message = createBaseLabelImageBoundingBoxOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelImageOrientedBoundingBoxOperationMetadata(): LabelImageOrientedBoundingBoxOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImageOrientedBoundingBoxOperationMetadata: MessageFns<
  LabelImageOrientedBoundingBoxOperationMetadata
> = {
  encode(
    message: LabelImageOrientedBoundingBoxOperationMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImageOrientedBoundingBoxOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImageOrientedBoundingBoxOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImageOrientedBoundingBoxOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImageOrientedBoundingBoxOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(
    base?: DeepPartial<LabelImageOrientedBoundingBoxOperationMetadata>,
  ): LabelImageOrientedBoundingBoxOperationMetadata {
    return LabelImageOrientedBoundingBoxOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelImageOrientedBoundingBoxOperationMetadata>,
  ): LabelImageOrientedBoundingBoxOperationMetadata {
    const message = createBaseLabelImageOrientedBoundingBoxOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelImageBoundingPolyOperationMetadata(): LabelImageBoundingPolyOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImageBoundingPolyOperationMetadata: MessageFns<LabelImageBoundingPolyOperationMetadata> = {
  encode(message: LabelImageBoundingPolyOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImageBoundingPolyOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImageBoundingPolyOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImageBoundingPolyOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImageBoundingPolyOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelImageBoundingPolyOperationMetadata>): LabelImageBoundingPolyOperationMetadata {
    return LabelImageBoundingPolyOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelImageBoundingPolyOperationMetadata>): LabelImageBoundingPolyOperationMetadata {
    const message = createBaseLabelImageBoundingPolyOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelImagePolylineOperationMetadata(): LabelImagePolylineOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImagePolylineOperationMetadata: MessageFns<LabelImagePolylineOperationMetadata> = {
  encode(message: LabelImagePolylineOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImagePolylineOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImagePolylineOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImagePolylineOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImagePolylineOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelImagePolylineOperationMetadata>): LabelImagePolylineOperationMetadata {
    return LabelImagePolylineOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelImagePolylineOperationMetadata>): LabelImagePolylineOperationMetadata {
    const message = createBaseLabelImagePolylineOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelImageSegmentationOperationMetadata(): LabelImageSegmentationOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelImageSegmentationOperationMetadata: MessageFns<LabelImageSegmentationOperationMetadata> = {
  encode(message: LabelImageSegmentationOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelImageSegmentationOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelImageSegmentationOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelImageSegmentationOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelImageSegmentationOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelImageSegmentationOperationMetadata>): LabelImageSegmentationOperationMetadata {
    return LabelImageSegmentationOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelImageSegmentationOperationMetadata>): LabelImageSegmentationOperationMetadata {
    const message = createBaseLabelImageSegmentationOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelVideoClassificationOperationMetadata(): LabelVideoClassificationOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelVideoClassificationOperationMetadata: MessageFns<LabelVideoClassificationOperationMetadata> = {
  encode(message: LabelVideoClassificationOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelVideoClassificationOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelVideoClassificationOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelVideoClassificationOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelVideoClassificationOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelVideoClassificationOperationMetadata>): LabelVideoClassificationOperationMetadata {
    return LabelVideoClassificationOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelVideoClassificationOperationMetadata>,
  ): LabelVideoClassificationOperationMetadata {
    const message = createBaseLabelVideoClassificationOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelVideoObjectDetectionOperationMetadata(): LabelVideoObjectDetectionOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelVideoObjectDetectionOperationMetadata: MessageFns<LabelVideoObjectDetectionOperationMetadata> = {
  encode(message: LabelVideoObjectDetectionOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelVideoObjectDetectionOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelVideoObjectDetectionOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelVideoObjectDetectionOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelVideoObjectDetectionOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelVideoObjectDetectionOperationMetadata>): LabelVideoObjectDetectionOperationMetadata {
    return LabelVideoObjectDetectionOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelVideoObjectDetectionOperationMetadata>,
  ): LabelVideoObjectDetectionOperationMetadata {
    const message = createBaseLabelVideoObjectDetectionOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelVideoObjectTrackingOperationMetadata(): LabelVideoObjectTrackingOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelVideoObjectTrackingOperationMetadata: MessageFns<LabelVideoObjectTrackingOperationMetadata> = {
  encode(message: LabelVideoObjectTrackingOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelVideoObjectTrackingOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelVideoObjectTrackingOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelVideoObjectTrackingOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelVideoObjectTrackingOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelVideoObjectTrackingOperationMetadata>): LabelVideoObjectTrackingOperationMetadata {
    return LabelVideoObjectTrackingOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelVideoObjectTrackingOperationMetadata>,
  ): LabelVideoObjectTrackingOperationMetadata {
    const message = createBaseLabelVideoObjectTrackingOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelVideoEventOperationMetadata(): LabelVideoEventOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelVideoEventOperationMetadata: MessageFns<LabelVideoEventOperationMetadata> = {
  encode(message: LabelVideoEventOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelVideoEventOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelVideoEventOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelVideoEventOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelVideoEventOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelVideoEventOperationMetadata>): LabelVideoEventOperationMetadata {
    return LabelVideoEventOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelVideoEventOperationMetadata>): LabelVideoEventOperationMetadata {
    const message = createBaseLabelVideoEventOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelTextClassificationOperationMetadata(): LabelTextClassificationOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelTextClassificationOperationMetadata: MessageFns<LabelTextClassificationOperationMetadata> = {
  encode(message: LabelTextClassificationOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelTextClassificationOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelTextClassificationOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelTextClassificationOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelTextClassificationOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelTextClassificationOperationMetadata>): LabelTextClassificationOperationMetadata {
    return LabelTextClassificationOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelTextClassificationOperationMetadata>): LabelTextClassificationOperationMetadata {
    const message = createBaseLabelTextClassificationOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseLabelTextEntityExtractionOperationMetadata(): LabelTextEntityExtractionOperationMetadata {
  return { basicConfig: undefined };
}

export const LabelTextEntityExtractionOperationMetadata: MessageFns<LabelTextEntityExtractionOperationMetadata> = {
  encode(message: LabelTextEntityExtractionOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicConfig !== undefined) {
      HumanAnnotationConfig.encode(message.basicConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelTextEntityExtractionOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelTextEntityExtractionOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basicConfig = HumanAnnotationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelTextEntityExtractionOperationMetadata {
    return { basicConfig: isSet(object.basicConfig) ? HumanAnnotationConfig.fromJSON(object.basicConfig) : undefined };
  },

  toJSON(message: LabelTextEntityExtractionOperationMetadata): unknown {
    const obj: any = {};
    if (message.basicConfig !== undefined) {
      obj.basicConfig = HumanAnnotationConfig.toJSON(message.basicConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LabelTextEntityExtractionOperationMetadata>): LabelTextEntityExtractionOperationMetadata {
    return LabelTextEntityExtractionOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<LabelTextEntityExtractionOperationMetadata>,
  ): LabelTextEntityExtractionOperationMetadata {
    const message = createBaseLabelTextEntityExtractionOperationMetadata();
    message.basicConfig = (object.basicConfig !== undefined && object.basicConfig !== null)
      ? HumanAnnotationConfig.fromPartial(object.basicConfig)
      : undefined;
    return message;
  },
};

function createBaseCreateInstructionMetadata(): CreateInstructionMetadata {
  return { instruction: "", partialFailures: [], createTime: undefined };
}

export const CreateInstructionMetadata: MessageFns<CreateInstructionMetadata> = {
  encode(message: CreateInstructionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instruction !== "") {
      writer.uint32(10).string(message.instruction);
    }
    for (const v of message.partialFailures) {
      Status.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstructionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstructionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instruction = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partialFailures.push(Status.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstructionMetadata {
    return {
      instruction: isSet(object.instruction) ? globalThis.String(object.instruction) : "",
      partialFailures: globalThis.Array.isArray(object?.partialFailures)
        ? object.partialFailures.map((e: any) => Status.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: CreateInstructionMetadata): unknown {
    const obj: any = {};
    if (message.instruction !== "") {
      obj.instruction = message.instruction;
    }
    if (message.partialFailures?.length) {
      obj.partialFailures = message.partialFailures.map((e) => Status.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstructionMetadata>): CreateInstructionMetadata {
    return CreateInstructionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstructionMetadata>): CreateInstructionMetadata {
    const message = createBaseCreateInstructionMetadata();
    message.instruction = object.instruction ?? "";
    message.partialFailures = object.partialFailures?.map((e) => Status.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
