// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/datalabeling/v1beta1/evaluation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { AnnotationType, annotationTypeFromJSON, annotationTypeToJSON } from "./annotation.js";
import { AnnotationSpec } from "./annotation_spec_set.js";

export const protobufPackage = "google.cloud.datalabeling.v1beta1";

/**
 * Describes an evaluation between a machine learning model's predictions and
 * ground truth labels. Created when an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob] runs successfully.
 */
export interface Evaluation {
  /**
   * Output only. Resource name of an evaluation. The name has the following
   * format:
   *
   * "projects/<var>{project_id}</var>/datasets/<var>{dataset_id}</var>/evaluations/<var>{evaluation_id</var>}'
   */
  name: string;
  /**
   * Output only. Options used in the evaluation job that created this
   * evaluation.
   */
  config:
    | EvaluationConfig
    | undefined;
  /**
   * Output only. Timestamp for when the evaluation job that created this
   * evaluation ran.
   */
  evaluationJobRunTime:
    | Date
    | undefined;
  /** Output only. Timestamp for when this evaluation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Metrics comparing predictions to ground truth labels. */
  evaluationMetrics:
    | EvaluationMetrics
    | undefined;
  /**
   * Output only. Type of task that the model version being evaluated performs,
   * as defined in the
   *
   * [evaluationJobConfig.inputConfig.annotationType][google.cloud.datalabeling.v1beta1.EvaluationJobConfig.input_config]
   * field of the evaluation job that created this evaluation.
   */
  annotationType: AnnotationType;
  /**
   * Output only. The number of items in the ground truth dataset that were used
   * for this evaluation. Only populated when the evaulation is for certain
   * AnnotationTypes.
   */
  evaluatedItemCount: Long;
}

/**
 * Configuration details used for calculating evaluation metrics and creating an
 * [Evaluation][google.cloud.datalabeling.v1beta1.Evaluation].
 */
export interface EvaluationConfig {
  /**
   * Only specify this field if the related model performs image object
   * detection (`IMAGE_BOUNDING_BOX_ANNOTATION`). Describes how to evaluate
   * bounding boxes.
   */
  boundingBoxEvaluationOptions?: BoundingBoxEvaluationOptions | undefined;
}

/** Options regarding evaluation between bounding boxes. */
export interface BoundingBoxEvaluationOptions {
  /**
   * Minimum
   * [intersection-over-union
   *
   * (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union)
   * required for 2 bounding boxes to be considered a match. This must be a
   * number between 0 and 1.
   */
  iouThreshold: number;
}

export interface EvaluationMetrics {
  classificationMetrics?: ClassificationMetrics | undefined;
  objectDetectionMetrics?: ObjectDetectionMetrics | undefined;
}

/** Metrics calculated for a classification model. */
export interface ClassificationMetrics {
  /**
   * Precision-recall curve based on ground truth labels, predicted labels, and
   * scores for the predicted labels.
   */
  prCurve:
    | PrCurve
    | undefined;
  /** Confusion matrix of predicted labels vs. ground truth labels. */
  confusionMatrix: ConfusionMatrix | undefined;
}

/** Metrics calculated for an image object detection (bounding box) model. */
export interface ObjectDetectionMetrics {
  /** Precision-recall curve. */
  prCurve: PrCurve | undefined;
}

export interface PrCurve {
  /**
   * The annotation spec of the label for which the precision-recall curve
   * calculated. If this field is empty, that means the precision-recall curve
   * is an aggregate curve for all labels.
   */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /**
   * Area under the precision-recall curve. Not to be confused with area under
   * a receiver operating characteristic (ROC) curve.
   */
  areaUnderCurve: number;
  /**
   * Entries that make up the precision-recall graph. Each entry is a "point" on
   * the graph drawn for a different `confidence_threshold`.
   */
  confidenceMetricsEntries: PrCurve_ConfidenceMetricsEntry[];
  /** Mean average prcision of this curve. */
  meanAveragePrecision: number;
}

export interface PrCurve_ConfidenceMetricsEntry {
  /**
   * Threshold used for this entry.
   *
   * For classification tasks, this is a classification threshold: a
   * predicted label is categorized as positive or negative (in the context of
   * this point on the PR curve) based on whether the label's score meets this
   * threshold.
   *
   * For image object detection (bounding box) tasks, this is the
   * [intersection-over-union
   *
   * (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union)
   * threshold for the context of this point on the PR curve.
   */
  confidenceThreshold: number;
  /** Recall value. */
  recall: number;
  /** Precision value. */
  precision: number;
  /** Harmonic mean of recall and precision. */
  f1Score: number;
  /** Recall value for entries with label that has highest score. */
  recallAt1: number;
  /** Precision value for entries with label that has highest score. */
  precisionAt1: number;
  /** The harmonic mean of [recall_at1][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.recall_at1] and [precision_at1][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.precision_at1]. */
  f1ScoreAt1: number;
  /** Recall value for entries with label that has highest 5 scores. */
  recallAt5: number;
  /** Precision value for entries with label that has highest 5 scores. */
  precisionAt5: number;
  /** The harmonic mean of [recall_at5][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.recall_at5] and [precision_at5][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.precision_at5]. */
  f1ScoreAt5: number;
}

/**
 * Confusion matrix of the model running the classification. Only applicable
 * when the metrics entry aggregates multiple labels. Not applicable when the
 * entry is for a single label.
 */
export interface ConfusionMatrix {
  row: ConfusionMatrix_Row[];
}

export interface ConfusionMatrix_ConfusionMatrixEntry {
  /** The annotation spec of a predicted label. */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /**
   * Number of items predicted to have this label. (The ground truth label for
   * these items is the `Row.annotationSpec` of this entry's parent.)
   */
  itemCount: number;
}

/**
 * A row in the confusion matrix. Each entry in this row has the same
 * ground truth label.
 */
export interface ConfusionMatrix_Row {
  /** The annotation spec of the ground truth label for this row. */
  annotationSpec:
    | AnnotationSpec
    | undefined;
  /**
   * A list of the confusion matrix entries. One entry for each possible
   * predicted label.
   */
  entries: ConfusionMatrix_ConfusionMatrixEntry[];
}

function createBaseEvaluation(): Evaluation {
  return {
    name: "",
    config: undefined,
    evaluationJobRunTime: undefined,
    createTime: undefined,
    evaluationMetrics: undefined,
    annotationType: 0,
    evaluatedItemCount: Long.ZERO,
  };
}

export const Evaluation: MessageFns<Evaluation> = {
  encode(message: Evaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      EvaluationConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    if (message.evaluationJobRunTime !== undefined) {
      Timestamp.encode(toTimestamp(message.evaluationJobRunTime), writer.uint32(26).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.evaluationMetrics !== undefined) {
      EvaluationMetrics.encode(message.evaluationMetrics, writer.uint32(42).fork()).join();
    }
    if (message.annotationType !== 0) {
      writer.uint32(48).int32(message.annotationType);
    }
    if (!message.evaluatedItemCount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.evaluatedItemCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = EvaluationConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.evaluationJobRunTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.evaluationMetrics = EvaluationMetrics.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.annotationType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.evaluatedItemCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? EvaluationConfig.fromJSON(object.config) : undefined,
      evaluationJobRunTime: isSet(object.evaluationJobRunTime)
        ? fromJsonTimestamp(object.evaluationJobRunTime)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      evaluationMetrics: isSet(object.evaluationMetrics)
        ? EvaluationMetrics.fromJSON(object.evaluationMetrics)
        : undefined,
      annotationType: isSet(object.annotationType) ? annotationTypeFromJSON(object.annotationType) : 0,
      evaluatedItemCount: isSet(object.evaluatedItemCount) ? Long.fromValue(object.evaluatedItemCount) : Long.ZERO,
    };
  },

  toJSON(message: Evaluation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = EvaluationConfig.toJSON(message.config);
    }
    if (message.evaluationJobRunTime !== undefined) {
      obj.evaluationJobRunTime = message.evaluationJobRunTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.evaluationMetrics !== undefined) {
      obj.evaluationMetrics = EvaluationMetrics.toJSON(message.evaluationMetrics);
    }
    if (message.annotationType !== 0) {
      obj.annotationType = annotationTypeToJSON(message.annotationType);
    }
    if (!message.evaluatedItemCount.equals(Long.ZERO)) {
      obj.evaluatedItemCount = (message.evaluatedItemCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation>): Evaluation {
    return Evaluation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation>): Evaluation {
    const message = createBaseEvaluation();
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? EvaluationConfig.fromPartial(object.config)
      : undefined;
    message.evaluationJobRunTime = object.evaluationJobRunTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.evaluationMetrics = (object.evaluationMetrics !== undefined && object.evaluationMetrics !== null)
      ? EvaluationMetrics.fromPartial(object.evaluationMetrics)
      : undefined;
    message.annotationType = object.annotationType ?? 0;
    message.evaluatedItemCount = (object.evaluatedItemCount !== undefined && object.evaluatedItemCount !== null)
      ? Long.fromValue(object.evaluatedItemCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseEvaluationConfig(): EvaluationConfig {
  return { boundingBoxEvaluationOptions: undefined };
}

export const EvaluationConfig: MessageFns<EvaluationConfig> = {
  encode(message: EvaluationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boundingBoxEvaluationOptions !== undefined) {
      BoundingBoxEvaluationOptions.encode(message.boundingBoxEvaluationOptions, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.boundingBoxEvaluationOptions = BoundingBoxEvaluationOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluationConfig {
    return {
      boundingBoxEvaluationOptions: isSet(object.boundingBoxEvaluationOptions)
        ? BoundingBoxEvaluationOptions.fromJSON(object.boundingBoxEvaluationOptions)
        : undefined,
    };
  },

  toJSON(message: EvaluationConfig): unknown {
    const obj: any = {};
    if (message.boundingBoxEvaluationOptions !== undefined) {
      obj.boundingBoxEvaluationOptions = BoundingBoxEvaluationOptions.toJSON(message.boundingBoxEvaluationOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluationConfig>): EvaluationConfig {
    return EvaluationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluationConfig>): EvaluationConfig {
    const message = createBaseEvaluationConfig();
    message.boundingBoxEvaluationOptions =
      (object.boundingBoxEvaluationOptions !== undefined && object.boundingBoxEvaluationOptions !== null)
        ? BoundingBoxEvaluationOptions.fromPartial(object.boundingBoxEvaluationOptions)
        : undefined;
    return message;
  },
};

function createBaseBoundingBoxEvaluationOptions(): BoundingBoxEvaluationOptions {
  return { iouThreshold: 0 };
}

export const BoundingBoxEvaluationOptions: MessageFns<BoundingBoxEvaluationOptions> = {
  encode(message: BoundingBoxEvaluationOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.iouThreshold !== 0) {
      writer.uint32(13).float(message.iouThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoundingBoxEvaluationOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoundingBoxEvaluationOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.iouThreshold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoundingBoxEvaluationOptions {
    return { iouThreshold: isSet(object.iouThreshold) ? globalThis.Number(object.iouThreshold) : 0 };
  },

  toJSON(message: BoundingBoxEvaluationOptions): unknown {
    const obj: any = {};
    if (message.iouThreshold !== 0) {
      obj.iouThreshold = message.iouThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<BoundingBoxEvaluationOptions>): BoundingBoxEvaluationOptions {
    return BoundingBoxEvaluationOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoundingBoxEvaluationOptions>): BoundingBoxEvaluationOptions {
    const message = createBaseBoundingBoxEvaluationOptions();
    message.iouThreshold = object.iouThreshold ?? 0;
    return message;
  },
};

function createBaseEvaluationMetrics(): EvaluationMetrics {
  return { classificationMetrics: undefined, objectDetectionMetrics: undefined };
}

export const EvaluationMetrics: MessageFns<EvaluationMetrics> = {
  encode(message: EvaluationMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classificationMetrics !== undefined) {
      ClassificationMetrics.encode(message.classificationMetrics, writer.uint32(10).fork()).join();
    }
    if (message.objectDetectionMetrics !== undefined) {
      ObjectDetectionMetrics.encode(message.objectDetectionMetrics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluationMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluationMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.classificationMetrics = ClassificationMetrics.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.objectDetectionMetrics = ObjectDetectionMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluationMetrics {
    return {
      classificationMetrics: isSet(object.classificationMetrics)
        ? ClassificationMetrics.fromJSON(object.classificationMetrics)
        : undefined,
      objectDetectionMetrics: isSet(object.objectDetectionMetrics)
        ? ObjectDetectionMetrics.fromJSON(object.objectDetectionMetrics)
        : undefined,
    };
  },

  toJSON(message: EvaluationMetrics): unknown {
    const obj: any = {};
    if (message.classificationMetrics !== undefined) {
      obj.classificationMetrics = ClassificationMetrics.toJSON(message.classificationMetrics);
    }
    if (message.objectDetectionMetrics !== undefined) {
      obj.objectDetectionMetrics = ObjectDetectionMetrics.toJSON(message.objectDetectionMetrics);
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluationMetrics>): EvaluationMetrics {
    return EvaluationMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluationMetrics>): EvaluationMetrics {
    const message = createBaseEvaluationMetrics();
    message.classificationMetrics =
      (object.classificationMetrics !== undefined && object.classificationMetrics !== null)
        ? ClassificationMetrics.fromPartial(object.classificationMetrics)
        : undefined;
    message.objectDetectionMetrics =
      (object.objectDetectionMetrics !== undefined && object.objectDetectionMetrics !== null)
        ? ObjectDetectionMetrics.fromPartial(object.objectDetectionMetrics)
        : undefined;
    return message;
  },
};

function createBaseClassificationMetrics(): ClassificationMetrics {
  return { prCurve: undefined, confusionMatrix: undefined };
}

export const ClassificationMetrics: MessageFns<ClassificationMetrics> = {
  encode(message: ClassificationMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prCurve !== undefined) {
      PrCurve.encode(message.prCurve, writer.uint32(10).fork()).join();
    }
    if (message.confusionMatrix !== undefined) {
      ConfusionMatrix.encode(message.confusionMatrix, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClassificationMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassificationMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prCurve = PrCurve.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.confusionMatrix = ConfusionMatrix.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClassificationMetrics {
    return {
      prCurve: isSet(object.prCurve) ? PrCurve.fromJSON(object.prCurve) : undefined,
      confusionMatrix: isSet(object.confusionMatrix) ? ConfusionMatrix.fromJSON(object.confusionMatrix) : undefined,
    };
  },

  toJSON(message: ClassificationMetrics): unknown {
    const obj: any = {};
    if (message.prCurve !== undefined) {
      obj.prCurve = PrCurve.toJSON(message.prCurve);
    }
    if (message.confusionMatrix !== undefined) {
      obj.confusionMatrix = ConfusionMatrix.toJSON(message.confusionMatrix);
    }
    return obj;
  },

  create(base?: DeepPartial<ClassificationMetrics>): ClassificationMetrics {
    return ClassificationMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClassificationMetrics>): ClassificationMetrics {
    const message = createBaseClassificationMetrics();
    message.prCurve = (object.prCurve !== undefined && object.prCurve !== null)
      ? PrCurve.fromPartial(object.prCurve)
      : undefined;
    message.confusionMatrix = (object.confusionMatrix !== undefined && object.confusionMatrix !== null)
      ? ConfusionMatrix.fromPartial(object.confusionMatrix)
      : undefined;
    return message;
  },
};

function createBaseObjectDetectionMetrics(): ObjectDetectionMetrics {
  return { prCurve: undefined };
}

export const ObjectDetectionMetrics: MessageFns<ObjectDetectionMetrics> = {
  encode(message: ObjectDetectionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prCurve !== undefined) {
      PrCurve.encode(message.prCurve, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectDetectionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectDetectionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prCurve = PrCurve.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectDetectionMetrics {
    return { prCurve: isSet(object.prCurve) ? PrCurve.fromJSON(object.prCurve) : undefined };
  },

  toJSON(message: ObjectDetectionMetrics): unknown {
    const obj: any = {};
    if (message.prCurve !== undefined) {
      obj.prCurve = PrCurve.toJSON(message.prCurve);
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectDetectionMetrics>): ObjectDetectionMetrics {
    return ObjectDetectionMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectDetectionMetrics>): ObjectDetectionMetrics {
    const message = createBaseObjectDetectionMetrics();
    message.prCurve = (object.prCurve !== undefined && object.prCurve !== null)
      ? PrCurve.fromPartial(object.prCurve)
      : undefined;
    return message;
  },
};

function createBasePrCurve(): PrCurve {
  return { annotationSpec: undefined, areaUnderCurve: 0, confidenceMetricsEntries: [], meanAveragePrecision: 0 };
}

export const PrCurve: MessageFns<PrCurve> = {
  encode(message: PrCurve, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    if (message.areaUnderCurve !== 0) {
      writer.uint32(21).float(message.areaUnderCurve);
    }
    for (const v of message.confidenceMetricsEntries) {
      PrCurve_ConfidenceMetricsEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.meanAveragePrecision !== 0) {
      writer.uint32(37).float(message.meanAveragePrecision);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrCurve {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrCurve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.areaUnderCurve = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.confidenceMetricsEntries.push(PrCurve_ConfidenceMetricsEntry.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.meanAveragePrecision = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrCurve {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      areaUnderCurve: isSet(object.areaUnderCurve) ? globalThis.Number(object.areaUnderCurve) : 0,
      confidenceMetricsEntries: globalThis.Array.isArray(object?.confidenceMetricsEntries)
        ? object.confidenceMetricsEntries.map((e: any) => PrCurve_ConfidenceMetricsEntry.fromJSON(e))
        : [],
      meanAveragePrecision: isSet(object.meanAveragePrecision) ? globalThis.Number(object.meanAveragePrecision) : 0,
    };
  },

  toJSON(message: PrCurve): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.areaUnderCurve !== 0) {
      obj.areaUnderCurve = message.areaUnderCurve;
    }
    if (message.confidenceMetricsEntries?.length) {
      obj.confidenceMetricsEntries = message.confidenceMetricsEntries.map((e) =>
        PrCurve_ConfidenceMetricsEntry.toJSON(e)
      );
    }
    if (message.meanAveragePrecision !== 0) {
      obj.meanAveragePrecision = message.meanAveragePrecision;
    }
    return obj;
  },

  create(base?: DeepPartial<PrCurve>): PrCurve {
    return PrCurve.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrCurve>): PrCurve {
    const message = createBasePrCurve();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.areaUnderCurve = object.areaUnderCurve ?? 0;
    message.confidenceMetricsEntries =
      object.confidenceMetricsEntries?.map((e) => PrCurve_ConfidenceMetricsEntry.fromPartial(e)) || [];
    message.meanAveragePrecision = object.meanAveragePrecision ?? 0;
    return message;
  },
};

function createBasePrCurve_ConfidenceMetricsEntry(): PrCurve_ConfidenceMetricsEntry {
  return {
    confidenceThreshold: 0,
    recall: 0,
    precision: 0,
    f1Score: 0,
    recallAt1: 0,
    precisionAt1: 0,
    f1ScoreAt1: 0,
    recallAt5: 0,
    precisionAt5: 0,
    f1ScoreAt5: 0,
  };
}

export const PrCurve_ConfidenceMetricsEntry: MessageFns<PrCurve_ConfidenceMetricsEntry> = {
  encode(message: PrCurve_ConfidenceMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceThreshold !== 0) {
      writer.uint32(13).float(message.confidenceThreshold);
    }
    if (message.recall !== 0) {
      writer.uint32(21).float(message.recall);
    }
    if (message.precision !== 0) {
      writer.uint32(29).float(message.precision);
    }
    if (message.f1Score !== 0) {
      writer.uint32(37).float(message.f1Score);
    }
    if (message.recallAt1 !== 0) {
      writer.uint32(45).float(message.recallAt1);
    }
    if (message.precisionAt1 !== 0) {
      writer.uint32(53).float(message.precisionAt1);
    }
    if (message.f1ScoreAt1 !== 0) {
      writer.uint32(61).float(message.f1ScoreAt1);
    }
    if (message.recallAt5 !== 0) {
      writer.uint32(69).float(message.recallAt5);
    }
    if (message.precisionAt5 !== 0) {
      writer.uint32(77).float(message.precisionAt5);
    }
    if (message.f1ScoreAt5 !== 0) {
      writer.uint32(85).float(message.f1ScoreAt5);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrCurve_ConfidenceMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrCurve_ConfidenceMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidenceThreshold = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.recall = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.precision = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.f1Score = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.recallAt1 = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.precisionAt1 = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.f1ScoreAt1 = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.recallAt5 = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.precisionAt5 = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.f1ScoreAt5 = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrCurve_ConfidenceMetricsEntry {
    return {
      confidenceThreshold: isSet(object.confidenceThreshold) ? globalThis.Number(object.confidenceThreshold) : 0,
      recall: isSet(object.recall) ? globalThis.Number(object.recall) : 0,
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      f1Score: isSet(object.f1Score) ? globalThis.Number(object.f1Score) : 0,
      recallAt1: isSet(object.recallAt1) ? globalThis.Number(object.recallAt1) : 0,
      precisionAt1: isSet(object.precisionAt1) ? globalThis.Number(object.precisionAt1) : 0,
      f1ScoreAt1: isSet(object.f1ScoreAt1) ? globalThis.Number(object.f1ScoreAt1) : 0,
      recallAt5: isSet(object.recallAt5) ? globalThis.Number(object.recallAt5) : 0,
      precisionAt5: isSet(object.precisionAt5) ? globalThis.Number(object.precisionAt5) : 0,
      f1ScoreAt5: isSet(object.f1ScoreAt5) ? globalThis.Number(object.f1ScoreAt5) : 0,
    };
  },

  toJSON(message: PrCurve_ConfidenceMetricsEntry): unknown {
    const obj: any = {};
    if (message.confidenceThreshold !== 0) {
      obj.confidenceThreshold = message.confidenceThreshold;
    }
    if (message.recall !== 0) {
      obj.recall = message.recall;
    }
    if (message.precision !== 0) {
      obj.precision = message.precision;
    }
    if (message.f1Score !== 0) {
      obj.f1Score = message.f1Score;
    }
    if (message.recallAt1 !== 0) {
      obj.recallAt1 = message.recallAt1;
    }
    if (message.precisionAt1 !== 0) {
      obj.precisionAt1 = message.precisionAt1;
    }
    if (message.f1ScoreAt1 !== 0) {
      obj.f1ScoreAt1 = message.f1ScoreAt1;
    }
    if (message.recallAt5 !== 0) {
      obj.recallAt5 = message.recallAt5;
    }
    if (message.precisionAt5 !== 0) {
      obj.precisionAt5 = message.precisionAt5;
    }
    if (message.f1ScoreAt5 !== 0) {
      obj.f1ScoreAt5 = message.f1ScoreAt5;
    }
    return obj;
  },

  create(base?: DeepPartial<PrCurve_ConfidenceMetricsEntry>): PrCurve_ConfidenceMetricsEntry {
    return PrCurve_ConfidenceMetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrCurve_ConfidenceMetricsEntry>): PrCurve_ConfidenceMetricsEntry {
    const message = createBasePrCurve_ConfidenceMetricsEntry();
    message.confidenceThreshold = object.confidenceThreshold ?? 0;
    message.recall = object.recall ?? 0;
    message.precision = object.precision ?? 0;
    message.f1Score = object.f1Score ?? 0;
    message.recallAt1 = object.recallAt1 ?? 0;
    message.precisionAt1 = object.precisionAt1 ?? 0;
    message.f1ScoreAt1 = object.f1ScoreAt1 ?? 0;
    message.recallAt5 = object.recallAt5 ?? 0;
    message.precisionAt5 = object.precisionAt5 ?? 0;
    message.f1ScoreAt5 = object.f1ScoreAt5 ?? 0;
    return message;
  },
};

function createBaseConfusionMatrix(): ConfusionMatrix {
  return { row: [] };
}

export const ConfusionMatrix: MessageFns<ConfusionMatrix> = {
  encode(message: ConfusionMatrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.row) {
      ConfusionMatrix_Row.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfusionMatrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfusionMatrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.row.push(ConfusionMatrix_Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfusionMatrix {
    return {
      row: globalThis.Array.isArray(object?.row) ? object.row.map((e: any) => ConfusionMatrix_Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: ConfusionMatrix): unknown {
    const obj: any = {};
    if (message.row?.length) {
      obj.row = message.row.map((e) => ConfusionMatrix_Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConfusionMatrix>): ConfusionMatrix {
    return ConfusionMatrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfusionMatrix>): ConfusionMatrix {
    const message = createBaseConfusionMatrix();
    message.row = object.row?.map((e) => ConfusionMatrix_Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConfusionMatrix_ConfusionMatrixEntry(): ConfusionMatrix_ConfusionMatrixEntry {
  return { annotationSpec: undefined, itemCount: 0 };
}

export const ConfusionMatrix_ConfusionMatrixEntry: MessageFns<ConfusionMatrix_ConfusionMatrixEntry> = {
  encode(message: ConfusionMatrix_ConfusionMatrixEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    if (message.itemCount !== 0) {
      writer.uint32(16).int32(message.itemCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfusionMatrix_ConfusionMatrixEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfusionMatrix_ConfusionMatrixEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.itemCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfusionMatrix_ConfusionMatrixEntry {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      itemCount: isSet(object.itemCount) ? globalThis.Number(object.itemCount) : 0,
    };
  },

  toJSON(message: ConfusionMatrix_ConfusionMatrixEntry): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.itemCount !== 0) {
      obj.itemCount = Math.round(message.itemCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ConfusionMatrix_ConfusionMatrixEntry>): ConfusionMatrix_ConfusionMatrixEntry {
    return ConfusionMatrix_ConfusionMatrixEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfusionMatrix_ConfusionMatrixEntry>): ConfusionMatrix_ConfusionMatrixEntry {
    const message = createBaseConfusionMatrix_ConfusionMatrixEntry();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.itemCount = object.itemCount ?? 0;
    return message;
  },
};

function createBaseConfusionMatrix_Row(): ConfusionMatrix_Row {
  return { annotationSpec: undefined, entries: [] };
}

export const ConfusionMatrix_Row: MessageFns<ConfusionMatrix_Row> = {
  encode(message: ConfusionMatrix_Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.annotationSpec !== undefined) {
      AnnotationSpec.encode(message.annotationSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.entries) {
      ConfusionMatrix_ConfusionMatrixEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfusionMatrix_Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfusionMatrix_Row();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationSpec = AnnotationSpec.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entries.push(ConfusionMatrix_ConfusionMatrixEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfusionMatrix_Row {
    return {
      annotationSpec: isSet(object.annotationSpec) ? AnnotationSpec.fromJSON(object.annotationSpec) : undefined,
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => ConfusionMatrix_ConfusionMatrixEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConfusionMatrix_Row): unknown {
    const obj: any = {};
    if (message.annotationSpec !== undefined) {
      obj.annotationSpec = AnnotationSpec.toJSON(message.annotationSpec);
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => ConfusionMatrix_ConfusionMatrixEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConfusionMatrix_Row>): ConfusionMatrix_Row {
    return ConfusionMatrix_Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfusionMatrix_Row>): ConfusionMatrix_Row {
    const message = createBaseConfusionMatrix_Row();
    message.annotationSpec = (object.annotationSpec !== undefined && object.annotationSpec !== null)
      ? AnnotationSpec.fromPartial(object.annotationSpec)
      : undefined;
    message.entries = object.entries?.map((e) => ConfusionMatrix_ConfusionMatrixEntry.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
