// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/speech/v1p1beta1/resource.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.speech.v1p1beta1";

/**
 * A set of words or phrases that represents a common concept likely to appear
 * in your audio, for example a list of passenger ship names. CustomClass items
 * can be substituted into placeholders that you set in PhraseSet phrases.
 */
export interface CustomClass {
  /** The resource name of the custom class. */
  name: string;
  /**
   * If this custom class is a resource, the custom_class_id is the resource id
   * of the CustomClass. Case sensitive.
   */
  customClassId: string;
  /** A collection of class items. */
  items: CustomClass_ClassItem[];
}

/** An item of the class. */
export interface CustomClass_ClassItem {
  /** The class item's value. */
  value: string;
}

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 */
export interface PhraseSet {
  /** The resource name of the phrase set. */
  name: string;
  /** A list of word and phrases. */
  phrases: PhraseSet_Phrase[];
  /**
   * Hint Boost. Positive value will increase the probability that a specific
   * phrase will be recognized over other similar sounding phrases. The higher
   * the boost, the higher the chance of false positive recognition as well.
   * Negative boost values would correspond to anti-biasing. Anti-biasing is not
   * enabled, so negative boost will simply be ignored. Though `boost` can
   * accept a wide range of positive values, most use cases are best served with
   * values between 0 (exclusive) and 20. We recommend using a binary search
   * approach to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   */
  boost: number;
}

/**
 * A phrases containing words and phrase "hints" so that
 * the speech recognition is more likely to recognize them. This can be used
 * to improve the accuracy for specific words and phrases, for example, if
 * specific commands are typically spoken by the user. This can also be used
 * to add additional words to the vocabulary of the recognizer. See
 * [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
 *
 * List items can also include pre-built or custom classes containing groups
 * of words that represent common concepts that occur in natural language. For
 * example, rather than providing a phrase hint for every month of the
 * year (e.g. "i was born in january", "i was born in febuary", ...), use the
 * pre-built `$MONTH` class improves the likelihood of correctly transcribing
 * audio that includes months (e.g. "i was born in $month").
 * To refer to pre-built classes, use the class' symbol prepended with `$`
 * e.g. `$MONTH`. To refer to custom classes that were defined inline in the
 * request, set the class's `custom_class_id` to a string unique to all class
 * resources and inline classes. Then use the class' id wrapped in $`{...}`
 * e.g. "${my-months}". To refer to custom classes resources, use the class'
 * id wrapped in `${}` (e.g. `${my-months}`).
 *
 * Speech-to-Text supports three locations: `global`, `us` (US North America),
 * and `eu` (Europe). If you are calling the `speech.googleapis.com`
 * endpoint, use the `global` location. To specify a region, use a
 * [regional endpoint](https://cloud.google.com/speech-to-text/docs/endpoints)
 * with matching `us` or `eu` location value.
 */
export interface PhraseSet_Phrase {
  /** The phrase itself. */
  value: string;
  /**
   * Hint Boost. Overrides the boost set at the phrase set level.
   * Positive value will increase the probability that a specific phrase will
   * be recognized over other similar sounding phrases. The higher the boost,
   * the higher the chance of false positive recognition as well. Negative
   * boost will simply be ignored. Though `boost` can accept a wide range of
   * positive values, most use cases are best served
   * with values between 0 and 20. We recommend using a binary search approach
   * to finding the optimal value for your use case as well as adding
   * phrases both with and without boost to your requests.
   */
  boost: number;
}

/** Speech adaptation configuration. */
export interface SpeechAdaptation {
  /**
   * A collection of phrase sets. To specify the hints inline, leave the
   * phrase set's `name` blank and fill in the rest of its fields. Any
   * phrase set can use any custom class.
   */
  phraseSets: PhraseSet[];
  /** A collection of phrase set resource names to use. */
  phraseSetReferences: string[];
  /**
   * A collection of custom classes. To specify the classes inline, leave the
   * class' `name` blank and fill in the rest of its fields, giving it a unique
   * `custom_class_id`. Refer to the inline defined class in phrase hints by its
   * `custom_class_id`.
   */
  customClasses: CustomClass[];
  /**
   * Augmented Backus-Naur form (ABNF) is a standardized grammar notation
   * comprised by a set of derivation rules.
   * See specifications: https://www.w3.org/TR/speech-grammar
   */
  abnfGrammar: SpeechAdaptation_ABNFGrammar | undefined;
}

export interface SpeechAdaptation_ABNFGrammar {
  /**
   * All declarations and rules of an ABNF grammar broken up into multiple
   * strings that will end up concatenated.
   */
  abnfStrings: string[];
}

/**
 * Transcription normalization configuration. Use transcription normalization
 * to automatically replace parts of the transcript with phrases of your
 * choosing. For StreamingRecognize, this normalization only applies to stable
 * partial transcripts (stability > 0.8) and final transcripts.
 */
export interface TranscriptNormalization {
  /**
   * A list of replacement entries. We will perform replacement with one entry
   * at a time. For example, the second entry in ["cat" => "dog", "mountain cat"
   * => "mountain dog"] will never be applied because we will always process the
   * first entry before it. At most 100 entries.
   */
  entries: TranscriptNormalization_Entry[];
}

/** A single replacement configuration. */
export interface TranscriptNormalization_Entry {
  /** What to replace. Max length is 100 characters. */
  search: string;
  /** What to replace with. Max length is 100 characters. */
  replace: string;
  /** Whether the search is case sensitive. */
  caseSensitive: boolean;
}

function createBaseCustomClass(): CustomClass {
  return { name: "", customClassId: "", items: [] };
}

export const CustomClass: MessageFns<CustomClass> = {
  encode(message: CustomClass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.customClassId !== "") {
      writer.uint32(18).string(message.customClassId);
    }
    for (const v of message.items) {
      CustomClass_ClassItem.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customClassId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.items.push(CustomClass_ClassItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClass {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      customClassId: isSet(object.customClassId) ? globalThis.String(object.customClassId) : "",
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => CustomClass_ClassItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomClass): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.customClassId !== "") {
      obj.customClassId = message.customClassId;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => CustomClass_ClassItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomClass>): CustomClass {
    return CustomClass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomClass>): CustomClass {
    const message = createBaseCustomClass();
    message.name = object.name ?? "";
    message.customClassId = object.customClassId ?? "";
    message.items = object.items?.map((e) => CustomClass_ClassItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCustomClass_ClassItem(): CustomClass_ClassItem {
  return { value: "" };
}

export const CustomClass_ClassItem: MessageFns<CustomClass_ClassItem> = {
  encode(message: CustomClass_ClassItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomClass_ClassItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomClass_ClassItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomClass_ClassItem {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: CustomClass_ClassItem): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomClass_ClassItem>): CustomClass_ClassItem {
    return CustomClass_ClassItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomClass_ClassItem>): CustomClass_ClassItem {
    const message = createBaseCustomClass_ClassItem();
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePhraseSet(): PhraseSet {
  return { name: "", phrases: [], boost: 0 };
}

export const PhraseSet: MessageFns<PhraseSet> = {
  encode(message: PhraseSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.phrases) {
      PhraseSet_Phrase.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.boost !== 0) {
      writer.uint32(37).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phrases.push(PhraseSet_Phrase.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.boost = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phrases: globalThis.Array.isArray(object?.phrases)
        ? object.phrases.map((e: any) => PhraseSet_Phrase.fromJSON(e))
        : [],
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: PhraseSet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phrases?.length) {
      obj.phrases = message.phrases.map((e) => PhraseSet_Phrase.toJSON(e));
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseSet>): PhraseSet {
    return PhraseSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseSet>): PhraseSet {
    const message = createBasePhraseSet();
    message.name = object.name ?? "";
    message.phrases = object.phrases?.map((e) => PhraseSet_Phrase.fromPartial(e)) || [];
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBasePhraseSet_Phrase(): PhraseSet_Phrase {
  return { value: "", boost: 0 };
}

export const PhraseSet_Phrase: MessageFns<PhraseSet_Phrase> = {
  encode(message: PhraseSet_Phrase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseSet_Phrase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseSet_Phrase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseSet_Phrase {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: PhraseSet_Phrase): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseSet_Phrase>): PhraseSet_Phrase {
    return PhraseSet_Phrase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseSet_Phrase>): PhraseSet_Phrase {
    const message = createBasePhraseSet_Phrase();
    message.value = object.value ?? "";
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBaseSpeechAdaptation(): SpeechAdaptation {
  return { phraseSets: [], phraseSetReferences: [], customClasses: [], abnfGrammar: undefined };
}

export const SpeechAdaptation: MessageFns<SpeechAdaptation> = {
  encode(message: SpeechAdaptation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.phraseSets) {
      PhraseSet.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.phraseSetReferences) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.customClasses) {
      CustomClass.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.abnfGrammar !== undefined) {
      SpeechAdaptation_ABNFGrammar.encode(message.abnfGrammar, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechAdaptation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechAdaptation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phraseSets.push(PhraseSet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phraseSetReferences.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customClasses.push(CustomClass.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.abnfGrammar = SpeechAdaptation_ABNFGrammar.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechAdaptation {
    return {
      phraseSets: globalThis.Array.isArray(object?.phraseSets)
        ? object.phraseSets.map((e: any) => PhraseSet.fromJSON(e))
        : [],
      phraseSetReferences: globalThis.Array.isArray(object?.phraseSetReferences)
        ? object.phraseSetReferences.map((e: any) => globalThis.String(e))
        : [],
      customClasses: globalThis.Array.isArray(object?.customClasses)
        ? object.customClasses.map((e: any) => CustomClass.fromJSON(e))
        : [],
      abnfGrammar: isSet(object.abnfGrammar) ? SpeechAdaptation_ABNFGrammar.fromJSON(object.abnfGrammar) : undefined,
    };
  },

  toJSON(message: SpeechAdaptation): unknown {
    const obj: any = {};
    if (message.phraseSets?.length) {
      obj.phraseSets = message.phraseSets.map((e) => PhraseSet.toJSON(e));
    }
    if (message.phraseSetReferences?.length) {
      obj.phraseSetReferences = message.phraseSetReferences;
    }
    if (message.customClasses?.length) {
      obj.customClasses = message.customClasses.map((e) => CustomClass.toJSON(e));
    }
    if (message.abnfGrammar !== undefined) {
      obj.abnfGrammar = SpeechAdaptation_ABNFGrammar.toJSON(message.abnfGrammar);
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechAdaptation>): SpeechAdaptation {
    return SpeechAdaptation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechAdaptation>): SpeechAdaptation {
    const message = createBaseSpeechAdaptation();
    message.phraseSets = object.phraseSets?.map((e) => PhraseSet.fromPartial(e)) || [];
    message.phraseSetReferences = object.phraseSetReferences?.map((e) => e) || [];
    message.customClasses = object.customClasses?.map((e) => CustomClass.fromPartial(e)) || [];
    message.abnfGrammar = (object.abnfGrammar !== undefined && object.abnfGrammar !== null)
      ? SpeechAdaptation_ABNFGrammar.fromPartial(object.abnfGrammar)
      : undefined;
    return message;
  },
};

function createBaseSpeechAdaptation_ABNFGrammar(): SpeechAdaptation_ABNFGrammar {
  return { abnfStrings: [] };
}

export const SpeechAdaptation_ABNFGrammar: MessageFns<SpeechAdaptation_ABNFGrammar> = {
  encode(message: SpeechAdaptation_ABNFGrammar, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.abnfStrings) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechAdaptation_ABNFGrammar {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechAdaptation_ABNFGrammar();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.abnfStrings.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechAdaptation_ABNFGrammar {
    return {
      abnfStrings: globalThis.Array.isArray(object?.abnfStrings)
        ? object.abnfStrings.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SpeechAdaptation_ABNFGrammar): unknown {
    const obj: any = {};
    if (message.abnfStrings?.length) {
      obj.abnfStrings = message.abnfStrings;
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechAdaptation_ABNFGrammar>): SpeechAdaptation_ABNFGrammar {
    return SpeechAdaptation_ABNFGrammar.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechAdaptation_ABNFGrammar>): SpeechAdaptation_ABNFGrammar {
    const message = createBaseSpeechAdaptation_ABNFGrammar();
    message.abnfStrings = object.abnfStrings?.map((e) => e) || [];
    return message;
  },
};

function createBaseTranscriptNormalization(): TranscriptNormalization {
  return { entries: [] };
}

export const TranscriptNormalization: MessageFns<TranscriptNormalization> = {
  encode(message: TranscriptNormalization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      TranscriptNormalization_Entry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptNormalization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptNormalization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(TranscriptNormalization_Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptNormalization {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => TranscriptNormalization_Entry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TranscriptNormalization): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => TranscriptNormalization_Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptNormalization>): TranscriptNormalization {
    return TranscriptNormalization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptNormalization>): TranscriptNormalization {
    const message = createBaseTranscriptNormalization();
    message.entries = object.entries?.map((e) => TranscriptNormalization_Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTranscriptNormalization_Entry(): TranscriptNormalization_Entry {
  return { search: "", replace: "", caseSensitive: false };
}

export const TranscriptNormalization_Entry: MessageFns<TranscriptNormalization_Entry> = {
  encode(message: TranscriptNormalization_Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.replace !== "") {
      writer.uint32(18).string(message.replace);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(24).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptNormalization_Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptNormalization_Entry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replace = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptNormalization_Entry {
    return {
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      replace: isSet(object.replace) ? globalThis.String(object.replace) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: TranscriptNormalization_Entry): unknown {
    const obj: any = {};
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.replace !== "") {
      obj.replace = message.replace;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptNormalization_Entry>): TranscriptNormalization_Entry {
    return TranscriptNormalization_Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptNormalization_Entry>): TranscriptNormalization_Entry {
    const message = createBaseTranscriptNormalization_Entry();
    message.search = object.search ?? "";
    message.replace = object.replace ?? "";
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
