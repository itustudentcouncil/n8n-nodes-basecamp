// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/speech/v1/cloud_speech.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue } from "../../../protobuf/wrappers.js";
import { Status } from "../../../rpc/status.js";
import { SpeechAdaptation, TranscriptNormalization } from "./resource.js";

export const protobufPackage = "google.cloud.speech.v1";

/** The top-level message sent by the client for the `Recognize` method. */
export interface RecognizeRequest {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   */
  config:
    | RecognitionConfig
    | undefined;
  /** Required. The audio data to be recognized. */
  audio: RecognitionAudio | undefined;
}

/**
 * The top-level message sent by the client for the `LongRunningRecognize`
 * method.
 */
export interface LongRunningRecognizeRequest {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   */
  config:
    | RecognitionConfig
    | undefined;
  /** Required. The audio data to be recognized. */
  audio:
    | RecognitionAudio
    | undefined;
  /** Optional. Specifies an optional destination for the recognition results. */
  outputConfig: TranscriptOutputConfig | undefined;
}

/** Specifies an optional destination for the recognition results. */
export interface TranscriptOutputConfig {
  /**
   * Specifies a Cloud Storage URI for the recognition results. Must be
   * specified in the format: `gs://bucket_name/object_name`, and the bucket
   * must already exist.
   */
  gcsUri?: string | undefined;
}

/**
 * The top-level message sent by the client for the `StreamingRecognize` method.
 * Multiple `StreamingRecognizeRequest` messages are sent. The first message
 * must contain a `streaming_config` message and must not contain
 * `audio_content`. All subsequent messages must contain `audio_content` and
 * must not contain a `streaming_config` message.
 */
export interface StreamingRecognizeRequest {
  /**
   * Provides information to the recognizer that specifies how to process the
   * request. The first `StreamingRecognizeRequest` message must contain a
   * `streaming_config`  message.
   */
  streamingConfig?:
    | StreamingRecognitionConfig
    | undefined;
  /**
   * The audio data to be recognized. Sequential chunks of audio data are sent
   * in sequential `StreamingRecognizeRequest` messages. The first
   * `StreamingRecognizeRequest` message must not contain `audio_content` data
   * and all subsequent `StreamingRecognizeRequest` messages must contain
   * `audio_content` data. The audio bytes must be encoded as specified in
   * `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
   * pure binary representation (not base64). See
   * [content limits](https://cloud.google.com/speech-to-text/quotas#content).
   */
  audioContent?: Buffer | undefined;
}

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 */
export interface StreamingRecognitionConfig {
  /**
   * Required. Provides information to the recognizer that specifies how to
   * process the request.
   */
  config:
    | RecognitionConfig
    | undefined;
  /**
   * If `false` or omitted, the recognizer will perform continuous
   * recognition (continuing to wait for and process audio even if the user
   * pauses speaking) until the client closes the input stream (gRPC API) or
   * until the maximum time limit has been reached. May return multiple
   * `StreamingRecognitionResult`s with the `is_final` flag set to `true`.
   *
   * If `true`, the recognizer will detect a single spoken utterance. When it
   * detects that the user has paused or stopped speaking, it will return an
   * `END_OF_SINGLE_UTTERANCE` event and cease recognition. It will return no
   * more than one `StreamingRecognitionResult` with the `is_final` flag set to
   * `true`.
   *
   * The `single_utterance` field can only be used with specified models,
   * otherwise an error is thrown. The `model` field in [`RecognitionConfig`][]
   * must be set to:
   *
   * * `command_and_search`
   * * `phone_call` AND additional field `useEnhanced`=`true`
   * * The `model` field is left undefined. In this case the API auto-selects
   *   a model based on any other parameters that you set in
   *   `RecognitionConfig`.
   */
  singleUtterance: boolean;
  /**
   * If `true`, interim results (tentative hypotheses) may be
   * returned as they become available (these interim results are indicated with
   * the `is_final=false` flag).
   * If `false` or omitted, only `is_final=true` result(s) are returned.
   */
  interimResults: boolean;
  /**
   * If `true`, responses with voice activity speech events will be returned as
   * they are detected.
   */
  enableVoiceActivityEvents: boolean;
  /**
   * If set, the server will automatically close the stream after the specified
   * duration has elapsed after the last VOICE_ACTIVITY speech event has been
   * sent. The field `voice_activity_events` must also be set to true.
   */
  voiceActivityTimeout: StreamingRecognitionConfig_VoiceActivityTimeout | undefined;
}

/** Events that a timeout can be set on for voice activity. */
export interface StreamingRecognitionConfig_VoiceActivityTimeout {
  /** Duration to timeout the stream if no speech begins. */
  speechStartTimeout:
    | Duration
    | undefined;
  /** Duration to timeout the stream after speech ends. */
  speechEndTimeout: Duration | undefined;
}

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 */
export interface RecognitionConfig {
  /**
   * Encoding of audio data sent in all `RecognitionAudio` messages.
   * This field is optional for `FLAC` and `WAV` audio files and required
   * for all other audio formats. For details, see
   * [AudioEncoding][google.cloud.speech.v1.RecognitionConfig.AudioEncoding].
   */
  encoding: RecognitionConfig_AudioEncoding;
  /**
   * Sample rate in Hertz of the audio data sent in all
   * `RecognitionAudio` messages. Valid values are: 8000-48000.
   * 16000 is optimal. For best results, set the sampling rate of the audio
   * source to 16000 Hz. If that's not possible, use the native sample rate of
   * the audio source (instead of re-sampling).
   * This field is optional for FLAC and WAV audio files, but is
   * required for all other audio formats. For details, see
   * [AudioEncoding][google.cloud.speech.v1.RecognitionConfig.AudioEncoding].
   */
  sampleRateHertz: number;
  /**
   * The number of channels in the input audio data.
   * ONLY set this for MULTI-CHANNEL recognition.
   * Valid values for LINEAR16, OGG_OPUS and FLAC are `1`-`8`.
   * Valid value for MULAW, AMR, AMR_WB and SPEEX_WITH_HEADER_BYTE is only `1`.
   * If `0` or omitted, defaults to one channel (mono).
   * Note: We only recognize the first channel by default.
   * To perform independent recognition on each channel set
   * `enable_separate_recognition_per_channel` to 'true'.
   */
  audioChannelCount: number;
  /**
   * This needs to be set to `true` explicitly and `audio_channel_count` > 1
   * to get each channel recognized separately. The recognition result will
   * contain a `channel_tag` field to state which channel that result belongs
   * to. If this is not true, we will only recognize the first channel. The
   * request is billed cumulatively for all channels recognized:
   * `audio_channel_count` multiplied by the length of the audio.
   */
  enableSeparateRecognitionPerChannel: boolean;
  /**
   * Required. The language of the supplied audio as a
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
   * Example: "en-US".
   * See [Language
   * Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
   * of the currently supported language codes.
   */
  languageCode: string;
  /**
   * A list of up to 3 additional
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags,
   * listing possible alternative languages of the supplied audio.
   * See [Language
   * Support](https://cloud.google.com/speech-to-text/docs/languages) for a list
   * of the currently supported language codes. If alternative languages are
   * listed, recognition result will contain recognition in the most likely
   * language detected including the main language_code. The recognition result
   * will include the language tag of the language detected in the audio. Note:
   * This feature is only supported for Voice Command and Voice Search use cases
   * and performance may vary for other use cases (e.g., phone call
   * transcription).
   */
  alternativeLanguageCodes: string[];
  /**
   * Maximum number of recognition hypotheses to be returned.
   * Specifically, the maximum number of `SpeechRecognitionAlternative` messages
   * within each `SpeechRecognitionResult`.
   * The server may return fewer than `max_alternatives`.
   * Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
   * one. If omitted, will return a maximum of one.
   */
  maxAlternatives: number;
  /**
   * If set to `true`, the server will attempt to filter out
   * profanities, replacing all but the initial character in each filtered word
   * with asterisks, e.g. "f***". If set to `false` or omitted, profanities
   * won't be filtered out.
   */
  profanityFilter: boolean;
  /**
   * Speech adaptation configuration improves the accuracy of speech
   * recognition. For more information, see the [speech
   * adaptation](https://cloud.google.com/speech-to-text/docs/adaptation)
   * documentation.
   * When speech adaptation is set it supersedes the `speech_contexts` field.
   */
  adaptation:
    | SpeechAdaptation
    | undefined;
  /**
   * Optional. Use transcription normalization to automatically replace parts of
   * the transcript with phrases of your choosing. For StreamingRecognize, this
   * normalization only applies to stable partial transcripts (stability > 0.8)
   * and final transcripts.
   */
  transcriptNormalization:
    | TranscriptNormalization
    | undefined;
  /**
   * Array of [SpeechContext][google.cloud.speech.v1.SpeechContext].
   * A means to provide context to assist the speech recognition. For more
   * information, see
   * [speech
   * adaptation](https://cloud.google.com/speech-to-text/docs/adaptation).
   */
  speechContexts: SpeechContext[];
  /**
   * If `true`, the top result includes a list of words and
   * the start and end time offsets (timestamps) for those words. If
   * `false`, no word-level time offset information is returned. The default is
   * `false`.
   */
  enableWordTimeOffsets: boolean;
  /**
   * If `true`, the top result includes a list of words and the
   * confidence for those words. If `false`, no word-level confidence
   * information is returned. The default is `false`.
   */
  enableWordConfidence: boolean;
  /**
   * If 'true', adds punctuation to recognition result hypotheses.
   * This feature is only available in select languages. Setting this for
   * requests in other languages has no effect at all.
   * The default 'false' value does not add punctuation to result hypotheses.
   */
  enableAutomaticPunctuation: boolean;
  /**
   * The spoken punctuation behavior for the call
   * If not set, uses default behavior based on model of choice
   * e.g. command_and_search will enable spoken punctuation by default
   * If 'true', replaces spoken punctuation with the corresponding symbols in
   * the request. For example, "how are you question mark" becomes "how are
   * you?". See https://cloud.google.com/speech-to-text/docs/spoken-punctuation
   * for support. If 'false', spoken punctuation is not replaced.
   */
  enableSpokenPunctuation:
    | boolean
    | undefined;
  /**
   * The spoken emoji behavior for the call
   * If not set, uses default behavior based on model of choice
   * If 'true', adds spoken emoji formatting for the request. This will replace
   * spoken emojis with the corresponding Unicode symbols in the final
   * transcript. If 'false', spoken emojis are not replaced.
   */
  enableSpokenEmojis:
    | boolean
    | undefined;
  /**
   * Config to enable speaker diarization and set additional
   * parameters to make diarization better suited for your application.
   * Note: When this is enabled, we send all the words from the beginning of the
   * audio for the top alternative in every consecutive STREAMING responses.
   * This is done in order to improve our speaker tags as our models learn to
   * identify the speakers in the conversation over time.
   * For non-streaming requests, the diarization results will be provided only
   * in the top alternative of the FINAL SpeechRecognitionResult.
   */
  diarizationConfig:
    | SpeakerDiarizationConfig
    | undefined;
  /** Metadata regarding this request. */
  metadata:
    | RecognitionMetadata
    | undefined;
  /**
   * Which model to select for the given request. Select the model
   * best suited to your domain to get best results. If a model is not
   * explicitly specified, then we auto-select a model based on the parameters
   * in the RecognitionConfig.
   * <table>
   *   <tr>
   *     <td><b>Model</b></td>
   *     <td><b>Description</b></td>
   *   </tr>
   *   <tr>
   *     <td><code>latest_long</code></td>
   *     <td>Best for long form content like media or conversation.</td>
   *   </tr>
   *   <tr>
   *     <td><code>latest_short</code></td>
   *     <td>Best for short form content like commands or single shot directed
   *     speech.</td>
   *   </tr>
   *   <tr>
   *     <td><code>command_and_search</code></td>
   *     <td>Best for short queries such as voice commands or voice search.</td>
   *   </tr>
   *   <tr>
   *     <td><code>phone_call</code></td>
   *     <td>Best for audio that originated from a phone call (typically
   *     recorded at an 8khz sampling rate).</td>
   *   </tr>
   *   <tr>
   *     <td><code>video</code></td>
   *     <td>Best for audio that originated from video or includes multiple
   *         speakers. Ideally the audio is recorded at a 16khz or greater
   *         sampling rate. This is a premium model that costs more than the
   *         standard rate.</td>
   *   </tr>
   *   <tr>
   *     <td><code>default</code></td>
   *     <td>Best for audio that is not one of the specific audio models.
   *         For example, long-form audio. Ideally the audio is high-fidelity,
   *         recorded at a 16khz or greater sampling rate.</td>
   *   </tr>
   *   <tr>
   *     <td><code>medical_conversation</code></td>
   *     <td>Best for audio that originated from a conversation between a
   *         medical provider and patient.</td>
   *   </tr>
   *   <tr>
   *     <td><code>medical_dictation</code></td>
   *     <td>Best for audio that originated from dictation notes by a medical
   *         provider.</td>
   *   </tr>
   * </table>
   */
  model: string;
  /**
   * Set to true to use an enhanced model for speech recognition.
   * If `use_enhanced` is set to true and the `model` field is not set, then
   * an appropriate enhanced model is chosen if an enhanced model exists for
   * the audio.
   *
   * If `use_enhanced` is true and an enhanced version of the specified model
   * does not exist, then the speech is recognized using the standard version
   * of the specified model.
   */
  useEnhanced: boolean;
}

/**
 * The encoding of the audio data sent in the request.
 *
 * All encodings support only 1 channel (mono) audio, unless the
 * `audio_channel_count` and `enable_separate_recognition_per_channel` fields
 * are set.
 *
 * For best results, the audio source should be captured and transmitted using
 * a lossless encoding (`FLAC` or `LINEAR16`). The accuracy of the speech
 * recognition can be reduced if lossy codecs are used to capture or transmit
 * audio, particularly if background noise is present. Lossy codecs include
 * `MULAW`, `AMR`, `AMR_WB`, `OGG_OPUS`, `SPEEX_WITH_HEADER_BYTE`, `MP3`,
 * and `WEBM_OPUS`.
 *
 * The `FLAC` and `WAV` audio file formats include a header that describes the
 * included audio content. You can request recognition for `WAV` files that
 * contain either `LINEAR16` or `MULAW` encoded audio.
 * If you send `FLAC` or `WAV` audio file format in
 * your request, you do not need to specify an `AudioEncoding`; the audio
 * encoding format is determined from the file header. If you specify
 * an `AudioEncoding` when you send  send `FLAC` or `WAV` audio, the
 * encoding configuration must match the encoding described in the audio
 * header; otherwise the request returns an
 * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT] error
 * code.
 */
export enum RecognitionConfig_AudioEncoding {
  /** ENCODING_UNSPECIFIED - Not specified. */
  ENCODING_UNSPECIFIED = 0,
  /** LINEAR16 - Uncompressed 16-bit signed little-endian samples (Linear PCM). */
  LINEAR16 = 1,
  /**
   * FLAC - `FLAC` (Free Lossless Audio
   * Codec) is the recommended encoding because it is
   * lossless--therefore recognition is not compromised--and
   * requires only about half the bandwidth of `LINEAR16`. `FLAC` stream
   * encoding supports 16-bit and 24-bit samples, however, not all fields in
   * `STREAMINFO` are supported.
   */
  FLAC = 2,
  /** MULAW - 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law. */
  MULAW = 3,
  /** AMR - Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000. */
  AMR = 4,
  /** AMR_WB - Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000. */
  AMR_WB = 5,
  /**
   * OGG_OPUS - Opus encoded audio frames in Ogg container
   * ([OggOpus](https://wiki.xiph.org/OggOpus)).
   * `sample_rate_hertz` must be one of 8000, 12000, 16000, 24000, or 48000.
   */
  OGG_OPUS = 6,
  /**
   * SPEEX_WITH_HEADER_BYTE - Although the use of lossy encodings is not recommended, if a very low
   * bitrate encoding is required, `OGG_OPUS` is highly preferred over
   * Speex encoding. The [Speex](https://speex.org/)  encoding supported by
   * Cloud Speech API has a header byte in each block, as in MIME type
   * `audio/x-speex-with-header-byte`.
   * It is a variant of the RTP Speex encoding defined in
   * [RFC 5574](https://tools.ietf.org/html/rfc5574).
   * The stream is a sequence of blocks, one block per RTP packet. Each block
   * starts with a byte containing the length of the block, in bytes, followed
   * by one or more frames of Speex data, padded to an integral number of
   * bytes (octets) as specified in RFC 5574. In other words, each RTP header
   * is replaced with a single byte containing the block length. Only Speex
   * wideband is supported. `sample_rate_hertz` must be 16000.
   */
  SPEEX_WITH_HEADER_BYTE = 7,
  /**
   * MP3 - MP3 audio. MP3 encoding is a Beta feature and only available in
   * v1p1beta1. Support all standard MP3 bitrates (which range from 32-320
   * kbps). When using this encoding, `sample_rate_hertz` has to match the
   * sample rate of the file being used.
   */
  MP3 = 8,
  /**
   * WEBM_OPUS - Opus encoded audio frames in WebM container
   * ([OggOpus](https://wiki.xiph.org/OggOpus)). `sample_rate_hertz` must be
   * one of 8000, 12000, 16000, 24000, or 48000.
   */
  WEBM_OPUS = 9,
  UNRECOGNIZED = -1,
}

export function recognitionConfig_AudioEncodingFromJSON(object: any): RecognitionConfig_AudioEncoding {
  switch (object) {
    case 0:
    case "ENCODING_UNSPECIFIED":
      return RecognitionConfig_AudioEncoding.ENCODING_UNSPECIFIED;
    case 1:
    case "LINEAR16":
      return RecognitionConfig_AudioEncoding.LINEAR16;
    case 2:
    case "FLAC":
      return RecognitionConfig_AudioEncoding.FLAC;
    case 3:
    case "MULAW":
      return RecognitionConfig_AudioEncoding.MULAW;
    case 4:
    case "AMR":
      return RecognitionConfig_AudioEncoding.AMR;
    case 5:
    case "AMR_WB":
      return RecognitionConfig_AudioEncoding.AMR_WB;
    case 6:
    case "OGG_OPUS":
      return RecognitionConfig_AudioEncoding.OGG_OPUS;
    case 7:
    case "SPEEX_WITH_HEADER_BYTE":
      return RecognitionConfig_AudioEncoding.SPEEX_WITH_HEADER_BYTE;
    case 8:
    case "MP3":
      return RecognitionConfig_AudioEncoding.MP3;
    case 9:
    case "WEBM_OPUS":
      return RecognitionConfig_AudioEncoding.WEBM_OPUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecognitionConfig_AudioEncoding.UNRECOGNIZED;
  }
}

export function recognitionConfig_AudioEncodingToJSON(object: RecognitionConfig_AudioEncoding): string {
  switch (object) {
    case RecognitionConfig_AudioEncoding.ENCODING_UNSPECIFIED:
      return "ENCODING_UNSPECIFIED";
    case RecognitionConfig_AudioEncoding.LINEAR16:
      return "LINEAR16";
    case RecognitionConfig_AudioEncoding.FLAC:
      return "FLAC";
    case RecognitionConfig_AudioEncoding.MULAW:
      return "MULAW";
    case RecognitionConfig_AudioEncoding.AMR:
      return "AMR";
    case RecognitionConfig_AudioEncoding.AMR_WB:
      return "AMR_WB";
    case RecognitionConfig_AudioEncoding.OGG_OPUS:
      return "OGG_OPUS";
    case RecognitionConfig_AudioEncoding.SPEEX_WITH_HEADER_BYTE:
      return "SPEEX_WITH_HEADER_BYTE";
    case RecognitionConfig_AudioEncoding.MP3:
      return "MP3";
    case RecognitionConfig_AudioEncoding.WEBM_OPUS:
      return "WEBM_OPUS";
    case RecognitionConfig_AudioEncoding.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Config to enable speaker diarization. */
export interface SpeakerDiarizationConfig {
  /**
   * If 'true', enables speaker detection for each recognized word in
   * the top alternative of the recognition result using a speaker_label
   * provided in the WordInfo.
   */
  enableSpeakerDiarization: boolean;
  /**
   * Minimum number of speakers in the conversation. This range gives you more
   * flexibility by allowing the system to automatically determine the correct
   * number of speakers. If not set, the default value is 2.
   */
  minSpeakerCount: number;
  /**
   * Maximum number of speakers in the conversation. This range gives you more
   * flexibility by allowing the system to automatically determine the correct
   * number of speakers. If not set, the default value is 6.
   */
  maxSpeakerCount: number;
  /**
   * Output only. Unused.
   *
   * @deprecated
   */
  speakerTag: number;
}

/**
 * Description of audio data to be recognized.
 *
 * @deprecated
 */
export interface RecognitionMetadata {
  /** The use case most closely describing the audio content to be recognized. */
  interactionType: RecognitionMetadata_InteractionType;
  /**
   * The industry vertical to which this speech recognition request most
   * closely applies. This is most indicative of the topics contained
   * in the audio.  Use the 6-digit NAICS code to identify the industry
   * vertical - see https://www.naics.com/search/.
   */
  industryNaicsCodeOfAudio: number;
  /** The audio type that most closely describes the audio being recognized. */
  microphoneDistance: RecognitionMetadata_MicrophoneDistance;
  /** The original media the speech was recorded on. */
  originalMediaType: RecognitionMetadata_OriginalMediaType;
  /** The type of device the speech was recorded with. */
  recordingDeviceType: RecognitionMetadata_RecordingDeviceType;
  /**
   * The device used to make the recording.  Examples 'Nexus 5X' or
   * 'Polycom SoundStation IP 6000' or 'POTS' or 'VoIP' or
   * 'Cardioid Microphone'.
   */
  recordingDeviceName: string;
  /**
   * Mime type of the original audio file.  For example `audio/m4a`,
   * `audio/x-alaw-basic`, `audio/mp3`, `audio/3gpp`.
   * A list of possible audio mime types is maintained at
   * http://www.iana.org/assignments/media-types/media-types.xhtml#audio
   */
  originalMimeType: string;
  /**
   * Description of the content. Eg. "Recordings of federal supreme court
   * hearings from 2012".
   */
  audioTopic: string;
}

/**
 * Use case categories that the audio recognition request can be described
 * by.
 */
export enum RecognitionMetadata_InteractionType {
  /**
   * INTERACTION_TYPE_UNSPECIFIED - Use case is either unknown or is something other than one of the other
   * values below.
   */
  INTERACTION_TYPE_UNSPECIFIED = 0,
  /**
   * DISCUSSION - Multiple people in a conversation or discussion. For example in a
   * meeting with two or more people actively participating. Typically
   * all the primary people speaking would be in the same room (if not,
   * see PHONE_CALL)
   */
  DISCUSSION = 1,
  /**
   * PRESENTATION - One or more persons lecturing or presenting to others, mostly
   * uninterrupted.
   */
  PRESENTATION = 2,
  /**
   * PHONE_CALL - A phone-call or video-conference in which two or more people, who are
   * not in the same room, are actively participating.
   */
  PHONE_CALL = 3,
  /** VOICEMAIL - A recorded message intended for another person to listen to. */
  VOICEMAIL = 4,
  /** PROFESSIONALLY_PRODUCED - Professionally produced audio (eg. TV Show, Podcast). */
  PROFESSIONALLY_PRODUCED = 5,
  /** VOICE_SEARCH - Transcribe spoken questions and queries into text. */
  VOICE_SEARCH = 6,
  /** VOICE_COMMAND - Transcribe voice commands, such as for controlling a device. */
  VOICE_COMMAND = 7,
  /**
   * DICTATION - Transcribe speech to text to create a written document, such as a
   * text-message, email or report.
   */
  DICTATION = 8,
  UNRECOGNIZED = -1,
}

export function recognitionMetadata_InteractionTypeFromJSON(object: any): RecognitionMetadata_InteractionType {
  switch (object) {
    case 0:
    case "INTERACTION_TYPE_UNSPECIFIED":
      return RecognitionMetadata_InteractionType.INTERACTION_TYPE_UNSPECIFIED;
    case 1:
    case "DISCUSSION":
      return RecognitionMetadata_InteractionType.DISCUSSION;
    case 2:
    case "PRESENTATION":
      return RecognitionMetadata_InteractionType.PRESENTATION;
    case 3:
    case "PHONE_CALL":
      return RecognitionMetadata_InteractionType.PHONE_CALL;
    case 4:
    case "VOICEMAIL":
      return RecognitionMetadata_InteractionType.VOICEMAIL;
    case 5:
    case "PROFESSIONALLY_PRODUCED":
      return RecognitionMetadata_InteractionType.PROFESSIONALLY_PRODUCED;
    case 6:
    case "VOICE_SEARCH":
      return RecognitionMetadata_InteractionType.VOICE_SEARCH;
    case 7:
    case "VOICE_COMMAND":
      return RecognitionMetadata_InteractionType.VOICE_COMMAND;
    case 8:
    case "DICTATION":
      return RecognitionMetadata_InteractionType.DICTATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecognitionMetadata_InteractionType.UNRECOGNIZED;
  }
}

export function recognitionMetadata_InteractionTypeToJSON(object: RecognitionMetadata_InteractionType): string {
  switch (object) {
    case RecognitionMetadata_InteractionType.INTERACTION_TYPE_UNSPECIFIED:
      return "INTERACTION_TYPE_UNSPECIFIED";
    case RecognitionMetadata_InteractionType.DISCUSSION:
      return "DISCUSSION";
    case RecognitionMetadata_InteractionType.PRESENTATION:
      return "PRESENTATION";
    case RecognitionMetadata_InteractionType.PHONE_CALL:
      return "PHONE_CALL";
    case RecognitionMetadata_InteractionType.VOICEMAIL:
      return "VOICEMAIL";
    case RecognitionMetadata_InteractionType.PROFESSIONALLY_PRODUCED:
      return "PROFESSIONALLY_PRODUCED";
    case RecognitionMetadata_InteractionType.VOICE_SEARCH:
      return "VOICE_SEARCH";
    case RecognitionMetadata_InteractionType.VOICE_COMMAND:
      return "VOICE_COMMAND";
    case RecognitionMetadata_InteractionType.DICTATION:
      return "DICTATION";
    case RecognitionMetadata_InteractionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumerates the types of capture settings describing an audio file. */
export enum RecognitionMetadata_MicrophoneDistance {
  /** MICROPHONE_DISTANCE_UNSPECIFIED - Audio type is not known. */
  MICROPHONE_DISTANCE_UNSPECIFIED = 0,
  /**
   * NEARFIELD - The audio was captured from a closely placed microphone. Eg. phone,
   * dictaphone, or handheld microphone. Generally if there speaker is within
   * 1 meter of the microphone.
   */
  NEARFIELD = 1,
  /** MIDFIELD - The speaker if within 3 meters of the microphone. */
  MIDFIELD = 2,
  /** FARFIELD - The speaker is more than 3 meters away from the microphone. */
  FARFIELD = 3,
  UNRECOGNIZED = -1,
}

export function recognitionMetadata_MicrophoneDistanceFromJSON(object: any): RecognitionMetadata_MicrophoneDistance {
  switch (object) {
    case 0:
    case "MICROPHONE_DISTANCE_UNSPECIFIED":
      return RecognitionMetadata_MicrophoneDistance.MICROPHONE_DISTANCE_UNSPECIFIED;
    case 1:
    case "NEARFIELD":
      return RecognitionMetadata_MicrophoneDistance.NEARFIELD;
    case 2:
    case "MIDFIELD":
      return RecognitionMetadata_MicrophoneDistance.MIDFIELD;
    case 3:
    case "FARFIELD":
      return RecognitionMetadata_MicrophoneDistance.FARFIELD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecognitionMetadata_MicrophoneDistance.UNRECOGNIZED;
  }
}

export function recognitionMetadata_MicrophoneDistanceToJSON(object: RecognitionMetadata_MicrophoneDistance): string {
  switch (object) {
    case RecognitionMetadata_MicrophoneDistance.MICROPHONE_DISTANCE_UNSPECIFIED:
      return "MICROPHONE_DISTANCE_UNSPECIFIED";
    case RecognitionMetadata_MicrophoneDistance.NEARFIELD:
      return "NEARFIELD";
    case RecognitionMetadata_MicrophoneDistance.MIDFIELD:
      return "MIDFIELD";
    case RecognitionMetadata_MicrophoneDistance.FARFIELD:
      return "FARFIELD";
    case RecognitionMetadata_MicrophoneDistance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The original media the speech was recorded on. */
export enum RecognitionMetadata_OriginalMediaType {
  /** ORIGINAL_MEDIA_TYPE_UNSPECIFIED - Unknown original media type. */
  ORIGINAL_MEDIA_TYPE_UNSPECIFIED = 0,
  /** AUDIO - The speech data is an audio recording. */
  AUDIO = 1,
  /** VIDEO - The speech data originally recorded on a video. */
  VIDEO = 2,
  UNRECOGNIZED = -1,
}

export function recognitionMetadata_OriginalMediaTypeFromJSON(object: any): RecognitionMetadata_OriginalMediaType {
  switch (object) {
    case 0:
    case "ORIGINAL_MEDIA_TYPE_UNSPECIFIED":
      return RecognitionMetadata_OriginalMediaType.ORIGINAL_MEDIA_TYPE_UNSPECIFIED;
    case 1:
    case "AUDIO":
      return RecognitionMetadata_OriginalMediaType.AUDIO;
    case 2:
    case "VIDEO":
      return RecognitionMetadata_OriginalMediaType.VIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecognitionMetadata_OriginalMediaType.UNRECOGNIZED;
  }
}

export function recognitionMetadata_OriginalMediaTypeToJSON(object: RecognitionMetadata_OriginalMediaType): string {
  switch (object) {
    case RecognitionMetadata_OriginalMediaType.ORIGINAL_MEDIA_TYPE_UNSPECIFIED:
      return "ORIGINAL_MEDIA_TYPE_UNSPECIFIED";
    case RecognitionMetadata_OriginalMediaType.AUDIO:
      return "AUDIO";
    case RecognitionMetadata_OriginalMediaType.VIDEO:
      return "VIDEO";
    case RecognitionMetadata_OriginalMediaType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of device the speech was recorded with. */
export enum RecognitionMetadata_RecordingDeviceType {
  /** RECORDING_DEVICE_TYPE_UNSPECIFIED - The recording device is unknown. */
  RECORDING_DEVICE_TYPE_UNSPECIFIED = 0,
  /** SMARTPHONE - Speech was recorded on a smartphone. */
  SMARTPHONE = 1,
  /** PC - Speech was recorded using a personal computer or tablet. */
  PC = 2,
  /** PHONE_LINE - Speech was recorded over a phone line. */
  PHONE_LINE = 3,
  /** VEHICLE - Speech was recorded in a vehicle. */
  VEHICLE = 4,
  /** OTHER_OUTDOOR_DEVICE - Speech was recorded outdoors. */
  OTHER_OUTDOOR_DEVICE = 5,
  /** OTHER_INDOOR_DEVICE - Speech was recorded indoors. */
  OTHER_INDOOR_DEVICE = 6,
  UNRECOGNIZED = -1,
}

export function recognitionMetadata_RecordingDeviceTypeFromJSON(object: any): RecognitionMetadata_RecordingDeviceType {
  switch (object) {
    case 0:
    case "RECORDING_DEVICE_TYPE_UNSPECIFIED":
      return RecognitionMetadata_RecordingDeviceType.RECORDING_DEVICE_TYPE_UNSPECIFIED;
    case 1:
    case "SMARTPHONE":
      return RecognitionMetadata_RecordingDeviceType.SMARTPHONE;
    case 2:
    case "PC":
      return RecognitionMetadata_RecordingDeviceType.PC;
    case 3:
    case "PHONE_LINE":
      return RecognitionMetadata_RecordingDeviceType.PHONE_LINE;
    case 4:
    case "VEHICLE":
      return RecognitionMetadata_RecordingDeviceType.VEHICLE;
    case 5:
    case "OTHER_OUTDOOR_DEVICE":
      return RecognitionMetadata_RecordingDeviceType.OTHER_OUTDOOR_DEVICE;
    case 6:
    case "OTHER_INDOOR_DEVICE":
      return RecognitionMetadata_RecordingDeviceType.OTHER_INDOOR_DEVICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecognitionMetadata_RecordingDeviceType.UNRECOGNIZED;
  }
}

export function recognitionMetadata_RecordingDeviceTypeToJSON(object: RecognitionMetadata_RecordingDeviceType): string {
  switch (object) {
    case RecognitionMetadata_RecordingDeviceType.RECORDING_DEVICE_TYPE_UNSPECIFIED:
      return "RECORDING_DEVICE_TYPE_UNSPECIFIED";
    case RecognitionMetadata_RecordingDeviceType.SMARTPHONE:
      return "SMARTPHONE";
    case RecognitionMetadata_RecordingDeviceType.PC:
      return "PC";
    case RecognitionMetadata_RecordingDeviceType.PHONE_LINE:
      return "PHONE_LINE";
    case RecognitionMetadata_RecordingDeviceType.VEHICLE:
      return "VEHICLE";
    case RecognitionMetadata_RecordingDeviceType.OTHER_OUTDOOR_DEVICE:
      return "OTHER_OUTDOOR_DEVICE";
    case RecognitionMetadata_RecordingDeviceType.OTHER_INDOOR_DEVICE:
      return "OTHER_INDOOR_DEVICE";
    case RecognitionMetadata_RecordingDeviceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 */
export interface SpeechContext {
  /**
   * A list of strings containing words and phrases "hints" so that
   * the speech recognition is more likely to recognize them. This can be used
   * to improve the accuracy for specific words and phrases, for example, if
   * specific commands are typically spoken by the user. This can also be used
   * to add additional words to the vocabulary of the recognizer. See
   * [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
   *
   * List items can also be set to classes for groups of words that represent
   * common concepts that occur in natural language. For example, rather than
   * providing phrase hints for every month of the year, using the $MONTH class
   * improves the likelihood of correctly transcribing audio that includes
   * months.
   */
  phrases: string[];
  /**
   * Hint Boost. Positive value will increase the probability that a specific
   * phrase will be recognized over other similar sounding phrases. The higher
   * the boost, the higher the chance of false positive recognition as well.
   * Negative boost values would correspond to anti-biasing. Anti-biasing is not
   * enabled, so negative boost will simply be ignored. Though `boost` can
   * accept a wide range of positive values, most use cases are best served with
   * values between 0 and 20. We recommend using a binary search approach to
   * finding the optimal value for your use case.
   */
  boost: number;
}

/**
 * Contains audio data in the encoding specified in the `RecognitionConfig`.
 * Either `content` or `uri` must be supplied. Supplying both or neither
 * returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
 * See [content limits](https://cloud.google.com/speech-to-text/quotas#content).
 */
export interface RecognitionAudio {
  /**
   * The audio data bytes encoded as specified in
   * `RecognitionConfig`. Note: as with all bytes fields, proto buffers use a
   * pure binary representation, whereas JSON representations use base64.
   */
  content?:
    | Buffer
    | undefined;
  /**
   * URI that points to a file that contains audio data bytes as specified in
   * `RecognitionConfig`. The file must not be compressed (for example, gzip).
   * Currently, only Google Cloud Storage URIs are
   * supported, which must be specified in the following format:
   * `gs://bucket_name/object_name` (other URI formats return
   * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]).
   * For more information, see [Request
   * URIs](https://cloud.google.com/storage/docs/reference-uris).
   */
  uri?: string | undefined;
}

/**
 * The only message returned to the client by the `Recognize` method. It
 * contains the result as zero or more sequential `SpeechRecognitionResult`
 * messages.
 */
export interface RecognizeResponse {
  /**
   * Sequential list of transcription results corresponding to
   * sequential portions of audio.
   */
  results: SpeechRecognitionResult[];
  /** When available, billed audio seconds for the corresponding request. */
  totalBilledTime:
    | Duration
    | undefined;
  /** Provides information on adaptation behavior in response */
  speechAdaptationInfo:
    | SpeechAdaptationInfo
    | undefined;
  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   */
  requestId: Long;
}

/**
 * The only message returned to the client by the `LongRunningRecognize` method.
 * It contains the result as zero or more sequential `SpeechRecognitionResult`
 * messages. It is included in the `result.response` field of the `Operation`
 * returned by the `GetOperation` call of the `google::longrunning::Operations`
 * service.
 */
export interface LongRunningRecognizeResponse {
  /**
   * Sequential list of transcription results corresponding to
   * sequential portions of audio.
   */
  results: SpeechRecognitionResult[];
  /** When available, billed audio seconds for the corresponding request. */
  totalBilledTime:
    | Duration
    | undefined;
  /** Original output config if present in the request. */
  outputConfig:
    | TranscriptOutputConfig
    | undefined;
  /** If the transcript output fails this field contains the relevant error. */
  outputError:
    | Status
    | undefined;
  /** Provides information on speech adaptation behavior in response */
  speechAdaptationInfo:
    | SpeechAdaptationInfo
    | undefined;
  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   */
  requestId: Long;
}

/**
 * Describes the progress of a long-running `LongRunningRecognize` call. It is
 * included in the `metadata` field of the `Operation` returned by the
 * `GetOperation` call of the `google::longrunning::Operations` service.
 */
export interface LongRunningRecognizeMetadata {
  /**
   * Approximate percentage of audio processed thus far. Guaranteed to be 100
   * when the audio is fully processed and the results are available.
   */
  progressPercent: number;
  /** Time when the request was received. */
  startTime:
    | Date
    | undefined;
  /** Time of the most recent processing update. */
  lastUpdateTime:
    | Date
    | undefined;
  /**
   * Output only. The URI of the audio file being transcribed. Empty if the
   * audio was sent as byte content.
   */
  uri: string;
}

/**
 * `StreamingRecognizeResponse` is the only message returned to the client by
 * `StreamingRecognize`. A series of zero or more `StreamingRecognizeResponse`
 * messages are streamed back to the client. If there is no recognizable
 * audio, and `single_utterance` is set to false, then no messages are streamed
 * back to the client.
 *
 * Here's an example of a series of `StreamingRecognizeResponse`s that might be
 * returned while processing audio:
 *
 * 1. results { alternatives { transcript: "tube" } stability: 0.01 }
 *
 * 2. results { alternatives { transcript: "to be a" } stability: 0.01 }
 *
 * 3. results { alternatives { transcript: "to be" } stability: 0.9 }
 *    results { alternatives { transcript: " or not to be" } stability: 0.01 }
 *
 * 4. results { alternatives { transcript: "to be or not to be"
 *                             confidence: 0.92 }
 *              alternatives { transcript: "to bee or not to bee" }
 *              is_final: true }
 *
 * 5. results { alternatives { transcript: " that's" } stability: 0.01 }
 *
 * 6. results { alternatives { transcript: " that is" } stability: 0.9 }
 *    results { alternatives { transcript: " the question" } stability: 0.01 }
 *
 * 7. results { alternatives { transcript: " that is the question"
 *                             confidence: 0.98 }
 *              alternatives { transcript: " that was the question" }
 *              is_final: true }
 *
 * Notes:
 *
 * - Only two of the above responses #4 and #7 contain final results; they are
 *   indicated by `is_final: true`. Concatenating these together generates the
 *   full transcript: "to be or not to be that is the question".
 *
 * - The others contain interim `results`. #3 and #6 contain two interim
 *   `results`: the first portion has a high stability and is less likely to
 *   change; the second portion has a low stability and is very likely to
 *   change. A UI designer might choose to show only high stability `results`.
 *
 * - The specific `stability` and `confidence` values shown above are only for
 *   illustrative purposes. Actual values may vary.
 *
 * - In each response, only one of these fields will be set:
 *     `error`,
 *     `speech_event_type`, or
 *     one or more (repeated) `results`.
 */
export interface StreamingRecognizeResponse {
  /**
   * If set, returns a [google.rpc.Status][google.rpc.Status] message that
   * specifies the error for the operation.
   */
  error:
    | Status
    | undefined;
  /**
   * This repeated list contains zero or more results that
   * correspond to consecutive portions of the audio currently being processed.
   * It contains zero or one `is_final=true` result (the newly settled portion),
   * followed by zero or more `is_final=false` results (the interim results).
   */
  results: StreamingRecognitionResult[];
  /** Indicates the type of speech event. */
  speechEventType: StreamingRecognizeResponse_SpeechEventType;
  /** Time offset between the beginning of the audio and event emission. */
  speechEventTime:
    | Duration
    | undefined;
  /**
   * When available, billed audio seconds for the stream.
   * Set only if this is the last response in the stream.
   */
  totalBilledTime:
    | Duration
    | undefined;
  /** Provides information on adaptation behavior in response */
  speechAdaptationInfo:
    | SpeechAdaptationInfo
    | undefined;
  /**
   * The ID associated with the request. This is a unique ID specific only to
   * the given request.
   */
  requestId: Long;
}

/** Indicates the type of speech event. */
export enum StreamingRecognizeResponse_SpeechEventType {
  /** SPEECH_EVENT_UNSPECIFIED - No speech event specified. */
  SPEECH_EVENT_UNSPECIFIED = 0,
  /**
   * END_OF_SINGLE_UTTERANCE - This event indicates that the server has detected the end of the user's
   * speech utterance and expects no additional speech. Therefore, the server
   * will not process additional audio (although it may subsequently return
   * additional results). The client should stop sending additional audio
   * data, half-close the gRPC connection, and wait for any additional results
   * until the server closes the gRPC connection. This event is only sent if
   * `single_utterance` was set to `true`, and is not used otherwise.
   */
  END_OF_SINGLE_UTTERANCE = 1,
  /**
   * SPEECH_ACTIVITY_BEGIN - This event indicates that the server has detected the beginning of human
   * voice activity in the stream. This event can be returned multiple times
   * if speech starts and stops repeatedly throughout the stream. This event
   * is only sent if `voice_activity_events` is set to true.
   */
  SPEECH_ACTIVITY_BEGIN = 2,
  /**
   * SPEECH_ACTIVITY_END - This event indicates that the server has detected the end of human voice
   * activity in the stream. This event can be returned multiple times if
   * speech starts and stops repeatedly throughout the stream. This event is
   * only sent if `voice_activity_events` is set to true.
   */
  SPEECH_ACTIVITY_END = 3,
  /**
   * SPEECH_ACTIVITY_TIMEOUT - This event indicates that the user-set timeout for speech activity begin
   * or end has exceeded. Upon receiving this event, the client is expected to
   * send a half close. Further audio will not be processed.
   */
  SPEECH_ACTIVITY_TIMEOUT = 4,
  UNRECOGNIZED = -1,
}

export function streamingRecognizeResponse_SpeechEventTypeFromJSON(
  object: any,
): StreamingRecognizeResponse_SpeechEventType {
  switch (object) {
    case 0:
    case "SPEECH_EVENT_UNSPECIFIED":
      return StreamingRecognizeResponse_SpeechEventType.SPEECH_EVENT_UNSPECIFIED;
    case 1:
    case "END_OF_SINGLE_UTTERANCE":
      return StreamingRecognizeResponse_SpeechEventType.END_OF_SINGLE_UTTERANCE;
    case 2:
    case "SPEECH_ACTIVITY_BEGIN":
      return StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_BEGIN;
    case 3:
    case "SPEECH_ACTIVITY_END":
      return StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_END;
    case 4:
    case "SPEECH_ACTIVITY_TIMEOUT":
      return StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamingRecognizeResponse_SpeechEventType.UNRECOGNIZED;
  }
}

export function streamingRecognizeResponse_SpeechEventTypeToJSON(
  object: StreamingRecognizeResponse_SpeechEventType,
): string {
  switch (object) {
    case StreamingRecognizeResponse_SpeechEventType.SPEECH_EVENT_UNSPECIFIED:
      return "SPEECH_EVENT_UNSPECIFIED";
    case StreamingRecognizeResponse_SpeechEventType.END_OF_SINGLE_UTTERANCE:
      return "END_OF_SINGLE_UTTERANCE";
    case StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_BEGIN:
      return "SPEECH_ACTIVITY_BEGIN";
    case StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_END:
      return "SPEECH_ACTIVITY_END";
    case StreamingRecognizeResponse_SpeechEventType.SPEECH_ACTIVITY_TIMEOUT:
      return "SPEECH_ACTIVITY_TIMEOUT";
    case StreamingRecognizeResponse_SpeechEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A streaming speech recognition result corresponding to a portion of the audio
 * that is currently being processed.
 */
export interface StreamingRecognitionResult {
  /**
   * May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   * These alternatives are ordered in terms of accuracy, with the top (first)
   * alternative being the most probable, as ranked by the recognizer.
   */
  alternatives: SpeechRecognitionAlternative[];
  /**
   * If `false`, this `StreamingRecognitionResult` represents an
   * interim result that may change. If `true`, this is the final time the
   * speech service will return this particular `StreamingRecognitionResult`,
   * the recognizer will not return any further hypotheses for this portion of
   * the transcript and corresponding audio.
   */
  isFinal: boolean;
  /**
   * An estimate of the likelihood that the recognizer will not
   * change its guess about this interim result. Values range from 0.0
   * (completely unstable) to 1.0 (completely stable).
   * This field is only provided for interim results (`is_final=false`).
   * The default of 0.0 is a sentinel value indicating `stability` was not set.
   */
  stability: number;
  /**
   * Time offset of the end of this result relative to the
   * beginning of the audio.
   */
  resultEndTime:
    | Duration
    | undefined;
  /**
   * For multi-channel audio, this is the channel number corresponding to the
   * recognized result for the audio from that channel.
   * For audio_channel_count = N, its output values can range from '1' to 'N'.
   */
  channelTag: number;
  /**
   * Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag of the language in this result. This language code was
   * detected to have the most likelihood of being spoken in the audio.
   */
  languageCode: string;
}

/** A speech recognition result corresponding to a portion of the audio. */
export interface SpeechRecognitionResult {
  /**
   * May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   * These alternatives are ordered in terms of accuracy, with the top (first)
   * alternative being the most probable, as ranked by the recognizer.
   */
  alternatives: SpeechRecognitionAlternative[];
  /**
   * For multi-channel audio, this is the channel number corresponding to the
   * recognized result for the audio from that channel.
   * For audio_channel_count = N, its output values can range from '1' to 'N'.
   */
  channelTag: number;
  /**
   * Time offset of the end of this result relative to the
   * beginning of the audio.
   */
  resultEndTime:
    | Duration
    | undefined;
  /**
   * Output only. The [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
   * language tag of the language in this result. This language code was
   * detected to have the most likelihood of being spoken in the audio.
   */
  languageCode: string;
}

/** Alternative hypotheses (a.k.a. n-best list). */
export interface SpeechRecognitionAlternative {
  /**
   * Transcript text representing the words that the user spoke.
   * In languages that use spaces to separate words, the transcript might have a
   * leading space if it isn't the first result. You can concatenate each result
   * to obtain the full transcript without using a separator.
   */
  transcript: string;
  /**
   * The confidence estimate between 0.0 and 1.0. A higher number
   * indicates an estimated greater likelihood that the recognized words are
   * correct. This field is set only for the top alternative of a non-streaming
   * result or, of a streaming result where `is_final=true`.
   * This field is not guaranteed to be accurate and users should not rely on it
   * to be always provided.
   * The default of 0.0 is a sentinel value indicating `confidence` was not set.
   */
  confidence: number;
  /**
   * A list of word-specific information for each recognized word.
   * Note: When `enable_speaker_diarization` is true, you will see all the words
   * from the beginning of the audio.
   */
  words: WordInfo[];
}

/** Word-specific information for recognized words. */
export interface WordInfo {
  /**
   * Time offset relative to the beginning of the audio,
   * and corresponding to the start of the spoken word.
   * This field is only set if `enable_word_time_offsets=true` and only
   * in the top hypothesis.
   * This is an experimental feature and the accuracy of the time offset can
   * vary.
   */
  startTime:
    | Duration
    | undefined;
  /**
   * Time offset relative to the beginning of the audio,
   * and corresponding to the end of the spoken word.
   * This field is only set if `enable_word_time_offsets=true` and only
   * in the top hypothesis.
   * This is an experimental feature and the accuracy of the time offset can
   * vary.
   */
  endTime:
    | Duration
    | undefined;
  /** The word corresponding to this set of information. */
  word: string;
  /**
   * The confidence estimate between 0.0 and 1.0. A higher number
   * indicates an estimated greater likelihood that the recognized words are
   * correct. This field is set only for the top alternative of a non-streaming
   * result or, of a streaming result where `is_final=true`.
   * This field is not guaranteed to be accurate and users should not rely on it
   * to be always provided.
   * The default of 0.0 is a sentinel value indicating `confidence` was not set.
   */
  confidence: number;
  /**
   * Output only. A distinct integer value is assigned for every speaker within
   * the audio. This field specifies which one of those speakers was detected to
   * have spoken this word. Value ranges from '1' to diarization_speaker_count.
   * speaker_tag is set if enable_speaker_diarization = 'true' and only for the
   * top alternative.
   * Note: Use speaker_label instead.
   *
   * @deprecated
   */
  speakerTag: number;
  /**
   * Output only. A label value assigned for every unique speaker within the
   * audio. This field specifies which speaker was detected to have spoken this
   * word. For some models, like medical_conversation this can be actual speaker
   * role, for example "patient" or "provider", but generally this would be a
   * number identifying a speaker. This field is only set if
   * enable_speaker_diarization = 'true' and only for the top alternative.
   */
  speakerLabel: string;
}

/** Information on speech adaptation use in results */
export interface SpeechAdaptationInfo {
  /**
   * Whether there was a timeout when applying speech adaptation. If true,
   * adaptation had no effect in the response transcript.
   */
  adaptationTimeout: boolean;
  /**
   * If set, returns a message specifying which part of the speech adaptation
   * request timed out.
   */
  timeoutMessage: string;
}

function createBaseRecognizeRequest(): RecognizeRequest {
  return { config: undefined, audio: undefined };
}

export const RecognizeRequest: MessageFns<RecognizeRequest> = {
  encode(message: RecognizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      RecognitionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audio !== undefined) {
      RecognitionAudio.encode(message.audio, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = RecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = RecognitionAudio.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecognizeRequest {
    return {
      config: isSet(object.config) ? RecognitionConfig.fromJSON(object.config) : undefined,
      audio: isSet(object.audio) ? RecognitionAudio.fromJSON(object.audio) : undefined,
    };
  },

  toJSON(message: RecognizeRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = RecognitionConfig.toJSON(message.config);
    }
    if (message.audio !== undefined) {
      obj.audio = RecognitionAudio.toJSON(message.audio);
    }
    return obj;
  },

  create(base?: DeepPartial<RecognizeRequest>): RecognizeRequest {
    return RecognizeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecognizeRequest>): RecognizeRequest {
    const message = createBaseRecognizeRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? RecognitionConfig.fromPartial(object.config)
      : undefined;
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? RecognitionAudio.fromPartial(object.audio)
      : undefined;
    return message;
  },
};

function createBaseLongRunningRecognizeRequest(): LongRunningRecognizeRequest {
  return { config: undefined, audio: undefined, outputConfig: undefined };
}

export const LongRunningRecognizeRequest: MessageFns<LongRunningRecognizeRequest> = {
  encode(message: LongRunningRecognizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      RecognitionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.audio !== undefined) {
      RecognitionAudio.encode(message.audio, writer.uint32(18).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      TranscriptOutputConfig.encode(message.outputConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongRunningRecognizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongRunningRecognizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = RecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audio = RecognitionAudio.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.outputConfig = TranscriptOutputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongRunningRecognizeRequest {
    return {
      config: isSet(object.config) ? RecognitionConfig.fromJSON(object.config) : undefined,
      audio: isSet(object.audio) ? RecognitionAudio.fromJSON(object.audio) : undefined,
      outputConfig: isSet(object.outputConfig) ? TranscriptOutputConfig.fromJSON(object.outputConfig) : undefined,
    };
  },

  toJSON(message: LongRunningRecognizeRequest): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = RecognitionConfig.toJSON(message.config);
    }
    if (message.audio !== undefined) {
      obj.audio = RecognitionAudio.toJSON(message.audio);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = TranscriptOutputConfig.toJSON(message.outputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LongRunningRecognizeRequest>): LongRunningRecognizeRequest {
    return LongRunningRecognizeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LongRunningRecognizeRequest>): LongRunningRecognizeRequest {
    const message = createBaseLongRunningRecognizeRequest();
    message.config = (object.config !== undefined && object.config !== null)
      ? RecognitionConfig.fromPartial(object.config)
      : undefined;
    message.audio = (object.audio !== undefined && object.audio !== null)
      ? RecognitionAudio.fromPartial(object.audio)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? TranscriptOutputConfig.fromPartial(object.outputConfig)
      : undefined;
    return message;
  },
};

function createBaseTranscriptOutputConfig(): TranscriptOutputConfig {
  return { gcsUri: undefined };
}

export const TranscriptOutputConfig: MessageFns<TranscriptOutputConfig> = {
  encode(message: TranscriptOutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsUri !== undefined) {
      writer.uint32(10).string(message.gcsUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptOutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptOutputConfig {
    return { gcsUri: isSet(object.gcsUri) ? globalThis.String(object.gcsUri) : undefined };
  },

  toJSON(message: TranscriptOutputConfig): unknown {
    const obj: any = {};
    if (message.gcsUri !== undefined) {
      obj.gcsUri = message.gcsUri;
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptOutputConfig>): TranscriptOutputConfig {
    return TranscriptOutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptOutputConfig>): TranscriptOutputConfig {
    const message = createBaseTranscriptOutputConfig();
    message.gcsUri = object.gcsUri ?? undefined;
    return message;
  },
};

function createBaseStreamingRecognizeRequest(): StreamingRecognizeRequest {
  return { streamingConfig: undefined, audioContent: undefined };
}

export const StreamingRecognizeRequest: MessageFns<StreamingRecognizeRequest> = {
  encode(message: StreamingRecognizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.streamingConfig !== undefined) {
      StreamingRecognitionConfig.encode(message.streamingConfig, writer.uint32(10).fork()).join();
    }
    if (message.audioContent !== undefined) {
      writer.uint32(18).bytes(message.audioContent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRecognizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRecognizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.streamingConfig = StreamingRecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audioContent = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRecognizeRequest {
    return {
      streamingConfig: isSet(object.streamingConfig)
        ? StreamingRecognitionConfig.fromJSON(object.streamingConfig)
        : undefined,
      audioContent: isSet(object.audioContent) ? Buffer.from(bytesFromBase64(object.audioContent)) : undefined,
    };
  },

  toJSON(message: StreamingRecognizeRequest): unknown {
    const obj: any = {};
    if (message.streamingConfig !== undefined) {
      obj.streamingConfig = StreamingRecognitionConfig.toJSON(message.streamingConfig);
    }
    if (message.audioContent !== undefined) {
      obj.audioContent = base64FromBytes(message.audioContent);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRecognizeRequest>): StreamingRecognizeRequest {
    return StreamingRecognizeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRecognizeRequest>): StreamingRecognizeRequest {
    const message = createBaseStreamingRecognizeRequest();
    message.streamingConfig = (object.streamingConfig !== undefined && object.streamingConfig !== null)
      ? StreamingRecognitionConfig.fromPartial(object.streamingConfig)
      : undefined;
    message.audioContent = object.audioContent ?? undefined;
    return message;
  },
};

function createBaseStreamingRecognitionConfig(): StreamingRecognitionConfig {
  return {
    config: undefined,
    singleUtterance: false,
    interimResults: false,
    enableVoiceActivityEvents: false,
    voiceActivityTimeout: undefined,
  };
}

export const StreamingRecognitionConfig: MessageFns<StreamingRecognitionConfig> = {
  encode(message: StreamingRecognitionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.config !== undefined) {
      RecognitionConfig.encode(message.config, writer.uint32(10).fork()).join();
    }
    if (message.singleUtterance !== false) {
      writer.uint32(16).bool(message.singleUtterance);
    }
    if (message.interimResults !== false) {
      writer.uint32(24).bool(message.interimResults);
    }
    if (message.enableVoiceActivityEvents !== false) {
      writer.uint32(40).bool(message.enableVoiceActivityEvents);
    }
    if (message.voiceActivityTimeout !== undefined) {
      StreamingRecognitionConfig_VoiceActivityTimeout.encode(message.voiceActivityTimeout, writer.uint32(50).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRecognitionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRecognitionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.config = RecognitionConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.singleUtterance = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interimResults = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableVoiceActivityEvents = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.voiceActivityTimeout = StreamingRecognitionConfig_VoiceActivityTimeout.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRecognitionConfig {
    return {
      config: isSet(object.config) ? RecognitionConfig.fromJSON(object.config) : undefined,
      singleUtterance: isSet(object.singleUtterance) ? globalThis.Boolean(object.singleUtterance) : false,
      interimResults: isSet(object.interimResults) ? globalThis.Boolean(object.interimResults) : false,
      enableVoiceActivityEvents: isSet(object.enableVoiceActivityEvents)
        ? globalThis.Boolean(object.enableVoiceActivityEvents)
        : false,
      voiceActivityTimeout: isSet(object.voiceActivityTimeout)
        ? StreamingRecognitionConfig_VoiceActivityTimeout.fromJSON(object.voiceActivityTimeout)
        : undefined,
    };
  },

  toJSON(message: StreamingRecognitionConfig): unknown {
    const obj: any = {};
    if (message.config !== undefined) {
      obj.config = RecognitionConfig.toJSON(message.config);
    }
    if (message.singleUtterance !== false) {
      obj.singleUtterance = message.singleUtterance;
    }
    if (message.interimResults !== false) {
      obj.interimResults = message.interimResults;
    }
    if (message.enableVoiceActivityEvents !== false) {
      obj.enableVoiceActivityEvents = message.enableVoiceActivityEvents;
    }
    if (message.voiceActivityTimeout !== undefined) {
      obj.voiceActivityTimeout = StreamingRecognitionConfig_VoiceActivityTimeout.toJSON(message.voiceActivityTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRecognitionConfig>): StreamingRecognitionConfig {
    return StreamingRecognitionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRecognitionConfig>): StreamingRecognitionConfig {
    const message = createBaseStreamingRecognitionConfig();
    message.config = (object.config !== undefined && object.config !== null)
      ? RecognitionConfig.fromPartial(object.config)
      : undefined;
    message.singleUtterance = object.singleUtterance ?? false;
    message.interimResults = object.interimResults ?? false;
    message.enableVoiceActivityEvents = object.enableVoiceActivityEvents ?? false;
    message.voiceActivityTimeout = (object.voiceActivityTimeout !== undefined && object.voiceActivityTimeout !== null)
      ? StreamingRecognitionConfig_VoiceActivityTimeout.fromPartial(object.voiceActivityTimeout)
      : undefined;
    return message;
  },
};

function createBaseStreamingRecognitionConfig_VoiceActivityTimeout(): StreamingRecognitionConfig_VoiceActivityTimeout {
  return { speechStartTimeout: undefined, speechEndTimeout: undefined };
}

export const StreamingRecognitionConfig_VoiceActivityTimeout: MessageFns<
  StreamingRecognitionConfig_VoiceActivityTimeout
> = {
  encode(
    message: StreamingRecognitionConfig_VoiceActivityTimeout,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.speechStartTimeout !== undefined) {
      Duration.encode(message.speechStartTimeout, writer.uint32(10).fork()).join();
    }
    if (message.speechEndTimeout !== undefined) {
      Duration.encode(message.speechEndTimeout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRecognitionConfig_VoiceActivityTimeout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRecognitionConfig_VoiceActivityTimeout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.speechStartTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.speechEndTimeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRecognitionConfig_VoiceActivityTimeout {
    return {
      speechStartTimeout: isSet(object.speechStartTimeout) ? Duration.fromJSON(object.speechStartTimeout) : undefined,
      speechEndTimeout: isSet(object.speechEndTimeout) ? Duration.fromJSON(object.speechEndTimeout) : undefined,
    };
  },

  toJSON(message: StreamingRecognitionConfig_VoiceActivityTimeout): unknown {
    const obj: any = {};
    if (message.speechStartTimeout !== undefined) {
      obj.speechStartTimeout = Duration.toJSON(message.speechStartTimeout);
    }
    if (message.speechEndTimeout !== undefined) {
      obj.speechEndTimeout = Duration.toJSON(message.speechEndTimeout);
    }
    return obj;
  },

  create(
    base?: DeepPartial<StreamingRecognitionConfig_VoiceActivityTimeout>,
  ): StreamingRecognitionConfig_VoiceActivityTimeout {
    return StreamingRecognitionConfig_VoiceActivityTimeout.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StreamingRecognitionConfig_VoiceActivityTimeout>,
  ): StreamingRecognitionConfig_VoiceActivityTimeout {
    const message = createBaseStreamingRecognitionConfig_VoiceActivityTimeout();
    message.speechStartTimeout = (object.speechStartTimeout !== undefined && object.speechStartTimeout !== null)
      ? Duration.fromPartial(object.speechStartTimeout)
      : undefined;
    message.speechEndTimeout = (object.speechEndTimeout !== undefined && object.speechEndTimeout !== null)
      ? Duration.fromPartial(object.speechEndTimeout)
      : undefined;
    return message;
  },
};

function createBaseRecognitionConfig(): RecognitionConfig {
  return {
    encoding: 0,
    sampleRateHertz: 0,
    audioChannelCount: 0,
    enableSeparateRecognitionPerChannel: false,
    languageCode: "",
    alternativeLanguageCodes: [],
    maxAlternatives: 0,
    profanityFilter: false,
    adaptation: undefined,
    transcriptNormalization: undefined,
    speechContexts: [],
    enableWordTimeOffsets: false,
    enableWordConfidence: false,
    enableAutomaticPunctuation: false,
    enableSpokenPunctuation: undefined,
    enableSpokenEmojis: undefined,
    diarizationConfig: undefined,
    metadata: undefined,
    model: "",
    useEnhanced: false,
  };
}

export const RecognitionConfig: MessageFns<RecognitionConfig> = {
  encode(message: RecognitionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encoding !== 0) {
      writer.uint32(8).int32(message.encoding);
    }
    if (message.sampleRateHertz !== 0) {
      writer.uint32(16).int32(message.sampleRateHertz);
    }
    if (message.audioChannelCount !== 0) {
      writer.uint32(56).int32(message.audioChannelCount);
    }
    if (message.enableSeparateRecognitionPerChannel !== false) {
      writer.uint32(96).bool(message.enableSeparateRecognitionPerChannel);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    for (const v of message.alternativeLanguageCodes) {
      writer.uint32(146).string(v!);
    }
    if (message.maxAlternatives !== 0) {
      writer.uint32(32).int32(message.maxAlternatives);
    }
    if (message.profanityFilter !== false) {
      writer.uint32(40).bool(message.profanityFilter);
    }
    if (message.adaptation !== undefined) {
      SpeechAdaptation.encode(message.adaptation, writer.uint32(162).fork()).join();
    }
    if (message.transcriptNormalization !== undefined) {
      TranscriptNormalization.encode(message.transcriptNormalization, writer.uint32(194).fork()).join();
    }
    for (const v of message.speechContexts) {
      SpeechContext.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.enableWordTimeOffsets !== false) {
      writer.uint32(64).bool(message.enableWordTimeOffsets);
    }
    if (message.enableWordConfidence !== false) {
      writer.uint32(120).bool(message.enableWordConfidence);
    }
    if (message.enableAutomaticPunctuation !== false) {
      writer.uint32(88).bool(message.enableAutomaticPunctuation);
    }
    if (message.enableSpokenPunctuation !== undefined) {
      BoolValue.encode({ value: message.enableSpokenPunctuation! }, writer.uint32(178).fork()).join();
    }
    if (message.enableSpokenEmojis !== undefined) {
      BoolValue.encode({ value: message.enableSpokenEmojis! }, writer.uint32(186).fork()).join();
    }
    if (message.diarizationConfig !== undefined) {
      SpeakerDiarizationConfig.encode(message.diarizationConfig, writer.uint32(154).fork()).join();
    }
    if (message.metadata !== undefined) {
      RecognitionMetadata.encode(message.metadata, writer.uint32(74).fork()).join();
    }
    if (message.model !== "") {
      writer.uint32(106).string(message.model);
    }
    if (message.useEnhanced !== false) {
      writer.uint32(112).bool(message.useEnhanced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognitionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognitionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.encoding = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sampleRateHertz = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.audioChannelCount = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.enableSeparateRecognitionPerChannel = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.alternativeLanguageCodes.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxAlternatives = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.profanityFilter = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.adaptation = SpeechAdaptation.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.transcriptNormalization = TranscriptNormalization.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.speechContexts.push(SpeechContext.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.enableWordTimeOffsets = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.enableWordConfidence = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableAutomaticPunctuation = reader.bool();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.enableSpokenPunctuation = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.enableSpokenEmojis = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.diarizationConfig = SpeakerDiarizationConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.metadata = RecognitionMetadata.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.model = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.useEnhanced = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecognitionConfig {
    return {
      encoding: isSet(object.encoding) ? recognitionConfig_AudioEncodingFromJSON(object.encoding) : 0,
      sampleRateHertz: isSet(object.sampleRateHertz) ? globalThis.Number(object.sampleRateHertz) : 0,
      audioChannelCount: isSet(object.audioChannelCount) ? globalThis.Number(object.audioChannelCount) : 0,
      enableSeparateRecognitionPerChannel: isSet(object.enableSeparateRecognitionPerChannel)
        ? globalThis.Boolean(object.enableSeparateRecognitionPerChannel)
        : false,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      alternativeLanguageCodes: globalThis.Array.isArray(object?.alternativeLanguageCodes)
        ? object.alternativeLanguageCodes.map((e: any) => globalThis.String(e))
        : [],
      maxAlternatives: isSet(object.maxAlternatives) ? globalThis.Number(object.maxAlternatives) : 0,
      profanityFilter: isSet(object.profanityFilter) ? globalThis.Boolean(object.profanityFilter) : false,
      adaptation: isSet(object.adaptation) ? SpeechAdaptation.fromJSON(object.adaptation) : undefined,
      transcriptNormalization: isSet(object.transcriptNormalization)
        ? TranscriptNormalization.fromJSON(object.transcriptNormalization)
        : undefined,
      speechContexts: globalThis.Array.isArray(object?.speechContexts)
        ? object.speechContexts.map((e: any) => SpeechContext.fromJSON(e))
        : [],
      enableWordTimeOffsets: isSet(object.enableWordTimeOffsets)
        ? globalThis.Boolean(object.enableWordTimeOffsets)
        : false,
      enableWordConfidence: isSet(object.enableWordConfidence)
        ? globalThis.Boolean(object.enableWordConfidence)
        : false,
      enableAutomaticPunctuation: isSet(object.enableAutomaticPunctuation)
        ? globalThis.Boolean(object.enableAutomaticPunctuation)
        : false,
      enableSpokenPunctuation: isSet(object.enableSpokenPunctuation)
        ? Boolean(object.enableSpokenPunctuation)
        : undefined,
      enableSpokenEmojis: isSet(object.enableSpokenEmojis) ? Boolean(object.enableSpokenEmojis) : undefined,
      diarizationConfig: isSet(object.diarizationConfig)
        ? SpeakerDiarizationConfig.fromJSON(object.diarizationConfig)
        : undefined,
      metadata: isSet(object.metadata) ? RecognitionMetadata.fromJSON(object.metadata) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      useEnhanced: isSet(object.useEnhanced) ? globalThis.Boolean(object.useEnhanced) : false,
    };
  },

  toJSON(message: RecognitionConfig): unknown {
    const obj: any = {};
    if (message.encoding !== 0) {
      obj.encoding = recognitionConfig_AudioEncodingToJSON(message.encoding);
    }
    if (message.sampleRateHertz !== 0) {
      obj.sampleRateHertz = Math.round(message.sampleRateHertz);
    }
    if (message.audioChannelCount !== 0) {
      obj.audioChannelCount = Math.round(message.audioChannelCount);
    }
    if (message.enableSeparateRecognitionPerChannel !== false) {
      obj.enableSeparateRecognitionPerChannel = message.enableSeparateRecognitionPerChannel;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.alternativeLanguageCodes?.length) {
      obj.alternativeLanguageCodes = message.alternativeLanguageCodes;
    }
    if (message.maxAlternatives !== 0) {
      obj.maxAlternatives = Math.round(message.maxAlternatives);
    }
    if (message.profanityFilter !== false) {
      obj.profanityFilter = message.profanityFilter;
    }
    if (message.adaptation !== undefined) {
      obj.adaptation = SpeechAdaptation.toJSON(message.adaptation);
    }
    if (message.transcriptNormalization !== undefined) {
      obj.transcriptNormalization = TranscriptNormalization.toJSON(message.transcriptNormalization);
    }
    if (message.speechContexts?.length) {
      obj.speechContexts = message.speechContexts.map((e) => SpeechContext.toJSON(e));
    }
    if (message.enableWordTimeOffsets !== false) {
      obj.enableWordTimeOffsets = message.enableWordTimeOffsets;
    }
    if (message.enableWordConfidence !== false) {
      obj.enableWordConfidence = message.enableWordConfidence;
    }
    if (message.enableAutomaticPunctuation !== false) {
      obj.enableAutomaticPunctuation = message.enableAutomaticPunctuation;
    }
    if (message.enableSpokenPunctuation !== undefined) {
      obj.enableSpokenPunctuation = message.enableSpokenPunctuation;
    }
    if (message.enableSpokenEmojis !== undefined) {
      obj.enableSpokenEmojis = message.enableSpokenEmojis;
    }
    if (message.diarizationConfig !== undefined) {
      obj.diarizationConfig = SpeakerDiarizationConfig.toJSON(message.diarizationConfig);
    }
    if (message.metadata !== undefined) {
      obj.metadata = RecognitionMetadata.toJSON(message.metadata);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.useEnhanced !== false) {
      obj.useEnhanced = message.useEnhanced;
    }
    return obj;
  },

  create(base?: DeepPartial<RecognitionConfig>): RecognitionConfig {
    return RecognitionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecognitionConfig>): RecognitionConfig {
    const message = createBaseRecognitionConfig();
    message.encoding = object.encoding ?? 0;
    message.sampleRateHertz = object.sampleRateHertz ?? 0;
    message.audioChannelCount = object.audioChannelCount ?? 0;
    message.enableSeparateRecognitionPerChannel = object.enableSeparateRecognitionPerChannel ?? false;
    message.languageCode = object.languageCode ?? "";
    message.alternativeLanguageCodes = object.alternativeLanguageCodes?.map((e) => e) || [];
    message.maxAlternatives = object.maxAlternatives ?? 0;
    message.profanityFilter = object.profanityFilter ?? false;
    message.adaptation = (object.adaptation !== undefined && object.adaptation !== null)
      ? SpeechAdaptation.fromPartial(object.adaptation)
      : undefined;
    message.transcriptNormalization =
      (object.transcriptNormalization !== undefined && object.transcriptNormalization !== null)
        ? TranscriptNormalization.fromPartial(object.transcriptNormalization)
        : undefined;
    message.speechContexts = object.speechContexts?.map((e) => SpeechContext.fromPartial(e)) || [];
    message.enableWordTimeOffsets = object.enableWordTimeOffsets ?? false;
    message.enableWordConfidence = object.enableWordConfidence ?? false;
    message.enableAutomaticPunctuation = object.enableAutomaticPunctuation ?? false;
    message.enableSpokenPunctuation = object.enableSpokenPunctuation ?? undefined;
    message.enableSpokenEmojis = object.enableSpokenEmojis ?? undefined;
    message.diarizationConfig = (object.diarizationConfig !== undefined && object.diarizationConfig !== null)
      ? SpeakerDiarizationConfig.fromPartial(object.diarizationConfig)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? RecognitionMetadata.fromPartial(object.metadata)
      : undefined;
    message.model = object.model ?? "";
    message.useEnhanced = object.useEnhanced ?? false;
    return message;
  },
};

function createBaseSpeakerDiarizationConfig(): SpeakerDiarizationConfig {
  return { enableSpeakerDiarization: false, minSpeakerCount: 0, maxSpeakerCount: 0, speakerTag: 0 };
}

export const SpeakerDiarizationConfig: MessageFns<SpeakerDiarizationConfig> = {
  encode(message: SpeakerDiarizationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSpeakerDiarization !== false) {
      writer.uint32(8).bool(message.enableSpeakerDiarization);
    }
    if (message.minSpeakerCount !== 0) {
      writer.uint32(16).int32(message.minSpeakerCount);
    }
    if (message.maxSpeakerCount !== 0) {
      writer.uint32(24).int32(message.maxSpeakerCount);
    }
    if (message.speakerTag !== 0) {
      writer.uint32(40).int32(message.speakerTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeakerDiarizationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeakerDiarizationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSpeakerDiarization = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minSpeakerCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxSpeakerCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.speakerTag = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeakerDiarizationConfig {
    return {
      enableSpeakerDiarization: isSet(object.enableSpeakerDiarization)
        ? globalThis.Boolean(object.enableSpeakerDiarization)
        : false,
      minSpeakerCount: isSet(object.minSpeakerCount) ? globalThis.Number(object.minSpeakerCount) : 0,
      maxSpeakerCount: isSet(object.maxSpeakerCount) ? globalThis.Number(object.maxSpeakerCount) : 0,
      speakerTag: isSet(object.speakerTag) ? globalThis.Number(object.speakerTag) : 0,
    };
  },

  toJSON(message: SpeakerDiarizationConfig): unknown {
    const obj: any = {};
    if (message.enableSpeakerDiarization !== false) {
      obj.enableSpeakerDiarization = message.enableSpeakerDiarization;
    }
    if (message.minSpeakerCount !== 0) {
      obj.minSpeakerCount = Math.round(message.minSpeakerCount);
    }
    if (message.maxSpeakerCount !== 0) {
      obj.maxSpeakerCount = Math.round(message.maxSpeakerCount);
    }
    if (message.speakerTag !== 0) {
      obj.speakerTag = Math.round(message.speakerTag);
    }
    return obj;
  },

  create(base?: DeepPartial<SpeakerDiarizationConfig>): SpeakerDiarizationConfig {
    return SpeakerDiarizationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeakerDiarizationConfig>): SpeakerDiarizationConfig {
    const message = createBaseSpeakerDiarizationConfig();
    message.enableSpeakerDiarization = object.enableSpeakerDiarization ?? false;
    message.minSpeakerCount = object.minSpeakerCount ?? 0;
    message.maxSpeakerCount = object.maxSpeakerCount ?? 0;
    message.speakerTag = object.speakerTag ?? 0;
    return message;
  },
};

function createBaseRecognitionMetadata(): RecognitionMetadata {
  return {
    interactionType: 0,
    industryNaicsCodeOfAudio: 0,
    microphoneDistance: 0,
    originalMediaType: 0,
    recordingDeviceType: 0,
    recordingDeviceName: "",
    originalMimeType: "",
    audioTopic: "",
  };
}

export const RecognitionMetadata: MessageFns<RecognitionMetadata> = {
  encode(message: RecognitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactionType !== 0) {
      writer.uint32(8).int32(message.interactionType);
    }
    if (message.industryNaicsCodeOfAudio !== 0) {
      writer.uint32(24).uint32(message.industryNaicsCodeOfAudio);
    }
    if (message.microphoneDistance !== 0) {
      writer.uint32(32).int32(message.microphoneDistance);
    }
    if (message.originalMediaType !== 0) {
      writer.uint32(40).int32(message.originalMediaType);
    }
    if (message.recordingDeviceType !== 0) {
      writer.uint32(48).int32(message.recordingDeviceType);
    }
    if (message.recordingDeviceName !== "") {
      writer.uint32(58).string(message.recordingDeviceName);
    }
    if (message.originalMimeType !== "") {
      writer.uint32(66).string(message.originalMimeType);
    }
    if (message.audioTopic !== "") {
      writer.uint32(82).string(message.audioTopic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognitionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.interactionType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.industryNaicsCodeOfAudio = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.microphoneDistance = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.originalMediaType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.recordingDeviceType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recordingDeviceName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.originalMimeType = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.audioTopic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecognitionMetadata {
    return {
      interactionType: isSet(object.interactionType)
        ? recognitionMetadata_InteractionTypeFromJSON(object.interactionType)
        : 0,
      industryNaicsCodeOfAudio: isSet(object.industryNaicsCodeOfAudio)
        ? globalThis.Number(object.industryNaicsCodeOfAudio)
        : 0,
      microphoneDistance: isSet(object.microphoneDistance)
        ? recognitionMetadata_MicrophoneDistanceFromJSON(object.microphoneDistance)
        : 0,
      originalMediaType: isSet(object.originalMediaType)
        ? recognitionMetadata_OriginalMediaTypeFromJSON(object.originalMediaType)
        : 0,
      recordingDeviceType: isSet(object.recordingDeviceType)
        ? recognitionMetadata_RecordingDeviceTypeFromJSON(object.recordingDeviceType)
        : 0,
      recordingDeviceName: isSet(object.recordingDeviceName) ? globalThis.String(object.recordingDeviceName) : "",
      originalMimeType: isSet(object.originalMimeType) ? globalThis.String(object.originalMimeType) : "",
      audioTopic: isSet(object.audioTopic) ? globalThis.String(object.audioTopic) : "",
    };
  },

  toJSON(message: RecognitionMetadata): unknown {
    const obj: any = {};
    if (message.interactionType !== 0) {
      obj.interactionType = recognitionMetadata_InteractionTypeToJSON(message.interactionType);
    }
    if (message.industryNaicsCodeOfAudio !== 0) {
      obj.industryNaicsCodeOfAudio = Math.round(message.industryNaicsCodeOfAudio);
    }
    if (message.microphoneDistance !== 0) {
      obj.microphoneDistance = recognitionMetadata_MicrophoneDistanceToJSON(message.microphoneDistance);
    }
    if (message.originalMediaType !== 0) {
      obj.originalMediaType = recognitionMetadata_OriginalMediaTypeToJSON(message.originalMediaType);
    }
    if (message.recordingDeviceType !== 0) {
      obj.recordingDeviceType = recognitionMetadata_RecordingDeviceTypeToJSON(message.recordingDeviceType);
    }
    if (message.recordingDeviceName !== "") {
      obj.recordingDeviceName = message.recordingDeviceName;
    }
    if (message.originalMimeType !== "") {
      obj.originalMimeType = message.originalMimeType;
    }
    if (message.audioTopic !== "") {
      obj.audioTopic = message.audioTopic;
    }
    return obj;
  },

  create(base?: DeepPartial<RecognitionMetadata>): RecognitionMetadata {
    return RecognitionMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecognitionMetadata>): RecognitionMetadata {
    const message = createBaseRecognitionMetadata();
    message.interactionType = object.interactionType ?? 0;
    message.industryNaicsCodeOfAudio = object.industryNaicsCodeOfAudio ?? 0;
    message.microphoneDistance = object.microphoneDistance ?? 0;
    message.originalMediaType = object.originalMediaType ?? 0;
    message.recordingDeviceType = object.recordingDeviceType ?? 0;
    message.recordingDeviceName = object.recordingDeviceName ?? "";
    message.originalMimeType = object.originalMimeType ?? "";
    message.audioTopic = object.audioTopic ?? "";
    return message;
  },
};

function createBaseSpeechContext(): SpeechContext {
  return { phrases: [], boost: 0 };
}

export const SpeechContext: MessageFns<SpeechContext> = {
  encode(message: SpeechContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.phrases) {
      writer.uint32(10).string(v!);
    }
    if (message.boost !== 0) {
      writer.uint32(37).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phrases.push(reader.string());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.boost = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechContext {
    return {
      phrases: globalThis.Array.isArray(object?.phrases) ? object.phrases.map((e: any) => globalThis.String(e)) : [],
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: SpeechContext): unknown {
    const obj: any = {};
    if (message.phrases?.length) {
      obj.phrases = message.phrases;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechContext>): SpeechContext {
    return SpeechContext.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechContext>): SpeechContext {
    const message = createBaseSpeechContext();
    message.phrases = object.phrases?.map((e) => e) || [];
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBaseRecognitionAudio(): RecognitionAudio {
  return { content: undefined, uri: undefined };
}

export const RecognitionAudio: MessageFns<RecognitionAudio> = {
  encode(message: RecognitionAudio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.uri !== undefined) {
      writer.uint32(18).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognitionAudio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognitionAudio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecognitionAudio {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
    };
  },

  toJSON(message: RecognitionAudio): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<RecognitionAudio>): RecognitionAudio {
    return RecognitionAudio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecognitionAudio>): RecognitionAudio {
    const message = createBaseRecognitionAudio();
    message.content = object.content ?? undefined;
    message.uri = object.uri ?? undefined;
    return message;
  },
};

function createBaseRecognizeResponse(): RecognizeResponse {
  return { results: [], totalBilledTime: undefined, speechAdaptationInfo: undefined, requestId: Long.ZERO };
}

export const RecognizeResponse: MessageFns<RecognizeResponse> = {
  encode(message: RecognizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SpeechRecognitionResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalBilledTime !== undefined) {
      Duration.encode(message.totalBilledTime, writer.uint32(26).fork()).join();
    }
    if (message.speechAdaptationInfo !== undefined) {
      SpeechAdaptationInfo.encode(message.speechAdaptationInfo, writer.uint32(58).fork()).join();
    }
    if (!message.requestId.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.requestId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecognizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecognizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SpeechRecognitionResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalBilledTime = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.speechAdaptationInfo = SpeechAdaptationInfo.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.requestId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecognizeResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SpeechRecognitionResult.fromJSON(e))
        : [],
      totalBilledTime: isSet(object.totalBilledTime) ? Duration.fromJSON(object.totalBilledTime) : undefined,
      speechAdaptationInfo: isSet(object.speechAdaptationInfo)
        ? SpeechAdaptationInfo.fromJSON(object.speechAdaptationInfo)
        : undefined,
      requestId: isSet(object.requestId) ? Long.fromValue(object.requestId) : Long.ZERO,
    };
  },

  toJSON(message: RecognizeResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SpeechRecognitionResult.toJSON(e));
    }
    if (message.totalBilledTime !== undefined) {
      obj.totalBilledTime = Duration.toJSON(message.totalBilledTime);
    }
    if (message.speechAdaptationInfo !== undefined) {
      obj.speechAdaptationInfo = SpeechAdaptationInfo.toJSON(message.speechAdaptationInfo);
    }
    if (!message.requestId.equals(Long.ZERO)) {
      obj.requestId = (message.requestId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<RecognizeResponse>): RecognizeResponse {
    return RecognizeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecognizeResponse>): RecognizeResponse {
    const message = createBaseRecognizeResponse();
    message.results = object.results?.map((e) => SpeechRecognitionResult.fromPartial(e)) || [];
    message.totalBilledTime = (object.totalBilledTime !== undefined && object.totalBilledTime !== null)
      ? Duration.fromPartial(object.totalBilledTime)
      : undefined;
    message.speechAdaptationInfo = (object.speechAdaptationInfo !== undefined && object.speechAdaptationInfo !== null)
      ? SpeechAdaptationInfo.fromPartial(object.speechAdaptationInfo)
      : undefined;
    message.requestId = (object.requestId !== undefined && object.requestId !== null)
      ? Long.fromValue(object.requestId)
      : Long.ZERO;
    return message;
  },
};

function createBaseLongRunningRecognizeResponse(): LongRunningRecognizeResponse {
  return {
    results: [],
    totalBilledTime: undefined,
    outputConfig: undefined,
    outputError: undefined,
    speechAdaptationInfo: undefined,
    requestId: Long.ZERO,
  };
}

export const LongRunningRecognizeResponse: MessageFns<LongRunningRecognizeResponse> = {
  encode(message: LongRunningRecognizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SpeechRecognitionResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalBilledTime !== undefined) {
      Duration.encode(message.totalBilledTime, writer.uint32(26).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      TranscriptOutputConfig.encode(message.outputConfig, writer.uint32(50).fork()).join();
    }
    if (message.outputError !== undefined) {
      Status.encode(message.outputError, writer.uint32(58).fork()).join();
    }
    if (message.speechAdaptationInfo !== undefined) {
      SpeechAdaptationInfo.encode(message.speechAdaptationInfo, writer.uint32(66).fork()).join();
    }
    if (!message.requestId.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.requestId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongRunningRecognizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongRunningRecognizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SpeechRecognitionResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalBilledTime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.outputConfig = TranscriptOutputConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.outputError = Status.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.speechAdaptationInfo = SpeechAdaptationInfo.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.requestId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongRunningRecognizeResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SpeechRecognitionResult.fromJSON(e))
        : [],
      totalBilledTime: isSet(object.totalBilledTime) ? Duration.fromJSON(object.totalBilledTime) : undefined,
      outputConfig: isSet(object.outputConfig) ? TranscriptOutputConfig.fromJSON(object.outputConfig) : undefined,
      outputError: isSet(object.outputError) ? Status.fromJSON(object.outputError) : undefined,
      speechAdaptationInfo: isSet(object.speechAdaptationInfo)
        ? SpeechAdaptationInfo.fromJSON(object.speechAdaptationInfo)
        : undefined,
      requestId: isSet(object.requestId) ? Long.fromValue(object.requestId) : Long.ZERO,
    };
  },

  toJSON(message: LongRunningRecognizeResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SpeechRecognitionResult.toJSON(e));
    }
    if (message.totalBilledTime !== undefined) {
      obj.totalBilledTime = Duration.toJSON(message.totalBilledTime);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = TranscriptOutputConfig.toJSON(message.outputConfig);
    }
    if (message.outputError !== undefined) {
      obj.outputError = Status.toJSON(message.outputError);
    }
    if (message.speechAdaptationInfo !== undefined) {
      obj.speechAdaptationInfo = SpeechAdaptationInfo.toJSON(message.speechAdaptationInfo);
    }
    if (!message.requestId.equals(Long.ZERO)) {
      obj.requestId = (message.requestId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LongRunningRecognizeResponse>): LongRunningRecognizeResponse {
    return LongRunningRecognizeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LongRunningRecognizeResponse>): LongRunningRecognizeResponse {
    const message = createBaseLongRunningRecognizeResponse();
    message.results = object.results?.map((e) => SpeechRecognitionResult.fromPartial(e)) || [];
    message.totalBilledTime = (object.totalBilledTime !== undefined && object.totalBilledTime !== null)
      ? Duration.fromPartial(object.totalBilledTime)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? TranscriptOutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.outputError = (object.outputError !== undefined && object.outputError !== null)
      ? Status.fromPartial(object.outputError)
      : undefined;
    message.speechAdaptationInfo = (object.speechAdaptationInfo !== undefined && object.speechAdaptationInfo !== null)
      ? SpeechAdaptationInfo.fromPartial(object.speechAdaptationInfo)
      : undefined;
    message.requestId = (object.requestId !== undefined && object.requestId !== null)
      ? Long.fromValue(object.requestId)
      : Long.ZERO;
    return message;
  },
};

function createBaseLongRunningRecognizeMetadata(): LongRunningRecognizeMetadata {
  return { progressPercent: 0, startTime: undefined, lastUpdateTime: undefined, uri: "" };
}

export const LongRunningRecognizeMetadata: MessageFns<LongRunningRecognizeMetadata> = {
  encode(message: LongRunningRecognizeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.progressPercent !== 0) {
      writer.uint32(8).int32(message.progressPercent);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(26).fork()).join();
    }
    if (message.uri !== "") {
      writer.uint32(34).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LongRunningRecognizeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLongRunningRecognizeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.progressPercent = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LongRunningRecognizeMetadata {
    return {
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: LongRunningRecognizeMetadata): unknown {
    const obj: any = {};
    if (message.progressPercent !== 0) {
      obj.progressPercent = Math.round(message.progressPercent);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<LongRunningRecognizeMetadata>): LongRunningRecognizeMetadata {
    return LongRunningRecognizeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LongRunningRecognizeMetadata>): LongRunningRecognizeMetadata {
    const message = createBaseLongRunningRecognizeMetadata();
    message.progressPercent = object.progressPercent ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseStreamingRecognizeResponse(): StreamingRecognizeResponse {
  return {
    error: undefined,
    results: [],
    speechEventType: 0,
    speechEventTime: undefined,
    totalBilledTime: undefined,
    speechAdaptationInfo: undefined,
    requestId: Long.ZERO,
  };
}

export const StreamingRecognizeResponse: MessageFns<StreamingRecognizeResponse> = {
  encode(message: StreamingRecognizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(10).fork()).join();
    }
    for (const v of message.results) {
      StreamingRecognitionResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.speechEventType !== 0) {
      writer.uint32(32).int32(message.speechEventType);
    }
    if (message.speechEventTime !== undefined) {
      Duration.encode(message.speechEventTime, writer.uint32(66).fork()).join();
    }
    if (message.totalBilledTime !== undefined) {
      Duration.encode(message.totalBilledTime, writer.uint32(42).fork()).join();
    }
    if (message.speechAdaptationInfo !== undefined) {
      SpeechAdaptationInfo.encode(message.speechAdaptationInfo, writer.uint32(74).fork()).join();
    }
    if (!message.requestId.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.requestId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRecognizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRecognizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(StreamingRecognitionResult.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.speechEventType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.speechEventTime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.totalBilledTime = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.speechAdaptationInfo = SpeechAdaptationInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.requestId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRecognizeResponse {
    return {
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => StreamingRecognitionResult.fromJSON(e))
        : [],
      speechEventType: isSet(object.speechEventType)
        ? streamingRecognizeResponse_SpeechEventTypeFromJSON(object.speechEventType)
        : 0,
      speechEventTime: isSet(object.speechEventTime) ? Duration.fromJSON(object.speechEventTime) : undefined,
      totalBilledTime: isSet(object.totalBilledTime) ? Duration.fromJSON(object.totalBilledTime) : undefined,
      speechAdaptationInfo: isSet(object.speechAdaptationInfo)
        ? SpeechAdaptationInfo.fromJSON(object.speechAdaptationInfo)
        : undefined,
      requestId: isSet(object.requestId) ? Long.fromValue(object.requestId) : Long.ZERO,
    };
  },

  toJSON(message: StreamingRecognizeResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => StreamingRecognitionResult.toJSON(e));
    }
    if (message.speechEventType !== 0) {
      obj.speechEventType = streamingRecognizeResponse_SpeechEventTypeToJSON(message.speechEventType);
    }
    if (message.speechEventTime !== undefined) {
      obj.speechEventTime = Duration.toJSON(message.speechEventTime);
    }
    if (message.totalBilledTime !== undefined) {
      obj.totalBilledTime = Duration.toJSON(message.totalBilledTime);
    }
    if (message.speechAdaptationInfo !== undefined) {
      obj.speechAdaptationInfo = SpeechAdaptationInfo.toJSON(message.speechAdaptationInfo);
    }
    if (!message.requestId.equals(Long.ZERO)) {
      obj.requestId = (message.requestId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRecognizeResponse>): StreamingRecognizeResponse {
    return StreamingRecognizeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRecognizeResponse>): StreamingRecognizeResponse {
    const message = createBaseStreamingRecognizeResponse();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.results = object.results?.map((e) => StreamingRecognitionResult.fromPartial(e)) || [];
    message.speechEventType = object.speechEventType ?? 0;
    message.speechEventTime = (object.speechEventTime !== undefined && object.speechEventTime !== null)
      ? Duration.fromPartial(object.speechEventTime)
      : undefined;
    message.totalBilledTime = (object.totalBilledTime !== undefined && object.totalBilledTime !== null)
      ? Duration.fromPartial(object.totalBilledTime)
      : undefined;
    message.speechAdaptationInfo = (object.speechAdaptationInfo !== undefined && object.speechAdaptationInfo !== null)
      ? SpeechAdaptationInfo.fromPartial(object.speechAdaptationInfo)
      : undefined;
    message.requestId = (object.requestId !== undefined && object.requestId !== null)
      ? Long.fromValue(object.requestId)
      : Long.ZERO;
    return message;
  },
};

function createBaseStreamingRecognitionResult(): StreamingRecognitionResult {
  return { alternatives: [], isFinal: false, stability: 0, resultEndTime: undefined, channelTag: 0, languageCode: "" };
}

export const StreamingRecognitionResult: MessageFns<StreamingRecognitionResult> = {
  encode(message: StreamingRecognitionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alternatives) {
      SpeechRecognitionAlternative.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.isFinal !== false) {
      writer.uint32(16).bool(message.isFinal);
    }
    if (message.stability !== 0) {
      writer.uint32(29).float(message.stability);
    }
    if (message.resultEndTime !== undefined) {
      Duration.encode(message.resultEndTime, writer.uint32(34).fork()).join();
    }
    if (message.channelTag !== 0) {
      writer.uint32(40).int32(message.channelTag);
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamingRecognitionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingRecognitionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternatives.push(SpeechRecognitionAlternative.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.stability = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resultEndTime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channelTag = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamingRecognitionResult {
    return {
      alternatives: globalThis.Array.isArray(object?.alternatives)
        ? object.alternatives.map((e: any) => SpeechRecognitionAlternative.fromJSON(e))
        : [],
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
      stability: isSet(object.stability) ? globalThis.Number(object.stability) : 0,
      resultEndTime: isSet(object.resultEndTime) ? Duration.fromJSON(object.resultEndTime) : undefined,
      channelTag: isSet(object.channelTag) ? globalThis.Number(object.channelTag) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: StreamingRecognitionResult): unknown {
    const obj: any = {};
    if (message.alternatives?.length) {
      obj.alternatives = message.alternatives.map((e) => SpeechRecognitionAlternative.toJSON(e));
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    if (message.stability !== 0) {
      obj.stability = message.stability;
    }
    if (message.resultEndTime !== undefined) {
      obj.resultEndTime = Duration.toJSON(message.resultEndTime);
    }
    if (message.channelTag !== 0) {
      obj.channelTag = Math.round(message.channelTag);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamingRecognitionResult>): StreamingRecognitionResult {
    return StreamingRecognitionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamingRecognitionResult>): StreamingRecognitionResult {
    const message = createBaseStreamingRecognitionResult();
    message.alternatives = object.alternatives?.map((e) => SpeechRecognitionAlternative.fromPartial(e)) || [];
    message.isFinal = object.isFinal ?? false;
    message.stability = object.stability ?? 0;
    message.resultEndTime = (object.resultEndTime !== undefined && object.resultEndTime !== null)
      ? Duration.fromPartial(object.resultEndTime)
      : undefined;
    message.channelTag = object.channelTag ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseSpeechRecognitionResult(): SpeechRecognitionResult {
  return { alternatives: [], channelTag: 0, resultEndTime: undefined, languageCode: "" };
}

export const SpeechRecognitionResult: MessageFns<SpeechRecognitionResult> = {
  encode(message: SpeechRecognitionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.alternatives) {
      SpeechRecognitionAlternative.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.channelTag !== 0) {
      writer.uint32(16).int32(message.channelTag);
    }
    if (message.resultEndTime !== undefined) {
      Duration.encode(message.resultEndTime, writer.uint32(34).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechRecognitionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechRecognitionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternatives.push(SpeechRecognitionAlternative.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.channelTag = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resultEndTime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechRecognitionResult {
    return {
      alternatives: globalThis.Array.isArray(object?.alternatives)
        ? object.alternatives.map((e: any) => SpeechRecognitionAlternative.fromJSON(e))
        : [],
      channelTag: isSet(object.channelTag) ? globalThis.Number(object.channelTag) : 0,
      resultEndTime: isSet(object.resultEndTime) ? Duration.fromJSON(object.resultEndTime) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: SpeechRecognitionResult): unknown {
    const obj: any = {};
    if (message.alternatives?.length) {
      obj.alternatives = message.alternatives.map((e) => SpeechRecognitionAlternative.toJSON(e));
    }
    if (message.channelTag !== 0) {
      obj.channelTag = Math.round(message.channelTag);
    }
    if (message.resultEndTime !== undefined) {
      obj.resultEndTime = Duration.toJSON(message.resultEndTime);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechRecognitionResult>): SpeechRecognitionResult {
    return SpeechRecognitionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechRecognitionResult>): SpeechRecognitionResult {
    const message = createBaseSpeechRecognitionResult();
    message.alternatives = object.alternatives?.map((e) => SpeechRecognitionAlternative.fromPartial(e)) || [];
    message.channelTag = object.channelTag ?? 0;
    message.resultEndTime = (object.resultEndTime !== undefined && object.resultEndTime !== null)
      ? Duration.fromPartial(object.resultEndTime)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseSpeechRecognitionAlternative(): SpeechRecognitionAlternative {
  return { transcript: "", confidence: 0, words: [] };
}

export const SpeechRecognitionAlternative: MessageFns<SpeechRecognitionAlternative> = {
  encode(message: SpeechRecognitionAlternative, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transcript !== "") {
      writer.uint32(10).string(message.transcript);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    for (const v of message.words) {
      WordInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechRecognitionAlternative {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechRecognitionAlternative();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transcript = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.words.push(WordInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechRecognitionAlternative {
    return {
      transcript: isSet(object.transcript) ? globalThis.String(object.transcript) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      words: globalThis.Array.isArray(object?.words) ? object.words.map((e: any) => WordInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: SpeechRecognitionAlternative): unknown {
    const obj: any = {};
    if (message.transcript !== "") {
      obj.transcript = message.transcript;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.words?.length) {
      obj.words = message.words.map((e) => WordInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechRecognitionAlternative>): SpeechRecognitionAlternative {
    return SpeechRecognitionAlternative.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechRecognitionAlternative>): SpeechRecognitionAlternative {
    const message = createBaseSpeechRecognitionAlternative();
    message.transcript = object.transcript ?? "";
    message.confidence = object.confidence ?? 0;
    message.words = object.words?.map((e) => WordInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWordInfo(): WordInfo {
  return { startTime: undefined, endTime: undefined, word: "", confidence: 0, speakerTag: 0, speakerLabel: "" };
}

export const WordInfo: MessageFns<WordInfo> = {
  encode(message: WordInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Duration.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Duration.encode(message.endTime, writer.uint32(18).fork()).join();
    }
    if (message.word !== "") {
      writer.uint32(26).string(message.word);
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    if (message.speakerTag !== 0) {
      writer.uint32(40).int32(message.speakerTag);
    }
    if (message.speakerLabel !== "") {
      writer.uint32(50).string(message.speakerLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WordInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWordInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.word = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.speakerTag = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.speakerLabel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WordInfo {
    return {
      startTime: isSet(object.startTime) ? Duration.fromJSON(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? Duration.fromJSON(object.endTime) : undefined,
      word: isSet(object.word) ? globalThis.String(object.word) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      speakerTag: isSet(object.speakerTag) ? globalThis.Number(object.speakerTag) : 0,
      speakerLabel: isSet(object.speakerLabel) ? globalThis.String(object.speakerLabel) : "",
    };
  },

  toJSON(message: WordInfo): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = Duration.toJSON(message.startTime);
    }
    if (message.endTime !== undefined) {
      obj.endTime = Duration.toJSON(message.endTime);
    }
    if (message.word !== "") {
      obj.word = message.word;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.speakerTag !== 0) {
      obj.speakerTag = Math.round(message.speakerTag);
    }
    if (message.speakerLabel !== "") {
      obj.speakerLabel = message.speakerLabel;
    }
    return obj;
  },

  create(base?: DeepPartial<WordInfo>): WordInfo {
    return WordInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WordInfo>): WordInfo {
    const message = createBaseWordInfo();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Duration.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Duration.fromPartial(object.endTime)
      : undefined;
    message.word = object.word ?? "";
    message.confidence = object.confidence ?? 0;
    message.speakerTag = object.speakerTag ?? 0;
    message.speakerLabel = object.speakerLabel ?? "";
    return message;
  },
};

function createBaseSpeechAdaptationInfo(): SpeechAdaptationInfo {
  return { adaptationTimeout: false, timeoutMessage: "" };
}

export const SpeechAdaptationInfo: MessageFns<SpeechAdaptationInfo> = {
  encode(message: SpeechAdaptationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adaptationTimeout !== false) {
      writer.uint32(8).bool(message.adaptationTimeout);
    }
    if (message.timeoutMessage !== "") {
      writer.uint32(34).string(message.timeoutMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechAdaptationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechAdaptationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.adaptationTimeout = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeoutMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechAdaptationInfo {
    return {
      adaptationTimeout: isSet(object.adaptationTimeout) ? globalThis.Boolean(object.adaptationTimeout) : false,
      timeoutMessage: isSet(object.timeoutMessage) ? globalThis.String(object.timeoutMessage) : "",
    };
  },

  toJSON(message: SpeechAdaptationInfo): unknown {
    const obj: any = {};
    if (message.adaptationTimeout !== false) {
      obj.adaptationTimeout = message.adaptationTimeout;
    }
    if (message.timeoutMessage !== "") {
      obj.timeoutMessage = message.timeoutMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechAdaptationInfo>): SpeechAdaptationInfo {
    return SpeechAdaptationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechAdaptationInfo>): SpeechAdaptationInfo {
    const message = createBaseSpeechAdaptationInfo();
    message.adaptationTimeout = object.adaptationTimeout ?? false;
    message.timeoutMessage = object.timeoutMessage ?? "";
    return message;
  },
};

/** Service that implements Google Cloud Speech API. */
export type SpeechDefinition = typeof SpeechDefinition;
export const SpeechDefinition = {
  name: "Speech",
  fullName: "google.cloud.speech.v1.Speech",
  methods: {
    /**
     * Performs synchronous speech recognition: receive results after all audio
     * has been sent and processed.
     */
    recognize: {
      name: "Recognize",
      requestType: RecognizeRequest,
      requestStream: false,
      responseType: RecognizeResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 99, 111, 110, 102, 105, 103, 44, 97, 117, 100, 105, 111])],
          578365826: [
            Buffer.from([
              25,
              58,
              1,
              42,
              34,
              20,
              47,
              118,
              49,
              47,
              115,
              112,
              101,
              101,
              99,
              104,
              58,
              114,
              101,
              99,
              111,
              103,
              110,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Performs asynchronous speech recognition: receive results via the
     * google.longrunning.Operations interface. Returns either an
     * `Operation.error` or an `Operation.response` which contains
     * a `LongRunningRecognizeResponse` message.
     * For more information on asynchronous speech recognition, see the
     * [how-to](https://cloud.google.com/speech-to-text/docs/async-recognize).
     */
    longRunningRecognize: {
      name: "LongRunningRecognize",
      requestType: LongRunningRecognizeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              60,
              10,
              28,
              76,
              111,
              110,
              103,
              82,
              117,
              110,
              110,
              105,
              110,
              103,
              82,
              101,
              99,
              111,
              103,
              110,
              105,
              122,
              101,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              28,
              76,
              111,
              110,
              103,
              82,
              117,
              110,
              110,
              105,
              110,
              103,
              82,
              101,
              99,
              111,
              103,
              110,
              105,
              122,
              101,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([12, 99, 111, 110, 102, 105, 103, 44, 97, 117, 100, 105, 111])],
          578365826: [
            Buffer.from([
              36,
              58,
              1,
              42,
              34,
              31,
              47,
              118,
              49,
              47,
              115,
              112,
              101,
              101,
              99,
              104,
              58,
              108,
              111,
              110,
              103,
              114,
              117,
              110,
              110,
              105,
              110,
              103,
              114,
              101,
              99,
              111,
              103,
              110,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Performs bidirectional streaming speech recognition: receive results while
     * sending audio. This method is only available via the gRPC API (not REST).
     */
    streamingRecognize: {
      name: "StreamingRecognize",
      requestType: StreamingRecognizeRequest,
      requestStream: true,
      responseType: StreamingRecognizeResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface SpeechServiceImplementation<CallContextExt = {}> {
  /**
   * Performs synchronous speech recognition: receive results after all audio
   * has been sent and processed.
   */
  recognize(request: RecognizeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RecognizeResponse>>;
  /**
   * Performs asynchronous speech recognition: receive results via the
   * google.longrunning.Operations interface. Returns either an
   * `Operation.error` or an `Operation.response` which contains
   * a `LongRunningRecognizeResponse` message.
   * For more information on asynchronous speech recognition, see the
   * [how-to](https://cloud.google.com/speech-to-text/docs/async-recognize).
   */
  longRunningRecognize(
    request: LongRunningRecognizeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Performs bidirectional streaming speech recognition: receive results while
   * sending audio. This method is only available via the gRPC API (not REST).
   */
  streamingRecognize(
    request: AsyncIterable<StreamingRecognizeRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<StreamingRecognizeResponse>>;
}

export interface SpeechClient<CallOptionsExt = {}> {
  /**
   * Performs synchronous speech recognition: receive results after all audio
   * has been sent and processed.
   */
  recognize(request: DeepPartial<RecognizeRequest>, options?: CallOptions & CallOptionsExt): Promise<RecognizeResponse>;
  /**
   * Performs asynchronous speech recognition: receive results via the
   * google.longrunning.Operations interface. Returns either an
   * `Operation.error` or an `Operation.response` which contains
   * a `LongRunningRecognizeResponse` message.
   * For more information on asynchronous speech recognition, see the
   * [how-to](https://cloud.google.com/speech-to-text/docs/async-recognize).
   */
  longRunningRecognize(
    request: DeepPartial<LongRunningRecognizeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Performs bidirectional streaming speech recognition: receive results while
   * sending audio. This method is only available via the gRPC API (not REST).
   */
  streamingRecognize(
    request: AsyncIterable<DeepPartial<StreamingRecognizeRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<StreamingRecognizeResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
