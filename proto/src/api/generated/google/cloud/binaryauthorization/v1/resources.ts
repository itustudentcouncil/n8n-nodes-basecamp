// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/binaryauthorization/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.binaryauthorization.v1";

/** A [policy][google.cloud.binaryauthorization.v1.Policy] for container image binary authorization. */
export interface Policy {
  /**
   * Output only. The resource name, in the format `projects/* /policy`. There is
   * at most one policy per project.
   */
  name: string;
  /** Optional. A descriptive comment. */
  description: string;
  /**
   * Optional. Controls the evaluation of a Google-maintained global admission
   * policy for common system-level images. Images not covered by the global
   * policy will be subject to the project admission policy. This setting
   * has no effect when specified inside a global admission policy.
   */
  globalPolicyEvaluationMode: Policy_GlobalPolicyEvaluationMode;
  /**
   * Optional. Admission policy allowlisting. A matching admission request will
   * always be permitted. This feature is typically used to exclude Google or
   * third-party infrastructure images from Binary Authorization policies.
   */
  admissionWhitelistPatterns: AdmissionWhitelistPattern[];
  /**
   * Optional. Per-cluster admission rules. Cluster spec format:
   * `location.clusterId`. There can be at most one admission rule per cluster
   * spec.
   * A `location` is either a compute zone (e.g. us-central1-a) or a region
   * (e.g. us-central1).
   * For `clusterId` syntax restrictions see
   * https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters.
   */
  clusterAdmissionRules: { [key: string]: AdmissionRule };
  /**
   * Optional. Per-kubernetes-namespace admission rules. K8s namespace spec format:
   * [a-z.-]+, e.g. 'some-namespace'
   */
  kubernetesNamespaceAdmissionRules: { [key: string]: AdmissionRule };
  /**
   * Optional. Per-kubernetes-service-account admission rules. Service account
   * spec format: `namespace:serviceaccount`. e.g. 'test-ns:default'
   */
  kubernetesServiceAccountAdmissionRules: { [key: string]: AdmissionRule };
  /**
   * Optional. Per-istio-service-identity admission rules. Istio service
   * identity spec format:
   * spiffe://<domain>/ns/<namespace>/sa/<serviceaccount> or
   * <domain>/ns/<namespace>/sa/<serviceaccount>
   * e.g. spiffe://example.com/ns/test-ns/sa/default
   */
  istioServiceIdentityAdmissionRules: { [key: string]: AdmissionRule };
  /**
   * Required. Default admission rule for a cluster without a per-cluster, per-
   * kubernetes-service-account, or per-istio-service-identity admission rule.
   */
  defaultAdmissionRule:
    | AdmissionRule
    | undefined;
  /** Output only. Time when the policy was last updated. */
  updateTime: Date | undefined;
}

export enum Policy_GlobalPolicyEvaluationMode {
  /** GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED - Not specified: DISABLE is assumed. */
  GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED = 0,
  /** ENABLE - Enables system policy evaluation. */
  ENABLE = 1,
  /** DISABLE - Disables system policy evaluation. */
  DISABLE = 2,
  UNRECOGNIZED = -1,
}

export function policy_GlobalPolicyEvaluationModeFromJSON(object: any): Policy_GlobalPolicyEvaluationMode {
  switch (object) {
    case 0:
    case "GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED":
      return Policy_GlobalPolicyEvaluationMode.GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED;
    case 1:
    case "ENABLE":
      return Policy_GlobalPolicyEvaluationMode.ENABLE;
    case 2:
    case "DISABLE":
      return Policy_GlobalPolicyEvaluationMode.DISABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Policy_GlobalPolicyEvaluationMode.UNRECOGNIZED;
  }
}

export function policy_GlobalPolicyEvaluationModeToJSON(object: Policy_GlobalPolicyEvaluationMode): string {
  switch (object) {
    case Policy_GlobalPolicyEvaluationMode.GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED:
      return "GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED";
    case Policy_GlobalPolicyEvaluationMode.ENABLE:
      return "ENABLE";
    case Policy_GlobalPolicyEvaluationMode.DISABLE:
      return "DISABLE";
    case Policy_GlobalPolicyEvaluationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Policy_ClusterAdmissionRulesEntry {
  key: string;
  value: AdmissionRule | undefined;
}

export interface Policy_KubernetesNamespaceAdmissionRulesEntry {
  key: string;
  value: AdmissionRule | undefined;
}

export interface Policy_KubernetesServiceAccountAdmissionRulesEntry {
  key: string;
  value: AdmissionRule | undefined;
}

export interface Policy_IstioServiceIdentityAdmissionRulesEntry {
  key: string;
  value: AdmissionRule | undefined;
}

/**
 * An [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern] exempts images
 * from checks by [admission rules][google.cloud.binaryauthorization.v1.AdmissionRule].
 */
export interface AdmissionWhitelistPattern {
  /**
   * An image name pattern to allowlist, in the form `registry/path/to/image`.
   * This supports a trailing `*` wildcard, but this is allowed only in
   * text after the `registry/` part. This also supports a trailing `**`
   * wildcard which matches subdirectories of a given entry.
   */
  namePattern: string;
}

/**
 * An [admission rule][google.cloud.binaryauthorization.v1.AdmissionRule] specifies either that all container images
 * used in a pod creation request must be attested to by one or more
 * [attestors][google.cloud.binaryauthorization.v1.Attestor], that all pod creations will be allowed, or that all
 * pod creations will be denied.
 *
 * Images matching an [admission allowlist pattern][google.cloud.binaryauthorization.v1.AdmissionWhitelistPattern]
 * are exempted from admission rules and will never block a pod creation.
 */
export interface AdmissionRule {
  /** Required. How this admission rule will be evaluated. */
  evaluationMode: AdmissionRule_EvaluationMode;
  /**
   * Optional. The resource names of the attestors that must attest to
   * a container image, in the format `projects/* /attestors/*`. Each
   * attestor must exist before a policy can reference it.  To add an attestor
   * to a policy the principal issuing the policy change request must be able
   * to read the attestor resource.
   *
   * Note: this field must be non-empty when the evaluation_mode field specifies
   * REQUIRE_ATTESTATION, otherwise it must be empty.
   */
  requireAttestationsBy: string[];
  /** Required. The action when a pod creation is denied by the admission rule. */
  enforcementMode: AdmissionRule_EnforcementMode;
}

export enum AdmissionRule_EvaluationMode {
  /** EVALUATION_MODE_UNSPECIFIED - Do not use. */
  EVALUATION_MODE_UNSPECIFIED = 0,
  /** ALWAYS_ALLOW - This rule allows all all pod creations. */
  ALWAYS_ALLOW = 1,
  /**
   * REQUIRE_ATTESTATION - This rule allows a pod creation if all the attestors listed in
   * 'require_attestations_by' have valid attestations for all of the
   * images in the pod spec.
   */
  REQUIRE_ATTESTATION = 2,
  /** ALWAYS_DENY - This rule denies all pod creations. */
  ALWAYS_DENY = 3,
  UNRECOGNIZED = -1,
}

export function admissionRule_EvaluationModeFromJSON(object: any): AdmissionRule_EvaluationMode {
  switch (object) {
    case 0:
    case "EVALUATION_MODE_UNSPECIFIED":
      return AdmissionRule_EvaluationMode.EVALUATION_MODE_UNSPECIFIED;
    case 1:
    case "ALWAYS_ALLOW":
      return AdmissionRule_EvaluationMode.ALWAYS_ALLOW;
    case 2:
    case "REQUIRE_ATTESTATION":
      return AdmissionRule_EvaluationMode.REQUIRE_ATTESTATION;
    case 3:
    case "ALWAYS_DENY":
      return AdmissionRule_EvaluationMode.ALWAYS_DENY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AdmissionRule_EvaluationMode.UNRECOGNIZED;
  }
}

export function admissionRule_EvaluationModeToJSON(object: AdmissionRule_EvaluationMode): string {
  switch (object) {
    case AdmissionRule_EvaluationMode.EVALUATION_MODE_UNSPECIFIED:
      return "EVALUATION_MODE_UNSPECIFIED";
    case AdmissionRule_EvaluationMode.ALWAYS_ALLOW:
      return "ALWAYS_ALLOW";
    case AdmissionRule_EvaluationMode.REQUIRE_ATTESTATION:
      return "REQUIRE_ATTESTATION";
    case AdmissionRule_EvaluationMode.ALWAYS_DENY:
      return "ALWAYS_DENY";
    case AdmissionRule_EvaluationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines the possible actions when a pod creation is denied by an admission
 * rule.
 */
export enum AdmissionRule_EnforcementMode {
  /** ENFORCEMENT_MODE_UNSPECIFIED - Do not use. */
  ENFORCEMENT_MODE_UNSPECIFIED = 0,
  /** ENFORCED_BLOCK_AND_AUDIT_LOG - Enforce the admission rule by blocking the pod creation. */
  ENFORCED_BLOCK_AND_AUDIT_LOG = 1,
  /**
   * DRYRUN_AUDIT_LOG_ONLY - Dryrun mode: Audit logging only.  This will allow the pod creation as if
   * the admission request had specified break-glass.
   */
  DRYRUN_AUDIT_LOG_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function admissionRule_EnforcementModeFromJSON(object: any): AdmissionRule_EnforcementMode {
  switch (object) {
    case 0:
    case "ENFORCEMENT_MODE_UNSPECIFIED":
      return AdmissionRule_EnforcementMode.ENFORCEMENT_MODE_UNSPECIFIED;
    case 1:
    case "ENFORCED_BLOCK_AND_AUDIT_LOG":
      return AdmissionRule_EnforcementMode.ENFORCED_BLOCK_AND_AUDIT_LOG;
    case 2:
    case "DRYRUN_AUDIT_LOG_ONLY":
      return AdmissionRule_EnforcementMode.DRYRUN_AUDIT_LOG_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AdmissionRule_EnforcementMode.UNRECOGNIZED;
  }
}

export function admissionRule_EnforcementModeToJSON(object: AdmissionRule_EnforcementMode): string {
  switch (object) {
    case AdmissionRule_EnforcementMode.ENFORCEMENT_MODE_UNSPECIFIED:
      return "ENFORCEMENT_MODE_UNSPECIFIED";
    case AdmissionRule_EnforcementMode.ENFORCED_BLOCK_AND_AUDIT_LOG:
      return "ENFORCED_BLOCK_AND_AUDIT_LOG";
    case AdmissionRule_EnforcementMode.DRYRUN_AUDIT_LOG_ONLY:
      return "DRYRUN_AUDIT_LOG_ONLY";
    case AdmissionRule_EnforcementMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An [attestor][google.cloud.binaryauthorization.v1.Attestor] that attests to container image
 * artifacts. An existing attestor cannot be modified except where
 * indicated.
 */
export interface Attestor {
  /**
   * Required. The resource name, in the format:
   * `projects/* /attestors/*`. This field may not be updated.
   */
  name: string;
  /**
   * Optional. A descriptive comment.  This field may be updated.
   * The field may be displayed in chooser dialogs.
   */
  description: string;
  /**
   * This specifies how an attestation will be read, and how it will be used
   * during policy enforcement.
   */
  userOwnedGrafeasNote?:
    | UserOwnedGrafeasNote
    | undefined;
  /** Output only. Time when the attestor was last updated. */
  updateTime: Date | undefined;
}

/**
 * An [user owned Grafeas note][google.cloud.binaryauthorization.v1.UserOwnedGrafeasNote] references a Grafeas
 * Attestation.Authority Note created by the user.
 */
export interface UserOwnedGrafeasNote {
  /**
   * Required. The Grafeas resource name of a Attestation.Authority Note,
   * created by the user, in the format: `projects/* /notes/*`. This field may
   * not be updated.
   *
   * An attestation by this attestor is stored as a Grafeas
   * Attestation.Authority Occurrence that names a container image and that
   * links to this Note. Grafeas is an external dependency.
   */
  noteReference: string;
  /**
   * Optional. Public keys that verify attestations signed by this
   * attestor.  This field may be updated.
   *
   * If this field is non-empty, one of the specified public keys must
   * verify that an attestation was signed by this attestor for the
   * image specified in the admission request.
   *
   * If this field is empty, this attestor always returns that no
   * valid attestations exist.
   */
  publicKeys: AttestorPublicKey[];
  /**
   * Output only. This field will contain the service account email address
   * that this Attestor will use as the principal when querying Container
   * Analysis. Attestor administrators must grant this service account the
   * IAM role needed to read attestations from the [note_reference][Note] in
   * Container Analysis (`containeranalysis.notes.occurrences.viewer`).
   *
   * This email address is fixed for the lifetime of the Attestor, but callers
   * should not make any other assumptions about the service account email;
   * future versions may use an email based on a different naming pattern.
   */
  delegationServiceAccountEmail: string;
}

/**
 * A public key in the PkixPublicKey format (see
 * https://tools.ietf.org/html/rfc5280#section-4.1.2.7 for details).
 * Public keys of this type are typically textually encoded using the PEM
 * format.
 */
export interface PkixPublicKey {
  /**
   * A PEM-encoded public key, as described in
   * https://tools.ietf.org/html/rfc7468#section-13
   */
  publicKeyPem: string;
  /**
   * The signature algorithm used to verify a message against a signature using
   * this key.
   * These signature algorithm must match the structure and any object
   * identifiers encoded in `public_key_pem` (i.e. this algorithm must match
   * that of the public key).
   */
  signatureAlgorithm: PkixPublicKey_SignatureAlgorithm;
}

/**
 * Represents a signature algorithm and other information necessary to verify
 * signatures with a given public key.
 * This is based primarily on the public key types supported by Tink's
 * PemKeyType, which is in turn based on KMS's supported signing algorithms.
 * See https://cloud.google.com/kms/docs/algorithms. In the future, BinAuthz
 * might support additional public key types independently of Tink and/or KMS.
 */
export enum PkixPublicKey_SignatureAlgorithm {
  /** SIGNATURE_ALGORITHM_UNSPECIFIED - Not specified. */
  SIGNATURE_ALGORITHM_UNSPECIFIED = 0,
  /** RSA_PSS_2048_SHA256 - RSASSA-PSS 2048 bit key with a SHA256 digest. */
  RSA_PSS_2048_SHA256 = 1,
  /** RSA_PSS_3072_SHA256 - RSASSA-PSS 3072 bit key with a SHA256 digest. */
  RSA_PSS_3072_SHA256 = 2,
  /** RSA_PSS_4096_SHA256 - RSASSA-PSS 4096 bit key with a SHA256 digest. */
  RSA_PSS_4096_SHA256 = 3,
  /** RSA_PSS_4096_SHA512 - RSASSA-PSS 4096 bit key with a SHA512 digest. */
  RSA_PSS_4096_SHA512 = 4,
  /** RSA_SIGN_PKCS1_2048_SHA256 - RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_2048_SHA256 = 5,
  /** RSA_SIGN_PKCS1_3072_SHA256 - RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_3072_SHA256 = 6,
  /** RSA_SIGN_PKCS1_4096_SHA256 - RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest. */
  RSA_SIGN_PKCS1_4096_SHA256 = 7,
  /** RSA_SIGN_PKCS1_4096_SHA512 - RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest. */
  RSA_SIGN_PKCS1_4096_SHA512 = 8,
  /** ECDSA_P256_SHA256 - ECDSA on the NIST P-256 curve with a SHA256 digest. */
  ECDSA_P256_SHA256 = 9,
  /** EC_SIGN_P256_SHA256 - ECDSA on the NIST P-256 curve with a SHA256 digest. */
  EC_SIGN_P256_SHA256 = 9,
  /** ECDSA_P384_SHA384 - ECDSA on the NIST P-384 curve with a SHA384 digest. */
  ECDSA_P384_SHA384 = 10,
  /** EC_SIGN_P384_SHA384 - ECDSA on the NIST P-384 curve with a SHA384 digest. */
  EC_SIGN_P384_SHA384 = 10,
  /** ECDSA_P521_SHA512 - ECDSA on the NIST P-521 curve with a SHA512 digest. */
  ECDSA_P521_SHA512 = 11,
  /** EC_SIGN_P521_SHA512 - ECDSA on the NIST P-521 curve with a SHA512 digest. */
  EC_SIGN_P521_SHA512 = 11,
  UNRECOGNIZED = -1,
}

export function pkixPublicKey_SignatureAlgorithmFromJSON(object: any): PkixPublicKey_SignatureAlgorithm {
  switch (object) {
    case 0:
    case "SIGNATURE_ALGORITHM_UNSPECIFIED":
      return PkixPublicKey_SignatureAlgorithm.SIGNATURE_ALGORITHM_UNSPECIFIED;
    case 1:
    case "RSA_PSS_2048_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_PSS_2048_SHA256;
    case 2:
    case "RSA_PSS_3072_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_PSS_3072_SHA256;
    case 3:
    case "RSA_PSS_4096_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_PSS_4096_SHA256;
    case 4:
    case "RSA_PSS_4096_SHA512":
      return PkixPublicKey_SignatureAlgorithm.RSA_PSS_4096_SHA512;
    case 5:
    case "RSA_SIGN_PKCS1_2048_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_2048_SHA256;
    case 6:
    case "RSA_SIGN_PKCS1_3072_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_3072_SHA256;
    case 7:
    case "RSA_SIGN_PKCS1_4096_SHA256":
      return PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_4096_SHA256;
    case 8:
    case "RSA_SIGN_PKCS1_4096_SHA512":
      return PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_4096_SHA512;
    case 9:
    case "ECDSA_P256_SHA256":
      return PkixPublicKey_SignatureAlgorithm.ECDSA_P256_SHA256;
    case 9:
    case "EC_SIGN_P256_SHA256":
      return PkixPublicKey_SignatureAlgorithm.EC_SIGN_P256_SHA256;
    case 10:
    case "ECDSA_P384_SHA384":
      return PkixPublicKey_SignatureAlgorithm.ECDSA_P384_SHA384;
    case 10:
    case "EC_SIGN_P384_SHA384":
      return PkixPublicKey_SignatureAlgorithm.EC_SIGN_P384_SHA384;
    case 11:
    case "ECDSA_P521_SHA512":
      return PkixPublicKey_SignatureAlgorithm.ECDSA_P521_SHA512;
    case 11:
    case "EC_SIGN_P521_SHA512":
      return PkixPublicKey_SignatureAlgorithm.EC_SIGN_P521_SHA512;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PkixPublicKey_SignatureAlgorithm.UNRECOGNIZED;
  }
}

export function pkixPublicKey_SignatureAlgorithmToJSON(object: PkixPublicKey_SignatureAlgorithm): string {
  switch (object) {
    case PkixPublicKey_SignatureAlgorithm.SIGNATURE_ALGORITHM_UNSPECIFIED:
      return "SIGNATURE_ALGORITHM_UNSPECIFIED";
    case PkixPublicKey_SignatureAlgorithm.RSA_PSS_2048_SHA256:
      return "RSA_PSS_2048_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_PSS_3072_SHA256:
      return "RSA_PSS_3072_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_PSS_4096_SHA256:
      return "RSA_PSS_4096_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_PSS_4096_SHA512:
      return "RSA_PSS_4096_SHA512";
    case PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_2048_SHA256:
      return "RSA_SIGN_PKCS1_2048_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_3072_SHA256:
      return "RSA_SIGN_PKCS1_3072_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_4096_SHA256:
      return "RSA_SIGN_PKCS1_4096_SHA256";
    case PkixPublicKey_SignatureAlgorithm.RSA_SIGN_PKCS1_4096_SHA512:
      return "RSA_SIGN_PKCS1_4096_SHA512";
    case PkixPublicKey_SignatureAlgorithm.ECDSA_P256_SHA256:
      return "ECDSA_P256_SHA256";
    case PkixPublicKey_SignatureAlgorithm.EC_SIGN_P256_SHA256:
      return "EC_SIGN_P256_SHA256";
    case PkixPublicKey_SignatureAlgorithm.ECDSA_P384_SHA384:
      return "ECDSA_P384_SHA384";
    case PkixPublicKey_SignatureAlgorithm.EC_SIGN_P384_SHA384:
      return "EC_SIGN_P384_SHA384";
    case PkixPublicKey_SignatureAlgorithm.ECDSA_P521_SHA512:
      return "ECDSA_P521_SHA512";
    case PkixPublicKey_SignatureAlgorithm.EC_SIGN_P521_SHA512:
      return "EC_SIGN_P521_SHA512";
    case PkixPublicKey_SignatureAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An [attestor public key][google.cloud.binaryauthorization.v1.AttestorPublicKey] that will be used to verify
 * attestations signed by this attestor.
 */
export interface AttestorPublicKey {
  /** Optional. A descriptive comment. This field may be updated. */
  comment: string;
  /**
   * The ID of this public key.
   * Signatures verified by BinAuthz must include the ID of the public key that
   * can be used to verify them, and that ID must match the contents of this
   * field exactly.
   * Additional restrictions on this field can be imposed based on which public
   * key type is encapsulated. See the documentation on `public_key` cases below
   * for details.
   */
  id: string;
  /**
   * ASCII-armored representation of a PGP public key, as the entire output by
   * the command `gpg --export --armor foo@example.com` (either LF or CRLF
   * line endings).
   * When using this field, `id` should be left blank.  The BinAuthz API
   * handlers will calculate the ID and fill it in automatically.  BinAuthz
   * computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as
   * upper-case hex.  If `id` is provided by the caller, it will be
   * overwritten by the API-calculated ID.
   */
  asciiArmoredPgpPublicKey?:
    | string
    | undefined;
  /**
   * A raw PKIX SubjectPublicKeyInfo format public key.
   *
   * NOTE: `id` may be explicitly provided by the caller when using this
   * type of public key, but it MUST be a valid RFC3986 URI. If `id` is left
   * blank, a default one will be computed based on the digest of the DER
   * encoding of the public key.
   */
  pkixPublicKey?: PkixPublicKey | undefined;
}

function createBasePolicy(): Policy {
  return {
    name: "",
    description: "",
    globalPolicyEvaluationMode: 0,
    admissionWhitelistPatterns: [],
    clusterAdmissionRules: {},
    kubernetesNamespaceAdmissionRules: {},
    kubernetesServiceAccountAdmissionRules: {},
    istioServiceIdentityAdmissionRules: {},
    defaultAdmissionRule: undefined,
    updateTime: undefined,
  };
}

export const Policy: MessageFns<Policy> = {
  encode(message: Policy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.globalPolicyEvaluationMode !== 0) {
      writer.uint32(56).int32(message.globalPolicyEvaluationMode);
    }
    for (const v of message.admissionWhitelistPatterns) {
      AdmissionWhitelistPattern.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.clusterAdmissionRules).forEach(([key, value]) => {
      Policy_ClusterAdmissionRulesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.kubernetesNamespaceAdmissionRules).forEach(([key, value]) => {
      Policy_KubernetesNamespaceAdmissionRulesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    Object.entries(message.kubernetesServiceAccountAdmissionRules).forEach(([key, value]) => {
      Policy_KubernetesServiceAccountAdmissionRulesEntry.encode({ key: key as any, value }, writer.uint32(66).fork())
        .join();
    });
    Object.entries(message.istioServiceIdentityAdmissionRules).forEach(([key, value]) => {
      Policy_IstioServiceIdentityAdmissionRulesEntry.encode({ key: key as any, value }, writer.uint32(74).fork())
        .join();
    });
    if (message.defaultAdmissionRule !== undefined) {
      AdmissionRule.encode(message.defaultAdmissionRule, writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.globalPolicyEvaluationMode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.admissionWhitelistPatterns.push(AdmissionWhitelistPattern.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Policy_ClusterAdmissionRulesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.clusterAdmissionRules[entry3.key] = entry3.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Policy_KubernetesNamespaceAdmissionRulesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.kubernetesNamespaceAdmissionRules[entry10.key] = entry10.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Policy_KubernetesServiceAccountAdmissionRulesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.kubernetesServiceAccountAdmissionRules[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Policy_IstioServiceIdentityAdmissionRulesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.istioServiceIdentityAdmissionRules[entry9.key] = entry9.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.defaultAdmissionRule = AdmissionRule.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      globalPolicyEvaluationMode: isSet(object.globalPolicyEvaluationMode)
        ? policy_GlobalPolicyEvaluationModeFromJSON(object.globalPolicyEvaluationMode)
        : 0,
      admissionWhitelistPatterns: globalThis.Array.isArray(object?.admissionWhitelistPatterns)
        ? object.admissionWhitelistPatterns.map((e: any) => AdmissionWhitelistPattern.fromJSON(e))
        : [],
      clusterAdmissionRules: isObject(object.clusterAdmissionRules)
        ? Object.entries(object.clusterAdmissionRules).reduce<{ [key: string]: AdmissionRule }>((acc, [key, value]) => {
          acc[key] = AdmissionRule.fromJSON(value);
          return acc;
        }, {})
        : {},
      kubernetesNamespaceAdmissionRules: isObject(object.kubernetesNamespaceAdmissionRules)
        ? Object.entries(object.kubernetesNamespaceAdmissionRules).reduce<{ [key: string]: AdmissionRule }>(
          (acc, [key, value]) => {
            acc[key] = AdmissionRule.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      kubernetesServiceAccountAdmissionRules: isObject(object.kubernetesServiceAccountAdmissionRules)
        ? Object.entries(object.kubernetesServiceAccountAdmissionRules).reduce<{ [key: string]: AdmissionRule }>(
          (acc, [key, value]) => {
            acc[key] = AdmissionRule.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      istioServiceIdentityAdmissionRules: isObject(object.istioServiceIdentityAdmissionRules)
        ? Object.entries(object.istioServiceIdentityAdmissionRules).reduce<{ [key: string]: AdmissionRule }>(
          (acc, [key, value]) => {
            acc[key] = AdmissionRule.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      defaultAdmissionRule: isSet(object.defaultAdmissionRule)
        ? AdmissionRule.fromJSON(object.defaultAdmissionRule)
        : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.globalPolicyEvaluationMode !== 0) {
      obj.globalPolicyEvaluationMode = policy_GlobalPolicyEvaluationModeToJSON(message.globalPolicyEvaluationMode);
    }
    if (message.admissionWhitelistPatterns?.length) {
      obj.admissionWhitelistPatterns = message.admissionWhitelistPatterns.map((e) =>
        AdmissionWhitelistPattern.toJSON(e)
      );
    }
    if (message.clusterAdmissionRules) {
      const entries = Object.entries(message.clusterAdmissionRules);
      if (entries.length > 0) {
        obj.clusterAdmissionRules = {};
        entries.forEach(([k, v]) => {
          obj.clusterAdmissionRules[k] = AdmissionRule.toJSON(v);
        });
      }
    }
    if (message.kubernetesNamespaceAdmissionRules) {
      const entries = Object.entries(message.kubernetesNamespaceAdmissionRules);
      if (entries.length > 0) {
        obj.kubernetesNamespaceAdmissionRules = {};
        entries.forEach(([k, v]) => {
          obj.kubernetesNamespaceAdmissionRules[k] = AdmissionRule.toJSON(v);
        });
      }
    }
    if (message.kubernetesServiceAccountAdmissionRules) {
      const entries = Object.entries(message.kubernetesServiceAccountAdmissionRules);
      if (entries.length > 0) {
        obj.kubernetesServiceAccountAdmissionRules = {};
        entries.forEach(([k, v]) => {
          obj.kubernetesServiceAccountAdmissionRules[k] = AdmissionRule.toJSON(v);
        });
      }
    }
    if (message.istioServiceIdentityAdmissionRules) {
      const entries = Object.entries(message.istioServiceIdentityAdmissionRules);
      if (entries.length > 0) {
        obj.istioServiceIdentityAdmissionRules = {};
        entries.forEach(([k, v]) => {
          obj.istioServiceIdentityAdmissionRules[k] = AdmissionRule.toJSON(v);
        });
      }
    }
    if (message.defaultAdmissionRule !== undefined) {
      obj.defaultAdmissionRule = AdmissionRule.toJSON(message.defaultAdmissionRule);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Policy>): Policy {
    return Policy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Policy>): Policy {
    const message = createBasePolicy();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.globalPolicyEvaluationMode = object.globalPolicyEvaluationMode ?? 0;
    message.admissionWhitelistPatterns =
      object.admissionWhitelistPatterns?.map((e) => AdmissionWhitelistPattern.fromPartial(e)) || [];
    message.clusterAdmissionRules = Object.entries(object.clusterAdmissionRules ?? {}).reduce<
      { [key: string]: AdmissionRule }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AdmissionRule.fromPartial(value);
      }
      return acc;
    }, {});
    message.kubernetesNamespaceAdmissionRules = Object.entries(object.kubernetesNamespaceAdmissionRules ?? {}).reduce<
      { [key: string]: AdmissionRule }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AdmissionRule.fromPartial(value);
      }
      return acc;
    }, {});
    message.kubernetesServiceAccountAdmissionRules = Object.entries(object.kubernetesServiceAccountAdmissionRules ?? {})
      .reduce<{ [key: string]: AdmissionRule }>((acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AdmissionRule.fromPartial(value);
        }
        return acc;
      }, {});
    message.istioServiceIdentityAdmissionRules = Object.entries(object.istioServiceIdentityAdmissionRules ?? {}).reduce<
      { [key: string]: AdmissionRule }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AdmissionRule.fromPartial(value);
      }
      return acc;
    }, {});
    message.defaultAdmissionRule = (object.defaultAdmissionRule !== undefined && object.defaultAdmissionRule !== null)
      ? AdmissionRule.fromPartial(object.defaultAdmissionRule)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBasePolicy_ClusterAdmissionRulesEntry(): Policy_ClusterAdmissionRulesEntry {
  return { key: "", value: undefined };
}

export const Policy_ClusterAdmissionRulesEntry: MessageFns<Policy_ClusterAdmissionRulesEntry> = {
  encode(message: Policy_ClusterAdmissionRulesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AdmissionRule.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_ClusterAdmissionRulesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_ClusterAdmissionRulesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AdmissionRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_ClusterAdmissionRulesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AdmissionRule.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Policy_ClusterAdmissionRulesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AdmissionRule.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Policy_ClusterAdmissionRulesEntry>): Policy_ClusterAdmissionRulesEntry {
    return Policy_ClusterAdmissionRulesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Policy_ClusterAdmissionRulesEntry>): Policy_ClusterAdmissionRulesEntry {
    const message = createBasePolicy_ClusterAdmissionRulesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AdmissionRule.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePolicy_KubernetesNamespaceAdmissionRulesEntry(): Policy_KubernetesNamespaceAdmissionRulesEntry {
  return { key: "", value: undefined };
}

export const Policy_KubernetesNamespaceAdmissionRulesEntry: MessageFns<Policy_KubernetesNamespaceAdmissionRulesEntry> =
  {
    encode(
      message: Policy_KubernetesNamespaceAdmissionRulesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        AdmissionRule.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Policy_KubernetesNamespaceAdmissionRulesEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBasePolicy_KubernetesNamespaceAdmissionRulesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = AdmissionRule.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Policy_KubernetesNamespaceAdmissionRulesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? AdmissionRule.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: Policy_KubernetesNamespaceAdmissionRulesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = AdmissionRule.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<Policy_KubernetesNamespaceAdmissionRulesEntry>,
    ): Policy_KubernetesNamespaceAdmissionRulesEntry {
      return Policy_KubernetesNamespaceAdmissionRulesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Policy_KubernetesNamespaceAdmissionRulesEntry>,
    ): Policy_KubernetesNamespaceAdmissionRulesEntry {
      const message = createBasePolicy_KubernetesNamespaceAdmissionRulesEntry();
      message.key = object.key ?? "";
      message.value = (object.value !== undefined && object.value !== null)
        ? AdmissionRule.fromPartial(object.value)
        : undefined;
      return message;
    },
  };

function createBasePolicy_KubernetesServiceAccountAdmissionRulesEntry(): Policy_KubernetesServiceAccountAdmissionRulesEntry {
  return { key: "", value: undefined };
}

export const Policy_KubernetesServiceAccountAdmissionRulesEntry: MessageFns<
  Policy_KubernetesServiceAccountAdmissionRulesEntry
> = {
  encode(
    message: Policy_KubernetesServiceAccountAdmissionRulesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AdmissionRule.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_KubernetesServiceAccountAdmissionRulesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_KubernetesServiceAccountAdmissionRulesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AdmissionRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_KubernetesServiceAccountAdmissionRulesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AdmissionRule.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Policy_KubernetesServiceAccountAdmissionRulesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AdmissionRule.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Policy_KubernetesServiceAccountAdmissionRulesEntry>,
  ): Policy_KubernetesServiceAccountAdmissionRulesEntry {
    return Policy_KubernetesServiceAccountAdmissionRulesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Policy_KubernetesServiceAccountAdmissionRulesEntry>,
  ): Policy_KubernetesServiceAccountAdmissionRulesEntry {
    const message = createBasePolicy_KubernetesServiceAccountAdmissionRulesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AdmissionRule.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePolicy_IstioServiceIdentityAdmissionRulesEntry(): Policy_IstioServiceIdentityAdmissionRulesEntry {
  return { key: "", value: undefined };
}

export const Policy_IstioServiceIdentityAdmissionRulesEntry: MessageFns<
  Policy_IstioServiceIdentityAdmissionRulesEntry
> = {
  encode(
    message: Policy_IstioServiceIdentityAdmissionRulesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AdmissionRule.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy_IstioServiceIdentityAdmissionRulesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_IstioServiceIdentityAdmissionRulesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AdmissionRule.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_IstioServiceIdentityAdmissionRulesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AdmissionRule.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Policy_IstioServiceIdentityAdmissionRulesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AdmissionRule.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Policy_IstioServiceIdentityAdmissionRulesEntry>,
  ): Policy_IstioServiceIdentityAdmissionRulesEntry {
    return Policy_IstioServiceIdentityAdmissionRulesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Policy_IstioServiceIdentityAdmissionRulesEntry>,
  ): Policy_IstioServiceIdentityAdmissionRulesEntry {
    const message = createBasePolicy_IstioServiceIdentityAdmissionRulesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AdmissionRule.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAdmissionWhitelistPattern(): AdmissionWhitelistPattern {
  return { namePattern: "" };
}

export const AdmissionWhitelistPattern: MessageFns<AdmissionWhitelistPattern> = {
  encode(message: AdmissionWhitelistPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namePattern !== "") {
      writer.uint32(10).string(message.namePattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionWhitelistPattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionWhitelistPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namePattern = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionWhitelistPattern {
    return { namePattern: isSet(object.namePattern) ? globalThis.String(object.namePattern) : "" };
  },

  toJSON(message: AdmissionWhitelistPattern): unknown {
    const obj: any = {};
    if (message.namePattern !== "") {
      obj.namePattern = message.namePattern;
    }
    return obj;
  },

  create(base?: DeepPartial<AdmissionWhitelistPattern>): AdmissionWhitelistPattern {
    return AdmissionWhitelistPattern.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdmissionWhitelistPattern>): AdmissionWhitelistPattern {
    const message = createBaseAdmissionWhitelistPattern();
    message.namePattern = object.namePattern ?? "";
    return message;
  },
};

function createBaseAdmissionRule(): AdmissionRule {
  return { evaluationMode: 0, requireAttestationsBy: [], enforcementMode: 0 };
}

export const AdmissionRule: MessageFns<AdmissionRule> = {
  encode(message: AdmissionRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationMode !== 0) {
      writer.uint32(8).int32(message.evaluationMode);
    }
    for (const v of message.requireAttestationsBy) {
      writer.uint32(18).string(v!);
    }
    if (message.enforcementMode !== 0) {
      writer.uint32(24).int32(message.enforcementMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdmissionRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdmissionRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.evaluationMode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requireAttestationsBy.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enforcementMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdmissionRule {
    return {
      evaluationMode: isSet(object.evaluationMode) ? admissionRule_EvaluationModeFromJSON(object.evaluationMode) : 0,
      requireAttestationsBy: globalThis.Array.isArray(object?.requireAttestationsBy)
        ? object.requireAttestationsBy.map((e: any) => globalThis.String(e))
        : [],
      enforcementMode: isSet(object.enforcementMode)
        ? admissionRule_EnforcementModeFromJSON(object.enforcementMode)
        : 0,
    };
  },

  toJSON(message: AdmissionRule): unknown {
    const obj: any = {};
    if (message.evaluationMode !== 0) {
      obj.evaluationMode = admissionRule_EvaluationModeToJSON(message.evaluationMode);
    }
    if (message.requireAttestationsBy?.length) {
      obj.requireAttestationsBy = message.requireAttestationsBy;
    }
    if (message.enforcementMode !== 0) {
      obj.enforcementMode = admissionRule_EnforcementModeToJSON(message.enforcementMode);
    }
    return obj;
  },

  create(base?: DeepPartial<AdmissionRule>): AdmissionRule {
    return AdmissionRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdmissionRule>): AdmissionRule {
    const message = createBaseAdmissionRule();
    message.evaluationMode = object.evaluationMode ?? 0;
    message.requireAttestationsBy = object.requireAttestationsBy?.map((e) => e) || [];
    message.enforcementMode = object.enforcementMode ?? 0;
    return message;
  },
};

function createBaseAttestor(): Attestor {
  return { name: "", description: "", userOwnedGrafeasNote: undefined, updateTime: undefined };
}

export const Attestor: MessageFns<Attestor> = {
  encode(message: Attestor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.userOwnedGrafeasNote !== undefined) {
      UserOwnedGrafeasNote.encode(message.userOwnedGrafeasNote, writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attestor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userOwnedGrafeasNote = UserOwnedGrafeasNote.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attestor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      userOwnedGrafeasNote: isSet(object.userOwnedGrafeasNote)
        ? UserOwnedGrafeasNote.fromJSON(object.userOwnedGrafeasNote)
        : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Attestor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.userOwnedGrafeasNote !== undefined) {
      obj.userOwnedGrafeasNote = UserOwnedGrafeasNote.toJSON(message.userOwnedGrafeasNote);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Attestor>): Attestor {
    return Attestor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attestor>): Attestor {
    const message = createBaseAttestor();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.userOwnedGrafeasNote = (object.userOwnedGrafeasNote !== undefined && object.userOwnedGrafeasNote !== null)
      ? UserOwnedGrafeasNote.fromPartial(object.userOwnedGrafeasNote)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseUserOwnedGrafeasNote(): UserOwnedGrafeasNote {
  return { noteReference: "", publicKeys: [], delegationServiceAccountEmail: "" };
}

export const UserOwnedGrafeasNote: MessageFns<UserOwnedGrafeasNote> = {
  encode(message: UserOwnedGrafeasNote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.noteReference !== "") {
      writer.uint32(10).string(message.noteReference);
    }
    for (const v of message.publicKeys) {
      AttestorPublicKey.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.delegationServiceAccountEmail !== "") {
      writer.uint32(26).string(message.delegationServiceAccountEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserOwnedGrafeasNote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOwnedGrafeasNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.noteReference = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKeys.push(AttestorPublicKey.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.delegationServiceAccountEmail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOwnedGrafeasNote {
    return {
      noteReference: isSet(object.noteReference) ? globalThis.String(object.noteReference) : "",
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => AttestorPublicKey.fromJSON(e))
        : [],
      delegationServiceAccountEmail: isSet(object.delegationServiceAccountEmail)
        ? globalThis.String(object.delegationServiceAccountEmail)
        : "",
    };
  },

  toJSON(message: UserOwnedGrafeasNote): unknown {
    const obj: any = {};
    if (message.noteReference !== "") {
      obj.noteReference = message.noteReference;
    }
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys.map((e) => AttestorPublicKey.toJSON(e));
    }
    if (message.delegationServiceAccountEmail !== "") {
      obj.delegationServiceAccountEmail = message.delegationServiceAccountEmail;
    }
    return obj;
  },

  create(base?: DeepPartial<UserOwnedGrafeasNote>): UserOwnedGrafeasNote {
    return UserOwnedGrafeasNote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserOwnedGrafeasNote>): UserOwnedGrafeasNote {
    const message = createBaseUserOwnedGrafeasNote();
    message.noteReference = object.noteReference ?? "";
    message.publicKeys = object.publicKeys?.map((e) => AttestorPublicKey.fromPartial(e)) || [];
    message.delegationServiceAccountEmail = object.delegationServiceAccountEmail ?? "";
    return message;
  },
};

function createBasePkixPublicKey(): PkixPublicKey {
  return { publicKeyPem: "", signatureAlgorithm: 0 };
}

export const PkixPublicKey: MessageFns<PkixPublicKey> = {
  encode(message: PkixPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKeyPem !== "") {
      writer.uint32(10).string(message.publicKeyPem);
    }
    if (message.signatureAlgorithm !== 0) {
      writer.uint32(16).int32(message.signatureAlgorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PkixPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePkixPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKeyPem = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.signatureAlgorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PkixPublicKey {
    return {
      publicKeyPem: isSet(object.publicKeyPem) ? globalThis.String(object.publicKeyPem) : "",
      signatureAlgorithm: isSet(object.signatureAlgorithm)
        ? pkixPublicKey_SignatureAlgorithmFromJSON(object.signatureAlgorithm)
        : 0,
    };
  },

  toJSON(message: PkixPublicKey): unknown {
    const obj: any = {};
    if (message.publicKeyPem !== "") {
      obj.publicKeyPem = message.publicKeyPem;
    }
    if (message.signatureAlgorithm !== 0) {
      obj.signatureAlgorithm = pkixPublicKey_SignatureAlgorithmToJSON(message.signatureAlgorithm);
    }
    return obj;
  },

  create(base?: DeepPartial<PkixPublicKey>): PkixPublicKey {
    return PkixPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PkixPublicKey>): PkixPublicKey {
    const message = createBasePkixPublicKey();
    message.publicKeyPem = object.publicKeyPem ?? "";
    message.signatureAlgorithm = object.signatureAlgorithm ?? 0;
    return message;
  },
};

function createBaseAttestorPublicKey(): AttestorPublicKey {
  return { comment: "", id: "", asciiArmoredPgpPublicKey: undefined, pkixPublicKey: undefined };
}

export const AttestorPublicKey: MessageFns<AttestorPublicKey> = {
  encode(message: AttestorPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.comment !== "") {
      writer.uint32(10).string(message.comment);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.asciiArmoredPgpPublicKey !== undefined) {
      writer.uint32(26).string(message.asciiArmoredPgpPublicKey);
    }
    if (message.pkixPublicKey !== undefined) {
      PkixPublicKey.encode(message.pkixPublicKey, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestorPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestorPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asciiArmoredPgpPublicKey = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pkixPublicKey = PkixPublicKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestorPublicKey {
    return {
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      asciiArmoredPgpPublicKey: isSet(object.asciiArmoredPgpPublicKey)
        ? globalThis.String(object.asciiArmoredPgpPublicKey)
        : undefined,
      pkixPublicKey: isSet(object.pkixPublicKey) ? PkixPublicKey.fromJSON(object.pkixPublicKey) : undefined,
    };
  },

  toJSON(message: AttestorPublicKey): unknown {
    const obj: any = {};
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.asciiArmoredPgpPublicKey !== undefined) {
      obj.asciiArmoredPgpPublicKey = message.asciiArmoredPgpPublicKey;
    }
    if (message.pkixPublicKey !== undefined) {
      obj.pkixPublicKey = PkixPublicKey.toJSON(message.pkixPublicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AttestorPublicKey>): AttestorPublicKey {
    return AttestorPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttestorPublicKey>): AttestorPublicKey {
    const message = createBaseAttestorPublicKey();
    message.comment = object.comment ?? "";
    message.id = object.id ?? "";
    message.asciiArmoredPgpPublicKey = object.asciiArmoredPgpPublicKey ?? undefined;
    message.pkixPublicKey = (object.pkixPublicKey !== undefined && object.pkixPublicKey !== null)
      ? PkixPublicKey.fromPartial(object.pkixPublicKey)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
