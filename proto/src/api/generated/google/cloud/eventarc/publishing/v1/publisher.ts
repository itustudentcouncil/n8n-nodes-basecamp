// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/eventarc/publishing/v1/publisher.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Any } from "../../../../protobuf/any.js";

export const protobufPackage = "google.cloud.eventarc.publishing.v1";

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The request message for the PublishChannelConnectionEvents method. */
export interface PublishChannelConnectionEventsRequest {
  /**
   * The channel_connection that the events are published from. For example:
   * `projects/{partner_project_id}/locations/{location}/channelConnections/{channel_connection_id}`.
   */
  channelConnection: string;
  /**
   * The CloudEvents v1.0 events to publish. No other types are allowed.
   * If this field is set, then the `text_events` fields must not be set.
   */
  events: Any[];
  /**
   * The text representation of events to publish.
   * CloudEvent v1.0 in JSON format is the only allowed type. Refer to
   * https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/formats/json-format.md
   * for specification.
   * If this field is set, then the `events` fields must not be set.
   */
  textEvents: string[];
}

/** The response message for the PublishChannelConnectionEvents method. */
export interface PublishChannelConnectionEventsResponse {
}

/** The request message for the PublishEvents method. */
export interface PublishEventsRequest {
  /**
   * The full name of the channel to publish to. For example:
   * `projects/{project}/locations/{location}/channels/{channel-id}`.
   */
  channel: string;
  /**
   * The CloudEvents v1.0 events to publish. No other types are allowed.
   * If this field is set, then the `text_events` fields must not be set.
   */
  events: Any[];
  /**
   * The text representation of events to publish.
   * CloudEvent v1.0 in JSON format is the only allowed type. Refer to
   * https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/formats/json-format.md
   * for specification.
   * If this field is set, then the `events` fields must not be set.
   */
  textEvents: string[];
}

/** The response message for the PublishEvents method. */
export interface PublishEventsResponse {
}

function createBasePublishChannelConnectionEventsRequest(): PublishChannelConnectionEventsRequest {
  return { channelConnection: "", events: [], textEvents: [] };
}

export const PublishChannelConnectionEventsRequest: MessageFns<PublishChannelConnectionEventsRequest> = {
  encode(message: PublishChannelConnectionEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelConnection !== "") {
      writer.uint32(10).string(message.channelConnection);
    }
    for (const v of message.events) {
      Any.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.textEvents) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishChannelConnectionEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishChannelConnectionEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelConnection = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(Any.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textEvents.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishChannelConnectionEventsRequest {
    return {
      channelConnection: isSet(object.channelConnection) ? globalThis.String(object.channelConnection) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Any.fromJSON(e)) : [],
      textEvents: globalThis.Array.isArray(object?.textEvents)
        ? object.textEvents.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PublishChannelConnectionEventsRequest): unknown {
    const obj: any = {};
    if (message.channelConnection !== "") {
      obj.channelConnection = message.channelConnection;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Any.toJSON(e));
    }
    if (message.textEvents?.length) {
      obj.textEvents = message.textEvents;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishChannelConnectionEventsRequest>): PublishChannelConnectionEventsRequest {
    return PublishChannelConnectionEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishChannelConnectionEventsRequest>): PublishChannelConnectionEventsRequest {
    const message = createBasePublishChannelConnectionEventsRequest();
    message.channelConnection = object.channelConnection ?? "";
    message.events = object.events?.map((e) => Any.fromPartial(e)) || [];
    message.textEvents = object.textEvents?.map((e) => e) || [];
    return message;
  },
};

function createBasePublishChannelConnectionEventsResponse(): PublishChannelConnectionEventsResponse {
  return {};
}

export const PublishChannelConnectionEventsResponse: MessageFns<PublishChannelConnectionEventsResponse> = {
  encode(_: PublishChannelConnectionEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishChannelConnectionEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishChannelConnectionEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishChannelConnectionEventsResponse {
    return {};
  },

  toJSON(_: PublishChannelConnectionEventsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PublishChannelConnectionEventsResponse>): PublishChannelConnectionEventsResponse {
    return PublishChannelConnectionEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PublishChannelConnectionEventsResponse>): PublishChannelConnectionEventsResponse {
    const message = createBasePublishChannelConnectionEventsResponse();
    return message;
  },
};

function createBasePublishEventsRequest(): PublishEventsRequest {
  return { channel: "", events: [], textEvents: [] };
}

export const PublishEventsRequest: MessageFns<PublishEventsRequest> = {
  encode(message: PublishEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== "") {
      writer.uint32(10).string(message.channel);
    }
    for (const v of message.events) {
      Any.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.textEvents) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.events.push(Any.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.textEvents.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventsRequest {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => Any.fromJSON(e)) : [],
      textEvents: globalThis.Array.isArray(object?.textEvents)
        ? object.textEvents.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PublishEventsRequest): unknown {
    const obj: any = {};
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.events?.length) {
      obj.events = message.events.map((e) => Any.toJSON(e));
    }
    if (message.textEvents?.length) {
      obj.textEvents = message.textEvents;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventsRequest>): PublishEventsRequest {
    return PublishEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventsRequest>): PublishEventsRequest {
    const message = createBasePublishEventsRequest();
    message.channel = object.channel ?? "";
    message.events = object.events?.map((e) => Any.fromPartial(e)) || [];
    message.textEvents = object.textEvents?.map((e) => e) || [];
    return message;
  },
};

function createBasePublishEventsResponse(): PublishEventsResponse {
  return {};
}

export const PublishEventsResponse: MessageFns<PublishEventsResponse> = {
  encode(_: PublishEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PublishEventsResponse {
    return {};
  },

  toJSON(_: PublishEventsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PublishEventsResponse>): PublishEventsResponse {
    return PublishEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PublishEventsResponse>): PublishEventsResponse {
    const message = createBasePublishEventsResponse();
    return message;
  },
};

/**
 * Eventarc processes events generated by an event provider and delivers them to
 * a subscriber.
 *
 * An event provider is a software-as-a-service (SaaS) system or
 * product that can generate and deliver events through Eventarc.
 *
 * A third-party event provider is an event provider from outside of Google.
 *
 * A partner is a third-party event provider that is integrated with Eventarc.
 *
 * A subscriber is a GCP customer interested in receiving events.
 *
 * Channel is a first-class Eventarc resource that is created and managed
 * by the subscriber in their GCP project. A Channel represents a subscriber's
 * intent to receive events from an event provider. A Channel is associated with
 * exactly one event provider.
 *
 * ChannelConnection is a first-class Eventarc resource that
 * is created and managed by the partner in their GCP project. A
 * ChannelConnection represents a connection between a partner and a
 * subscriber's Channel. A ChannelConnection has a one-to-one mapping with a
 * Channel.
 *
 * Publisher allows an event provider to publish events to Eventarc.
 */
export type PublisherDefinition = typeof PublisherDefinition;
export const PublisherDefinition = {
  name: "Publisher",
  fullName: "google.cloud.eventarc.publishing.v1.Publisher",
  methods: {
    /** Publish events to a ChannelConnection in a partner's project. */
    publishChannelConnectionEvents: {
      name: "PublishChannelConnectionEvents",
      requestType: PublishChannelConnectionEventsRequest,
      requestStream: false,
      responseType: PublishChannelConnectionEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              87,
              58,
              1,
              42,
              34,
              82,
              47,
              118,
              49,
              47,
              123,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              112,
              117,
              98,
              108,
              105,
              115,
              104,
              69,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Publish events to a subscriber's channel. */
    publishEvents: {
      name: "PublishEvents",
      requestType: PublishEventsRequest,
      requestStream: false,
      responseType: PublishEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              112,
              117,
              98,
              108,
              105,
              115,
              104,
              69,
              118,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface PublisherServiceImplementation<CallContextExt = {}> {
  /** Publish events to a ChannelConnection in a partner's project. */
  publishChannelConnectionEvents(
    request: PublishChannelConnectionEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PublishChannelConnectionEventsResponse>>;
  /** Publish events to a subscriber's channel. */
  publishEvents(
    request: PublishEventsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PublishEventsResponse>>;
}

export interface PublisherClient<CallOptionsExt = {}> {
  /** Publish events to a ChannelConnection in a partner's project. */
  publishChannelConnectionEvents(
    request: DeepPartial<PublishChannelConnectionEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PublishChannelConnectionEventsResponse>;
  /** Publish events to a subscriber's channel. */
  publishEvents(
    request: DeepPartial<PublishEventsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PublishEventsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
