// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/eventarc/v1/trigger.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Code, codeFromJSON, codeToJSON } from "../../../rpc/code.js";

export const protobufPackage = "google.cloud.eventarc.v1";

/** A representation of the trigger resource. */
export interface Trigger {
  /**
   * Required. The resource name of the trigger. Must be unique within the location of the
   * project and must be in
   * `projects/{project}/locations/{location}/triggers/{trigger}` format.
   */
  name: string;
  /**
   * Output only. Server-assigned unique identifier for the trigger. The value is a UUID4
   * string and guaranteed to remain unchanged until the resource is deleted.
   */
  uid: string;
  /** Output only. The creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last-modified time. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. Unordered list. The list of filters that applies to event attributes. Only events that
   * match all the provided filters are sent to the destination.
   */
  eventFilters: EventFilter[];
  /**
   * Optional. The IAM service account email associated with the trigger. The
   * service account represents the identity of the trigger.
   *
   * The principal who calls this API must have the `iam.serviceAccounts.actAs`
   * permission in the service account. See
   * https://cloud.google.com/iam/docs/understanding-service-accounts?hl=en#sa_common
   * for more information.
   *
   * For Cloud Run destinations, this service account is used to generate
   * identity tokens when invoking the service. See
   * https://cloud.google.com/run/docs/triggering/pubsub-push#create-service-account
   * for information on how to invoke authenticated Cloud Run services.
   * To create Audit Log triggers, the service account should also
   * have the `roles/eventarc.eventReceiver` IAM role.
   */
  serviceAccount: string;
  /** Required. Destination specifies where the events should be sent to. */
  destination:
    | Destination
    | undefined;
  /**
   * Optional. To deliver messages, Eventarc might use other GCP
   * products as a transport intermediary. This field contains a reference to
   * that transport intermediary. This information can be used for debugging
   * purposes.
   */
  transport:
    | Transport
    | undefined;
  /** Optional. User labels attached to the triggers that can be used to group resources. */
  labels: { [key: string]: string };
  /**
   * Optional. The name of the channel associated with the trigger in
   * `projects/{project}/locations/{location}/channels/{channel}` format.
   * You must provide a channel to receive events from Eventarc SaaS partners.
   */
  channel: string;
  /** Output only. The reason(s) why a trigger is in FAILED state. */
  conditions: { [key: string]: StateCondition };
  /**
   * Output only. This checksum is computed by the server based on the value of other
   * fields, and might be sent only on create requests to ensure that the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

export interface Trigger_LabelsEntry {
  key: string;
  value: string;
}

export interface Trigger_ConditionsEntry {
  key: string;
  value: StateCondition | undefined;
}

/** Filters events based on exact matches on the CloudEvents attributes. */
export interface EventFilter {
  /**
   * Required. The name of a CloudEvents attribute. Currently, only a subset of attributes
   * are supported for filtering.
   *
   * All triggers MUST provide a filter for the 'type' attribute.
   */
  attribute: string;
  /** Required. The value for the attribute. */
  value: string;
  /**
   * Optional. The operator used for matching the events with the value of the
   * filter. If not specified, only events that have an exact key-value pair
   * specified in the filter are matched. The only allowed value is
   * `match-path-pattern`.
   */
  operator: string;
}

/** A condition that is part of the trigger state computation. */
export interface StateCondition {
  /** The canonical code of the condition. */
  code: Code;
  /** Human-readable message. */
  message: string;
}

/** Represents a target of an invocation over HTTP. */
export interface Destination {
  /**
   * Cloud Run fully-managed resource that receives the events. The resource
   * should be in the same project as the trigger.
   */
  cloudRun?:
    | CloudRun
    | undefined;
  /**
   * The Cloud Function resource name. Only Cloud Functions V2 is supported.
   * Format: `projects/{project}/locations/{location}/functions/{function}`
   */
  cloudFunction?:
    | string
    | undefined;
  /**
   * A GKE service capable of receiving events. The service should be running
   * in the same project as the trigger.
   */
  gke?:
    | GKE
    | undefined;
  /**
   * The resource name of the Workflow whose Executions are triggered by
   * the events. The Workflow resource should be deployed in the same project
   * as the trigger.
   * Format: `projects/{project}/locations/{location}/workflows/{workflow}`
   */
  workflow?: string | undefined;
}

/**
 * Represents the transport intermediaries created for the trigger to
 * deliver events.
 */
export interface Transport {
  /**
   * The Pub/Sub topic and subscription used by Eventarc as a transport
   * intermediary.
   */
  pubsub?: Pubsub | undefined;
}

/** Represents a Cloud Run destination. */
export interface CloudRun {
  /**
   * Required. The name of the Cloud Run service being addressed. See
   * https://cloud.google.com/run/docs/reference/rest/v1/namespaces.services.
   *
   * Only services located in the same project as the trigger object
   * can be addressed.
   */
  service: string;
  /**
   * Optional. The relative path on the Cloud Run service the events should be sent to.
   *
   * The value must conform to the definition of a URI path segment (section 3.3
   * of RFC2396). Examples: "/route", "route", "route/subroute".
   */
  path: string;
  /** Required. The region the Cloud Run service is deployed in. */
  region: string;
}

/** Represents a GKE destination. */
export interface GKE {
  /**
   * Required. The name of the cluster the GKE service is running in. The cluster must be
   * running in the same project as the trigger being created.
   */
  cluster: string;
  /**
   * Required. The name of the Google Compute Engine in which the cluster resides, which
   * can either be compute zone (for example, us-central1-a) for the zonal
   * clusters or region (for example, us-central1) for regional clusters.
   */
  location: string;
  /** Required. The namespace the GKE service is running in. */
  namespace: string;
  /** Required. Name of the GKE service. */
  service: string;
  /**
   * Optional. The relative path on the GKE service the events should be sent to.
   *
   * The value must conform to the definition of a URI path segment (section 3.3
   * of RFC2396). Examples: "/route", "route", "route/subroute".
   */
  path: string;
}

/** Represents a Pub/Sub transport. */
export interface Pubsub {
  /**
   * Optional. The name of the Pub/Sub topic created and managed by Eventarc as
   * a transport for the event delivery. Format:
   * `projects/{PROJECT_ID}/topics/{TOPIC_NAME}`.
   *
   * You can set an existing topic for triggers of the type
   * `google.cloud.pubsub.topic.v1.messagePublished`. The topic you provide
   * here is not deleted by Eventarc at trigger deletion.
   */
  topic: string;
  /**
   * Output only. The name of the Pub/Sub subscription created and managed by Eventarc
   * as a transport for the event delivery. Format:
   * `projects/{PROJECT_ID}/subscriptions/{SUBSCRIPTION_NAME}`.
   */
  subscription: string;
}

function createBaseTrigger(): Trigger {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    eventFilters: [],
    serviceAccount: "",
    destination: undefined,
    transport: undefined,
    labels: {},
    channel: "",
    conditions: {},
    etag: "",
  };
}

export const Trigger: MessageFns<Trigger> = {
  encode(message: Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    for (const v of message.eventFilters) {
      EventFilter.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.serviceAccount !== "") {
      writer.uint32(74).string(message.serviceAccount);
    }
    if (message.destination !== undefined) {
      Destination.encode(message.destination, writer.uint32(82).fork()).join();
    }
    if (message.transport !== undefined) {
      Transport.encode(message.transport, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Trigger_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.channel !== "") {
      writer.uint32(106).string(message.channel);
    }
    Object.entries(message.conditions).forEach(([key, value]) => {
      Trigger_ConditionsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(794).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.eventFilters.push(EventFilter.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.destination = Destination.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transport = Transport.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Trigger_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.channel = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = Trigger_ConditionsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.conditions[entry15.key] = entry15.value;
          }
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      eventFilters: globalThis.Array.isArray(object?.eventFilters)
        ? object.eventFilters.map((e: any) => EventFilter.fromJSON(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      destination: isSet(object.destination) ? Destination.fromJSON(object.destination) : undefined,
      transport: isSet(object.transport) ? Transport.fromJSON(object.transport) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      conditions: isObject(object.conditions)
        ? Object.entries(object.conditions).reduce<{ [key: string]: StateCondition }>((acc, [key, value]) => {
          acc[key] = StateCondition.fromJSON(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.eventFilters?.length) {
      obj.eventFilters = message.eventFilters.map((e) => EventFilter.toJSON(e));
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.destination !== undefined) {
      obj.destination = Destination.toJSON(message.destination);
    }
    if (message.transport !== undefined) {
      obj.transport = Transport.toJSON(message.transport);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.conditions) {
      const entries = Object.entries(message.conditions);
      if (entries.length > 0) {
        obj.conditions = {};
        entries.forEach(([k, v]) => {
          obj.conditions[k] = StateCondition.toJSON(v);
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Trigger>): Trigger {
    return Trigger.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trigger>): Trigger {
    const message = createBaseTrigger();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.eventFilters = object.eventFilters?.map((e) => EventFilter.fromPartial(e)) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? Destination.fromPartial(object.destination)
      : undefined;
    message.transport = (object.transport !== undefined && object.transport !== null)
      ? Transport.fromPartial(object.transport)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.channel = object.channel ?? "";
    message.conditions = Object.entries(object.conditions ?? {}).reduce<{ [key: string]: StateCondition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = StateCondition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseTrigger_LabelsEntry(): Trigger_LabelsEntry {
  return { key: "", value: "" };
}

export const Trigger_LabelsEntry: MessageFns<Trigger_LabelsEntry> = {
  encode(message: Trigger_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Trigger_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Trigger_LabelsEntry>): Trigger_LabelsEntry {
    return Trigger_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trigger_LabelsEntry>): Trigger_LabelsEntry {
    const message = createBaseTrigger_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrigger_ConditionsEntry(): Trigger_ConditionsEntry {
  return { key: "", value: undefined };
}

export const Trigger_ConditionsEntry: MessageFns<Trigger_ConditionsEntry> = {
  encode(message: Trigger_ConditionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      StateCondition.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger_ConditionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger_ConditionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = StateCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger_ConditionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? StateCondition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Trigger_ConditionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = StateCondition.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Trigger_ConditionsEntry>): Trigger_ConditionsEntry {
    return Trigger_ConditionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trigger_ConditionsEntry>): Trigger_ConditionsEntry {
    const message = createBaseTrigger_ConditionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? StateCondition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEventFilter(): EventFilter {
  return { attribute: "", value: "", operator: "" };
}

export const EventFilter: MessageFns<EventFilter> = {
  encode(message: EventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.operator !== "") {
      writer.uint32(26).string(message.operator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFilter {
    return {
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: EventFilter): unknown {
    const obj: any = {};
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create(base?: DeepPartial<EventFilter>): EventFilter {
    return EventFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventFilter>): EventFilter {
    const message = createBaseEventFilter();
    message.attribute = object.attribute ?? "";
    message.value = object.value ?? "";
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseStateCondition(): StateCondition {
  return { code: 0, message: "" };
}

export const StateCondition: MessageFns<StateCondition> = {
  encode(message: StateCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StateCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateCondition {
    return {
      code: isSet(object.code) ? codeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: StateCondition): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = codeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<StateCondition>): StateCondition {
    return StateCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateCondition>): StateCondition {
    const message = createBaseStateCondition();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDestination(): Destination {
  return { cloudRun: undefined, cloudFunction: undefined, gke: undefined, workflow: undefined };
}

export const Destination: MessageFns<Destination> = {
  encode(message: Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudRun !== undefined) {
      CloudRun.encode(message.cloudRun, writer.uint32(10).fork()).join();
    }
    if (message.cloudFunction !== undefined) {
      writer.uint32(18).string(message.cloudFunction);
    }
    if (message.gke !== undefined) {
      GKE.encode(message.gke, writer.uint32(26).fork()).join();
    }
    if (message.workflow !== undefined) {
      writer.uint32(34).string(message.workflow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudRun = CloudRun.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudFunction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gke = GKE.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workflow = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Destination {
    return {
      cloudRun: isSet(object.cloudRun) ? CloudRun.fromJSON(object.cloudRun) : undefined,
      cloudFunction: isSet(object.cloudFunction) ? globalThis.String(object.cloudFunction) : undefined,
      gke: isSet(object.gke) ? GKE.fromJSON(object.gke) : undefined,
      workflow: isSet(object.workflow) ? globalThis.String(object.workflow) : undefined,
    };
  },

  toJSON(message: Destination): unknown {
    const obj: any = {};
    if (message.cloudRun !== undefined) {
      obj.cloudRun = CloudRun.toJSON(message.cloudRun);
    }
    if (message.cloudFunction !== undefined) {
      obj.cloudFunction = message.cloudFunction;
    }
    if (message.gke !== undefined) {
      obj.gke = GKE.toJSON(message.gke);
    }
    if (message.workflow !== undefined) {
      obj.workflow = message.workflow;
    }
    return obj;
  },

  create(base?: DeepPartial<Destination>): Destination {
    return Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Destination>): Destination {
    const message = createBaseDestination();
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? CloudRun.fromPartial(object.cloudRun)
      : undefined;
    message.cloudFunction = object.cloudFunction ?? undefined;
    message.gke = (object.gke !== undefined && object.gke !== null) ? GKE.fromPartial(object.gke) : undefined;
    message.workflow = object.workflow ?? undefined;
    return message;
  },
};

function createBaseTransport(): Transport {
  return { pubsub: undefined };
}

export const Transport: MessageFns<Transport> = {
  encode(message: Transport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsub !== undefined) {
      Pubsub.encode(message.pubsub, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Transport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsub = Pubsub.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transport {
    return { pubsub: isSet(object.pubsub) ? Pubsub.fromJSON(object.pubsub) : undefined };
  },

  toJSON(message: Transport): unknown {
    const obj: any = {};
    if (message.pubsub !== undefined) {
      obj.pubsub = Pubsub.toJSON(message.pubsub);
    }
    return obj;
  },

  create(base?: DeepPartial<Transport>): Transport {
    return Transport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transport>): Transport {
    const message = createBaseTransport();
    message.pubsub = (object.pubsub !== undefined && object.pubsub !== null)
      ? Pubsub.fromPartial(object.pubsub)
      : undefined;
    return message;
  },
};

function createBaseCloudRun(): CloudRun {
  return { service: "", path: "", region: "" };
}

export const CloudRun: MessageFns<CloudRun> = {
  encode(message: CloudRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.region !== "") {
      writer.uint32(26).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRun {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
    };
  },

  toJSON(message: CloudRun): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRun>): CloudRun {
    return CloudRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRun>): CloudRun {
    const message = createBaseCloudRun();
    message.service = object.service ?? "";
    message.path = object.path ?? "";
    message.region = object.region ?? "";
    return message;
  },
};

function createBaseGKE(): GKE {
  return { cluster: "", location: "", namespace: "", service: "", path: "" };
}

export const GKE: MessageFns<GKE> = {
  encode(message: GKE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.namespace !== "") {
      writer.uint32(26).string(message.namespace);
    }
    if (message.service !== "") {
      writer.uint32(34).string(message.service);
    }
    if (message.path !== "") {
      writer.uint32(42).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GKE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGKE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.service = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GKE {
    return {
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: GKE): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<GKE>): GKE {
    return GKE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GKE>): GKE {
    const message = createBaseGKE();
    message.cluster = object.cluster ?? "";
    message.location = object.location ?? "";
    message.namespace = object.namespace ?? "";
    message.service = object.service ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBasePubsub(): Pubsub {
  return { topic: "", subscription: "" };
}

export const Pubsub: MessageFns<Pubsub> = {
  encode(message: Pubsub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.subscription !== "") {
      writer.uint32(18).string(message.subscription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pubsub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subscription = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pubsub {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
    };
  },

  toJSON(message: Pubsub): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    return obj;
  },

  create(base?: DeepPartial<Pubsub>): Pubsub {
    return Pubsub.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pubsub>): Pubsub {
    const message = createBasePubsub();
    message.topic = object.topic ?? "";
    message.subscription = object.subscription ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
