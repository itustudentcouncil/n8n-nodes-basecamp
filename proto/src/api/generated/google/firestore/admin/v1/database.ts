// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/firestore/admin/v1/database.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.firestore.admin.v1";

/** A Cloud Firestore Database. */
export interface Database {
  /**
   * The resource name of the Database.
   * Format: `projects/{project}/databases/{database}`
   */
  name: string;
  /** Output only. The system-generated UUID4 for this Database. */
  uid: string;
  /**
   * Output only. The timestamp at which this database was created. Databases
   * created before 2016 do not populate create_time.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The timestamp at which this database was most recently
   * updated. Note this only includes updates to the database resource and not
   * data contained by the database.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The timestamp at which this database was deleted. Only set if
   * the database has been deleted.
   */
  deleteTime:
    | Date
    | undefined;
  /**
   * The location of the database. Available locations are listed at
   * https://cloud.google.com/firestore/docs/locations.
   */
  locationId: string;
  /**
   * The type of the database.
   * See https://cloud.google.com/datastore/docs/firestore-or-datastore for
   * information about how to choose.
   */
  type: Database_DatabaseType;
  /** The concurrency control mode to use for this database. */
  concurrencyMode: Database_ConcurrencyMode;
  /**
   * Output only. The period during which past versions of data are retained in
   * the database.
   *
   * Any [read][google.firestore.v1.GetDocumentRequest.read_time]
   * or [query][google.firestore.v1.ListDocumentsRequest.read_time] can specify
   * a `read_time` within this window, and will read the state of the database
   * at that time.
   *
   * If the PITR feature is enabled, the retention period is 7 days. Otherwise,
   * the retention period is 1 hour.
   */
  versionRetentionPeriod:
    | Duration
    | undefined;
  /**
   * Output only. The earliest timestamp at which older versions of the data can
   * be read from the database. See [version_retention_period] above; this field
   * is populated with `now - version_retention_period`.
   *
   * This value is continuously updated, and becomes stale the moment it is
   * queried. If you are using this value to recover data, make sure to account
   * for the time from the moment when the value is queried to the moment when
   * you initiate the recovery.
   */
  earliestVersionTime:
    | Date
    | undefined;
  /** Whether to enable the PITR feature on this database. */
  pointInTimeRecoveryEnablement: Database_PointInTimeRecoveryEnablement;
  /** The App Engine integration mode to use for this database. */
  appEngineIntegrationMode: Database_AppEngineIntegrationMode;
  /**
   * Output only. The key_prefix for this database. This key_prefix is used, in
   * combination with the project ID ("<key prefix>~<project id>") to construct
   * the application ID that is returned from the Cloud Datastore APIs in Google
   * App Engine first generation runtimes.
   *
   * This value may be empty in which case the appid to use for URL-encoded keys
   * is the project_id (eg: foo instead of v~foo).
   */
  keyPrefix: string;
  /** State of delete protection for the database. */
  deleteProtectionState: Database_DeleteProtectionState;
  /** Optional. Presence indicates CMEK is enabled for this database. */
  cmekConfig:
    | Database_CmekConfig
    | undefined;
  /**
   * Output only. The database resource's prior database ID. This field is only
   * populated for deleted databases.
   */
  previousId: string;
  /** Output only. Information about the provenance of this database. */
  sourceInfo:
    | Database_SourceInfo
    | undefined;
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
}

/**
 * The type of the database.
 * See https://cloud.google.com/datastore/docs/firestore-or-datastore for
 * information about how to choose.
 *
 * Mode changes are only allowed if the database is empty.
 */
export enum Database_DatabaseType {
  /** DATABASE_TYPE_UNSPECIFIED - Not used. */
  DATABASE_TYPE_UNSPECIFIED = 0,
  /** FIRESTORE_NATIVE - Firestore Native Mode */
  FIRESTORE_NATIVE = 1,
  /** DATASTORE_MODE - Firestore in Datastore Mode. */
  DATASTORE_MODE = 2,
  UNRECOGNIZED = -1,
}

export function database_DatabaseTypeFromJSON(object: any): Database_DatabaseType {
  switch (object) {
    case 0:
    case "DATABASE_TYPE_UNSPECIFIED":
      return Database_DatabaseType.DATABASE_TYPE_UNSPECIFIED;
    case 1:
    case "FIRESTORE_NATIVE":
      return Database_DatabaseType.FIRESTORE_NATIVE;
    case 2:
    case "DATASTORE_MODE":
      return Database_DatabaseType.DATASTORE_MODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Database_DatabaseType.UNRECOGNIZED;
  }
}

export function database_DatabaseTypeToJSON(object: Database_DatabaseType): string {
  switch (object) {
    case Database_DatabaseType.DATABASE_TYPE_UNSPECIFIED:
      return "DATABASE_TYPE_UNSPECIFIED";
    case Database_DatabaseType.FIRESTORE_NATIVE:
      return "FIRESTORE_NATIVE";
    case Database_DatabaseType.DATASTORE_MODE:
      return "DATASTORE_MODE";
    case Database_DatabaseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of concurrency control mode for transactions. */
export enum Database_ConcurrencyMode {
  /** CONCURRENCY_MODE_UNSPECIFIED - Not used. */
  CONCURRENCY_MODE_UNSPECIFIED = 0,
  /**
   * OPTIMISTIC - Use optimistic concurrency control by default. This mode is available
   * for Cloud Firestore databases.
   */
  OPTIMISTIC = 1,
  /**
   * PESSIMISTIC - Use pessimistic concurrency control by default. This mode is available
   * for Cloud Firestore databases.
   *
   * This is the default setting for Cloud Firestore.
   */
  PESSIMISTIC = 2,
  /**
   * OPTIMISTIC_WITH_ENTITY_GROUPS - Use optimistic concurrency control with entity groups by default.
   *
   * This is the only available mode for Cloud Datastore.
   *
   * This mode is also available for Cloud Firestore with Datastore Mode but
   * is not recommended.
   */
  OPTIMISTIC_WITH_ENTITY_GROUPS = 3,
  UNRECOGNIZED = -1,
}

export function database_ConcurrencyModeFromJSON(object: any): Database_ConcurrencyMode {
  switch (object) {
    case 0:
    case "CONCURRENCY_MODE_UNSPECIFIED":
      return Database_ConcurrencyMode.CONCURRENCY_MODE_UNSPECIFIED;
    case 1:
    case "OPTIMISTIC":
      return Database_ConcurrencyMode.OPTIMISTIC;
    case 2:
    case "PESSIMISTIC":
      return Database_ConcurrencyMode.PESSIMISTIC;
    case 3:
    case "OPTIMISTIC_WITH_ENTITY_GROUPS":
      return Database_ConcurrencyMode.OPTIMISTIC_WITH_ENTITY_GROUPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Database_ConcurrencyMode.UNRECOGNIZED;
  }
}

export function database_ConcurrencyModeToJSON(object: Database_ConcurrencyMode): string {
  switch (object) {
    case Database_ConcurrencyMode.CONCURRENCY_MODE_UNSPECIFIED:
      return "CONCURRENCY_MODE_UNSPECIFIED";
    case Database_ConcurrencyMode.OPTIMISTIC:
      return "OPTIMISTIC";
    case Database_ConcurrencyMode.PESSIMISTIC:
      return "PESSIMISTIC";
    case Database_ConcurrencyMode.OPTIMISTIC_WITH_ENTITY_GROUPS:
      return "OPTIMISTIC_WITH_ENTITY_GROUPS";
    case Database_ConcurrencyMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Point In Time Recovery feature enablement. */
export enum Database_PointInTimeRecoveryEnablement {
  /** POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED - Not used. */
  POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED = 0,
  /**
   * POINT_IN_TIME_RECOVERY_ENABLED - Reads are supported on selected versions of the data from within the past
   * 7 days:
   *
   * * Reads against any timestamp within the past hour
   * * Reads against 1-minute snapshots beyond 1 hour and within 7 days
   *
   * `version_retention_period` and `earliest_version_time` can be
   * used to determine the supported versions.
   */
  POINT_IN_TIME_RECOVERY_ENABLED = 1,
  /**
   * POINT_IN_TIME_RECOVERY_DISABLED - Reads are supported on any version of the data from within the past 1
   * hour.
   */
  POINT_IN_TIME_RECOVERY_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function database_PointInTimeRecoveryEnablementFromJSON(object: any): Database_PointInTimeRecoveryEnablement {
  switch (object) {
    case 0:
    case "POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED":
      return Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED;
    case 1:
    case "POINT_IN_TIME_RECOVERY_ENABLED":
      return Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_ENABLED;
    case 2:
    case "POINT_IN_TIME_RECOVERY_DISABLED":
      return Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Database_PointInTimeRecoveryEnablement.UNRECOGNIZED;
  }
}

export function database_PointInTimeRecoveryEnablementToJSON(object: Database_PointInTimeRecoveryEnablement): string {
  switch (object) {
    case Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED:
      return "POINT_IN_TIME_RECOVERY_ENABLEMENT_UNSPECIFIED";
    case Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_ENABLED:
      return "POINT_IN_TIME_RECOVERY_ENABLED";
    case Database_PointInTimeRecoveryEnablement.POINT_IN_TIME_RECOVERY_DISABLED:
      return "POINT_IN_TIME_RECOVERY_DISABLED";
    case Database_PointInTimeRecoveryEnablement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The type of App Engine integration mode. */
export enum Database_AppEngineIntegrationMode {
  /** APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED - Not used. */
  APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED = 0,
  /**
   * ENABLED - If an App Engine application exists in the same region as this database,
   * App Engine configuration will impact this database. This includes
   * disabling of the application & database, as well as disabling writes to
   * the database.
   */
  ENABLED = 1,
  /**
   * DISABLED - App Engine has no effect on the ability of this database to serve
   * requests.
   *
   * This is the default setting for databases created with the Firestore API.
   */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function database_AppEngineIntegrationModeFromJSON(object: any): Database_AppEngineIntegrationMode {
  switch (object) {
    case 0:
    case "APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED":
      return Database_AppEngineIntegrationMode.APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Database_AppEngineIntegrationMode.ENABLED;
    case 2:
    case "DISABLED":
      return Database_AppEngineIntegrationMode.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Database_AppEngineIntegrationMode.UNRECOGNIZED;
  }
}

export function database_AppEngineIntegrationModeToJSON(object: Database_AppEngineIntegrationMode): string {
  switch (object) {
    case Database_AppEngineIntegrationMode.APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED:
      return "APP_ENGINE_INTEGRATION_MODE_UNSPECIFIED";
    case Database_AppEngineIntegrationMode.ENABLED:
      return "ENABLED";
    case Database_AppEngineIntegrationMode.DISABLED:
      return "DISABLED";
    case Database_AppEngineIntegrationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The delete protection state of the database. */
export enum Database_DeleteProtectionState {
  /** DELETE_PROTECTION_STATE_UNSPECIFIED - The default value. Delete protection type is not specified */
  DELETE_PROTECTION_STATE_UNSPECIFIED = 0,
  /** DELETE_PROTECTION_DISABLED - Delete protection is disabled */
  DELETE_PROTECTION_DISABLED = 1,
  /** DELETE_PROTECTION_ENABLED - Delete protection is enabled */
  DELETE_PROTECTION_ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function database_DeleteProtectionStateFromJSON(object: any): Database_DeleteProtectionState {
  switch (object) {
    case 0:
    case "DELETE_PROTECTION_STATE_UNSPECIFIED":
      return Database_DeleteProtectionState.DELETE_PROTECTION_STATE_UNSPECIFIED;
    case 1:
    case "DELETE_PROTECTION_DISABLED":
      return Database_DeleteProtectionState.DELETE_PROTECTION_DISABLED;
    case 2:
    case "DELETE_PROTECTION_ENABLED":
      return Database_DeleteProtectionState.DELETE_PROTECTION_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Database_DeleteProtectionState.UNRECOGNIZED;
  }
}

export function database_DeleteProtectionStateToJSON(object: Database_DeleteProtectionState): string {
  switch (object) {
    case Database_DeleteProtectionState.DELETE_PROTECTION_STATE_UNSPECIFIED:
      return "DELETE_PROTECTION_STATE_UNSPECIFIED";
    case Database_DeleteProtectionState.DELETE_PROTECTION_DISABLED:
      return "DELETE_PROTECTION_DISABLED";
    case Database_DeleteProtectionState.DELETE_PROTECTION_ENABLED:
      return "DELETE_PROTECTION_ENABLED";
    case Database_DeleteProtectionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The CMEK (Customer Managed Encryption Key) configuration for a Firestore
 * database. If not present, the database is secured by the default Google
 * encryption key.
 */
export interface Database_CmekConfig {
  /**
   * Required. Only keys in the same location as this database are allowed to
   * be used for encryption.
   *
   * For Firestore's nam5 multi-region, this corresponds to Cloud KMS
   * multi-region us. For Firestore's eur3 multi-region, this corresponds to
   * Cloud KMS multi-region europe. See
   * https://cloud.google.com/kms/docs/locations.
   *
   * The expected format is
   * `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
   */
  kmsKeyName: string;
  /**
   * Output only. Currently in-use [KMS key
   * versions](https://cloud.google.com/kms/docs/resource-hierarchy#key_versions).
   * During [key rotation](https://cloud.google.com/kms/docs/key-rotation),
   * there can be multiple in-use key versions.
   *
   * The expected format is
   * `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}/cryptoKeyVersions/{key_version}`.
   */
  activeKeyVersion: string[];
}

/** Information about the provenance of this database. */
export interface Database_SourceInfo {
  /**
   * If set, this database was restored from the specified backup (or a
   * snapshot thereof).
   */
  backup?:
    | Database_SourceInfo_BackupSource
    | undefined;
  /**
   * The associated long-running operation. This field may not be set after
   * the operation has completed. Format:
   * `projects/{project}/databases/{database}/operations/{operation}`.
   */
  operation: string;
}

/** Information about a backup that was used to restore a database. */
export interface Database_SourceInfo_BackupSource {
  /**
   * The resource name of the backup that was used to restore this
   * database. Format:
   * `projects/{project}/locations/{location}/backups/{backup}`.
   */
  backup: string;
}

/**
 * Encryption configuration for a new database being created from another
 * source.
 *
 * The source could be a [Backup][google.firestore.admin.v1.Backup] .
 */
export interface Database_EncryptionConfig {
  /** Use Google default encryption. */
  googleDefaultEncryption?:
    | Database_EncryptionConfig_GoogleDefaultEncryptionOptions
    | undefined;
  /** The database will use the same encryption configuration as the source. */
  useSourceEncryption?:
    | Database_EncryptionConfig_SourceEncryptionOptions
    | undefined;
  /** Use Customer Managed Encryption Keys (CMEK) for encryption. */
  customerManagedEncryption?: Database_EncryptionConfig_CustomerManagedEncryptionOptions | undefined;
}

/** The configuration options for using Google default encryption. */
export interface Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
}

/**
 * The configuration options for using the same encryption method as the
 * source.
 */
export interface Database_EncryptionConfig_SourceEncryptionOptions {
}

/**
 * The configuration options for using CMEK (Customer Managed Encryption
 * Key) encryption.
 */
export interface Database_EncryptionConfig_CustomerManagedEncryptionOptions {
  /**
   * Required. Only keys in the same location as the database are allowed to
   * be used for encryption.
   *
   * For Firestore's nam5 multi-region, this corresponds to Cloud KMS
   * multi-region us. For Firestore's eur3 multi-region, this corresponds to
   * Cloud KMS multi-region europe. See
   * https://cloud.google.com/kms/docs/locations.
   *
   * The expected format is
   * `projects/{project_id}/locations/{kms_location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
   */
  kmsKeyName: string;
}

function createBaseDatabase(): Database {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    locationId: "",
    type: 0,
    concurrencyMode: 0,
    versionRetentionPeriod: undefined,
    earliestVersionTime: undefined,
    pointInTimeRecoveryEnablement: 0,
    appEngineIntegrationMode: 0,
    keyPrefix: "",
    deleteProtectionState: 0,
    cmekConfig: undefined,
    previousId: "",
    sourceInfo: undefined,
    etag: "",
  };
}

export const Database: MessageFns<Database> = {
  encode(message: Database, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(58).fork()).join();
    }
    if (message.locationId !== "") {
      writer.uint32(74).string(message.locationId);
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.concurrencyMode !== 0) {
      writer.uint32(120).int32(message.concurrencyMode);
    }
    if (message.versionRetentionPeriod !== undefined) {
      Duration.encode(message.versionRetentionPeriod, writer.uint32(138).fork()).join();
    }
    if (message.earliestVersionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.earliestVersionTime), writer.uint32(146).fork()).join();
    }
    if (message.pointInTimeRecoveryEnablement !== 0) {
      writer.uint32(168).int32(message.pointInTimeRecoveryEnablement);
    }
    if (message.appEngineIntegrationMode !== 0) {
      writer.uint32(152).int32(message.appEngineIntegrationMode);
    }
    if (message.keyPrefix !== "") {
      writer.uint32(162).string(message.keyPrefix);
    }
    if (message.deleteProtectionState !== 0) {
      writer.uint32(176).int32(message.deleteProtectionState);
    }
    if (message.cmekConfig !== undefined) {
      Database_CmekConfig.encode(message.cmekConfig, writer.uint32(186).fork()).join();
    }
    if (message.previousId !== "") {
      writer.uint32(202).string(message.previousId);
    }
    if (message.sourceInfo !== undefined) {
      Database_SourceInfo.encode(message.sourceInfo, writer.uint32(210).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(794).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.locationId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.concurrencyMode = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.versionRetentionPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.earliestVersionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.pointInTimeRecoveryEnablement = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.appEngineIntegrationMode = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.keyPrefix = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.deleteProtectionState = reader.int32() as any;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.cmekConfig = Database_CmekConfig.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.previousId = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.sourceInfo = Database_SourceInfo.decode(reader, reader.uint32());
          continue;
        case 99:
          if (tag !== 794) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      locationId: isSet(object.locationId) ? globalThis.String(object.locationId) : "",
      type: isSet(object.type) ? database_DatabaseTypeFromJSON(object.type) : 0,
      concurrencyMode: isSet(object.concurrencyMode) ? database_ConcurrencyModeFromJSON(object.concurrencyMode) : 0,
      versionRetentionPeriod: isSet(object.versionRetentionPeriod)
        ? Duration.fromJSON(object.versionRetentionPeriod)
        : undefined,
      earliestVersionTime: isSet(object.earliestVersionTime)
        ? fromJsonTimestamp(object.earliestVersionTime)
        : undefined,
      pointInTimeRecoveryEnablement: isSet(object.pointInTimeRecoveryEnablement)
        ? database_PointInTimeRecoveryEnablementFromJSON(object.pointInTimeRecoveryEnablement)
        : 0,
      appEngineIntegrationMode: isSet(object.appEngineIntegrationMode)
        ? database_AppEngineIntegrationModeFromJSON(object.appEngineIntegrationMode)
        : 0,
      keyPrefix: isSet(object.keyPrefix) ? globalThis.String(object.keyPrefix) : "",
      deleteProtectionState: isSet(object.deleteProtectionState)
        ? database_DeleteProtectionStateFromJSON(object.deleteProtectionState)
        : 0,
      cmekConfig: isSet(object.cmekConfig) ? Database_CmekConfig.fromJSON(object.cmekConfig) : undefined,
      previousId: isSet(object.previousId) ? globalThis.String(object.previousId) : "",
      sourceInfo: isSet(object.sourceInfo) ? Database_SourceInfo.fromJSON(object.sourceInfo) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: Database): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.locationId !== "") {
      obj.locationId = message.locationId;
    }
    if (message.type !== 0) {
      obj.type = database_DatabaseTypeToJSON(message.type);
    }
    if (message.concurrencyMode !== 0) {
      obj.concurrencyMode = database_ConcurrencyModeToJSON(message.concurrencyMode);
    }
    if (message.versionRetentionPeriod !== undefined) {
      obj.versionRetentionPeriod = Duration.toJSON(message.versionRetentionPeriod);
    }
    if (message.earliestVersionTime !== undefined) {
      obj.earliestVersionTime = message.earliestVersionTime.toISOString();
    }
    if (message.pointInTimeRecoveryEnablement !== 0) {
      obj.pointInTimeRecoveryEnablement = database_PointInTimeRecoveryEnablementToJSON(
        message.pointInTimeRecoveryEnablement,
      );
    }
    if (message.appEngineIntegrationMode !== 0) {
      obj.appEngineIntegrationMode = database_AppEngineIntegrationModeToJSON(message.appEngineIntegrationMode);
    }
    if (message.keyPrefix !== "") {
      obj.keyPrefix = message.keyPrefix;
    }
    if (message.deleteProtectionState !== 0) {
      obj.deleteProtectionState = database_DeleteProtectionStateToJSON(message.deleteProtectionState);
    }
    if (message.cmekConfig !== undefined) {
      obj.cmekConfig = Database_CmekConfig.toJSON(message.cmekConfig);
    }
    if (message.previousId !== "") {
      obj.previousId = message.previousId;
    }
    if (message.sourceInfo !== undefined) {
      obj.sourceInfo = Database_SourceInfo.toJSON(message.sourceInfo);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<Database>): Database {
    return Database.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database>): Database {
    const message = createBaseDatabase();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.locationId = object.locationId ?? "";
    message.type = object.type ?? 0;
    message.concurrencyMode = object.concurrencyMode ?? 0;
    message.versionRetentionPeriod =
      (object.versionRetentionPeriod !== undefined && object.versionRetentionPeriod !== null)
        ? Duration.fromPartial(object.versionRetentionPeriod)
        : undefined;
    message.earliestVersionTime = object.earliestVersionTime ?? undefined;
    message.pointInTimeRecoveryEnablement = object.pointInTimeRecoveryEnablement ?? 0;
    message.appEngineIntegrationMode = object.appEngineIntegrationMode ?? 0;
    message.keyPrefix = object.keyPrefix ?? "";
    message.deleteProtectionState = object.deleteProtectionState ?? 0;
    message.cmekConfig = (object.cmekConfig !== undefined && object.cmekConfig !== null)
      ? Database_CmekConfig.fromPartial(object.cmekConfig)
      : undefined;
    message.previousId = object.previousId ?? "";
    message.sourceInfo = (object.sourceInfo !== undefined && object.sourceInfo !== null)
      ? Database_SourceInfo.fromPartial(object.sourceInfo)
      : undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseDatabase_CmekConfig(): Database_CmekConfig {
  return { kmsKeyName: "", activeKeyVersion: [] };
}

export const Database_CmekConfig: MessageFns<Database_CmekConfig> = {
  encode(message: Database_CmekConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKeyName !== "") {
      writer.uint32(10).string(message.kmsKeyName);
    }
    for (const v of message.activeKeyVersion) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_CmekConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_CmekConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activeKeyVersion.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_CmekConfig {
    return {
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      activeKeyVersion: globalThis.Array.isArray(object?.activeKeyVersion)
        ? object.activeKeyVersion.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Database_CmekConfig): unknown {
    const obj: any = {};
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.activeKeyVersion?.length) {
      obj.activeKeyVersion = message.activeKeyVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Database_CmekConfig>): Database_CmekConfig {
    return Database_CmekConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_CmekConfig>): Database_CmekConfig {
    const message = createBaseDatabase_CmekConfig();
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.activeKeyVersion = object.activeKeyVersion?.map((e) => e) || [];
    return message;
  },
};

function createBaseDatabase_SourceInfo(): Database_SourceInfo {
  return { backup: undefined, operation: "" };
}

export const Database_SourceInfo: MessageFns<Database_SourceInfo> = {
  encode(message: Database_SourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backup !== undefined) {
      Database_SourceInfo_BackupSource.encode(message.backup, writer.uint32(10).fork()).join();
    }
    if (message.operation !== "") {
      writer.uint32(26).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_SourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_SourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backup = Database_SourceInfo_BackupSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_SourceInfo {
    return {
      backup: isSet(object.backup) ? Database_SourceInfo_BackupSource.fromJSON(object.backup) : undefined,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
    };
  },

  toJSON(message: Database_SourceInfo): unknown {
    const obj: any = {};
    if (message.backup !== undefined) {
      obj.backup = Database_SourceInfo_BackupSource.toJSON(message.backup);
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<Database_SourceInfo>): Database_SourceInfo {
    return Database_SourceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_SourceInfo>): Database_SourceInfo {
    const message = createBaseDatabase_SourceInfo();
    message.backup = (object.backup !== undefined && object.backup !== null)
      ? Database_SourceInfo_BackupSource.fromPartial(object.backup)
      : undefined;
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseDatabase_SourceInfo_BackupSource(): Database_SourceInfo_BackupSource {
  return { backup: "" };
}

export const Database_SourceInfo_BackupSource: MessageFns<Database_SourceInfo_BackupSource> = {
  encode(message: Database_SourceInfo_BackupSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backup !== "") {
      writer.uint32(10).string(message.backup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_SourceInfo_BackupSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_SourceInfo_BackupSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_SourceInfo_BackupSource {
    return { backup: isSet(object.backup) ? globalThis.String(object.backup) : "" };
  },

  toJSON(message: Database_SourceInfo_BackupSource): unknown {
    const obj: any = {};
    if (message.backup !== "") {
      obj.backup = message.backup;
    }
    return obj;
  },

  create(base?: DeepPartial<Database_SourceInfo_BackupSource>): Database_SourceInfo_BackupSource {
    return Database_SourceInfo_BackupSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_SourceInfo_BackupSource>): Database_SourceInfo_BackupSource {
    const message = createBaseDatabase_SourceInfo_BackupSource();
    message.backup = object.backup ?? "";
    return message;
  },
};

function createBaseDatabase_EncryptionConfig(): Database_EncryptionConfig {
  return { googleDefaultEncryption: undefined, useSourceEncryption: undefined, customerManagedEncryption: undefined };
}

export const Database_EncryptionConfig: MessageFns<Database_EncryptionConfig> = {
  encode(message: Database_EncryptionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.googleDefaultEncryption !== undefined) {
      Database_EncryptionConfig_GoogleDefaultEncryptionOptions.encode(
        message.googleDefaultEncryption,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.useSourceEncryption !== undefined) {
      Database_EncryptionConfig_SourceEncryptionOptions.encode(message.useSourceEncryption, writer.uint32(18).fork())
        .join();
    }
    if (message.customerManagedEncryption !== undefined) {
      Database_EncryptionConfig_CustomerManagedEncryptionOptions.encode(
        message.customerManagedEncryption,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_EncryptionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_EncryptionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.googleDefaultEncryption = Database_EncryptionConfig_GoogleDefaultEncryptionOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.useSourceEncryption = Database_EncryptionConfig_SourceEncryptionOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerManagedEncryption = Database_EncryptionConfig_CustomerManagedEncryptionOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_EncryptionConfig {
    return {
      googleDefaultEncryption: isSet(object.googleDefaultEncryption)
        ? Database_EncryptionConfig_GoogleDefaultEncryptionOptions.fromJSON(object.googleDefaultEncryption)
        : undefined,
      useSourceEncryption: isSet(object.useSourceEncryption)
        ? Database_EncryptionConfig_SourceEncryptionOptions.fromJSON(object.useSourceEncryption)
        : undefined,
      customerManagedEncryption: isSet(object.customerManagedEncryption)
        ? Database_EncryptionConfig_CustomerManagedEncryptionOptions.fromJSON(object.customerManagedEncryption)
        : undefined,
    };
  },

  toJSON(message: Database_EncryptionConfig): unknown {
    const obj: any = {};
    if (message.googleDefaultEncryption !== undefined) {
      obj.googleDefaultEncryption = Database_EncryptionConfig_GoogleDefaultEncryptionOptions.toJSON(
        message.googleDefaultEncryption,
      );
    }
    if (message.useSourceEncryption !== undefined) {
      obj.useSourceEncryption = Database_EncryptionConfig_SourceEncryptionOptions.toJSON(message.useSourceEncryption);
    }
    if (message.customerManagedEncryption !== undefined) {
      obj.customerManagedEncryption = Database_EncryptionConfig_CustomerManagedEncryptionOptions.toJSON(
        message.customerManagedEncryption,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Database_EncryptionConfig>): Database_EncryptionConfig {
    return Database_EncryptionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Database_EncryptionConfig>): Database_EncryptionConfig {
    const message = createBaseDatabase_EncryptionConfig();
    message.googleDefaultEncryption =
      (object.googleDefaultEncryption !== undefined && object.googleDefaultEncryption !== null)
        ? Database_EncryptionConfig_GoogleDefaultEncryptionOptions.fromPartial(object.googleDefaultEncryption)
        : undefined;
    message.useSourceEncryption = (object.useSourceEncryption !== undefined && object.useSourceEncryption !== null)
      ? Database_EncryptionConfig_SourceEncryptionOptions.fromPartial(object.useSourceEncryption)
      : undefined;
    message.customerManagedEncryption =
      (object.customerManagedEncryption !== undefined && object.customerManagedEncryption !== null)
        ? Database_EncryptionConfig_CustomerManagedEncryptionOptions.fromPartial(object.customerManagedEncryption)
        : undefined;
    return message;
  },
};

function createBaseDatabase_EncryptionConfig_GoogleDefaultEncryptionOptions(): Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
  return {};
}

export const Database_EncryptionConfig_GoogleDefaultEncryptionOptions: MessageFns<
  Database_EncryptionConfig_GoogleDefaultEncryptionOptions
> = {
  encode(
    _: Database_EncryptionConfig_GoogleDefaultEncryptionOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_EncryptionConfig_GoogleDefaultEncryptionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
    return {};
  },

  toJSON(_: Database_EncryptionConfig_GoogleDefaultEncryptionOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<Database_EncryptionConfig_GoogleDefaultEncryptionOptions>,
  ): Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
    return Database_EncryptionConfig_GoogleDefaultEncryptionOptions.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<Database_EncryptionConfig_GoogleDefaultEncryptionOptions>,
  ): Database_EncryptionConfig_GoogleDefaultEncryptionOptions {
    const message = createBaseDatabase_EncryptionConfig_GoogleDefaultEncryptionOptions();
    return message;
  },
};

function createBaseDatabase_EncryptionConfig_SourceEncryptionOptions(): Database_EncryptionConfig_SourceEncryptionOptions {
  return {};
}

export const Database_EncryptionConfig_SourceEncryptionOptions: MessageFns<
  Database_EncryptionConfig_SourceEncryptionOptions
> = {
  encode(
    _: Database_EncryptionConfig_SourceEncryptionOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Database_EncryptionConfig_SourceEncryptionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_EncryptionConfig_SourceEncryptionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Database_EncryptionConfig_SourceEncryptionOptions {
    return {};
  },

  toJSON(_: Database_EncryptionConfig_SourceEncryptionOptions): unknown {
    const obj: any = {};
    return obj;
  },

  create(
    base?: DeepPartial<Database_EncryptionConfig_SourceEncryptionOptions>,
  ): Database_EncryptionConfig_SourceEncryptionOptions {
    return Database_EncryptionConfig_SourceEncryptionOptions.fromPartial(base ?? {});
  },
  fromPartial(
    _: DeepPartial<Database_EncryptionConfig_SourceEncryptionOptions>,
  ): Database_EncryptionConfig_SourceEncryptionOptions {
    const message = createBaseDatabase_EncryptionConfig_SourceEncryptionOptions();
    return message;
  },
};

function createBaseDatabase_EncryptionConfig_CustomerManagedEncryptionOptions(): Database_EncryptionConfig_CustomerManagedEncryptionOptions {
  return { kmsKeyName: "" };
}

export const Database_EncryptionConfig_CustomerManagedEncryptionOptions: MessageFns<
  Database_EncryptionConfig_CustomerManagedEncryptionOptions
> = {
  encode(
    message: Database_EncryptionConfig_CustomerManagedEncryptionOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.kmsKeyName !== "") {
      writer.uint32(10).string(message.kmsKeyName);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Database_EncryptionConfig_CustomerManagedEncryptionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabase_EncryptionConfig_CustomerManagedEncryptionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Database_EncryptionConfig_CustomerManagedEncryptionOptions {
    return { kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "" };
  },

  toJSON(message: Database_EncryptionConfig_CustomerManagedEncryptionOptions): unknown {
    const obj: any = {};
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Database_EncryptionConfig_CustomerManagedEncryptionOptions>,
  ): Database_EncryptionConfig_CustomerManagedEncryptionOptions {
    return Database_EncryptionConfig_CustomerManagedEncryptionOptions.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Database_EncryptionConfig_CustomerManagedEncryptionOptions>,
  ): Database_EncryptionConfig_CustomerManagedEncryptionOptions {
    const message = createBaseDatabase_EncryptionConfig_CustomerManagedEncryptionOptions();
    message.kmsKeyName = object.kmsKeyName ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
