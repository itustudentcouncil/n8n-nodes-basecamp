// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/firestore/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { DoubleValue, Int32Value, Int64Value } from "../../protobuf/wrappers.js";
import { Value } from "./document.js";

export const protobufPackage = "google.firestore.v1";

/**
 * A Firestore query.
 *
 * The query stages are executed in the following order:
 * 1. from
 * 2. where
 * 3. select
 * 4. order_by + start_at + end_at
 * 5. offset
 * 6. limit
 */
export interface StructuredQuery {
  /**
   * Optional sub-set of the fields to return.
   *
   * This acts as a [DocumentMask][google.firestore.v1.DocumentMask] over the
   * documents returned from a query. When not set, assumes that the caller
   * wants all fields returned.
   */
  select:
    | StructuredQuery_Projection
    | undefined;
  /** The collections to query. */
  from: StructuredQuery_CollectionSelector[];
  /** The filter to apply. */
  where:
    | StructuredQuery_Filter
    | undefined;
  /**
   * The order to apply to the query results.
   *
   * Firestore allows callers to provide a full ordering, a partial ordering, or
   * no ordering at all. In all cases, Firestore guarantees a stable ordering
   * through the following rules:
   *
   *  * The `order_by` is required to reference all fields used with an
   *    inequality filter.
   *  * All fields that are required to be in the `order_by` but are not already
   *    present are appended in lexicographical ordering of the field name.
   *  * If an order on `__name__` is not specified, it is appended by default.
   *
   * Fields are appended with the same sort direction as the last order
   * specified, or 'ASCENDING' if no order was specified. For example:
   *
   *  * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC`
   *  * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC`
   *  * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC`
   *  * `WHERE __name__ > ... AND a > 1` becomes
   *     `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`
   */
  orderBy: StructuredQuery_Order[];
  /**
   * A potential prefix of a position in the result set to start the query at.
   *
   * The ordering of the result set is based on the `ORDER BY` clause of the
   * original query.
   *
   * ```
   * SELECT * FROM k WHERE a = 1 AND b > 2 ORDER BY b ASC, __name__ ASC;
   * ```
   *
   * This query's results are ordered by `(b ASC, __name__ ASC)`.
   *
   * Cursors can reference either the full ordering or a prefix of the location,
   * though it cannot reference more fields than what are in the provided
   * `ORDER BY`.
   *
   * Continuing off the example above, attaching the following start cursors
   * will have varying impact:
   *
   * - `START BEFORE (2, /k/123)`: start the query right before `a = 1 AND
   *    b > 2 AND __name__ > /k/123`.
   * - `START AFTER (10)`: start the query right after `a = 1 AND b > 10`.
   *
   * Unlike `OFFSET` which requires scanning over the first N results to skip,
   * a start cursor allows the query to begin at a logical position. This
   * position is not required to match an actual result, it will scan forward
   * from this position to find the next document.
   *
   * Requires:
   *
   * * The number of values cannot be greater than the number of fields
   *   specified in the `ORDER BY` clause.
   */
  startAt:
    | Cursor
    | undefined;
  /**
   * A potential prefix of a position in the result set to end the query at.
   *
   * This is similar to `START_AT` but with it controlling the end position
   * rather than the start position.
   *
   * Requires:
   *
   * * The number of values cannot be greater than the number of fields
   *   specified in the `ORDER BY` clause.
   */
  endAt:
    | Cursor
    | undefined;
  /**
   * The number of documents to skip before returning the first result.
   *
   * This applies after the constraints specified by the `WHERE`, `START AT`, &
   * `END AT` but before the `LIMIT` clause.
   *
   * Requires:
   *
   * * The value must be greater than or equal to zero if specified.
   */
  offset: number;
  /**
   * The maximum number of results to return.
   *
   * Applies after all other constraints.
   *
   * Requires:
   *
   * * The value must be greater than or equal to zero if specified.
   */
  limit:
    | number
    | undefined;
  /**
   * Optional. A potential nearest neighbors search.
   *
   * Applies after all other filters and ordering.
   *
   * Finds the closest vector embeddings to the given query vector.
   */
  findNearest: StructuredQuery_FindNearest | undefined;
}

/** A sort direction. */
export enum StructuredQuery_Direction {
  /** DIRECTION_UNSPECIFIED - Unspecified. */
  DIRECTION_UNSPECIFIED = 0,
  /** ASCENDING - Ascending. */
  ASCENDING = 1,
  /** DESCENDING - Descending. */
  DESCENDING = 2,
  UNRECOGNIZED = -1,
}

export function structuredQuery_DirectionFromJSON(object: any): StructuredQuery_Direction {
  switch (object) {
    case 0:
    case "DIRECTION_UNSPECIFIED":
      return StructuredQuery_Direction.DIRECTION_UNSPECIFIED;
    case 1:
    case "ASCENDING":
      return StructuredQuery_Direction.ASCENDING;
    case 2:
    case "DESCENDING":
      return StructuredQuery_Direction.DESCENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_Direction.UNRECOGNIZED;
  }
}

export function structuredQuery_DirectionToJSON(object: StructuredQuery_Direction): string {
  switch (object) {
    case StructuredQuery_Direction.DIRECTION_UNSPECIFIED:
      return "DIRECTION_UNSPECIFIED";
    case StructuredQuery_Direction.ASCENDING:
      return "ASCENDING";
    case StructuredQuery_Direction.DESCENDING:
      return "DESCENDING";
    case StructuredQuery_Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A selection of a collection, such as `messages as m1`. */
export interface StructuredQuery_CollectionSelector {
  /**
   * The collection ID.
   * When set, selects only collections with this ID.
   */
  collectionId: string;
  /**
   * When false, selects only collections that are immediate children of
   * the `parent` specified in the containing `RunQueryRequest`.
   * When true, selects all descendant collections.
   */
  allDescendants: boolean;
}

/** A filter. */
export interface StructuredQuery_Filter {
  /** A composite filter. */
  compositeFilter?:
    | StructuredQuery_CompositeFilter
    | undefined;
  /** A filter on a document field. */
  fieldFilter?:
    | StructuredQuery_FieldFilter
    | undefined;
  /** A filter that takes exactly one argument. */
  unaryFilter?: StructuredQuery_UnaryFilter | undefined;
}

/** A filter that merges multiple other filters using the given operator. */
export interface StructuredQuery_CompositeFilter {
  /** The operator for combining multiple filters. */
  op: StructuredQuery_CompositeFilter_Operator;
  /**
   * The list of filters to combine.
   *
   * Requires:
   *
   * * At least one filter is present.
   */
  filters: StructuredQuery_Filter[];
}

/** A composite filter operator. */
export enum StructuredQuery_CompositeFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /** AND - Documents are required to satisfy all of the combined filters. */
  AND = 1,
  /** OR - Documents are required to satisfy at least one of the combined filters. */
  OR = 2,
  UNRECOGNIZED = -1,
}

export function structuredQuery_CompositeFilter_OperatorFromJSON(
  object: any,
): StructuredQuery_CompositeFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_CompositeFilter_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "AND":
      return StructuredQuery_CompositeFilter_Operator.AND;
    case 2:
    case "OR":
      return StructuredQuery_CompositeFilter_Operator.OR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_CompositeFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_CompositeFilter_OperatorToJSON(
  object: StructuredQuery_CompositeFilter_Operator,
): string {
  switch (object) {
    case StructuredQuery_CompositeFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_CompositeFilter_Operator.AND:
      return "AND";
    case StructuredQuery_CompositeFilter_Operator.OR:
      return "OR";
    case StructuredQuery_CompositeFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A filter on a specific field. */
export interface StructuredQuery_FieldFilter {
  /** The field to filter by. */
  field:
    | StructuredQuery_FieldReference
    | undefined;
  /** The operator to filter by. */
  op: StructuredQuery_FieldFilter_Operator;
  /** The value to compare to. */
  value: Value | undefined;
}

/** A field filter operator. */
export enum StructuredQuery_FieldFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /**
   * LESS_THAN - The given `field` is less than the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  LESS_THAN = 1,
  /**
   * LESS_THAN_OR_EQUAL - The given `field` is less than or equal to the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  LESS_THAN_OR_EQUAL = 2,
  /**
   * GREATER_THAN - The given `field` is greater than the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  GREATER_THAN = 3,
  /**
   * GREATER_THAN_OR_EQUAL - The given `field` is greater than or equal to the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  GREATER_THAN_OR_EQUAL = 4,
  /** EQUAL - The given `field` is equal to the given `value`. */
  EQUAL = 5,
  /**
   * NOT_EQUAL - The given `field` is not equal to the given `value`.
   *
   * Requires:
   *
   * * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  NOT_EQUAL = 6,
  /** ARRAY_CONTAINS - The given `field` is an array that contains the given `value`. */
  ARRAY_CONTAINS = 7,
  /**
   * IN - The given `field` is equal to at least one value in the given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue`, subject to disjunction
   *   limits.
   * * No `NOT_IN` filters in the same query.
   */
  IN = 8,
  /**
   * ARRAY_CONTAINS_ANY - The given `field` is an array that contains any of the values in the
   * given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue`, subject to disjunction
   *   limits.
   * * No other `ARRAY_CONTAINS_ANY` filters within the same disjunction.
   * * No `NOT_IN` filters in the same query.
   */
  ARRAY_CONTAINS_ANY = 9,
  /**
   * NOT_IN - The value of the `field` is not in the given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue` with at most 10 values.
   * * No other `OR`, `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`, `NOT_EQUAL`,
   *   `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  NOT_IN = 10,
  UNRECOGNIZED = -1,
}

export function structuredQuery_FieldFilter_OperatorFromJSON(object: any): StructuredQuery_FieldFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_FieldFilter_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "LESS_THAN":
      return StructuredQuery_FieldFilter_Operator.LESS_THAN;
    case 2:
    case "LESS_THAN_OR_EQUAL":
      return StructuredQuery_FieldFilter_Operator.LESS_THAN_OR_EQUAL;
    case 3:
    case "GREATER_THAN":
      return StructuredQuery_FieldFilter_Operator.GREATER_THAN;
    case 4:
    case "GREATER_THAN_OR_EQUAL":
      return StructuredQuery_FieldFilter_Operator.GREATER_THAN_OR_EQUAL;
    case 5:
    case "EQUAL":
      return StructuredQuery_FieldFilter_Operator.EQUAL;
    case 6:
    case "NOT_EQUAL":
      return StructuredQuery_FieldFilter_Operator.NOT_EQUAL;
    case 7:
    case "ARRAY_CONTAINS":
      return StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS;
    case 8:
    case "IN":
      return StructuredQuery_FieldFilter_Operator.IN;
    case 9:
    case "ARRAY_CONTAINS_ANY":
      return StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS_ANY;
    case 10:
    case "NOT_IN":
      return StructuredQuery_FieldFilter_Operator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_FieldFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_FieldFilter_OperatorToJSON(object: StructuredQuery_FieldFilter_Operator): string {
  switch (object) {
    case StructuredQuery_FieldFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_FieldFilter_Operator.LESS_THAN:
      return "LESS_THAN";
    case StructuredQuery_FieldFilter_Operator.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case StructuredQuery_FieldFilter_Operator.GREATER_THAN:
      return "GREATER_THAN";
    case StructuredQuery_FieldFilter_Operator.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case StructuredQuery_FieldFilter_Operator.EQUAL:
      return "EQUAL";
    case StructuredQuery_FieldFilter_Operator.NOT_EQUAL:
      return "NOT_EQUAL";
    case StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS:
      return "ARRAY_CONTAINS";
    case StructuredQuery_FieldFilter_Operator.IN:
      return "IN";
    case StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS_ANY:
      return "ARRAY_CONTAINS_ANY";
    case StructuredQuery_FieldFilter_Operator.NOT_IN:
      return "NOT_IN";
    case StructuredQuery_FieldFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A filter with a single operand. */
export interface StructuredQuery_UnaryFilter {
  /** The unary operator to apply. */
  op: StructuredQuery_UnaryFilter_Operator;
  /** The field to which to apply the operator. */
  field?: StructuredQuery_FieldReference | undefined;
}

/** A unary operator. */
export enum StructuredQuery_UnaryFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /** IS_NAN - The given `field` is equal to `NaN`. */
  IS_NAN = 2,
  /** IS_NULL - The given `field` is equal to `NULL`. */
  IS_NULL = 3,
  /**
   * IS_NOT_NAN - The given `field` is not equal to `NaN`.
   *
   * Requires:
   *
   * * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  IS_NOT_NAN = 4,
  /**
   * IS_NOT_NULL - The given `field` is not equal to `NULL`.
   *
   * Requires:
   *
   * * A single `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  IS_NOT_NULL = 5,
  UNRECOGNIZED = -1,
}

export function structuredQuery_UnaryFilter_OperatorFromJSON(object: any): StructuredQuery_UnaryFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_UnaryFilter_Operator.OPERATOR_UNSPECIFIED;
    case 2:
    case "IS_NAN":
      return StructuredQuery_UnaryFilter_Operator.IS_NAN;
    case 3:
    case "IS_NULL":
      return StructuredQuery_UnaryFilter_Operator.IS_NULL;
    case 4:
    case "IS_NOT_NAN":
      return StructuredQuery_UnaryFilter_Operator.IS_NOT_NAN;
    case 5:
    case "IS_NOT_NULL":
      return StructuredQuery_UnaryFilter_Operator.IS_NOT_NULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_UnaryFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_UnaryFilter_OperatorToJSON(object: StructuredQuery_UnaryFilter_Operator): string {
  switch (object) {
    case StructuredQuery_UnaryFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_UnaryFilter_Operator.IS_NAN:
      return "IS_NAN";
    case StructuredQuery_UnaryFilter_Operator.IS_NULL:
      return "IS_NULL";
    case StructuredQuery_UnaryFilter_Operator.IS_NOT_NAN:
      return "IS_NOT_NAN";
    case StructuredQuery_UnaryFilter_Operator.IS_NOT_NULL:
      return "IS_NOT_NULL";
    case StructuredQuery_UnaryFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An order on a field. */
export interface StructuredQuery_Order {
  /** The field to order by. */
  field:
    | StructuredQuery_FieldReference
    | undefined;
  /** The direction to order by. Defaults to `ASCENDING`. */
  direction: StructuredQuery_Direction;
}

/** A reference to a field in a document, ex: `stats.operations`. */
export interface StructuredQuery_FieldReference {
  /**
   * A reference to a field in a document.
   *
   * Requires:
   *
   * * MUST be a dot-delimited (`.`) string of segments, where each segment
   * conforms to [document field name][google.firestore.v1.Document.fields]
   * limitations.
   */
  fieldPath: string;
}

/** The projection of document's fields to return. */
export interface StructuredQuery_Projection {
  /**
   * The fields to return.
   *
   * If empty, all fields are returned. To only return the name
   * of the document, use `['__name__']`.
   */
  fields: StructuredQuery_FieldReference[];
}

/**
 * Nearest Neighbors search config. The ordering provided by FindNearest
 * supersedes the order_by stage. If multiple documents have the same vector
 * distance, the returned document order is not guaranteed to be stable
 * between queries.
 */
export interface StructuredQuery_FindNearest {
  /**
   * Required. An indexed vector field to search upon. Only documents which
   * contain vectors whose dimensionality match the query_vector can be
   * returned.
   */
  vectorField:
    | StructuredQuery_FieldReference
    | undefined;
  /**
   * Required. The query vector that we are searching on. Must be a vector of
   * no more than 2048 dimensions.
   */
  queryVector:
    | Value
    | undefined;
  /** Required. The distance measure to use, required. */
  distanceMeasure: StructuredQuery_FindNearest_DistanceMeasure;
  /**
   * Required. The number of nearest neighbors to return. Must be a positive
   * integer of no more than 1000.
   */
  limit:
    | number
    | undefined;
  /**
   * Optional. Optional name of the field to output the result of the vector
   * distance calculation. Must conform to [document field
   * name][google.firestore.v1.Document.fields] limitations.
   */
  distanceResultField: string;
  /**
   * Optional. Option to specify a threshold for which no less similar
   * documents will be returned. The behavior of the specified
   * `distance_measure` will affect the meaning of the distance threshold.
   * Since DOT_PRODUCT distances increase when the vectors are more similar,
   * the comparison is inverted.
   *
   * For EUCLIDEAN, COSINE: WHERE distance <= distance_threshold
   * For DOT_PRODUCT:       WHERE distance >= distance_threshold
   */
  distanceThreshold: number | undefined;
}

/** The distance measure to use when comparing vectors. */
export enum StructuredQuery_FindNearest_DistanceMeasure {
  /** DISTANCE_MEASURE_UNSPECIFIED - Should not be set. */
  DISTANCE_MEASURE_UNSPECIFIED = 0,
  /**
   * EUCLIDEAN - Measures the EUCLIDEAN distance between the vectors. See
   * [Euclidean](https://en.wikipedia.org/wiki/Euclidean_distance) to learn
   * more. The resulting distance decreases the more similar two vectors
   * are.
   */
  EUCLIDEAN = 1,
  /**
   * COSINE - COSINE distance compares vectors based on the angle between them, which
   * allows you to measure similarity that isn't based on the vectors
   * magnitude. We recommend using DOT_PRODUCT with unit normalized vectors
   * instead of COSINE distance, which is mathematically equivalent with
   * better performance. See [Cosine
   * Similarity](https://en.wikipedia.org/wiki/Cosine_similarity) to learn
   * more about COSINE similarity and COSINE distance. The resulting
   * COSINE distance decreases the more similar two vectors are.
   */
  COSINE = 2,
  /**
   * DOT_PRODUCT - Similar to cosine but is affected by the magnitude of the vectors. See
   * [Dot Product](https://en.wikipedia.org/wiki/Dot_product) to learn more.
   * The resulting distance increases the more similar two vectors are.
   */
  DOT_PRODUCT = 3,
  UNRECOGNIZED = -1,
}

export function structuredQuery_FindNearest_DistanceMeasureFromJSON(
  object: any,
): StructuredQuery_FindNearest_DistanceMeasure {
  switch (object) {
    case 0:
    case "DISTANCE_MEASURE_UNSPECIFIED":
      return StructuredQuery_FindNearest_DistanceMeasure.DISTANCE_MEASURE_UNSPECIFIED;
    case 1:
    case "EUCLIDEAN":
      return StructuredQuery_FindNearest_DistanceMeasure.EUCLIDEAN;
    case 2:
    case "COSINE":
      return StructuredQuery_FindNearest_DistanceMeasure.COSINE;
    case 3:
    case "DOT_PRODUCT":
      return StructuredQuery_FindNearest_DistanceMeasure.DOT_PRODUCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_FindNearest_DistanceMeasure.UNRECOGNIZED;
  }
}

export function structuredQuery_FindNearest_DistanceMeasureToJSON(
  object: StructuredQuery_FindNearest_DistanceMeasure,
): string {
  switch (object) {
    case StructuredQuery_FindNearest_DistanceMeasure.DISTANCE_MEASURE_UNSPECIFIED:
      return "DISTANCE_MEASURE_UNSPECIFIED";
    case StructuredQuery_FindNearest_DistanceMeasure.EUCLIDEAN:
      return "EUCLIDEAN";
    case StructuredQuery_FindNearest_DistanceMeasure.COSINE:
      return "COSINE";
    case StructuredQuery_FindNearest_DistanceMeasure.DOT_PRODUCT:
      return "DOT_PRODUCT";
    case StructuredQuery_FindNearest_DistanceMeasure.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Firestore query for running an aggregation over a
 * [StructuredQuery][google.firestore.v1.StructuredQuery].
 */
export interface StructuredAggregationQuery {
  /** Nested structured query. */
  structuredQuery?:
    | StructuredQuery
    | undefined;
  /**
   * Optional. Series of aggregations to apply over the results of the
   * `structured_query`.
   *
   * Requires:
   *
   * * A minimum of one and maximum of five aggregations per query.
   */
  aggregations: StructuredAggregationQuery_Aggregation[];
}

/** Defines an aggregation that produces a single result. */
export interface StructuredAggregationQuery_Aggregation {
  /** Count aggregator. */
  count?:
    | StructuredAggregationQuery_Aggregation_Count
    | undefined;
  /** Sum aggregator. */
  sum?:
    | StructuredAggregationQuery_Aggregation_Sum
    | undefined;
  /** Average aggregator. */
  avg?:
    | StructuredAggregationQuery_Aggregation_Avg
    | undefined;
  /**
   * Optional. Optional name of the field to store the result of the
   * aggregation into.
   *
   * If not provided, Firestore will pick a default name following the format
   * `field_<incremental_id++>`. For example:
   *
   * ```
   * AGGREGATE
   *   COUNT_UP_TO(1) AS count_up_to_1,
   *   COUNT_UP_TO(2),
   *   COUNT_UP_TO(3) AS count_up_to_3,
   *   COUNT(*)
   * OVER (
   *   ...
   * );
   * ```
   *
   * becomes:
   *
   * ```
   * AGGREGATE
   *   COUNT_UP_TO(1) AS count_up_to_1,
   *   COUNT_UP_TO(2) AS field_1,
   *   COUNT_UP_TO(3) AS count_up_to_3,
   *   COUNT(*) AS field_2
   * OVER (
   *   ...
   * );
   * ```
   *
   * Requires:
   *
   * * Must be unique across all aggregation aliases.
   * * Conform to [document field name][google.firestore.v1.Document.fields]
   * limitations.
   */
  alias: string;
}

/**
 * Count of documents that match the query.
 *
 * The `COUNT(*)` aggregation function operates on the entire document
 * so it does not require a field reference.
 */
export interface StructuredAggregationQuery_Aggregation_Count {
  /**
   * Optional. Optional constraint on the maximum number of documents to
   * count.
   *
   * This provides a way to set an upper bound on the number of documents
   * to scan, limiting latency, and cost.
   *
   * Unspecified is interpreted as no bound.
   *
   * High-Level Example:
   *
   * ```
   * AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k );
   * ```
   *
   * Requires:
   *
   * * Must be greater than zero when present.
   */
  upTo: Long | undefined;
}

/**
 * Sum of the values of the requested field.
 *
 * * Only numeric values will be aggregated. All non-numeric values
 * including `NULL` are skipped.
 *
 * * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
 * follows IEEE-754 standards.
 *
 * * If the aggregated value set is empty, returns 0.
 *
 * * Returns a 64-bit integer if all aggregated numbers are integers and the
 * sum result does not overflow. Otherwise, the result is returned as a
 * double. Note that even if all the aggregated values are integers, the
 * result is returned as a double if it cannot fit within a 64-bit signed
 * integer. When this occurs, the returned value will lose precision.
 *
 * * When underflow occurs, floating-point aggregation is non-deterministic.
 * This means that running the same query repeatedly without any changes to
 * the underlying values could produce slightly different results each
 * time. In those cases, values should be stored as integers over
 * floating-point numbers.
 */
export interface StructuredAggregationQuery_Aggregation_Sum {
  /** The field to aggregate on. */
  field: StructuredQuery_FieldReference | undefined;
}

/**
 * Average of the values of the requested field.
 *
 * * Only numeric values will be aggregated. All non-numeric values
 * including `NULL` are skipped.
 *
 * * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
 * follows IEEE-754 standards.
 *
 * * If the aggregated value set is empty, returns `NULL`.
 *
 * * Always returns the result as a double.
 */
export interface StructuredAggregationQuery_Aggregation_Avg {
  /** The field to aggregate on. */
  field: StructuredQuery_FieldReference | undefined;
}

/** A position in a query result set. */
export interface Cursor {
  /**
   * The values that represent a position, in the order they appear in
   * the order by clause of a query.
   *
   * Can contain fewer values than specified in the order by clause.
   */
  values: Value[];
  /**
   * If the position is just before or just after the given values, relative
   * to the sort order defined by the query.
   */
  before: boolean;
}

function createBaseStructuredQuery(): StructuredQuery {
  return {
    select: undefined,
    from: [],
    where: undefined,
    orderBy: [],
    startAt: undefined,
    endAt: undefined,
    offset: 0,
    limit: undefined,
    findNearest: undefined,
  };
}

export const StructuredQuery: MessageFns<StructuredQuery> = {
  encode(message: StructuredQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.select !== undefined) {
      StructuredQuery_Projection.encode(message.select, writer.uint32(10).fork()).join();
    }
    for (const v of message.from) {
      StructuredQuery_CollectionSelector.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.where !== undefined) {
      StructuredQuery_Filter.encode(message.where, writer.uint32(26).fork()).join();
    }
    for (const v of message.orderBy) {
      StructuredQuery_Order.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.startAt !== undefined) {
      Cursor.encode(message.startAt, writer.uint32(58).fork()).join();
    }
    if (message.endAt !== undefined) {
      Cursor.encode(message.endAt, writer.uint32(66).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(48).int32(message.offset);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(42).fork()).join();
    }
    if (message.findNearest !== undefined) {
      StructuredQuery_FindNearest.encode(message.findNearest, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.select = StructuredQuery_Projection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from.push(StructuredQuery_CollectionSelector.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.where = StructuredQuery_Filter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy.push(StructuredQuery_Order.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startAt = Cursor.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endAt = Cursor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.findNearest = StructuredQuery_FindNearest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery {
    return {
      select: isSet(object.select) ? StructuredQuery_Projection.fromJSON(object.select) : undefined,
      from: globalThis.Array.isArray(object?.from)
        ? object.from.map((e: any) => StructuredQuery_CollectionSelector.fromJSON(e))
        : [],
      where: isSet(object.where) ? StructuredQuery_Filter.fromJSON(object.where) : undefined,
      orderBy: globalThis.Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => StructuredQuery_Order.fromJSON(e))
        : [],
      startAt: isSet(object.startAt) ? Cursor.fromJSON(object.startAt) : undefined,
      endAt: isSet(object.endAt) ? Cursor.fromJSON(object.endAt) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      findNearest: isSet(object.findNearest) ? StructuredQuery_FindNearest.fromJSON(object.findNearest) : undefined,
    };
  },

  toJSON(message: StructuredQuery): unknown {
    const obj: any = {};
    if (message.select !== undefined) {
      obj.select = StructuredQuery_Projection.toJSON(message.select);
    }
    if (message.from?.length) {
      obj.from = message.from.map((e) => StructuredQuery_CollectionSelector.toJSON(e));
    }
    if (message.where !== undefined) {
      obj.where = StructuredQuery_Filter.toJSON(message.where);
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => StructuredQuery_Order.toJSON(e));
    }
    if (message.startAt !== undefined) {
      obj.startAt = Cursor.toJSON(message.startAt);
    }
    if (message.endAt !== undefined) {
      obj.endAt = Cursor.toJSON(message.endAt);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.findNearest !== undefined) {
      obj.findNearest = StructuredQuery_FindNearest.toJSON(message.findNearest);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery>): StructuredQuery {
    return StructuredQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery>): StructuredQuery {
    const message = createBaseStructuredQuery();
    message.select = (object.select !== undefined && object.select !== null)
      ? StructuredQuery_Projection.fromPartial(object.select)
      : undefined;
    message.from = object.from?.map((e) => StructuredQuery_CollectionSelector.fromPartial(e)) || [];
    message.where = (object.where !== undefined && object.where !== null)
      ? StructuredQuery_Filter.fromPartial(object.where)
      : undefined;
    message.orderBy = object.orderBy?.map((e) => StructuredQuery_Order.fromPartial(e)) || [];
    message.startAt = (object.startAt !== undefined && object.startAt !== null)
      ? Cursor.fromPartial(object.startAt)
      : undefined;
    message.endAt = (object.endAt !== undefined && object.endAt !== null)
      ? Cursor.fromPartial(object.endAt)
      : undefined;
    message.offset = object.offset ?? 0;
    message.limit = object.limit ?? undefined;
    message.findNearest = (object.findNearest !== undefined && object.findNearest !== null)
      ? StructuredQuery_FindNearest.fromPartial(object.findNearest)
      : undefined;
    return message;
  },
};

function createBaseStructuredQuery_CollectionSelector(): StructuredQuery_CollectionSelector {
  return { collectionId: "", allDescendants: false };
}

export const StructuredQuery_CollectionSelector: MessageFns<StructuredQuery_CollectionSelector> = {
  encode(message: StructuredQuery_CollectionSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collectionId !== "") {
      writer.uint32(18).string(message.collectionId);
    }
    if (message.allDescendants !== false) {
      writer.uint32(24).bool(message.allDescendants);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_CollectionSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_CollectionSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allDescendants = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_CollectionSelector {
    return {
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      allDescendants: isSet(object.allDescendants) ? globalThis.Boolean(object.allDescendants) : false,
    };
  },

  toJSON(message: StructuredQuery_CollectionSelector): unknown {
    const obj: any = {};
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.allDescendants !== false) {
      obj.allDescendants = message.allDescendants;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_CollectionSelector>): StructuredQuery_CollectionSelector {
    return StructuredQuery_CollectionSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_CollectionSelector>): StructuredQuery_CollectionSelector {
    const message = createBaseStructuredQuery_CollectionSelector();
    message.collectionId = object.collectionId ?? "";
    message.allDescendants = object.allDescendants ?? false;
    return message;
  },
};

function createBaseStructuredQuery_Filter(): StructuredQuery_Filter {
  return { compositeFilter: undefined, fieldFilter: undefined, unaryFilter: undefined };
}

export const StructuredQuery_Filter: MessageFns<StructuredQuery_Filter> = {
  encode(message: StructuredQuery_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compositeFilter !== undefined) {
      StructuredQuery_CompositeFilter.encode(message.compositeFilter, writer.uint32(10).fork()).join();
    }
    if (message.fieldFilter !== undefined) {
      StructuredQuery_FieldFilter.encode(message.fieldFilter, writer.uint32(18).fork()).join();
    }
    if (message.unaryFilter !== undefined) {
      StructuredQuery_UnaryFilter.encode(message.unaryFilter, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.compositeFilter = StructuredQuery_CompositeFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldFilter = StructuredQuery_FieldFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unaryFilter = StructuredQuery_UnaryFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Filter {
    return {
      compositeFilter: isSet(object.compositeFilter)
        ? StructuredQuery_CompositeFilter.fromJSON(object.compositeFilter)
        : undefined,
      fieldFilter: isSet(object.fieldFilter) ? StructuredQuery_FieldFilter.fromJSON(object.fieldFilter) : undefined,
      unaryFilter: isSet(object.unaryFilter) ? StructuredQuery_UnaryFilter.fromJSON(object.unaryFilter) : undefined,
    };
  },

  toJSON(message: StructuredQuery_Filter): unknown {
    const obj: any = {};
    if (message.compositeFilter !== undefined) {
      obj.compositeFilter = StructuredQuery_CompositeFilter.toJSON(message.compositeFilter);
    }
    if (message.fieldFilter !== undefined) {
      obj.fieldFilter = StructuredQuery_FieldFilter.toJSON(message.fieldFilter);
    }
    if (message.unaryFilter !== undefined) {
      obj.unaryFilter = StructuredQuery_UnaryFilter.toJSON(message.unaryFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Filter>): StructuredQuery_Filter {
    return StructuredQuery_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Filter>): StructuredQuery_Filter {
    const message = createBaseStructuredQuery_Filter();
    message.compositeFilter = (object.compositeFilter !== undefined && object.compositeFilter !== null)
      ? StructuredQuery_CompositeFilter.fromPartial(object.compositeFilter)
      : undefined;
    message.fieldFilter = (object.fieldFilter !== undefined && object.fieldFilter !== null)
      ? StructuredQuery_FieldFilter.fromPartial(object.fieldFilter)
      : undefined;
    message.unaryFilter = (object.unaryFilter !== undefined && object.unaryFilter !== null)
      ? StructuredQuery_UnaryFilter.fromPartial(object.unaryFilter)
      : undefined;
    return message;
  },
};

function createBaseStructuredQuery_CompositeFilter(): StructuredQuery_CompositeFilter {
  return { op: 0, filters: [] };
}

export const StructuredQuery_CompositeFilter: MessageFns<StructuredQuery_CompositeFilter> = {
  encode(message: StructuredQuery_CompositeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    for (const v of message.filters) {
      StructuredQuery_Filter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_CompositeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_CompositeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filters.push(StructuredQuery_Filter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_CompositeFilter {
    return {
      op: isSet(object.op) ? structuredQuery_CompositeFilter_OperatorFromJSON(object.op) : 0,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => StructuredQuery_Filter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StructuredQuery_CompositeFilter): unknown {
    const obj: any = {};
    if (message.op !== 0) {
      obj.op = structuredQuery_CompositeFilter_OperatorToJSON(message.op);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => StructuredQuery_Filter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_CompositeFilter>): StructuredQuery_CompositeFilter {
    return StructuredQuery_CompositeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_CompositeFilter>): StructuredQuery_CompositeFilter {
    const message = createBaseStructuredQuery_CompositeFilter();
    message.op = object.op ?? 0;
    message.filters = object.filters?.map((e) => StructuredQuery_Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructuredQuery_FieldFilter(): StructuredQuery_FieldFilter {
  return { field: undefined, op: 0, value: undefined };
}

export const StructuredQuery_FieldFilter: MessageFns<StructuredQuery_FieldFilter> = {
  encode(message: StructuredQuery_FieldFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_FieldFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_FieldFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_FieldFilter {
    return {
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
      op: isSet(object.op) ? structuredQuery_FieldFilter_OperatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StructuredQuery_FieldFilter): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    if (message.op !== 0) {
      obj.op = structuredQuery_FieldFilter_OperatorToJSON(message.op);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_FieldFilter>): StructuredQuery_FieldFilter {
    return StructuredQuery_FieldFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_FieldFilter>): StructuredQuery_FieldFilter {
    const message = createBaseStructuredQuery_FieldFilter();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    message.op = object.op ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseStructuredQuery_UnaryFilter(): StructuredQuery_UnaryFilter {
  return { op: 0, field: undefined };
}

export const StructuredQuery_UnaryFilter: MessageFns<StructuredQuery_UnaryFilter> = {
  encode(message: StructuredQuery_UnaryFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_UnaryFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_UnaryFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_UnaryFilter {
    return {
      op: isSet(object.op) ? structuredQuery_UnaryFilter_OperatorFromJSON(object.op) : 0,
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
    };
  },

  toJSON(message: StructuredQuery_UnaryFilter): unknown {
    const obj: any = {};
    if (message.op !== 0) {
      obj.op = structuredQuery_UnaryFilter_OperatorToJSON(message.op);
    }
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_UnaryFilter>): StructuredQuery_UnaryFilter {
    return StructuredQuery_UnaryFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_UnaryFilter>): StructuredQuery_UnaryFilter {
    const message = createBaseStructuredQuery_UnaryFilter();
    message.op = object.op ?? 0;
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    return message;
  },
};

function createBaseStructuredQuery_Order(): StructuredQuery_Order {
  return { field: undefined, direction: 0 };
}

export const StructuredQuery_Order: MessageFns<StructuredQuery_Order> = {
  encode(message: StructuredQuery_Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Order();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Order {
    return {
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
      direction: isSet(object.direction) ? structuredQuery_DirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: StructuredQuery_Order): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    if (message.direction !== 0) {
      obj.direction = structuredQuery_DirectionToJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Order>): StructuredQuery_Order {
    return StructuredQuery_Order.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Order>): StructuredQuery_Order {
    const message = createBaseStructuredQuery_Order();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseStructuredQuery_FieldReference(): StructuredQuery_FieldReference {
  return { fieldPath: "" };
}

export const StructuredQuery_FieldReference: MessageFns<StructuredQuery_FieldReference> = {
  encode(message: StructuredQuery_FieldReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(18).string(message.fieldPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_FieldReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_FieldReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_FieldReference {
    return { fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "" };
  },

  toJSON(message: StructuredQuery_FieldReference): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_FieldReference>): StructuredQuery_FieldReference {
    return StructuredQuery_FieldReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_FieldReference>): StructuredQuery_FieldReference {
    const message = createBaseStructuredQuery_FieldReference();
    message.fieldPath = object.fieldPath ?? "";
    return message;
  },
};

function createBaseStructuredQuery_Projection(): StructuredQuery_Projection {
  return { fields: [] };
}

export const StructuredQuery_Projection: MessageFns<StructuredQuery_Projection> = {
  encode(message: StructuredQuery_Projection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      StructuredQuery_FieldReference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Projection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Projection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(StructuredQuery_FieldReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Projection {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => StructuredQuery_FieldReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StructuredQuery_Projection): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => StructuredQuery_FieldReference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Projection>): StructuredQuery_Projection {
    return StructuredQuery_Projection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Projection>): StructuredQuery_Projection {
    const message = createBaseStructuredQuery_Projection();
    message.fields = object.fields?.map((e) => StructuredQuery_FieldReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructuredQuery_FindNearest(): StructuredQuery_FindNearest {
  return {
    vectorField: undefined,
    queryVector: undefined,
    distanceMeasure: 0,
    limit: undefined,
    distanceResultField: "",
    distanceThreshold: undefined,
  };
}

export const StructuredQuery_FindNearest: MessageFns<StructuredQuery_FindNearest> = {
  encode(message: StructuredQuery_FindNearest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vectorField !== undefined) {
      StructuredQuery_FieldReference.encode(message.vectorField, writer.uint32(10).fork()).join();
    }
    if (message.queryVector !== undefined) {
      Value.encode(message.queryVector, writer.uint32(18).fork()).join();
    }
    if (message.distanceMeasure !== 0) {
      writer.uint32(24).int32(message.distanceMeasure);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(34).fork()).join();
    }
    if (message.distanceResultField !== "") {
      writer.uint32(42).string(message.distanceResultField);
    }
    if (message.distanceThreshold !== undefined) {
      DoubleValue.encode({ value: message.distanceThreshold! }, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_FindNearest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_FindNearest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vectorField = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryVector = Value.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.distanceMeasure = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distanceResultField = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.distanceThreshold = DoubleValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_FindNearest {
    return {
      vectorField: isSet(object.vectorField) ? StructuredQuery_FieldReference.fromJSON(object.vectorField) : undefined,
      queryVector: isSet(object.queryVector) ? Value.fromJSON(object.queryVector) : undefined,
      distanceMeasure: isSet(object.distanceMeasure)
        ? structuredQuery_FindNearest_DistanceMeasureFromJSON(object.distanceMeasure)
        : 0,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
      distanceResultField: isSet(object.distanceResultField) ? globalThis.String(object.distanceResultField) : "",
      distanceThreshold: isSet(object.distanceThreshold) ? Number(object.distanceThreshold) : undefined,
    };
  },

  toJSON(message: StructuredQuery_FindNearest): unknown {
    const obj: any = {};
    if (message.vectorField !== undefined) {
      obj.vectorField = StructuredQuery_FieldReference.toJSON(message.vectorField);
    }
    if (message.queryVector !== undefined) {
      obj.queryVector = Value.toJSON(message.queryVector);
    }
    if (message.distanceMeasure !== 0) {
      obj.distanceMeasure = structuredQuery_FindNearest_DistanceMeasureToJSON(message.distanceMeasure);
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    if (message.distanceResultField !== "") {
      obj.distanceResultField = message.distanceResultField;
    }
    if (message.distanceThreshold !== undefined) {
      obj.distanceThreshold = message.distanceThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_FindNearest>): StructuredQuery_FindNearest {
    return StructuredQuery_FindNearest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_FindNearest>): StructuredQuery_FindNearest {
    const message = createBaseStructuredQuery_FindNearest();
    message.vectorField = (object.vectorField !== undefined && object.vectorField !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.vectorField)
      : undefined;
    message.queryVector = (object.queryVector !== undefined && object.queryVector !== null)
      ? Value.fromPartial(object.queryVector)
      : undefined;
    message.distanceMeasure = object.distanceMeasure ?? 0;
    message.limit = object.limit ?? undefined;
    message.distanceResultField = object.distanceResultField ?? "";
    message.distanceThreshold = object.distanceThreshold ?? undefined;
    return message;
  },
};

function createBaseStructuredAggregationQuery(): StructuredAggregationQuery {
  return { structuredQuery: undefined, aggregations: [] };
}

export const StructuredAggregationQuery: MessageFns<StructuredAggregationQuery> = {
  encode(message: StructuredAggregationQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.structuredQuery !== undefined) {
      StructuredQuery.encode(message.structuredQuery, writer.uint32(10).fork()).join();
    }
    for (const v of message.aggregations) {
      StructuredAggregationQuery_Aggregation.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredAggregationQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredAggregationQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.structuredQuery = StructuredQuery.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aggregations.push(StructuredAggregationQuery_Aggregation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredAggregationQuery {
    return {
      structuredQuery: isSet(object.structuredQuery) ? StructuredQuery.fromJSON(object.structuredQuery) : undefined,
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => StructuredAggregationQuery_Aggregation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StructuredAggregationQuery): unknown {
    const obj: any = {};
    if (message.structuredQuery !== undefined) {
      obj.structuredQuery = StructuredQuery.toJSON(message.structuredQuery);
    }
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => StructuredAggregationQuery_Aggregation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredAggregationQuery>): StructuredAggregationQuery {
    return StructuredAggregationQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredAggregationQuery>): StructuredAggregationQuery {
    const message = createBaseStructuredAggregationQuery();
    message.structuredQuery = (object.structuredQuery !== undefined && object.structuredQuery !== null)
      ? StructuredQuery.fromPartial(object.structuredQuery)
      : undefined;
    message.aggregations = object.aggregations?.map((e) => StructuredAggregationQuery_Aggregation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructuredAggregationQuery_Aggregation(): StructuredAggregationQuery_Aggregation {
  return { count: undefined, sum: undefined, avg: undefined, alias: "" };
}

export const StructuredAggregationQuery_Aggregation: MessageFns<StructuredAggregationQuery_Aggregation> = {
  encode(message: StructuredAggregationQuery_Aggregation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== undefined) {
      StructuredAggregationQuery_Aggregation_Count.encode(message.count, writer.uint32(10).fork()).join();
    }
    if (message.sum !== undefined) {
      StructuredAggregationQuery_Aggregation_Sum.encode(message.sum, writer.uint32(18).fork()).join();
    }
    if (message.avg !== undefined) {
      StructuredAggregationQuery_Aggregation_Avg.encode(message.avg, writer.uint32(26).fork()).join();
    }
    if (message.alias !== "") {
      writer.uint32(58).string(message.alias);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredAggregationQuery_Aggregation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredAggregationQuery_Aggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.count = StructuredAggregationQuery_Aggregation_Count.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sum = StructuredAggregationQuery_Aggregation_Sum.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avg = StructuredAggregationQuery_Aggregation_Avg.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.alias = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredAggregationQuery_Aggregation {
    return {
      count: isSet(object.count) ? StructuredAggregationQuery_Aggregation_Count.fromJSON(object.count) : undefined,
      sum: isSet(object.sum) ? StructuredAggregationQuery_Aggregation_Sum.fromJSON(object.sum) : undefined,
      avg: isSet(object.avg) ? StructuredAggregationQuery_Aggregation_Avg.fromJSON(object.avg) : undefined,
      alias: isSet(object.alias) ? globalThis.String(object.alias) : "",
    };
  },

  toJSON(message: StructuredAggregationQuery_Aggregation): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = StructuredAggregationQuery_Aggregation_Count.toJSON(message.count);
    }
    if (message.sum !== undefined) {
      obj.sum = StructuredAggregationQuery_Aggregation_Sum.toJSON(message.sum);
    }
    if (message.avg !== undefined) {
      obj.avg = StructuredAggregationQuery_Aggregation_Avg.toJSON(message.avg);
    }
    if (message.alias !== "") {
      obj.alias = message.alias;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredAggregationQuery_Aggregation>): StructuredAggregationQuery_Aggregation {
    return StructuredAggregationQuery_Aggregation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredAggregationQuery_Aggregation>): StructuredAggregationQuery_Aggregation {
    const message = createBaseStructuredAggregationQuery_Aggregation();
    message.count = (object.count !== undefined && object.count !== null)
      ? StructuredAggregationQuery_Aggregation_Count.fromPartial(object.count)
      : undefined;
    message.sum = (object.sum !== undefined && object.sum !== null)
      ? StructuredAggregationQuery_Aggregation_Sum.fromPartial(object.sum)
      : undefined;
    message.avg = (object.avg !== undefined && object.avg !== null)
      ? StructuredAggregationQuery_Aggregation_Avg.fromPartial(object.avg)
      : undefined;
    message.alias = object.alias ?? "";
    return message;
  },
};

function createBaseStructuredAggregationQuery_Aggregation_Count(): StructuredAggregationQuery_Aggregation_Count {
  return { upTo: undefined };
}

export const StructuredAggregationQuery_Aggregation_Count: MessageFns<StructuredAggregationQuery_Aggregation_Count> = {
  encode(
    message: StructuredAggregationQuery_Aggregation_Count,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.upTo !== undefined) {
      Int64Value.encode({ value: message.upTo! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredAggregationQuery_Aggregation_Count {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredAggregationQuery_Aggregation_Count();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.upTo = Int64Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredAggregationQuery_Aggregation_Count {
    return { upTo: isSet(object.upTo) ? Long.fromValue(object.upTo) : undefined };
  },

  toJSON(message: StructuredAggregationQuery_Aggregation_Count): unknown {
    const obj: any = {};
    if (message.upTo !== undefined) {
      obj.upTo = message.upTo;
    }
    return obj;
  },

  create(
    base?: DeepPartial<StructuredAggregationQuery_Aggregation_Count>,
  ): StructuredAggregationQuery_Aggregation_Count {
    return StructuredAggregationQuery_Aggregation_Count.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StructuredAggregationQuery_Aggregation_Count>,
  ): StructuredAggregationQuery_Aggregation_Count {
    const message = createBaseStructuredAggregationQuery_Aggregation_Count();
    message.upTo = (object.upTo !== undefined && object.upTo !== null) ? Long.fromValue(object.upTo) : undefined;
    return message;
  },
};

function createBaseStructuredAggregationQuery_Aggregation_Sum(): StructuredAggregationQuery_Aggregation_Sum {
  return { field: undefined };
}

export const StructuredAggregationQuery_Aggregation_Sum: MessageFns<StructuredAggregationQuery_Aggregation_Sum> = {
  encode(message: StructuredAggregationQuery_Aggregation_Sum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredAggregationQuery_Aggregation_Sum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredAggregationQuery_Aggregation_Sum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredAggregationQuery_Aggregation_Sum {
    return { field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined };
  },

  toJSON(message: StructuredAggregationQuery_Aggregation_Sum): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredAggregationQuery_Aggregation_Sum>): StructuredAggregationQuery_Aggregation_Sum {
    return StructuredAggregationQuery_Aggregation_Sum.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StructuredAggregationQuery_Aggregation_Sum>,
  ): StructuredAggregationQuery_Aggregation_Sum {
    const message = createBaseStructuredAggregationQuery_Aggregation_Sum();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    return message;
  },
};

function createBaseStructuredAggregationQuery_Aggregation_Avg(): StructuredAggregationQuery_Aggregation_Avg {
  return { field: undefined };
}

export const StructuredAggregationQuery_Aggregation_Avg: MessageFns<StructuredAggregationQuery_Aggregation_Avg> = {
  encode(message: StructuredAggregationQuery_Aggregation_Avg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredAggregationQuery_Aggregation_Avg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredAggregationQuery_Aggregation_Avg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredAggregationQuery_Aggregation_Avg {
    return { field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined };
  },

  toJSON(message: StructuredAggregationQuery_Aggregation_Avg): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredAggregationQuery_Aggregation_Avg>): StructuredAggregationQuery_Aggregation_Avg {
    return StructuredAggregationQuery_Aggregation_Avg.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<StructuredAggregationQuery_Aggregation_Avg>,
  ): StructuredAggregationQuery_Aggregation_Avg {
    const message = createBaseStructuredAggregationQuery_Aggregation_Avg();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    return message;
  },
};

function createBaseCursor(): Cursor {
  return { values: [], before: false };
}

export const Cursor: MessageFns<Cursor> = {
  encode(message: Cursor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.before !== false) {
      writer.uint32(16).bool(message.before);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cursor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.before = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cursor {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [],
      before: isSet(object.before) ? globalThis.Boolean(object.before) : false,
    };
  },

  toJSON(message: Cursor): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    if (message.before !== false) {
      obj.before = message.before;
    }
    return obj;
  },

  create(base?: DeepPartial<Cursor>): Cursor {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cursor>): Cursor {
    const message = createBaseCursor();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    message.before = object.before ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
