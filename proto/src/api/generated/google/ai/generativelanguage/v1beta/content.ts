// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ai/generativelanguage/v1beta/content.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Struct } from "../../../protobuf/struct.js";

export const protobufPackage = "google.ai.generativelanguage.v1beta";

/**
 * Type contains the list of OpenAPI data types as defined by
 * https://spec.openapis.org/oas/v3.0.3#data-types
 */
export enum Type {
  /** TYPE_UNSPECIFIED - Not specified, should not be used. */
  TYPE_UNSPECIFIED = 0,
  /** STRING - String type. */
  STRING = 1,
  /** NUMBER - Number type. */
  NUMBER = 2,
  /** INTEGER - Integer type. */
  INTEGER = 3,
  /** BOOLEAN - Boolean type. */
  BOOLEAN = 4,
  /** ARRAY - Array type. */
  ARRAY = 5,
  /** OBJECT - Object type. */
  OBJECT = 6,
  UNRECOGNIZED = -1,
}

export function typeFromJSON(object: any): Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Type.TYPE_UNSPECIFIED;
    case 1:
    case "STRING":
      return Type.STRING;
    case 2:
    case "NUMBER":
      return Type.NUMBER;
    case 3:
    case "INTEGER":
      return Type.INTEGER;
    case 4:
    case "BOOLEAN":
      return Type.BOOLEAN;
    case 5:
    case "ARRAY":
      return Type.ARRAY;
    case 6:
    case "OBJECT":
      return Type.OBJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Type.UNRECOGNIZED;
  }
}

export function typeToJSON(object: Type): string {
  switch (object) {
    case Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Type.STRING:
      return "STRING";
    case Type.NUMBER:
      return "NUMBER";
    case Type.INTEGER:
      return "INTEGER";
    case Type.BOOLEAN:
      return "BOOLEAN";
    case Type.ARRAY:
      return "ARRAY";
    case Type.OBJECT:
      return "OBJECT";
    case Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The base structured datatype containing multi-part content of a message.
 *
 * A `Content` includes a `role` field designating the producer of the `Content`
 * and a `parts` field containing multi-part data that contains the content of
 * the message turn.
 */
export interface Content {
  /**
   * Ordered `Parts` that constitute a single message. Parts may have different
   * MIME types.
   */
  parts: Part[];
  /**
   * Optional. The producer of the content. Must be either 'user' or 'model'.
   *
   * Useful to set for multi-turn conversations, otherwise can be left blank
   * or unset.
   */
  role: string;
}

/**
 * A datatype containing media that is part of a multi-part `Content` message.
 *
 * A `Part` consists of data which has an associated datatype. A `Part` can only
 * contain one of the accepted types in `Part.data`.
 *
 * A `Part` must have a fixed IANA MIME type identifying the type and subtype
 * of the media if the `inline_data` field is filled with raw bytes.
 */
export interface Part {
  /** Inline text. */
  text?:
    | string
    | undefined;
  /** Inline media bytes. */
  inlineData?:
    | Blob
    | undefined;
  /**
   * A predicted `FunctionCall` returned from the model that contains
   * a string representing the `FunctionDeclaration.name` with the
   * arguments and their values.
   */
  functionCall?:
    | FunctionCall
    | undefined;
  /**
   * The result output of a `FunctionCall` that contains a string
   * representing the `FunctionDeclaration.name` and a structured JSON
   * object containing any output from the function is used as context to
   * the model.
   */
  functionResponse?:
    | FunctionResponse
    | undefined;
  /** URI based data. */
  fileData?:
    | FileData
    | undefined;
  /** Code generated by the model that is meant to be executed. */
  executableCode?:
    | ExecutableCode
    | undefined;
  /** Result of executing the `ExecutableCode`. */
  codeExecutionResult?: CodeExecutionResult | undefined;
}

/**
 * Raw media bytes.
 *
 * Text should not be sent as raw bytes, use the 'text' field.
 */
export interface Blob {
  /**
   * The IANA standard MIME type of the source data.
   * Examples:
   *   - image/png
   *   - image/jpeg
   * If an unsupported MIME type is provided, an error will be returned. For a
   * complete list of supported types, see [Supported file
   * formats](https://ai.google.dev/gemini-api/docs/prompting_with_media#supported_file_formats).
   */
  mimeType: string;
  /** Raw bytes for media formats. */
  data: Buffer;
}

/** URI based data. */
export interface FileData {
  /** Optional. The IANA standard MIME type of the source data. */
  mimeType: string;
  /** Required. URI. */
  fileUri: string;
}

/**
 * Code generated by the model that is meant to be executed, and the result
 * returned to the model.
 *
 * Only generated when using the `CodeExecution` tool, in which the code will
 * be automatically executed, and a corresponding `CodeExecutionResult` will
 * also be generated.
 */
export interface ExecutableCode {
  /** Required. Programming language of the `code`. */
  language: ExecutableCode_Language;
  /** Required. The code to be executed. */
  code: string;
}

/** Supported programming languages for the generated code. */
export enum ExecutableCode_Language {
  /** LANGUAGE_UNSPECIFIED - Unspecified language. This value should not be used. */
  LANGUAGE_UNSPECIFIED = 0,
  /** PYTHON - Python >= 3.10, with numpy and simpy available. */
  PYTHON = 1,
  UNRECOGNIZED = -1,
}

export function executableCode_LanguageFromJSON(object: any): ExecutableCode_Language {
  switch (object) {
    case 0:
    case "LANGUAGE_UNSPECIFIED":
      return ExecutableCode_Language.LANGUAGE_UNSPECIFIED;
    case 1:
    case "PYTHON":
      return ExecutableCode_Language.PYTHON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutableCode_Language.UNRECOGNIZED;
  }
}

export function executableCode_LanguageToJSON(object: ExecutableCode_Language): string {
  switch (object) {
    case ExecutableCode_Language.LANGUAGE_UNSPECIFIED:
      return "LANGUAGE_UNSPECIFIED";
    case ExecutableCode_Language.PYTHON:
      return "PYTHON";
    case ExecutableCode_Language.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Result of executing the `ExecutableCode`.
 *
 * Only generated when using the `CodeExecution`, and always follows a `part`
 * containing the `ExecutableCode`.
 */
export interface CodeExecutionResult {
  /** Required. Outcome of the code execution. */
  outcome: CodeExecutionResult_Outcome;
  /**
   * Optional. Contains stdout when code execution is successful, stderr or
   * other description otherwise.
   */
  output: string;
}

/** Enumeration of possible outcomes of the code execution. */
export enum CodeExecutionResult_Outcome {
  /** OUTCOME_UNSPECIFIED - Unspecified status. This value should not be used. */
  OUTCOME_UNSPECIFIED = 0,
  /** OUTCOME_OK - Code execution completed successfully. */
  OUTCOME_OK = 1,
  /**
   * OUTCOME_FAILED - Code execution finished but with a failure. `stderr` should contain the
   * reason.
   */
  OUTCOME_FAILED = 2,
  /**
   * OUTCOME_DEADLINE_EXCEEDED - Code execution ran for too long, and was cancelled. There may or may not
   * be a partial output present.
   */
  OUTCOME_DEADLINE_EXCEEDED = 3,
  UNRECOGNIZED = -1,
}

export function codeExecutionResult_OutcomeFromJSON(object: any): CodeExecutionResult_Outcome {
  switch (object) {
    case 0:
    case "OUTCOME_UNSPECIFIED":
      return CodeExecutionResult_Outcome.OUTCOME_UNSPECIFIED;
    case 1:
    case "OUTCOME_OK":
      return CodeExecutionResult_Outcome.OUTCOME_OK;
    case 2:
    case "OUTCOME_FAILED":
      return CodeExecutionResult_Outcome.OUTCOME_FAILED;
    case 3:
    case "OUTCOME_DEADLINE_EXCEEDED":
      return CodeExecutionResult_Outcome.OUTCOME_DEADLINE_EXCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CodeExecutionResult_Outcome.UNRECOGNIZED;
  }
}

export function codeExecutionResult_OutcomeToJSON(object: CodeExecutionResult_Outcome): string {
  switch (object) {
    case CodeExecutionResult_Outcome.OUTCOME_UNSPECIFIED:
      return "OUTCOME_UNSPECIFIED";
    case CodeExecutionResult_Outcome.OUTCOME_OK:
      return "OUTCOME_OK";
    case CodeExecutionResult_Outcome.OUTCOME_FAILED:
      return "OUTCOME_FAILED";
    case CodeExecutionResult_Outcome.OUTCOME_DEADLINE_EXCEEDED:
      return "OUTCOME_DEADLINE_EXCEEDED";
    case CodeExecutionResult_Outcome.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Tool details that the model may use to generate response.
 *
 * A `Tool` is a piece of code that enables the system to interact with
 * external systems to perform an action, or set of actions, outside of
 * knowledge and scope of the model.
 */
export interface Tool {
  /**
   * Optional. A list of `FunctionDeclarations` available to the model that can
   * be used for function calling.
   *
   * The model or system does not execute the function. Instead the defined
   * function may be returned as a
   * [FunctionCall][google.ai.generativelanguage.v1beta.Part.function_call] with
   * arguments to the client side for execution. The model may decide to call a
   * subset of these functions by populating
   * [FunctionCall][google.ai.generativelanguage.v1beta.Part.function_call] in
   * the response. The next conversation turn may contain a
   * [FunctionResponse][google.ai.generativelanguage.v1beta.Part.function_response]
   * with the [Content.role][google.ai.generativelanguage.v1beta.Content.role]
   * "function" generation context for the next model turn.
   */
  functionDeclarations: FunctionDeclaration[];
  /** Optional. Retrieval tool that is powered by Google search. */
  googleSearchRetrieval:
    | GoogleSearchRetrieval
    | undefined;
  /** Optional. Enables the model to execute code as part of generation. */
  codeExecution: CodeExecution | undefined;
}

/** Tool to retrieve public web data for grounding, powered by Google. */
export interface GoogleSearchRetrieval {
  /** Specifies the dynamic retrieval configuration for the given source. */
  dynamicRetrievalConfig: DynamicRetrievalConfig | undefined;
}

/** Describes the options to customize dynamic retrieval. */
export interface DynamicRetrievalConfig {
  /** The mode of the predictor to be used in dynamic retrieval. */
  mode: DynamicRetrievalConfig_Mode;
  /**
   * The threshold to be used in dynamic retrieval.
   * If not set, a system default value is used.
   */
  dynamicThreshold?: number | undefined;
}

/** The mode of the predictor to be used in dynamic retrieval. */
export enum DynamicRetrievalConfig_Mode {
  /** MODE_UNSPECIFIED - Always trigger retrieval. */
  MODE_UNSPECIFIED = 0,
  /** MODE_DYNAMIC - Run retrieval only when system decides it is necessary. */
  MODE_DYNAMIC = 1,
  UNRECOGNIZED = -1,
}

export function dynamicRetrievalConfig_ModeFromJSON(object: any): DynamicRetrievalConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return DynamicRetrievalConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "MODE_DYNAMIC":
      return DynamicRetrievalConfig_Mode.MODE_DYNAMIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DynamicRetrievalConfig_Mode.UNRECOGNIZED;
  }
}

export function dynamicRetrievalConfig_ModeToJSON(object: DynamicRetrievalConfig_Mode): string {
  switch (object) {
    case DynamicRetrievalConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case DynamicRetrievalConfig_Mode.MODE_DYNAMIC:
      return "MODE_DYNAMIC";
    case DynamicRetrievalConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Tool that executes code generated by the model, and automatically returns
 * the result to the model.
 *
 * See also `ExecutableCode` and `CodeExecutionResult` which are only generated
 * when using this tool.
 */
export interface CodeExecution {
}

/**
 * The Tool configuration containing parameters for specifying `Tool` use
 * in the request.
 */
export interface ToolConfig {
  /** Optional. Function calling config. */
  functionCallingConfig: FunctionCallingConfig | undefined;
}

/** Configuration for specifying function calling behavior. */
export interface FunctionCallingConfig {
  /**
   * Optional. Specifies the mode in which function calling should execute. If
   * unspecified, the default value will be set to AUTO.
   */
  mode: FunctionCallingConfig_Mode;
  /**
   * Optional. A set of function names that, when provided, limits the functions
   * the model will call.
   *
   * This should only be set when the Mode is ANY. Function names
   * should match [FunctionDeclaration.name]. With mode set to ANY, model will
   * predict a function call from the set of function names provided.
   */
  allowedFunctionNames: string[];
}

/**
 * Defines the execution behavior for function calling by defining the
 * execution mode.
 */
export enum FunctionCallingConfig_Mode {
  /** MODE_UNSPECIFIED - Unspecified function calling mode. This value should not be used. */
  MODE_UNSPECIFIED = 0,
  /**
   * AUTO - Default model behavior, model decides to predict either a function call
   * or a natural language response.
   */
  AUTO = 1,
  /**
   * ANY - Model is constrained to always predicting a function call only.
   * If "allowed_function_names" are set, the predicted function call will be
   * limited to any one of "allowed_function_names", else the predicted
   * function call will be any one of the provided "function_declarations".
   */
  ANY = 2,
  /**
   * NONE - Model will not predict any function call. Model behavior is same as when
   * not passing any function declarations.
   */
  NONE = 3,
  UNRECOGNIZED = -1,
}

export function functionCallingConfig_ModeFromJSON(object: any): FunctionCallingConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return FunctionCallingConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "AUTO":
      return FunctionCallingConfig_Mode.AUTO;
    case 2:
    case "ANY":
      return FunctionCallingConfig_Mode.ANY;
    case 3:
    case "NONE":
      return FunctionCallingConfig_Mode.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FunctionCallingConfig_Mode.UNRECOGNIZED;
  }
}

export function functionCallingConfig_ModeToJSON(object: FunctionCallingConfig_Mode): string {
  switch (object) {
    case FunctionCallingConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case FunctionCallingConfig_Mode.AUTO:
      return "AUTO";
    case FunctionCallingConfig_Mode.ANY:
      return "ANY";
    case FunctionCallingConfig_Mode.NONE:
      return "NONE";
    case FunctionCallingConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Structured representation of a function declaration as defined by the
 * [OpenAPI 3.03 specification](https://spec.openapis.org/oas/v3.0.3). Included
 * in this declaration are the function name and parameters. This
 * FunctionDeclaration is a representation of a block of code that can be used
 * as a `Tool` by the model and executed by the client.
 */
export interface FunctionDeclaration {
  /**
   * Required. The name of the function.
   * Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
   * length of 63.
   */
  name: string;
  /** Required. A brief description of the function. */
  description: string;
  /**
   * Optional. Describes the parameters to this function. Reflects the Open
   * API 3.03 Parameter Object string Key: the name of the parameter. Parameter
   * names are case sensitive. Schema Value: the Schema defining the type used
   * for the parameter.
   */
  parameters?: Schema | undefined;
}

/**
 * A predicted `FunctionCall` returned from the model that contains
 * a string representing the `FunctionDeclaration.name` with the
 * arguments and their values.
 */
export interface FunctionCall {
  /**
   * Required. The name of the function to call.
   * Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
   * length of 63.
   */
  name: string;
  /** Optional. The function parameters and values in JSON object format. */
  args?: { [key: string]: any } | undefined;
}

/**
 * The result output from a `FunctionCall` that contains a string
 * representing the `FunctionDeclaration.name` and a structured JSON
 * object containing any output from the function is used as context to
 * the model. This should contain the result of a`FunctionCall` made
 * based on model prediction.
 */
export interface FunctionResponse {
  /**
   * Required. The name of the function to call.
   * Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
   * length of 63.
   */
  name: string;
  /** Required. The function response in JSON object format. */
  response: { [key: string]: any } | undefined;
}

/**
 * The `Schema` object allows the definition of input and output data types.
 * These types can be objects, but also primitives and arrays.
 * Represents a select subset of an [OpenAPI 3.0 schema
 * object](https://spec.openapis.org/oas/v3.0.3#schema).
 */
export interface Schema {
  /** Required. Data type. */
  type: Type;
  /**
   * Optional. The format of the data. This is used only for primitive
   * datatypes. Supported formats:
   *  for NUMBER type: float, double
   *  for INTEGER type: int32, int64
   *  for STRING type: enum
   */
  format: string;
  /**
   * Optional. A brief description of the parameter. This could contain examples
   * of use. Parameter description may be formatted as Markdown.
   */
  description: string;
  /** Optional. Indicates if the value may be null. */
  nullable: boolean;
  /**
   * Optional. Possible values of the element of Type.STRING with enum format.
   * For example we can define an Enum Direction as :
   * {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
   */
  enum: string[];
  /** Optional. Schema of the elements of Type.ARRAY. */
  items?:
    | Schema
    | undefined;
  /** Optional. Maximum number of the elements for Type.ARRAY. */
  maxItems: Long;
  /** Optional. Minimum number of the elements for Type.ARRAY. */
  minItems: Long;
  /** Optional. Properties of Type.OBJECT. */
  properties: { [key: string]: Schema };
  /** Optional. Required properties of Type.OBJECT. */
  required: string[];
}

export interface Schema_PropertiesEntry {
  key: string;
  value: Schema | undefined;
}

/** Passage included inline with a grounding configuration. */
export interface GroundingPassage {
  /**
   * Identifier for the passage for attributing this passage in grounded
   * answers.
   */
  id: string;
  /** Content of the passage. */
  content: Content | undefined;
}

/** A repeated list of passages. */
export interface GroundingPassages {
  /** List of passages. */
  passages: GroundingPassage[];
}

function createBaseContent(): Content {
  return { parts: [], role: "" };
}

export const Content: MessageFns<Content> = {
  encode(message: Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parts) {
      Part.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parts.push(Part.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content {
    return {
      parts: globalThis.Array.isArray(object?.parts) ? object.parts.map((e: any) => Part.fromJSON(e)) : [],
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: Content): unknown {
    const obj: any = {};
    if (message.parts?.length) {
      obj.parts = message.parts.map((e) => Part.toJSON(e));
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create(base?: DeepPartial<Content>): Content {
    return Content.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content>): Content {
    const message = createBaseContent();
    message.parts = object.parts?.map((e) => Part.fromPartial(e)) || [];
    message.role = object.role ?? "";
    return message;
  },
};

function createBasePart(): Part {
  return {
    text: undefined,
    inlineData: undefined,
    functionCall: undefined,
    functionResponse: undefined,
    fileData: undefined,
    executableCode: undefined,
    codeExecutionResult: undefined,
  };
}

export const Part: MessageFns<Part> = {
  encode(message: Part, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    if (message.inlineData !== undefined) {
      Blob.encode(message.inlineData, writer.uint32(26).fork()).join();
    }
    if (message.functionCall !== undefined) {
      FunctionCall.encode(message.functionCall, writer.uint32(34).fork()).join();
    }
    if (message.functionResponse !== undefined) {
      FunctionResponse.encode(message.functionResponse, writer.uint32(42).fork()).join();
    }
    if (message.fileData !== undefined) {
      FileData.encode(message.fileData, writer.uint32(50).fork()).join();
    }
    if (message.executableCode !== undefined) {
      ExecutableCode.encode(message.executableCode, writer.uint32(74).fork()).join();
    }
    if (message.codeExecutionResult !== undefined) {
      CodeExecutionResult.encode(message.codeExecutionResult, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Part {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inlineData = Blob.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.functionCall = FunctionCall.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.functionResponse = FunctionResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fileData = FileData.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.executableCode = ExecutableCode.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.codeExecutionResult = CodeExecutionResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Part {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      inlineData: isSet(object.inlineData) ? Blob.fromJSON(object.inlineData) : undefined,
      functionCall: isSet(object.functionCall) ? FunctionCall.fromJSON(object.functionCall) : undefined,
      functionResponse: isSet(object.functionResponse) ? FunctionResponse.fromJSON(object.functionResponse) : undefined,
      fileData: isSet(object.fileData) ? FileData.fromJSON(object.fileData) : undefined,
      executableCode: isSet(object.executableCode) ? ExecutableCode.fromJSON(object.executableCode) : undefined,
      codeExecutionResult: isSet(object.codeExecutionResult)
        ? CodeExecutionResult.fromJSON(object.codeExecutionResult)
        : undefined,
    };
  },

  toJSON(message: Part): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.inlineData !== undefined) {
      obj.inlineData = Blob.toJSON(message.inlineData);
    }
    if (message.functionCall !== undefined) {
      obj.functionCall = FunctionCall.toJSON(message.functionCall);
    }
    if (message.functionResponse !== undefined) {
      obj.functionResponse = FunctionResponse.toJSON(message.functionResponse);
    }
    if (message.fileData !== undefined) {
      obj.fileData = FileData.toJSON(message.fileData);
    }
    if (message.executableCode !== undefined) {
      obj.executableCode = ExecutableCode.toJSON(message.executableCode);
    }
    if (message.codeExecutionResult !== undefined) {
      obj.codeExecutionResult = CodeExecutionResult.toJSON(message.codeExecutionResult);
    }
    return obj;
  },

  create(base?: DeepPartial<Part>): Part {
    return Part.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Part>): Part {
    const message = createBasePart();
    message.text = object.text ?? undefined;
    message.inlineData = (object.inlineData !== undefined && object.inlineData !== null)
      ? Blob.fromPartial(object.inlineData)
      : undefined;
    message.functionCall = (object.functionCall !== undefined && object.functionCall !== null)
      ? FunctionCall.fromPartial(object.functionCall)
      : undefined;
    message.functionResponse = (object.functionResponse !== undefined && object.functionResponse !== null)
      ? FunctionResponse.fromPartial(object.functionResponse)
      : undefined;
    message.fileData = (object.fileData !== undefined && object.fileData !== null)
      ? FileData.fromPartial(object.fileData)
      : undefined;
    message.executableCode = (object.executableCode !== undefined && object.executableCode !== null)
      ? ExecutableCode.fromPartial(object.executableCode)
      : undefined;
    message.codeExecutionResult = (object.codeExecutionResult !== undefined && object.codeExecutionResult !== null)
      ? CodeExecutionResult.fromPartial(object.codeExecutionResult)
      : undefined;
    return message;
  },
};

function createBaseBlob(): Blob {
  return { mimeType: "", data: Buffer.alloc(0) };
}

export const Blob: MessageFns<Blob> = {
  encode(message: Blob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blob {
    return {
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Blob): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<Blob>): Blob {
    return Blob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blob>): Blob {
    const message = createBaseBlob();
    message.mimeType = object.mimeType ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseFileData(): FileData {
  return { mimeType: "", fileUri: "" };
}

export const FileData: MessageFns<FileData> = {
  encode(message: FileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mimeType !== "") {
      writer.uint32(10).string(message.mimeType);
    }
    if (message.fileUri !== "") {
      writer.uint32(18).string(message.fileUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileData {
    return {
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      fileUri: isSet(object.fileUri) ? globalThis.String(object.fileUri) : "",
    };
  },

  toJSON(message: FileData): unknown {
    const obj: any = {};
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.fileUri !== "") {
      obj.fileUri = message.fileUri;
    }
    return obj;
  },

  create(base?: DeepPartial<FileData>): FileData {
    return FileData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileData>): FileData {
    const message = createBaseFileData();
    message.mimeType = object.mimeType ?? "";
    message.fileUri = object.fileUri ?? "";
    return message;
  },
};

function createBaseExecutableCode(): ExecutableCode {
  return { language: 0, code: "" };
}

export const ExecutableCode: MessageFns<ExecutableCode> = {
  encode(message: ExecutableCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== 0) {
      writer.uint32(8).int32(message.language);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutableCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutableCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutableCode {
    return {
      language: isSet(object.language) ? executableCode_LanguageFromJSON(object.language) : 0,
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: ExecutableCode): unknown {
    const obj: any = {};
    if (message.language !== 0) {
      obj.language = executableCode_LanguageToJSON(message.language);
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutableCode>): ExecutableCode {
    return ExecutableCode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutableCode>): ExecutableCode {
    const message = createBaseExecutableCode();
    message.language = object.language ?? 0;
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseCodeExecutionResult(): CodeExecutionResult {
  return { outcome: 0, output: "" };
}

export const CodeExecutionResult: MessageFns<CodeExecutionResult> = {
  encode(message: CodeExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outcome !== 0) {
      writer.uint32(8).int32(message.outcome);
    }
    if (message.output !== "") {
      writer.uint32(18).string(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.outcome = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeExecutionResult {
    return {
      outcome: isSet(object.outcome) ? codeExecutionResult_OutcomeFromJSON(object.outcome) : 0,
      output: isSet(object.output) ? globalThis.String(object.output) : "",
    };
  },

  toJSON(message: CodeExecutionResult): unknown {
    const obj: any = {};
    if (message.outcome !== 0) {
      obj.outcome = codeExecutionResult_OutcomeToJSON(message.outcome);
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    return obj;
  },

  create(base?: DeepPartial<CodeExecutionResult>): CodeExecutionResult {
    return CodeExecutionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CodeExecutionResult>): CodeExecutionResult {
    const message = createBaseCodeExecutionResult();
    message.outcome = object.outcome ?? 0;
    message.output = object.output ?? "";
    return message;
  },
};

function createBaseTool(): Tool {
  return { functionDeclarations: [], googleSearchRetrieval: undefined, codeExecution: undefined };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.functionDeclarations) {
      FunctionDeclaration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.googleSearchRetrieval !== undefined) {
      GoogleSearchRetrieval.encode(message.googleSearchRetrieval, writer.uint32(18).fork()).join();
    }
    if (message.codeExecution !== undefined) {
      CodeExecution.encode(message.codeExecution, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionDeclarations.push(FunctionDeclaration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.googleSearchRetrieval = GoogleSearchRetrieval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.codeExecution = CodeExecution.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      functionDeclarations: globalThis.Array.isArray(object?.functionDeclarations)
        ? object.functionDeclarations.map((e: any) => FunctionDeclaration.fromJSON(e))
        : [],
      googleSearchRetrieval: isSet(object.googleSearchRetrieval)
        ? GoogleSearchRetrieval.fromJSON(object.googleSearchRetrieval)
        : undefined,
      codeExecution: isSet(object.codeExecution) ? CodeExecution.fromJSON(object.codeExecution) : undefined,
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.functionDeclarations?.length) {
      obj.functionDeclarations = message.functionDeclarations.map((e) => FunctionDeclaration.toJSON(e));
    }
    if (message.googleSearchRetrieval !== undefined) {
      obj.googleSearchRetrieval = GoogleSearchRetrieval.toJSON(message.googleSearchRetrieval);
    }
    if (message.codeExecution !== undefined) {
      obj.codeExecution = CodeExecution.toJSON(message.codeExecution);
    }
    return obj;
  },

  create(base?: DeepPartial<Tool>): Tool {
    return Tool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tool>): Tool {
    const message = createBaseTool();
    message.functionDeclarations = object.functionDeclarations?.map((e) => FunctionDeclaration.fromPartial(e)) || [];
    message.googleSearchRetrieval =
      (object.googleSearchRetrieval !== undefined && object.googleSearchRetrieval !== null)
        ? GoogleSearchRetrieval.fromPartial(object.googleSearchRetrieval)
        : undefined;
    message.codeExecution = (object.codeExecution !== undefined && object.codeExecution !== null)
      ? CodeExecution.fromPartial(object.codeExecution)
      : undefined;
    return message;
  },
};

function createBaseGoogleSearchRetrieval(): GoogleSearchRetrieval {
  return { dynamicRetrievalConfig: undefined };
}

export const GoogleSearchRetrieval: MessageFns<GoogleSearchRetrieval> = {
  encode(message: GoogleSearchRetrieval, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dynamicRetrievalConfig !== undefined) {
      DynamicRetrievalConfig.encode(message.dynamicRetrievalConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleSearchRetrieval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleSearchRetrieval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dynamicRetrievalConfig = DynamicRetrievalConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleSearchRetrieval {
    return {
      dynamicRetrievalConfig: isSet(object.dynamicRetrievalConfig)
        ? DynamicRetrievalConfig.fromJSON(object.dynamicRetrievalConfig)
        : undefined,
    };
  },

  toJSON(message: GoogleSearchRetrieval): unknown {
    const obj: any = {};
    if (message.dynamicRetrievalConfig !== undefined) {
      obj.dynamicRetrievalConfig = DynamicRetrievalConfig.toJSON(message.dynamicRetrievalConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    return GoogleSearchRetrieval.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GoogleSearchRetrieval>): GoogleSearchRetrieval {
    const message = createBaseGoogleSearchRetrieval();
    message.dynamicRetrievalConfig =
      (object.dynamicRetrievalConfig !== undefined && object.dynamicRetrievalConfig !== null)
        ? DynamicRetrievalConfig.fromPartial(object.dynamicRetrievalConfig)
        : undefined;
    return message;
  },
};

function createBaseDynamicRetrievalConfig(): DynamicRetrievalConfig {
  return { mode: 0, dynamicThreshold: undefined };
}

export const DynamicRetrievalConfig: MessageFns<DynamicRetrievalConfig> = {
  encode(message: DynamicRetrievalConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.dynamicThreshold !== undefined) {
      writer.uint32(21).float(message.dynamicThreshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DynamicRetrievalConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDynamicRetrievalConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.dynamicThreshold = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DynamicRetrievalConfig {
    return {
      mode: isSet(object.mode) ? dynamicRetrievalConfig_ModeFromJSON(object.mode) : 0,
      dynamicThreshold: isSet(object.dynamicThreshold) ? globalThis.Number(object.dynamicThreshold) : undefined,
    };
  },

  toJSON(message: DynamicRetrievalConfig): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = dynamicRetrievalConfig_ModeToJSON(message.mode);
    }
    if (message.dynamicThreshold !== undefined) {
      obj.dynamicThreshold = message.dynamicThreshold;
    }
    return obj;
  },

  create(base?: DeepPartial<DynamicRetrievalConfig>): DynamicRetrievalConfig {
    return DynamicRetrievalConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DynamicRetrievalConfig>): DynamicRetrievalConfig {
    const message = createBaseDynamicRetrievalConfig();
    message.mode = object.mode ?? 0;
    message.dynamicThreshold = object.dynamicThreshold ?? undefined;
    return message;
  },
};

function createBaseCodeExecution(): CodeExecution {
  return {};
}

export const CodeExecution: MessageFns<CodeExecution> = {
  encode(_: CodeExecution, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeExecution {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeExecution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CodeExecution {
    return {};
  },

  toJSON(_: CodeExecution): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CodeExecution>): CodeExecution {
    return CodeExecution.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CodeExecution>): CodeExecution {
    const message = createBaseCodeExecution();
    return message;
  },
};

function createBaseToolConfig(): ToolConfig {
  return { functionCallingConfig: undefined };
}

export const ToolConfig: MessageFns<ToolConfig> = {
  encode(message: ToolConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.functionCallingConfig !== undefined) {
      FunctionCallingConfig.encode(message.functionCallingConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionCallingConfig = FunctionCallingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolConfig {
    return {
      functionCallingConfig: isSet(object.functionCallingConfig)
        ? FunctionCallingConfig.fromJSON(object.functionCallingConfig)
        : undefined,
    };
  },

  toJSON(message: ToolConfig): unknown {
    const obj: any = {};
    if (message.functionCallingConfig !== undefined) {
      obj.functionCallingConfig = FunctionCallingConfig.toJSON(message.functionCallingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ToolConfig>): ToolConfig {
    return ToolConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ToolConfig>): ToolConfig {
    const message = createBaseToolConfig();
    message.functionCallingConfig =
      (object.functionCallingConfig !== undefined && object.functionCallingConfig !== null)
        ? FunctionCallingConfig.fromPartial(object.functionCallingConfig)
        : undefined;
    return message;
  },
};

function createBaseFunctionCallingConfig(): FunctionCallingConfig {
  return { mode: 0, allowedFunctionNames: [] };
}

export const FunctionCallingConfig: MessageFns<FunctionCallingConfig> = {
  encode(message: FunctionCallingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    for (const v of message.allowedFunctionNames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCallingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCallingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedFunctionNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCallingConfig {
    return {
      mode: isSet(object.mode) ? functionCallingConfig_ModeFromJSON(object.mode) : 0,
      allowedFunctionNames: globalThis.Array.isArray(object?.allowedFunctionNames)
        ? object.allowedFunctionNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FunctionCallingConfig): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = functionCallingConfig_ModeToJSON(message.mode);
    }
    if (message.allowedFunctionNames?.length) {
      obj.allowedFunctionNames = message.allowedFunctionNames;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    return FunctionCallingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCallingConfig>): FunctionCallingConfig {
    const message = createBaseFunctionCallingConfig();
    message.mode = object.mode ?? 0;
    message.allowedFunctionNames = object.allowedFunctionNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseFunctionDeclaration(): FunctionDeclaration {
  return { name: "", description: "", parameters: undefined };
}

export const FunctionDeclaration: MessageFns<FunctionDeclaration> = {
  encode(message: FunctionDeclaration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parameters !== undefined) {
      Schema.encode(message.parameters, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionDeclaration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionDeclaration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parameters = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionDeclaration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isSet(object.parameters) ? Schema.fromJSON(object.parameters) : undefined,
    };
  },

  toJSON(message: FunctionDeclaration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters !== undefined) {
      obj.parameters = Schema.toJSON(message.parameters);
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    return FunctionDeclaration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionDeclaration>): FunctionDeclaration {
    const message = createBaseFunctionDeclaration();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = (object.parameters !== undefined && object.parameters !== null)
      ? Schema.fromPartial(object.parameters)
      : undefined;
    return message;
  },
};

function createBaseFunctionCall(): FunctionCall {
  return { name: "", args: undefined };
}

export const FunctionCall: MessageFns<FunctionCall> = {
  encode(message: FunctionCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.args !== undefined) {
      Struct.encode(Struct.wrap(message.args), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionCall {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      args: isObject(object.args) ? object.args : undefined,
    };
  },

  toJSON(message: FunctionCall): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.args !== undefined) {
      obj.args = message.args;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionCall>): FunctionCall {
    return FunctionCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionCall>): FunctionCall {
    const message = createBaseFunctionCall();
    message.name = object.name ?? "";
    message.args = object.args ?? undefined;
    return message;
  },
};

function createBaseFunctionResponse(): FunctionResponse {
  return { name: "", response: undefined };
}

export const FunctionResponse: MessageFns<FunctionResponse> = {
  encode(message: FunctionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.response !== undefined) {
      Struct.encode(Struct.wrap(message.response), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FunctionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFunctionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.response = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FunctionResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      response: isObject(object.response) ? object.response : undefined,
    };
  },

  toJSON(message: FunctionResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.response !== undefined) {
      obj.response = message.response;
    }
    return obj;
  },

  create(base?: DeepPartial<FunctionResponse>): FunctionResponse {
    return FunctionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FunctionResponse>): FunctionResponse {
    const message = createBaseFunctionResponse();
    message.name = object.name ?? "";
    message.response = object.response ?? undefined;
    return message;
  },
};

function createBaseSchema(): Schema {
  return {
    type: 0,
    format: "",
    description: "",
    nullable: false,
    enum: [],
    items: undefined,
    maxItems: Long.ZERO,
    minItems: Long.ZERO,
    properties: {},
    required: [],
  };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.nullable !== false) {
      writer.uint32(32).bool(message.nullable);
    }
    for (const v of message.enum) {
      writer.uint32(42).string(v!);
    }
    if (message.items !== undefined) {
      Schema.encode(message.items, writer.uint32(50).fork()).join();
    }
    if (!message.maxItems.equals(Long.ZERO)) {
      writer.uint32(168).int64(message.maxItems.toString());
    }
    if (!message.minItems.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.minItems.toString());
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Schema_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.required) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.enum.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.items = Schema.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.maxItems = Long.fromString(reader.int64().toString());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.minItems = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Schema_PropertiesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.properties[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.required.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      type: isSet(object.type) ? typeFromJSON(object.type) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      enum: globalThis.Array.isArray(object?.enum) ? object.enum.map((e: any) => globalThis.String(e)) : [],
      items: isSet(object.items) ? Schema.fromJSON(object.items) : undefined,
      maxItems: isSet(object.maxItems) ? Long.fromValue(object.maxItems) : Long.ZERO,
      minItems: isSet(object.minItems) ? Long.fromValue(object.minItems) : Long.ZERO,
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Schema }>((acc, [key, value]) => {
          acc[key] = Schema.fromJSON(value);
          return acc;
        }, {})
        : {},
      required: globalThis.Array.isArray(object?.required) ? object.required.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = typeToJSON(message.type);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.enum?.length) {
      obj.enum = message.enum;
    }
    if (message.items !== undefined) {
      obj.items = Schema.toJSON(message.items);
    }
    if (!message.maxItems.equals(Long.ZERO)) {
      obj.maxItems = (message.maxItems || Long.ZERO).toString();
    }
    if (!message.minItems.equals(Long.ZERO)) {
      obj.minItems = (message.minItems || Long.ZERO).toString();
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = Schema.toJSON(v);
        });
      }
    }
    if (message.required?.length) {
      obj.required = message.required;
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.type = object.type ?? 0;
    message.format = object.format ?? "";
    message.description = object.description ?? "";
    message.nullable = object.nullable ?? false;
    message.enum = object.enum?.map((e) => e) || [];
    message.items = (object.items !== undefined && object.items !== null)
      ? Schema.fromPartial(object.items)
      : undefined;
    message.maxItems = (object.maxItems !== undefined && object.maxItems !== null)
      ? Long.fromValue(object.maxItems)
      : Long.ZERO;
    message.minItems = (object.minItems !== undefined && object.minItems !== null)
      ? Long.fromValue(object.minItems)
      : Long.ZERO;
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Schema }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Schema.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.required = object.required?.map((e) => e) || [];
    return message;
  },
};

function createBaseSchema_PropertiesEntry(): Schema_PropertiesEntry {
  return { key: "", value: undefined };
}

export const Schema_PropertiesEntry: MessageFns<Schema_PropertiesEntry> = {
  encode(message: Schema_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Schema.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Schema.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Schema.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Schema_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Schema.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Schema_PropertiesEntry>): Schema_PropertiesEntry {
    return Schema_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema_PropertiesEntry>): Schema_PropertiesEntry {
    const message = createBaseSchema_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Schema.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGroundingPassage(): GroundingPassage {
  return { id: "", content: undefined };
}

export const GroundingPassage: MessageFns<GroundingPassage> = {
  encode(message: GroundingPassage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.content !== undefined) {
      Content.encode(message.content, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingPassage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingPassage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = Content.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingPassage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      content: isSet(object.content) ? Content.fromJSON(object.content) : undefined,
    };
  },

  toJSON(message: GroundingPassage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.content !== undefined) {
      obj.content = Content.toJSON(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingPassage>): GroundingPassage {
    return GroundingPassage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingPassage>): GroundingPassage {
    const message = createBaseGroundingPassage();
    message.id = object.id ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? Content.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseGroundingPassages(): GroundingPassages {
  return { passages: [] };
}

export const GroundingPassages: MessageFns<GroundingPassages> = {
  encode(message: GroundingPassages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.passages) {
      GroundingPassage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroundingPassages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroundingPassages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.passages.push(GroundingPassage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroundingPassages {
    return {
      passages: globalThis.Array.isArray(object?.passages)
        ? object.passages.map((e: any) => GroundingPassage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroundingPassages): unknown {
    const obj: any = {};
    if (message.passages?.length) {
      obj.passages = message.passages.map((e) => GroundingPassage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GroundingPassages>): GroundingPassages {
    return GroundingPassages.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroundingPassages>): GroundingPassages {
    const message = createBaseGroundingPassages();
    message.passages = object.passages?.map((e) => GroundingPassage.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
