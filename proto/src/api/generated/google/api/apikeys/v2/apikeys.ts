// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/api/apikeys/v2/apikeys.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Key } from "./resources.js";

export const protobufPackage = "google.api.apikeys.v2";

/** Request message for `CreateKey` method. */
export interface CreateKeyRequest {
  /** Required. The project in which the API key is created. */
  parent: string;
  /**
   * Required. The API key fields to set at creation time.
   * You can configure only the `display_name`, `restrictions`, and
   * `annotations` fields.
   */
  key:
    | Key
    | undefined;
  /**
   * User specified key id (optional). If specified, it will become the final
   * component of the key resource name.
   *
   * The id must be unique within the project, must conform with RFC-1034,
   * is restricted to lower-cased letters, and has a maximum length of 63
   * characters. In another word, the id must match the regular
   * expression: `[a-z]([a-z0-9-]{0,61}[a-z0-9])?`.
   *
   * The id must NOT be a UUID-like string.
   */
  keyId: string;
}

/** Request message for `ListKeys` method. */
export interface ListKeysRequest {
  /** Required. Lists all API keys associated with this project. */
  parent: string;
  /** Optional. Specifies the maximum number of results to be returned at a time. */
  pageSize: number;
  /** Optional. Requests a specific page of results. */
  pageToken: string;
  /**
   * Optional. Indicate that keys deleted in the past 30 days should also be
   * returned.
   */
  showDeleted: boolean;
}

/** Response message for `ListKeys` method. */
export interface ListKeysResponse {
  /** A list of API keys. */
  keys: Key[];
  /** The pagination token for the next page of results. */
  nextPageToken: string;
}

/** Request message for `GetKey` method. */
export interface GetKeyRequest {
  /** Required. The resource name of the API key to get. */
  name: string;
}

/** Request message for `GetKeyString` method. */
export interface GetKeyStringRequest {
  /** Required. The resource name of the API key to be retrieved. */
  name: string;
}

/** Response message for `GetKeyString` method. */
export interface GetKeyStringResponse {
  /** An encrypted and signed value of the key. */
  keyString: string;
}

/** Request message for `UpdateKey` method. */
export interface UpdateKeyRequest {
  /**
   * Required. Set the `name` field to the resource name of the API key to be
   * updated. You can update only the `display_name`, `restrictions`, and
   * `annotations` fields.
   */
  key:
    | Key
    | undefined;
  /**
   * The field mask specifies which fields to be updated as part of this
   * request. All other fields are ignored.
   * Mutable fields are: `display_name`, `restrictions`, and `annotations`.
   * If an update mask is not provided, the service treats it as an implied mask
   * equivalent to all allowed fields that are set on the wire. If the field
   * mask has a special value "*", the service treats it equivalent to replace
   * all allowed mutable fields.
   */
  updateMask: string[] | undefined;
}

/** Request message for `DeleteKey` method. */
export interface DeleteKeyRequest {
  /** Required. The resource name of the API key to be deleted. */
  name: string;
  /**
   * Optional. The etag known to the client for the expected state of the key.
   * This is to be used for optimistic concurrency.
   */
  etag: string;
}

/** Request message for `UndeleteKey` method. */
export interface UndeleteKeyRequest {
  /** Required. The resource name of the API key to be undeleted. */
  name: string;
}

/** Request message for `LookupKey` method. */
export interface LookupKeyRequest {
  /** Required. Finds the project that owns the key string value. */
  keyString: string;
}

/** Response message for `LookupKey` method. */
export interface LookupKeyResponse {
  /** The project that owns the key with the value specified in the request. */
  parent: string;
  /**
   * The resource name of the API key. If the API key has been purged,
   * resource name is empty.
   */
  name: string;
}

function createBaseCreateKeyRequest(): CreateKeyRequest {
  return { parent: "", key: undefined, keyId: "" };
}

export const CreateKeyRequest: MessageFns<CreateKeyRequest> = {
  encode(message: CreateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(18).fork()).join();
    }
    if (message.keyId !== "") {
      writer.uint32(26).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateKeyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "",
    };
  },

  toJSON(message: CreateKeyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateKeyRequest>): CreateKeyRequest {
    return CreateKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateKeyRequest>): CreateKeyRequest {
    const message = createBaseCreateKeyRequest();
    message.parent = object.parent ?? "";
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseListKeysRequest(): ListKeysRequest {
  return { parent: "", pageSize: 0, pageToken: "", showDeleted: false };
}

export const ListKeysRequest: MessageFns<ListKeysRequest> = {
  encode(message: ListKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.showDeleted !== false) {
      writer.uint32(48).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeysRequest>): ListKeysRequest {
    return ListKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeysRequest>): ListKeysRequest {
    const message = createBaseListKeysRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListKeysResponse(): ListKeysResponse {
  return { keys: [], nextPageToken: "" };
}

export const ListKeysResponse: MessageFns<ListKeysResponse> = {
  encode(message: ListKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      Key.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Key.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListKeysResponse {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Key.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Key.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListKeysResponse>): ListKeysResponse {
    return ListKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListKeysResponse>): ListKeysResponse {
    const message = createBaseListKeysResponse();
    message.keys = object.keys?.map((e) => Key.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetKeyRequest(): GetKeyRequest {
  return { name: "" };
}

export const GetKeyRequest: MessageFns<GetKeyRequest> = {
  encode(message: GetKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKeyRequest>): GetKeyRequest {
    return GetKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKeyRequest>): GetKeyRequest {
    const message = createBaseGetKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetKeyStringRequest(): GetKeyStringRequest {
  return { name: "" };
}

export const GetKeyStringRequest: MessageFns<GetKeyStringRequest> = {
  encode(message: GetKeyStringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyStringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyStringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyStringRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetKeyStringRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKeyStringRequest>): GetKeyStringRequest {
    return GetKeyStringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKeyStringRequest>): GetKeyStringRequest {
    const message = createBaseGetKeyStringRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetKeyStringResponse(): GetKeyStringResponse {
  return { keyString: "" };
}

export const GetKeyStringResponse: MessageFns<GetKeyStringResponse> = {
  encode(message: GetKeyStringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyString !== "") {
      writer.uint32(10).string(message.keyString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetKeyStringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetKeyStringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetKeyStringResponse {
    return { keyString: isSet(object.keyString) ? globalThis.String(object.keyString) : "" };
  },

  toJSON(message: GetKeyStringResponse): unknown {
    const obj: any = {};
    if (message.keyString !== "") {
      obj.keyString = message.keyString;
    }
    return obj;
  },

  create(base?: DeepPartial<GetKeyStringResponse>): GetKeyStringResponse {
    return GetKeyStringResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetKeyStringResponse>): GetKeyStringResponse {
    const message = createBaseGetKeyStringResponse();
    message.keyString = object.keyString ?? "";
    return message;
  },
};

function createBaseUpdateKeyRequest(): UpdateKeyRequest {
  return { key: undefined, updateMask: undefined };
}

export const UpdateKeyRequest: MessageFns<UpdateKeyRequest> = {
  encode(message: UpdateKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      Key.encode(message.key, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = Key.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateKeyRequest {
    return {
      key: isSet(object.key) ? Key.fromJSON(object.key) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateKeyRequest): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = Key.toJSON(message.key);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateKeyRequest>): UpdateKeyRequest {
    return UpdateKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateKeyRequest>): UpdateKeyRequest {
    const message = createBaseUpdateKeyRequest();
    message.key = (object.key !== undefined && object.key !== null) ? Key.fromPartial(object.key) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteKeyRequest(): DeleteKeyRequest {
  return { name: "", etag: "" };
}

export const DeleteKeyRequest: MessageFns<DeleteKeyRequest> = {
  encode(message: DeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteKeyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteKeyRequest>): DeleteKeyRequest {
    return DeleteKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteKeyRequest>): DeleteKeyRequest {
    const message = createBaseDeleteKeyRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseUndeleteKeyRequest(): UndeleteKeyRequest {
  return { name: "" };
}

export const UndeleteKeyRequest: MessageFns<UndeleteKeyRequest> = {
  encode(message: UndeleteKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeleteKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeleteKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeleteKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: UndeleteKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeleteKeyRequest>): UndeleteKeyRequest {
    return UndeleteKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeleteKeyRequest>): UndeleteKeyRequest {
    const message = createBaseUndeleteKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLookupKeyRequest(): LookupKeyRequest {
  return { keyString: "" };
}

export const LookupKeyRequest: MessageFns<LookupKeyRequest> = {
  encode(message: LookupKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyString !== "") {
      writer.uint32(10).string(message.keyString);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupKeyRequest {
    return { keyString: isSet(object.keyString) ? globalThis.String(object.keyString) : "" };
  },

  toJSON(message: LookupKeyRequest): unknown {
    const obj: any = {};
    if (message.keyString !== "") {
      obj.keyString = message.keyString;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupKeyRequest>): LookupKeyRequest {
    return LookupKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupKeyRequest>): LookupKeyRequest {
    const message = createBaseLookupKeyRequest();
    message.keyString = object.keyString ?? "";
    return message;
  },
};

function createBaseLookupKeyResponse(): LookupKeyResponse {
  return { parent: "", name: "" };
}

export const LookupKeyResponse: MessageFns<LookupKeyResponse> = {
  encode(message: LookupKeyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupKeyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupKeyResponse {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: LookupKeyResponse): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupKeyResponse>): LookupKeyResponse {
    return LookupKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupKeyResponse>): LookupKeyResponse {
    const message = createBaseLookupKeyResponse();
    message.parent = object.parent ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

/** Manages the API keys associated with projects. */
export type ApiKeysDefinition = typeof ApiKeysDefinition;
export const ApiKeysDefinition = {
  name: "ApiKeys",
  fullName: "google.api.apikeys.v2.ApiKeys",
  methods: {
    /**
     * Creates a new API key.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    createKey: {
      name: "CreateKey",
      requestType: CreateKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              3,
              75,
              101,
              121,
              18,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
            ]),
          ],
          8410: [Buffer.from([17, 112, 97, 114, 101, 110, 116, 44, 107, 101, 121, 44, 107, 101, 121, 95, 105, 100])],
          578365826: [
            Buffer.from([
              47,
              58,
              3,
              107,
              101,
              121,
              34,
              40,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the API keys owned by a project. The key string of the API key
     * isn't included in the response.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    listKeys: {
      name: "ListKeys",
      requestType: ListKeysRequest,
      requestStream: false,
      responseType: ListKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the metadata for an API key. The key string of the API key
     * isn't included in the response.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    getKey: {
      name: "GetKey",
      requestType: GetKeyRequest,
      requestStream: false,
      responseType: Key,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Get the key string for an API key.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    getKeyString: {
      name: "GetKeyString",
      requestType: GetKeyStringRequest,
      requestStream: false,
      responseType: GetKeyStringResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              47,
              107,
              101,
              121,
              83,
              116,
              114,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /**
     * Patches the modifiable fields of an API key.
     * The key string of the API key isn't included in the response.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    updateKey: {
      name: "UpdateKey",
      requestType: UpdateKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              3,
              75,
              101,
              121,
              18,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
            ]),
          ],
          8410: [Buffer.from([15, 107, 101, 121, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              51,
              58,
              3,
              107,
              101,
              121,
              50,
              44,
              47,
              118,
              50,
              47,
              123,
              107,
              101,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes an API key. Deleted key can be retrieved within 30 days of
     * deletion. Afterward, key will be purged from the project.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    deleteKey: {
      name: "DeleteKey",
      requestType: DeleteKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              3,
              75,
              101,
              121,
              18,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              42,
              42,
              40,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Undeletes an API key which was deleted within 30 days.
     *
     * NOTE: Key is a global resource; hence the only supported value for
     * location is `global`.
     */
    undeleteKey: {
      name: "UndeleteKey",
      requestType: UndeleteKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              3,
              75,
              101,
              121,
              18,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              54,
              58,
              1,
              42,
              34,
              49,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              107,
              101,
              121,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Find the parent project and resource name of the API
     * key that matches the key string in the request. If the API key has been
     * purged, resource name will not be set.
     * The service account must have the `apikeys.keys.lookup` permission
     * on the parent project.
     */
    lookupKey: {
      name: "LookupKey",
      requestType: LookupKeyRequest,
      requestStream: false,
      responseType: LookupKeyResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              20,
              18,
              18,
              47,
              118,
              50,
              47,
              107,
              101,
              121,
              115,
              58,
              108,
              111,
              111,
              107,
              117,
              112,
              75,
              101,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ApiKeysServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  createKey(request: CreateKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Lists the API keys owned by a project. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  listKeys(request: ListKeysRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListKeysResponse>>;
  /**
   * Gets the metadata for an API key. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  getKey(request: GetKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Key>>;
  /**
   * Get the key string for an API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  getKeyString(
    request: GetKeyStringRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetKeyStringResponse>>;
  /**
   * Patches the modifiable fields of an API key.
   * The key string of the API key isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  updateKey(request: UpdateKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes an API key. Deleted key can be retrieved within 30 days of
   * deletion. Afterward, key will be purged from the project.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  deleteKey(request: DeleteKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Undeletes an API key which was deleted within 30 days.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  undeleteKey(request: UndeleteKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Find the parent project and resource name of the API
   * key that matches the key string in the request. If the API key has been
   * purged, resource name will not be set.
   * The service account must have the `apikeys.keys.lookup` permission
   * on the parent project.
   */
  lookupKey(request: LookupKeyRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LookupKeyResponse>>;
}

export interface ApiKeysClient<CallOptionsExt = {}> {
  /**
   * Creates a new API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  createKey(request: DeepPartial<CreateKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Lists the API keys owned by a project. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  listKeys(request: DeepPartial<ListKeysRequest>, options?: CallOptions & CallOptionsExt): Promise<ListKeysResponse>;
  /**
   * Gets the metadata for an API key. The key string of the API key
   * isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  getKey(request: DeepPartial<GetKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Key>;
  /**
   * Get the key string for an API key.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  getKeyString(
    request: DeepPartial<GetKeyStringRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetKeyStringResponse>;
  /**
   * Patches the modifiable fields of an API key.
   * The key string of the API key isn't included in the response.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  updateKey(request: DeepPartial<UpdateKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes an API key. Deleted key can be retrieved within 30 days of
   * deletion. Afterward, key will be purged from the project.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  deleteKey(request: DeepPartial<DeleteKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Undeletes an API key which was deleted within 30 days.
   *
   * NOTE: Key is a global resource; hence the only supported value for
   * location is `global`.
   */
  undeleteKey(request: DeepPartial<UndeleteKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Find the parent project and resource name of the API
   * key that matches the key string in the request. If the API key has been
   * purged, resource name will not be set.
   * The service account must have the `apikeys.keys.lookup` permission
   * on the parent project.
   */
  lookupKey(request: DeepPartial<LookupKeyRequest>, options?: CallOptions & CallOptionsExt): Promise<LookupKeyResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
