// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/iam/v2/deny.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Expr } from "../../type/expr.js";

export const protobufPackage = "google.iam.v2";

/** A deny rule in an IAM deny policy. */
export interface DenyRule {
  /**
   * The identities that are prevented from using one or more permissions on
   * Google Cloud resources. This field can contain the following values:
   *
   * * `principalSet://goog/public:all`: A special identifier that represents
   *   any principal that is on the internet, even if they do not have a Google
   *   Account or are not logged in.
   *
   * * `principal://goog/subject/{email_id}`: A specific Google Account.
   *   Includes Gmail, Cloud Identity, and Google Workspace user accounts. For
   *   example, `principal://goog/subject/alice@example.com`.
   *
   * * `deleted:principal://goog/subject/{email_id}?uid={uid}`: A specific
   *   Google Account that was deleted recently. For example,
   *   `deleted:principal://goog/subject/alice@example.com?uid=1234567890`. If
   *   the Google Account is recovered, this identifier reverts to the standard
   *   identifier for a Google Account.
   *
   * * `principalSet://goog/group/{group_id}`: A Google group. For example,
   *   `principalSet://goog/group/admins@example.com`.
   *
   * * `deleted:principalSet://goog/group/{group_id}?uid={uid}`: A Google group
   *   that was deleted recently. For example,
   *   `deleted:principalSet://goog/group/admins@example.com?uid=1234567890`. If
   *   the Google group is restored, this identifier reverts to the standard
   *   identifier for a Google group.
   *
   * * `principal://iam.googleapis.com/projects/-/serviceAccounts/{service_account_id}`:
   *   A Google Cloud service account. For example,
   *   `principal://iam.googleapis.com/projects/-/serviceAccounts/my-service-account@iam.gserviceaccount.com`.
   *
   * * `deleted:principal://iam.googleapis.com/projects/-/serviceAccounts/{service_account_id}?uid={uid}`:
   *   A Google Cloud service account that was deleted recently. For example,
   *   `deleted:principal://iam.googleapis.com/projects/-/serviceAccounts/my-service-account@iam.gserviceaccount.com?uid=1234567890`.
   *   If the service account is undeleted, this identifier reverts to the
   *   standard identifier for a service account.
   *
   * * `principalSet://goog/cloudIdentityCustomerId/{customer_id}`: All of the
   *   principals associated with the specified Google Workspace or Cloud
   *   Identity customer ID. For example,
   *   `principalSet://goog/cloudIdentityCustomerId/C01Abc35`.
   */
  deniedPrincipals: string[];
  /**
   * The identities that are excluded from the deny rule, even if they are
   * listed in the `denied_principals`. For example, you could add a Google
   * group to the `denied_principals`, then exclude specific users who belong to
   * that group.
   *
   * This field can contain the same values as the `denied_principals` field,
   * excluding `principalSet://goog/public:all`, which represents all users on
   * the internet.
   */
  exceptionPrincipals: string[];
  /**
   * The permissions that are explicitly denied by this rule. Each permission
   * uses the format `{service_fqdn}/{resource}.{verb}`, where `{service_fqdn}`
   * is the fully qualified domain name for the service. For example,
   * `iam.googleapis.com/roles.list`.
   */
  deniedPermissions: string[];
  /**
   * Specifies the permissions that this rule excludes from the set of denied
   * permissions given by `denied_permissions`. If a permission appears in
   * `denied_permissions` _and_ in `exception_permissions` then it will _not_ be
   * denied.
   *
   * The excluded permissions can be specified using the same syntax as
   * `denied_permissions`.
   */
  exceptionPermissions: string[];
  /**
   * The condition that determines whether this deny rule applies to a request.
   * If the condition expression evaluates to `true`, then the deny rule is
   * applied; otherwise, the deny rule is not applied.
   *
   * Each deny rule is evaluated independently. If this deny rule does not apply
   * to a request, other deny rules might still apply.
   *
   * The condition can use CEL functions that evaluate
   * [resource
   * tags](https://cloud.google.com/iam/help/conditions/resource-tags). Other
   * functions and operators are not supported.
   */
  denialCondition: Expr | undefined;
}

function createBaseDenyRule(): DenyRule {
  return {
    deniedPrincipals: [],
    exceptionPrincipals: [],
    deniedPermissions: [],
    exceptionPermissions: [],
    denialCondition: undefined,
  };
}

export const DenyRule: MessageFns<DenyRule> = {
  encode(message: DenyRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deniedPrincipals) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.exceptionPrincipals) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.deniedPermissions) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.exceptionPermissions) {
      writer.uint32(34).string(v!);
    }
    if (message.denialCondition !== undefined) {
      Expr.encode(message.denialCondition, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DenyRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDenyRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deniedPrincipals.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exceptionPrincipals.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deniedPermissions.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exceptionPermissions.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.denialCondition = Expr.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DenyRule {
    return {
      deniedPrincipals: globalThis.Array.isArray(object?.deniedPrincipals)
        ? object.deniedPrincipals.map((e: any) => globalThis.String(e))
        : [],
      exceptionPrincipals: globalThis.Array.isArray(object?.exceptionPrincipals)
        ? object.exceptionPrincipals.map((e: any) => globalThis.String(e))
        : [],
      deniedPermissions: globalThis.Array.isArray(object?.deniedPermissions)
        ? object.deniedPermissions.map((e: any) => globalThis.String(e))
        : [],
      exceptionPermissions: globalThis.Array.isArray(object?.exceptionPermissions)
        ? object.exceptionPermissions.map((e: any) => globalThis.String(e))
        : [],
      denialCondition: isSet(object.denialCondition) ? Expr.fromJSON(object.denialCondition) : undefined,
    };
  },

  toJSON(message: DenyRule): unknown {
    const obj: any = {};
    if (message.deniedPrincipals?.length) {
      obj.deniedPrincipals = message.deniedPrincipals;
    }
    if (message.exceptionPrincipals?.length) {
      obj.exceptionPrincipals = message.exceptionPrincipals;
    }
    if (message.deniedPermissions?.length) {
      obj.deniedPermissions = message.deniedPermissions;
    }
    if (message.exceptionPermissions?.length) {
      obj.exceptionPermissions = message.exceptionPermissions;
    }
    if (message.denialCondition !== undefined) {
      obj.denialCondition = Expr.toJSON(message.denialCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<DenyRule>): DenyRule {
    return DenyRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DenyRule>): DenyRule {
    const message = createBaseDenyRule();
    message.deniedPrincipals = object.deniedPrincipals?.map((e) => e) || [];
    message.exceptionPrincipals = object.exceptionPrincipals?.map((e) => e) || [];
    message.deniedPermissions = object.deniedPermissions?.map((e) => e) || [];
    message.exceptionPermissions = object.exceptionPermissions?.map((e) => e) || [];
    message.denialCondition = (object.denialCondition !== undefined && object.denialCondition !== null)
      ? Expr.fromPartial(object.denialCondition)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
