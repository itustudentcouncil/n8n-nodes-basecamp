// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/group_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { MonitoredResource } from "../../api/monitored_resource.js";
import { Empty } from "../../protobuf/empty.js";
import { TimeInterval } from "./common.js";
import { Group } from "./group.js";

export const protobufPackage = "google.monitoring.v3";

/** The `ListGroup` request. */
export interface ListGroupsRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) whose
   * groups are to be listed. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * A group name. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   *
   * Returns groups whose `parent_name` field contains the group
   * name.  If no groups have this parent, the results are empty.
   */
  childrenOfGroup?:
    | string
    | undefined;
  /**
   * A group name. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   *
   * Returns groups that are ancestors of the specified group.
   * The groups are returned in order, starting with the immediate parent and
   * ending with the most distant ancestor.  If the specified group has no
   * immediate parent, the results are empty.
   */
  ancestorsOfGroup?:
    | string
    | undefined;
  /**
   * A group name. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   *
   * Returns the descendants of the specified group.  This is a superset of
   * the results returned by the `children_of_group` filter, and includes
   * children-of-children, and so forth.
   */
  descendantsOfGroup?:
    | string
    | undefined;
  /** A positive number that is the maximum number of results to return. */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `next_page_token` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
}

/** The `ListGroups` response. */
export interface ListGroupsResponse {
  /** The groups that match the specified filters. */
  group: Group[];
  /**
   * If there are more results than have been returned, then this field is set
   * to a non-empty value.  To see the additional results,
   * use that value as `page_token` in the next call to this method.
   */
  nextPageToken: string;
}

/** The `GetGroup` request. */
export interface GetGroupRequest {
  /**
   * Required. The group to retrieve. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   */
  name: string;
}

/** The `CreateGroup` request. */
export interface CreateGroupRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) in which
   * to create the group. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * Required. A group definition. It is an error to define the `name` field
   * because the system assigns the name.
   */
  group:
    | Group
    | undefined;
  /** If true, validate this request but do not create the group. */
  validateOnly: boolean;
}

/** The `UpdateGroup` request. */
export interface UpdateGroupRequest {
  /**
   * Required. The new definition of the group.  All fields of the existing
   * group, excepting `name`, are replaced with the corresponding fields of this
   * group.
   */
  group:
    | Group
    | undefined;
  /** If true, validate this request but do not update the existing group. */
  validateOnly: boolean;
}

/**
 * The `DeleteGroup` request. The default behavior is to be able to delete a
 * single group without any descendants.
 */
export interface DeleteGroupRequest {
  /**
   * Required. The group to delete. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   */
  name: string;
  /**
   * If this field is true, then the request means to delete a group with all
   * its descendants. Otherwise, the request means to delete a group only when
   * it has no descendants. The default value is false.
   */
  recursive: boolean;
}

/** The `ListGroupMembers` request. */
export interface ListGroupMembersRequest {
  /**
   * Required. The group whose members are listed. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
   */
  name: string;
  /** A positive number that is the maximum number of results to return. */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `next_page_token` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
  /**
   * An optional [list
   * filter](https://cloud.google.com/monitoring/api/learn_more#filtering)
   * describing the members to be returned.  The filter may reference the type,
   * labels, and metadata of monitored resources that comprise the group. For
   * example, to return only resources representing Compute Engine VM instances,
   * use this filter:
   *
   *     `resource.type = "gce_instance"`
   */
  filter: string;
  /**
   * An optional time interval for which results should be returned. Only
   * members that were part of the group during the specified interval are
   * included in the response.  If no interval is provided then the group
   * membership over the last minute is returned.
   */
  interval: TimeInterval | undefined;
}

/** The `ListGroupMembers` response. */
export interface ListGroupMembersResponse {
  /** A set of monitored resources in the group. */
  members: MonitoredResource[];
  /**
   * If there are more results than have been returned, then this field is
   * set to a non-empty value.  To see the additional results, use that value as
   * `page_token` in the next call to this method.
   */
  nextPageToken: string;
  /** The total number of elements matching this request. */
  totalSize: number;
}

function createBaseListGroupsRequest(): ListGroupsRequest {
  return {
    name: "",
    childrenOfGroup: undefined,
    ancestorsOfGroup: undefined,
    descendantsOfGroup: undefined,
    pageSize: 0,
    pageToken: "",
  };
}

export const ListGroupsRequest: MessageFns<ListGroupsRequest> = {
  encode(message: ListGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.childrenOfGroup !== undefined) {
      writer.uint32(18).string(message.childrenOfGroup);
    }
    if (message.ancestorsOfGroup !== undefined) {
      writer.uint32(26).string(message.ancestorsOfGroup);
    }
    if (message.descendantsOfGroup !== undefined) {
      writer.uint32(34).string(message.descendantsOfGroup);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.childrenOfGroup = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ancestorsOfGroup = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.descendantsOfGroup = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      childrenOfGroup: isSet(object.childrenOfGroup) ? globalThis.String(object.childrenOfGroup) : undefined,
      ancestorsOfGroup: isSet(object.ancestorsOfGroup) ? globalThis.String(object.ancestorsOfGroup) : undefined,
      descendantsOfGroup: isSet(object.descendantsOfGroup) ? globalThis.String(object.descendantsOfGroup) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListGroupsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.childrenOfGroup !== undefined) {
      obj.childrenOfGroup = message.childrenOfGroup;
    }
    if (message.ancestorsOfGroup !== undefined) {
      obj.ancestorsOfGroup = message.ancestorsOfGroup;
    }
    if (message.descendantsOfGroup !== undefined) {
      obj.descendantsOfGroup = message.descendantsOfGroup;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    return ListGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    const message = createBaseListGroupsRequest();
    message.name = object.name ?? "";
    message.childrenOfGroup = object.childrenOfGroup ?? undefined;
    message.ancestorsOfGroup = object.ancestorsOfGroup ?? undefined;
    message.descendantsOfGroup = object.descendantsOfGroup ?? undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListGroupsResponse(): ListGroupsResponse {
  return { group: [], nextPageToken: "" };
}

export const ListGroupsResponse: MessageFns<ListGroupsResponse> = {
  encode(message: ListGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.group) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group.push(Group.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupsResponse {
    return {
      group: globalThis.Array.isArray(object?.group) ? object.group.map((e: any) => Group.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListGroupsResponse): unknown {
    const obj: any = {};
    if (message.group?.length) {
      obj.group = message.group.map((e) => Group.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    return ListGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupsResponse>): ListGroupsResponse {
    const message = createBaseListGroupsResponse();
    message.group = object.group?.map((e) => Group.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetGroupRequest(): GetGroupRequest {
  return { name: "" };
}

export const GetGroupRequest: MessageFns<GetGroupRequest> = {
  encode(message: GetGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGroupRequest>): GetGroupRequest {
    return GetGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGroupRequest>): GetGroupRequest {
    const message = createBaseGetGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateGroupRequest(): CreateGroupRequest {
  return { name: "", group: undefined, validateOnly: false };
}

export const CreateGroupRequest: MessageFns<CreateGroupRequest> = {
  encode(message: CreateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    return CreateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    const message = createBaseCreateGroupRequest();
    message.name = object.name ?? "";
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateGroupRequest(): UpdateGroupRequest {
  return { group: undefined, validateOnly: false };
}

export const UpdateGroupRequest: MessageFns<UpdateGroupRequest> = {
  encode(message: UpdateGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.group !== undefined) {
      Group.encode(message.group, writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.group = Group.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGroupRequest {
    return {
      group: isSet(object.group) ? Group.fromJSON(object.group) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateGroupRequest): unknown {
    const obj: any = {};
    if (message.group !== undefined) {
      obj.group = Group.toJSON(message.group);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    return UpdateGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    const message = createBaseUpdateGroupRequest();
    message.group = (object.group !== undefined && object.group !== null) ? Group.fromPartial(object.group) : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteGroupRequest(): DeleteGroupRequest {
  return { name: "", recursive: false };
}

export const DeleteGroupRequest: MessageFns<DeleteGroupRequest> = {
  encode(message: DeleteGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.recursive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
    };
  },

  toJSON(message: DeleteGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    return DeleteGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    const message = createBaseDeleteGroupRequest();
    message.name = object.name ?? "";
    message.recursive = object.recursive ?? false;
    return message;
  },
};

function createBaseListGroupMembersRequest(): ListGroupMembersRequest {
  return { name: "", pageSize: 0, pageToken: "", filter: "", interval: undefined };
}

export const ListGroupMembersRequest: MessageFns<ListGroupMembersRequest> = {
  encode(message: ListGroupMembersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.interval !== undefined) {
      TimeInterval.encode(message.interval, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupMembersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupMembersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.interval = TimeInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupMembersRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      interval: isSet(object.interval) ? TimeInterval.fromJSON(object.interval) : undefined,
    };
  },

  toJSON(message: ListGroupMembersRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.interval !== undefined) {
      obj.interval = TimeInterval.toJSON(message.interval);
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupMembersRequest>): ListGroupMembersRequest {
    return ListGroupMembersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupMembersRequest>): ListGroupMembersRequest {
    const message = createBaseListGroupMembersRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? TimeInterval.fromPartial(object.interval)
      : undefined;
    return message;
  },
};

function createBaseListGroupMembersResponse(): ListGroupMembersResponse {
  return { members: [], nextPageToken: "", totalSize: 0 };
}

export const ListGroupMembersResponse: MessageFns<ListGroupMembersResponse> = {
  encode(message: ListGroupMembersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      MonitoredResource.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGroupMembersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGroupMembersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.members.push(MonitoredResource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGroupMembersResponse {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => MonitoredResource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListGroupMembersResponse): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => MonitoredResource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListGroupMembersResponse>): ListGroupMembersResponse {
    return ListGroupMembersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGroupMembersResponse>): ListGroupMembersResponse {
    const message = createBaseListGroupMembersResponse();
    message.members = object.members?.map((e) => MonitoredResource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

/**
 * The Group API lets you inspect and manage your
 * [groups](#google.monitoring.v3.Group).
 *
 * A group is a named filter that is used to identify
 * a collection of monitored resources. Groups are typically used to
 * mirror the physical and/or logical topology of the environment.
 * Because group membership is computed dynamically, monitored
 * resources that are started in the future are automatically placed
 * in matching groups. By using a group to name monitored resources in,
 * for example, an alert policy, the target of that alert policy is
 * updated automatically as monitored resources are added and removed
 * from the infrastructure.
 */
export type GroupServiceDefinition = typeof GroupServiceDefinition;
export const GroupServiceDefinition = {
  name: "GroupService",
  fullName: "google.monitoring.v3.GroupService",
  methods: {
    /** Lists the existing groups. */
    listGroups: {
      name: "ListGroups",
      requestType: ListGroupsRequest,
      requestStream: false,
      responseType: ListGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a single group. */
    getGroup: {
      name: "GetGroup",
      requestType: GetGroupRequest,
      requestStream: false,
      responseType: Group,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new group. */
    createGroup: {
      name: "CreateGroup",
      requestType: CreateGroupRequest,
      requestStream: false,
      responseType: Group,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 110, 97, 109, 101, 44, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              37,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              34,
              28,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an existing group.
     * You can change any group attributes except `name`.
     */
    updateGroup: {
      name: "UpdateGroup",
      requestType: UpdateGroupRequest,
      requestStream: false,
      responseType: Group,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([5, 103, 114, 111, 117, 112])],
          578365826: [
            Buffer.from([
              45,
              58,
              5,
              103,
              114,
              111,
              117,
              112,
              26,
              36,
              47,
              118,
              51,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes an existing group. */
    deleteGroup: {
      name: "DeleteGroup",
      requestType: DeleteGroupRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              32,
              42,
              30,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists the monitored resources that are members of a group. */
    listGroupMembers: {
      name: "ListGroupMembers",
      requestType: ListGroupMembersRequest,
      requestStream: false,
      responseType: ListGroupMembersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              40,
              18,
              38,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface GroupServiceImplementation<CallContextExt = {}> {
  /** Lists the existing groups. */
  listGroups(
    request: ListGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGroupsResponse>>;
  /** Gets a single group. */
  getGroup(request: GetGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Group>>;
  /** Creates a new group. */
  createGroup(request: CreateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Group>>;
  /**
   * Updates an existing group.
   * You can change any group attributes except `name`.
   */
  updateGroup(request: UpdateGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Group>>;
  /** Deletes an existing group. */
  deleteGroup(request: DeleteGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Lists the monitored resources that are members of a group. */
  listGroupMembers(
    request: ListGroupMembersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListGroupMembersResponse>>;
}

export interface GroupServiceClient<CallOptionsExt = {}> {
  /** Lists the existing groups. */
  listGroups(
    request: DeepPartial<ListGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGroupsResponse>;
  /** Gets a single group. */
  getGroup(request: DeepPartial<GetGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Group>;
  /** Creates a new group. */
  createGroup(request: DeepPartial<CreateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Group>;
  /**
   * Updates an existing group.
   * You can change any group attributes except `name`.
   */
  updateGroup(request: DeepPartial<UpdateGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Group>;
  /** Deletes an existing group. */
  deleteGroup(request: DeepPartial<DeleteGroupRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Lists the monitored resources that are members of a group. */
  listGroupMembers(
    request: DeepPartial<ListGroupMembersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListGroupMembersResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
