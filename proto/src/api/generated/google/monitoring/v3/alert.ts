// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/alert.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../protobuf/duration.js";
import { BoolValue } from "../../protobuf/wrappers.js";
import { Status } from "../../rpc/status.js";
import { Aggregation, ComparisonType, comparisonTypeFromJSON, comparisonTypeToJSON } from "./common.js";
import { MutationRecord } from "./mutation_record.js";

export const protobufPackage = "google.monitoring.v3";

/**
 * A description of the conditions under which some aspect of your system is
 * considered to be "unhealthy" and the ways to notify people or services about
 * this state. For an overview of alert policies, see
 * [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
 */
export interface AlertPolicy {
  /**
   * Required if the policy exists. The resource name for this policy. The
   * format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
   *
   * `[ALERT_POLICY_ID]` is assigned by Cloud Monitoring when the policy
   * is created. When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the alerting policy passed as
   * part of the request.
   */
  name: string;
  /**
   * A short name or phrase used to identify the policy in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple policies in the same project. The name is
   * limited to 512 Unicode characters.
   *
   * The convention for the display_name of a PrometheusQueryLanguageCondition
   * is "{rule group name}/{alert name}", where the {rule group name} and
   * {alert name} should be taken from the corresponding Prometheus
   * configuration file. This convention is not enforced.
   * In any case the display_name is not a unique key of the AlertPolicy.
   */
  displayName: string;
  /**
   * Documentation that is included with notifications and incidents related to
   * this policy. Best practice is for the documentation to include information
   * to help responders understand, mitigate, escalate, and correct the
   * underlying problems detected by the alerting policy. Notification channels
   * that have limited capacity might not show this documentation.
   */
  documentation:
    | AlertPolicy_Documentation
    | undefined;
  /**
   * User-supplied key/value data to be used for organizing and
   * identifying the `AlertPolicy` objects.
   *
   * The field can contain up to 64 entries. Each key and value is limited to
   * 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
   * values can contain only lowercase letters, numerals, underscores, and
   * dashes. Keys must begin with a letter.
   *
   * Note that Prometheus {alert name} is a
   * [valid Prometheus label
   * names](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels),
   * whereas Prometheus {rule group} is an unrestricted UTF-8 string.
   * This means that they cannot be stored as-is in user labels, because
   * they may contain characters that are not allowed in user-label values.
   */
  userLabels: { [key: string]: string };
  /**
   * A list of conditions for the policy. The conditions are combined by AND or
   * OR according to the `combiner` field. If the combined conditions evaluate
   * to true, then an incident is created. A policy can have from one to six
   * conditions.
   * If `condition_time_series_query_language` is present, it must be the only
   * `condition`.
   * If `condition_monitoring_query_language` is present, it must be the only
   * `condition`.
   */
  conditions: AlertPolicy_Condition[];
  /**
   * How to combine the results of multiple conditions to determine if an
   * incident should be opened.
   * If `condition_time_series_query_language` is present, this must be
   * `COMBINE_UNSPECIFIED`.
   */
  combiner: AlertPolicy_ConditionCombinerType;
  /**
   * Whether or not the policy is enabled. On write, the default interpretation
   * if unset is that the policy is enabled. On read, clients should not make
   * any assumption about the state if it has not been populated. The
   * field should always be populated on List and Get operations, unless
   * a field projection has been specified that strips it out.
   */
  enabled:
    | boolean
    | undefined;
  /**
   * Read-only description of how the alert policy is invalid. This field is
   * only set when the alert policy is invalid. An invalid alert policy will not
   * generate incidents.
   */
  validity:
    | Status
    | undefined;
  /**
   * Identifies the notification channels to which notifications should be sent
   * when incidents are opened or closed or when new violations occur on
   * an already opened incident. Each element of this array corresponds to
   * the `name` field in each of the
   * [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
   * objects that are returned from the [`ListNotificationChannels`]
   * [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
   * method. The format of the entries in this field is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   */
  notificationChannels: string[];
  /**
   * A read-only record of the creation of the alerting policy. If provided
   * in a call to create or update, this field will be ignored.
   */
  creationRecord:
    | MutationRecord
    | undefined;
  /**
   * A read-only record of the most recent change to the alerting policy. If
   * provided in a call to create or update, this field will be ignored.
   */
  mutationRecord:
    | MutationRecord
    | undefined;
  /** Control over how this alert policy's notification channels are notified. */
  alertStrategy:
    | AlertPolicy_AlertStrategy
    | undefined;
  /**
   * Optional. The severity of an alert policy indicates how important incidents
   * generated by that policy are. The severity level will be displayed on the
   * Incident detail page and in notifications.
   */
  severity: AlertPolicy_Severity;
}

/** Operators for combining conditions. */
export enum AlertPolicy_ConditionCombinerType {
  /** COMBINE_UNSPECIFIED - An unspecified combiner. */
  COMBINE_UNSPECIFIED = 0,
  /**
   * AND - Combine conditions using the logical `AND` operator. An
   * incident is created only if all the conditions are met
   * simultaneously. This combiner is satisfied if all conditions are
   * met, even if they are met on completely different resources.
   */
  AND = 1,
  /**
   * OR - Combine conditions using the logical `OR` operator. An incident
   * is created if any of the listed conditions is met.
   */
  OR = 2,
  /**
   * AND_WITH_MATCHING_RESOURCE - Combine conditions using logical `AND` operator, but unlike the regular
   * `AND` option, an incident is created only if all conditions are met
   * simultaneously on at least one resource.
   */
  AND_WITH_MATCHING_RESOURCE = 3,
  UNRECOGNIZED = -1,
}

export function alertPolicy_ConditionCombinerTypeFromJSON(object: any): AlertPolicy_ConditionCombinerType {
  switch (object) {
    case 0:
    case "COMBINE_UNSPECIFIED":
      return AlertPolicy_ConditionCombinerType.COMBINE_UNSPECIFIED;
    case 1:
    case "AND":
      return AlertPolicy_ConditionCombinerType.AND;
    case 2:
    case "OR":
      return AlertPolicy_ConditionCombinerType.OR;
    case 3:
    case "AND_WITH_MATCHING_RESOURCE":
      return AlertPolicy_ConditionCombinerType.AND_WITH_MATCHING_RESOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlertPolicy_ConditionCombinerType.UNRECOGNIZED;
  }
}

export function alertPolicy_ConditionCombinerTypeToJSON(object: AlertPolicy_ConditionCombinerType): string {
  switch (object) {
    case AlertPolicy_ConditionCombinerType.COMBINE_UNSPECIFIED:
      return "COMBINE_UNSPECIFIED";
    case AlertPolicy_ConditionCombinerType.AND:
      return "AND";
    case AlertPolicy_ConditionCombinerType.OR:
      return "OR";
    case AlertPolicy_ConditionCombinerType.AND_WITH_MATCHING_RESOURCE:
      return "AND_WITH_MATCHING_RESOURCE";
    case AlertPolicy_ConditionCombinerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An enumeration of possible severity level for an Alert Policy. */
export enum AlertPolicy_Severity {
  /** SEVERITY_UNSPECIFIED - No severity is specified. This is the default value. */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * CRITICAL - This is the highest severity level. Use this if the problem could
   * cause significant damage or downtime.
   */
  CRITICAL = 1,
  /**
   * ERROR - This is the medium severity level. Use this if the problem could
   * cause minor damage or downtime.
   */
  ERROR = 2,
  /**
   * WARNING - This is the lowest severity level. Use this if the problem is not causing
   * any damage or downtime, but could potentially lead to a problem in the
   * future.
   */
  WARNING = 3,
  UNRECOGNIZED = -1,
}

export function alertPolicy_SeverityFromJSON(object: any): AlertPolicy_Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return AlertPolicy_Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "CRITICAL":
      return AlertPolicy_Severity.CRITICAL;
    case 2:
    case "ERROR":
      return AlertPolicy_Severity.ERROR;
    case 3:
    case "WARNING":
      return AlertPolicy_Severity.WARNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlertPolicy_Severity.UNRECOGNIZED;
  }
}

export function alertPolicy_SeverityToJSON(object: AlertPolicy_Severity): string {
  switch (object) {
    case AlertPolicy_Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case AlertPolicy_Severity.CRITICAL:
      return "CRITICAL";
    case AlertPolicy_Severity.ERROR:
      return "ERROR";
    case AlertPolicy_Severity.WARNING:
      return "WARNING";
    case AlertPolicy_Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Documentation that is included in the notifications and incidents
 * pertaining to this policy.
 */
export interface AlertPolicy_Documentation {
  /**
   * The body of the documentation, interpreted according to `mime_type`.
   * The content may not exceed 8,192 Unicode characters and may not exceed
   * more than 10,240 bytes when encoded in UTF-8 format, whichever is
   * smaller. This text can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   */
  content: string;
  /**
   * The format of the `content` field. Presently, only the value
   * `"text/markdown"` is supported. See
   * [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
   */
  mimeType: string;
  /**
   * Optional. The subject line of the notification. The subject line may not
   * exceed 10,240 bytes. In notifications generated by this policy, the
   * contents of the subject line after variable expansion will be truncated
   * to 255 bytes or shorter at the latest UTF-8 character boundary. The
   * 255-byte limit is recommended by [this
   * thread](https://stackoverflow.com/questions/1592291/what-is-the-email-subject-length-limit).
   * It is both the limit imposed by some third-party ticketing products and
   * it is common to define textual fields in databases as VARCHAR(255).
   *
   * The contents of the subject line can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   * If this field is missing or empty, a default subject line will be
   * generated.
   */
  subject: string;
  /**
   * Optional. Links to content such as playbooks, repositories, and other
   * resources. This field can contain up to 3 entries.
   */
  links: AlertPolicy_Documentation_Link[];
}

/** Links to content such as playbooks, repositories, and other resources. */
export interface AlertPolicy_Documentation_Link {
  /**
   * A short display name for the link. The display name must not be empty
   * or exceed 63 characters. Example: "playbook".
   */
  displayName: string;
  /**
   * The url of a webpage.
   * A url can be templatized by using variables
   * in the path or the query parameters. The total length of a URL should
   * not exceed 2083 characters before and after variable expansion.
   * Example: "https://my_domain.com/playbook?name=${resource.name}"
   */
  url: string;
}

/**
 * A condition is a true/false test that determines when an alerting policy
 * should open an incident. If a condition evaluates to true, it signifies
 * that something is wrong.
 */
export interface AlertPolicy_Condition {
  /**
   * Required if the condition exists. The unique resource name for this
   * condition. Its format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
   *
   * `[CONDITION_ID]` is assigned by Cloud Monitoring when the
   * condition is created as part of a new or updated alerting policy.
   *
   * When calling the
   * [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
   * method, do not include the `name` field in the conditions of the
   * requested alerting policy. Cloud Monitoring creates the
   * condition identifiers and includes them in the new policy.
   *
   * When calling the
   * [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
   * method to update a policy, including a condition `name` causes the
   * existing condition to be updated. Conditions without names are added to
   * the updated policy. Existing conditions are deleted if they are not
   * updated.
   *
   * Best practice is to preserve `[CONDITION_ID]` if you make only small
   * changes, such as those to condition thresholds, durations, or trigger
   * values.  Otherwise, treat the change as a new condition and let the
   * existing condition be deleted.
   */
  name: string;
  /**
   * A short name or phrase used to identify the condition in dashboards,
   * notifications, and incidents. To avoid confusion, don't use the same
   * display name for multiple conditions in the same policy.
   */
  displayName: string;
  /** A condition that compares a time series against a threshold. */
  conditionThreshold?:
    | AlertPolicy_Condition_MetricThreshold
    | undefined;
  /**
   * A condition that checks that a time series continues to
   * receive new data points.
   */
  conditionAbsent?:
    | AlertPolicy_Condition_MetricAbsence
    | undefined;
  /**
   * A condition that checks for log messages matching given constraints. If
   * set, no other conditions can be present.
   */
  conditionMatchedLog?:
    | AlertPolicy_Condition_LogMatch
    | undefined;
  /**
   * A condition that uses the Monitoring Query Language to define
   * alerts.
   */
  conditionMonitoringQueryLanguage?:
    | AlertPolicy_Condition_MonitoringQueryLanguageCondition
    | undefined;
  /** A condition that uses the Prometheus query language to define alerts. */
  conditionPrometheusQueryLanguage?: AlertPolicy_Condition_PrometheusQueryLanguageCondition | undefined;
}

/**
 * A condition control that determines how metric-threshold conditions
 * are evaluated when data stops arriving.
 * This control doesn't affect metric-absence policies.
 */
export enum AlertPolicy_Condition_EvaluationMissingData {
  /**
   * EVALUATION_MISSING_DATA_UNSPECIFIED - An unspecified evaluation missing data option.  Equivalent to
   * EVALUATION_MISSING_DATA_NO_OP.
   */
  EVALUATION_MISSING_DATA_UNSPECIFIED = 0,
  /**
   * EVALUATION_MISSING_DATA_INACTIVE - If there is no data to evaluate the condition, then evaluate the
   * condition as false.
   */
  EVALUATION_MISSING_DATA_INACTIVE = 1,
  /**
   * EVALUATION_MISSING_DATA_ACTIVE - If there is no data to evaluate the condition, then evaluate the
   * condition as true.
   */
  EVALUATION_MISSING_DATA_ACTIVE = 2,
  /** EVALUATION_MISSING_DATA_NO_OP - Do not evaluate the condition to any value if there is no data. */
  EVALUATION_MISSING_DATA_NO_OP = 3,
  UNRECOGNIZED = -1,
}

export function alertPolicy_Condition_EvaluationMissingDataFromJSON(
  object: any,
): AlertPolicy_Condition_EvaluationMissingData {
  switch (object) {
    case 0:
    case "EVALUATION_MISSING_DATA_UNSPECIFIED":
      return AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_UNSPECIFIED;
    case 1:
    case "EVALUATION_MISSING_DATA_INACTIVE":
      return AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_INACTIVE;
    case 2:
    case "EVALUATION_MISSING_DATA_ACTIVE":
      return AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_ACTIVE;
    case 3:
    case "EVALUATION_MISSING_DATA_NO_OP":
      return AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_NO_OP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AlertPolicy_Condition_EvaluationMissingData.UNRECOGNIZED;
  }
}

export function alertPolicy_Condition_EvaluationMissingDataToJSON(
  object: AlertPolicy_Condition_EvaluationMissingData,
): string {
  switch (object) {
    case AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_UNSPECIFIED:
      return "EVALUATION_MISSING_DATA_UNSPECIFIED";
    case AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_INACTIVE:
      return "EVALUATION_MISSING_DATA_INACTIVE";
    case AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_ACTIVE:
      return "EVALUATION_MISSING_DATA_ACTIVE";
    case AlertPolicy_Condition_EvaluationMissingData.EVALUATION_MISSING_DATA_NO_OP:
      return "EVALUATION_MISSING_DATA_NO_OP";
    case AlertPolicy_Condition_EvaluationMissingData.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies how many time series must fail a predicate to trigger a
 * condition. If not specified, then a `{count: 1}` trigger is used.
 */
export interface AlertPolicy_Condition_Trigger {
  /**
   * The absolute number of time series that must fail
   * the predicate for the condition to be triggered.
   */
  count?:
    | number
    | undefined;
  /**
   * The percentage of time series that must fail the
   * predicate for the condition to be triggered.
   */
  percent?: number | undefined;
}

/**
 * A condition type that compares a collection of time series
 * against a threshold.
 */
export interface AlertPolicy_Condition_MetricThreshold {
  /**
   * Required. A
   * [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   */
  filter: string;
  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   */
  aggregations: Aggregation[];
  /**
   * A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies a time series that should be used as the denominator of a
   * ratio that will be compared with the threshold. If a
   * `denominator_filter` is specified, the time series specified by the
   * `filter` field will be used as the numerator.
   *
   * The filter must specify the metric type and optionally may contain
   * restrictions on resource type, resource labels, and metric labels.
   * This field may not exceed 2048 Unicode characters in length.
   */
  denominatorFilter: string;
  /**
   * Specifies the alignment of data points in individual time series
   * selected by `denominatorFilter` as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources).
   *
   * When computing ratios, the `aggregations` and
   * `denominator_aggregations` fields must use the same alignment period
   * and produce time series that have the same periodicity and labels.
   */
  denominatorAggregations: Aggregation[];
  /**
   * When this field is present, the `MetricThreshold` condition forecasts
   * whether the time series is predicted to violate the threshold within
   * the `forecast_horizon`. When this field is not set, the
   * `MetricThreshold` tests the current value of the timeseries against the
   * threshold.
   */
  forecastOptions:
    | AlertPolicy_Condition_MetricThreshold_ForecastOptions
    | undefined;
  /**
   * The comparison to apply between the time series (indicated by `filter`
   * and `aggregation`) and the threshold (indicated by `threshold_value`).
   * The comparison is applied on each time series, with the time series
   * on the left-hand side and the threshold on the right-hand side.
   *
   * Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
   */
  comparison: ComparisonType;
  /** A value against which to compare the time series. */
  thresholdValue: number;
  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   */
  trigger:
    | AlertPolicy_Condition_Trigger
    | undefined;
  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving. To use this control, the value
   * of the `duration` field must be greater than or equal to 60 seconds.
   */
  evaluationMissingData: AlertPolicy_Condition_EvaluationMissingData;
}

/**
 * Options used when forecasting the time series and testing
 * the predicted value against the threshold.
 */
export interface AlertPolicy_Condition_MetricThreshold_ForecastOptions {
  /**
   * Required. The length of time into the future to forecast whether a
   * time series will violate the threshold. If the predicted value is
   * found to violate the threshold, and the violation is observed in all
   * forecasts made for the configured `duration`, then the time series is
   * considered to be failing.
   * The forecast horizon can range from 1 hour to 60 hours.
   */
  forecastHorizon: Duration | undefined;
}

/**
 * A condition type that checks that monitored resources
 * are reporting data. The configuration defines a metric and
 * a set of monitored resources. The predicate is considered in violation
 * when a time series for the specified metric of a monitored
 * resource does not include any data in the specified `duration`.
 */
export interface AlertPolicy_Condition_MetricAbsence {
  /**
   * Required. A
   * [filter](https://cloud.google.com/monitoring/api/v3/filters) that
   * identifies which time series should be compared with the threshold.
   *
   * The filter is similar to the one that is specified in the
   * [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
   * (that call is useful to verify the time series that will be retrieved /
   * processed). The filter must specify the metric type and the resource
   * type. Optionally, it can specify resource labels and metric labels.
   * This field must not exceed 2048 Unicode characters in length.
   */
  filter: string;
  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series together (such as
   * when aggregating multiple streams on each resource to a single
   * stream for each resource or when aggregating streams across all
   * members of a group of resources). Multiple aggregations
   * are applied in the order specified.
   *
   * This field is similar to the one in the [`ListTimeSeries`
   * request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
   * It is advisable to use the `ListTimeSeries` method when debugging this
   * field.
   */
  aggregations: Aggregation[];
  /**
   * The amount of time that a time series must fail to report new
   * data to be considered failing. The minimum value of this field
   * is 120 seconds. Larger values that are a multiple of a
   * minute--for example, 240 or 300 seconds--are supported.
   * If an invalid value is given, an
   * error will be returned. The `Duration.nanos` field is
   * ignored.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`.
   */
  trigger: AlertPolicy_Condition_Trigger | undefined;
}

/**
 * A condition type that checks whether a log message in the [scoping
 * project](https://cloud.google.com/monitoring/api/v3#project_name)
 * satisfies the given filter. Logs from other projects in the metrics
 * scope are not evaluated.
 */
export interface AlertPolicy_Condition_LogMatch {
  /**
   * Required. A logs-based filter. See [Advanced Logs
   * Queries](https://cloud.google.com/logging/docs/view/advanced-queries)
   * for how this filter should be constructed.
   */
  filter: string;
  /**
   * Optional. A map from a label key to an extractor expression, which is
   * used to extract the value for this label key. Each entry in this map is
   * a specification for how data should be extracted from log entries that
   * match `filter`. Each combination of extracted values is treated as a
   * separate rule for the purposes of triggering notifications. Label keys
   * and corresponding values can be used in notifications generated by this
   * condition.
   *
   * Please see [the documentation on logs-based metric
   * `valueExtractor`s](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics#LogMetric.FIELDS.value_extractor)
   * for syntax and examples.
   */
  labelExtractors: { [key: string]: string };
}

export interface AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
  key: string;
  value: string;
}

/**
 * A condition type that allows alert policies to be defined using
 * [Monitoring Query Language](https://cloud.google.com/monitoring/mql).
 */
export interface AlertPolicy_Condition_MonitoringQueryLanguageCondition {
  /**
   * [Monitoring Query Language](https://cloud.google.com/monitoring/mql)
   * query that outputs a boolean stream.
   */
  query: string;
  /**
   * The amount of time that a time series must violate the
   * threshold to be considered failing. Currently, only values
   * that are a multiple of a minute--e.g., 0, 60, 120, or 300
   * seconds--are supported. If an invalid value is given, an
   * error will be returned. When choosing a duration, it is useful to
   * keep in mind the frequency of the underlying time series data
   * (which may also be affected by any alignments specified in the
   * `aggregations` field); a good duration is long enough so that a single
   * outlier does not generate spurious alerts, but short enough that
   * unhealthy states are detected and alerted on quickly.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The number/percent of time series for which the comparison must hold
   * in order for the condition to trigger. If unspecified, then the
   * condition will trigger if the comparison is true for any of the
   * time series that have been identified by `filter` and `aggregations`,
   * or by the ratio, if `denominator_filter` and `denominator_aggregations`
   * are specified.
   */
  trigger:
    | AlertPolicy_Condition_Trigger
    | undefined;
  /**
   * A condition control that determines how metric-threshold conditions
   * are evaluated when data stops arriving.
   */
  evaluationMissingData: AlertPolicy_Condition_EvaluationMissingData;
}

/**
 * A condition type that allows alert policies to be defined using
 * [Prometheus Query Language
 * (PromQL)](https://prometheus.io/docs/prometheus/latest/querying/basics/).
 *
 * The PrometheusQueryLanguageCondition message contains information
 * from a Prometheus alerting rule and its associated rule group.
 *
 * A Prometheus alerting rule is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/).
 * The semantics of a Prometheus alerting rule is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule).
 *
 * A Prometheus rule group is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/).
 * The semantics of a Prometheus rule group is described
 * [here](https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/#rule_group).
 *
 * Because Cloud Alerting has no representation of a Prometheus rule
 * group resource, we must embed the information of the parent rule
 * group inside each of the conditions that refer to it. We must also
 * update the contents of all Prometheus alerts in case the information
 * of their rule group changes.
 *
 * The PrometheusQueryLanguageCondition protocol buffer combines the
 * information of the corresponding rule group and alerting rule.
 * The structure of the PrometheusQueryLanguageCondition protocol buffer
 * does NOT mimic the structure of the Prometheus rule group and alerting
 * rule YAML declarations. The PrometheusQueryLanguageCondition protocol
 * buffer may change in the future to support future rule group and/or
 * alerting rule features. There are no new such features at the present
 * time (2023-06-26).
 */
export interface AlertPolicy_Condition_PrometheusQueryLanguageCondition {
  /**
   * Required. The PromQL expression to evaluate. Every evaluation cycle
   * this expression is evaluated at the current time, and all resultant
   * time series become pending/firing alerts. This field must not be empty.
   */
  query: string;
  /**
   * Optional. Alerts are considered firing once their PromQL expression was
   * evaluated to be "true" for this long.
   * Alerts whose PromQL expression was not evaluated to be "true" for
   * long enough are considered pending.
   * Must be a non-negative duration or missing.
   * This field is optional. Its default value is zero.
   */
  duration:
    | Duration
    | undefined;
  /**
   * Optional. How often this rule should be evaluated.
   * Must be a positive multiple of 30 seconds or missing.
   * This field is optional. Its default value is 30 seconds.
   * If this PrometheusQueryLanguageCondition was generated from a
   * Prometheus alerting rule, then this value should be taken from the
   * enclosing rule group.
   */
  evaluationInterval:
    | Duration
    | undefined;
  /**
   * Optional. Labels to add to or overwrite in the PromQL query result.
   * Label names [must be
   * valid](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
   * Label values can be [templatized by using
   * variables](https://cloud.google.com/monitoring/alerts/doc-variables).
   * The only available variable names are the names of the labels in the
   * PromQL result, including "__name__" and "value". "labels" may be empty.
   */
  labels: { [key: string]: string };
  /**
   * Optional. The rule group name of this alert in the corresponding
   * Prometheus configuration file.
   *
   * Some external tools may require this field to be populated correctly
   * in order to refer to the original Prometheus configuration file.
   * The rule group name and the alert name are necessary to update the
   * relevant AlertPolicies in case the definition of the rule group changes
   * in the future.
   *
   * This field is optional. If this field is not empty, then it must
   * contain a valid UTF-8 string.
   * This field may not exceed 2048 Unicode characters in length.
   */
  ruleGroup: string;
  /**
   * Optional. The alerting rule name of this alert in the corresponding
   * Prometheus configuration file.
   *
   * Some external tools may require this field to be populated correctly
   * in order to refer to the original Prometheus configuration file.
   * The rule group name and the alert name are necessary to update the
   * relevant AlertPolicies in case the definition of the rule group changes
   * in the future.
   *
   * This field is optional. If this field is not empty, then it must be a
   * [valid Prometheus label
   * name](https://prometheus.io/docs/concepts/data_model/#metric-names-and-labels).
   * This field may not exceed 2048 Unicode characters in length.
   */
  alertRule: string;
}

export interface AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Control over how the notification channels in `notification_channels`
 * are notified when this alert fires.
 */
export interface AlertPolicy_AlertStrategy {
  /**
   * Required for alert policies with a `LogMatch` condition.
   *
   * This limit is not implemented for alert policies that are not log-based.
   */
  notificationRateLimit:
    | AlertPolicy_AlertStrategy_NotificationRateLimit
    | undefined;
  /**
   * If an alert policy that was active has no data for this long, any open
   * incidents will close
   */
  autoClose:
    | Duration
    | undefined;
  /** Control how notifications will be sent out, on a per-channel basis. */
  notificationChannelStrategy: AlertPolicy_AlertStrategy_NotificationChannelStrategy[];
}

/**
 * Control over the rate of notifications sent to this alert policy's
 * notification channels.
 */
export interface AlertPolicy_AlertStrategy_NotificationRateLimit {
  /** Not more than one notification per `period`. */
  period: Duration | undefined;
}

/**
 * Control over how the notification channels in `notification_channels`
 * are notified when this alert fires, on a per-channel basis.
 */
export interface AlertPolicy_AlertStrategy_NotificationChannelStrategy {
  /**
   * The full REST resource name for the notification channels that these
   * settings apply to. Each of these correspond to the name field in one
   * of the NotificationChannel objects referenced in the
   * notification_channels field of this AlertPolicy.
   * The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   */
  notificationChannelNames: string[];
  /**
   * The frequency at which to send reminder notifications for open
   * incidents.
   */
  renotifyInterval: Duration | undefined;
}

export interface AlertPolicy_UserLabelsEntry {
  key: string;
  value: string;
}

function createBaseAlertPolicy(): AlertPolicy {
  return {
    name: "",
    displayName: "",
    documentation: undefined,
    userLabels: {},
    conditions: [],
    combiner: 0,
    enabled: undefined,
    validity: undefined,
    notificationChannels: [],
    creationRecord: undefined,
    mutationRecord: undefined,
    alertStrategy: undefined,
    severity: 0,
  };
}

export const AlertPolicy: MessageFns<AlertPolicy> = {
  encode(message: AlertPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.documentation !== undefined) {
      AlertPolicy_Documentation.encode(message.documentation, writer.uint32(106).fork()).join();
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      AlertPolicy_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    for (const v of message.conditions) {
      AlertPolicy_Condition.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.combiner !== 0) {
      writer.uint32(48).int32(message.combiner);
    }
    if (message.enabled !== undefined) {
      BoolValue.encode({ value: message.enabled! }, writer.uint32(138).fork()).join();
    }
    if (message.validity !== undefined) {
      Status.encode(message.validity, writer.uint32(146).fork()).join();
    }
    for (const v of message.notificationChannels) {
      writer.uint32(114).string(v!);
    }
    if (message.creationRecord !== undefined) {
      MutationRecord.encode(message.creationRecord, writer.uint32(82).fork()).join();
    }
    if (message.mutationRecord !== undefined) {
      MutationRecord.encode(message.mutationRecord, writer.uint32(90).fork()).join();
    }
    if (message.alertStrategy !== undefined) {
      AlertPolicy_AlertStrategy.encode(message.alertStrategy, writer.uint32(170).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(176).int32(message.severity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.documentation = AlertPolicy_Documentation.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = AlertPolicy_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.userLabels[entry16.key] = entry16.value;
          }
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.conditions.push(AlertPolicy_Condition.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.combiner = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.enabled = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.validity = Status.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.notificationChannels.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.creationRecord = MutationRecord.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.mutationRecord = MutationRecord.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.alertStrategy = AlertPolicy_AlertStrategy.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      documentation: isSet(object.documentation) ? AlertPolicy_Documentation.fromJSON(object.documentation) : undefined,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => AlertPolicy_Condition.fromJSON(e))
        : [],
      combiner: isSet(object.combiner) ? alertPolicy_ConditionCombinerTypeFromJSON(object.combiner) : 0,
      enabled: isSet(object.enabled) ? Boolean(object.enabled) : undefined,
      validity: isSet(object.validity) ? Status.fromJSON(object.validity) : undefined,
      notificationChannels: globalThis.Array.isArray(object?.notificationChannels)
        ? object.notificationChannels.map((e: any) => globalThis.String(e))
        : [],
      creationRecord: isSet(object.creationRecord) ? MutationRecord.fromJSON(object.creationRecord) : undefined,
      mutationRecord: isSet(object.mutationRecord) ? MutationRecord.fromJSON(object.mutationRecord) : undefined,
      alertStrategy: isSet(object.alertStrategy) ? AlertPolicy_AlertStrategy.fromJSON(object.alertStrategy) : undefined,
      severity: isSet(object.severity) ? alertPolicy_SeverityFromJSON(object.severity) : 0,
    };
  },

  toJSON(message: AlertPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.documentation !== undefined) {
      obj.documentation = AlertPolicy_Documentation.toJSON(message.documentation);
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => AlertPolicy_Condition.toJSON(e));
    }
    if (message.combiner !== 0) {
      obj.combiner = alertPolicy_ConditionCombinerTypeToJSON(message.combiner);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    if (message.validity !== undefined) {
      obj.validity = Status.toJSON(message.validity);
    }
    if (message.notificationChannels?.length) {
      obj.notificationChannels = message.notificationChannels;
    }
    if (message.creationRecord !== undefined) {
      obj.creationRecord = MutationRecord.toJSON(message.creationRecord);
    }
    if (message.mutationRecord !== undefined) {
      obj.mutationRecord = MutationRecord.toJSON(message.mutationRecord);
    }
    if (message.alertStrategy !== undefined) {
      obj.alertStrategy = AlertPolicy_AlertStrategy.toJSON(message.alertStrategy);
    }
    if (message.severity !== 0) {
      obj.severity = alertPolicy_SeverityToJSON(message.severity);
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy>): AlertPolicy {
    return AlertPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy>): AlertPolicy {
    const message = createBaseAlertPolicy();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? AlertPolicy_Documentation.fromPartial(object.documentation)
      : undefined;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.conditions = object.conditions?.map((e) => AlertPolicy_Condition.fromPartial(e)) || [];
    message.combiner = object.combiner ?? 0;
    message.enabled = object.enabled ?? undefined;
    message.validity = (object.validity !== undefined && object.validity !== null)
      ? Status.fromPartial(object.validity)
      : undefined;
    message.notificationChannels = object.notificationChannels?.map((e) => e) || [];
    message.creationRecord = (object.creationRecord !== undefined && object.creationRecord !== null)
      ? MutationRecord.fromPartial(object.creationRecord)
      : undefined;
    message.mutationRecord = (object.mutationRecord !== undefined && object.mutationRecord !== null)
      ? MutationRecord.fromPartial(object.mutationRecord)
      : undefined;
    message.alertStrategy = (object.alertStrategy !== undefined && object.alertStrategy !== null)
      ? AlertPolicy_AlertStrategy.fromPartial(object.alertStrategy)
      : undefined;
    message.severity = object.severity ?? 0;
    return message;
  },
};

function createBaseAlertPolicy_Documentation(): AlertPolicy_Documentation {
  return { content: "", mimeType: "", subject: "", links: [] };
}

export const AlertPolicy_Documentation: MessageFns<AlertPolicy_Documentation> = {
  encode(message: AlertPolicy_Documentation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.subject !== "") {
      writer.uint32(26).string(message.subject);
    }
    for (const v of message.links) {
      AlertPolicy_Documentation_Link.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Documentation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Documentation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.links.push(AlertPolicy_Documentation_Link.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Documentation {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      links: globalThis.Array.isArray(object?.links)
        ? object.links.map((e: any) => AlertPolicy_Documentation_Link.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlertPolicy_Documentation): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.links?.length) {
      obj.links = message.links.map((e) => AlertPolicy_Documentation_Link.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Documentation>): AlertPolicy_Documentation {
    return AlertPolicy_Documentation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Documentation>): AlertPolicy_Documentation {
    const message = createBaseAlertPolicy_Documentation();
    message.content = object.content ?? "";
    message.mimeType = object.mimeType ?? "";
    message.subject = object.subject ?? "";
    message.links = object.links?.map((e) => AlertPolicy_Documentation_Link.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlertPolicy_Documentation_Link(): AlertPolicy_Documentation_Link {
  return { displayName: "", url: "" };
}

export const AlertPolicy_Documentation_Link: MessageFns<AlertPolicy_Documentation_Link> = {
  encode(message: AlertPolicy_Documentation_Link, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Documentation_Link {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Documentation_Link();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Documentation_Link {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: AlertPolicy_Documentation_Link): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Documentation_Link>): AlertPolicy_Documentation_Link {
    return AlertPolicy_Documentation_Link.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Documentation_Link>): AlertPolicy_Documentation_Link {
    const message = createBaseAlertPolicy_Documentation_Link();
    message.displayName = object.displayName ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseAlertPolicy_Condition(): AlertPolicy_Condition {
  return {
    name: "",
    displayName: "",
    conditionThreshold: undefined,
    conditionAbsent: undefined,
    conditionMatchedLog: undefined,
    conditionMonitoringQueryLanguage: undefined,
    conditionPrometheusQueryLanguage: undefined,
  };
}

export const AlertPolicy_Condition: MessageFns<AlertPolicy_Condition> = {
  encode(message: AlertPolicy_Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(98).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.conditionThreshold !== undefined) {
      AlertPolicy_Condition_MetricThreshold.encode(message.conditionThreshold, writer.uint32(10).fork()).join();
    }
    if (message.conditionAbsent !== undefined) {
      AlertPolicy_Condition_MetricAbsence.encode(message.conditionAbsent, writer.uint32(18).fork()).join();
    }
    if (message.conditionMatchedLog !== undefined) {
      AlertPolicy_Condition_LogMatch.encode(message.conditionMatchedLog, writer.uint32(162).fork()).join();
    }
    if (message.conditionMonitoringQueryLanguage !== undefined) {
      AlertPolicy_Condition_MonitoringQueryLanguageCondition.encode(
        message.conditionMonitoringQueryLanguage,
        writer.uint32(154).fork(),
      ).join();
    }
    if (message.conditionPrometheusQueryLanguage !== undefined) {
      AlertPolicy_Condition_PrometheusQueryLanguageCondition.encode(
        message.conditionPrometheusQueryLanguage,
        writer.uint32(170).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conditionThreshold = AlertPolicy_Condition_MetricThreshold.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conditionAbsent = AlertPolicy_Condition_MetricAbsence.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.conditionMatchedLog = AlertPolicy_Condition_LogMatch.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.conditionMonitoringQueryLanguage = AlertPolicy_Condition_MonitoringQueryLanguageCondition.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.conditionPrometheusQueryLanguage = AlertPolicy_Condition_PrometheusQueryLanguageCondition.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      conditionThreshold: isSet(object.conditionThreshold)
        ? AlertPolicy_Condition_MetricThreshold.fromJSON(object.conditionThreshold)
        : undefined,
      conditionAbsent: isSet(object.conditionAbsent)
        ? AlertPolicy_Condition_MetricAbsence.fromJSON(object.conditionAbsent)
        : undefined,
      conditionMatchedLog: isSet(object.conditionMatchedLog)
        ? AlertPolicy_Condition_LogMatch.fromJSON(object.conditionMatchedLog)
        : undefined,
      conditionMonitoringQueryLanguage: isSet(object.conditionMonitoringQueryLanguage)
        ? AlertPolicy_Condition_MonitoringQueryLanguageCondition.fromJSON(object.conditionMonitoringQueryLanguage)
        : undefined,
      conditionPrometheusQueryLanguage: isSet(object.conditionPrometheusQueryLanguage)
        ? AlertPolicy_Condition_PrometheusQueryLanguageCondition.fromJSON(object.conditionPrometheusQueryLanguage)
        : undefined,
    };
  },

  toJSON(message: AlertPolicy_Condition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.conditionThreshold !== undefined) {
      obj.conditionThreshold = AlertPolicy_Condition_MetricThreshold.toJSON(message.conditionThreshold);
    }
    if (message.conditionAbsent !== undefined) {
      obj.conditionAbsent = AlertPolicy_Condition_MetricAbsence.toJSON(message.conditionAbsent);
    }
    if (message.conditionMatchedLog !== undefined) {
      obj.conditionMatchedLog = AlertPolicy_Condition_LogMatch.toJSON(message.conditionMatchedLog);
    }
    if (message.conditionMonitoringQueryLanguage !== undefined) {
      obj.conditionMonitoringQueryLanguage = AlertPolicy_Condition_MonitoringQueryLanguageCondition.toJSON(
        message.conditionMonitoringQueryLanguage,
      );
    }
    if (message.conditionPrometheusQueryLanguage !== undefined) {
      obj.conditionPrometheusQueryLanguage = AlertPolicy_Condition_PrometheusQueryLanguageCondition.toJSON(
        message.conditionPrometheusQueryLanguage,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Condition>): AlertPolicy_Condition {
    return AlertPolicy_Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Condition>): AlertPolicy_Condition {
    const message = createBaseAlertPolicy_Condition();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.conditionThreshold = (object.conditionThreshold !== undefined && object.conditionThreshold !== null)
      ? AlertPolicy_Condition_MetricThreshold.fromPartial(object.conditionThreshold)
      : undefined;
    message.conditionAbsent = (object.conditionAbsent !== undefined && object.conditionAbsent !== null)
      ? AlertPolicy_Condition_MetricAbsence.fromPartial(object.conditionAbsent)
      : undefined;
    message.conditionMatchedLog = (object.conditionMatchedLog !== undefined && object.conditionMatchedLog !== null)
      ? AlertPolicy_Condition_LogMatch.fromPartial(object.conditionMatchedLog)
      : undefined;
    message.conditionMonitoringQueryLanguage =
      (object.conditionMonitoringQueryLanguage !== undefined && object.conditionMonitoringQueryLanguage !== null)
        ? AlertPolicy_Condition_MonitoringQueryLanguageCondition.fromPartial(object.conditionMonitoringQueryLanguage)
        : undefined;
    message.conditionPrometheusQueryLanguage =
      (object.conditionPrometheusQueryLanguage !== undefined && object.conditionPrometheusQueryLanguage !== null)
        ? AlertPolicy_Condition_PrometheusQueryLanguageCondition.fromPartial(object.conditionPrometheusQueryLanguage)
        : undefined;
    return message;
  },
};

function createBaseAlertPolicy_Condition_Trigger(): AlertPolicy_Condition_Trigger {
  return { count: undefined, percent: undefined };
}

export const AlertPolicy_Condition_Trigger: MessageFns<AlertPolicy_Condition_Trigger> = {
  encode(message: AlertPolicy_Condition_Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== undefined) {
      writer.uint32(8).int32(message.count);
    }
    if (message.percent !== undefined) {
      writer.uint32(17).double(message.percent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_Trigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.percent = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_Trigger {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      percent: isSet(object.percent) ? globalThis.Number(object.percent) : undefined,
    };
  },

  toJSON(message: AlertPolicy_Condition_Trigger): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.percent !== undefined) {
      obj.percent = message.percent;
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Condition_Trigger>): AlertPolicy_Condition_Trigger {
    return AlertPolicy_Condition_Trigger.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Condition_Trigger>): AlertPolicy_Condition_Trigger {
    const message = createBaseAlertPolicy_Condition_Trigger();
    message.count = object.count ?? undefined;
    message.percent = object.percent ?? undefined;
    return message;
  },
};

function createBaseAlertPolicy_Condition_MetricThreshold(): AlertPolicy_Condition_MetricThreshold {
  return {
    filter: "",
    aggregations: [],
    denominatorFilter: "",
    denominatorAggregations: [],
    forecastOptions: undefined,
    comparison: 0,
    thresholdValue: 0,
    duration: undefined,
    trigger: undefined,
    evaluationMissingData: 0,
  };
}

export const AlertPolicy_Condition_MetricThreshold: MessageFns<AlertPolicy_Condition_MetricThreshold> = {
  encode(message: AlertPolicy_Condition_MetricThreshold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    for (const v of message.aggregations) {
      Aggregation.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.denominatorFilter !== "") {
      writer.uint32(74).string(message.denominatorFilter);
    }
    for (const v of message.denominatorAggregations) {
      Aggregation.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.forecastOptions !== undefined) {
      AlertPolicy_Condition_MetricThreshold_ForecastOptions.encode(message.forecastOptions, writer.uint32(98).fork())
        .join();
    }
    if (message.comparison !== 0) {
      writer.uint32(32).int32(message.comparison);
    }
    if (message.thresholdValue !== 0) {
      writer.uint32(41).double(message.thresholdValue);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(50).fork()).join();
    }
    if (message.trigger !== undefined) {
      AlertPolicy_Condition_Trigger.encode(message.trigger, writer.uint32(58).fork()).join();
    }
    if (message.evaluationMissingData !== 0) {
      writer.uint32(88).int32(message.evaluationMissingData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_MetricThreshold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_MetricThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.aggregations.push(Aggregation.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.denominatorFilter = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.denominatorAggregations.push(Aggregation.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.forecastOptions = AlertPolicy_Condition_MetricThreshold_ForecastOptions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.comparison = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.thresholdValue = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.trigger = AlertPolicy_Condition_Trigger.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.evaluationMissingData = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_MetricThreshold {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => Aggregation.fromJSON(e))
        : [],
      denominatorFilter: isSet(object.denominatorFilter) ? globalThis.String(object.denominatorFilter) : "",
      denominatorAggregations: globalThis.Array.isArray(object?.denominatorAggregations)
        ? object.denominatorAggregations.map((e: any) => Aggregation.fromJSON(e))
        : [],
      forecastOptions: isSet(object.forecastOptions)
        ? AlertPolicy_Condition_MetricThreshold_ForecastOptions.fromJSON(object.forecastOptions)
        : undefined,
      comparison: isSet(object.comparison) ? comparisonTypeFromJSON(object.comparison) : 0,
      thresholdValue: isSet(object.thresholdValue) ? globalThis.Number(object.thresholdValue) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      trigger: isSet(object.trigger) ? AlertPolicy_Condition_Trigger.fromJSON(object.trigger) : undefined,
      evaluationMissingData: isSet(object.evaluationMissingData)
        ? alertPolicy_Condition_EvaluationMissingDataFromJSON(object.evaluationMissingData)
        : 0,
    };
  },

  toJSON(message: AlertPolicy_Condition_MetricThreshold): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => Aggregation.toJSON(e));
    }
    if (message.denominatorFilter !== "") {
      obj.denominatorFilter = message.denominatorFilter;
    }
    if (message.denominatorAggregations?.length) {
      obj.denominatorAggregations = message.denominatorAggregations.map((e) => Aggregation.toJSON(e));
    }
    if (message.forecastOptions !== undefined) {
      obj.forecastOptions = AlertPolicy_Condition_MetricThreshold_ForecastOptions.toJSON(message.forecastOptions);
    }
    if (message.comparison !== 0) {
      obj.comparison = comparisonTypeToJSON(message.comparison);
    }
    if (message.thresholdValue !== 0) {
      obj.thresholdValue = message.thresholdValue;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.trigger !== undefined) {
      obj.trigger = AlertPolicy_Condition_Trigger.toJSON(message.trigger);
    }
    if (message.evaluationMissingData !== 0) {
      obj.evaluationMissingData = alertPolicy_Condition_EvaluationMissingDataToJSON(message.evaluationMissingData);
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Condition_MetricThreshold>): AlertPolicy_Condition_MetricThreshold {
    return AlertPolicy_Condition_MetricThreshold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Condition_MetricThreshold>): AlertPolicy_Condition_MetricThreshold {
    const message = createBaseAlertPolicy_Condition_MetricThreshold();
    message.filter = object.filter ?? "";
    message.aggregations = object.aggregations?.map((e) => Aggregation.fromPartial(e)) || [];
    message.denominatorFilter = object.denominatorFilter ?? "";
    message.denominatorAggregations = object.denominatorAggregations?.map((e) => Aggregation.fromPartial(e)) || [];
    message.forecastOptions = (object.forecastOptions !== undefined && object.forecastOptions !== null)
      ? AlertPolicy_Condition_MetricThreshold_ForecastOptions.fromPartial(object.forecastOptions)
      : undefined;
    message.comparison = object.comparison ?? 0;
    message.thresholdValue = object.thresholdValue ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? AlertPolicy_Condition_Trigger.fromPartial(object.trigger)
      : undefined;
    message.evaluationMissingData = object.evaluationMissingData ?? 0;
    return message;
  },
};

function createBaseAlertPolicy_Condition_MetricThreshold_ForecastOptions(): AlertPolicy_Condition_MetricThreshold_ForecastOptions {
  return { forecastHorizon: undefined };
}

export const AlertPolicy_Condition_MetricThreshold_ForecastOptions: MessageFns<
  AlertPolicy_Condition_MetricThreshold_ForecastOptions
> = {
  encode(
    message: AlertPolicy_Condition_MetricThreshold_ForecastOptions,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.forecastHorizon !== undefined) {
      Duration.encode(message.forecastHorizon, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_MetricThreshold_ForecastOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_MetricThreshold_ForecastOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.forecastHorizon = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_MetricThreshold_ForecastOptions {
    return { forecastHorizon: isSet(object.forecastHorizon) ? Duration.fromJSON(object.forecastHorizon) : undefined };
  },

  toJSON(message: AlertPolicy_Condition_MetricThreshold_ForecastOptions): unknown {
    const obj: any = {};
    if (message.forecastHorizon !== undefined) {
      obj.forecastHorizon = Duration.toJSON(message.forecastHorizon);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_Condition_MetricThreshold_ForecastOptions>,
  ): AlertPolicy_Condition_MetricThreshold_ForecastOptions {
    return AlertPolicy_Condition_MetricThreshold_ForecastOptions.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_Condition_MetricThreshold_ForecastOptions>,
  ): AlertPolicy_Condition_MetricThreshold_ForecastOptions {
    const message = createBaseAlertPolicy_Condition_MetricThreshold_ForecastOptions();
    message.forecastHorizon = (object.forecastHorizon !== undefined && object.forecastHorizon !== null)
      ? Duration.fromPartial(object.forecastHorizon)
      : undefined;
    return message;
  },
};

function createBaseAlertPolicy_Condition_MetricAbsence(): AlertPolicy_Condition_MetricAbsence {
  return { filter: "", aggregations: [], duration: undefined, trigger: undefined };
}

export const AlertPolicy_Condition_MetricAbsence: MessageFns<AlertPolicy_Condition_MetricAbsence> = {
  encode(message: AlertPolicy_Condition_MetricAbsence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    for (const v of message.aggregations) {
      Aggregation.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.trigger !== undefined) {
      AlertPolicy_Condition_Trigger.encode(message.trigger, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_MetricAbsence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_MetricAbsence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aggregations.push(Aggregation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trigger = AlertPolicy_Condition_Trigger.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_MetricAbsence {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => Aggregation.fromJSON(e))
        : [],
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      trigger: isSet(object.trigger) ? AlertPolicy_Condition_Trigger.fromJSON(object.trigger) : undefined,
    };
  },

  toJSON(message: AlertPolicy_Condition_MetricAbsence): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => Aggregation.toJSON(e));
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.trigger !== undefined) {
      obj.trigger = AlertPolicy_Condition_Trigger.toJSON(message.trigger);
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Condition_MetricAbsence>): AlertPolicy_Condition_MetricAbsence {
    return AlertPolicy_Condition_MetricAbsence.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Condition_MetricAbsence>): AlertPolicy_Condition_MetricAbsence {
    const message = createBaseAlertPolicy_Condition_MetricAbsence();
    message.filter = object.filter ?? "";
    message.aggregations = object.aggregations?.map((e) => Aggregation.fromPartial(e)) || [];
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? AlertPolicy_Condition_Trigger.fromPartial(object.trigger)
      : undefined;
    return message;
  },
};

function createBaseAlertPolicy_Condition_LogMatch(): AlertPolicy_Condition_LogMatch {
  return { filter: "", labelExtractors: {} };
}

export const AlertPolicy_Condition_LogMatch: MessageFns<AlertPolicy_Condition_LogMatch> = {
  encode(message: AlertPolicy_Condition_LogMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== "") {
      writer.uint32(10).string(message.filter);
    }
    Object.entries(message.labelExtractors).forEach(([key, value]) => {
      AlertPolicy_Condition_LogMatch_LabelExtractorsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_LogMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_LogMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AlertPolicy_Condition_LogMatch_LabelExtractorsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labelExtractors[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_LogMatch {
    return {
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      labelExtractors: isObject(object.labelExtractors)
        ? Object.entries(object.labelExtractors).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AlertPolicy_Condition_LogMatch): unknown {
    const obj: any = {};
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.labelExtractors) {
      const entries = Object.entries(message.labelExtractors);
      if (entries.length > 0) {
        obj.labelExtractors = {};
        entries.forEach(([k, v]) => {
          obj.labelExtractors[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_Condition_LogMatch>): AlertPolicy_Condition_LogMatch {
    return AlertPolicy_Condition_LogMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_Condition_LogMatch>): AlertPolicy_Condition_LogMatch {
    const message = createBaseAlertPolicy_Condition_LogMatch();
    message.filter = object.filter ?? "";
    message.labelExtractors = Object.entries(object.labelExtractors ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAlertPolicy_Condition_LogMatch_LabelExtractorsEntry(): AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
  return { key: "", value: "" };
}

export const AlertPolicy_Condition_LogMatch_LabelExtractorsEntry: MessageFns<
  AlertPolicy_Condition_LogMatch_LabelExtractorsEntry
> = {
  encode(
    message: AlertPolicy_Condition_LogMatch_LabelExtractorsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_LogMatch_LabelExtractorsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlertPolicy_Condition_LogMatch_LabelExtractorsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_Condition_LogMatch_LabelExtractorsEntry>,
  ): AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
    return AlertPolicy_Condition_LogMatch_LabelExtractorsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_Condition_LogMatch_LabelExtractorsEntry>,
  ): AlertPolicy_Condition_LogMatch_LabelExtractorsEntry {
    const message = createBaseAlertPolicy_Condition_LogMatch_LabelExtractorsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlertPolicy_Condition_MonitoringQueryLanguageCondition(): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
  return { query: "", duration: undefined, trigger: undefined, evaluationMissingData: 0 };
}

export const AlertPolicy_Condition_MonitoringQueryLanguageCondition: MessageFns<
  AlertPolicy_Condition_MonitoringQueryLanguageCondition
> = {
  encode(
    message: AlertPolicy_Condition_MonitoringQueryLanguageCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.trigger !== undefined) {
      AlertPolicy_Condition_Trigger.encode(message.trigger, writer.uint32(26).fork()).join();
    }
    if (message.evaluationMissingData !== 0) {
      writer.uint32(32).int32(message.evaluationMissingData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_MonitoringQueryLanguageCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.trigger = AlertPolicy_Condition_Trigger.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.evaluationMissingData = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      trigger: isSet(object.trigger) ? AlertPolicy_Condition_Trigger.fromJSON(object.trigger) : undefined,
      evaluationMissingData: isSet(object.evaluationMissingData)
        ? alertPolicy_Condition_EvaluationMissingDataFromJSON(object.evaluationMissingData)
        : 0,
    };
  },

  toJSON(message: AlertPolicy_Condition_MonitoringQueryLanguageCondition): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.trigger !== undefined) {
      obj.trigger = AlertPolicy_Condition_Trigger.toJSON(message.trigger);
    }
    if (message.evaluationMissingData !== 0) {
      obj.evaluationMissingData = alertPolicy_Condition_EvaluationMissingDataToJSON(message.evaluationMissingData);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_Condition_MonitoringQueryLanguageCondition>,
  ): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    return AlertPolicy_Condition_MonitoringQueryLanguageCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_Condition_MonitoringQueryLanguageCondition>,
  ): AlertPolicy_Condition_MonitoringQueryLanguageCondition {
    const message = createBaseAlertPolicy_Condition_MonitoringQueryLanguageCondition();
    message.query = object.query ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? AlertPolicy_Condition_Trigger.fromPartial(object.trigger)
      : undefined;
    message.evaluationMissingData = object.evaluationMissingData ?? 0;
    return message;
  },
};

function createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition(): AlertPolicy_Condition_PrometheusQueryLanguageCondition {
  return { query: "", duration: undefined, evaluationInterval: undefined, labels: {}, ruleGroup: "", alertRule: "" };
}

export const AlertPolicy_Condition_PrometheusQueryLanguageCondition: MessageFns<
  AlertPolicy_Condition_PrometheusQueryLanguageCondition
> = {
  encode(
    message: AlertPolicy_Condition_PrometheusQueryLanguageCondition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.evaluationInterval !== undefined) {
      Duration.encode(message.evaluationInterval, writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).join();
    });
    if (message.ruleGroup !== "") {
      writer.uint32(42).string(message.ruleGroup);
    }
    if (message.alertRule !== "") {
      writer.uint32(50).string(message.alertRule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_Condition_PrometheusQueryLanguageCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.evaluationInterval = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ruleGroup = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.alertRule = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_PrometheusQueryLanguageCondition {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      evaluationInterval: isSet(object.evaluationInterval) ? Duration.fromJSON(object.evaluationInterval) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      ruleGroup: isSet(object.ruleGroup) ? globalThis.String(object.ruleGroup) : "",
      alertRule: isSet(object.alertRule) ? globalThis.String(object.alertRule) : "",
    };
  },

  toJSON(message: AlertPolicy_Condition_PrometheusQueryLanguageCondition): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.evaluationInterval !== undefined) {
      obj.evaluationInterval = Duration.toJSON(message.evaluationInterval);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.ruleGroup !== "") {
      obj.ruleGroup = message.ruleGroup;
    }
    if (message.alertRule !== "") {
      obj.alertRule = message.alertRule;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_Condition_PrometheusQueryLanguageCondition>,
  ): AlertPolicy_Condition_PrometheusQueryLanguageCondition {
    return AlertPolicy_Condition_PrometheusQueryLanguageCondition.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_Condition_PrometheusQueryLanguageCondition>,
  ): AlertPolicy_Condition_PrometheusQueryLanguageCondition {
    const message = createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition();
    message.query = object.query ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.evaluationInterval = (object.evaluationInterval !== undefined && object.evaluationInterval !== null)
      ? Duration.fromPartial(object.evaluationInterval)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.ruleGroup = object.ruleGroup ?? "";
    message.alertRule = object.alertRule ?? "";
    return message;
  },
};

function createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry(): AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
  return { key: "", value: "" };
}

export const AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry: MessageFns<
  AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry
> = {
  encode(
    message: AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry>,
  ): AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
    return AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry>,
  ): AlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry {
    const message = createBaseAlertPolicy_Condition_PrometheusQueryLanguageCondition_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAlertPolicy_AlertStrategy(): AlertPolicy_AlertStrategy {
  return { notificationRateLimit: undefined, autoClose: undefined, notificationChannelStrategy: [] };
}

export const AlertPolicy_AlertStrategy: MessageFns<AlertPolicy_AlertStrategy> = {
  encode(message: AlertPolicy_AlertStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notificationRateLimit !== undefined) {
      AlertPolicy_AlertStrategy_NotificationRateLimit.encode(message.notificationRateLimit, writer.uint32(10).fork())
        .join();
    }
    if (message.autoClose !== undefined) {
      Duration.encode(message.autoClose, writer.uint32(26).fork()).join();
    }
    for (const v of message.notificationChannelStrategy) {
      AlertPolicy_AlertStrategy_NotificationChannelStrategy.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_AlertStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_AlertStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notificationRateLimit = AlertPolicy_AlertStrategy_NotificationRateLimit.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.autoClose = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.notificationChannelStrategy.push(
            AlertPolicy_AlertStrategy_NotificationChannelStrategy.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_AlertStrategy {
    return {
      notificationRateLimit: isSet(object.notificationRateLimit)
        ? AlertPolicy_AlertStrategy_NotificationRateLimit.fromJSON(object.notificationRateLimit)
        : undefined,
      autoClose: isSet(object.autoClose) ? Duration.fromJSON(object.autoClose) : undefined,
      notificationChannelStrategy: globalThis.Array.isArray(object?.notificationChannelStrategy)
        ? object.notificationChannelStrategy.map((e: any) =>
          AlertPolicy_AlertStrategy_NotificationChannelStrategy.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: AlertPolicy_AlertStrategy): unknown {
    const obj: any = {};
    if (message.notificationRateLimit !== undefined) {
      obj.notificationRateLimit = AlertPolicy_AlertStrategy_NotificationRateLimit.toJSON(message.notificationRateLimit);
    }
    if (message.autoClose !== undefined) {
      obj.autoClose = Duration.toJSON(message.autoClose);
    }
    if (message.notificationChannelStrategy?.length) {
      obj.notificationChannelStrategy = message.notificationChannelStrategy.map((e) =>
        AlertPolicy_AlertStrategy_NotificationChannelStrategy.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_AlertStrategy>): AlertPolicy_AlertStrategy {
    return AlertPolicy_AlertStrategy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_AlertStrategy>): AlertPolicy_AlertStrategy {
    const message = createBaseAlertPolicy_AlertStrategy();
    message.notificationRateLimit =
      (object.notificationRateLimit !== undefined && object.notificationRateLimit !== null)
        ? AlertPolicy_AlertStrategy_NotificationRateLimit.fromPartial(object.notificationRateLimit)
        : undefined;
    message.autoClose = (object.autoClose !== undefined && object.autoClose !== null)
      ? Duration.fromPartial(object.autoClose)
      : undefined;
    message.notificationChannelStrategy =
      object.notificationChannelStrategy?.map((e) =>
        AlertPolicy_AlertStrategy_NotificationChannelStrategy.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseAlertPolicy_AlertStrategy_NotificationRateLimit(): AlertPolicy_AlertStrategy_NotificationRateLimit {
  return { period: undefined };
}

export const AlertPolicy_AlertStrategy_NotificationRateLimit: MessageFns<
  AlertPolicy_AlertStrategy_NotificationRateLimit
> = {
  encode(
    message: AlertPolicy_AlertStrategy_NotificationRateLimit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.period !== undefined) {
      Duration.encode(message.period, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_AlertStrategy_NotificationRateLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_AlertStrategy_NotificationRateLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.period = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_AlertStrategy_NotificationRateLimit {
    return { period: isSet(object.period) ? Duration.fromJSON(object.period) : undefined };
  },

  toJSON(message: AlertPolicy_AlertStrategy_NotificationRateLimit): unknown {
    const obj: any = {};
    if (message.period !== undefined) {
      obj.period = Duration.toJSON(message.period);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_AlertStrategy_NotificationRateLimit>,
  ): AlertPolicy_AlertStrategy_NotificationRateLimit {
    return AlertPolicy_AlertStrategy_NotificationRateLimit.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_AlertStrategy_NotificationRateLimit>,
  ): AlertPolicy_AlertStrategy_NotificationRateLimit {
    const message = createBaseAlertPolicy_AlertStrategy_NotificationRateLimit();
    message.period = (object.period !== undefined && object.period !== null)
      ? Duration.fromPartial(object.period)
      : undefined;
    return message;
  },
};

function createBaseAlertPolicy_AlertStrategy_NotificationChannelStrategy(): AlertPolicy_AlertStrategy_NotificationChannelStrategy {
  return { notificationChannelNames: [], renotifyInterval: undefined };
}

export const AlertPolicy_AlertStrategy_NotificationChannelStrategy: MessageFns<
  AlertPolicy_AlertStrategy_NotificationChannelStrategy
> = {
  encode(
    message: AlertPolicy_AlertStrategy_NotificationChannelStrategy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.notificationChannelNames) {
      writer.uint32(10).string(v!);
    }
    if (message.renotifyInterval !== undefined) {
      Duration.encode(message.renotifyInterval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_AlertStrategy_NotificationChannelStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_AlertStrategy_NotificationChannelStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notificationChannelNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.renotifyInterval = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_AlertStrategy_NotificationChannelStrategy {
    return {
      notificationChannelNames: globalThis.Array.isArray(object?.notificationChannelNames)
        ? object.notificationChannelNames.map((e: any) => globalThis.String(e))
        : [],
      renotifyInterval: isSet(object.renotifyInterval) ? Duration.fromJSON(object.renotifyInterval) : undefined,
    };
  },

  toJSON(message: AlertPolicy_AlertStrategy_NotificationChannelStrategy): unknown {
    const obj: any = {};
    if (message.notificationChannelNames?.length) {
      obj.notificationChannelNames = message.notificationChannelNames;
    }
    if (message.renotifyInterval !== undefined) {
      obj.renotifyInterval = Duration.toJSON(message.renotifyInterval);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AlertPolicy_AlertStrategy_NotificationChannelStrategy>,
  ): AlertPolicy_AlertStrategy_NotificationChannelStrategy {
    return AlertPolicy_AlertStrategy_NotificationChannelStrategy.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AlertPolicy_AlertStrategy_NotificationChannelStrategy>,
  ): AlertPolicy_AlertStrategy_NotificationChannelStrategy {
    const message = createBaseAlertPolicy_AlertStrategy_NotificationChannelStrategy();
    message.notificationChannelNames = object.notificationChannelNames?.map((e) => e) || [];
    message.renotifyInterval = (object.renotifyInterval !== undefined && object.renotifyInterval !== null)
      ? Duration.fromPartial(object.renotifyInterval)
      : undefined;
    return message;
  },
};

function createBaseAlertPolicy_UserLabelsEntry(): AlertPolicy_UserLabelsEntry {
  return { key: "", value: "" };
}

export const AlertPolicy_UserLabelsEntry: MessageFns<AlertPolicy_UserLabelsEntry> = {
  encode(message: AlertPolicy_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertPolicy_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertPolicy_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertPolicy_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AlertPolicy_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AlertPolicy_UserLabelsEntry>): AlertPolicy_UserLabelsEntry {
    return AlertPolicy_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertPolicy_UserLabelsEntry>): AlertPolicy_UserLabelsEntry {
    const message = createBaseAlertPolicy_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
