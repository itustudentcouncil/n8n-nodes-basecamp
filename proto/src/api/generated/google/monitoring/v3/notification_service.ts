// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/notification_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../protobuf/empty.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { NotificationChannel, NotificationChannelDescriptor } from "./notification.js";

export const protobufPackage = "google.monitoring.v3";

/** The `ListNotificationChannelDescriptors` request. */
export interface ListNotificationChannelDescriptorsRequest {
  /**
   * Required. The REST resource name of the parent from which to retrieve
   * the notification channel descriptors. The expected syntax is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   *
   * Note that this
   * [names](https://cloud.google.com/monitoring/api/v3#project_name) the parent
   * container in which to look for the descriptors; to retrieve a single
   * descriptor by name, use the
   * [GetNotificationChannelDescriptor][google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]
   * operation, instead.
   */
  name: string;
  /**
   * The maximum number of results to return in a single response. If
   * not set to a positive number, a reasonable value will be chosen by the
   * service.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` must contain a value returned as the
   * `next_page_token` in a previous response to request the next set
   * of results.
   */
  pageToken: string;
}

/** The `ListNotificationChannelDescriptors` response. */
export interface ListNotificationChannelDescriptorsResponse {
  /**
   * The monitored resource descriptors supported for the specified
   * project, optionally filtered.
   */
  channelDescriptors: NotificationChannelDescriptor[];
  /**
   * If not empty, indicates that there may be more results that match
   * the request. Use the value in the `page_token` field in a
   * subsequent request to fetch the next set of results. If empty,
   * all results have been returned.
   */
  nextPageToken: string;
}

/** The `GetNotificationChannelDescriptor` response. */
export interface GetNotificationChannelDescriptorRequest {
  /**
   * Required. The channel type for which to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
   */
  name: string;
}

/** The `CreateNotificationChannel` request. */
export interface CreateNotificationChannelRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   *
   * This names the container into which the channel will be
   * written, this does not name the newly created channel. The resulting
   * channel's name will have a normalized version of this field as a prefix,
   * but will add `/notificationChannels/[CHANNEL_ID]` to identify the channel.
   */
  name: string;
  /** Required. The definition of the `NotificationChannel` to create. */
  notificationChannel: NotificationChannel | undefined;
}

/** The `ListNotificationChannels` request. */
export interface ListNotificationChannelsRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   *
   * This names the container
   * in which to look for the notification channels; it does not name a
   * specific channel. To query a specific channel by REST resource name, use
   * the
   * [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
   * operation.
   */
  name: string;
  /**
   * If provided, this field specifies the criteria that must be met by
   * notification channels to be included in the response.
   *
   * For more details, see [sorting and
   * filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
   */
  filter: string;
  /**
   * A comma-separated list of fields by which to sort the result. Supports
   * the same set of fields as in `filter`. Entries can be prefixed with
   * a minus sign to sort in descending rather than ascending order.
   *
   * For more details, see [sorting and
   * filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
   */
  orderBy: string;
  /**
   * The maximum number of results to return in a single response. If
   * not set to a positive number, a reasonable value will be chosen by the
   * service.
   */
  pageSize: number;
  /**
   * If non-empty, `page_token` must contain a value returned as the
   * `next_page_token` in a previous response to request the next set
   * of results.
   */
  pageToken: string;
}

/** The `ListNotificationChannels` response. */
export interface ListNotificationChannelsResponse {
  /** The notification channels defined for the specified project. */
  notificationChannels: NotificationChannel[];
  /**
   * If not empty, indicates that there may be more results that match
   * the request. Use the value in the `page_token` field in a
   * subsequent request to fetch the next set of results. If empty,
   * all results have been returned.
   */
  nextPageToken: string;
  /**
   * The total number of notification channels in all pages. This number is only
   * an estimate, and may change in subsequent pages. https://aip.dev/158
   */
  totalSize: number;
}

/** The `GetNotificationChannel` request. */
export interface GetNotificationChannelRequest {
  /**
   * Required. The channel for which to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   */
  name: string;
}

/** The `UpdateNotificationChannel` request. */
export interface UpdateNotificationChannelRequest {
  /** The fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Required. A description of the changes to be applied to the specified
   * notification channel. The description must provide a definition for
   * fields to be updated; the names of these fields should also be
   * included in the `update_mask`.
   */
  notificationChannel: NotificationChannel | undefined;
}

/** The `DeleteNotificationChannel` request. */
export interface DeleteNotificationChannelRequest {
  /**
   * Required. The channel for which to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
   */
  name: string;
  /**
   * If true, the notification channel will be deleted regardless of its
   * use in alert policies (the policies will be updated to remove the
   * channel). If false, channels that are still referenced by an existing
   * alerting policy will fail to be deleted in a delete operation.
   */
  force: boolean;
}

/** The `SendNotificationChannelVerificationCode` request. */
export interface SendNotificationChannelVerificationCodeRequest {
  /** Required. The notification channel to which to send a verification code. */
  name: string;
}

/** The `GetNotificationChannelVerificationCode` request. */
export interface GetNotificationChannelVerificationCodeRequest {
  /**
   * Required. The notification channel for which a verification code is to be
   * generated and retrieved. This must name a channel that is already verified;
   * if the specified channel is not verified, the request will fail.
   */
  name: string;
  /**
   * The desired expiration time. If specified, the API will guarantee that
   * the returned code will not be valid after the specified timestamp;
   * however, the API cannot guarantee that the returned code will be
   * valid for at least as long as the requested time (the API puts an upper
   * bound on the amount of time for which a code may be valid). If omitted,
   * a default expiration will be used, which may be less than the max
   * permissible expiration (so specifying an expiration may extend the
   * code's lifetime over omitting an expiration, even though the API does
   * impose an upper limit on the maximum expiration that is permitted).
   */
  expireTime: Date | undefined;
}

/** The `GetNotificationChannelVerificationCode` request. */
export interface GetNotificationChannelVerificationCodeResponse {
  /**
   * The verification code, which may be used to verify other channels
   * that have an equivalent identity (i.e. other channels of the same
   * type with the same fingerprint such as other email channels with
   * the same email address or other sms channels with the same number).
   */
  code: string;
  /**
   * The expiration time associated with the code that was returned. If
   * an expiration was provided in the request, this is the minimum of the
   * requested expiration in the request and the max permitted expiration.
   */
  expireTime: Date | undefined;
}

/** The `VerifyNotificationChannel` request. */
export interface VerifyNotificationChannelRequest {
  /** Required. The notification channel to verify. */
  name: string;
  /**
   * Required. The verification code that was delivered to the channel as
   * a result of invoking the `SendNotificationChannelVerificationCode` API
   * method or that was retrieved from a verified channel via
   * `GetNotificationChannelVerificationCode`. For example, one might have
   * "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only
   * guaranteed that the code is valid UTF-8; one should not
   * make any assumptions regarding the structure or format of the code).
   */
  code: string;
}

function createBaseListNotificationChannelDescriptorsRequest(): ListNotificationChannelDescriptorsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListNotificationChannelDescriptorsRequest: MessageFns<ListNotificationChannelDescriptorsRequest> = {
  encode(message: ListNotificationChannelDescriptorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationChannelDescriptorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationChannelDescriptorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationChannelDescriptorsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNotificationChannelDescriptorsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationChannelDescriptorsRequest>): ListNotificationChannelDescriptorsRequest {
    return ListNotificationChannelDescriptorsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListNotificationChannelDescriptorsRequest>,
  ): ListNotificationChannelDescriptorsRequest {
    const message = createBaseListNotificationChannelDescriptorsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNotificationChannelDescriptorsResponse(): ListNotificationChannelDescriptorsResponse {
  return { channelDescriptors: [], nextPageToken: "" };
}

export const ListNotificationChannelDescriptorsResponse: MessageFns<ListNotificationChannelDescriptorsResponse> = {
  encode(message: ListNotificationChannelDescriptorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channelDescriptors) {
      NotificationChannelDescriptor.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationChannelDescriptorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationChannelDescriptorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelDescriptors.push(NotificationChannelDescriptor.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationChannelDescriptorsResponse {
    return {
      channelDescriptors: globalThis.Array.isArray(object?.channelDescriptors)
        ? object.channelDescriptors.map((e: any) => NotificationChannelDescriptor.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNotificationChannelDescriptorsResponse): unknown {
    const obj: any = {};
    if (message.channelDescriptors?.length) {
      obj.channelDescriptors = message.channelDescriptors.map((e) => NotificationChannelDescriptor.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationChannelDescriptorsResponse>): ListNotificationChannelDescriptorsResponse {
    return ListNotificationChannelDescriptorsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListNotificationChannelDescriptorsResponse>,
  ): ListNotificationChannelDescriptorsResponse {
    const message = createBaseListNotificationChannelDescriptorsResponse();
    message.channelDescriptors = object.channelDescriptors?.map((e) => NotificationChannelDescriptor.fromPartial(e)) ||
      [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetNotificationChannelDescriptorRequest(): GetNotificationChannelDescriptorRequest {
  return { name: "" };
}

export const GetNotificationChannelDescriptorRequest: MessageFns<GetNotificationChannelDescriptorRequest> = {
  encode(message: GetNotificationChannelDescriptorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationChannelDescriptorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationChannelDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationChannelDescriptorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNotificationChannelDescriptorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNotificationChannelDescriptorRequest>): GetNotificationChannelDescriptorRequest {
    return GetNotificationChannelDescriptorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNotificationChannelDescriptorRequest>): GetNotificationChannelDescriptorRequest {
    const message = createBaseGetNotificationChannelDescriptorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNotificationChannelRequest(): CreateNotificationChannelRequest {
  return { name: "", notificationChannel: undefined };
}

export const CreateNotificationChannelRequest: MessageFns<CreateNotificationChannelRequest> = {
  encode(message: CreateNotificationChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.notificationChannel !== undefined) {
      NotificationChannel.encode(message.notificationChannel, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNotificationChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNotificationChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notificationChannel = NotificationChannel.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNotificationChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      notificationChannel: isSet(object.notificationChannel)
        ? NotificationChannel.fromJSON(object.notificationChannel)
        : undefined,
    };
  },

  toJSON(message: CreateNotificationChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.notificationChannel !== undefined) {
      obj.notificationChannel = NotificationChannel.toJSON(message.notificationChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNotificationChannelRequest>): CreateNotificationChannelRequest {
    return CreateNotificationChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNotificationChannelRequest>): CreateNotificationChannelRequest {
    const message = createBaseCreateNotificationChannelRequest();
    message.name = object.name ?? "";
    message.notificationChannel = (object.notificationChannel !== undefined && object.notificationChannel !== null)
      ? NotificationChannel.fromPartial(object.notificationChannel)
      : undefined;
    return message;
  },
};

function createBaseListNotificationChannelsRequest(): ListNotificationChannelsRequest {
  return { name: "", filter: "", orderBy: "", pageSize: 0, pageToken: "" };
}

export const ListNotificationChannelsRequest: MessageFns<ListNotificationChannelsRequest> = {
  encode(message: ListNotificationChannelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(50).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(58).string(message.orderBy);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationChannelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationChannelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationChannelsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNotificationChannelsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationChannelsRequest>): ListNotificationChannelsRequest {
    return ListNotificationChannelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotificationChannelsRequest>): ListNotificationChannelsRequest {
    const message = createBaseListNotificationChannelsRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNotificationChannelsResponse(): ListNotificationChannelsResponse {
  return { notificationChannels: [], nextPageToken: "", totalSize: 0 };
}

export const ListNotificationChannelsResponse: MessageFns<ListNotificationChannelsResponse> = {
  encode(message: ListNotificationChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.notificationChannels) {
      NotificationChannel.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(32).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationChannelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notificationChannels.push(NotificationChannel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationChannelsResponse {
    return {
      notificationChannels: globalThis.Array.isArray(object?.notificationChannels)
        ? object.notificationChannels.map((e: any) => NotificationChannel.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: ListNotificationChannelsResponse): unknown {
    const obj: any = {};
    if (message.notificationChannels?.length) {
      obj.notificationChannels = message.notificationChannels.map((e) => NotificationChannel.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationChannelsResponse>): ListNotificationChannelsResponse {
    return ListNotificationChannelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotificationChannelsResponse>): ListNotificationChannelsResponse {
    const message = createBaseListNotificationChannelsResponse();
    message.notificationChannels = object.notificationChannels?.map((e) => NotificationChannel.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseGetNotificationChannelRequest(): GetNotificationChannelRequest {
  return { name: "" };
}

export const GetNotificationChannelRequest: MessageFns<GetNotificationChannelRequest> = {
  encode(message: GetNotificationChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationChannelRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNotificationChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNotificationChannelRequest>): GetNotificationChannelRequest {
    return GetNotificationChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNotificationChannelRequest>): GetNotificationChannelRequest {
    const message = createBaseGetNotificationChannelRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNotificationChannelRequest(): UpdateNotificationChannelRequest {
  return { updateMask: undefined, notificationChannel: undefined };
}

export const UpdateNotificationChannelRequest: MessageFns<UpdateNotificationChannelRequest> = {
  encode(message: UpdateNotificationChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.notificationChannel !== undefined) {
      NotificationChannel.encode(message.notificationChannel, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNotificationChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNotificationChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notificationChannel = NotificationChannel.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNotificationChannelRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      notificationChannel: isSet(object.notificationChannel)
        ? NotificationChannel.fromJSON(object.notificationChannel)
        : undefined,
    };
  },

  toJSON(message: UpdateNotificationChannelRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.notificationChannel !== undefined) {
      obj.notificationChannel = NotificationChannel.toJSON(message.notificationChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNotificationChannelRequest>): UpdateNotificationChannelRequest {
    return UpdateNotificationChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNotificationChannelRequest>): UpdateNotificationChannelRequest {
    const message = createBaseUpdateNotificationChannelRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.notificationChannel = (object.notificationChannel !== undefined && object.notificationChannel !== null)
      ? NotificationChannel.fromPartial(object.notificationChannel)
      : undefined;
    return message;
  },
};

function createBaseDeleteNotificationChannelRequest(): DeleteNotificationChannelRequest {
  return { name: "", force: false };
}

export const DeleteNotificationChannelRequest: MessageFns<DeleteNotificationChannelRequest> = {
  encode(message: DeleteNotificationChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(40).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNotificationChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNotificationChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNotificationChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteNotificationChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNotificationChannelRequest>): DeleteNotificationChannelRequest {
    return DeleteNotificationChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNotificationChannelRequest>): DeleteNotificationChannelRequest {
    const message = createBaseDeleteNotificationChannelRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseSendNotificationChannelVerificationCodeRequest(): SendNotificationChannelVerificationCodeRequest {
  return { name: "" };
}

export const SendNotificationChannelVerificationCodeRequest: MessageFns<
  SendNotificationChannelVerificationCodeRequest
> = {
  encode(
    message: SendNotificationChannelVerificationCodeRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendNotificationChannelVerificationCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendNotificationChannelVerificationCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendNotificationChannelVerificationCodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: SendNotificationChannelVerificationCodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SendNotificationChannelVerificationCodeRequest>,
  ): SendNotificationChannelVerificationCodeRequest {
    return SendNotificationChannelVerificationCodeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SendNotificationChannelVerificationCodeRequest>,
  ): SendNotificationChannelVerificationCodeRequest {
    const message = createBaseSendNotificationChannelVerificationCodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetNotificationChannelVerificationCodeRequest(): GetNotificationChannelVerificationCodeRequest {
  return { name: "", expireTime: undefined };
}

export const GetNotificationChannelVerificationCodeRequest: MessageFns<GetNotificationChannelVerificationCodeRequest> =
  {
    encode(
      message: GetNotificationChannelVerificationCodeRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.expireTime !== undefined) {
        Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationChannelVerificationCodeRequest {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGetNotificationChannelVerificationCodeRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GetNotificationChannelVerificationCodeRequest {
      return {
        name: isSet(object.name) ? globalThis.String(object.name) : "",
        expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      };
    },

    toJSON(message: GetNotificationChannelVerificationCodeRequest): unknown {
      const obj: any = {};
      if (message.name !== "") {
        obj.name = message.name;
      }
      if (message.expireTime !== undefined) {
        obj.expireTime = message.expireTime.toISOString();
      }
      return obj;
    },

    create(
      base?: DeepPartial<GetNotificationChannelVerificationCodeRequest>,
    ): GetNotificationChannelVerificationCodeRequest {
      return GetNotificationChannelVerificationCodeRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GetNotificationChannelVerificationCodeRequest>,
    ): GetNotificationChannelVerificationCodeRequest {
      const message = createBaseGetNotificationChannelVerificationCodeRequest();
      message.name = object.name ?? "";
      message.expireTime = object.expireTime ?? undefined;
      return message;
    },
  };

function createBaseGetNotificationChannelVerificationCodeResponse(): GetNotificationChannelVerificationCodeResponse {
  return { code: "", expireTime: undefined };
}

export const GetNotificationChannelVerificationCodeResponse: MessageFns<
  GetNotificationChannelVerificationCodeResponse
> = {
  encode(
    message: GetNotificationChannelVerificationCodeResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNotificationChannelVerificationCodeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNotificationChannelVerificationCodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNotificationChannelVerificationCodeResponse {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: GetNotificationChannelVerificationCodeResponse): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetNotificationChannelVerificationCodeResponse>,
  ): GetNotificationChannelVerificationCodeResponse {
    return GetNotificationChannelVerificationCodeResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetNotificationChannelVerificationCodeResponse>,
  ): GetNotificationChannelVerificationCodeResponse {
    const message = createBaseGetNotificationChannelVerificationCodeResponse();
    message.code = object.code ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseVerifyNotificationChannelRequest(): VerifyNotificationChannelRequest {
  return { name: "", code: "" };
}

export const VerifyNotificationChannelRequest: MessageFns<VerifyNotificationChannelRequest> = {
  encode(message: VerifyNotificationChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyNotificationChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyNotificationChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyNotificationChannelRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
    };
  },

  toJSON(message: VerifyNotificationChannelRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<VerifyNotificationChannelRequest>): VerifyNotificationChannelRequest {
    return VerifyNotificationChannelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerifyNotificationChannelRequest>): VerifyNotificationChannelRequest {
    const message = createBaseVerifyNotificationChannelRequest();
    message.name = object.name ?? "";
    message.code = object.code ?? "";
    return message;
  },
};

/**
 * The Notification Channel API provides access to configuration that
 * controls how messages related to incidents are sent.
 */
export type NotificationChannelServiceDefinition = typeof NotificationChannelServiceDefinition;
export const NotificationChannelServiceDefinition = {
  name: "NotificationChannelService",
  fullName: "google.monitoring.v3.NotificationChannelService",
  methods: {
    /**
     * Lists the descriptors for supported channel types. The use of descriptors
     * makes it possible for new channel types to be dynamically added.
     */
    listNotificationChannelDescriptors: {
      name: "ListNotificationChannelDescriptors",
      requestType: ListNotificationChannelDescriptorsRequest,
      requestStream: false,
      responseType: ListNotificationChannelDescriptorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a single channel descriptor. The descriptor indicates which fields
     * are expected / permitted for a notification channel of the given type.
     */
    getNotificationChannelDescriptor: {
      name: "GetNotificationChannelDescriptor",
      requestType: GetNotificationChannelDescriptorRequest,
      requestStream: false,
      responseType: NotificationChannelDescriptor,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the notification channels that have been created for the project.
     * To list the types of notification channels that are supported, use
     * the `ListNotificationChannelDescriptors` method.
     */
    listNotificationChannels: {
      name: "ListNotificationChannels",
      requestType: ListNotificationChannelsRequest,
      requestStream: false,
      responseType: ListNotificationChannelsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets a single notification channel. The channel includes the relevant
     * configuration details with which the channel was created. However, the
     * response may truncate or omit passwords, API keys, or other private key
     * matter and thus the response may not be 100% identical to the information
     * that was supplied in the call to the create method.
     */
    getNotificationChannel: {
      name: "GetNotificationChannel",
      requestType: GetNotificationChannelRequest,
      requestStream: false,
      responseType: NotificationChannel,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new notification channel, representing a single notification
     * endpoint such as an email address, SMS number, or PagerDuty service.
     *
     * Design your application to single-thread API calls that modify the state of
     * notification channels in a single project. This includes calls to
     * CreateNotificationChannel, DeleteNotificationChannel and
     * UpdateNotificationChannel.
     */
    createNotificationChannel: {
      name: "CreateNotificationChannel",
      requestType: CreateNotificationChannelRequest,
      requestStream: false,
      responseType: NotificationChannel,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              110,
              97,
              109,
              101,
              44,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              20,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              34,
              42,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a notification channel. Fields not specified in the field mask
     * remain unchanged.
     *
     * Design your application to single-thread API calls that modify the state of
     * notification channels in a single project. This includes calls to
     * CreateNotificationChannel, DeleteNotificationChannel and
     * UpdateNotificationChannel.
     */
    updateNotificationChannel: {
      name: "UpdateNotificationChannel",
      requestType: UpdateNotificationChannelRequest,
      requestStream: false,
      responseType: NotificationChannel,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              32,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
              44,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
            ]),
          ],
          578365826: [
            Buffer.from([
              89,
              58,
              20,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              50,
              65,
              47,
              118,
              51,
              47,
              123,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              104,
              97,
              110,
              110,
              101,
              108,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a notification channel.
     *
     * Design your application to single-thread API calls that modify the state of
     * notification channels in a single project. This includes calls to
     * CreateNotificationChannel, DeleteNotificationChannel and
     * UpdateNotificationChannel.
     */
    deleteNotificationChannel: {
      name: "DeleteNotificationChannel",
      requestType: DeleteNotificationChannelRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 110, 97, 109, 101, 44, 102, 111, 114, 99, 101])],
          578365826: [
            Buffer.from([
              46,
              42,
              44,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Causes a verification code to be delivered to the channel. The code
     * can then be supplied in `VerifyNotificationChannel` to verify the channel.
     */
    sendNotificationChannelVerificationCode: {
      name: "SendNotificationChannelVerificationCode",
      requestType: SendNotificationChannelVerificationCodeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              110,
              100,
              86,
              101,
              114,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Requests a verification code for an already verified channel that can then
     * be used in a call to VerifyNotificationChannel() on a different channel
     * with an equivalent identity in the same or in a different project. This
     * makes it possible to copy a channel between projects without requiring
     * manual reverification of the channel. If the channel is not in the
     * verified state, this method will fail (in other words, this may only be
     * used if the SendNotificationChannelVerificationCode and
     * VerifyNotificationChannel paths have already been used to put the given
     * channel into the verified state).
     *
     * There is no guarantee that the verification codes returned by this method
     * will be of a similar structure or form as the ones that are delivered
     * to the channel via SendNotificationChannelVerificationCode; while
     * VerifyNotificationChannel() will recognize both the codes delivered via
     * SendNotificationChannelVerificationCode() and returned from
     * GetNotificationChannelVerificationCode(), it is typically the case that
     * the verification codes delivered via
     * SendNotificationChannelVerificationCode() will be shorter and also
     * have a shorter expiration (e.g. codes such as "G-123456") whereas
     * GetVerificationCode() will typically return a much longer, websafe base
     * 64 encoded string that has a longer expiration time.
     */
    getNotificationChannelVerificationCode: {
      name: "GetNotificationChannelVerificationCode",
      requestType: GetNotificationChannelVerificationCodeRequest,
      requestStream: false,
      responseType: GetNotificationChannelVerificationCodeResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              86,
              101,
              114,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Verifies a `NotificationChannel` by proving receipt of the code
     * delivered to the channel as a result of calling
     * `SendNotificationChannelVerificationCode`.
     */
    verifyNotificationChannel: {
      name: "VerifyNotificationChannel",
      requestType: VerifyNotificationChannelRequest,
      requestStream: false,
      responseType: NotificationChannel,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([9, 110, 97, 109, 101, 44, 99, 111, 100, 101])],
          578365826: [
            Buffer.from([
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              110,
              111,
              116,
              105,
              102,
              105,
              99,
              97,
              116,
              105,
              111,
              110,
              67,
              104,
              97,
              110,
              110,
              101,
              108,
              115,
              47,
              42,
              125,
              58,
              118,
              101,
              114,
              105,
              102,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface NotificationChannelServiceImplementation<CallContextExt = {}> {
  /**
   * Lists the descriptors for supported channel types. The use of descriptors
   * makes it possible for new channel types to be dynamically added.
   */
  listNotificationChannelDescriptors(
    request: ListNotificationChannelDescriptorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNotificationChannelDescriptorsResponse>>;
  /**
   * Gets a single channel descriptor. The descriptor indicates which fields
   * are expected / permitted for a notification channel of the given type.
   */
  getNotificationChannelDescriptor(
    request: GetNotificationChannelDescriptorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NotificationChannelDescriptor>>;
  /**
   * Lists the notification channels that have been created for the project.
   * To list the types of notification channels that are supported, use
   * the `ListNotificationChannelDescriptors` method.
   */
  listNotificationChannels(
    request: ListNotificationChannelsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNotificationChannelsResponse>>;
  /**
   * Gets a single notification channel. The channel includes the relevant
   * configuration details with which the channel was created. However, the
   * response may truncate or omit passwords, API keys, or other private key
   * matter and thus the response may not be 100% identical to the information
   * that was supplied in the call to the create method.
   */
  getNotificationChannel(
    request: GetNotificationChannelRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NotificationChannel>>;
  /**
   * Creates a new notification channel, representing a single notification
   * endpoint such as an email address, SMS number, or PagerDuty service.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  createNotificationChannel(
    request: CreateNotificationChannelRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NotificationChannel>>;
  /**
   * Updates a notification channel. Fields not specified in the field mask
   * remain unchanged.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  updateNotificationChannel(
    request: UpdateNotificationChannelRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NotificationChannel>>;
  /**
   * Deletes a notification channel.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  deleteNotificationChannel(
    request: DeleteNotificationChannelRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Causes a verification code to be delivered to the channel. The code
   * can then be supplied in `VerifyNotificationChannel` to verify the channel.
   */
  sendNotificationChannelVerificationCode(
    request: SendNotificationChannelVerificationCodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Requests a verification code for an already verified channel that can then
   * be used in a call to VerifyNotificationChannel() on a different channel
   * with an equivalent identity in the same or in a different project. This
   * makes it possible to copy a channel between projects without requiring
   * manual reverification of the channel. If the channel is not in the
   * verified state, this method will fail (in other words, this may only be
   * used if the SendNotificationChannelVerificationCode and
   * VerifyNotificationChannel paths have already been used to put the given
   * channel into the verified state).
   *
   * There is no guarantee that the verification codes returned by this method
   * will be of a similar structure or form as the ones that are delivered
   * to the channel via SendNotificationChannelVerificationCode; while
   * VerifyNotificationChannel() will recognize both the codes delivered via
   * SendNotificationChannelVerificationCode() and returned from
   * GetNotificationChannelVerificationCode(), it is typically the case that
   * the verification codes delivered via
   * SendNotificationChannelVerificationCode() will be shorter and also
   * have a shorter expiration (e.g. codes such as "G-123456") whereas
   * GetVerificationCode() will typically return a much longer, websafe base
   * 64 encoded string that has a longer expiration time.
   */
  getNotificationChannelVerificationCode(
    request: GetNotificationChannelVerificationCodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetNotificationChannelVerificationCodeResponse>>;
  /**
   * Verifies a `NotificationChannel` by proving receipt of the code
   * delivered to the channel as a result of calling
   * `SendNotificationChannelVerificationCode`.
   */
  verifyNotificationChannel(
    request: VerifyNotificationChannelRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NotificationChannel>>;
}

export interface NotificationChannelServiceClient<CallOptionsExt = {}> {
  /**
   * Lists the descriptors for supported channel types. The use of descriptors
   * makes it possible for new channel types to be dynamically added.
   */
  listNotificationChannelDescriptors(
    request: DeepPartial<ListNotificationChannelDescriptorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNotificationChannelDescriptorsResponse>;
  /**
   * Gets a single channel descriptor. The descriptor indicates which fields
   * are expected / permitted for a notification channel of the given type.
   */
  getNotificationChannelDescriptor(
    request: DeepPartial<GetNotificationChannelDescriptorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NotificationChannelDescriptor>;
  /**
   * Lists the notification channels that have been created for the project.
   * To list the types of notification channels that are supported, use
   * the `ListNotificationChannelDescriptors` method.
   */
  listNotificationChannels(
    request: DeepPartial<ListNotificationChannelsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNotificationChannelsResponse>;
  /**
   * Gets a single notification channel. The channel includes the relevant
   * configuration details with which the channel was created. However, the
   * response may truncate or omit passwords, API keys, or other private key
   * matter and thus the response may not be 100% identical to the information
   * that was supplied in the call to the create method.
   */
  getNotificationChannel(
    request: DeepPartial<GetNotificationChannelRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NotificationChannel>;
  /**
   * Creates a new notification channel, representing a single notification
   * endpoint such as an email address, SMS number, or PagerDuty service.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  createNotificationChannel(
    request: DeepPartial<CreateNotificationChannelRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NotificationChannel>;
  /**
   * Updates a notification channel. Fields not specified in the field mask
   * remain unchanged.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  updateNotificationChannel(
    request: DeepPartial<UpdateNotificationChannelRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NotificationChannel>;
  /**
   * Deletes a notification channel.
   *
   * Design your application to single-thread API calls that modify the state of
   * notification channels in a single project. This includes calls to
   * CreateNotificationChannel, DeleteNotificationChannel and
   * UpdateNotificationChannel.
   */
  deleteNotificationChannel(
    request: DeepPartial<DeleteNotificationChannelRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Causes a verification code to be delivered to the channel. The code
   * can then be supplied in `VerifyNotificationChannel` to verify the channel.
   */
  sendNotificationChannelVerificationCode(
    request: DeepPartial<SendNotificationChannelVerificationCodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Requests a verification code for an already verified channel that can then
   * be used in a call to VerifyNotificationChannel() on a different channel
   * with an equivalent identity in the same or in a different project. This
   * makes it possible to copy a channel between projects without requiring
   * manual reverification of the channel. If the channel is not in the
   * verified state, this method will fail (in other words, this may only be
   * used if the SendNotificationChannelVerificationCode and
   * VerifyNotificationChannel paths have already been used to put the given
   * channel into the verified state).
   *
   * There is no guarantee that the verification codes returned by this method
   * will be of a similar structure or form as the ones that are delivered
   * to the channel via SendNotificationChannelVerificationCode; while
   * VerifyNotificationChannel() will recognize both the codes delivered via
   * SendNotificationChannelVerificationCode() and returned from
   * GetNotificationChannelVerificationCode(), it is typically the case that
   * the verification codes delivered via
   * SendNotificationChannelVerificationCode() will be shorter and also
   * have a shorter expiration (e.g. codes such as "G-123456") whereas
   * GetVerificationCode() will typically return a much longer, websafe base
   * 64 encoded string that has a longer expiration time.
   */
  getNotificationChannelVerificationCode(
    request: DeepPartial<GetNotificationChannelVerificationCodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetNotificationChannelVerificationCodeResponse>;
  /**
   * Verifies a `NotificationChannel` by proving receipt of the code
   * delivered to the channel as a result of calling
   * `SendNotificationChannelVerificationCode`.
   */
  verifyNotificationChannel(
    request: DeepPartial<VerifyNotificationChannelRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NotificationChannel>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
