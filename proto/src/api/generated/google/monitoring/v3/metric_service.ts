// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/metric_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { MetricDescriptor } from "../../api/metric.js";
import { MonitoredResourceDescriptor } from "../../api/monitored_resource.js";
import { Empty } from "../../protobuf/empty.js";
import { Status } from "../../rpc/status.js";
import { Aggregation, TimeInterval } from "./common.js";
import { QueryError, TimeSeries, TimeSeriesData, TimeSeriesDescriptor } from "./metric.js";

export const protobufPackage = "google.monitoring.v3";

/** The `ListMonitoredResourceDescriptors` request. */
export interface ListMonitoredResourceDescriptorsRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * An optional [filter](https://cloud.google.com/monitoring/api/v3/filters)
   * describing the descriptors to be returned.  The filter can reference the
   * descriptor's type and labels. For example, the following filter returns
   * only Google Compute Engine descriptors that have an `id` label:
   *
   *     resource.type = starts_with("gce_") AND resource.label:id
   */
  filter: string;
  /** A positive number that is the maximum number of results to return. */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `nextPageToken` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
}

/** The `ListMonitoredResourceDescriptors` response. */
export interface ListMonitoredResourceDescriptorsResponse {
  /**
   * The monitored resource descriptors that are available to this project
   * and that match `filter`, if present.
   */
  resourceDescriptors: MonitoredResourceDescriptor[];
  /**
   * If there are more results than have been returned, then this field is set
   * to a non-empty value.  To see the additional results,
   * use that value as `page_token` in the next call to this method.
   */
  nextPageToken: string;
}

/** The `GetMonitoredResourceDescriptor` request. */
export interface GetMonitoredResourceDescriptorRequest {
  /**
   * Required. The monitored resource descriptor to get.  The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/monitoredResourceDescriptors/[RESOURCE_TYPE]
   *
   * The `[RESOURCE_TYPE]` is a predefined type, such as
   * `cloudsql_database`.
   */
  name: string;
}

/** The `ListMetricDescriptors` request. */
export interface ListMetricDescriptorsRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * If this field is empty, all custom and
   * system-defined metric descriptors are returned.
   * Otherwise, the [filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifies which metric descriptors are to be
   * returned. For example, the following filter matches all
   * [custom metrics](https://cloud.google.com/monitoring/custom-metrics):
   *
   *     metric.type = starts_with("custom.googleapis.com/")
   */
  filter: string;
  /**
   * A positive number that is the maximum number of results to return. The
   * default and maximum value is 10,000. If a page_size <= 0 or > 10,000 is
   * submitted, will instead return a maximum of 10,000 results.
   */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `nextPageToken` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
}

/** The `ListMetricDescriptors` response. */
export interface ListMetricDescriptorsResponse {
  /**
   * The metric descriptors that are available to the project
   * and that match the value of `filter`, if present.
   */
  metricDescriptors: MetricDescriptor[];
  /**
   * If there are more results than have been returned, then this field is set
   * to a non-empty value.  To see the additional results,
   * use that value as `page_token` in the next call to this method.
   */
  nextPageToken: string;
}

/** The `GetMetricDescriptor` request. */
export interface GetMetricDescriptorRequest {
  /**
   * Required. The metric descriptor on which to execute the request. The format
   * is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
   *
   * An example value of `[METRIC_ID]` is
   * `"compute.googleapis.com/instance/disk/read_bytes_count"`.
   */
  name: string;
}

/** The `CreateMetricDescriptor` request. */
export interface CreateMetricDescriptorRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   * 4
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * Required. The new [custom
   * metric](https://cloud.google.com/monitoring/custom-metrics) descriptor.
   */
  metricDescriptor: MetricDescriptor | undefined;
}

/** The `DeleteMetricDescriptor` request. */
export interface DeleteMetricDescriptorRequest {
  /**
   * Required. The metric descriptor on which to execute the request. The format
   * is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/metricDescriptors/[METRIC_ID]
   *
   * An example of `[METRIC_ID]` is:
   * `"custom.googleapis.com/my_test_metric"`.
   */
  name: string;
}

/** The `ListTimeSeries` request. */
export interface ListTimeSeriesRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name),
   * organization or folder on which to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   *     organizations/[ORGANIZATION_ID]
   *     folders/[FOLDER_ID]
   */
  name: string;
  /**
   * Required. A [monitoring
   * filter](https://cloud.google.com/monitoring/api/v3/filters) that specifies
   * which time series should be returned.  The filter must specify a single
   * metric type, and can additionally specify metric labels and other
   * information. For example:
   *
   *     metric.type = "compute.googleapis.com/instance/cpu/usage_time" AND
   *         metric.labels.instance_name = "my-instance-name"
   */
  filter: string;
  /**
   * Required. The time interval for which results should be returned. Only time
   * series that contain data points in the specified interval are included in
   * the response.
   */
  interval:
    | TimeInterval
    | undefined;
  /**
   * Specifies the alignment of data points in individual time series as
   * well as how to combine the retrieved time series across specified labels.
   *
   * By default (if no `aggregation` is explicitly specified), the raw time
   * series data is returned.
   */
  aggregation:
    | Aggregation
    | undefined;
  /**
   * Apply a second aggregation after `aggregation` is applied. May only be
   * specified if `aggregation` is specified.
   */
  secondaryAggregation:
    | Aggregation
    | undefined;
  /**
   * Unsupported: must be left blank. The points in each time series are
   * currently returned in reverse time order (most recent to oldest).
   */
  orderBy: string;
  /** Required. Specifies which information is returned about the time series. */
  view: ListTimeSeriesRequest_TimeSeriesView;
  /**
   * A positive number that is the maximum number of results to return. If
   * `page_size` is empty or more than 100,000 results, the effective
   * `page_size` is 100,000 results. If `view` is set to `FULL`, this is the
   * maximum number of `Points` returned. If `view` is set to `HEADERS`, this is
   * the maximum number of `TimeSeries` returned.
   */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `nextPageToken` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
}

/** Controls which fields are returned by `ListTimeSeries*`. */
export enum ListTimeSeriesRequest_TimeSeriesView {
  /**
   * FULL - Returns the identity of the metric(s), the time series,
   * and the time series data.
   */
  FULL = 0,
  /**
   * HEADERS - Returns the identity of the metric and the time series resource,
   * but not the time series data.
   */
  HEADERS = 1,
  UNRECOGNIZED = -1,
}

export function listTimeSeriesRequest_TimeSeriesViewFromJSON(object: any): ListTimeSeriesRequest_TimeSeriesView {
  switch (object) {
    case 0:
    case "FULL":
      return ListTimeSeriesRequest_TimeSeriesView.FULL;
    case 1:
    case "HEADERS":
      return ListTimeSeriesRequest_TimeSeriesView.HEADERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListTimeSeriesRequest_TimeSeriesView.UNRECOGNIZED;
  }
}

export function listTimeSeriesRequest_TimeSeriesViewToJSON(object: ListTimeSeriesRequest_TimeSeriesView): string {
  switch (object) {
    case ListTimeSeriesRequest_TimeSeriesView.FULL:
      return "FULL";
    case ListTimeSeriesRequest_TimeSeriesView.HEADERS:
      return "HEADERS";
    case ListTimeSeriesRequest_TimeSeriesView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The `ListTimeSeries` response. */
export interface ListTimeSeriesResponse {
  /** One or more time series that match the filter included in the request. */
  timeSeries: TimeSeries[];
  /**
   * If there are more results than have been returned, then this field is set
   * to a non-empty value.  To see the additional results,
   * use that value as `page_token` in the next call to this method.
   */
  nextPageToken: string;
  /**
   * Query execution errors that may have caused the time series data returned
   * to be incomplete.
   */
  executionErrors: Status[];
  /**
   * The unit in which all `time_series` point values are reported. `unit`
   * follows the UCUM format for units as seen in
   * https://unitsofmeasure.org/ucum.html.
   * If different `time_series` have different units (for example, because they
   * come from different metric types, or a unit is absent), then `unit` will be
   * "{not_a_unit}".
   */
  unit: string;
}

/** The `CreateTimeSeries` request. */
export interface CreateTimeSeriesRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * Required. The new data to be added to a list of time series.
   * Adds at most one data point to each of several time series.  The new data
   * point must be more recent than any other point in its time series.  Each
   * `TimeSeries` value must fully specify a unique time series by supplying
   * all label values for the metric and the monitored resource.
   *
   * The maximum number of `TimeSeries` objects per `Create` request is 200.
   */
  timeSeries: TimeSeries[];
}

/** DEPRECATED. Used to hold per-time-series error status. */
export interface CreateTimeSeriesError {
  /**
   * DEPRECATED. Time series ID that resulted in the `status` error.
   *
   * @deprecated
   */
  timeSeries:
    | TimeSeries
    | undefined;
  /**
   * DEPRECATED. The status of the requested write operation for `time_series`.
   *
   * @deprecated
   */
  status: Status | undefined;
}

/** Summary of the result of a failed request to write data to a time series. */
export interface CreateTimeSeriesSummary {
  /** The number of points in the request. */
  totalPointCount: number;
  /** The number of points that were successfully written. */
  successPointCount: number;
  /** The number of points that failed to be written. Order is not guaranteed. */
  errors: CreateTimeSeriesSummary_Error[];
}

/** Detailed information about an error category. */
export interface CreateTimeSeriesSummary_Error {
  /** The status of the requested write operation. */
  status:
    | Status
    | undefined;
  /** The number of points that couldn't be written because of `status`. */
  pointCount: number;
}

/** The `QueryTimeSeries` request. */
export interface QueryTimeSeriesRequest {
  /**
   * Required. The
   * [project](https://cloud.google.com/monitoring/api/v3#project_name) on which
   * to execute the request. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]
   */
  name: string;
  /**
   * Required. The query in the [Monitoring Query
   * Language](https://cloud.google.com/monitoring/mql/reference) format.
   * The default time zone is in UTC.
   */
  query: string;
  /** A positive number that is the maximum number of time_series_data to return. */
  pageSize: number;
  /**
   * If this field is not empty then it must contain the `nextPageToken` value
   * returned by a previous call to this method.  Using this field causes the
   * method to return additional results from the previous method call.
   */
  pageToken: string;
}

/** The `QueryTimeSeries` response. */
export interface QueryTimeSeriesResponse {
  /** The descriptor for the time series data. */
  timeSeriesDescriptor:
    | TimeSeriesDescriptor
    | undefined;
  /** The time series data. */
  timeSeriesData: TimeSeriesData[];
  /**
   * If there are more results than have been returned, then this field is set
   * to a non-empty value.  To see the additional results, use that value as
   * `page_token` in the next call to this method.
   */
  nextPageToken: string;
  /**
   * Query execution errors that may have caused the time series data returned
   * to be incomplete. The available data will be available in the
   * response.
   */
  partialErrors: Status[];
}

/** This is an error detail intended to be used with INVALID_ARGUMENT errors. */
export interface QueryErrorList {
  /**
   * Errors in parsing the time series query language text. The number of errors
   * in the response may be limited.
   */
  errors: QueryError[];
  /** A summary of all the errors. */
  errorSummary: string;
}

function createBaseListMonitoredResourceDescriptorsRequest(): ListMonitoredResourceDescriptorsRequest {
  return { name: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListMonitoredResourceDescriptorsRequest: MessageFns<ListMonitoredResourceDescriptorsRequest> = {
  encode(message: ListMonitoredResourceDescriptorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMonitoredResourceDescriptorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMonitoredResourceDescriptorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMonitoredResourceDescriptorsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListMonitoredResourceDescriptorsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMonitoredResourceDescriptorsRequest>): ListMonitoredResourceDescriptorsRequest {
    return ListMonitoredResourceDescriptorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMonitoredResourceDescriptorsRequest>): ListMonitoredResourceDescriptorsRequest {
    const message = createBaseListMonitoredResourceDescriptorsRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListMonitoredResourceDescriptorsResponse(): ListMonitoredResourceDescriptorsResponse {
  return { resourceDescriptors: [], nextPageToken: "" };
}

export const ListMonitoredResourceDescriptorsResponse: MessageFns<ListMonitoredResourceDescriptorsResponse> = {
  encode(message: ListMonitoredResourceDescriptorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resourceDescriptors) {
      MonitoredResourceDescriptor.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMonitoredResourceDescriptorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMonitoredResourceDescriptorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceDescriptors.push(MonitoredResourceDescriptor.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMonitoredResourceDescriptorsResponse {
    return {
      resourceDescriptors: globalThis.Array.isArray(object?.resourceDescriptors)
        ? object.resourceDescriptors.map((e: any) => MonitoredResourceDescriptor.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMonitoredResourceDescriptorsResponse): unknown {
    const obj: any = {};
    if (message.resourceDescriptors?.length) {
      obj.resourceDescriptors = message.resourceDescriptors.map((e) => MonitoredResourceDescriptor.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMonitoredResourceDescriptorsResponse>): ListMonitoredResourceDescriptorsResponse {
    return ListMonitoredResourceDescriptorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMonitoredResourceDescriptorsResponse>): ListMonitoredResourceDescriptorsResponse {
    const message = createBaseListMonitoredResourceDescriptorsResponse();
    message.resourceDescriptors = object.resourceDescriptors?.map((e) => MonitoredResourceDescriptor.fromPartial(e)) ||
      [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetMonitoredResourceDescriptorRequest(): GetMonitoredResourceDescriptorRequest {
  return { name: "" };
}

export const GetMonitoredResourceDescriptorRequest: MessageFns<GetMonitoredResourceDescriptorRequest> = {
  encode(message: GetMonitoredResourceDescriptorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMonitoredResourceDescriptorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMonitoredResourceDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMonitoredResourceDescriptorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMonitoredResourceDescriptorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMonitoredResourceDescriptorRequest>): GetMonitoredResourceDescriptorRequest {
    return GetMonitoredResourceDescriptorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMonitoredResourceDescriptorRequest>): GetMonitoredResourceDescriptorRequest {
    const message = createBaseGetMonitoredResourceDescriptorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListMetricDescriptorsRequest(): ListMetricDescriptorsRequest {
  return { name: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListMetricDescriptorsRequest: MessageFns<ListMetricDescriptorsRequest> = {
  encode(message: ListMetricDescriptorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMetricDescriptorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricDescriptorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricDescriptorsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListMetricDescriptorsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricDescriptorsRequest>): ListMetricDescriptorsRequest {
    return ListMetricDescriptorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricDescriptorsRequest>): ListMetricDescriptorsRequest {
    const message = createBaseListMetricDescriptorsRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListMetricDescriptorsResponse(): ListMetricDescriptorsResponse {
  return { metricDescriptors: [], nextPageToken: "" };
}

export const ListMetricDescriptorsResponse: MessageFns<ListMetricDescriptorsResponse> = {
  encode(message: ListMetricDescriptorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.metricDescriptors) {
      MetricDescriptor.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMetricDescriptorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMetricDescriptorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricDescriptors.push(MetricDescriptor.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMetricDescriptorsResponse {
    return {
      metricDescriptors: globalThis.Array.isArray(object?.metricDescriptors)
        ? object.metricDescriptors.map((e: any) => MetricDescriptor.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMetricDescriptorsResponse): unknown {
    const obj: any = {};
    if (message.metricDescriptors?.length) {
      obj.metricDescriptors = message.metricDescriptors.map((e) => MetricDescriptor.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMetricDescriptorsResponse>): ListMetricDescriptorsResponse {
    return ListMetricDescriptorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMetricDescriptorsResponse>): ListMetricDescriptorsResponse {
    const message = createBaseListMetricDescriptorsResponse();
    message.metricDescriptors = object.metricDescriptors?.map((e) => MetricDescriptor.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetMetricDescriptorRequest(): GetMetricDescriptorRequest {
  return { name: "" };
}

export const GetMetricDescriptorRequest: MessageFns<GetMetricDescriptorRequest> = {
  encode(message: GetMetricDescriptorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMetricDescriptorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetricDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetricDescriptorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMetricDescriptorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetricDescriptorRequest>): GetMetricDescriptorRequest {
    return GetMetricDescriptorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetricDescriptorRequest>): GetMetricDescriptorRequest {
    const message = createBaseGetMetricDescriptorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateMetricDescriptorRequest(): CreateMetricDescriptorRequest {
  return { name: "", metricDescriptor: undefined };
}

export const CreateMetricDescriptorRequest: MessageFns<CreateMetricDescriptorRequest> = {
  encode(message: CreateMetricDescriptorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metricDescriptor !== undefined) {
      MetricDescriptor.encode(message.metricDescriptor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMetricDescriptorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMetricDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricDescriptor = MetricDescriptor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMetricDescriptorRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metricDescriptor: isSet(object.metricDescriptor) ? MetricDescriptor.fromJSON(object.metricDescriptor) : undefined,
    };
  },

  toJSON(message: CreateMetricDescriptorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metricDescriptor !== undefined) {
      obj.metricDescriptor = MetricDescriptor.toJSON(message.metricDescriptor);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateMetricDescriptorRequest>): CreateMetricDescriptorRequest {
    return CreateMetricDescriptorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateMetricDescriptorRequest>): CreateMetricDescriptorRequest {
    const message = createBaseCreateMetricDescriptorRequest();
    message.name = object.name ?? "";
    message.metricDescriptor = (object.metricDescriptor !== undefined && object.metricDescriptor !== null)
      ? MetricDescriptor.fromPartial(object.metricDescriptor)
      : undefined;
    return message;
  },
};

function createBaseDeleteMetricDescriptorRequest(): DeleteMetricDescriptorRequest {
  return { name: "" };
}

export const DeleteMetricDescriptorRequest: MessageFns<DeleteMetricDescriptorRequest> = {
  encode(message: DeleteMetricDescriptorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMetricDescriptorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMetricDescriptorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMetricDescriptorRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteMetricDescriptorRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMetricDescriptorRequest>): DeleteMetricDescriptorRequest {
    return DeleteMetricDescriptorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMetricDescriptorRequest>): DeleteMetricDescriptorRequest {
    const message = createBaseDeleteMetricDescriptorRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListTimeSeriesRequest(): ListTimeSeriesRequest {
  return {
    name: "",
    filter: "",
    interval: undefined,
    aggregation: undefined,
    secondaryAggregation: undefined,
    orderBy: "",
    view: 0,
    pageSize: 0,
    pageToken: "",
  };
}

export const ListTimeSeriesRequest: MessageFns<ListTimeSeriesRequest> = {
  encode(message: ListTimeSeriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.interval !== undefined) {
      TimeInterval.encode(message.interval, writer.uint32(34).fork()).join();
    }
    if (message.aggregation !== undefined) {
      Aggregation.encode(message.aggregation, writer.uint32(42).fork()).join();
    }
    if (message.secondaryAggregation !== undefined) {
      Aggregation.encode(message.secondaryAggregation, writer.uint32(90).fork()).join();
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(56).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(64).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(74).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTimeSeriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTimeSeriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.interval = TimeInterval.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aggregation = Aggregation.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.secondaryAggregation = Aggregation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTimeSeriesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      interval: isSet(object.interval) ? TimeInterval.fromJSON(object.interval) : undefined,
      aggregation: isSet(object.aggregation) ? Aggregation.fromJSON(object.aggregation) : undefined,
      secondaryAggregation: isSet(object.secondaryAggregation)
        ? Aggregation.fromJSON(object.secondaryAggregation)
        : undefined,
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? listTimeSeriesRequest_TimeSeriesViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTimeSeriesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.interval !== undefined) {
      obj.interval = TimeInterval.toJSON(message.interval);
    }
    if (message.aggregation !== undefined) {
      obj.aggregation = Aggregation.toJSON(message.aggregation);
    }
    if (message.secondaryAggregation !== undefined) {
      obj.secondaryAggregation = Aggregation.toJSON(message.secondaryAggregation);
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = listTimeSeriesRequest_TimeSeriesViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTimeSeriesRequest>): ListTimeSeriesRequest {
    return ListTimeSeriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTimeSeriesRequest>): ListTimeSeriesRequest {
    const message = createBaseListTimeSeriesRequest();
    message.name = object.name ?? "";
    message.filter = object.filter ?? "";
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? TimeInterval.fromPartial(object.interval)
      : undefined;
    message.aggregation = (object.aggregation !== undefined && object.aggregation !== null)
      ? Aggregation.fromPartial(object.aggregation)
      : undefined;
    message.secondaryAggregation = (object.secondaryAggregation !== undefined && object.secondaryAggregation !== null)
      ? Aggregation.fromPartial(object.secondaryAggregation)
      : undefined;
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTimeSeriesResponse(): ListTimeSeriesResponse {
  return { timeSeries: [], nextPageToken: "", executionErrors: [], unit: "" };
}

export const ListTimeSeriesResponse: MessageFns<ListTimeSeriesResponse> = {
  encode(message: ListTimeSeriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.timeSeries) {
      TimeSeries.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.executionErrors) {
      Status.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.unit !== "") {
      writer.uint32(42).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTimeSeriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTimeSeriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSeries.push(TimeSeries.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionErrors.push(Status.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTimeSeriesResponse {
    return {
      timeSeries: globalThis.Array.isArray(object?.timeSeries)
        ? object.timeSeries.map((e: any) => TimeSeries.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      executionErrors: globalThis.Array.isArray(object?.executionErrors)
        ? object.executionErrors.map((e: any) => Status.fromJSON(e))
        : [],
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: ListTimeSeriesResponse): unknown {
    const obj: any = {};
    if (message.timeSeries?.length) {
      obj.timeSeries = message.timeSeries.map((e) => TimeSeries.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.executionErrors?.length) {
      obj.executionErrors = message.executionErrors.map((e) => Status.toJSON(e));
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTimeSeriesResponse>): ListTimeSeriesResponse {
    return ListTimeSeriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTimeSeriesResponse>): ListTimeSeriesResponse {
    const message = createBaseListTimeSeriesResponse();
    message.timeSeries = object.timeSeries?.map((e) => TimeSeries.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.executionErrors = object.executionErrors?.map((e) => Status.fromPartial(e)) || [];
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseCreateTimeSeriesRequest(): CreateTimeSeriesRequest {
  return { name: "", timeSeries: [] };
}

export const CreateTimeSeriesRequest: MessageFns<CreateTimeSeriesRequest> = {
  encode(message: CreateTimeSeriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.timeSeries) {
      TimeSeries.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTimeSeriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTimeSeriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeSeries.push(TimeSeries.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTimeSeriesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      timeSeries: globalThis.Array.isArray(object?.timeSeries)
        ? object.timeSeries.map((e: any) => TimeSeries.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateTimeSeriesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.timeSeries?.length) {
      obj.timeSeries = message.timeSeries.map((e) => TimeSeries.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTimeSeriesRequest>): CreateTimeSeriesRequest {
    return CreateTimeSeriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTimeSeriesRequest>): CreateTimeSeriesRequest {
    const message = createBaseCreateTimeSeriesRequest();
    message.name = object.name ?? "";
    message.timeSeries = object.timeSeries?.map((e) => TimeSeries.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTimeSeriesError(): CreateTimeSeriesError {
  return { timeSeries: undefined, status: undefined };
}

export const CreateTimeSeriesError: MessageFns<CreateTimeSeriesError> = {
  encode(message: CreateTimeSeriesError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSeries !== undefined) {
      TimeSeries.encode(message.timeSeries, writer.uint32(10).fork()).join();
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTimeSeriesError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTimeSeriesError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSeries = TimeSeries.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTimeSeriesError {
    return {
      timeSeries: isSet(object.timeSeries) ? TimeSeries.fromJSON(object.timeSeries) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: CreateTimeSeriesError): unknown {
    const obj: any = {};
    if (message.timeSeries !== undefined) {
      obj.timeSeries = TimeSeries.toJSON(message.timeSeries);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTimeSeriesError>): CreateTimeSeriesError {
    return CreateTimeSeriesError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTimeSeriesError>): CreateTimeSeriesError {
    const message = createBaseCreateTimeSeriesError();
    message.timeSeries = (object.timeSeries !== undefined && object.timeSeries !== null)
      ? TimeSeries.fromPartial(object.timeSeries)
      : undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseCreateTimeSeriesSummary(): CreateTimeSeriesSummary {
  return { totalPointCount: 0, successPointCount: 0, errors: [] };
}

export const CreateTimeSeriesSummary: MessageFns<CreateTimeSeriesSummary> = {
  encode(message: CreateTimeSeriesSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalPointCount !== 0) {
      writer.uint32(8).int32(message.totalPointCount);
    }
    if (message.successPointCount !== 0) {
      writer.uint32(16).int32(message.successPointCount);
    }
    for (const v of message.errors) {
      CreateTimeSeriesSummary_Error.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTimeSeriesSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTimeSeriesSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalPointCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.successPointCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errors.push(CreateTimeSeriesSummary_Error.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTimeSeriesSummary {
    return {
      totalPointCount: isSet(object.totalPointCount) ? globalThis.Number(object.totalPointCount) : 0,
      successPointCount: isSet(object.successPointCount) ? globalThis.Number(object.successPointCount) : 0,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => CreateTimeSeriesSummary_Error.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateTimeSeriesSummary): unknown {
    const obj: any = {};
    if (message.totalPointCount !== 0) {
      obj.totalPointCount = Math.round(message.totalPointCount);
    }
    if (message.successPointCount !== 0) {
      obj.successPointCount = Math.round(message.successPointCount);
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => CreateTimeSeriesSummary_Error.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTimeSeriesSummary>): CreateTimeSeriesSummary {
    return CreateTimeSeriesSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTimeSeriesSummary>): CreateTimeSeriesSummary {
    const message = createBaseCreateTimeSeriesSummary();
    message.totalPointCount = object.totalPointCount ?? 0;
    message.successPointCount = object.successPointCount ?? 0;
    message.errors = object.errors?.map((e) => CreateTimeSeriesSummary_Error.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateTimeSeriesSummary_Error(): CreateTimeSeriesSummary_Error {
  return { status: undefined, pointCount: 0 };
}

export const CreateTimeSeriesSummary_Error: MessageFns<CreateTimeSeriesSummary_Error> = {
  encode(message: CreateTimeSeriesSummary_Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.pointCount !== 0) {
      writer.uint32(16).int32(message.pointCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTimeSeriesSummary_Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTimeSeriesSummary_Error();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pointCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTimeSeriesSummary_Error {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      pointCount: isSet(object.pointCount) ? globalThis.Number(object.pointCount) : 0,
    };
  },

  toJSON(message: CreateTimeSeriesSummary_Error): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.pointCount !== 0) {
      obj.pointCount = Math.round(message.pointCount);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTimeSeriesSummary_Error>): CreateTimeSeriesSummary_Error {
    return CreateTimeSeriesSummary_Error.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTimeSeriesSummary_Error>): CreateTimeSeriesSummary_Error {
    const message = createBaseCreateTimeSeriesSummary_Error();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.pointCount = object.pointCount ?? 0;
    return message;
  },
};

function createBaseQueryTimeSeriesRequest(): QueryTimeSeriesRequest {
  return { name: "", query: "", pageSize: 0, pageToken: "" };
}

export const QueryTimeSeriesRequest: MessageFns<QueryTimeSeriesRequest> = {
  encode(message: QueryTimeSeriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.query !== "") {
      writer.uint32(58).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(72).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(82).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTimeSeriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTimeSeriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.query = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTimeSeriesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: QueryTimeSeriesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTimeSeriesRequest>): QueryTimeSeriesRequest {
    return QueryTimeSeriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTimeSeriesRequest>): QueryTimeSeriesRequest {
    const message = createBaseQueryTimeSeriesRequest();
    message.name = object.name ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseQueryTimeSeriesResponse(): QueryTimeSeriesResponse {
  return { timeSeriesDescriptor: undefined, timeSeriesData: [], nextPageToken: "", partialErrors: [] };
}

export const QueryTimeSeriesResponse: MessageFns<QueryTimeSeriesResponse> = {
  encode(message: QueryTimeSeriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSeriesDescriptor !== undefined) {
      TimeSeriesDescriptor.encode(message.timeSeriesDescriptor, writer.uint32(66).fork()).join();
    }
    for (const v of message.timeSeriesData) {
      TimeSeriesData.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(82).string(message.nextPageToken);
    }
    for (const v of message.partialErrors) {
      Status.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTimeSeriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTimeSeriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeSeriesDescriptor = TimeSeriesDescriptor.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.timeSeriesData.push(TimeSeriesData.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.partialErrors.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTimeSeriesResponse {
    return {
      timeSeriesDescriptor: isSet(object.timeSeriesDescriptor)
        ? TimeSeriesDescriptor.fromJSON(object.timeSeriesDescriptor)
        : undefined,
      timeSeriesData: globalThis.Array.isArray(object?.timeSeriesData)
        ? object.timeSeriesData.map((e: any) => TimeSeriesData.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      partialErrors: globalThis.Array.isArray(object?.partialErrors)
        ? object.partialErrors.map((e: any) => Status.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryTimeSeriesResponse): unknown {
    const obj: any = {};
    if (message.timeSeriesDescriptor !== undefined) {
      obj.timeSeriesDescriptor = TimeSeriesDescriptor.toJSON(message.timeSeriesDescriptor);
    }
    if (message.timeSeriesData?.length) {
      obj.timeSeriesData = message.timeSeriesData.map((e) => TimeSeriesData.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.partialErrors?.length) {
      obj.partialErrors = message.partialErrors.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryTimeSeriesResponse>): QueryTimeSeriesResponse {
    return QueryTimeSeriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryTimeSeriesResponse>): QueryTimeSeriesResponse {
    const message = createBaseQueryTimeSeriesResponse();
    message.timeSeriesDescriptor = (object.timeSeriesDescriptor !== undefined && object.timeSeriesDescriptor !== null)
      ? TimeSeriesDescriptor.fromPartial(object.timeSeriesDescriptor)
      : undefined;
    message.timeSeriesData = object.timeSeriesData?.map((e) => TimeSeriesData.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.partialErrors = object.partialErrors?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryErrorList(): QueryErrorList {
  return { errors: [], errorSummary: "" };
}

export const QueryErrorList: MessageFns<QueryErrorList> = {
  encode(message: QueryErrorList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      QueryError.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.errorSummary !== "") {
      writer.uint32(18).string(message.errorSummary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryErrorList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryErrorList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errors.push(QueryError.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorSummary = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryErrorList {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => QueryError.fromJSON(e)) : [],
      errorSummary: isSet(object.errorSummary) ? globalThis.String(object.errorSummary) : "",
    };
  },

  toJSON(message: QueryErrorList): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => QueryError.toJSON(e));
    }
    if (message.errorSummary !== "") {
      obj.errorSummary = message.errorSummary;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryErrorList>): QueryErrorList {
    return QueryErrorList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryErrorList>): QueryErrorList {
    const message = createBaseQueryErrorList();
    message.errors = object.errors?.map((e) => QueryError.fromPartial(e)) || [];
    message.errorSummary = object.errorSummary ?? "";
    return message;
  },
};

/**
 * Manages metric descriptors, monitored resource descriptors, and
 * time series data.
 */
export type MetricServiceDefinition = typeof MetricServiceDefinition;
export const MetricServiceDefinition = {
  name: "MetricService",
  fullName: "google.monitoring.v3.MetricService",
  methods: {
    /** Lists monitored resource descriptors that match a filter. */
    listMonitoredResourceDescriptors: {
      name: "ListMonitoredResourceDescriptors",
      requestType: ListMonitoredResourceDescriptorsRequest,
      requestStream: false,
      responseType: ListMonitoredResourceDescriptorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              111,
              110,
              105,
              116,
              111,
              114,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a single monitored resource descriptor. */
    getMonitoredResourceDescriptor: {
      name: "GetMonitoredResourceDescriptor",
      requestType: GetMonitoredResourceDescriptorRequest,
      requestStream: false,
      responseType: MonitoredResourceDescriptor,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              111,
              110,
              105,
              116,
              111,
              114,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists metric descriptors that match a filter. */
    listMetricDescriptors: {
      name: "ListMetricDescriptors",
      requestType: ListMetricDescriptorsRequest,
      requestStream: false,
      responseType: ListMetricDescriptorsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              41,
              18,
              39,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a single metric descriptor. */
    getMetricDescriptor: {
      name: "GetMetricDescriptor",
      requestType: GetMetricDescriptorRequest,
      requestStream: false,
      responseType: MetricDescriptor,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new metric descriptor.
     * The creation is executed asynchronously.
     * User-created metric descriptors define
     * [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
     * The metric descriptor is updated if it already exists,
     * except that metric labels are never removed.
     */
    createMetricDescriptor: {
      name: "CreateMetricDescriptor",
      requestType: CreateMetricDescriptorRequest,
      requestStream: false,
      responseType: MetricDescriptor,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              110,
              97,
              109,
              101,
              44,
              109,
              101,
              116,
              114,
              105,
              99,
              95,
              100,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
            ]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              17,
              109,
              101,
              116,
              114,
              105,
              99,
              95,
              100,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              34,
              39,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a metric descriptor. Only user-created
     * [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
     * deleted.
     */
    deleteMetricDescriptor: {
      name: "DeleteMetricDescriptor",
      requestType: DeleteMetricDescriptorRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              42,
              42,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              68,
              101,
              115,
              99,
              114,
              105,
              112,
              116,
              111,
              114,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists time series that match a filter. */
    listTimeSeries: {
      name: "ListTimeSeries",
      requestType: ListTimeSeriesRequest,
      requestStream: false,
      responseType: ListTimeSeriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              25,
              110,
              97,
              109,
              101,
              44,
              102,
              105,
              108,
              116,
              101,
              114,
              44,
              105,
              110,
              116,
              101,
              114,
              118,
              97,
              108,
              44,
              118,
              105,
              101,
              119,
            ]),
          ],
          578365826: [
            Buffer.from([
              110,
              90,
              39,
              18,
              37,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              116,
              105,
              109,
              101,
              83,
              101,
              114,
              105,
              101,
              115,
              90,
              33,
              18,
              31,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              105,
              109,
              101,
              83,
              101,
              114,
              105,
              101,
              115,
              18,
              32,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              105,
              109,
              101,
              83,
              101,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates or adds data to one or more time series.
     * The response is empty if all time series in the request were written.
     * If any time series could not be written, a corresponding failure message is
     * included in the error response.
     * This method does not support
     * [resource locations constraint of an organization
     * policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
     */
    createTimeSeries: {
      name: "CreateTimeSeries",
      requestType: CreateTimeSeriesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 116, 105, 109, 101, 95, 115, 101, 114, 105, 101, 115])],
          578365826: [
            Buffer.from([
              37,
              58,
              1,
              42,
              34,
              32,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              105,
              109,
              101,
              83,
              101,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates or adds data to one or more service time series. A service time
     * series is a time series for a metric from a Google Cloud service. The
     * response is empty if all time series in the request were written. If any
     * time series could not be written, a corresponding failure message is
     * included in the error response. This endpoint rejects writes to
     * user-defined metrics.
     * This method is only for use by Google Cloud services. Use
     * [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
     * instead.
     */
    createServiceTimeSeries: {
      name: "CreateServiceTimeSeries",
      requestType: CreateTimeSeriesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 116, 105, 109, 101, 95, 115, 101, 114, 105, 101, 115])],
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              51,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              116,
              105,
              109,
              101,
              83,
              101,
              114,
              105,
              101,
              115,
              58,
              99,
              114,
              101,
              97,
              116,
              101,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface MetricServiceImplementation<CallContextExt = {}> {
  /** Lists monitored resource descriptors that match a filter. */
  listMonitoredResourceDescriptors(
    request: ListMonitoredResourceDescriptorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMonitoredResourceDescriptorsResponse>>;
  /** Gets a single monitored resource descriptor. */
  getMonitoredResourceDescriptor(
    request: GetMonitoredResourceDescriptorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MonitoredResourceDescriptor>>;
  /** Lists metric descriptors that match a filter. */
  listMetricDescriptors(
    request: ListMetricDescriptorsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListMetricDescriptorsResponse>>;
  /** Gets a single metric descriptor. */
  getMetricDescriptor(
    request: GetMetricDescriptorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MetricDescriptor>>;
  /**
   * Creates a new metric descriptor.
   * The creation is executed asynchronously.
   * User-created metric descriptors define
   * [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
   * The metric descriptor is updated if it already exists,
   * except that metric labels are never removed.
   */
  createMetricDescriptor(
    request: CreateMetricDescriptorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<MetricDescriptor>>;
  /**
   * Deletes a metric descriptor. Only user-created
   * [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
   * deleted.
   */
  deleteMetricDescriptor(
    request: DeleteMetricDescriptorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists time series that match a filter. */
  listTimeSeries(
    request: ListTimeSeriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTimeSeriesResponse>>;
  /**
   * Creates or adds data to one or more time series.
   * The response is empty if all time series in the request were written.
   * If any time series could not be written, a corresponding failure message is
   * included in the error response.
   * This method does not support
   * [resource locations constraint of an organization
   * policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
   */
  createTimeSeries(
    request: CreateTimeSeriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Creates or adds data to one or more service time series. A service time
   * series is a time series for a metric from a Google Cloud service. The
   * response is empty if all time series in the request were written. If any
   * time series could not be written, a corresponding failure message is
   * included in the error response. This endpoint rejects writes to
   * user-defined metrics.
   * This method is only for use by Google Cloud services. Use
   * [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
   * instead.
   */
  createServiceTimeSeries(
    request: CreateTimeSeriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface MetricServiceClient<CallOptionsExt = {}> {
  /** Lists monitored resource descriptors that match a filter. */
  listMonitoredResourceDescriptors(
    request: DeepPartial<ListMonitoredResourceDescriptorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMonitoredResourceDescriptorsResponse>;
  /** Gets a single monitored resource descriptor. */
  getMonitoredResourceDescriptor(
    request: DeepPartial<GetMonitoredResourceDescriptorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MonitoredResourceDescriptor>;
  /** Lists metric descriptors that match a filter. */
  listMetricDescriptors(
    request: DeepPartial<ListMetricDescriptorsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListMetricDescriptorsResponse>;
  /** Gets a single metric descriptor. */
  getMetricDescriptor(
    request: DeepPartial<GetMetricDescriptorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MetricDescriptor>;
  /**
   * Creates a new metric descriptor.
   * The creation is executed asynchronously.
   * User-created metric descriptors define
   * [custom metrics](https://cloud.google.com/monitoring/custom-metrics).
   * The metric descriptor is updated if it already exists,
   * except that metric labels are never removed.
   */
  createMetricDescriptor(
    request: DeepPartial<CreateMetricDescriptorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<MetricDescriptor>;
  /**
   * Deletes a metric descriptor. Only user-created
   * [custom metrics](https://cloud.google.com/monitoring/custom-metrics) can be
   * deleted.
   */
  deleteMetricDescriptor(
    request: DeepPartial<DeleteMetricDescriptorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists time series that match a filter. */
  listTimeSeries(
    request: DeepPartial<ListTimeSeriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTimeSeriesResponse>;
  /**
   * Creates or adds data to one or more time series.
   * The response is empty if all time series in the request were written.
   * If any time series could not be written, a corresponding failure message is
   * included in the error response.
   * This method does not support
   * [resource locations constraint of an organization
   * policy](https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy).
   */
  createTimeSeries(
    request: DeepPartial<CreateTimeSeriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Creates or adds data to one or more service time series. A service time
   * series is a time series for a metric from a Google Cloud service. The
   * response is empty if all time series in the request were written. If any
   * time series could not be written, a corresponding failure message is
   * included in the error response. This endpoint rejects writes to
   * user-defined metrics.
   * This method is only for use by Google Cloud services. Use
   * [projects.timeSeries.create][google.monitoring.v3.MetricService.CreateTimeSeries]
   * instead.
   */
  createServiceTimeSeries(
    request: DeepPartial<CreateTimeSeriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
