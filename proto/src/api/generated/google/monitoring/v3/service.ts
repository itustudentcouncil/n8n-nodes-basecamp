// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../protobuf/duration.js";
import { CalendarPeriod, calendarPeriodFromJSON, calendarPeriodToJSON } from "../../type/calendar_period.js";

export const protobufPackage = "google.monitoring.v3";

/**
 * A `Service` is a discrete, autonomous, and network-accessible unit, designed
 * to solve an individual concern
 * ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
 * Cloud Monitoring, a `Service` acts as the root resource under which
 * operational aspects of the service are accessible.
 */
export interface Service {
  /**
   * Identifier. Resource name for this Service. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
   */
  name: string;
  /** Name used for UI elements listing this Service. */
  displayName: string;
  /** Custom service type. */
  custom?:
    | Service_Custom
    | undefined;
  /** Type used for App Engine services. */
  appEngine?:
    | Service_AppEngine
    | undefined;
  /** Type used for Cloud Endpoints services. */
  cloudEndpoints?:
    | Service_CloudEndpoints
    | undefined;
  /** Type used for Istio services that live in a Kubernetes cluster. */
  clusterIstio?:
    | Service_ClusterIstio
    | undefined;
  /** Type used for Istio services scoped to an Istio mesh. */
  meshIstio?:
    | Service_MeshIstio
    | undefined;
  /**
   * Type used for canonical services scoped to an Istio mesh.
   * Metrics for Istio are
   * [documented here](https://istio.io/latest/docs/reference/config/metrics/)
   */
  istioCanonicalService?:
    | Service_IstioCanonicalService
    | undefined;
  /** Type used for Cloud Run services. */
  cloudRun?:
    | Service_CloudRun
    | undefined;
  /** Type used for GKE Namespaces. */
  gkeNamespace?:
    | Service_GkeNamespace
    | undefined;
  /** Type used for GKE Workloads. */
  gkeWorkload?:
    | Service_GkeWorkload
    | undefined;
  /** Type used for GKE Services (the Kubernetes concept of a service). */
  gkeService?:
    | Service_GkeService
    | undefined;
  /**
   * Message that contains the service type and service labels of this service
   * if it is a basic service.
   * Documentation and examples
   * [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
   */
  basicService:
    | Service_BasicService
    | undefined;
  /** Configuration for how to query telemetry on a Service. */
  telemetry:
    | Service_Telemetry
    | undefined;
  /**
   * Labels which have been used to annotate the service. Label keys must start
   * with a letter. Label keys and values may contain lowercase letters,
   * numbers, underscores, and dashes. Label keys and values have a maximum
   * length of 63 characters, and must be less than 128 bytes in size. Up to 64
   * label entries may be stored. For labels which do not have a semantic value,
   * the empty string may be supplied for the label value.
   */
  userLabels: { [key: string]: string };
}

/**
 * Use a custom service to designate a service that you want to monitor
 * when none of the other service types (like App Engine, Cloud Run, or
 * a GKE type) matches your intended service.
 */
export interface Service_Custom {
}

/** App Engine service. Learn more at https://cloud.google.com/appengine. */
export interface Service_AppEngine {
  /**
   * The ID of the App Engine module underlying this service. Corresponds to
   * the `module_id` resource label in the [`gae_app` monitored
   * resource](https://cloud.google.com/monitoring/api/resources#tag_gae_app).
   */
  moduleId: string;
}

/** Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints. */
export interface Service_CloudEndpoints {
  /**
   * The name of the Cloud Endpoints service underlying this service.
   * Corresponds to the `service` resource label in the [`api` monitored
   * resource](https://cloud.google.com/monitoring/api/resources#tag_api).
   */
  service: string;
}

/**
 * Istio service scoped to a single Kubernetes cluster. Learn more at
 * https://istio.io. Clusters running OSS Istio will have their services
 * ingested as this type.
 */
export interface Service_ClusterIstio {
  /**
   * The location of the Kubernetes cluster in which this Istio service is
   * defined. Corresponds to the `location` resource label in `k8s_cluster`
   * resources.
   */
  location: string;
  /**
   * The name of the Kubernetes cluster in which this Istio service is
   * defined. Corresponds to the `cluster_name` resource label in
   * `k8s_cluster` resources.
   */
  clusterName: string;
  /**
   * The namespace of the Istio service underlying this service. Corresponds
   * to the `destination_service_namespace` metric label in Istio metrics.
   */
  serviceNamespace: string;
  /**
   * The name of the Istio service underlying this service. Corresponds to the
   * `destination_service_name` metric label in Istio metrics.
   */
  serviceName: string;
}

/**
 * Istio service scoped to an Istio mesh. Anthos clusters running ASM < 1.6.8
 * will have their services ingested as this type.
 */
export interface Service_MeshIstio {
  /**
   * Identifier for the mesh in which this Istio service is defined.
   * Corresponds to the `mesh_uid` metric label in Istio metrics.
   */
  meshUid: string;
  /**
   * The namespace of the Istio service underlying this service. Corresponds
   * to the `destination_service_namespace` metric label in Istio metrics.
   */
  serviceNamespace: string;
  /**
   * The name of the Istio service underlying this service. Corresponds to the
   * `destination_service_name` metric label in Istio metrics.
   */
  serviceName: string;
}

/**
 * Canonical service scoped to an Istio mesh. Anthos clusters running ASM >=
 * 1.6.8 will have their services ingested as this type.
 */
export interface Service_IstioCanonicalService {
  /**
   * Identifier for the Istio mesh in which this canonical service is defined.
   * Corresponds to the `mesh_uid` metric label in
   * [Istio metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   */
  meshUid: string;
  /**
   * The namespace of the canonical service underlying this service.
   * Corresponds to the `destination_canonical_service_namespace` metric
   * label in [Istio
   * metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   */
  canonicalServiceNamespace: string;
  /**
   * The name of the canonical service underlying this service.
   * Corresponds to the `destination_canonical_service_name` metric label in
   * label in [Istio
   * metrics](https://cloud.google.com/monitoring/api/metrics_istio).
   */
  canonicalService: string;
}

/** Cloud Run service. Learn more at https://cloud.google.com/run. */
export interface Service_CloudRun {
  /**
   * The name of the Cloud Run service. Corresponds to the `service_name`
   * resource label in the [`cloud_run_revision` monitored
   * resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
   */
  serviceName: string;
  /**
   * The location the service is run. Corresponds to the `location`
   * resource label in the [`cloud_run_revision` monitored
   * resource](https://cloud.google.com/monitoring/api/resources#tag_cloud_run_revision).
   */
  location: string;
}

/**
 * GKE Namespace. The field names correspond to the resource metadata labels
 * on monitored resources that fall under a namespace (for example,
 * `k8s_container` or `k8s_pod`).
 */
export interface Service_GkeNamespace {
  /**
   * Output only. The project this resource lives in. For legacy services
   * migrated from the `Custom` type, this may be a distinct project from the
   * one parenting the service itself.
   */
  projectId: string;
  /** The location of the parent cluster. This may be a zone or region. */
  location: string;
  /** The name of the parent cluster. */
  clusterName: string;
  /** The name of this namespace. */
  namespaceName: string;
}

/**
 * A GKE Workload (Deployment, StatefulSet, etc). The field names correspond
 * to the metadata labels on monitored resources that fall under a workload
 * (for example, `k8s_container` or `k8s_pod`).
 */
export interface Service_GkeWorkload {
  /**
   * Output only. The project this resource lives in. For legacy services
   * migrated from the `Custom` type, this may be a distinct project from the
   * one parenting the service itself.
   */
  projectId: string;
  /** The location of the parent cluster. This may be a zone or region. */
  location: string;
  /** The name of the parent cluster. */
  clusterName: string;
  /** The name of the parent namespace. */
  namespaceName: string;
  /** The type of this workload (for example, "Deployment" or "DaemonSet") */
  topLevelControllerType: string;
  /** The name of this workload. */
  topLevelControllerName: string;
}

/**
 * GKE Service. The "service" here represents a
 * [Kubernetes service
 * object](https://kubernetes.io/docs/concepts/services-networking/service).
 * The field names correspond to the resource labels on [`k8s_service`
 * monitored
 * resources](https://cloud.google.com/monitoring/api/resources#tag_k8s_service).
 */
export interface Service_GkeService {
  /**
   * Output only. The project this resource lives in. For legacy services
   * migrated from the `Custom` type, this may be a distinct project from the
   * one parenting the service itself.
   */
  projectId: string;
  /** The location of the parent cluster. This may be a zone or region. */
  location: string;
  /** The name of the parent cluster. */
  clusterName: string;
  /** The name of the parent namespace. */
  namespaceName: string;
  /** The name of this service. */
  serviceName: string;
}

/**
 * A well-known service type, defined by its service type and service labels.
 * Documentation and examples
 * [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
 */
export interface Service_BasicService {
  /**
   * The type of service that this basic service defines, e.g.
   * APP_ENGINE service type.
   * Documentation and valid values
   * [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
   */
  serviceType: string;
  /**
   * Labels that specify the resource that emits the monitoring data which
   * is used for SLO reporting of this `Service`.
   * Documentation and valid values for given service types
   * [here](https://cloud.google.com/stackdriver/docs/solutions/slo-monitoring/api/api-structures#basic-svc-w-basic-sli).
   */
  serviceLabels: { [key: string]: string };
}

export interface Service_BasicService_ServiceLabelsEntry {
  key: string;
  value: string;
}

/** Configuration for how to query telemetry on a Service. */
export interface Service_Telemetry {
  /**
   * The full name of the resource that defines this service. Formatted as
   * described in https://cloud.google.com/apis/design/resource_names.
   */
  resourceName: string;
}

export interface Service_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * A Service-Level Objective (SLO) describes a level of desired good service. It
 * consists of a service-level indicator (SLI), a performance goal, and a period
 * over which the objective is to be evaluated against that goal. The SLO can
 * use SLIs defined in a number of different manners. Typical SLOs might include
 * "99% of requests in each rolling week have latency below 200 milliseconds" or
 * "99.5% of requests in each calendar month return successfully."
 */
export interface ServiceLevelObjective {
  /**
   * Identifier. Resource name for this `ServiceLevelObjective`. The format is:
   *
   *     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
   */
  name: string;
  /** Name used for UI elements listing this SLO. */
  displayName: string;
  /**
   * The definition of good service, used to measure and calculate the quality
   * of the `Service`'s performance with respect to a single aspect of service
   * quality.
   */
  serviceLevelIndicator:
    | ServiceLevelIndicator
    | undefined;
  /**
   * The fraction of service that must be good in order for this objective to be
   * met. `0 < goal <= 0.999`.
   */
  goal: number;
  /**
   * A rolling time period, semantically "in the past `<rolling_period>`".
   * Must be an integer multiple of 1 day no larger than 30 days.
   */
  rollingPeriod?:
    | Duration
    | undefined;
  /**
   * A calendar period, semantically "since the start of the current
   * `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
   * `MONTH` are supported.
   */
  calendarPeriod?:
    | CalendarPeriod
    | undefined;
  /**
   * Labels which have been used to annotate the service-level objective. Label
   * keys must start with a letter. Label keys and values may contain lowercase
   * letters, numbers, underscores, and dashes. Label keys and values have a
   * maximum length of 63 characters, and must be less than 128 bytes in size.
   * Up to 64 label entries may be stored. For labels which do not have a
   * semantic value, the empty string may be supplied for the label value.
   */
  userLabels: { [key: string]: string };
}

/**
 * `ServiceLevelObjective.View` determines what form of
 * `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
 * `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
 */
export enum ServiceLevelObjective_View {
  /** VIEW_UNSPECIFIED - Same as FULL. */
  VIEW_UNSPECIFIED = 0,
  /**
   * FULL - Return the embedded `ServiceLevelIndicator` in the form in which it was
   * defined. If it was defined using a `BasicSli`, return that `BasicSli`.
   */
  FULL = 2,
  /**
   * EXPLICIT - For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
   * return the `ServiceLevelIndicator` with its mode of computation fully
   * spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
   * `RequestBasedSli` or `WindowsBasedSli`, return the
   * `ServiceLevelIndicator` as it was provided.
   */
  EXPLICIT = 1,
  UNRECOGNIZED = -1,
}

export function serviceLevelObjective_ViewFromJSON(object: any): ServiceLevelObjective_View {
  switch (object) {
    case 0:
    case "VIEW_UNSPECIFIED":
      return ServiceLevelObjective_View.VIEW_UNSPECIFIED;
    case 2:
    case "FULL":
      return ServiceLevelObjective_View.FULL;
    case 1:
    case "EXPLICIT":
      return ServiceLevelObjective_View.EXPLICIT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceLevelObjective_View.UNRECOGNIZED;
  }
}

export function serviceLevelObjective_ViewToJSON(object: ServiceLevelObjective_View): string {
  switch (object) {
    case ServiceLevelObjective_View.VIEW_UNSPECIFIED:
      return "VIEW_UNSPECIFIED";
    case ServiceLevelObjective_View.FULL:
      return "FULL";
    case ServiceLevelObjective_View.EXPLICIT:
      return "EXPLICIT";
    case ServiceLevelObjective_View.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ServiceLevelObjective_UserLabelsEntry {
  key: string;
  value: string;
}

/**
 * A Service-Level Indicator (SLI) describes the "performance" of a service. For
 * some services, the SLI is well-defined. In such cases, the SLI can be
 * described easily by referencing the well-known SLI and providing the needed
 * parameters. Alternatively, a "custom" SLI can be defined with a query to the
 * underlying metric store. An SLI is defined to be `good_service /
 * total_service` over any queried time interval. The value of performance
 * always falls into the range `0 <= performance <= 1`. A custom SLI describes
 * how to compute this ratio, whether this is by dividing values from a pair of
 * time series, cutting a `Distribution` into good and bad counts, or counting
 * time windows in which the service complies with a criterion. For separation
 * of concerns, a single Service-Level Indicator measures performance for only
 * one aspect of service quality, such as fraction of successful queries or
 * fast-enough queries.
 */
export interface ServiceLevelIndicator {
  /** Basic SLI on a well-known service type. */
  basicSli?:
    | BasicSli
    | undefined;
  /** Request-based SLIs */
  requestBased?:
    | RequestBasedSli
    | undefined;
  /** Windows-based SLIs */
  windowsBased?: WindowsBasedSli | undefined;
}

/**
 * An SLI measuring performance on a well-known service type. Performance will
 * be computed on the basis of pre-defined metrics. The type of the
 * `service_resource` determines the metrics to use and the
 * `service_resource.labels` and `metric_labels` are used to construct a
 * monitoring filter to filter that metric down to just the data relevant to
 * this service.
 */
export interface BasicSli {
  /**
   * OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
   * other methods will not be used to calculate performance for this SLI. If
   * omitted, this SLI applies to all the Service's methods. For service types
   * that don't support breaking down by method, setting this field will result
   * in an error.
   */
  method: string[];
  /**
   * OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
   * from other locations will not be used to calculate performance for this
   * SLI. If omitted, this SLI applies to all locations in which the Service has
   * activity. For service types that don't support breaking down by location,
   * setting this field will result in an error.
   */
  location: string[];
  /**
   * OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
   * from other API versions will not be used to calculate performance for this
   * SLI. If omitted, this SLI applies to all API versions. For service types
   * that don't support breaking down by version, setting this field will result
   * in an error.
   */
  version: string[];
  /**
   * Good service is defined to be the count of requests made to this service
   * that return successfully.
   */
  availability?:
    | BasicSli_AvailabilityCriteria
    | undefined;
  /**
   * Good service is defined to be the count of requests made to this service
   * that are fast enough with respect to `latency.threshold`.
   */
  latency?: BasicSli_LatencyCriteria | undefined;
}

/** Future parameters for the availability SLI. */
export interface BasicSli_AvailabilityCriteria {
}

/** Parameters for a latency threshold SLI. */
export interface BasicSli_LatencyCriteria {
  /**
   * Good service is defined to be the count of requests made to this service
   * that return in no more than `threshold`.
   */
  threshold: Duration | undefined;
}

/** Range of numerical values within `min` and `max`. */
export interface Range {
  /** Range minimum. */
  min: number;
  /** Range maximum. */
  max: number;
}

/**
 * Service Level Indicators for which atomic units of service are counted
 * directly.
 */
export interface RequestBasedSli {
  /**
   * `good_total_ratio` is used when the ratio of `good_service` to
   * `total_service` is computed from two `TimeSeries`.
   */
  goodTotalRatio?:
    | TimeSeriesRatio
    | undefined;
  /**
   * `distribution_cut` is used when `good_service` is a count of values
   * aggregated in a `Distribution` that fall into a good range. The
   * `total_service` is the total count of all values aggregated in the
   * `Distribution`.
   */
  distributionCut?: DistributionCut | undefined;
}

/**
 * A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
 * `good_service / total_service` ratio. The specified `TimeSeries` must have
 * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
 * DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
 * exactly two of good, bad, and total, and the relationship `good_service +
 * bad_service = total_service` will be assumed.
 */
export interface TimeSeriesRatio {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying good service provided. Must have
   * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
   * DELTA` or `MetricKind = CUMULATIVE`.
   */
  goodServiceFilter: string;
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying bad service, either demanded service
   * that was not provided or demanded service that was of inadequate quality.
   * Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
   * `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   */
  badServiceFilter: string;
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` quantifying total demanded service. Must have
   * `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
   * DELTA` or `MetricKind = CUMULATIVE`.
   */
  totalServiceFilter: string;
}

/**
 * A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
 * good service and total service. The `TimeSeries` must have `ValueType =
 * DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
 * computed `good_service` will be the estimated count of values in the
 * `Distribution` that fall within the specified `min` and `max`.
 */
export interface DistributionCut {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` aggregating values. Must have `ValueType =
   * DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
   */
  distributionFilter: string;
  /**
   * Range of values considered "good." For a one-sided range, set one bound to
   * an infinite value.
   */
  range: Range | undefined;
}

/**
 * A `WindowsBasedSli` defines `good_service` as the count of time windows for
 * which the provided service was of good quality. Criteria for determining
 * if service was good are embedded in the `window_criterion`.
 */
export interface WindowsBasedSli {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
   * any `true` values appear in the window.
   */
  goodBadMetricFilter?:
    | string
    | undefined;
  /** A window is good if its `performance` is high enough. */
  goodTotalRatioThreshold?:
    | WindowsBasedSli_PerformanceThreshold
    | undefined;
  /**
   * A window is good if the metric's value is in a good range, averaged
   * across returned streams.
   */
  metricMeanInRange?:
    | WindowsBasedSli_MetricRange
    | undefined;
  /**
   * A window is good if the metric's value is in a good range, summed across
   * returned streams.
   */
  metricSumInRange?:
    | WindowsBasedSli_MetricRange
    | undefined;
  /**
   * Duration over which window quality is evaluated. Must be an integer
   * fraction of a day and at least `60s`.
   */
  windowPeriod: Duration | undefined;
}

/**
 * A `PerformanceThreshold` is used when each window is good when that window
 * has a sufficiently high `performance`.
 */
export interface WindowsBasedSli_PerformanceThreshold {
  /** `RequestBasedSli` to evaluate to judge window quality. */
  performance?:
    | RequestBasedSli
    | undefined;
  /** `BasicSli` to evaluate to judge window quality. */
  basicSliPerformance?:
    | BasicSli
    | undefined;
  /** If window `performance >= threshold`, the window is counted as good. */
  threshold: number;
}

/**
 * A `MetricRange` is used when each window is good when the value x of a
 * single `TimeSeries` satisfies `range.min <= x <= range.max`. The provided
 * `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
 * `MetricKind = GAUGE`.
 */
export interface WindowsBasedSli_MetricRange {
  /**
   * A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
   * specifying the `TimeSeries` to use for evaluating window quality.
   */
  timeSeries: string;
  /**
   * Range of values considered "good." For a one-sided range, set one bound
   * to an infinite value.
   */
  range: Range | undefined;
}

function createBaseService(): Service {
  return {
    name: "",
    displayName: "",
    custom: undefined,
    appEngine: undefined,
    cloudEndpoints: undefined,
    clusterIstio: undefined,
    meshIstio: undefined,
    istioCanonicalService: undefined,
    cloudRun: undefined,
    gkeNamespace: undefined,
    gkeWorkload: undefined,
    gkeService: undefined,
    basicService: undefined,
    telemetry: undefined,
    userLabels: {},
  };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.custom !== undefined) {
      Service_Custom.encode(message.custom, writer.uint32(50).fork()).join();
    }
    if (message.appEngine !== undefined) {
      Service_AppEngine.encode(message.appEngine, writer.uint32(58).fork()).join();
    }
    if (message.cloudEndpoints !== undefined) {
      Service_CloudEndpoints.encode(message.cloudEndpoints, writer.uint32(66).fork()).join();
    }
    if (message.clusterIstio !== undefined) {
      Service_ClusterIstio.encode(message.clusterIstio, writer.uint32(74).fork()).join();
    }
    if (message.meshIstio !== undefined) {
      Service_MeshIstio.encode(message.meshIstio, writer.uint32(82).fork()).join();
    }
    if (message.istioCanonicalService !== undefined) {
      Service_IstioCanonicalService.encode(message.istioCanonicalService, writer.uint32(90).fork()).join();
    }
    if (message.cloudRun !== undefined) {
      Service_CloudRun.encode(message.cloudRun, writer.uint32(98).fork()).join();
    }
    if (message.gkeNamespace !== undefined) {
      Service_GkeNamespace.encode(message.gkeNamespace, writer.uint32(122).fork()).join();
    }
    if (message.gkeWorkload !== undefined) {
      Service_GkeWorkload.encode(message.gkeWorkload, writer.uint32(130).fork()).join();
    }
    if (message.gkeService !== undefined) {
      Service_GkeService.encode(message.gkeService, writer.uint32(138).fork()).join();
    }
    if (message.basicService !== undefined) {
      Service_BasicService.encode(message.basicService, writer.uint32(154).fork()).join();
    }
    if (message.telemetry !== undefined) {
      Service_Telemetry.encode(message.telemetry, writer.uint32(106).fork()).join();
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      Service_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.custom = Service_Custom.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.appEngine = Service_AppEngine.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cloudEndpoints = Service_CloudEndpoints.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clusterIstio = Service_ClusterIstio.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.meshIstio = Service_MeshIstio.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.istioCanonicalService = Service_IstioCanonicalService.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cloudRun = Service_CloudRun.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.gkeNamespace = Service_GkeNamespace.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.gkeWorkload = Service_GkeWorkload.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.gkeService = Service_GkeService.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.basicService = Service_BasicService.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.telemetry = Service_Telemetry.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = Service_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.userLabels[entry14.key] = entry14.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      custom: isSet(object.custom) ? Service_Custom.fromJSON(object.custom) : undefined,
      appEngine: isSet(object.appEngine) ? Service_AppEngine.fromJSON(object.appEngine) : undefined,
      cloudEndpoints: isSet(object.cloudEndpoints) ? Service_CloudEndpoints.fromJSON(object.cloudEndpoints) : undefined,
      clusterIstio: isSet(object.clusterIstio) ? Service_ClusterIstio.fromJSON(object.clusterIstio) : undefined,
      meshIstio: isSet(object.meshIstio) ? Service_MeshIstio.fromJSON(object.meshIstio) : undefined,
      istioCanonicalService: isSet(object.istioCanonicalService)
        ? Service_IstioCanonicalService.fromJSON(object.istioCanonicalService)
        : undefined,
      cloudRun: isSet(object.cloudRun) ? Service_CloudRun.fromJSON(object.cloudRun) : undefined,
      gkeNamespace: isSet(object.gkeNamespace) ? Service_GkeNamespace.fromJSON(object.gkeNamespace) : undefined,
      gkeWorkload: isSet(object.gkeWorkload) ? Service_GkeWorkload.fromJSON(object.gkeWorkload) : undefined,
      gkeService: isSet(object.gkeService) ? Service_GkeService.fromJSON(object.gkeService) : undefined,
      basicService: isSet(object.basicService) ? Service_BasicService.fromJSON(object.basicService) : undefined,
      telemetry: isSet(object.telemetry) ? Service_Telemetry.fromJSON(object.telemetry) : undefined,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.custom !== undefined) {
      obj.custom = Service_Custom.toJSON(message.custom);
    }
    if (message.appEngine !== undefined) {
      obj.appEngine = Service_AppEngine.toJSON(message.appEngine);
    }
    if (message.cloudEndpoints !== undefined) {
      obj.cloudEndpoints = Service_CloudEndpoints.toJSON(message.cloudEndpoints);
    }
    if (message.clusterIstio !== undefined) {
      obj.clusterIstio = Service_ClusterIstio.toJSON(message.clusterIstio);
    }
    if (message.meshIstio !== undefined) {
      obj.meshIstio = Service_MeshIstio.toJSON(message.meshIstio);
    }
    if (message.istioCanonicalService !== undefined) {
      obj.istioCanonicalService = Service_IstioCanonicalService.toJSON(message.istioCanonicalService);
    }
    if (message.cloudRun !== undefined) {
      obj.cloudRun = Service_CloudRun.toJSON(message.cloudRun);
    }
    if (message.gkeNamespace !== undefined) {
      obj.gkeNamespace = Service_GkeNamespace.toJSON(message.gkeNamespace);
    }
    if (message.gkeWorkload !== undefined) {
      obj.gkeWorkload = Service_GkeWorkload.toJSON(message.gkeWorkload);
    }
    if (message.gkeService !== undefined) {
      obj.gkeService = Service_GkeService.toJSON(message.gkeService);
    }
    if (message.basicService !== undefined) {
      obj.basicService = Service_BasicService.toJSON(message.basicService);
    }
    if (message.telemetry !== undefined) {
      obj.telemetry = Service_Telemetry.toJSON(message.telemetry);
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Service>): Service {
    return Service.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service>): Service {
    const message = createBaseService();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? Service_Custom.fromPartial(object.custom)
      : undefined;
    message.appEngine = (object.appEngine !== undefined && object.appEngine !== null)
      ? Service_AppEngine.fromPartial(object.appEngine)
      : undefined;
    message.cloudEndpoints = (object.cloudEndpoints !== undefined && object.cloudEndpoints !== null)
      ? Service_CloudEndpoints.fromPartial(object.cloudEndpoints)
      : undefined;
    message.clusterIstio = (object.clusterIstio !== undefined && object.clusterIstio !== null)
      ? Service_ClusterIstio.fromPartial(object.clusterIstio)
      : undefined;
    message.meshIstio = (object.meshIstio !== undefined && object.meshIstio !== null)
      ? Service_MeshIstio.fromPartial(object.meshIstio)
      : undefined;
    message.istioCanonicalService =
      (object.istioCanonicalService !== undefined && object.istioCanonicalService !== null)
        ? Service_IstioCanonicalService.fromPartial(object.istioCanonicalService)
        : undefined;
    message.cloudRun = (object.cloudRun !== undefined && object.cloudRun !== null)
      ? Service_CloudRun.fromPartial(object.cloudRun)
      : undefined;
    message.gkeNamespace = (object.gkeNamespace !== undefined && object.gkeNamespace !== null)
      ? Service_GkeNamespace.fromPartial(object.gkeNamespace)
      : undefined;
    message.gkeWorkload = (object.gkeWorkload !== undefined && object.gkeWorkload !== null)
      ? Service_GkeWorkload.fromPartial(object.gkeWorkload)
      : undefined;
    message.gkeService = (object.gkeService !== undefined && object.gkeService !== null)
      ? Service_GkeService.fromPartial(object.gkeService)
      : undefined;
    message.basicService = (object.basicService !== undefined && object.basicService !== null)
      ? Service_BasicService.fromPartial(object.basicService)
      : undefined;
    message.telemetry = (object.telemetry !== undefined && object.telemetry !== null)
      ? Service_Telemetry.fromPartial(object.telemetry)
      : undefined;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseService_Custom(): Service_Custom {
  return {};
}

export const Service_Custom: MessageFns<Service_Custom> = {
  encode(_: Service_Custom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_Custom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_Custom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Service_Custom {
    return {};
  },

  toJSON(_: Service_Custom): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Service_Custom>): Service_Custom {
    return Service_Custom.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Service_Custom>): Service_Custom {
    const message = createBaseService_Custom();
    return message;
  },
};

function createBaseService_AppEngine(): Service_AppEngine {
  return { moduleId: "" };
}

export const Service_AppEngine: MessageFns<Service_AppEngine> = {
  encode(message: Service_AppEngine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moduleId !== "") {
      writer.uint32(10).string(message.moduleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_AppEngine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_AppEngine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.moduleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_AppEngine {
    return { moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "" };
  },

  toJSON(message: Service_AppEngine): unknown {
    const obj: any = {};
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_AppEngine>): Service_AppEngine {
    return Service_AppEngine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_AppEngine>): Service_AppEngine {
    const message = createBaseService_AppEngine();
    message.moduleId = object.moduleId ?? "";
    return message;
  },
};

function createBaseService_CloudEndpoints(): Service_CloudEndpoints {
  return { service: "" };
}

export const Service_CloudEndpoints: MessageFns<Service_CloudEndpoints> = {
  encode(message: Service_CloudEndpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_CloudEndpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_CloudEndpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_CloudEndpoints {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: Service_CloudEndpoints): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_CloudEndpoints>): Service_CloudEndpoints {
    return Service_CloudEndpoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_CloudEndpoints>): Service_CloudEndpoints {
    const message = createBaseService_CloudEndpoints();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseService_ClusterIstio(): Service_ClusterIstio {
  return { location: "", clusterName: "", serviceNamespace: "", serviceName: "" };
}

export const Service_ClusterIstio: MessageFns<Service_ClusterIstio> = {
  encode(message: Service_ClusterIstio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    if (message.clusterName !== "") {
      writer.uint32(18).string(message.clusterName);
    }
    if (message.serviceNamespace !== "") {
      writer.uint32(26).string(message.serviceNamespace);
    }
    if (message.serviceName !== "") {
      writer.uint32(34).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_ClusterIstio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_ClusterIstio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceNamespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_ClusterIstio {
    return {
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
      serviceNamespace: isSet(object.serviceNamespace) ? globalThis.String(object.serviceNamespace) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
    };
  },

  toJSON(message: Service_ClusterIstio): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    if (message.serviceNamespace !== "") {
      obj.serviceNamespace = message.serviceNamespace;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_ClusterIstio>): Service_ClusterIstio {
    return Service_ClusterIstio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_ClusterIstio>): Service_ClusterIstio {
    const message = createBaseService_ClusterIstio();
    message.location = object.location ?? "";
    message.clusterName = object.clusterName ?? "";
    message.serviceNamespace = object.serviceNamespace ?? "";
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseService_MeshIstio(): Service_MeshIstio {
  return { meshUid: "", serviceNamespace: "", serviceName: "" };
}

export const Service_MeshIstio: MessageFns<Service_MeshIstio> = {
  encode(message: Service_MeshIstio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meshUid !== "") {
      writer.uint32(10).string(message.meshUid);
    }
    if (message.serviceNamespace !== "") {
      writer.uint32(26).string(message.serviceNamespace);
    }
    if (message.serviceName !== "") {
      writer.uint32(34).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_MeshIstio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_MeshIstio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.meshUid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceNamespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_MeshIstio {
    return {
      meshUid: isSet(object.meshUid) ? globalThis.String(object.meshUid) : "",
      serviceNamespace: isSet(object.serviceNamespace) ? globalThis.String(object.serviceNamespace) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
    };
  },

  toJSON(message: Service_MeshIstio): unknown {
    const obj: any = {};
    if (message.meshUid !== "") {
      obj.meshUid = message.meshUid;
    }
    if (message.serviceNamespace !== "") {
      obj.serviceNamespace = message.serviceNamespace;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_MeshIstio>): Service_MeshIstio {
    return Service_MeshIstio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_MeshIstio>): Service_MeshIstio {
    const message = createBaseService_MeshIstio();
    message.meshUid = object.meshUid ?? "";
    message.serviceNamespace = object.serviceNamespace ?? "";
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseService_IstioCanonicalService(): Service_IstioCanonicalService {
  return { meshUid: "", canonicalServiceNamespace: "", canonicalService: "" };
}

export const Service_IstioCanonicalService: MessageFns<Service_IstioCanonicalService> = {
  encode(message: Service_IstioCanonicalService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.meshUid !== "") {
      writer.uint32(10).string(message.meshUid);
    }
    if (message.canonicalServiceNamespace !== "") {
      writer.uint32(26).string(message.canonicalServiceNamespace);
    }
    if (message.canonicalService !== "") {
      writer.uint32(34).string(message.canonicalService);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_IstioCanonicalService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_IstioCanonicalService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.meshUid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.canonicalServiceNamespace = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.canonicalService = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_IstioCanonicalService {
    return {
      meshUid: isSet(object.meshUid) ? globalThis.String(object.meshUid) : "",
      canonicalServiceNamespace: isSet(object.canonicalServiceNamespace)
        ? globalThis.String(object.canonicalServiceNamespace)
        : "",
      canonicalService: isSet(object.canonicalService) ? globalThis.String(object.canonicalService) : "",
    };
  },

  toJSON(message: Service_IstioCanonicalService): unknown {
    const obj: any = {};
    if (message.meshUid !== "") {
      obj.meshUid = message.meshUid;
    }
    if (message.canonicalServiceNamespace !== "") {
      obj.canonicalServiceNamespace = message.canonicalServiceNamespace;
    }
    if (message.canonicalService !== "") {
      obj.canonicalService = message.canonicalService;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_IstioCanonicalService>): Service_IstioCanonicalService {
    return Service_IstioCanonicalService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_IstioCanonicalService>): Service_IstioCanonicalService {
    const message = createBaseService_IstioCanonicalService();
    message.meshUid = object.meshUid ?? "";
    message.canonicalServiceNamespace = object.canonicalServiceNamespace ?? "";
    message.canonicalService = object.canonicalService ?? "";
    return message;
  },
};

function createBaseService_CloudRun(): Service_CloudRun {
  return { serviceName: "", location: "" };
}

export const Service_CloudRun: MessageFns<Service_CloudRun> = {
  encode(message: Service_CloudRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_CloudRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_CloudRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_CloudRun {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: Service_CloudRun): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_CloudRun>): Service_CloudRun {
    return Service_CloudRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_CloudRun>): Service_CloudRun {
    const message = createBaseService_CloudRun();
    message.serviceName = object.serviceName ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseService_GkeNamespace(): Service_GkeNamespace {
  return { projectId: "", location: "", clusterName: "", namespaceName: "" };
}

export const Service_GkeNamespace: MessageFns<Service_GkeNamespace> = {
  encode(message: Service_GkeNamespace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.clusterName !== "") {
      writer.uint32(26).string(message.clusterName);
    }
    if (message.namespaceName !== "") {
      writer.uint32(34).string(message.namespaceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_GkeNamespace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_GkeNamespace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespaceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_GkeNamespace {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
      namespaceName: isSet(object.namespaceName) ? globalThis.String(object.namespaceName) : "",
    };
  },

  toJSON(message: Service_GkeNamespace): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    if (message.namespaceName !== "") {
      obj.namespaceName = message.namespaceName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_GkeNamespace>): Service_GkeNamespace {
    return Service_GkeNamespace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_GkeNamespace>): Service_GkeNamespace {
    const message = createBaseService_GkeNamespace();
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    message.clusterName = object.clusterName ?? "";
    message.namespaceName = object.namespaceName ?? "";
    return message;
  },
};

function createBaseService_GkeWorkload(): Service_GkeWorkload {
  return {
    projectId: "",
    location: "",
    clusterName: "",
    namespaceName: "",
    topLevelControllerType: "",
    topLevelControllerName: "",
  };
}

export const Service_GkeWorkload: MessageFns<Service_GkeWorkload> = {
  encode(message: Service_GkeWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.clusterName !== "") {
      writer.uint32(26).string(message.clusterName);
    }
    if (message.namespaceName !== "") {
      writer.uint32(34).string(message.namespaceName);
    }
    if (message.topLevelControllerType !== "") {
      writer.uint32(42).string(message.topLevelControllerType);
    }
    if (message.topLevelControllerName !== "") {
      writer.uint32(50).string(message.topLevelControllerName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_GkeWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_GkeWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespaceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.topLevelControllerType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.topLevelControllerName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_GkeWorkload {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
      namespaceName: isSet(object.namespaceName) ? globalThis.String(object.namespaceName) : "",
      topLevelControllerType: isSet(object.topLevelControllerType)
        ? globalThis.String(object.topLevelControllerType)
        : "",
      topLevelControllerName: isSet(object.topLevelControllerName)
        ? globalThis.String(object.topLevelControllerName)
        : "",
    };
  },

  toJSON(message: Service_GkeWorkload): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    if (message.namespaceName !== "") {
      obj.namespaceName = message.namespaceName;
    }
    if (message.topLevelControllerType !== "") {
      obj.topLevelControllerType = message.topLevelControllerType;
    }
    if (message.topLevelControllerName !== "") {
      obj.topLevelControllerName = message.topLevelControllerName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_GkeWorkload>): Service_GkeWorkload {
    return Service_GkeWorkload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_GkeWorkload>): Service_GkeWorkload {
    const message = createBaseService_GkeWorkload();
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    message.clusterName = object.clusterName ?? "";
    message.namespaceName = object.namespaceName ?? "";
    message.topLevelControllerType = object.topLevelControllerType ?? "";
    message.topLevelControllerName = object.topLevelControllerName ?? "";
    return message;
  },
};

function createBaseService_GkeService(): Service_GkeService {
  return { projectId: "", location: "", clusterName: "", namespaceName: "", serviceName: "" };
}

export const Service_GkeService: MessageFns<Service_GkeService> = {
  encode(message: Service_GkeService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.clusterName !== "") {
      writer.uint32(26).string(message.clusterName);
    }
    if (message.namespaceName !== "") {
      writer.uint32(34).string(message.namespaceName);
    }
    if (message.serviceName !== "") {
      writer.uint32(42).string(message.serviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_GkeService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_GkeService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.namespaceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_GkeService {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      clusterName: isSet(object.clusterName) ? globalThis.String(object.clusterName) : "",
      namespaceName: isSet(object.namespaceName) ? globalThis.String(object.namespaceName) : "",
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
    };
  },

  toJSON(message: Service_GkeService): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.clusterName !== "") {
      obj.clusterName = message.clusterName;
    }
    if (message.namespaceName !== "") {
      obj.namespaceName = message.namespaceName;
    }
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_GkeService>): Service_GkeService {
    return Service_GkeService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_GkeService>): Service_GkeService {
    const message = createBaseService_GkeService();
    message.projectId = object.projectId ?? "";
    message.location = object.location ?? "";
    message.clusterName = object.clusterName ?? "";
    message.namespaceName = object.namespaceName ?? "";
    message.serviceName = object.serviceName ?? "";
    return message;
  },
};

function createBaseService_BasicService(): Service_BasicService {
  return { serviceType: "", serviceLabels: {} };
}

export const Service_BasicService: MessageFns<Service_BasicService> = {
  encode(message: Service_BasicService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceType !== "") {
      writer.uint32(10).string(message.serviceType);
    }
    Object.entries(message.serviceLabels).forEach(([key, value]) => {
      Service_BasicService_ServiceLabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_BasicService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_BasicService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Service_BasicService_ServiceLabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.serviceLabels[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_BasicService {
    return {
      serviceType: isSet(object.serviceType) ? globalThis.String(object.serviceType) : "",
      serviceLabels: isObject(object.serviceLabels)
        ? Object.entries(object.serviceLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Service_BasicService): unknown {
    const obj: any = {};
    if (message.serviceType !== "") {
      obj.serviceType = message.serviceType;
    }
    if (message.serviceLabels) {
      const entries = Object.entries(message.serviceLabels);
      if (entries.length > 0) {
        obj.serviceLabels = {};
        entries.forEach(([k, v]) => {
          obj.serviceLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Service_BasicService>): Service_BasicService {
    return Service_BasicService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_BasicService>): Service_BasicService {
    const message = createBaseService_BasicService();
    message.serviceType = object.serviceType ?? "";
    message.serviceLabels = Object.entries(object.serviceLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseService_BasicService_ServiceLabelsEntry(): Service_BasicService_ServiceLabelsEntry {
  return { key: "", value: "" };
}

export const Service_BasicService_ServiceLabelsEntry: MessageFns<Service_BasicService_ServiceLabelsEntry> = {
  encode(message: Service_BasicService_ServiceLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_BasicService_ServiceLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_BasicService_ServiceLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_BasicService_ServiceLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Service_BasicService_ServiceLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_BasicService_ServiceLabelsEntry>): Service_BasicService_ServiceLabelsEntry {
    return Service_BasicService_ServiceLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_BasicService_ServiceLabelsEntry>): Service_BasicService_ServiceLabelsEntry {
    const message = createBaseService_BasicService_ServiceLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseService_Telemetry(): Service_Telemetry {
  return { resourceName: "" };
}

export const Service_Telemetry: MessageFns<Service_Telemetry> = {
  encode(message: Service_Telemetry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceName !== "") {
      writer.uint32(10).string(message.resourceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_Telemetry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_Telemetry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_Telemetry {
    return { resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : "" };
  },

  toJSON(message: Service_Telemetry): unknown {
    const obj: any = {};
    if (message.resourceName !== "") {
      obj.resourceName = message.resourceName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_Telemetry>): Service_Telemetry {
    return Service_Telemetry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_Telemetry>): Service_Telemetry {
    const message = createBaseService_Telemetry();
    message.resourceName = object.resourceName ?? "";
    return message;
  },
};

function createBaseService_UserLabelsEntry(): Service_UserLabelsEntry {
  return { key: "", value: "" };
}

export const Service_UserLabelsEntry: MessageFns<Service_UserLabelsEntry> = {
  encode(message: Service_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Service_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Service_UserLabelsEntry>): Service_UserLabelsEntry {
    return Service_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service_UserLabelsEntry>): Service_UserLabelsEntry {
    const message = createBaseService_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceLevelObjective(): ServiceLevelObjective {
  return {
    name: "",
    displayName: "",
    serviceLevelIndicator: undefined,
    goal: 0,
    rollingPeriod: undefined,
    calendarPeriod: undefined,
    userLabels: {},
  };
}

export const ServiceLevelObjective: MessageFns<ServiceLevelObjective> = {
  encode(message: ServiceLevelObjective, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    if (message.serviceLevelIndicator !== undefined) {
      ServiceLevelIndicator.encode(message.serviceLevelIndicator, writer.uint32(26).fork()).join();
    }
    if (message.goal !== 0) {
      writer.uint32(33).double(message.goal);
    }
    if (message.rollingPeriod !== undefined) {
      Duration.encode(message.rollingPeriod, writer.uint32(42).fork()).join();
    }
    if (message.calendarPeriod !== undefined) {
      writer.uint32(48).int32(message.calendarPeriod);
    }
    Object.entries(message.userLabels).forEach(([key, value]) => {
      ServiceLevelObjective_UserLabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceLevelObjective {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceLevelObjective();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.serviceLevelIndicator = ServiceLevelIndicator.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.goal = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rollingPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.calendarPeriod = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = ServiceLevelObjective_UserLabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.userLabels[entry12.key] = entry12.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceLevelObjective {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      serviceLevelIndicator: isSet(object.serviceLevelIndicator)
        ? ServiceLevelIndicator.fromJSON(object.serviceLevelIndicator)
        : undefined,
      goal: isSet(object.goal) ? globalThis.Number(object.goal) : 0,
      rollingPeriod: isSet(object.rollingPeriod) ? Duration.fromJSON(object.rollingPeriod) : undefined,
      calendarPeriod: isSet(object.calendarPeriod) ? calendarPeriodFromJSON(object.calendarPeriod) : undefined,
      userLabels: isObject(object.userLabels)
        ? Object.entries(object.userLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ServiceLevelObjective): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.serviceLevelIndicator !== undefined) {
      obj.serviceLevelIndicator = ServiceLevelIndicator.toJSON(message.serviceLevelIndicator);
    }
    if (message.goal !== 0) {
      obj.goal = message.goal;
    }
    if (message.rollingPeriod !== undefined) {
      obj.rollingPeriod = Duration.toJSON(message.rollingPeriod);
    }
    if (message.calendarPeriod !== undefined) {
      obj.calendarPeriod = calendarPeriodToJSON(message.calendarPeriod);
    }
    if (message.userLabels) {
      const entries = Object.entries(message.userLabels);
      if (entries.length > 0) {
        obj.userLabels = {};
        entries.forEach(([k, v]) => {
          obj.userLabels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceLevelObjective>): ServiceLevelObjective {
    return ServiceLevelObjective.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceLevelObjective>): ServiceLevelObjective {
    const message = createBaseServiceLevelObjective();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.serviceLevelIndicator =
      (object.serviceLevelIndicator !== undefined && object.serviceLevelIndicator !== null)
        ? ServiceLevelIndicator.fromPartial(object.serviceLevelIndicator)
        : undefined;
    message.goal = object.goal ?? 0;
    message.rollingPeriod = (object.rollingPeriod !== undefined && object.rollingPeriod !== null)
      ? Duration.fromPartial(object.rollingPeriod)
      : undefined;
    message.calendarPeriod = object.calendarPeriod ?? undefined;
    message.userLabels = Object.entries(object.userLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseServiceLevelObjective_UserLabelsEntry(): ServiceLevelObjective_UserLabelsEntry {
  return { key: "", value: "" };
}

export const ServiceLevelObjective_UserLabelsEntry: MessageFns<ServiceLevelObjective_UserLabelsEntry> = {
  encode(message: ServiceLevelObjective_UserLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceLevelObjective_UserLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceLevelObjective_UserLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceLevelObjective_UserLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ServiceLevelObjective_UserLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceLevelObjective_UserLabelsEntry>): ServiceLevelObjective_UserLabelsEntry {
    return ServiceLevelObjective_UserLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceLevelObjective_UserLabelsEntry>): ServiceLevelObjective_UserLabelsEntry {
    const message = createBaseServiceLevelObjective_UserLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseServiceLevelIndicator(): ServiceLevelIndicator {
  return { basicSli: undefined, requestBased: undefined, windowsBased: undefined };
}

export const ServiceLevelIndicator: MessageFns<ServiceLevelIndicator> = {
  encode(message: ServiceLevelIndicator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basicSli !== undefined) {
      BasicSli.encode(message.basicSli, writer.uint32(34).fork()).join();
    }
    if (message.requestBased !== undefined) {
      RequestBasedSli.encode(message.requestBased, writer.uint32(10).fork()).join();
    }
    if (message.windowsBased !== undefined) {
      WindowsBasedSli.encode(message.windowsBased, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceLevelIndicator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceLevelIndicator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.basicSli = BasicSli.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestBased = RequestBasedSli.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowsBased = WindowsBasedSli.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceLevelIndicator {
    return {
      basicSli: isSet(object.basicSli) ? BasicSli.fromJSON(object.basicSli) : undefined,
      requestBased: isSet(object.requestBased) ? RequestBasedSli.fromJSON(object.requestBased) : undefined,
      windowsBased: isSet(object.windowsBased) ? WindowsBasedSli.fromJSON(object.windowsBased) : undefined,
    };
  },

  toJSON(message: ServiceLevelIndicator): unknown {
    const obj: any = {};
    if (message.basicSli !== undefined) {
      obj.basicSli = BasicSli.toJSON(message.basicSli);
    }
    if (message.requestBased !== undefined) {
      obj.requestBased = RequestBasedSli.toJSON(message.requestBased);
    }
    if (message.windowsBased !== undefined) {
      obj.windowsBased = WindowsBasedSli.toJSON(message.windowsBased);
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceLevelIndicator>): ServiceLevelIndicator {
    return ServiceLevelIndicator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceLevelIndicator>): ServiceLevelIndicator {
    const message = createBaseServiceLevelIndicator();
    message.basicSli = (object.basicSli !== undefined && object.basicSli !== null)
      ? BasicSli.fromPartial(object.basicSli)
      : undefined;
    message.requestBased = (object.requestBased !== undefined && object.requestBased !== null)
      ? RequestBasedSli.fromPartial(object.requestBased)
      : undefined;
    message.windowsBased = (object.windowsBased !== undefined && object.windowsBased !== null)
      ? WindowsBasedSli.fromPartial(object.windowsBased)
      : undefined;
    return message;
  },
};

function createBaseBasicSli(): BasicSli {
  return { method: [], location: [], version: [], availability: undefined, latency: undefined };
}

export const BasicSli: MessageFns<BasicSli> = {
  encode(message: BasicSli, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.method) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.location) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.version) {
      writer.uint32(74).string(v!);
    }
    if (message.availability !== undefined) {
      BasicSli_AvailabilityCriteria.encode(message.availability, writer.uint32(18).fork()).join();
    }
    if (message.latency !== undefined) {
      BasicSli_LatencyCriteria.encode(message.latency, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicSli {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicSli();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.method.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.location.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.version.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.availability = BasicSli_AvailabilityCriteria.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latency = BasicSli_LatencyCriteria.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicSli {
    return {
      method: globalThis.Array.isArray(object?.method) ? object.method.map((e: any) => globalThis.String(e)) : [],
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.String(e)) : [],
      version: globalThis.Array.isArray(object?.version) ? object.version.map((e: any) => globalThis.String(e)) : [],
      availability: isSet(object.availability)
        ? BasicSli_AvailabilityCriteria.fromJSON(object.availability)
        : undefined,
      latency: isSet(object.latency) ? BasicSli_LatencyCriteria.fromJSON(object.latency) : undefined,
    };
  },

  toJSON(message: BasicSli): unknown {
    const obj: any = {};
    if (message.method?.length) {
      obj.method = message.method;
    }
    if (message.location?.length) {
      obj.location = message.location;
    }
    if (message.version?.length) {
      obj.version = message.version;
    }
    if (message.availability !== undefined) {
      obj.availability = BasicSli_AvailabilityCriteria.toJSON(message.availability);
    }
    if (message.latency !== undefined) {
      obj.latency = BasicSli_LatencyCriteria.toJSON(message.latency);
    }
    return obj;
  },

  create(base?: DeepPartial<BasicSli>): BasicSli {
    return BasicSli.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BasicSli>): BasicSli {
    const message = createBaseBasicSli();
    message.method = object.method?.map((e) => e) || [];
    message.location = object.location?.map((e) => e) || [];
    message.version = object.version?.map((e) => e) || [];
    message.availability = (object.availability !== undefined && object.availability !== null)
      ? BasicSli_AvailabilityCriteria.fromPartial(object.availability)
      : undefined;
    message.latency = (object.latency !== undefined && object.latency !== null)
      ? BasicSli_LatencyCriteria.fromPartial(object.latency)
      : undefined;
    return message;
  },
};

function createBaseBasicSli_AvailabilityCriteria(): BasicSli_AvailabilityCriteria {
  return {};
}

export const BasicSli_AvailabilityCriteria: MessageFns<BasicSli_AvailabilityCriteria> = {
  encode(_: BasicSli_AvailabilityCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicSli_AvailabilityCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicSli_AvailabilityCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BasicSli_AvailabilityCriteria {
    return {};
  },

  toJSON(_: BasicSli_AvailabilityCriteria): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<BasicSli_AvailabilityCriteria>): BasicSli_AvailabilityCriteria {
    return BasicSli_AvailabilityCriteria.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<BasicSli_AvailabilityCriteria>): BasicSli_AvailabilityCriteria {
    const message = createBaseBasicSli_AvailabilityCriteria();
    return message;
  },
};

function createBaseBasicSli_LatencyCriteria(): BasicSli_LatencyCriteria {
  return { threshold: undefined };
}

export const BasicSli_LatencyCriteria: MessageFns<BasicSli_LatencyCriteria> = {
  encode(message: BasicSli_LatencyCriteria, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== undefined) {
      Duration.encode(message.threshold, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicSli_LatencyCriteria {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicSli_LatencyCriteria();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.threshold = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicSli_LatencyCriteria {
    return { threshold: isSet(object.threshold) ? Duration.fromJSON(object.threshold) : undefined };
  },

  toJSON(message: BasicSli_LatencyCriteria): unknown {
    const obj: any = {};
    if (message.threshold !== undefined) {
      obj.threshold = Duration.toJSON(message.threshold);
    }
    return obj;
  },

  create(base?: DeepPartial<BasicSli_LatencyCriteria>): BasicSli_LatencyCriteria {
    return BasicSli_LatencyCriteria.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BasicSli_LatencyCriteria>): BasicSli_LatencyCriteria {
    const message = createBaseBasicSli_LatencyCriteria();
    message.threshold = (object.threshold !== undefined && object.threshold !== null)
      ? Duration.fromPartial(object.threshold)
      : undefined;
    return message;
  },
};

function createBaseRange(): Range {
  return { min: 0, max: 0 };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.min !== 0) {
      writer.uint32(9).double(message.min);
    }
    if (message.max !== 0) {
      writer.uint32(17).double(message.max);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.min = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.max = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      min: isSet(object.min) ? globalThis.Number(object.min) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (message.min !== 0) {
      obj.min = message.min;
    }
    if (message.max !== 0) {
      obj.max = message.max;
    }
    return obj;
  },

  create(base?: DeepPartial<Range>): Range {
    return Range.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Range>): Range {
    const message = createBaseRange();
    message.min = object.min ?? 0;
    message.max = object.max ?? 0;
    return message;
  },
};

function createBaseRequestBasedSli(): RequestBasedSli {
  return { goodTotalRatio: undefined, distributionCut: undefined };
}

export const RequestBasedSli: MessageFns<RequestBasedSli> = {
  encode(message: RequestBasedSli, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.goodTotalRatio !== undefined) {
      TimeSeriesRatio.encode(message.goodTotalRatio, writer.uint32(10).fork()).join();
    }
    if (message.distributionCut !== undefined) {
      DistributionCut.encode(message.distributionCut, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestBasedSli {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBasedSli();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.goodTotalRatio = TimeSeriesRatio.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.distributionCut = DistributionCut.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBasedSli {
    return {
      goodTotalRatio: isSet(object.goodTotalRatio) ? TimeSeriesRatio.fromJSON(object.goodTotalRatio) : undefined,
      distributionCut: isSet(object.distributionCut) ? DistributionCut.fromJSON(object.distributionCut) : undefined,
    };
  },

  toJSON(message: RequestBasedSli): unknown {
    const obj: any = {};
    if (message.goodTotalRatio !== undefined) {
      obj.goodTotalRatio = TimeSeriesRatio.toJSON(message.goodTotalRatio);
    }
    if (message.distributionCut !== undefined) {
      obj.distributionCut = DistributionCut.toJSON(message.distributionCut);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBasedSli>): RequestBasedSli {
    return RequestBasedSli.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBasedSli>): RequestBasedSli {
    const message = createBaseRequestBasedSli();
    message.goodTotalRatio = (object.goodTotalRatio !== undefined && object.goodTotalRatio !== null)
      ? TimeSeriesRatio.fromPartial(object.goodTotalRatio)
      : undefined;
    message.distributionCut = (object.distributionCut !== undefined && object.distributionCut !== null)
      ? DistributionCut.fromPartial(object.distributionCut)
      : undefined;
    return message;
  },
};

function createBaseTimeSeriesRatio(): TimeSeriesRatio {
  return { goodServiceFilter: "", badServiceFilter: "", totalServiceFilter: "" };
}

export const TimeSeriesRatio: MessageFns<TimeSeriesRatio> = {
  encode(message: TimeSeriesRatio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.goodServiceFilter !== "") {
      writer.uint32(34).string(message.goodServiceFilter);
    }
    if (message.badServiceFilter !== "") {
      writer.uint32(42).string(message.badServiceFilter);
    }
    if (message.totalServiceFilter !== "") {
      writer.uint32(50).string(message.totalServiceFilter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeriesRatio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeriesRatio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.goodServiceFilter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.badServiceFilter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.totalServiceFilter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeriesRatio {
    return {
      goodServiceFilter: isSet(object.goodServiceFilter) ? globalThis.String(object.goodServiceFilter) : "",
      badServiceFilter: isSet(object.badServiceFilter) ? globalThis.String(object.badServiceFilter) : "",
      totalServiceFilter: isSet(object.totalServiceFilter) ? globalThis.String(object.totalServiceFilter) : "",
    };
  },

  toJSON(message: TimeSeriesRatio): unknown {
    const obj: any = {};
    if (message.goodServiceFilter !== "") {
      obj.goodServiceFilter = message.goodServiceFilter;
    }
    if (message.badServiceFilter !== "") {
      obj.badServiceFilter = message.badServiceFilter;
    }
    if (message.totalServiceFilter !== "") {
      obj.totalServiceFilter = message.totalServiceFilter;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeriesRatio>): TimeSeriesRatio {
    return TimeSeriesRatio.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeriesRatio>): TimeSeriesRatio {
    const message = createBaseTimeSeriesRatio();
    message.goodServiceFilter = object.goodServiceFilter ?? "";
    message.badServiceFilter = object.badServiceFilter ?? "";
    message.totalServiceFilter = object.totalServiceFilter ?? "";
    return message;
  },
};

function createBaseDistributionCut(): DistributionCut {
  return { distributionFilter: "", range: undefined };
}

export const DistributionCut: MessageFns<DistributionCut> = {
  encode(message: DistributionCut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distributionFilter !== "") {
      writer.uint32(34).string(message.distributionFilter);
    }
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistributionCut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistributionCut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.distributionFilter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistributionCut {
    return {
      distributionFilter: isSet(object.distributionFilter) ? globalThis.String(object.distributionFilter) : "",
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
    };
  },

  toJSON(message: DistributionCut): unknown {
    const obj: any = {};
    if (message.distributionFilter !== "") {
      obj.distributionFilter = message.distributionFilter;
    }
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    return obj;
  },

  create(base?: DeepPartial<DistributionCut>): DistributionCut {
    return DistributionCut.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DistributionCut>): DistributionCut {
    const message = createBaseDistributionCut();
    message.distributionFilter = object.distributionFilter ?? "";
    message.range = (object.range !== undefined && object.range !== null) ? Range.fromPartial(object.range) : undefined;
    return message;
  },
};

function createBaseWindowsBasedSli(): WindowsBasedSli {
  return {
    goodBadMetricFilter: undefined,
    goodTotalRatioThreshold: undefined,
    metricMeanInRange: undefined,
    metricSumInRange: undefined,
    windowPeriod: undefined,
  };
}

export const WindowsBasedSli: MessageFns<WindowsBasedSli> = {
  encode(message: WindowsBasedSli, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.goodBadMetricFilter !== undefined) {
      writer.uint32(42).string(message.goodBadMetricFilter);
    }
    if (message.goodTotalRatioThreshold !== undefined) {
      WindowsBasedSli_PerformanceThreshold.encode(message.goodTotalRatioThreshold, writer.uint32(18).fork()).join();
    }
    if (message.metricMeanInRange !== undefined) {
      WindowsBasedSli_MetricRange.encode(message.metricMeanInRange, writer.uint32(50).fork()).join();
    }
    if (message.metricSumInRange !== undefined) {
      WindowsBasedSli_MetricRange.encode(message.metricSumInRange, writer.uint32(58).fork()).join();
    }
    if (message.windowPeriod !== undefined) {
      Duration.encode(message.windowPeriod, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsBasedSli {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsBasedSli();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.goodBadMetricFilter = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.goodTotalRatioThreshold = WindowsBasedSli_PerformanceThreshold.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metricMeanInRange = WindowsBasedSli_MetricRange.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metricSumInRange = WindowsBasedSli_MetricRange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.windowPeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsBasedSli {
    return {
      goodBadMetricFilter: isSet(object.goodBadMetricFilter)
        ? globalThis.String(object.goodBadMetricFilter)
        : undefined,
      goodTotalRatioThreshold: isSet(object.goodTotalRatioThreshold)
        ? WindowsBasedSli_PerformanceThreshold.fromJSON(object.goodTotalRatioThreshold)
        : undefined,
      metricMeanInRange: isSet(object.metricMeanInRange)
        ? WindowsBasedSli_MetricRange.fromJSON(object.metricMeanInRange)
        : undefined,
      metricSumInRange: isSet(object.metricSumInRange)
        ? WindowsBasedSli_MetricRange.fromJSON(object.metricSumInRange)
        : undefined,
      windowPeriod: isSet(object.windowPeriod) ? Duration.fromJSON(object.windowPeriod) : undefined,
    };
  },

  toJSON(message: WindowsBasedSli): unknown {
    const obj: any = {};
    if (message.goodBadMetricFilter !== undefined) {
      obj.goodBadMetricFilter = message.goodBadMetricFilter;
    }
    if (message.goodTotalRatioThreshold !== undefined) {
      obj.goodTotalRatioThreshold = WindowsBasedSli_PerformanceThreshold.toJSON(message.goodTotalRatioThreshold);
    }
    if (message.metricMeanInRange !== undefined) {
      obj.metricMeanInRange = WindowsBasedSli_MetricRange.toJSON(message.metricMeanInRange);
    }
    if (message.metricSumInRange !== undefined) {
      obj.metricSumInRange = WindowsBasedSli_MetricRange.toJSON(message.metricSumInRange);
    }
    if (message.windowPeriod !== undefined) {
      obj.windowPeriod = Duration.toJSON(message.windowPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsBasedSli>): WindowsBasedSli {
    return WindowsBasedSli.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsBasedSli>): WindowsBasedSli {
    const message = createBaseWindowsBasedSli();
    message.goodBadMetricFilter = object.goodBadMetricFilter ?? undefined;
    message.goodTotalRatioThreshold =
      (object.goodTotalRatioThreshold !== undefined && object.goodTotalRatioThreshold !== null)
        ? WindowsBasedSli_PerformanceThreshold.fromPartial(object.goodTotalRatioThreshold)
        : undefined;
    message.metricMeanInRange = (object.metricMeanInRange !== undefined && object.metricMeanInRange !== null)
      ? WindowsBasedSli_MetricRange.fromPartial(object.metricMeanInRange)
      : undefined;
    message.metricSumInRange = (object.metricSumInRange !== undefined && object.metricSumInRange !== null)
      ? WindowsBasedSli_MetricRange.fromPartial(object.metricSumInRange)
      : undefined;
    message.windowPeriod = (object.windowPeriod !== undefined && object.windowPeriod !== null)
      ? Duration.fromPartial(object.windowPeriod)
      : undefined;
    return message;
  },
};

function createBaseWindowsBasedSli_PerformanceThreshold(): WindowsBasedSli_PerformanceThreshold {
  return { performance: undefined, basicSliPerformance: undefined, threshold: 0 };
}

export const WindowsBasedSli_PerformanceThreshold: MessageFns<WindowsBasedSli_PerformanceThreshold> = {
  encode(message: WindowsBasedSli_PerformanceThreshold, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.performance !== undefined) {
      RequestBasedSli.encode(message.performance, writer.uint32(10).fork()).join();
    }
    if (message.basicSliPerformance !== undefined) {
      BasicSli.encode(message.basicSliPerformance, writer.uint32(26).fork()).join();
    }
    if (message.threshold !== 0) {
      writer.uint32(17).double(message.threshold);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsBasedSli_PerformanceThreshold {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsBasedSli_PerformanceThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.performance = RequestBasedSli.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.basicSliPerformance = BasicSli.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.threshold = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsBasedSli_PerformanceThreshold {
    return {
      performance: isSet(object.performance) ? RequestBasedSli.fromJSON(object.performance) : undefined,
      basicSliPerformance: isSet(object.basicSliPerformance)
        ? BasicSli.fromJSON(object.basicSliPerformance)
        : undefined,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
    };
  },

  toJSON(message: WindowsBasedSli_PerformanceThreshold): unknown {
    const obj: any = {};
    if (message.performance !== undefined) {
      obj.performance = RequestBasedSli.toJSON(message.performance);
    }
    if (message.basicSliPerformance !== undefined) {
      obj.basicSliPerformance = BasicSli.toJSON(message.basicSliPerformance);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsBasedSli_PerformanceThreshold>): WindowsBasedSli_PerformanceThreshold {
    return WindowsBasedSli_PerformanceThreshold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsBasedSli_PerformanceThreshold>): WindowsBasedSli_PerformanceThreshold {
    const message = createBaseWindowsBasedSli_PerformanceThreshold();
    message.performance = (object.performance !== undefined && object.performance !== null)
      ? RequestBasedSli.fromPartial(object.performance)
      : undefined;
    message.basicSliPerformance = (object.basicSliPerformance !== undefined && object.basicSliPerformance !== null)
      ? BasicSli.fromPartial(object.basicSliPerformance)
      : undefined;
    message.threshold = object.threshold ?? 0;
    return message;
  },
};

function createBaseWindowsBasedSli_MetricRange(): WindowsBasedSli_MetricRange {
  return { timeSeries: "", range: undefined };
}

export const WindowsBasedSli_MetricRange: MessageFns<WindowsBasedSli_MetricRange> = {
  encode(message: WindowsBasedSli_MetricRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSeries !== "") {
      writer.uint32(10).string(message.timeSeries);
    }
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsBasedSli_MetricRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsBasedSli_MetricRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSeries = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsBasedSli_MetricRange {
    return {
      timeSeries: isSet(object.timeSeries) ? globalThis.String(object.timeSeries) : "",
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
    };
  },

  toJSON(message: WindowsBasedSli_MetricRange): unknown {
    const obj: any = {};
    if (message.timeSeries !== "") {
      obj.timeSeries = message.timeSeries;
    }
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsBasedSli_MetricRange>): WindowsBasedSli_MetricRange {
    return WindowsBasedSli_MetricRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsBasedSli_MetricRange>): WindowsBasedSli_MetricRange {
    const message = createBaseWindowsBasedSli_MetricRange();
    message.timeSeries = object.timeSeries ?? "";
    message.range = (object.range !== undefined && object.range !== null) ? Range.fromPartial(object.range) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
