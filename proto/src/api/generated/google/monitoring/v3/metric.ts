// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/v3/metric.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { LabelDescriptor } from "../../api/label.js";
import {
  Metric,
  MetricDescriptor_MetricKind,
  metricDescriptor_MetricKindFromJSON,
  metricDescriptor_MetricKindToJSON,
  MetricDescriptor_ValueType,
  metricDescriptor_ValueTypeFromJSON,
  metricDescriptor_ValueTypeToJSON,
} from "../../api/metric.js";
import { MonitoredResource, MonitoredResourceMetadata } from "../../api/monitored_resource.js";
import { TimeInterval, TypedValue } from "./common.js";

export const protobufPackage = "google.monitoring.v3";

/** A single data point in a time series. */
export interface Point {
  /**
   * The time interval to which the data point applies.  For `GAUGE` metrics,
   * the start time is optional, but if it is supplied, it must equal the
   * end time.  For `DELTA` metrics, the start
   * and end time should specify a non-zero interval, with subsequent points
   * specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
   * metrics, the start and end time should specify a non-zero interval, with
   * subsequent points specifying the same start time and increasing end times,
   * until an event resets the cumulative value to zero and sets a new start
   * time for the following points.
   */
  interval:
    | TimeInterval
    | undefined;
  /** The value of the data point. */
  value: TypedValue | undefined;
}

/**
 * A collection of data points that describes the time-varying values
 * of a metric. A time series is identified by a combination of a
 * fully-specified monitored resource and a fully-specified metric.
 * This type is used for both listing and creating time series.
 */
export interface TimeSeries {
  /**
   * The associated metric. A fully-specified metric used to identify the time
   * series.
   */
  metric:
    | Metric
    | undefined;
  /**
   * The associated monitored resource.  Custom metrics can use only certain
   * monitored resource types in their time series data. For more information,
   * see [Monitored resources for custom
   * metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
   */
  resource:
    | MonitoredResource
    | undefined;
  /**
   * Output only. The associated monitored resource metadata. When reading a
   * time series, this field will include metadata labels that are explicitly
   * named in the reduction. When creating a time series, this field is ignored.
   */
  metadata:
    | MonitoredResourceMetadata
    | undefined;
  /**
   * The metric kind of the time series. When listing time series, this metric
   * kind might be different from the metric kind of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the metric kind of the associated metric. If the associated
   * metric's descriptor must be auto-created, then this field specifies the
   * metric kind of the new descriptor and must be either `GAUGE` (the default)
   * or `CUMULATIVE`.
   */
  metricKind: MetricDescriptor_MetricKind;
  /**
   * The value type of the time series. When listing time series, this value
   * type might be different from the value type of the associated metric if
   * this time series is an alignment or reduction of other time series.
   *
   * When creating a time series, this field is optional. If present, it must be
   * the same as the type of the data in the `points` field.
   */
  valueType: MetricDescriptor_ValueType;
  /**
   * The data points of this time series. When listing time series, points are
   * returned in reverse time order.
   *
   * When creating a time series, this field must contain exactly one point and
   * the point's type must be the same as the value type of the associated
   * metric. If the associated metric's descriptor must be auto-created, then
   * the value type of the descriptor is determined by the point's type, which
   * must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
   */
  points: Point[];
  /**
   * The units in which the metric value is reported. It is only applicable
   * if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
   * defines the representation of the stored metric values.
   */
  unit: string;
}

/** A descriptor for the labels and points in a time series. */
export interface TimeSeriesDescriptor {
  /** Descriptors for the labels. */
  labelDescriptors: LabelDescriptor[];
  /** Descriptors for the point data value columns. */
  pointDescriptors: TimeSeriesDescriptor_ValueDescriptor[];
}

/** A descriptor for the value columns in a data point. */
export interface TimeSeriesDescriptor_ValueDescriptor {
  /** The value key. */
  key: string;
  /** The value type. */
  valueType: MetricDescriptor_ValueType;
  /** The value stream kind. */
  metricKind: MetricDescriptor_MetricKind;
  /**
   * The unit in which `time_series` point values are reported. `unit`
   * follows the UCUM format for units as seen in
   * https://unitsofmeasure.org/ucum.html.
   * `unit` is only valid if `value_type` is INTEGER, DOUBLE, DISTRIBUTION.
   */
  unit: string;
}

/**
 * Represents the values of a time series associated with a
 * TimeSeriesDescriptor.
 */
export interface TimeSeriesData {
  /**
   * The values of the labels in the time series identifier, given in the same
   * order as the `label_descriptors` field of the TimeSeriesDescriptor
   * associated with this object. Each value must have a value of the type
   * given in the corresponding entry of `label_descriptors`.
   */
  labelValues: LabelValue[];
  /** The points in the time series. */
  pointData: TimeSeriesData_PointData[];
}

/**
 * A point's value columns and time interval. Each point has one or more
 * point values corresponding to the entries in `point_descriptors` field in
 * the TimeSeriesDescriptor associated with this object.
 */
export interface TimeSeriesData_PointData {
  /** The values that make up the point. */
  values: TypedValue[];
  /** The time interval associated with the point. */
  timeInterval: TimeInterval | undefined;
}

/** A label value. */
export interface LabelValue {
  /** A bool label value. */
  boolValue?:
    | boolean
    | undefined;
  /** An int64 label value. */
  int64Value?:
    | Long
    | undefined;
  /** A string label value. */
  stringValue?: string | undefined;
}

/** An error associated with a query in the time series query language format. */
export interface QueryError {
  /**
   * The location of the time series query language text that this error applies
   * to.
   */
  locator:
    | TextLocator
    | undefined;
  /** The error message. */
  message: string;
}

/**
 * A locator for text. Indicates a particular part of the text of a request or
 * of an object referenced in the request.
 *
 * For example, suppose the request field `text` contains:
 *
 *   text: "The quick brown fox jumps over the lazy dog."
 *
 * Then the locator:
 *
 *   source: "text"
 *   start_position {
 *     line: 1
 *     column: 17
 *   }
 *   end_position {
 *     line: 1
 *     column: 19
 *   }
 *
 * refers to the part of the text: "fox".
 */
export interface TextLocator {
  /**
   * The source of the text. The source may be a field in the request, in which
   * case its format is the format of the
   * google.rpc.BadRequest.FieldViolation.field field in
   * https://cloud.google.com/apis/design/errors#error_details. It may also be
   * be a source other than the request field (e.g. a macro definition
   * referenced in the text of the query), in which case this is the name of
   * the source (e.g. the macro name).
   */
  source: string;
  /** The position of the first byte within the text. */
  startPosition:
    | TextLocator_Position
    | undefined;
  /** The position of the last byte within the text. */
  endPosition:
    | TextLocator_Position
    | undefined;
  /**
   * If `source`, `start_position`, and `end_position` describe a call on
   * some object (e.g. a macro in the time series query language text) and a
   * location is to be designated in that object's text, `nested_locator`
   * identifies the location within that object.
   */
  nestedLocator:
    | TextLocator
    | undefined;
  /**
   * When `nested_locator` is set, this field gives the reason for the nesting.
   * Usually, the reason is a macro invocation. In that case, the macro name
   * (including the leading '@') signals the location of the macro call
   * in the text and a macro argument name (including the leading '$') signals
   * the location of the macro argument inside the macro body that got
   * substituted away.
   */
  nestingReason: string;
}

/** The position of a byte within the text. */
export interface TextLocator_Position {
  /** The line, starting with 1, where the byte is positioned. */
  line: number;
  /**
   * The column within the line, starting with 1, where the byte is
   * positioned. This is a byte index even though the text is UTF-8.
   */
  column: number;
}

function createBasePoint(): Point {
  return { interval: undefined, value: undefined };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interval !== undefined) {
      TimeInterval.encode(message.interval, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      TypedValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interval = TimeInterval.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TypedValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      interval: isSet(object.interval) ? TimeInterval.fromJSON(object.interval) : undefined,
      value: isSet(object.value) ? TypedValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.interval !== undefined) {
      obj.interval = TimeInterval.toJSON(message.interval);
    }
    if (message.value !== undefined) {
      obj.value = TypedValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Point>): Point {
    return Point.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Point>): Point {
    const message = createBasePoint();
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? TimeInterval.fromPartial(object.interval)
      : undefined;
    message.value = (object.value !== undefined && object.value !== null)
      ? TypedValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTimeSeries(): TimeSeries {
  return {
    metric: undefined,
    resource: undefined,
    metadata: undefined,
    metricKind: 0,
    valueType: 0,
    points: [],
    unit: "",
  };
}

export const TimeSeries: MessageFns<TimeSeries> = {
  encode(message: TimeSeries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== undefined) {
      Metric.encode(message.metric, writer.uint32(10).fork()).join();
    }
    if (message.resource !== undefined) {
      MonitoredResource.encode(message.resource, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      MonitoredResourceMetadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    if (message.metricKind !== 0) {
      writer.uint32(24).int32(message.metricKind);
    }
    if (message.valueType !== 0) {
      writer.uint32(32).int32(message.valueType);
    }
    for (const v of message.points) {
      Point.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.unit !== "") {
      writer.uint32(66).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metric = Metric.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = MonitoredResource.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = MonitoredResourceMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metricKind = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.points.push(Point.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeries {
    return {
      metric: isSet(object.metric) ? Metric.fromJSON(object.metric) : undefined,
      resource: isSet(object.resource) ? MonitoredResource.fromJSON(object.resource) : undefined,
      metadata: isSet(object.metadata) ? MonitoredResourceMetadata.fromJSON(object.metadata) : undefined,
      metricKind: isSet(object.metricKind) ? metricDescriptor_MetricKindFromJSON(object.metricKind) : 0,
      valueType: isSet(object.valueType) ? metricDescriptor_ValueTypeFromJSON(object.valueType) : 0,
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point.fromJSON(e)) : [],
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: TimeSeries): unknown {
    const obj: any = {};
    if (message.metric !== undefined) {
      obj.metric = Metric.toJSON(message.metric);
    }
    if (message.resource !== undefined) {
      obj.resource = MonitoredResource.toJSON(message.resource);
    }
    if (message.metadata !== undefined) {
      obj.metadata = MonitoredResourceMetadata.toJSON(message.metadata);
    }
    if (message.metricKind !== 0) {
      obj.metricKind = metricDescriptor_MetricKindToJSON(message.metricKind);
    }
    if (message.valueType !== 0) {
      obj.valueType = metricDescriptor_ValueTypeToJSON(message.valueType);
    }
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point.toJSON(e));
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeries>): TimeSeries {
    return TimeSeries.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeries>): TimeSeries {
    const message = createBaseTimeSeries();
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? Metric.fromPartial(object.metric)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? MonitoredResource.fromPartial(object.resource)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MonitoredResourceMetadata.fromPartial(object.metadata)
      : undefined;
    message.metricKind = object.metricKind ?? 0;
    message.valueType = object.valueType ?? 0;
    message.points = object.points?.map((e) => Point.fromPartial(e)) || [];
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseTimeSeriesDescriptor(): TimeSeriesDescriptor {
  return { labelDescriptors: [], pointDescriptors: [] };
}

export const TimeSeriesDescriptor: MessageFns<TimeSeriesDescriptor> = {
  encode(message: TimeSeriesDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labelDescriptors) {
      LabelDescriptor.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.pointDescriptors) {
      TimeSeriesDescriptor_ValueDescriptor.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeriesDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeriesDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.labelDescriptors.push(LabelDescriptor.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pointDescriptors.push(TimeSeriesDescriptor_ValueDescriptor.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeriesDescriptor {
    return {
      labelDescriptors: globalThis.Array.isArray(object?.labelDescriptors)
        ? object.labelDescriptors.map((e: any) => LabelDescriptor.fromJSON(e))
        : [],
      pointDescriptors: globalThis.Array.isArray(object?.pointDescriptors)
        ? object.pointDescriptors.map((e: any) => TimeSeriesDescriptor_ValueDescriptor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TimeSeriesDescriptor): unknown {
    const obj: any = {};
    if (message.labelDescriptors?.length) {
      obj.labelDescriptors = message.labelDescriptors.map((e) => LabelDescriptor.toJSON(e));
    }
    if (message.pointDescriptors?.length) {
      obj.pointDescriptors = message.pointDescriptors.map((e) => TimeSeriesDescriptor_ValueDescriptor.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeriesDescriptor>): TimeSeriesDescriptor {
    return TimeSeriesDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeriesDescriptor>): TimeSeriesDescriptor {
    const message = createBaseTimeSeriesDescriptor();
    message.labelDescriptors = object.labelDescriptors?.map((e) => LabelDescriptor.fromPartial(e)) || [];
    message.pointDescriptors =
      object.pointDescriptors?.map((e) => TimeSeriesDescriptor_ValueDescriptor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimeSeriesDescriptor_ValueDescriptor(): TimeSeriesDescriptor_ValueDescriptor {
  return { key: "", valueType: 0, metricKind: 0, unit: "" };
}

export const TimeSeriesDescriptor_ValueDescriptor: MessageFns<TimeSeriesDescriptor_ValueDescriptor> = {
  encode(message: TimeSeriesDescriptor_ValueDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.valueType !== 0) {
      writer.uint32(16).int32(message.valueType);
    }
    if (message.metricKind !== 0) {
      writer.uint32(24).int32(message.metricKind);
    }
    if (message.unit !== "") {
      writer.uint32(34).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeriesDescriptor_ValueDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeriesDescriptor_ValueDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metricKind = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeriesDescriptor_ValueDescriptor {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      valueType: isSet(object.valueType) ? metricDescriptor_ValueTypeFromJSON(object.valueType) : 0,
      metricKind: isSet(object.metricKind) ? metricDescriptor_MetricKindFromJSON(object.metricKind) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: TimeSeriesDescriptor_ValueDescriptor): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.valueType !== 0) {
      obj.valueType = metricDescriptor_ValueTypeToJSON(message.valueType);
    }
    if (message.metricKind !== 0) {
      obj.metricKind = metricDescriptor_MetricKindToJSON(message.metricKind);
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeriesDescriptor_ValueDescriptor>): TimeSeriesDescriptor_ValueDescriptor {
    return TimeSeriesDescriptor_ValueDescriptor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeriesDescriptor_ValueDescriptor>): TimeSeriesDescriptor_ValueDescriptor {
    const message = createBaseTimeSeriesDescriptor_ValueDescriptor();
    message.key = object.key ?? "";
    message.valueType = object.valueType ?? 0;
    message.metricKind = object.metricKind ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseTimeSeriesData(): TimeSeriesData {
  return { labelValues: [], pointData: [] };
}

export const TimeSeriesData: MessageFns<TimeSeriesData> = {
  encode(message: TimeSeriesData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.labelValues) {
      LabelValue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.pointData) {
      TimeSeriesData_PointData.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeriesData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeriesData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.labelValues.push(LabelValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pointData.push(TimeSeriesData_PointData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeriesData {
    return {
      labelValues: globalThis.Array.isArray(object?.labelValues)
        ? object.labelValues.map((e: any) => LabelValue.fromJSON(e))
        : [],
      pointData: globalThis.Array.isArray(object?.pointData)
        ? object.pointData.map((e: any) => TimeSeriesData_PointData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TimeSeriesData): unknown {
    const obj: any = {};
    if (message.labelValues?.length) {
      obj.labelValues = message.labelValues.map((e) => LabelValue.toJSON(e));
    }
    if (message.pointData?.length) {
      obj.pointData = message.pointData.map((e) => TimeSeriesData_PointData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeriesData>): TimeSeriesData {
    return TimeSeriesData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeriesData>): TimeSeriesData {
    const message = createBaseTimeSeriesData();
    message.labelValues = object.labelValues?.map((e) => LabelValue.fromPartial(e)) || [];
    message.pointData = object.pointData?.map((e) => TimeSeriesData_PointData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTimeSeriesData_PointData(): TimeSeriesData_PointData {
  return { values: [], timeInterval: undefined };
}

export const TimeSeriesData_PointData: MessageFns<TimeSeriesData_PointData> = {
  encode(message: TimeSeriesData_PointData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      TypedValue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.timeInterval !== undefined) {
      TimeInterval.encode(message.timeInterval, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeSeriesData_PointData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeSeriesData_PointData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(TypedValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeInterval = TimeInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeSeriesData_PointData {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => TypedValue.fromJSON(e)) : [],
      timeInterval: isSet(object.timeInterval) ? TimeInterval.fromJSON(object.timeInterval) : undefined,
    };
  },

  toJSON(message: TimeSeriesData_PointData): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => TypedValue.toJSON(e));
    }
    if (message.timeInterval !== undefined) {
      obj.timeInterval = TimeInterval.toJSON(message.timeInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<TimeSeriesData_PointData>): TimeSeriesData_PointData {
    return TimeSeriesData_PointData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeSeriesData_PointData>): TimeSeriesData_PointData {
    const message = createBaseTimeSeriesData_PointData();
    message.values = object.values?.map((e) => TypedValue.fromPartial(e)) || [];
    message.timeInterval = (object.timeInterval !== undefined && object.timeInterval !== null)
      ? TimeInterval.fromPartial(object.timeInterval)
      : undefined;
    return message;
  },
};

function createBaseLabelValue(): LabelValue {
  return { boolValue: undefined, int64Value: undefined, stringValue: undefined };
}

export const LabelValue: MessageFns<LabelValue> = {
  encode(message: LabelValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.boolValue !== undefined) {
      writer.uint32(8).bool(message.boolValue);
    }
    if (message.int64Value !== undefined) {
      writer.uint32(16).int64(message.int64Value.toString());
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LabelValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLabelValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LabelValue {
    return {
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
    };
  },

  toJSON(message: LabelValue): unknown {
    const obj: any = {};
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create(base?: DeepPartial<LabelValue>): LabelValue {
    return LabelValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LabelValue>): LabelValue {
    const message = createBaseLabelValue();
    message.boolValue = object.boolValue ?? undefined;
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.stringValue = object.stringValue ?? undefined;
    return message;
  },
};

function createBaseQueryError(): QueryError {
  return { locator: undefined, message: "" };
}

export const QueryError: MessageFns<QueryError> = {
  encode(message: QueryError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locator !== undefined) {
      TextLocator.encode(message.locator, writer.uint32(10).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.locator = TextLocator.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryError {
    return {
      locator: isSet(object.locator) ? TextLocator.fromJSON(object.locator) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: QueryError): unknown {
    const obj: any = {};
    if (message.locator !== undefined) {
      obj.locator = TextLocator.toJSON(message.locator);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryError>): QueryError {
    return QueryError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryError>): QueryError {
    const message = createBaseQueryError();
    message.locator = (object.locator !== undefined && object.locator !== null)
      ? TextLocator.fromPartial(object.locator)
      : undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTextLocator(): TextLocator {
  return { source: "", startPosition: undefined, endPosition: undefined, nestedLocator: undefined, nestingReason: "" };
}

export const TextLocator: MessageFns<TextLocator> = {
  encode(message: TextLocator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.startPosition !== undefined) {
      TextLocator_Position.encode(message.startPosition, writer.uint32(18).fork()).join();
    }
    if (message.endPosition !== undefined) {
      TextLocator_Position.encode(message.endPosition, writer.uint32(26).fork()).join();
    }
    if (message.nestedLocator !== undefined) {
      TextLocator.encode(message.nestedLocator, writer.uint32(34).fork()).join();
    }
    if (message.nestingReason !== "") {
      writer.uint32(42).string(message.nestingReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextLocator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextLocator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startPosition = TextLocator_Position.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endPosition = TextLocator_Position.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nestedLocator = TextLocator.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nestingReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextLocator {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      startPosition: isSet(object.startPosition) ? TextLocator_Position.fromJSON(object.startPosition) : undefined,
      endPosition: isSet(object.endPosition) ? TextLocator_Position.fromJSON(object.endPosition) : undefined,
      nestedLocator: isSet(object.nestedLocator) ? TextLocator.fromJSON(object.nestedLocator) : undefined,
      nestingReason: isSet(object.nestingReason) ? globalThis.String(object.nestingReason) : "",
    };
  },

  toJSON(message: TextLocator): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.startPosition !== undefined) {
      obj.startPosition = TextLocator_Position.toJSON(message.startPosition);
    }
    if (message.endPosition !== undefined) {
      obj.endPosition = TextLocator_Position.toJSON(message.endPosition);
    }
    if (message.nestedLocator !== undefined) {
      obj.nestedLocator = TextLocator.toJSON(message.nestedLocator);
    }
    if (message.nestingReason !== "") {
      obj.nestingReason = message.nestingReason;
    }
    return obj;
  },

  create(base?: DeepPartial<TextLocator>): TextLocator {
    return TextLocator.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextLocator>): TextLocator {
    const message = createBaseTextLocator();
    message.source = object.source ?? "";
    message.startPosition = (object.startPosition !== undefined && object.startPosition !== null)
      ? TextLocator_Position.fromPartial(object.startPosition)
      : undefined;
    message.endPosition = (object.endPosition !== undefined && object.endPosition !== null)
      ? TextLocator_Position.fromPartial(object.endPosition)
      : undefined;
    message.nestedLocator = (object.nestedLocator !== undefined && object.nestedLocator !== null)
      ? TextLocator.fromPartial(object.nestedLocator)
      : undefined;
    message.nestingReason = object.nestingReason ?? "";
    return message;
  },
};

function createBaseTextLocator_Position(): TextLocator_Position {
  return { line: 0, column: 0 };
}

export const TextLocator_Position: MessageFns<TextLocator_Position> = {
  encode(message: TextLocator_Position, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).int32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(16).int32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextLocator_Position {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextLocator_Position();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.line = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.column = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextLocator_Position {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
    };
  },

  toJSON(message: TextLocator_Position): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create(base?: DeepPartial<TextLocator_Position>): TextLocator_Position {
    return TextLocator_Position.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextLocator_Position>): TextLocator_Position {
    const message = createBaseTextLocator_Position();
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
