// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/dashboard/v1/text.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.monitoring.dashboard.v1";

/** A widget that displays textual content. */
export interface Text {
  /** The text content to be displayed. */
  content: string;
  /** How the text content is formatted. */
  format: Text_Format;
  /** How the text is styled */
  style: Text_TextStyle | undefined;
}

/** The format type of the text content. */
export enum Text_Format {
  /** FORMAT_UNSPECIFIED - Format is unspecified. Defaults to MARKDOWN. */
  FORMAT_UNSPECIFIED = 0,
  /** MARKDOWN - The text contains Markdown formatting. */
  MARKDOWN = 1,
  /** RAW - The text contains no special formatting. */
  RAW = 2,
  UNRECOGNIZED = -1,
}

export function text_FormatFromJSON(object: any): Text_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return Text_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "MARKDOWN":
      return Text_Format.MARKDOWN;
    case 2:
    case "RAW":
      return Text_Format.RAW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_Format.UNRECOGNIZED;
  }
}

export function text_FormatToJSON(object: Text_Format): string {
  switch (object) {
    case Text_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case Text_Format.MARKDOWN:
      return "MARKDOWN";
    case Text_Format.RAW:
      return "RAW";
    case Text_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Properties that determine how the title and content are styled */
export interface Text_TextStyle {
  /** The background color as a hex string. "#RRGGBB" or "#RGB" */
  backgroundColor: string;
  /** The text color as a hex string. "#RRGGBB" or "#RGB" */
  textColor: string;
  /** The horizontal alignment of both the title and content */
  horizontalAlignment: Text_TextStyle_HorizontalAlignment;
  /** The vertical alignment of both the title and content */
  verticalAlignment: Text_TextStyle_VerticalAlignment;
  /** The amount of padding around the widget */
  padding: Text_TextStyle_PaddingSize;
  /**
   * Font sizes for both the title and content. The title will still be larger
   * relative to the content.
   */
  fontSize: Text_TextStyle_FontSize;
  /** The pointer location for this widget (also sometimes called a "tail") */
  pointerLocation: Text_TextStyle_PointerLocation;
}

/** The horizontal alignment of both the title and content on a text widget */
export enum Text_TextStyle_HorizontalAlignment {
  /** HORIZONTAL_ALIGNMENT_UNSPECIFIED - No horizontal alignment specified, will default to H_LEFT */
  HORIZONTAL_ALIGNMENT_UNSPECIFIED = 0,
  /** H_LEFT - Left-align */
  H_LEFT = 1,
  /** H_CENTER - Center-align */
  H_CENTER = 2,
  /** H_RIGHT - Right-align */
  H_RIGHT = 3,
  UNRECOGNIZED = -1,
}

export function text_TextStyle_HorizontalAlignmentFromJSON(object: any): Text_TextStyle_HorizontalAlignment {
  switch (object) {
    case 0:
    case "HORIZONTAL_ALIGNMENT_UNSPECIFIED":
      return Text_TextStyle_HorizontalAlignment.HORIZONTAL_ALIGNMENT_UNSPECIFIED;
    case 1:
    case "H_LEFT":
      return Text_TextStyle_HorizontalAlignment.H_LEFT;
    case 2:
    case "H_CENTER":
      return Text_TextStyle_HorizontalAlignment.H_CENTER;
    case 3:
    case "H_RIGHT":
      return Text_TextStyle_HorizontalAlignment.H_RIGHT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_TextStyle_HorizontalAlignment.UNRECOGNIZED;
  }
}

export function text_TextStyle_HorizontalAlignmentToJSON(object: Text_TextStyle_HorizontalAlignment): string {
  switch (object) {
    case Text_TextStyle_HorizontalAlignment.HORIZONTAL_ALIGNMENT_UNSPECIFIED:
      return "HORIZONTAL_ALIGNMENT_UNSPECIFIED";
    case Text_TextStyle_HorizontalAlignment.H_LEFT:
      return "H_LEFT";
    case Text_TextStyle_HorizontalAlignment.H_CENTER:
      return "H_CENTER";
    case Text_TextStyle_HorizontalAlignment.H_RIGHT:
      return "H_RIGHT";
    case Text_TextStyle_HorizontalAlignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The vertical alignment of both the title and content on a text widget */
export enum Text_TextStyle_VerticalAlignment {
  /** VERTICAL_ALIGNMENT_UNSPECIFIED - No vertical alignment specified, will default to V_TOP */
  VERTICAL_ALIGNMENT_UNSPECIFIED = 0,
  /** V_TOP - Top-align */
  V_TOP = 1,
  /** V_CENTER - Center-align */
  V_CENTER = 2,
  /** V_BOTTOM - Bottom-align */
  V_BOTTOM = 3,
  UNRECOGNIZED = -1,
}

export function text_TextStyle_VerticalAlignmentFromJSON(object: any): Text_TextStyle_VerticalAlignment {
  switch (object) {
    case 0:
    case "VERTICAL_ALIGNMENT_UNSPECIFIED":
      return Text_TextStyle_VerticalAlignment.VERTICAL_ALIGNMENT_UNSPECIFIED;
    case 1:
    case "V_TOP":
      return Text_TextStyle_VerticalAlignment.V_TOP;
    case 2:
    case "V_CENTER":
      return Text_TextStyle_VerticalAlignment.V_CENTER;
    case 3:
    case "V_BOTTOM":
      return Text_TextStyle_VerticalAlignment.V_BOTTOM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_TextStyle_VerticalAlignment.UNRECOGNIZED;
  }
}

export function text_TextStyle_VerticalAlignmentToJSON(object: Text_TextStyle_VerticalAlignment): string {
  switch (object) {
    case Text_TextStyle_VerticalAlignment.VERTICAL_ALIGNMENT_UNSPECIFIED:
      return "VERTICAL_ALIGNMENT_UNSPECIFIED";
    case Text_TextStyle_VerticalAlignment.V_TOP:
      return "V_TOP";
    case Text_TextStyle_VerticalAlignment.V_CENTER:
      return "V_CENTER";
    case Text_TextStyle_VerticalAlignment.V_BOTTOM:
      return "V_BOTTOM";
    case Text_TextStyle_VerticalAlignment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies padding size around a text widget */
export enum Text_TextStyle_PaddingSize {
  /** PADDING_SIZE_UNSPECIFIED - No padding size specified, will default to P_EXTRA_SMALL */
  PADDING_SIZE_UNSPECIFIED = 0,
  /** P_EXTRA_SMALL - Extra small padding */
  P_EXTRA_SMALL = 1,
  /** P_SMALL - Small padding */
  P_SMALL = 2,
  /** P_MEDIUM - Medium padding */
  P_MEDIUM = 3,
  /** P_LARGE - Large padding */
  P_LARGE = 4,
  /** P_EXTRA_LARGE - Extra large padding */
  P_EXTRA_LARGE = 5,
  UNRECOGNIZED = -1,
}

export function text_TextStyle_PaddingSizeFromJSON(object: any): Text_TextStyle_PaddingSize {
  switch (object) {
    case 0:
    case "PADDING_SIZE_UNSPECIFIED":
      return Text_TextStyle_PaddingSize.PADDING_SIZE_UNSPECIFIED;
    case 1:
    case "P_EXTRA_SMALL":
      return Text_TextStyle_PaddingSize.P_EXTRA_SMALL;
    case 2:
    case "P_SMALL":
      return Text_TextStyle_PaddingSize.P_SMALL;
    case 3:
    case "P_MEDIUM":
      return Text_TextStyle_PaddingSize.P_MEDIUM;
    case 4:
    case "P_LARGE":
      return Text_TextStyle_PaddingSize.P_LARGE;
    case 5:
    case "P_EXTRA_LARGE":
      return Text_TextStyle_PaddingSize.P_EXTRA_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_TextStyle_PaddingSize.UNRECOGNIZED;
  }
}

export function text_TextStyle_PaddingSizeToJSON(object: Text_TextStyle_PaddingSize): string {
  switch (object) {
    case Text_TextStyle_PaddingSize.PADDING_SIZE_UNSPECIFIED:
      return "PADDING_SIZE_UNSPECIFIED";
    case Text_TextStyle_PaddingSize.P_EXTRA_SMALL:
      return "P_EXTRA_SMALL";
    case Text_TextStyle_PaddingSize.P_SMALL:
      return "P_SMALL";
    case Text_TextStyle_PaddingSize.P_MEDIUM:
      return "P_MEDIUM";
    case Text_TextStyle_PaddingSize.P_LARGE:
      return "P_LARGE";
    case Text_TextStyle_PaddingSize.P_EXTRA_LARGE:
      return "P_EXTRA_LARGE";
    case Text_TextStyle_PaddingSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies a font size for the title and content of a text widget */
export enum Text_TextStyle_FontSize {
  /** FONT_SIZE_UNSPECIFIED - No font size specified, will default to FS_LARGE */
  FONT_SIZE_UNSPECIFIED = 0,
  /** FS_EXTRA_SMALL - Extra small font size */
  FS_EXTRA_SMALL = 1,
  /** FS_SMALL - Small font size */
  FS_SMALL = 2,
  /** FS_MEDIUM - Medium font size */
  FS_MEDIUM = 3,
  /** FS_LARGE - Large font size */
  FS_LARGE = 4,
  /** FS_EXTRA_LARGE - Extra large font size */
  FS_EXTRA_LARGE = 5,
  UNRECOGNIZED = -1,
}

export function text_TextStyle_FontSizeFromJSON(object: any): Text_TextStyle_FontSize {
  switch (object) {
    case 0:
    case "FONT_SIZE_UNSPECIFIED":
      return Text_TextStyle_FontSize.FONT_SIZE_UNSPECIFIED;
    case 1:
    case "FS_EXTRA_SMALL":
      return Text_TextStyle_FontSize.FS_EXTRA_SMALL;
    case 2:
    case "FS_SMALL":
      return Text_TextStyle_FontSize.FS_SMALL;
    case 3:
    case "FS_MEDIUM":
      return Text_TextStyle_FontSize.FS_MEDIUM;
    case 4:
    case "FS_LARGE":
      return Text_TextStyle_FontSize.FS_LARGE;
    case 5:
    case "FS_EXTRA_LARGE":
      return Text_TextStyle_FontSize.FS_EXTRA_LARGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_TextStyle_FontSize.UNRECOGNIZED;
  }
}

export function text_TextStyle_FontSizeToJSON(object: Text_TextStyle_FontSize): string {
  switch (object) {
    case Text_TextStyle_FontSize.FONT_SIZE_UNSPECIFIED:
      return "FONT_SIZE_UNSPECIFIED";
    case Text_TextStyle_FontSize.FS_EXTRA_SMALL:
      return "FS_EXTRA_SMALL";
    case Text_TextStyle_FontSize.FS_SMALL:
      return "FS_SMALL";
    case Text_TextStyle_FontSize.FS_MEDIUM:
      return "FS_MEDIUM";
    case Text_TextStyle_FontSize.FS_LARGE:
      return "FS_LARGE";
    case Text_TextStyle_FontSize.FS_EXTRA_LARGE:
      return "FS_EXTRA_LARGE";
    case Text_TextStyle_FontSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies where a visual pointer is placed on a text widget (also
 * sometimes called a "tail")
 */
export enum Text_TextStyle_PointerLocation {
  /** POINTER_LOCATION_UNSPECIFIED - No visual pointer */
  POINTER_LOCATION_UNSPECIFIED = 0,
  /** PL_TOP - Placed in the middle of the top of the widget */
  PL_TOP = 1,
  /** PL_RIGHT - Placed in the middle of the right side of the widget */
  PL_RIGHT = 2,
  /** PL_BOTTOM - Placed in the middle of the bottom of the widget */
  PL_BOTTOM = 3,
  /** PL_LEFT - Placed in the middle of the left side of the widget */
  PL_LEFT = 4,
  /** PL_TOP_LEFT - Placed on the left side of the top of the widget */
  PL_TOP_LEFT = 5,
  /** PL_TOP_RIGHT - Placed on the right side of the top of the widget */
  PL_TOP_RIGHT = 6,
  /** PL_RIGHT_TOP - Placed on the top of the right side of the widget */
  PL_RIGHT_TOP = 7,
  /** PL_RIGHT_BOTTOM - Placed on the bottom of the right side of the widget */
  PL_RIGHT_BOTTOM = 8,
  /** PL_BOTTOM_RIGHT - Placed on the right side of the bottom of the widget */
  PL_BOTTOM_RIGHT = 9,
  /** PL_BOTTOM_LEFT - Placed on the left side of the bottom of the widget */
  PL_BOTTOM_LEFT = 10,
  /** PL_LEFT_BOTTOM - Placed on the bottom of the left side of the widget */
  PL_LEFT_BOTTOM = 11,
  /** PL_LEFT_TOP - Placed on the top of the left side of the widget */
  PL_LEFT_TOP = 12,
  UNRECOGNIZED = -1,
}

export function text_TextStyle_PointerLocationFromJSON(object: any): Text_TextStyle_PointerLocation {
  switch (object) {
    case 0:
    case "POINTER_LOCATION_UNSPECIFIED":
      return Text_TextStyle_PointerLocation.POINTER_LOCATION_UNSPECIFIED;
    case 1:
    case "PL_TOP":
      return Text_TextStyle_PointerLocation.PL_TOP;
    case 2:
    case "PL_RIGHT":
      return Text_TextStyle_PointerLocation.PL_RIGHT;
    case 3:
    case "PL_BOTTOM":
      return Text_TextStyle_PointerLocation.PL_BOTTOM;
    case 4:
    case "PL_LEFT":
      return Text_TextStyle_PointerLocation.PL_LEFT;
    case 5:
    case "PL_TOP_LEFT":
      return Text_TextStyle_PointerLocation.PL_TOP_LEFT;
    case 6:
    case "PL_TOP_RIGHT":
      return Text_TextStyle_PointerLocation.PL_TOP_RIGHT;
    case 7:
    case "PL_RIGHT_TOP":
      return Text_TextStyle_PointerLocation.PL_RIGHT_TOP;
    case 8:
    case "PL_RIGHT_BOTTOM":
      return Text_TextStyle_PointerLocation.PL_RIGHT_BOTTOM;
    case 9:
    case "PL_BOTTOM_RIGHT":
      return Text_TextStyle_PointerLocation.PL_BOTTOM_RIGHT;
    case 10:
    case "PL_BOTTOM_LEFT":
      return Text_TextStyle_PointerLocation.PL_BOTTOM_LEFT;
    case 11:
    case "PL_LEFT_BOTTOM":
      return Text_TextStyle_PointerLocation.PL_LEFT_BOTTOM;
    case 12:
    case "PL_LEFT_TOP":
      return Text_TextStyle_PointerLocation.PL_LEFT_TOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Text_TextStyle_PointerLocation.UNRECOGNIZED;
  }
}

export function text_TextStyle_PointerLocationToJSON(object: Text_TextStyle_PointerLocation): string {
  switch (object) {
    case Text_TextStyle_PointerLocation.POINTER_LOCATION_UNSPECIFIED:
      return "POINTER_LOCATION_UNSPECIFIED";
    case Text_TextStyle_PointerLocation.PL_TOP:
      return "PL_TOP";
    case Text_TextStyle_PointerLocation.PL_RIGHT:
      return "PL_RIGHT";
    case Text_TextStyle_PointerLocation.PL_BOTTOM:
      return "PL_BOTTOM";
    case Text_TextStyle_PointerLocation.PL_LEFT:
      return "PL_LEFT";
    case Text_TextStyle_PointerLocation.PL_TOP_LEFT:
      return "PL_TOP_LEFT";
    case Text_TextStyle_PointerLocation.PL_TOP_RIGHT:
      return "PL_TOP_RIGHT";
    case Text_TextStyle_PointerLocation.PL_RIGHT_TOP:
      return "PL_RIGHT_TOP";
    case Text_TextStyle_PointerLocation.PL_RIGHT_BOTTOM:
      return "PL_RIGHT_BOTTOM";
    case Text_TextStyle_PointerLocation.PL_BOTTOM_RIGHT:
      return "PL_BOTTOM_RIGHT";
    case Text_TextStyle_PointerLocation.PL_BOTTOM_LEFT:
      return "PL_BOTTOM_LEFT";
    case Text_TextStyle_PointerLocation.PL_LEFT_BOTTOM:
      return "PL_LEFT_BOTTOM";
    case Text_TextStyle_PointerLocation.PL_LEFT_TOP:
      return "PL_LEFT_TOP";
    case Text_TextStyle_PointerLocation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseText(): Text {
  return { content: "", format: 0, style: undefined };
}

export const Text: MessageFns<Text> = {
  encode(message: Text, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== "") {
      writer.uint32(10).string(message.content);
    }
    if (message.format !== 0) {
      writer.uint32(16).int32(message.format);
    }
    if (message.style !== undefined) {
      Text_TextStyle.encode(message.style, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.style = Text_TextStyle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text {
    return {
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      format: isSet(object.format) ? text_FormatFromJSON(object.format) : 0,
      style: isSet(object.style) ? Text_TextStyle.fromJSON(object.style) : undefined,
    };
  },

  toJSON(message: Text): unknown {
    const obj: any = {};
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.format !== 0) {
      obj.format = text_FormatToJSON(message.format);
    }
    if (message.style !== undefined) {
      obj.style = Text_TextStyle.toJSON(message.style);
    }
    return obj;
  },

  create(base?: DeepPartial<Text>): Text {
    return Text.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Text>): Text {
    const message = createBaseText();
    message.content = object.content ?? "";
    message.format = object.format ?? 0;
    message.style = (object.style !== undefined && object.style !== null)
      ? Text_TextStyle.fromPartial(object.style)
      : undefined;
    return message;
  },
};

function createBaseText_TextStyle(): Text_TextStyle {
  return {
    backgroundColor: "",
    textColor: "",
    horizontalAlignment: 0,
    verticalAlignment: 0,
    padding: 0,
    fontSize: 0,
    pointerLocation: 0,
  };
}

export const Text_TextStyle: MessageFns<Text_TextStyle> = {
  encode(message: Text_TextStyle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backgroundColor !== "") {
      writer.uint32(10).string(message.backgroundColor);
    }
    if (message.textColor !== "") {
      writer.uint32(18).string(message.textColor);
    }
    if (message.horizontalAlignment !== 0) {
      writer.uint32(24).int32(message.horizontalAlignment);
    }
    if (message.verticalAlignment !== 0) {
      writer.uint32(32).int32(message.verticalAlignment);
    }
    if (message.padding !== 0) {
      writer.uint32(40).int32(message.padding);
    }
    if (message.fontSize !== 0) {
      writer.uint32(48).int32(message.fontSize);
    }
    if (message.pointerLocation !== 0) {
      writer.uint32(56).int32(message.pointerLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Text_TextStyle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseText_TextStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backgroundColor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.horizontalAlignment = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.verticalAlignment = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.padding = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fontSize = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pointerLocation = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Text_TextStyle {
    return {
      backgroundColor: isSet(object.backgroundColor) ? globalThis.String(object.backgroundColor) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      horizontalAlignment: isSet(object.horizontalAlignment)
        ? text_TextStyle_HorizontalAlignmentFromJSON(object.horizontalAlignment)
        : 0,
      verticalAlignment: isSet(object.verticalAlignment)
        ? text_TextStyle_VerticalAlignmentFromJSON(object.verticalAlignment)
        : 0,
      padding: isSet(object.padding) ? text_TextStyle_PaddingSizeFromJSON(object.padding) : 0,
      fontSize: isSet(object.fontSize) ? text_TextStyle_FontSizeFromJSON(object.fontSize) : 0,
      pointerLocation: isSet(object.pointerLocation)
        ? text_TextStyle_PointerLocationFromJSON(object.pointerLocation)
        : 0,
    };
  },

  toJSON(message: Text_TextStyle): unknown {
    const obj: any = {};
    if (message.backgroundColor !== "") {
      obj.backgroundColor = message.backgroundColor;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.horizontalAlignment !== 0) {
      obj.horizontalAlignment = text_TextStyle_HorizontalAlignmentToJSON(message.horizontalAlignment);
    }
    if (message.verticalAlignment !== 0) {
      obj.verticalAlignment = text_TextStyle_VerticalAlignmentToJSON(message.verticalAlignment);
    }
    if (message.padding !== 0) {
      obj.padding = text_TextStyle_PaddingSizeToJSON(message.padding);
    }
    if (message.fontSize !== 0) {
      obj.fontSize = text_TextStyle_FontSizeToJSON(message.fontSize);
    }
    if (message.pointerLocation !== 0) {
      obj.pointerLocation = text_TextStyle_PointerLocationToJSON(message.pointerLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<Text_TextStyle>): Text_TextStyle {
    return Text_TextStyle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Text_TextStyle>): Text_TextStyle {
    const message = createBaseText_TextStyle();
    message.backgroundColor = object.backgroundColor ?? "";
    message.textColor = object.textColor ?? "";
    message.horizontalAlignment = object.horizontalAlignment ?? 0;
    message.verticalAlignment = object.verticalAlignment ?? 0;
    message.padding = object.padding ?? 0;
    message.fontSize = object.fontSize ?? 0;
    message.pointerLocation = object.pointerLocation ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
