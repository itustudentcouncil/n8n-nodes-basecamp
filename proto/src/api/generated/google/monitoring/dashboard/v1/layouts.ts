// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/dashboard/v1/layouts.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Widget } from "./widget.js";

export const protobufPackage = "google.monitoring.dashboard.v1";

/**
 * A basic layout divides the available space into vertical columns of equal
 * width and arranges a list of widgets using a row-first strategy.
 */
export interface GridLayout {
  /**
   * The number of columns into which the view's width is divided. If omitted
   * or set to zero, a system default will be used while rendering.
   */
  columns: Long;
  /** The informational elements that are arranged into the columns row-first. */
  widgets: Widget[];
}

/**
 * A mosaic layout divides the available space into a grid of blocks, and
 * overlays the grid with tiles. Unlike `GridLayout`, tiles may span multiple
 * grid blocks and can be placed at arbitrary locations in the grid.
 */
export interface MosaicLayout {
  /**
   * The number of columns in the mosaic grid. The number of columns must be
   * between 1 and 12, inclusive.
   */
  columns: number;
  /** The tiles to display. */
  tiles: MosaicLayout_Tile[];
}

/**
 * A single tile in the mosaic. The placement and size of the tile are
 * configurable.
 */
export interface MosaicLayout_Tile {
  /**
   * The zero-indexed position of the tile in grid blocks relative to the
   * left edge of the grid. Tiles must be contained within the specified
   * number of columns. `x_pos` cannot be negative.
   */
  xPos: number;
  /**
   * The zero-indexed position of the tile in grid blocks relative to the
   * top edge of the grid. `y_pos` cannot be negative.
   */
  yPos: number;
  /**
   * The width of the tile, measured in grid blocks. Tiles must have a
   * minimum width of 1.
   */
  width: number;
  /**
   * The height of the tile, measured in grid blocks. Tiles must have a
   * minimum height of 1.
   */
  height: number;
  /** The informational widget contained in the tile. For example an `XyChart`. */
  widget: Widget | undefined;
}

/**
 * A simplified layout that divides the available space into rows
 * and arranges a set of widgets horizontally in each row.
 */
export interface RowLayout {
  /** The rows of content to display. */
  rows: RowLayout_Row[];
}

/** Defines the layout properties and content for a row. */
export interface RowLayout_Row {
  /**
   * The relative weight of this row. The row weight is used to adjust the
   * height of rows on the screen (relative to peers). Greater the weight,
   * greater the height of the row on the screen. If omitted, a value
   * of 1 is used while rendering.
   */
  weight: Long;
  /** The display widgets arranged horizontally in this row. */
  widgets: Widget[];
}

/**
 * A simplified layout that divides the available space into vertical columns
 * and arranges a set of widgets vertically in each column.
 */
export interface ColumnLayout {
  /** The columns of content to display. */
  columns: ColumnLayout_Column[];
}

/** Defines the layout properties and content for a column. */
export interface ColumnLayout_Column {
  /**
   * The relative weight of this column. The column weight is used to adjust
   * the width of columns on the screen (relative to peers).
   * Greater the weight, greater the width of the column on the screen.
   * If omitted, a value of 1 is used while rendering.
   */
  weight: Long;
  /** The display widgets arranged vertically in this column. */
  widgets: Widget[];
}

function createBaseGridLayout(): GridLayout {
  return { columns: Long.ZERO, widgets: [] };
}

export const GridLayout: MessageFns<GridLayout> = {
  encode(message: GridLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.columns.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.columns.toString());
    }
    for (const v of message.widgets) {
      Widget.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.columns = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.widgets.push(Widget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridLayout {
    return {
      columns: isSet(object.columns) ? Long.fromValue(object.columns) : Long.ZERO,
      widgets: globalThis.Array.isArray(object?.widgets) ? object.widgets.map((e: any) => Widget.fromJSON(e)) : [],
    };
  },

  toJSON(message: GridLayout): unknown {
    const obj: any = {};
    if (!message.columns.equals(Long.ZERO)) {
      obj.columns = (message.columns || Long.ZERO).toString();
    }
    if (message.widgets?.length) {
      obj.widgets = message.widgets.map((e) => Widget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GridLayout>): GridLayout {
    return GridLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GridLayout>): GridLayout {
    const message = createBaseGridLayout();
    message.columns = (object.columns !== undefined && object.columns !== null)
      ? Long.fromValue(object.columns)
      : Long.ZERO;
    message.widgets = object.widgets?.map((e) => Widget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMosaicLayout(): MosaicLayout {
  return { columns: 0, tiles: [] };
}

export const MosaicLayout: MessageFns<MosaicLayout> = {
  encode(message: MosaicLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columns !== 0) {
      writer.uint32(8).int32(message.columns);
    }
    for (const v of message.tiles) {
      MosaicLayout_Tile.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MosaicLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMosaicLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.columns = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tiles.push(MosaicLayout_Tile.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MosaicLayout {
    return {
      columns: isSet(object.columns) ? globalThis.Number(object.columns) : 0,
      tiles: globalThis.Array.isArray(object?.tiles) ? object.tiles.map((e: any) => MosaicLayout_Tile.fromJSON(e)) : [],
    };
  },

  toJSON(message: MosaicLayout): unknown {
    const obj: any = {};
    if (message.columns !== 0) {
      obj.columns = Math.round(message.columns);
    }
    if (message.tiles?.length) {
      obj.tiles = message.tiles.map((e) => MosaicLayout_Tile.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MosaicLayout>): MosaicLayout {
    return MosaicLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MosaicLayout>): MosaicLayout {
    const message = createBaseMosaicLayout();
    message.columns = object.columns ?? 0;
    message.tiles = object.tiles?.map((e) => MosaicLayout_Tile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMosaicLayout_Tile(): MosaicLayout_Tile {
  return { xPos: 0, yPos: 0, width: 0, height: 0, widget: undefined };
}

export const MosaicLayout_Tile: MessageFns<MosaicLayout_Tile> = {
  encode(message: MosaicLayout_Tile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.xPos !== 0) {
      writer.uint32(8).int32(message.xPos);
    }
    if (message.yPos !== 0) {
      writer.uint32(16).int32(message.yPos);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    if (message.widget !== undefined) {
      Widget.encode(message.widget, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MosaicLayout_Tile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMosaicLayout_Tile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.xPos = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.yPos = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.widget = Widget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MosaicLayout_Tile {
    return {
      xPos: isSet(object.xPos) ? globalThis.Number(object.xPos) : 0,
      yPos: isSet(object.yPos) ? globalThis.Number(object.yPos) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      widget: isSet(object.widget) ? Widget.fromJSON(object.widget) : undefined,
    };
  },

  toJSON(message: MosaicLayout_Tile): unknown {
    const obj: any = {};
    if (message.xPos !== 0) {
      obj.xPos = Math.round(message.xPos);
    }
    if (message.yPos !== 0) {
      obj.yPos = Math.round(message.yPos);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.widget !== undefined) {
      obj.widget = Widget.toJSON(message.widget);
    }
    return obj;
  },

  create(base?: DeepPartial<MosaicLayout_Tile>): MosaicLayout_Tile {
    return MosaicLayout_Tile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MosaicLayout_Tile>): MosaicLayout_Tile {
    const message = createBaseMosaicLayout_Tile();
    message.xPos = object.xPos ?? 0;
    message.yPos = object.yPos ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.widget = (object.widget !== undefined && object.widget !== null)
      ? Widget.fromPartial(object.widget)
      : undefined;
    return message;
  },
};

function createBaseRowLayout(): RowLayout {
  return { rows: [] };
}

export const RowLayout: MessageFns<RowLayout> = {
  encode(message: RowLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      RowLayout_Row.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RowLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRowLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rows.push(RowLayout_Row.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RowLayout {
    return {
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => RowLayout_Row.fromJSON(e)) : [],
    };
  },

  toJSON(message: RowLayout): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => RowLayout_Row.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RowLayout>): RowLayout {
    return RowLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RowLayout>): RowLayout {
    const message = createBaseRowLayout();
    message.rows = object.rows?.map((e) => RowLayout_Row.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRowLayout_Row(): RowLayout_Row {
  return { weight: Long.ZERO, widgets: [] };
}

export const RowLayout_Row: MessageFns<RowLayout_Row> = {
  encode(message: RowLayout_Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.weight.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.weight.toString());
    }
    for (const v of message.widgets) {
      Widget.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RowLayout_Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRowLayout_Row();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weight = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.widgets.push(Widget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RowLayout_Row {
    return {
      weight: isSet(object.weight) ? Long.fromValue(object.weight) : Long.ZERO,
      widgets: globalThis.Array.isArray(object?.widgets) ? object.widgets.map((e: any) => Widget.fromJSON(e)) : [],
    };
  },

  toJSON(message: RowLayout_Row): unknown {
    const obj: any = {};
    if (!message.weight.equals(Long.ZERO)) {
      obj.weight = (message.weight || Long.ZERO).toString();
    }
    if (message.widgets?.length) {
      obj.widgets = message.widgets.map((e) => Widget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RowLayout_Row>): RowLayout_Row {
    return RowLayout_Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RowLayout_Row>): RowLayout_Row {
    const message = createBaseRowLayout_Row();
    message.weight = (object.weight !== undefined && object.weight !== null)
      ? Long.fromValue(object.weight)
      : Long.ZERO;
    message.widgets = object.widgets?.map((e) => Widget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnLayout(): ColumnLayout {
  return { columns: [] };
}

export const ColumnLayout: MessageFns<ColumnLayout> = {
  encode(message: ColumnLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      ColumnLayout_Column.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(ColumnLayout_Column.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnLayout {
    return {
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => ColumnLayout_Column.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ColumnLayout): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => ColumnLayout_Column.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnLayout>): ColumnLayout {
    return ColumnLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnLayout>): ColumnLayout {
    const message = createBaseColumnLayout();
    message.columns = object.columns?.map((e) => ColumnLayout_Column.fromPartial(e)) || [];
    return message;
  },
};

function createBaseColumnLayout_Column(): ColumnLayout_Column {
  return { weight: Long.ZERO, widgets: [] };
}

export const ColumnLayout_Column: MessageFns<ColumnLayout_Column> = {
  encode(message: ColumnLayout_Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.weight.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.weight.toString());
    }
    for (const v of message.widgets) {
      Widget.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnLayout_Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnLayout_Column();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weight = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.widgets.push(Widget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnLayout_Column {
    return {
      weight: isSet(object.weight) ? Long.fromValue(object.weight) : Long.ZERO,
      widgets: globalThis.Array.isArray(object?.widgets) ? object.widgets.map((e: any) => Widget.fromJSON(e)) : [],
    };
  },

  toJSON(message: ColumnLayout_Column): unknown {
    const obj: any = {};
    if (!message.weight.equals(Long.ZERO)) {
      obj.weight = (message.weight || Long.ZERO).toString();
    }
    if (message.widgets?.length) {
      obj.widgets = message.widgets.map((e) => Widget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnLayout_Column>): ColumnLayout_Column {
    return ColumnLayout_Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnLayout_Column>): ColumnLayout_Column {
    const message = createBaseColumnLayout_Column();
    message.weight = (object.weight !== undefined && object.weight !== null)
      ? Long.fromValue(object.weight)
      : Long.ZERO;
    message.widgets = object.widgets?.map((e) => Widget.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
