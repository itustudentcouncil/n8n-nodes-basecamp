// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/dashboard/v1/scorecard.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { SparkChartType, sparkChartTypeFromJSON, sparkChartTypeToJSON, Threshold, TimeSeriesQuery } from "./metrics.js";

export const protobufPackage = "google.monitoring.dashboard.v1";

/**
 * A widget showing the latest value of a metric, and how this value relates to
 * one or more thresholds.
 */
export interface Scorecard {
  /**
   * Required. Fields for querying time series data from the
   * Stackdriver metrics API.
   */
  timeSeriesQuery:
    | TimeSeriesQuery
    | undefined;
  /** Will cause the scorecard to show a gauge chart. */
  gaugeView?:
    | Scorecard_GaugeView
    | undefined;
  /** Will cause the scorecard to show a spark chart. */
  sparkChartView?:
    | Scorecard_SparkChartView
    | undefined;
  /**
   * Will cause the `Scorecard` to show only the value, with no indicator to
   * its value relative to its thresholds.
   */
  blankView?:
    | Empty
    | undefined;
  /**
   * The thresholds used to determine the state of the scorecard given the
   * time series' current value. For an actual value x, the scorecard is in a
   * danger state if x is less than or equal to a danger threshold that triggers
   * below, or greater than or equal to a danger threshold that triggers above.
   * Similarly, if x is above/below a warning threshold that triggers
   * above/below, then the scorecard is in a warning state - unless x also puts
   * it in a danger state. (Danger trumps warning.)
   *
   * As an example, consider a scorecard with the following four thresholds:
   *
   * ```
   * {
   *   value: 90,
   *   category: 'DANGER',
   *   trigger: 'ABOVE',
   * },
   * {
   *   value: 70,
   *   category: 'WARNING',
   *   trigger: 'ABOVE',
   * },
   * {
   *   value: 10,
   *   category: 'DANGER',
   *   trigger: 'BELOW',
   * },
   * {
   *   value: 20,
   *   category: 'WARNING',
   *   trigger: 'BELOW',
   * }
   * ```
   *
   * Then: values less than or equal to 10 would put the scorecard in a DANGER
   * state, values greater than 10 but less than or equal to 20 a WARNING state,
   * values strictly between 20 and 70 an OK state, values greater than or equal
   * to 70 but less than 90 a WARNING state, and values greater than or equal to
   * 90 a DANGER state.
   */
  thresholds: Threshold[];
}

/**
 * A gauge chart shows where the current value sits within a pre-defined
 * range. The upper and lower bounds should define the possible range of
 * values for the scorecard's query (inclusive).
 */
export interface Scorecard_GaugeView {
  /**
   * The lower bound for this gauge chart. The value of the chart should
   * always be greater than or equal to this.
   */
  lowerBound: number;
  /**
   * The upper bound for this gauge chart. The value of the chart should
   * always be less than or equal to this.
   */
  upperBound: number;
}

/**
 * A sparkChart is a small chart suitable for inclusion in a table-cell or
 * inline in text. This message contains the configuration for a sparkChart
 * to show up on a Scorecard, showing recent trends of the scorecard's
 * timeseries.
 */
export interface Scorecard_SparkChartView {
  /** Required. The type of sparkchart to show in this chartView. */
  sparkChartType: SparkChartType;
  /**
   * The lower bound on data point frequency in the chart implemented by
   * specifying the minimum alignment period to use in a time series query.
   * For example, if the data is published once every 10 minutes it would not
   * make sense to fetch and align data at one minute intervals. This field is
   * optional and exists only as a hint.
   */
  minAlignmentPeriod: Duration | undefined;
}

function createBaseScorecard(): Scorecard {
  return {
    timeSeriesQuery: undefined,
    gaugeView: undefined,
    sparkChartView: undefined,
    blankView: undefined,
    thresholds: [],
  };
}

export const Scorecard: MessageFns<Scorecard> = {
  encode(message: Scorecard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSeriesQuery !== undefined) {
      TimeSeriesQuery.encode(message.timeSeriesQuery, writer.uint32(10).fork()).join();
    }
    if (message.gaugeView !== undefined) {
      Scorecard_GaugeView.encode(message.gaugeView, writer.uint32(34).fork()).join();
    }
    if (message.sparkChartView !== undefined) {
      Scorecard_SparkChartView.encode(message.sparkChartView, writer.uint32(42).fork()).join();
    }
    if (message.blankView !== undefined) {
      Empty.encode(message.blankView, writer.uint32(58).fork()).join();
    }
    for (const v of message.thresholds) {
      Threshold.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scorecard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScorecard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSeriesQuery = TimeSeriesQuery.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gaugeView = Scorecard_GaugeView.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sparkChartView = Scorecard_SparkChartView.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blankView = Empty.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.thresholds.push(Threshold.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scorecard {
    return {
      timeSeriesQuery: isSet(object.timeSeriesQuery) ? TimeSeriesQuery.fromJSON(object.timeSeriesQuery) : undefined,
      gaugeView: isSet(object.gaugeView) ? Scorecard_GaugeView.fromJSON(object.gaugeView) : undefined,
      sparkChartView: isSet(object.sparkChartView)
        ? Scorecard_SparkChartView.fromJSON(object.sparkChartView)
        : undefined,
      blankView: isSet(object.blankView) ? Empty.fromJSON(object.blankView) : undefined,
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => Threshold.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Scorecard): unknown {
    const obj: any = {};
    if (message.timeSeriesQuery !== undefined) {
      obj.timeSeriesQuery = TimeSeriesQuery.toJSON(message.timeSeriesQuery);
    }
    if (message.gaugeView !== undefined) {
      obj.gaugeView = Scorecard_GaugeView.toJSON(message.gaugeView);
    }
    if (message.sparkChartView !== undefined) {
      obj.sparkChartView = Scorecard_SparkChartView.toJSON(message.sparkChartView);
    }
    if (message.blankView !== undefined) {
      obj.blankView = Empty.toJSON(message.blankView);
    }
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds.map((e) => Threshold.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Scorecard>): Scorecard {
    return Scorecard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scorecard>): Scorecard {
    const message = createBaseScorecard();
    message.timeSeriesQuery = (object.timeSeriesQuery !== undefined && object.timeSeriesQuery !== null)
      ? TimeSeriesQuery.fromPartial(object.timeSeriesQuery)
      : undefined;
    message.gaugeView = (object.gaugeView !== undefined && object.gaugeView !== null)
      ? Scorecard_GaugeView.fromPartial(object.gaugeView)
      : undefined;
    message.sparkChartView = (object.sparkChartView !== undefined && object.sparkChartView !== null)
      ? Scorecard_SparkChartView.fromPartial(object.sparkChartView)
      : undefined;
    message.blankView = (object.blankView !== undefined && object.blankView !== null)
      ? Empty.fromPartial(object.blankView)
      : undefined;
    message.thresholds = object.thresholds?.map((e) => Threshold.fromPartial(e)) || [];
    return message;
  },
};

function createBaseScorecard_GaugeView(): Scorecard_GaugeView {
  return { lowerBound: 0, upperBound: 0 };
}

export const Scorecard_GaugeView: MessageFns<Scorecard_GaugeView> = {
  encode(message: Scorecard_GaugeView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerBound !== 0) {
      writer.uint32(9).double(message.lowerBound);
    }
    if (message.upperBound !== 0) {
      writer.uint32(17).double(message.upperBound);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scorecard_GaugeView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScorecard_GaugeView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.lowerBound = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.upperBound = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scorecard_GaugeView {
    return {
      lowerBound: isSet(object.lowerBound) ? globalThis.Number(object.lowerBound) : 0,
      upperBound: isSet(object.upperBound) ? globalThis.Number(object.upperBound) : 0,
    };
  },

  toJSON(message: Scorecard_GaugeView): unknown {
    const obj: any = {};
    if (message.lowerBound !== 0) {
      obj.lowerBound = message.lowerBound;
    }
    if (message.upperBound !== 0) {
      obj.upperBound = message.upperBound;
    }
    return obj;
  },

  create(base?: DeepPartial<Scorecard_GaugeView>): Scorecard_GaugeView {
    return Scorecard_GaugeView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scorecard_GaugeView>): Scorecard_GaugeView {
    const message = createBaseScorecard_GaugeView();
    message.lowerBound = object.lowerBound ?? 0;
    message.upperBound = object.upperBound ?? 0;
    return message;
  },
};

function createBaseScorecard_SparkChartView(): Scorecard_SparkChartView {
  return { sparkChartType: 0, minAlignmentPeriod: undefined };
}

export const Scorecard_SparkChartView: MessageFns<Scorecard_SparkChartView> = {
  encode(message: Scorecard_SparkChartView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sparkChartType !== 0) {
      writer.uint32(8).int32(message.sparkChartType);
    }
    if (message.minAlignmentPeriod !== undefined) {
      Duration.encode(message.minAlignmentPeriod, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scorecard_SparkChartView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScorecard_SparkChartView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sparkChartType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minAlignmentPeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scorecard_SparkChartView {
    return {
      sparkChartType: isSet(object.sparkChartType) ? sparkChartTypeFromJSON(object.sparkChartType) : 0,
      minAlignmentPeriod: isSet(object.minAlignmentPeriod) ? Duration.fromJSON(object.minAlignmentPeriod) : undefined,
    };
  },

  toJSON(message: Scorecard_SparkChartView): unknown {
    const obj: any = {};
    if (message.sparkChartType !== 0) {
      obj.sparkChartType = sparkChartTypeToJSON(message.sparkChartType);
    }
    if (message.minAlignmentPeriod !== undefined) {
      obj.minAlignmentPeriod = Duration.toJSON(message.minAlignmentPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<Scorecard_SparkChartView>): Scorecard_SparkChartView {
    return Scorecard_SparkChartView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scorecard_SparkChartView>): Scorecard_SparkChartView {
    const message = createBaseScorecard_SparkChartView();
    message.sparkChartType = object.sparkChartType ?? 0;
    message.minAlignmentPeriod = (object.minAlignmentPeriod !== undefined && object.minAlignmentPeriod !== null)
      ? Duration.fromPartial(object.minAlignmentPeriod)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
