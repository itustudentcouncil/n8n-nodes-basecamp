// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/monitoring/dashboard/v1/xychart.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Threshold, TimeSeriesQuery } from "./metrics.js";

export const protobufPackage = "google.monitoring.dashboard.v1";

/** A chart that displays data on a 2D (X and Y axes) plane. */
export interface XyChart {
  /** Required. The data displayed in this chart. */
  dataSets: XyChart_DataSet[];
  /**
   * The duration used to display a comparison chart. A comparison chart
   * simultaneously shows values from two similar-length time periods
   * (e.g., week-over-week metrics).
   * The duration must be positive, and it can only be applied to charts with
   * data sets of LINE plot type.
   */
  timeshiftDuration:
    | Duration
    | undefined;
  /** Threshold lines drawn horizontally across the chart. */
  thresholds: Threshold[];
  /** The properties applied to the x-axis. */
  xAxis:
    | XyChart_Axis
    | undefined;
  /** The properties applied to the y-axis. */
  yAxis:
    | XyChart_Axis
    | undefined;
  /** The properties applied to the y2-axis. */
  y2Axis:
    | XyChart_Axis
    | undefined;
  /** Display options for the chart. */
  chartOptions: ChartOptions | undefined;
}

/** Groups a time series query definition with charting options. */
export interface XyChart_DataSet {
  /**
   * Required. Fields for querying time series data from the
   * Stackdriver metrics API.
   */
  timeSeriesQuery:
    | TimeSeriesQuery
    | undefined;
  /** How this data should be plotted on the chart. */
  plotType: XyChart_DataSet_PlotType;
  /**
   * A template string for naming `TimeSeries` in the resulting data set.
   * This should be a string with interpolations of the form `${label_name}`,
   * which will resolve to the label's value.
   */
  legendTemplate: string;
  /**
   * Optional. The lower bound on data point frequency for this data set,
   * implemented by specifying the minimum alignment period to use in a time
   * series query For example, if the data is published once every 10 minutes,
   * the `min_alignment_period` should be at least 10 minutes. It would not
   * make sense to fetch and align data at one minute intervals.
   */
  minAlignmentPeriod:
    | Duration
    | undefined;
  /** Optional. The target axis to use for plotting the metric. */
  targetAxis: XyChart_DataSet_TargetAxis;
}

/** The types of plotting strategies for data sets. */
export enum XyChart_DataSet_PlotType {
  /** PLOT_TYPE_UNSPECIFIED - Plot type is unspecified. The view will default to `LINE`. */
  PLOT_TYPE_UNSPECIFIED = 0,
  /** LINE - The data is plotted as a set of lines (one line per series). */
  LINE = 1,
  /**
   * STACKED_AREA - The data is plotted as a set of filled areas (one area per series),
   * with the areas stacked vertically (the base of each area is the top of
   * its predecessor, and the base of the first area is the x-axis). Since
   * the areas do not overlap, each is filled with a different opaque color.
   */
  STACKED_AREA = 2,
  /**
   * STACKED_BAR - The data is plotted as a set of rectangular boxes (one box per series),
   * with the boxes stacked vertically (the base of each box is the top of
   * its predecessor, and the base of the first box is the x-axis). Since
   * the boxes do not overlap, each is filled with a different opaque color.
   */
  STACKED_BAR = 3,
  /**
   * HEATMAP - The data is plotted as a heatmap. The series being plotted must have a
   * `DISTRIBUTION` value type. The value of each bucket in the distribution
   * is displayed as a color. This type is not currently available in the
   * Stackdriver Monitoring application.
   */
  HEATMAP = 4,
  UNRECOGNIZED = -1,
}

export function xyChart_DataSet_PlotTypeFromJSON(object: any): XyChart_DataSet_PlotType {
  switch (object) {
    case 0:
    case "PLOT_TYPE_UNSPECIFIED":
      return XyChart_DataSet_PlotType.PLOT_TYPE_UNSPECIFIED;
    case 1:
    case "LINE":
      return XyChart_DataSet_PlotType.LINE;
    case 2:
    case "STACKED_AREA":
      return XyChart_DataSet_PlotType.STACKED_AREA;
    case 3:
    case "STACKED_BAR":
      return XyChart_DataSet_PlotType.STACKED_BAR;
    case 4:
    case "HEATMAP":
      return XyChart_DataSet_PlotType.HEATMAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XyChart_DataSet_PlotType.UNRECOGNIZED;
  }
}

export function xyChart_DataSet_PlotTypeToJSON(object: XyChart_DataSet_PlotType): string {
  switch (object) {
    case XyChart_DataSet_PlotType.PLOT_TYPE_UNSPECIFIED:
      return "PLOT_TYPE_UNSPECIFIED";
    case XyChart_DataSet_PlotType.LINE:
      return "LINE";
    case XyChart_DataSet_PlotType.STACKED_AREA:
      return "STACKED_AREA";
    case XyChart_DataSet_PlotType.STACKED_BAR:
      return "STACKED_BAR";
    case XyChart_DataSet_PlotType.HEATMAP:
      return "HEATMAP";
    case XyChart_DataSet_PlotType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An axis identifier. */
export enum XyChart_DataSet_TargetAxis {
  /** TARGET_AXIS_UNSPECIFIED - The target axis was not specified. Defaults to Y1. */
  TARGET_AXIS_UNSPECIFIED = 0,
  /** Y1 - The y_axis (the right axis of chart). */
  Y1 = 1,
  /** Y2 - The y2_axis (the left axis of chart). */
  Y2 = 2,
  UNRECOGNIZED = -1,
}

export function xyChart_DataSet_TargetAxisFromJSON(object: any): XyChart_DataSet_TargetAxis {
  switch (object) {
    case 0:
    case "TARGET_AXIS_UNSPECIFIED":
      return XyChart_DataSet_TargetAxis.TARGET_AXIS_UNSPECIFIED;
    case 1:
    case "Y1":
      return XyChart_DataSet_TargetAxis.Y1;
    case 2:
    case "Y2":
      return XyChart_DataSet_TargetAxis.Y2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XyChart_DataSet_TargetAxis.UNRECOGNIZED;
  }
}

export function xyChart_DataSet_TargetAxisToJSON(object: XyChart_DataSet_TargetAxis): string {
  switch (object) {
    case XyChart_DataSet_TargetAxis.TARGET_AXIS_UNSPECIFIED:
      return "TARGET_AXIS_UNSPECIFIED";
    case XyChart_DataSet_TargetAxis.Y1:
      return "Y1";
    case XyChart_DataSet_TargetAxis.Y2:
      return "Y2";
    case XyChart_DataSet_TargetAxis.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A chart axis. */
export interface XyChart_Axis {
  /** The label of the axis. */
  label: string;
  /** The axis scale. By default, a linear scale is used. */
  scale: XyChart_Axis_Scale;
}

/** Types of scales used in axes. */
export enum XyChart_Axis_Scale {
  /** SCALE_UNSPECIFIED - Scale is unspecified. The view will default to `LINEAR`. */
  SCALE_UNSPECIFIED = 0,
  /** LINEAR - Linear scale. */
  LINEAR = 1,
  /** LOG10 - Logarithmic scale (base 10). */
  LOG10 = 2,
  UNRECOGNIZED = -1,
}

export function xyChart_Axis_ScaleFromJSON(object: any): XyChart_Axis_Scale {
  switch (object) {
    case 0:
    case "SCALE_UNSPECIFIED":
      return XyChart_Axis_Scale.SCALE_UNSPECIFIED;
    case 1:
    case "LINEAR":
      return XyChart_Axis_Scale.LINEAR;
    case 2:
    case "LOG10":
      return XyChart_Axis_Scale.LOG10;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XyChart_Axis_Scale.UNRECOGNIZED;
  }
}

export function xyChart_Axis_ScaleToJSON(object: XyChart_Axis_Scale): string {
  switch (object) {
    case XyChart_Axis_Scale.SCALE_UNSPECIFIED:
      return "SCALE_UNSPECIFIED";
    case XyChart_Axis_Scale.LINEAR:
      return "LINEAR";
    case XyChart_Axis_Scale.LOG10:
      return "LOG10";
    case XyChart_Axis_Scale.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Options to control visual rendering of a chart. */
export interface ChartOptions {
  /** The chart mode. */
  mode: ChartOptions_Mode;
}

/** Chart mode options. */
export enum ChartOptions_Mode {
  /** MODE_UNSPECIFIED - Mode is unspecified. The view will default to `COLOR`. */
  MODE_UNSPECIFIED = 0,
  /**
   * COLOR - The chart distinguishes data series using different color. Line
   * colors may get reused when there are many lines in the chart.
   */
  COLOR = 1,
  /**
   * X_RAY - The chart uses the Stackdriver x-ray mode, in which each
   * data set is plotted using the same semi-transparent color.
   */
  X_RAY = 2,
  /**
   * STATS - The chart displays statistics such as average, median, 95th percentile,
   * and more.
   */
  STATS = 3,
  UNRECOGNIZED = -1,
}

export function chartOptions_ModeFromJSON(object: any): ChartOptions_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return ChartOptions_Mode.MODE_UNSPECIFIED;
    case 1:
    case "COLOR":
      return ChartOptions_Mode.COLOR;
    case 2:
    case "X_RAY":
      return ChartOptions_Mode.X_RAY;
    case 3:
    case "STATS":
      return ChartOptions_Mode.STATS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChartOptions_Mode.UNRECOGNIZED;
  }
}

export function chartOptions_ModeToJSON(object: ChartOptions_Mode): string {
  switch (object) {
    case ChartOptions_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case ChartOptions_Mode.COLOR:
      return "COLOR";
    case ChartOptions_Mode.X_RAY:
      return "X_RAY";
    case ChartOptions_Mode.STATS:
      return "STATS";
    case ChartOptions_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseXyChart(): XyChart {
  return {
    dataSets: [],
    timeshiftDuration: undefined,
    thresholds: [],
    xAxis: undefined,
    yAxis: undefined,
    y2Axis: undefined,
    chartOptions: undefined,
  };
}

export const XyChart: MessageFns<XyChart> = {
  encode(message: XyChart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSets) {
      XyChart_DataSet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.timeshiftDuration !== undefined) {
      Duration.encode(message.timeshiftDuration, writer.uint32(34).fork()).join();
    }
    for (const v of message.thresholds) {
      Threshold.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.xAxis !== undefined) {
      XyChart_Axis.encode(message.xAxis, writer.uint32(50).fork()).join();
    }
    if (message.yAxis !== undefined) {
      XyChart_Axis.encode(message.yAxis, writer.uint32(58).fork()).join();
    }
    if (message.y2Axis !== undefined) {
      XyChart_Axis.encode(message.y2Axis, writer.uint32(74).fork()).join();
    }
    if (message.chartOptions !== undefined) {
      ChartOptions.encode(message.chartOptions, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XyChart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXyChart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSets.push(XyChart_DataSet.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeshiftDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.thresholds.push(Threshold.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.xAxis = XyChart_Axis.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.yAxis = XyChart_Axis.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.y2Axis = XyChart_Axis.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.chartOptions = ChartOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XyChart {
    return {
      dataSets: globalThis.Array.isArray(object?.dataSets)
        ? object.dataSets.map((e: any) => XyChart_DataSet.fromJSON(e))
        : [],
      timeshiftDuration: isSet(object.timeshiftDuration) ? Duration.fromJSON(object.timeshiftDuration) : undefined,
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => Threshold.fromJSON(e))
        : [],
      xAxis: isSet(object.xAxis) ? XyChart_Axis.fromJSON(object.xAxis) : undefined,
      yAxis: isSet(object.yAxis) ? XyChart_Axis.fromJSON(object.yAxis) : undefined,
      y2Axis: isSet(object.y2Axis) ? XyChart_Axis.fromJSON(object.y2Axis) : undefined,
      chartOptions: isSet(object.chartOptions) ? ChartOptions.fromJSON(object.chartOptions) : undefined,
    };
  },

  toJSON(message: XyChart): unknown {
    const obj: any = {};
    if (message.dataSets?.length) {
      obj.dataSets = message.dataSets.map((e) => XyChart_DataSet.toJSON(e));
    }
    if (message.timeshiftDuration !== undefined) {
      obj.timeshiftDuration = Duration.toJSON(message.timeshiftDuration);
    }
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds.map((e) => Threshold.toJSON(e));
    }
    if (message.xAxis !== undefined) {
      obj.xAxis = XyChart_Axis.toJSON(message.xAxis);
    }
    if (message.yAxis !== undefined) {
      obj.yAxis = XyChart_Axis.toJSON(message.yAxis);
    }
    if (message.y2Axis !== undefined) {
      obj.y2Axis = XyChart_Axis.toJSON(message.y2Axis);
    }
    if (message.chartOptions !== undefined) {
      obj.chartOptions = ChartOptions.toJSON(message.chartOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<XyChart>): XyChart {
    return XyChart.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XyChart>): XyChart {
    const message = createBaseXyChart();
    message.dataSets = object.dataSets?.map((e) => XyChart_DataSet.fromPartial(e)) || [];
    message.timeshiftDuration = (object.timeshiftDuration !== undefined && object.timeshiftDuration !== null)
      ? Duration.fromPartial(object.timeshiftDuration)
      : undefined;
    message.thresholds = object.thresholds?.map((e) => Threshold.fromPartial(e)) || [];
    message.xAxis = (object.xAxis !== undefined && object.xAxis !== null)
      ? XyChart_Axis.fromPartial(object.xAxis)
      : undefined;
    message.yAxis = (object.yAxis !== undefined && object.yAxis !== null)
      ? XyChart_Axis.fromPartial(object.yAxis)
      : undefined;
    message.y2Axis = (object.y2Axis !== undefined && object.y2Axis !== null)
      ? XyChart_Axis.fromPartial(object.y2Axis)
      : undefined;
    message.chartOptions = (object.chartOptions !== undefined && object.chartOptions !== null)
      ? ChartOptions.fromPartial(object.chartOptions)
      : undefined;
    return message;
  },
};

function createBaseXyChart_DataSet(): XyChart_DataSet {
  return { timeSeriesQuery: undefined, plotType: 0, legendTemplate: "", minAlignmentPeriod: undefined, targetAxis: 0 };
}

export const XyChart_DataSet: MessageFns<XyChart_DataSet> = {
  encode(message: XyChart_DataSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeSeriesQuery !== undefined) {
      TimeSeriesQuery.encode(message.timeSeriesQuery, writer.uint32(10).fork()).join();
    }
    if (message.plotType !== 0) {
      writer.uint32(16).int32(message.plotType);
    }
    if (message.legendTemplate !== "") {
      writer.uint32(26).string(message.legendTemplate);
    }
    if (message.minAlignmentPeriod !== undefined) {
      Duration.encode(message.minAlignmentPeriod, writer.uint32(34).fork()).join();
    }
    if (message.targetAxis !== 0) {
      writer.uint32(40).int32(message.targetAxis);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XyChart_DataSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXyChart_DataSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeSeriesQuery = TimeSeriesQuery.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.plotType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.legendTemplate = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minAlignmentPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.targetAxis = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XyChart_DataSet {
    return {
      timeSeriesQuery: isSet(object.timeSeriesQuery) ? TimeSeriesQuery.fromJSON(object.timeSeriesQuery) : undefined,
      plotType: isSet(object.plotType) ? xyChart_DataSet_PlotTypeFromJSON(object.plotType) : 0,
      legendTemplate: isSet(object.legendTemplate) ? globalThis.String(object.legendTemplate) : "",
      minAlignmentPeriod: isSet(object.minAlignmentPeriod) ? Duration.fromJSON(object.minAlignmentPeriod) : undefined,
      targetAxis: isSet(object.targetAxis) ? xyChart_DataSet_TargetAxisFromJSON(object.targetAxis) : 0,
    };
  },

  toJSON(message: XyChart_DataSet): unknown {
    const obj: any = {};
    if (message.timeSeriesQuery !== undefined) {
      obj.timeSeriesQuery = TimeSeriesQuery.toJSON(message.timeSeriesQuery);
    }
    if (message.plotType !== 0) {
      obj.plotType = xyChart_DataSet_PlotTypeToJSON(message.plotType);
    }
    if (message.legendTemplate !== "") {
      obj.legendTemplate = message.legendTemplate;
    }
    if (message.minAlignmentPeriod !== undefined) {
      obj.minAlignmentPeriod = Duration.toJSON(message.minAlignmentPeriod);
    }
    if (message.targetAxis !== 0) {
      obj.targetAxis = xyChart_DataSet_TargetAxisToJSON(message.targetAxis);
    }
    return obj;
  },

  create(base?: DeepPartial<XyChart_DataSet>): XyChart_DataSet {
    return XyChart_DataSet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XyChart_DataSet>): XyChart_DataSet {
    const message = createBaseXyChart_DataSet();
    message.timeSeriesQuery = (object.timeSeriesQuery !== undefined && object.timeSeriesQuery !== null)
      ? TimeSeriesQuery.fromPartial(object.timeSeriesQuery)
      : undefined;
    message.plotType = object.plotType ?? 0;
    message.legendTemplate = object.legendTemplate ?? "";
    message.minAlignmentPeriod = (object.minAlignmentPeriod !== undefined && object.minAlignmentPeriod !== null)
      ? Duration.fromPartial(object.minAlignmentPeriod)
      : undefined;
    message.targetAxis = object.targetAxis ?? 0;
    return message;
  },
};

function createBaseXyChart_Axis(): XyChart_Axis {
  return { label: "", scale: 0 };
}

export const XyChart_Axis: MessageFns<XyChart_Axis> = {
  encode(message: XyChart_Axis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.scale !== 0) {
      writer.uint32(16).int32(message.scale);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): XyChart_Axis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXyChart_Axis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scale = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XyChart_Axis {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      scale: isSet(object.scale) ? xyChart_Axis_ScaleFromJSON(object.scale) : 0,
    };
  },

  toJSON(message: XyChart_Axis): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.scale !== 0) {
      obj.scale = xyChart_Axis_ScaleToJSON(message.scale);
    }
    return obj;
  },

  create(base?: DeepPartial<XyChart_Axis>): XyChart_Axis {
    return XyChart_Axis.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XyChart_Axis>): XyChart_Axis {
    const message = createBaseXyChart_Axis();
    message.label = object.label ?? "";
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseChartOptions(): ChartOptions {
  return { mode: 0 };
}

export const ChartOptions: MessageFns<ChartOptions> = {
  encode(message: ChartOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChartOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChartOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChartOptions {
    return { mode: isSet(object.mode) ? chartOptions_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: ChartOptions): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = chartOptions_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<ChartOptions>): ChartOptions {
    return ChartOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChartOptions>): ChartOptions {
    const message = createBaseChartOptions();
    message.mode = object.mode ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
