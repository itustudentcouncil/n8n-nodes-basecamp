// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/container/v1/cluster_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../protobuf/duration.js";
import { Empty } from "../../protobuf/empty.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { BoolValue } from "../../protobuf/wrappers.js";
import { Code, codeFromJSON, codeToJSON } from "../../rpc/code.js";
import { Status } from "../../rpc/status.js";

export const protobufPackage = "google.container.v1";

/**
 * PrivateIPv6GoogleAccess controls whether and how the pods can communicate
 * with Google Services through gRPC over IPv6.
 */
export enum PrivateIPv6GoogleAccess {
  /** PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED - Default value. Same as DISABLED */
  PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED = 0,
  /** PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED - No private access to or from Google Services */
  PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED = 1,
  /** PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE - Enables private IPv6 access to Google Services from GKE */
  PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE = 2,
  /** PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL - Enables private IPv6 access to and from Google Services */
  PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL = 3,
  UNRECOGNIZED = -1,
}

export function privateIPv6GoogleAccessFromJSON(object: any): PrivateIPv6GoogleAccess {
  switch (object) {
    case 0:
    case "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED":
      return PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED;
    case 1:
    case "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED":
      return PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED;
    case 2:
    case "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE":
      return PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE;
    case 3:
    case "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL":
      return PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateIPv6GoogleAccess.UNRECOGNIZED;
  }
}

export function privateIPv6GoogleAccessToJSON(object: PrivateIPv6GoogleAccess): string {
  switch (object) {
    case PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED:
      return "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED";
    case PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED:
      return "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED";
    case PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE:
      return "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE";
    case PrivateIPv6GoogleAccess.PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL:
      return "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL";
    case PrivateIPv6GoogleAccess.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * UpgradeResourceType is the resource type that is upgrading. It is used
 * in upgrade notifications.
 */
export enum UpgradeResourceType {
  /** UPGRADE_RESOURCE_TYPE_UNSPECIFIED - Default value. This shouldn't be used. */
  UPGRADE_RESOURCE_TYPE_UNSPECIFIED = 0,
  /** MASTER - Master / control plane */
  MASTER = 1,
  /** NODE_POOL - Node pool */
  NODE_POOL = 2,
  UNRECOGNIZED = -1,
}

export function upgradeResourceTypeFromJSON(object: any): UpgradeResourceType {
  switch (object) {
    case 0:
    case "UPGRADE_RESOURCE_TYPE_UNSPECIFIED":
      return UpgradeResourceType.UPGRADE_RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "MASTER":
      return UpgradeResourceType.MASTER;
    case 2:
    case "NODE_POOL":
      return UpgradeResourceType.NODE_POOL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpgradeResourceType.UNRECOGNIZED;
  }
}

export function upgradeResourceTypeToJSON(object: UpgradeResourceType): string {
  switch (object) {
    case UpgradeResourceType.UPGRADE_RESOURCE_TYPE_UNSPECIFIED:
      return "UPGRADE_RESOURCE_TYPE_UNSPECIFIED";
    case UpgradeResourceType.MASTER:
      return "MASTER";
    case UpgradeResourceType.NODE_POOL:
      return "NODE_POOL";
    case UpgradeResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The datapath provider selects the implementation of the Kubernetes networking
 * model for service resolution and network policy enforcement.
 */
export enum DatapathProvider {
  /** DATAPATH_PROVIDER_UNSPECIFIED - Default value. */
  DATAPATH_PROVIDER_UNSPECIFIED = 0,
  /** LEGACY_DATAPATH - Use the IPTables implementation based on kube-proxy. */
  LEGACY_DATAPATH = 1,
  /**
   * ADVANCED_DATAPATH - Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
   * Dataplane V2
   * documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
   * for more.
   */
  ADVANCED_DATAPATH = 2,
  UNRECOGNIZED = -1,
}

export function datapathProviderFromJSON(object: any): DatapathProvider {
  switch (object) {
    case 0:
    case "DATAPATH_PROVIDER_UNSPECIFIED":
      return DatapathProvider.DATAPATH_PROVIDER_UNSPECIFIED;
    case 1:
    case "LEGACY_DATAPATH":
      return DatapathProvider.LEGACY_DATAPATH;
    case 2:
    case "ADVANCED_DATAPATH":
      return DatapathProvider.ADVANCED_DATAPATH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatapathProvider.UNRECOGNIZED;
  }
}

export function datapathProviderToJSON(object: DatapathProvider): string {
  switch (object) {
    case DatapathProvider.DATAPATH_PROVIDER_UNSPECIFIED:
      return "DATAPATH_PROVIDER_UNSPECIFIED";
    case DatapathProvider.LEGACY_DATAPATH:
      return "LEGACY_DATAPATH";
    case DatapathProvider.ADVANCED_DATAPATH:
      return "ADVANCED_DATAPATH";
    case DatapathProvider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Strategy used for node pool update. */
export enum NodePoolUpdateStrategy {
  /**
   * NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED - Default value if unset. GKE internally defaults the update strategy to
   * SURGE for unspecified strategies.
   */
  NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED = 0,
  /** BLUE_GREEN - blue-green upgrade. */
  BLUE_GREEN = 2,
  /**
   * SURGE - SURGE is the traditional way of upgrade a node pool.
   * max_surge and max_unavailable determines the level of upgrade parallelism.
   */
  SURGE = 3,
  UNRECOGNIZED = -1,
}

export function nodePoolUpdateStrategyFromJSON(object: any): NodePoolUpdateStrategy {
  switch (object) {
    case 0:
    case "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED":
      return NodePoolUpdateStrategy.NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED;
    case 2:
    case "BLUE_GREEN":
      return NodePoolUpdateStrategy.BLUE_GREEN;
    case 3:
    case "SURGE":
      return NodePoolUpdateStrategy.SURGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePoolUpdateStrategy.UNRECOGNIZED;
  }
}

export function nodePoolUpdateStrategyToJSON(object: NodePoolUpdateStrategy): string {
  switch (object) {
    case NodePoolUpdateStrategy.NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED:
      return "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED";
    case NodePoolUpdateStrategy.BLUE_GREEN:
      return "BLUE_GREEN";
    case NodePoolUpdateStrategy.SURGE:
      return "SURGE";
    case NodePoolUpdateStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for IP stack type */
export enum StackType {
  /** STACK_TYPE_UNSPECIFIED - Default value, will be defaulted as IPV4 only */
  STACK_TYPE_UNSPECIFIED = 0,
  /** IPV4 - Cluster is IPV4 only */
  IPV4 = 1,
  /** IPV4_IPV6 - Cluster can use both IPv4 and IPv6 */
  IPV4_IPV6 = 2,
  UNRECOGNIZED = -1,
}

export function stackTypeFromJSON(object: any): StackType {
  switch (object) {
    case 0:
    case "STACK_TYPE_UNSPECIFIED":
      return StackType.STACK_TYPE_UNSPECIFIED;
    case 1:
    case "IPV4":
      return StackType.IPV4;
    case 2:
    case "IPV4_IPV6":
      return StackType.IPV4_IPV6;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StackType.UNRECOGNIZED;
  }
}

export function stackTypeToJSON(object: StackType): string {
  switch (object) {
    case StackType.STACK_TYPE_UNSPECIFIED:
      return "STACK_TYPE_UNSPECIFIED";
    case StackType.IPV4:
      return "IPV4";
    case StackType.IPV4_IPV6:
      return "IPV4_IPV6";
    case StackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible values for IPv6 access type */
export enum IPv6AccessType {
  /** IPV6_ACCESS_TYPE_UNSPECIFIED - Default value, will be defaulted as type external. */
  IPV6_ACCESS_TYPE_UNSPECIFIED = 0,
  /** INTERNAL - Access type internal (all v6 addresses are internal IPs) */
  INTERNAL = 1,
  /** EXTERNAL - Access type external (all v6 addresses are external IPs) */
  EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function iPv6AccessTypeFromJSON(object: any): IPv6AccessType {
  switch (object) {
    case 0:
    case "IPV6_ACCESS_TYPE_UNSPECIFIED":
      return IPv6AccessType.IPV6_ACCESS_TYPE_UNSPECIFIED;
    case 1:
    case "INTERNAL":
      return IPv6AccessType.INTERNAL;
    case 2:
    case "EXTERNAL":
      return IPv6AccessType.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IPv6AccessType.UNRECOGNIZED;
  }
}

export function iPv6AccessTypeToJSON(object: IPv6AccessType): string {
  switch (object) {
    case IPv6AccessType.IPV6_ACCESS_TYPE_UNSPECIFIED:
      return "IPV6_ACCESS_TYPE_UNSPECIFIED";
    case IPv6AccessType.INTERNAL:
      return "INTERNAL";
    case IPv6AccessType.EXTERNAL:
      return "EXTERNAL";
    case IPv6AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Options for in-transit encryption. */
export enum InTransitEncryptionConfig {
  /**
   * IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED - Unspecified, will be inferred as default -
   * IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
   */
  IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED = 0,
  /** IN_TRANSIT_ENCRYPTION_DISABLED - In-transit encryption is disabled. */
  IN_TRANSIT_ENCRYPTION_DISABLED = 1,
  /** IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT - Data in-transit is encrypted using inter-node transparent encryption. */
  IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT = 2,
  UNRECOGNIZED = -1,
}

export function inTransitEncryptionConfigFromJSON(object: any): InTransitEncryptionConfig {
  switch (object) {
    case 0:
    case "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED":
      return InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED;
    case 1:
    case "IN_TRANSIT_ENCRYPTION_DISABLED":
      return InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_DISABLED;
    case 2:
    case "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT":
      return InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InTransitEncryptionConfig.UNRECOGNIZED;
  }
}

export function inTransitEncryptionConfigToJSON(object: InTransitEncryptionConfig): string {
  switch (object) {
    case InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED:
      return "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED";
    case InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_DISABLED:
      return "IN_TRANSIT_ENCRYPTION_DISABLED";
    case InTransitEncryptionConfig.IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT:
      return "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT";
    case InTransitEncryptionConfig.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Parameters that can be configured on Linux nodes. */
export interface LinuxNodeConfig {
  /**
   * The Linux kernel parameters to be applied to the nodes and all pods running
   * on the nodes.
   *
   * The following parameters are supported.
   *
   * net.core.busy_poll
   * net.core.busy_read
   * net.core.netdev_max_backlog
   * net.core.rmem_max
   * net.core.wmem_default
   * net.core.wmem_max
   * net.core.optmem_max
   * net.core.somaxconn
   * net.ipv4.tcp_rmem
   * net.ipv4.tcp_wmem
   * net.ipv4.tcp_tw_reuse
   */
  sysctls: { [key: string]: string };
  /** cgroup_mode specifies the cgroup mode to be used on the node. */
  cgroupMode: LinuxNodeConfig_CgroupMode;
  /** Optional. Amounts for 2M and 1G hugepages */
  hugepages?: LinuxNodeConfig_HugepagesConfig | undefined;
}

/** Possible cgroup modes that can be used. */
export enum LinuxNodeConfig_CgroupMode {
  /**
   * CGROUP_MODE_UNSPECIFIED - CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
   * The default for the GKE node OS image will be used.
   */
  CGROUP_MODE_UNSPECIFIED = 0,
  /**
   * CGROUP_MODE_V1 - CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
   * the node image.
   */
  CGROUP_MODE_V1 = 1,
  /**
   * CGROUP_MODE_V2 - CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
   * the node image.
   */
  CGROUP_MODE_V2 = 2,
  UNRECOGNIZED = -1,
}

export function linuxNodeConfig_CgroupModeFromJSON(object: any): LinuxNodeConfig_CgroupMode {
  switch (object) {
    case 0:
    case "CGROUP_MODE_UNSPECIFIED":
      return LinuxNodeConfig_CgroupMode.CGROUP_MODE_UNSPECIFIED;
    case 1:
    case "CGROUP_MODE_V1":
      return LinuxNodeConfig_CgroupMode.CGROUP_MODE_V1;
    case 2:
    case "CGROUP_MODE_V2":
      return LinuxNodeConfig_CgroupMode.CGROUP_MODE_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LinuxNodeConfig_CgroupMode.UNRECOGNIZED;
  }
}

export function linuxNodeConfig_CgroupModeToJSON(object: LinuxNodeConfig_CgroupMode): string {
  switch (object) {
    case LinuxNodeConfig_CgroupMode.CGROUP_MODE_UNSPECIFIED:
      return "CGROUP_MODE_UNSPECIFIED";
    case LinuxNodeConfig_CgroupMode.CGROUP_MODE_V1:
      return "CGROUP_MODE_V1";
    case LinuxNodeConfig_CgroupMode.CGROUP_MODE_V2:
      return "CGROUP_MODE_V2";
    case LinuxNodeConfig_CgroupMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Hugepages amount in both 2m and 1g size */
export interface LinuxNodeConfig_HugepagesConfig {
  /** Optional. Amount of 2M hugepages */
  hugepageSize2m?:
    | number
    | undefined;
  /** Optional. Amount of 1G hugepages */
  hugepageSize1g?: number | undefined;
}

export interface LinuxNodeConfig_SysctlsEntry {
  key: string;
  value: string;
}

/**
 * Parameters that can be configured on Windows nodes.
 * Windows Node Config that define the parameters that will be used to
 * configure the Windows node pool settings
 */
export interface WindowsNodeConfig {
  /** OSVersion specifies the Windows node config to be used on the node */
  osVersion: WindowsNodeConfig_OSVersion;
}

/** Possible OS version that can be used. */
export enum WindowsNodeConfig_OSVersion {
  /** OS_VERSION_UNSPECIFIED - When OSVersion is not specified */
  OS_VERSION_UNSPECIFIED = 0,
  /** OS_VERSION_LTSC2019 - LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image */
  OS_VERSION_LTSC2019 = 1,
  /** OS_VERSION_LTSC2022 - LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image */
  OS_VERSION_LTSC2022 = 2,
  UNRECOGNIZED = -1,
}

export function windowsNodeConfig_OSVersionFromJSON(object: any): WindowsNodeConfig_OSVersion {
  switch (object) {
    case 0:
    case "OS_VERSION_UNSPECIFIED":
      return WindowsNodeConfig_OSVersion.OS_VERSION_UNSPECIFIED;
    case 1:
    case "OS_VERSION_LTSC2019":
      return WindowsNodeConfig_OSVersion.OS_VERSION_LTSC2019;
    case 2:
    case "OS_VERSION_LTSC2022":
      return WindowsNodeConfig_OSVersion.OS_VERSION_LTSC2022;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowsNodeConfig_OSVersion.UNRECOGNIZED;
  }
}

export function windowsNodeConfig_OSVersionToJSON(object: WindowsNodeConfig_OSVersion): string {
  switch (object) {
    case WindowsNodeConfig_OSVersion.OS_VERSION_UNSPECIFIED:
      return "OS_VERSION_UNSPECIFIED";
    case WindowsNodeConfig_OSVersion.OS_VERSION_LTSC2019:
      return "OS_VERSION_LTSC2019";
    case WindowsNodeConfig_OSVersion.OS_VERSION_LTSC2022:
      return "OS_VERSION_LTSC2022";
    case WindowsNodeConfig_OSVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Node kubelet configs. */
export interface NodeKubeletConfig {
  /**
   * Control the CPU management policy on the node.
   * See
   * https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/
   *
   * The following values are allowed.
   * * "none": the default, which represents the existing scheduling behavior.
   * * "static": allows pods with certain resource characteristics to be granted
   * increased CPU affinity and exclusivity on the node.
   * The default value is 'none' if unspecified.
   */
  cpuManagerPolicy: string;
  /**
   * Enable CPU CFS quota enforcement for containers that specify CPU limits.
   *
   * This option is enabled by default which makes kubelet use CFS quota
   * (https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt) to
   * enforce container CPU limits. Otherwise, CPU limits will not be enforced at
   * all.
   *
   * Disable this option to mitigate CPU throttling problems while still having
   * your pods to be in Guaranteed QoS class by specifying the CPU limits.
   *
   * The default value is 'true' if unspecified.
   */
  cpuCfsQuota:
    | boolean
    | undefined;
  /**
   * Set the CPU CFS quota period value 'cpu.cfs_period_us'.
   *
   * The string must be a sequence of decimal numbers, each with optional
   * fraction and a unit suffix, such as "300ms".
   * Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
   * The value must be a positive duration.
   */
  cpuCfsQuotaPeriod: string;
  /**
   * Set the Pod PID limits. See
   * https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits
   *
   * Controls the maximum number of processes allowed to run in a pod. The value
   * must be greater than or equal to 1024 and less than 4194304.
   */
  podPidsLimit: Long;
  /** Enable or disable Kubelet read only port. */
  insecureKubeletReadonlyPortEnabled?: boolean | undefined;
}

/**
 * Parameters that describe the nodes in a cluster.
 *
 * GKE Autopilot clusters do not
 * recognize parameters in `NodeConfig`. Use
 * [AutoprovisioningNodePoolDefaults][google.container.v1.AutoprovisioningNodePoolDefaults]
 * instead.
 */
export interface NodeConfig {
  /**
   * The name of a Google Compute Engine [machine
   * type](https://cloud.google.com/compute/docs/machine-types)
   *
   * If unspecified, the default machine type is `e2-medium`.
   */
  machineType: string;
  /**
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   *
   * If unspecified, the default disk size is 100GB.
   */
  diskSizeGb: number;
  /**
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   *
   * The following scopes are recommended, but not required, and by default are
   * not included:
   *
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container
   * Registry](https://cloud.google.com/container-registry/)).
   *
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   */
  oauthScopes: string[];
  /**
   * The Google Cloud Platform Service Account to be used by the node VMs.
   * Specify the email address of the Service Account; otherwise, if no Service
   * Account is specified, the "default" service account is used.
   */
  serviceAccount: string;
  /**
   * The metadata key/value pairs assigned to instances in the cluster.
   *
   * Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the reserved keys:
   *
   *  - "cluster-location"
   *  - "cluster-name"
   *  - "cluster-uid"
   *  - "configure-sh"
   *  - "containerd-configure-sh"
   *  - "enable-os-login"
   *  - "gci-ensure-gke-docker"
   *  - "gci-metrics-enabled"
   *  - "gci-update-strategy"
   *  - "instance-template"
   *  - "kube-env"
   *  - "startup-script"
   *  - "user-data"
   *  - "disable-address-manager"
   *  - "windows-startup-script-ps1"
   *  - "common-psm1"
   *  - "k8s-node-setup-psm1"
   *  - "install-ssh-psm1"
   *  - "user-profile-psm1"
   *
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   *
   * The total size of all keys and values must be less than 512 KB.
   */
  metadata: { [key: string]: string };
  /**
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used. Please see
   * https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
   * available image types.
   */
  imageType: string;
  /**
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
   */
  labels: { [key: string]: string };
  /**
   * The number of local SSD disks to be attached to the node.
   *
   * The limit for this value is dependent upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd
   * for more information.
   */
  localSsdCount: number;
  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   */
  tags: string[];
  /**
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * information about preemptible VM instances.
   */
  preemptible: boolean;
  /**
   * A list of hardware accelerators to be attached to each node.
   * See https://cloud.google.com/compute/docs/gpus for more information about
   * support for GPUs.
   */
  accelerators: AcceleratorConfig[];
  /**
   * Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
   * 'pd-balanced')
   *
   * If unspecified, the default disk type is 'pd-standard'
   */
  diskType: string;
  /**
   * Minimum CPU platform to be used by this instance. The instance may be
   * scheduled on the specified or newer CPU platform. Applicable values are the
   * friendly names of CPU platforms, such as
   * `minCpuPlatform: "Intel Haswell"` or
   * `minCpuPlatform: "Intel Sandy Bridge"`. For more
   * information, read [how to specify min CPU
   * platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
   */
  minCpuPlatform: string;
  /** The workload metadata configuration for this node. */
  workloadMetadataConfig:
    | WorkloadMetadataConfig
    | undefined;
  /**
   * List of kubernetes taints to be applied to each node.
   *
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
   */
  taints: NodeTaint[];
  /** Sandbox configuration for this node. */
  sandboxConfig:
    | SandboxConfig
    | undefined;
  /**
   * Setting this field will assign instances of this
   * pool to run on the specified node group. This is useful for running
   * workloads on [sole tenant
   * nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
   */
  nodeGroup: string;
  /**
   * The optional reservation affinity. Setting this field will apply
   * the specified [Zonal Compute
   * Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
   * to this node pool.
   */
  reservationAffinity:
    | ReservationAffinity
    | undefined;
  /** Shielded Instance options. */
  shieldedInstanceConfig:
    | ShieldedInstanceConfig
    | undefined;
  /** Parameters that can be configured on Linux nodes. */
  linuxNodeConfig:
    | LinuxNodeConfig
    | undefined;
  /** Node kubelet configs. */
  kubeletConfig:
    | NodeKubeletConfig
    | undefined;
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached
   * to each node in the node pool. This should be of the form
   * projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
   * For more information about protecting resources with Cloud KMS Keys please
   * see:
   * https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   */
  bootDiskKmsKey: string;
  /** Google Container File System (image streaming) configs. */
  gcfsConfig:
    | GcfsConfig
    | undefined;
  /** Advanced features for the Compute Engine VM. */
  advancedMachineFeatures:
    | AdvancedMachineFeatures
    | undefined;
  /** Enable or disable gvnic in the node pool. */
  gvnic:
    | VirtualNIC
    | undefined;
  /**
   * Spot flag for enabling Spot VM, which is a rebrand of
   * the existing preemptible flag.
   */
  spot: boolean;
  /**
   * Confidential nodes config.
   * All the nodes in the node pool will be Confidential VM once enabled.
   */
  confidentialNodes:
    | ConfidentialNodes
    | undefined;
  /** Enable or disable NCCL fast socket for the node pool. */
  fastSocket?:
    | FastSocket
    | undefined;
  /**
   * The resource labels for the node pool to use to annotate any related
   * Google Compute Engine resources.
   */
  resourceLabels: { [key: string]: string };
  /** Logging configuration. */
  loggingConfig:
    | NodePoolLoggingConfig
    | undefined;
  /** Parameters that can be configured on Windows nodes. */
  windowsNodeConfig:
    | WindowsNodeConfig
    | undefined;
  /** Parameters for using raw-block Local NVMe SSDs. */
  localNvmeSsdBlockConfig:
    | LocalNvmeSsdBlockConfig
    | undefined;
  /**
   * Parameters for the node ephemeral storage using Local SSDs.
   * If unspecified, ephemeral storage is backed by the boot disk.
   */
  ephemeralStorageLocalSsdConfig:
    | EphemeralStorageLocalSsdConfig
    | undefined;
  /** Parameters for node pools to be backed by shared sole tenant node groups. */
  soleTenantConfig:
    | SoleTenantConfig
    | undefined;
  /** Parameters for containerd customization. */
  containerdConfig:
    | ContainerdConfig
    | undefined;
  /** A map of resource manager tag keys and values to be attached to the nodes. */
  resourceManagerTags:
    | ResourceManagerTags
    | undefined;
  /** Optional. Reserved for future use. */
  enableConfidentialStorage: boolean;
  /** List of secondary boot disks attached to the nodes. */
  secondaryBootDisks: SecondaryBootDisk[];
  /** Secondary boot disk update strategy. */
  secondaryBootDiskUpdateStrategy?: SecondaryBootDiskUpdateStrategy | undefined;
}

export interface NodeConfig_MetadataEntry {
  key: string;
  value: string;
}

export interface NodeConfig_LabelsEntry {
  key: string;
  value: string;
}

export interface NodeConfig_ResourceLabelsEntry {
  key: string;
  value: string;
}

/** Specifies options for controlling advanced machine features. */
export interface AdvancedMachineFeatures {
  /**
   * The number of threads per physical core. To disable simultaneous
   * multithreading (SMT) set this to 1. If unset, the maximum number of threads
   * supported per core by the underlying processor is assumed.
   */
  threadsPerCore?:
    | Long
    | undefined;
  /** Whether or not to enable nested virtualization (defaults to false). */
  enableNestedVirtualization?: boolean | undefined;
}

/** Parameters for node pool-level network config. */
export interface NodeNetworkConfig {
  /**
   * Input only. Whether to create a new range for pod IPs in this node pool.
   * Defaults are provided for `pod_range` and `pod_ipv4_cidr_block` if they
   * are not specified.
   *
   * If neither `create_pod_range` or `pod_range` are specified, the
   * cluster-level default (`ip_allocation_policy.cluster_ipv4_cidr_block`) is
   * used.
   *
   * Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
   *
   * This field cannot be changed after the node pool has been created.
   */
  createPodRange: boolean;
  /**
   * The ID of the secondary range for pod IPs.
   * If `create_pod_range` is true, this ID is used for the new range.
   * If `create_pod_range` is false, uses an existing secondary range with this
   * ID.
   *
   * Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
   *
   * This field cannot be changed after the node pool has been created.
   */
  podRange: string;
  /**
   * The IP address range for pod IPs in this node pool.
   *
   * Only applicable if `create_pod_range` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) to pick a specific range to use.
   *
   * Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
   *
   * This field cannot be changed after the node pool has been created.
   */
  podIpv4CidrBlock: string;
  /**
   * Whether nodes have internal IP addresses only.
   * If enable_private_nodes is not specified, then the value is derived from
   * [cluster.privateClusterConfig.enablePrivateNodes][google.container.v1beta1.PrivateClusterConfig.enablePrivateNodes]
   */
  enablePrivateNodes?:
    | boolean
    | undefined;
  /** Network bandwidth tier configuration. */
  networkPerformanceConfig?:
    | NodeNetworkConfig_NetworkPerformanceConfig
    | undefined;
  /**
   * [PRIVATE FIELD]
   * Pod CIDR size overprovisioning config for the nodepool.
   *
   * Pod CIDR size per node depends on max_pods_per_node. By default, the value
   * of max_pods_per_node is rounded off to next power of 2 and we then double
   * that to get the size of pod CIDR block per node.
   * Example: max_pods_per_node of 30 would result in 64 IPs (/26).
   *
   * This config can disable the doubling of IPs (we still round off to next
   * power of 2)
   * Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
   * overprovisioning is disabled.
   */
  podCidrOverprovisionConfig:
    | PodCIDROverprovisionConfig
    | undefined;
  /**
   * We specify the additional node networks for this node pool using this list.
   * Each node network corresponds to an additional interface
   */
  additionalNodeNetworkConfigs: AdditionalNodeNetworkConfig[];
  /**
   * We specify the additional pod networks for this node pool using this list.
   * Each pod network corresponds to an additional alias IP range for the node
   */
  additionalPodNetworkConfigs: AdditionalPodNetworkConfig[];
  /**
   * Output only. The utilization of the IPv4 range for the pod.
   * The ratio is Usage/[Total number of IPs in the secondary range],
   * Usage=numNodes*numZones*podIPsPerNode.
   */
  podIpv4RangeUtilization: number;
}

/** Configuration of all network bandwidth tiers */
export interface NodeNetworkConfig_NetworkPerformanceConfig {
  /** Specifies the total network bandwidth tier for the NodePool. */
  totalEgressBandwidthTier?: NodeNetworkConfig_NetworkPerformanceConfig_Tier | undefined;
}

/** Node network tier */
export enum NodeNetworkConfig_NetworkPerformanceConfig_Tier {
  /** TIER_UNSPECIFIED - Default value */
  TIER_UNSPECIFIED = 0,
  /** TIER_1 - Higher bandwidth, actual values based on VM size. */
  TIER_1 = 1,
  UNRECOGNIZED = -1,
}

export function nodeNetworkConfig_NetworkPerformanceConfig_TierFromJSON(
  object: any,
): NodeNetworkConfig_NetworkPerformanceConfig_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return NodeNetworkConfig_NetworkPerformanceConfig_Tier.TIER_UNSPECIFIED;
    case 1:
    case "TIER_1":
      return NodeNetworkConfig_NetworkPerformanceConfig_Tier.TIER_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeNetworkConfig_NetworkPerformanceConfig_Tier.UNRECOGNIZED;
  }
}

export function nodeNetworkConfig_NetworkPerformanceConfig_TierToJSON(
  object: NodeNetworkConfig_NetworkPerformanceConfig_Tier,
): string {
  switch (object) {
    case NodeNetworkConfig_NetworkPerformanceConfig_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case NodeNetworkConfig_NetworkPerformanceConfig_Tier.TIER_1:
      return "TIER_1";
    case NodeNetworkConfig_NetworkPerformanceConfig_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AdditionalNodeNetworkConfig is the configuration for additional node networks
 * within the NodeNetworkConfig message
 */
export interface AdditionalNodeNetworkConfig {
  /** Name of the VPC where the additional interface belongs */
  network: string;
  /** Name of the subnetwork where the additional interface belongs */
  subnetwork: string;
}

/**
 * AdditionalPodNetworkConfig is the configuration for additional pod networks
 * within the NodeNetworkConfig message
 */
export interface AdditionalPodNetworkConfig {
  /** Name of the subnetwork where the additional pod network belongs. */
  subnetwork: string;
  /**
   * The name of the secondary range on the subnet which provides IP address for
   * this pod range.
   */
  secondaryPodRange: string;
  /** The maximum number of pods per node which use this pod network. */
  maxPodsPerNode?: MaxPodsConstraint | undefined;
}

/** A set of Shielded Instance options. */
export interface ShieldedInstanceConfig {
  /**
   * Defines whether the instance has Secure Boot enabled.
   *
   * Secure Boot helps ensure that the system only runs authentic software by
   * verifying the digital signature of all boot components, and halting the
   * boot process if signature verification fails.
   */
  enableSecureBoot: boolean;
  /**
   * Defines whether the instance has integrity monitoring enabled.
   *
   * Enables monitoring and attestation of the boot integrity of the instance.
   * The attestation is performed against the integrity policy baseline. This
   * baseline is initially derived from the implicitly trusted boot image when
   * the instance is created.
   */
  enableIntegrityMonitoring: boolean;
}

/** SandboxConfig contains configurations of the sandbox to use for the node. */
export interface SandboxConfig {
  /** Type of the sandbox to use for the node. */
  type: SandboxConfig_Type;
}

/** Possible types of sandboxes. */
export enum SandboxConfig_Type {
  /** UNSPECIFIED - Default value. This should not be used. */
  UNSPECIFIED = 0,
  /** GVISOR - Run sandbox using gvisor. */
  GVISOR = 1,
  UNRECOGNIZED = -1,
}

export function sandboxConfig_TypeFromJSON(object: any): SandboxConfig_Type {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return SandboxConfig_Type.UNSPECIFIED;
    case 1:
    case "GVISOR":
      return SandboxConfig_Type.GVISOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SandboxConfig_Type.UNRECOGNIZED;
  }
}

export function sandboxConfig_TypeToJSON(object: SandboxConfig_Type): string {
  switch (object) {
    case SandboxConfig_Type.UNSPECIFIED:
      return "UNSPECIFIED";
    case SandboxConfig_Type.GVISOR:
      return "GVISOR";
    case SandboxConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * GcfsConfig contains configurations of Google Container File System
 * (image streaming).
 */
export interface GcfsConfig {
  /** Whether to use GCFS. */
  enabled: boolean;
}

/**
 * [ReservationAffinity](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
 * is the configuration of desired reservation which instances could take
 * capacity from.
 */
export interface ReservationAffinity {
  /** Corresponds to the type of reservation consumption. */
  consumeReservationType: ReservationAffinity_Type;
  /**
   * Corresponds to the label key of a reservation resource. To target a
   * SPECIFIC_RESERVATION by name, specify
   * "compute.googleapis.com/reservation-name" as the key and specify the name
   * of your reservation as its value.
   */
  key: string;
  /** Corresponds to the label value(s) of reservation resource(s). */
  values: string[];
}

/** Indicates whether to consume capacity from a reservation or not. */
export enum ReservationAffinity_Type {
  /** UNSPECIFIED - Default value. This should not be used. */
  UNSPECIFIED = 0,
  /** NO_RESERVATION - Do not consume from any reserved capacity. */
  NO_RESERVATION = 1,
  /** ANY_RESERVATION - Consume any reservation available. */
  ANY_RESERVATION = 2,
  /**
   * SPECIFIC_RESERVATION - Must consume from a specific reservation. Must specify key value fields
   * for specifying the reservations.
   */
  SPECIFIC_RESERVATION = 3,
  UNRECOGNIZED = -1,
}

export function reservationAffinity_TypeFromJSON(object: any): ReservationAffinity_Type {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ReservationAffinity_Type.UNSPECIFIED;
    case 1:
    case "NO_RESERVATION":
      return ReservationAffinity_Type.NO_RESERVATION;
    case 2:
    case "ANY_RESERVATION":
      return ReservationAffinity_Type.ANY_RESERVATION;
    case 3:
    case "SPECIFIC_RESERVATION":
      return ReservationAffinity_Type.SPECIFIC_RESERVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReservationAffinity_Type.UNRECOGNIZED;
  }
}

export function reservationAffinity_TypeToJSON(object: ReservationAffinity_Type): string {
  switch (object) {
    case ReservationAffinity_Type.UNSPECIFIED:
      return "UNSPECIFIED";
    case ReservationAffinity_Type.NO_RESERVATION:
      return "NO_RESERVATION";
    case ReservationAffinity_Type.ANY_RESERVATION:
      return "ANY_RESERVATION";
    case ReservationAffinity_Type.SPECIFIC_RESERVATION:
      return "SPECIFIC_RESERVATION";
    case ReservationAffinity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * SoleTenantConfig contains the NodeAffinities to specify what shared sole
 * tenant node groups should back the node pool.
 */
export interface SoleTenantConfig {
  /** NodeAffinities used to match to a shared sole tenant node group. */
  nodeAffinities: SoleTenantConfig_NodeAffinity[];
}

/**
 * Specifies the NodeAffinity key, values, and affinity operator according to
 * [shared sole tenant node group
 * affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity).
 */
export interface SoleTenantConfig_NodeAffinity {
  /** Key for NodeAffinity. */
  key: string;
  /** Operator for NodeAffinity. */
  operator: SoleTenantConfig_NodeAffinity_Operator;
  /** Values for NodeAffinity. */
  values: string[];
}

/**
 * Operator allows user to specify affinity or anti-affinity for the
 * given key values.
 */
export enum SoleTenantConfig_NodeAffinity_Operator {
  /** OPERATOR_UNSPECIFIED - Invalid or unspecified affinity operator. */
  OPERATOR_UNSPECIFIED = 0,
  /** IN - Affinity operator. */
  IN = 1,
  /** NOT_IN - Anti-affinity operator. */
  NOT_IN = 2,
  UNRECOGNIZED = -1,
}

export function soleTenantConfig_NodeAffinity_OperatorFromJSON(object: any): SoleTenantConfig_NodeAffinity_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return SoleTenantConfig_NodeAffinity_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "IN":
      return SoleTenantConfig_NodeAffinity_Operator.IN;
    case 2:
    case "NOT_IN":
      return SoleTenantConfig_NodeAffinity_Operator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoleTenantConfig_NodeAffinity_Operator.UNRECOGNIZED;
  }
}

export function soleTenantConfig_NodeAffinity_OperatorToJSON(object: SoleTenantConfig_NodeAffinity_Operator): string {
  switch (object) {
    case SoleTenantConfig_NodeAffinity_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case SoleTenantConfig_NodeAffinity_Operator.IN:
      return "IN";
    case SoleTenantConfig_NodeAffinity_Operator.NOT_IN:
      return "NOT_IN";
    case SoleTenantConfig_NodeAffinity_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ContainerdConfig contains configuration to customize containerd. */
export interface ContainerdConfig {
  /**
   * PrivateRegistryAccessConfig is used to configure access configuration
   * for private container registries.
   */
  privateRegistryAccessConfig: ContainerdConfig_PrivateRegistryAccessConfig | undefined;
}

/**
 * PrivateRegistryAccessConfig contains access configuration for
 * private container registries.
 */
export interface ContainerdConfig_PrivateRegistryAccessConfig {
  /** Private registry access is enabled. */
  enabled: boolean;
  /** Private registry access configuration. */
  certificateAuthorityDomainConfig: ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig[];
}

/**
 * CertificateAuthorityDomainConfig configures one or more fully qualified
 * domain names (FQDN) to a specific certificate.
 */
export interface ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
  /**
   * List of fully qualified domain names (FQDN).
   * Specifying port is supported.
   * Wilcards are NOT supported.
   * Examples:
   * - my.customdomain.com
   * - 10.0.1.2:5000
   */
  fqdns: string[];
  /** Google Secret Manager (GCP) certificate configuration. */
  gcpSecretManagerCertificateConfig?:
    | ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
    | undefined;
}

/**
 * GCPSecretManagerCertificateConfig configures a secret from
 * [Google Secret Manager](https://cloud.google.com/secret-manager).
 */
export interface ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
  /**
   * Secret URI, in the form
   * "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION".
   * Version can be fixed (e.g. "2") or "latest"
   */
  secretUri: string;
}

/**
 * Kubernetes taint is composed of three fields: key, value, and effect. Effect
 * can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
 *
 * See
 * [here](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration)
 * for more information, including usage and the valid values.
 */
export interface NodeTaint {
  /** Key for taint. */
  key: string;
  /** Value for taint. */
  value: string;
  /** Effect for taint. */
  effect: NodeTaint_Effect;
}

/** Possible values for Effect in taint. */
export enum NodeTaint_Effect {
  /** EFFECT_UNSPECIFIED - Not set */
  EFFECT_UNSPECIFIED = 0,
  /** NO_SCHEDULE - NoSchedule */
  NO_SCHEDULE = 1,
  /** PREFER_NO_SCHEDULE - PreferNoSchedule */
  PREFER_NO_SCHEDULE = 2,
  /** NO_EXECUTE - NoExecute */
  NO_EXECUTE = 3,
  UNRECOGNIZED = -1,
}

export function nodeTaint_EffectFromJSON(object: any): NodeTaint_Effect {
  switch (object) {
    case 0:
    case "EFFECT_UNSPECIFIED":
      return NodeTaint_Effect.EFFECT_UNSPECIFIED;
    case 1:
    case "NO_SCHEDULE":
      return NodeTaint_Effect.NO_SCHEDULE;
    case 2:
    case "PREFER_NO_SCHEDULE":
      return NodeTaint_Effect.PREFER_NO_SCHEDULE;
    case 3:
    case "NO_EXECUTE":
      return NodeTaint_Effect.NO_EXECUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeTaint_Effect.UNRECOGNIZED;
  }
}

export function nodeTaint_EffectToJSON(object: NodeTaint_Effect): string {
  switch (object) {
    case NodeTaint_Effect.EFFECT_UNSPECIFIED:
      return "EFFECT_UNSPECIFIED";
    case NodeTaint_Effect.NO_SCHEDULE:
      return "NO_SCHEDULE";
    case NodeTaint_Effect.PREFER_NO_SCHEDULE:
      return "PREFER_NO_SCHEDULE";
    case NodeTaint_Effect.NO_EXECUTE:
      return "NO_EXECUTE";
    case NodeTaint_Effect.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Collection of Kubernetes [node
 * taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration).
 */
export interface NodeTaints {
  /** List of node taints. */
  taints: NodeTaint[];
}

/**
 * Collection of node-level [Kubernetes
 * labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels).
 */
export interface NodeLabels {
  /** Map of node label keys and node label values. */
  labels: { [key: string]: string };
}

export interface NodeLabels_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Collection of [GCP
 * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
 */
export interface ResourceLabels {
  /** Map of node label keys and node label values. */
  labels: { [key: string]: string };
}

export interface ResourceLabels_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Collection of Compute Engine network tags that can be applied to a node's
 * underlying VM instance.
 */
export interface NetworkTags {
  /** List of network tags. */
  tags: string[];
}

/**
 * The authentication information for accessing the master endpoint.
 * Authentication can be done using HTTP basic auth or using client
 * certificates.
 */
export interface MasterAuth {
  /**
   * The username to use for HTTP basic authentication to the master endpoint.
   * For clusters v1.6.0 and later, basic authentication can be disabled by
   * leaving username unspecified (or setting it to the empty string).
   *
   * Warning: basic authentication is deprecated, and will be removed in GKE
   * control plane versions 1.19 and newer. For a list of recommended
   * authentication methods, see:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication
   *
   * @deprecated
   */
  username: string;
  /**
   * The password to use for HTTP basic authentication to the master endpoint.
   * Because the master endpoint is open to the Internet, you should create a
   * strong password.  If a password is provided for cluster creation, username
   * must be non-empty.
   *
   * Warning: basic authentication is deprecated, and will be removed in GKE
   * control plane versions 1.19 and newer. For a list of recommended
   * authentication methods, see:
   * https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication
   *
   * @deprecated
   */
  password: string;
  /**
   * Configuration for client certificate authentication on the cluster. For
   * clusters before v1.12, if no configuration is specified, a client
   * certificate is issued.
   */
  clientCertificateConfig:
    | ClientCertificateConfig
    | undefined;
  /**
   * Output only. Base64-encoded public certificate that is the root of
   * trust for the cluster.
   */
  clusterCaCertificate: string;
  /**
   * Output only. Base64-encoded public certificate used by clients to
   * authenticate to the cluster endpoint.
   */
  clientCertificate: string;
  /**
   * Output only. Base64-encoded private key used by clients to authenticate
   * to the cluster endpoint.
   */
  clientKey: string;
}

/** Configuration for client certificates on the cluster. */
export interface ClientCertificateConfig {
  /** Issue a client certificate. */
  issueClientCertificate: boolean;
}

/**
 * Configuration for the addons that can be automatically spun up in the
 * cluster, enabling additional functionality.
 */
export interface AddonsConfig {
  /**
   * Configuration for the HTTP (L7) load balancing controller addon, which
   * makes it easy to set up HTTP load balancers for services in a cluster.
   */
  httpLoadBalancing:
    | HttpLoadBalancing
    | undefined;
  /**
   * Configuration for the horizontal pod autoscaling feature, which
   * increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   */
  horizontalPodAutoscaling:
    | HorizontalPodAutoscaling
    | undefined;
  /**
   * Configuration for the Kubernetes Dashboard.
   * This addon is deprecated, and will be disabled in 1.15. It is recommended
   * to use the Cloud Console to manage and monitor your Kubernetes clusters,
   * workloads and applications. For more information, see:
   * https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards
   *
   * @deprecated
   */
  kubernetesDashboard:
    | KubernetesDashboard
    | undefined;
  /**
   * Configuration for NetworkPolicy. This only tracks whether the addon
   * is enabled or not on the Master, it does not track whether network policy
   * is enabled for the nodes.
   */
  networkPolicyConfig:
    | NetworkPolicyConfig
    | undefined;
  /**
   * Configuration for the Cloud Run addon, which allows the user to use a
   * managed Knative service.
   */
  cloudRunConfig:
    | CloudRunConfig
    | undefined;
  /** Configuration for NodeLocalDNS, a dns cache running on cluster nodes */
  dnsCacheConfig:
    | DnsCacheConfig
    | undefined;
  /**
   * Configuration for the ConfigConnector add-on, a Kubernetes
   * extension to manage hosted GCP services through the Kubernetes API
   */
  configConnectorConfig:
    | ConfigConnectorConfig
    | undefined;
  /** Configuration for the Compute Engine Persistent Disk CSI driver. */
  gcePersistentDiskCsiDriverConfig:
    | GcePersistentDiskCsiDriverConfig
    | undefined;
  /** Configuration for the GCP Filestore CSI driver. */
  gcpFilestoreCsiDriverConfig:
    | GcpFilestoreCsiDriverConfig
    | undefined;
  /** Configuration for the Backup for GKE agent addon. */
  gkeBackupAgentConfig:
    | GkeBackupAgentConfig
    | undefined;
  /** Configuration for the Cloud Storage Fuse CSI driver. */
  gcsFuseCsiDriverConfig:
    | GcsFuseCsiDriverConfig
    | undefined;
  /** Optional. Configuration for the StatefulHA add-on. */
  statefulHaConfig:
    | StatefulHAConfig
    | undefined;
  /** Optional. Configuration for Ray Operator addon. */
  rayOperatorConfig: RayOperatorConfig | undefined;
}

/**
 * Configuration options for the HTTP (L7) load balancing controller addon,
 * which makes it easy to set up HTTP load balancers for services in a cluster.
 */
export interface HttpLoadBalancing {
  /**
   * Whether the HTTP Load Balancing controller is enabled in the cluster.
   * When enabled, it runs a small pod in the cluster that manages the load
   * balancers.
   */
  disabled: boolean;
}

/**
 * Configuration options for the horizontal pod autoscaling feature, which
 * increases or decreases the number of replica pods a replication controller
 * has based on the resource usage of the existing pods.
 */
export interface HorizontalPodAutoscaling {
  /**
   * Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
   * When enabled, it ensures that metrics are collected into Stackdriver
   * Monitoring.
   */
  disabled: boolean;
}

/** Configuration for the Kubernetes Dashboard. */
export interface KubernetesDashboard {
  /** Whether the Kubernetes Dashboard is enabled for this cluster. */
  disabled: boolean;
}

/**
 * Configuration for NetworkPolicy. This only tracks whether the addon
 * is enabled or not on the Master, it does not track whether network policy
 * is enabled for the nodes.
 */
export interface NetworkPolicyConfig {
  /** Whether NetworkPolicy is enabled for this cluster. */
  disabled: boolean;
}

/** Configuration for NodeLocal DNSCache */
export interface DnsCacheConfig {
  /** Whether NodeLocal DNSCache is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration for controlling master global access settings. */
export interface PrivateClusterMasterGlobalAccessConfig {
  /** Whenever master is accessible globally or not. */
  enabled: boolean;
}

/** Configuration options for private clusters. */
export interface PrivateClusterConfig {
  /**
   * Whether nodes have internal IP addresses only. If enabled, all nodes are
   * given only RFC 1918 private addresses and communicate with the master via
   * private networking.
   */
  enablePrivateNodes: boolean;
  /** Whether the master's internal IP address is used as the cluster endpoint. */
  enablePrivateEndpoint: boolean;
  /**
   * The IP range in CIDR notation to use for the hosted master network. This
   * range will be used for assigning internal IP addresses to the master or
   * set of masters, as well as the ILB VIP. This range must not overlap with
   * any other ranges in use within the cluster's network.
   */
  masterIpv4CidrBlock: string;
  /** Output only. The internal IP address of this cluster's master endpoint. */
  privateEndpoint: string;
  /** Output only. The external IP address of this cluster's master endpoint. */
  publicEndpoint: string;
  /** Output only. The peering name in the customer VPC used by this cluster. */
  peeringName: string;
  /** Controls master global access settings. */
  masterGlobalAccessConfig:
    | PrivateClusterMasterGlobalAccessConfig
    | undefined;
  /**
   * Subnet to provision the master's private endpoint during cluster creation.
   * Specified in projects/* /regions/* /subnetworks/* format.
   */
  privateEndpointSubnetwork: string;
}

/** Configuration for returning group information from authenticators. */
export interface AuthenticatorGroupsConfig {
  /**
   * Whether this cluster should return group membership lookups
   * during authentication using a group of security groups.
   */
  enabled: boolean;
  /**
   * The name of the security group-of-groups to be used. Only relevant
   * if enabled = true.
   */
  securityGroup: string;
}

/** Configuration options for the Cloud Run feature. */
export interface CloudRunConfig {
  /** Whether Cloud Run addon is enabled for this cluster. */
  disabled: boolean;
  /** Which load balancer type is installed for Cloud Run. */
  loadBalancerType: CloudRunConfig_LoadBalancerType;
}

/** Load balancer type of ingress service of Cloud Run. */
export enum CloudRunConfig_LoadBalancerType {
  /** LOAD_BALANCER_TYPE_UNSPECIFIED - Load balancer type for Cloud Run is unspecified. */
  LOAD_BALANCER_TYPE_UNSPECIFIED = 0,
  /** LOAD_BALANCER_TYPE_EXTERNAL - Install external load balancer for Cloud Run. */
  LOAD_BALANCER_TYPE_EXTERNAL = 1,
  /** LOAD_BALANCER_TYPE_INTERNAL - Install internal load balancer for Cloud Run. */
  LOAD_BALANCER_TYPE_INTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function cloudRunConfig_LoadBalancerTypeFromJSON(object: any): CloudRunConfig_LoadBalancerType {
  switch (object) {
    case 0:
    case "LOAD_BALANCER_TYPE_UNSPECIFIED":
      return CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED;
    case 1:
    case "LOAD_BALANCER_TYPE_EXTERNAL":
      return CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_EXTERNAL;
    case 2:
    case "LOAD_BALANCER_TYPE_INTERNAL":
      return CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_INTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CloudRunConfig_LoadBalancerType.UNRECOGNIZED;
  }
}

export function cloudRunConfig_LoadBalancerTypeToJSON(object: CloudRunConfig_LoadBalancerType): string {
  switch (object) {
    case CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_UNSPECIFIED:
      return "LOAD_BALANCER_TYPE_UNSPECIFIED";
    case CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_EXTERNAL:
      return "LOAD_BALANCER_TYPE_EXTERNAL";
    case CloudRunConfig_LoadBalancerType.LOAD_BALANCER_TYPE_INTERNAL:
      return "LOAD_BALANCER_TYPE_INTERNAL";
    case CloudRunConfig_LoadBalancerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration options for the Config Connector add-on. */
export interface ConfigConnectorConfig {
  /** Whether Cloud Connector is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration for the Compute Engine PD CSI driver. */
export interface GcePersistentDiskCsiDriverConfig {
  /** Whether the Compute Engine PD CSI driver is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration for the GCP Filestore CSI driver. */
export interface GcpFilestoreCsiDriverConfig {
  /** Whether the GCP Filestore CSI driver is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration for the Cloud Storage Fuse CSI driver. */
export interface GcsFuseCsiDriverConfig {
  /** Whether the Cloud Storage Fuse CSI driver is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration options for the Ray Operator add-on. */
export interface RayOperatorConfig {
  /** Whether the Ray Operator addon is enabled for this cluster. */
  enabled: boolean;
  /** Optional. Logging configuration for Ray clusters. */
  rayClusterLoggingConfig:
    | RayClusterLoggingConfig
    | undefined;
  /** Optional. Monitoring configuration for Ray clusters. */
  rayClusterMonitoringConfig: RayClusterMonitoringConfig | undefined;
}

/** Configuration for the Backup for GKE Agent. */
export interface GkeBackupAgentConfig {
  /** Whether the Backup for GKE agent is enabled for this cluster. */
  enabled: boolean;
}

/** Configuration for the Stateful HA add-on. */
export interface StatefulHAConfig {
  /** Whether the Stateful HA add-on is enabled for this cluster. */
  enabled: boolean;
}

/**
 * Configuration options for the master authorized networks feature. Enabled
 * master authorized networks will disallow all external traffic to access
 * Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 * Google Compute Engine Public IPs and Google Prod IPs.
 */
export interface MasterAuthorizedNetworksConfig {
  /** Whether or not master authorized networks is enabled. */
  enabled: boolean;
  /**
   * cidr_blocks define up to 50 external networks that could access
   * Kubernetes master through HTTPS.
   */
  cidrBlocks: MasterAuthorizedNetworksConfig_CidrBlock[];
  /** Whether master is accessbile via Google Compute Engine Public IP addresses. */
  gcpPublicCidrsAccessEnabled?: boolean | undefined;
}

/** CidrBlock contains an optional name and one CIDR block. */
export interface MasterAuthorizedNetworksConfig_CidrBlock {
  /** display_name is an optional field for users to identify CIDR blocks. */
  displayName: string;
  /** cidr_block must be specified in CIDR notation. */
  cidrBlock: string;
}

/**
 * Configuration for the legacy Attribute Based Access Control authorization
 * mode.
 */
export interface LegacyAbac {
  /**
   * Whether the ABAC authorizer is enabled for this cluster. When enabled,
   * identities in the system, including service accounts, nodes, and
   * controllers, will have statically granted permissions beyond those
   * provided by the RBAC configuration or IAM.
   */
  enabled: boolean;
}

/**
 * Configuration options for the NetworkPolicy feature.
 * https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
 */
export interface NetworkPolicy {
  /** The selected network policy provider. */
  provider: NetworkPolicy_Provider;
  /** Whether network policy is enabled on the cluster. */
  enabled: boolean;
}

/** Allowed Network Policy providers. */
export enum NetworkPolicy_Provider {
  /** PROVIDER_UNSPECIFIED - Not set */
  PROVIDER_UNSPECIFIED = 0,
  /** CALICO - Tigera (Calico Felix). */
  CALICO = 1,
  UNRECOGNIZED = -1,
}

export function networkPolicy_ProviderFromJSON(object: any): NetworkPolicy_Provider {
  switch (object) {
    case 0:
    case "PROVIDER_UNSPECIFIED":
      return NetworkPolicy_Provider.PROVIDER_UNSPECIFIED;
    case 1:
    case "CALICO":
      return NetworkPolicy_Provider.CALICO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPolicy_Provider.UNRECOGNIZED;
  }
}

export function networkPolicy_ProviderToJSON(object: NetworkPolicy_Provider): string {
  switch (object) {
    case NetworkPolicy_Provider.PROVIDER_UNSPECIFIED:
      return "PROVIDER_UNSPECIFIED";
    case NetworkPolicy_Provider.CALICO:
      return "CALICO";
    case NetworkPolicy_Provider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for Binary Authorization. */
export interface BinaryAuthorization {
  /**
   * This field is deprecated. Leave this unset and instead configure
   * BinaryAuthorization using evaluation_mode. If evaluation_mode is set to
   * anything other than EVALUATION_MODE_UNSPECIFIED, this field is ignored.
   *
   * @deprecated
   */
  enabled: boolean;
  /**
   * Mode of operation for binauthz policy evaluation. If unspecified, defaults
   * to DISABLED.
   */
  evaluationMode: BinaryAuthorization_EvaluationMode;
}

/** Binary Authorization mode of operation. */
export enum BinaryAuthorization_EvaluationMode {
  /** EVALUATION_MODE_UNSPECIFIED - Default value */
  EVALUATION_MODE_UNSPECIFIED = 0,
  /** DISABLED - Disable BinaryAuthorization */
  DISABLED = 1,
  /**
   * PROJECT_SINGLETON_POLICY_ENFORCE - Enforce Kubernetes admission requests with BinaryAuthorization using the
   * project's singleton policy. This is equivalent to setting the
   * enabled boolean to true.
   */
  PROJECT_SINGLETON_POLICY_ENFORCE = 2,
  UNRECOGNIZED = -1,
}

export function binaryAuthorization_EvaluationModeFromJSON(object: any): BinaryAuthorization_EvaluationMode {
  switch (object) {
    case 0:
    case "EVALUATION_MODE_UNSPECIFIED":
      return BinaryAuthorization_EvaluationMode.EVALUATION_MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return BinaryAuthorization_EvaluationMode.DISABLED;
    case 2:
    case "PROJECT_SINGLETON_POLICY_ENFORCE":
      return BinaryAuthorization_EvaluationMode.PROJECT_SINGLETON_POLICY_ENFORCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BinaryAuthorization_EvaluationMode.UNRECOGNIZED;
  }
}

export function binaryAuthorization_EvaluationModeToJSON(object: BinaryAuthorization_EvaluationMode): string {
  switch (object) {
    case BinaryAuthorization_EvaluationMode.EVALUATION_MODE_UNSPECIFIED:
      return "EVALUATION_MODE_UNSPECIFIED";
    case BinaryAuthorization_EvaluationMode.DISABLED:
      return "DISABLED";
    case BinaryAuthorization_EvaluationMode.PROJECT_SINGLETON_POLICY_ENFORCE:
      return "PROJECT_SINGLETON_POLICY_ENFORCE";
    case BinaryAuthorization_EvaluationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * [PRIVATE FIELD]
 * Config for pod CIDR size overprovisioning.
 */
export interface PodCIDROverprovisionConfig {
  /**
   * Whether Pod CIDR overprovisioning is disabled.
   * Note: Pod CIDR overprovisioning is enabled by default.
   */
  disable: boolean;
}

/** Configuration for controlling how IPs are allocated in the cluster. */
export interface IPAllocationPolicy {
  /**
   * Whether alias IPs will be used for pod IPs in the cluster.
   * This is used in conjunction with use_routes. It cannot
   * be true if use_routes is true. If both use_ip_aliases and use_routes are
   * false, then the server picks the default IP allocation mode
   */
  useIpAliases: boolean;
  /**
   * Whether a new subnetwork will be created automatically for the cluster.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   */
  createSubnetwork: boolean;
  /**
   * A custom subnetwork name to be used if `create_subnetwork` is true.  If
   * this field is empty, then an automatic name will be chosen for the new
   * subnetwork.
   */
  subnetworkName: string;
  /**
   * This field is deprecated, use cluster_ipv4_cidr_block.
   *
   * @deprecated
   */
  clusterIpv4Cidr: string;
  /**
   * This field is deprecated, use node_ipv4_cidr_block.
   *
   * @deprecated
   */
  nodeIpv4Cidr: string;
  /**
   * This field is deprecated, use services_ipv4_cidr_block.
   *
   * @deprecated
   */
  servicesIpv4Cidr: string;
  /**
   * The name of the secondary range to be used for the cluster CIDR
   * block.  The secondary range will be used for pod IP
   * addresses. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable with use_ip_aliases is true and
   * create_subnetwork is false.
   */
  clusterSecondaryRangeName: string;
  /**
   * The name of the secondary range to be used as for the services
   * CIDR block.  The secondary range will be used for service
   * ClusterIPs. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable with use_ip_aliases is true and
   * create_subnetwork is false.
   */
  servicesSecondaryRangeName: string;
  /**
   * The IP address range for the cluster pod IPs. If this field is set, then
   * `cluster.cluster_ipv4_cidr` must be left blank.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  clusterIpv4CidrBlock: string;
  /**
   * The IP address range of the instance IPs in this cluster.
   *
   * This is applicable only if `create_subnetwork` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  nodeIpv4CidrBlock: string;
  /**
   * The IP address range of the services IPs in this cluster. If blank, a range
   * will be automatically chosen with the default size.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  servicesIpv4CidrBlock: string;
  /**
   * The IP address range of the Cloud TPUs in this cluster. If unspecified, a
   * range will be automatically chosen with the default size.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * If unspecified, the range will use the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   */
  tpuIpv4CidrBlock: string;
  /**
   * Whether routes will be used for pod IPs in the cluster.
   * This is used in conjunction with use_ip_aliases. It cannot be true if
   * use_ip_aliases is true. If both use_ip_aliases and use_routes are false,
   * then the server picks the default IP allocation mode
   */
  useRoutes: boolean;
  /** The IP stack type of the cluster */
  stackType: StackType;
  /** The ipv6 access type (internal or external) when create_subnetwork is true */
  ipv6AccessType: IPv6AccessType;
  /**
   * [PRIVATE FIELD]
   * Pod CIDR size overprovisioning config for the cluster.
   *
   * Pod CIDR size per node depends on max_pods_per_node. By default, the value
   * of max_pods_per_node is doubled and then rounded off to next power of 2 to
   * get the size of pod CIDR block per node.
   * Example: max_pods_per_node of 30 would result in 64 IPs (/26).
   *
   * This config can disable the doubling of IPs (we still round off to next
   * power of 2)
   * Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
   * overprovisioning is disabled.
   */
  podCidrOverprovisionConfig:
    | PodCIDROverprovisionConfig
    | undefined;
  /** Output only. The subnet's IPv6 CIDR block used by nodes and pods. */
  subnetIpv6CidrBlock: string;
  /** Output only. The services IPv6 CIDR block for the cluster. */
  servicesIpv6CidrBlock: string;
  /**
   * Output only. The additional pod ranges that are added to the cluster.
   * These pod ranges can be used by new node pools to allocate pod IPs
   * automatically. Once the range is removed it will not show up in
   * IPAllocationPolicy.
   */
  additionalPodRangesConfig:
    | AdditionalPodRangesConfig
    | undefined;
  /**
   * Output only. The utilization of the cluster default IPv4 range for the
   * pod. The ratio is Usage/[Total number of IPs in the secondary range],
   * Usage=numNodes*numZones*podIPsPerNode.
   */
  defaultPodIpv4RangeUtilization: number;
}

/** A Google Kubernetes Engine cluster. */
export interface Cluster {
  /**
   * The name of this cluster. The name must be unique within this project
   * and location (e.g. zone or region), and can be up to 40 characters with
   * the following restrictions:
   *
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   */
  name: string;
  /** An optional description of this cluster. */
  description: string;
  /**
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   *
   * This field is deprecated, use node_pool.initial_node_count instead.
   *
   * @deprecated
   */
  initialNodeCount: number;
  /**
   * Parameters used in creating the cluster's nodes.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool. (For configuration of each node pool, see
   * `node_pool.config`)
   *
   * If unspecified, the defaults are used.
   * This field is deprecated, use node_pool.config instead.
   *
   * @deprecated
   */
  nodeConfig:
    | NodeConfig
    | undefined;
  /**
   * The authentication information for accessing the master endpoint.
   * If unspecified, the defaults are used:
   * For clusters before v1.12, if master_auth is unspecified, `username` will
   * be set to "admin", a random password will be generated, and a client
   * certificate will be issued.
   */
  masterAuth:
    | MasterAuth
    | undefined;
  /**
   * The logging service the cluster should use to write logs.
   * Currently available options:
   *
   * * `logging.googleapis.com/kubernetes` - The Cloud Logging
   * service with a Kubernetes-native resource model
   * * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
   *   available as of GKE 1.15).
   * * `none` - no logs will be exported from the cluster.
   *
   * If left as an empty string,`logging.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
   */
  loggingService: string;
  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
   * service with a Kubernetes-native resource model
   * * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
   *   longer available as of GKE 1.15).
   * * `none` - No metrics will be exported from the cluster.
   *
   * If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
   */
  monitoringService: string;
  /**
   * The name of the Google Compute Engine
   * [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
   * to which the cluster is connected. If left unspecified, the `default`
   * network will be used.
   */
  network: string;
  /**
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   */
  clusterIpv4Cidr: string;
  /** Configurations for the various addons available to run in the cluster. */
  addonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The name of the Google Compute Engine
   * [subnetwork](https://cloud.google.com/compute/docs/subnetworks) to which
   * the cluster is connected.
   */
  subnetwork: string;
  /**
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   */
  nodePools: NodePool[];
  /**
   * The list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster's nodes should be located.
   *
   * This field provides a default value if
   * [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
   * are not specified during node pool creation.
   *
   * Warning: changing cluster locations will update the
   * [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
   * of all node pools and will result in nodes being added and/or removed.
   */
  locations: string[];
  /**
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   */
  enableKubernetesAlpha: boolean;
  /**
   * The resource labels for the cluster to use to annotate any related
   * Google Compute Engine resources.
   */
  resourceLabels: { [key: string]: string };
  /** The fingerprint of the set of labels for this cluster. */
  labelFingerprint: string;
  /** Configuration for the legacy ABAC authorization mode. */
  legacyAbac:
    | LegacyAbac
    | undefined;
  /** Configuration options for the NetworkPolicy feature. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /** Configuration for cluster IP allocation. */
  ipAllocationPolicy:
    | IPAllocationPolicy
    | undefined;
  /** The configuration options for master authorized networks feature. */
  masterAuthorizedNetworksConfig:
    | MasterAuthorizedNetworksConfig
    | undefined;
  /** Configure the maintenance policy for this cluster. */
  maintenancePolicy:
    | MaintenancePolicy
    | undefined;
  /** Configuration for Binary Authorization. */
  binaryAuthorization:
    | BinaryAuthorization
    | undefined;
  /** Cluster-level autoscaling configuration. */
  autoscaling:
    | ClusterAutoscaling
    | undefined;
  /** Configuration for cluster networking. */
  networkConfig:
    | NetworkConfig
    | undefined;
  /**
   * The default constraint on the maximum number of pods that can be run
   * simultaneously on a node in the node pool of this cluster. Only honored
   * if cluster created with IP Alias support.
   */
  defaultMaxPodsConstraint:
    | MaxPodsConstraint
    | undefined;
  /**
   * Configuration for exporting resource usages. Resource usage export is
   * disabled when this config is unspecified.
   */
  resourceUsageExportConfig:
    | ResourceUsageExportConfig
    | undefined;
  /** Configuration controlling RBAC group membership information. */
  authenticatorGroupsConfig:
    | AuthenticatorGroupsConfig
    | undefined;
  /** Configuration for private cluster. */
  privateClusterConfig:
    | PrivateClusterConfig
    | undefined;
  /** Configuration of etcd encryption. */
  databaseEncryption:
    | DatabaseEncryption
    | undefined;
  /** Cluster-level Vertical Pod Autoscaling configuration. */
  verticalPodAutoscaling:
    | VerticalPodAutoscaling
    | undefined;
  /** Shielded Nodes configuration. */
  shieldedNodes:
    | ShieldedNodes
    | undefined;
  /**
   * Release channel configuration. If left unspecified on cluster creation and
   * a version is specified, the cluster is enrolled in the most mature release
   * channel where the version is available (first checking STABLE, then
   * REGULAR, and finally RAPID). Otherwise, if no release channel
   * configuration and no version is specified, the cluster is enrolled in the
   * REGULAR channel with its default version.
   */
  releaseChannel:
    | ReleaseChannel
    | undefined;
  /**
   * Configuration for the use of Kubernetes Service Accounts in GCP IAM
   * policies.
   */
  workloadIdentityConfig:
    | WorkloadIdentityConfig
    | undefined;
  /**
   * Configuration for issuance of mTLS keys and certificates to Kubernetes
   * pods.
   */
  meshCertificates:
    | MeshCertificates
    | undefined;
  /** Configuration for the fine-grained cost management feature. */
  costManagementConfig:
    | CostManagementConfig
    | undefined;
  /** Notification configuration of the cluster. */
  notificationConfig:
    | NotificationConfig
    | undefined;
  /**
   * Configuration of Confidential Nodes.
   * All the nodes in the cluster will be Confidential VM once enabled.
   */
  confidentialNodes:
    | ConfidentialNodes
    | undefined;
  /** Configuration for Identity Service component. */
  identityServiceConfig:
    | IdentityServiceConfig
    | undefined;
  /** Output only. Server-defined URL for the resource. */
  selfLink: string;
  /**
   * Output only. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field is deprecated, use location instead.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Output only. The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password@endpoint/`.
   *
   * See the `masterAuth` property of this resource for username and
   * password information.
   */
  endpoint: string;
  /**
   * The initial Kubernetes version for this cluster.  Valid versions are those
   * found in validMasterVersions returned by getServerConfig.  The version can
   * be upgraded over time; such upgrades are reflected in
   * currentMasterVersion and currentNodeVersion.
   *
   * Users may specify either explicit versions offered by
   * Kubernetes Engine or version aliases, which have the following behavior:
   *
   * - "latest": picks the highest valid Kubernetes version
   * - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
   * - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
   * - "1.X.Y-gke.N": picks an explicit Kubernetes version
   * - "","-": picks the default Kubernetes version
   */
  initialClusterVersion: string;
  /** Output only. The current software version of the master endpoint. */
  currentMasterVersion: string;
  /**
   * Output only. Deprecated, use
   * [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools)
   * instead. The current version of the node software components. If they are
   * currently at multiple versions because they're in the process of being
   * upgraded, this reflects the minimum version of all nodes.
   *
   * @deprecated
   */
  currentNodeVersion: string;
  /**
   * Output only. The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  createTime: string;
  /** Output only. The current status of this cluster. */
  status: Cluster_Status;
  /**
   * Output only. Deprecated. Use conditions instead.
   * Additional information about the current status of this
   * cluster, if available.
   *
   * @deprecated
   */
  statusMessage: string;
  /**
   * Output only. The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range. This field will only be set when cluster is in route-based network
   * mode.
   */
  nodeIpv4CidrSize: number;
  /**
   * Output only. The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   */
  servicesIpv4Cidr: string;
  /**
   * Output only. Deprecated. Use node_pools.instance_group_urls.
   *
   * @deprecated
   */
  instanceGroupUrls: string[];
  /**
   * Output only. The number of nodes currently in the cluster. Deprecated.
   * Call Kubernetes API directly to retrieve node information.
   *
   * @deprecated
   */
  currentNodeCount: number;
  /**
   * Output only. The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  expireTime: string;
  /**
   * Output only. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
   * or
   * [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
   * in which the cluster resides.
   */
  location: string;
  /** Enable the ability to use Cloud TPUs in this cluster. */
  enableTpu: boolean;
  /**
   * Output only. The IP address range of the Cloud TPUs in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`).
   */
  tpuIpv4CidrBlock: string;
  /** Which conditions caused the current cluster state. */
  conditions: StatusCondition[];
  /** Autopilot configuration for the cluster. */
  autopilot:
    | Autopilot
    | undefined;
  /** Output only. Unique id for the cluster. */
  id: string;
  /**
   * Default NodePool settings for the entire cluster. These settings are
   * overridden if specified on the specific NodePool object.
   */
  nodePoolDefaults?:
    | NodePoolDefaults
    | undefined;
  /** Logging configuration for the cluster. */
  loggingConfig:
    | LoggingConfig
    | undefined;
  /** Monitoring configuration for the cluster. */
  monitoringConfig:
    | MonitoringConfig
    | undefined;
  /**
   * Node pool configs that apply to all auto-provisioned node pools
   * in autopilot clusters and node auto-provisioning enabled clusters.
   */
  nodePoolAutoConfig:
    | NodePoolAutoConfig
    | undefined;
  /**
   * This checksum is computed by the server based on the value of cluster
   * fields, and may be sent on update requests to ensure the client has an
   * up-to-date value before proceeding.
   */
  etag: string;
  /** Fleet information for the cluster. */
  fleet:
    | Fleet
    | undefined;
  /** Enable/Disable Security Posture API features for the cluster. */
  securityPostureConfig:
    | SecurityPostureConfig
    | undefined;
  /** Beta APIs Config */
  enableK8sBetaApis:
    | K8sBetaAPIConfig
    | undefined;
  /** GKE Enterprise Configuration. */
  enterpriseConfig:
    | EnterpriseConfig
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzs?:
    | boolean
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzi?: boolean | undefined;
}

/** The current status of the cluster. */
export enum Cluster_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PROVISIONING - The PROVISIONING state indicates the cluster is being created. */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the cluster has been created and is fully
   * usable.
   */
  RUNNING = 2,
  /**
   * RECONCILING - The RECONCILING state indicates that some work is actively being done on
   * the cluster, such as upgrading the master or node software. Details can
   * be found in the `statusMessage` field.
   */
  RECONCILING = 3,
  /** STOPPING - The STOPPING state indicates the cluster is being deleted. */
  STOPPING = 4,
  /**
   * ERROR - The ERROR state indicates the cluster is unusable. It will be
   * automatically deleted. Details can be found in the `statusMessage` field.
   */
  ERROR = 5,
  /**
   * DEGRADED - The DEGRADED state indicates the cluster requires user action to restore
   * full functionality. Details can be found in the `statusMessage` field.
   */
  DEGRADED = 6,
  UNRECOGNIZED = -1,
}

export function cluster_StatusFromJSON(object: any): Cluster_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Cluster_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Cluster_Status.PROVISIONING;
    case 2:
    case "RUNNING":
      return Cluster_Status.RUNNING;
    case 3:
    case "RECONCILING":
      return Cluster_Status.RECONCILING;
    case 4:
    case "STOPPING":
      return Cluster_Status.STOPPING;
    case 5:
    case "ERROR":
      return Cluster_Status.ERROR;
    case 6:
    case "DEGRADED":
      return Cluster_Status.DEGRADED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_Status.UNRECOGNIZED;
  }
}

export function cluster_StatusToJSON(object: Cluster_Status): string {
  switch (object) {
    case Cluster_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Cluster_Status.PROVISIONING:
      return "PROVISIONING";
    case Cluster_Status.RUNNING:
      return "RUNNING";
    case Cluster_Status.RECONCILING:
      return "RECONCILING";
    case Cluster_Status.STOPPING:
      return "STOPPING";
    case Cluster_Status.ERROR:
      return "ERROR";
    case Cluster_Status.DEGRADED:
      return "DEGRADED";
    case Cluster_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Cluster_ResourceLabelsEntry {
  key: string;
  value: string;
}

/** K8sBetaAPIConfig , configuration for beta APIs */
export interface K8sBetaAPIConfig {
  /** Enabled k8s beta APIs. */
  enabledApis: string[];
}

/**
 * SecurityPostureConfig defines the flags needed to enable/disable features for
 * the Security Posture API.
 */
export interface SecurityPostureConfig {
  /** Sets which mode to use for Security Posture features. */
  mode?:
    | SecurityPostureConfig_Mode
    | undefined;
  /** Sets which mode to use for vulnerability scanning. */
  vulnerabilityMode?: SecurityPostureConfig_VulnerabilityMode | undefined;
}

/** Mode defines enablement mode for GKE Security posture features. */
export enum SecurityPostureConfig_Mode {
  /** MODE_UNSPECIFIED - Default value not specified. */
  MODE_UNSPECIFIED = 0,
  /** DISABLED - Disables Security Posture features on the cluster. */
  DISABLED = 1,
  /** BASIC - Applies Security Posture features on the cluster. */
  BASIC = 2,
  /** ENTERPRISE - Applies the Security Posture off cluster Enterprise level features. */
  ENTERPRISE = 3,
  UNRECOGNIZED = -1,
}

export function securityPostureConfig_ModeFromJSON(object: any): SecurityPostureConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SecurityPostureConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SecurityPostureConfig_Mode.DISABLED;
    case 2:
    case "BASIC":
      return SecurityPostureConfig_Mode.BASIC;
    case 3:
    case "ENTERPRISE":
      return SecurityPostureConfig_Mode.ENTERPRISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityPostureConfig_Mode.UNRECOGNIZED;
  }
}

export function securityPostureConfig_ModeToJSON(object: SecurityPostureConfig_Mode): string {
  switch (object) {
    case SecurityPostureConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SecurityPostureConfig_Mode.DISABLED:
      return "DISABLED";
    case SecurityPostureConfig_Mode.BASIC:
      return "BASIC";
    case SecurityPostureConfig_Mode.ENTERPRISE:
      return "ENTERPRISE";
    case SecurityPostureConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VulnerabilityMode defines enablement mode for vulnerability scanning. */
export enum SecurityPostureConfig_VulnerabilityMode {
  /** VULNERABILITY_MODE_UNSPECIFIED - Default value not specified. */
  VULNERABILITY_MODE_UNSPECIFIED = 0,
  /** VULNERABILITY_DISABLED - Disables vulnerability scanning on the cluster. */
  VULNERABILITY_DISABLED = 1,
  /** VULNERABILITY_BASIC - Applies basic vulnerability scanning on the cluster. */
  VULNERABILITY_BASIC = 2,
  /**
   * VULNERABILITY_ENTERPRISE - Applies the Security Posture's vulnerability on cluster Enterprise level
   * features.
   */
  VULNERABILITY_ENTERPRISE = 3,
  UNRECOGNIZED = -1,
}

export function securityPostureConfig_VulnerabilityModeFromJSON(object: any): SecurityPostureConfig_VulnerabilityMode {
  switch (object) {
    case 0:
    case "VULNERABILITY_MODE_UNSPECIFIED":
      return SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_MODE_UNSPECIFIED;
    case 1:
    case "VULNERABILITY_DISABLED":
      return SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_DISABLED;
    case 2:
    case "VULNERABILITY_BASIC":
      return SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_BASIC;
    case 3:
    case "VULNERABILITY_ENTERPRISE":
      return SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_ENTERPRISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecurityPostureConfig_VulnerabilityMode.UNRECOGNIZED;
  }
}

export function securityPostureConfig_VulnerabilityModeToJSON(object: SecurityPostureConfig_VulnerabilityMode): string {
  switch (object) {
    case SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_MODE_UNSPECIFIED:
      return "VULNERABILITY_MODE_UNSPECIFIED";
    case SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_DISABLED:
      return "VULNERABILITY_DISABLED";
    case SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_BASIC:
      return "VULNERABILITY_BASIC";
    case SecurityPostureConfig_VulnerabilityMode.VULNERABILITY_ENTERPRISE:
      return "VULNERABILITY_ENTERPRISE";
    case SecurityPostureConfig_VulnerabilityMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Node pool configs that apply to all auto-provisioned node pools
 * in autopilot clusters and node auto-provisioning enabled clusters.
 */
export interface NodePoolAutoConfig {
  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster creation. Each tag within the list
   * must comply with RFC1035.
   */
  networkTags:
    | NetworkTags
    | undefined;
  /**
   * Resource manager tag keys and values to be attached to the nodes
   * for managing Compute Engine firewalls using Network Firewall Policies.
   */
  resourceManagerTags:
    | ResourceManagerTags
    | undefined;
  /**
   * NodeKubeletConfig controls the defaults for autoprovisioned node-pools.
   *
   * Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
   */
  nodeKubeletConfig: NodeKubeletConfig | undefined;
}

/** Subset of Nodepool message that has defaults. */
export interface NodePoolDefaults {
  /** Subset of NodeConfig message that has defaults. */
  nodeConfigDefaults: NodeConfigDefaults | undefined;
}

/** Subset of NodeConfig message that has defaults. */
export interface NodeConfigDefaults {
  /** GCFS (Google Container File System, also known as Riptide) options. */
  gcfsConfig:
    | GcfsConfig
    | undefined;
  /** Logging configuration for node pools. */
  loggingConfig:
    | NodePoolLoggingConfig
    | undefined;
  /** Parameters for containerd customization. */
  containerdConfig:
    | ContainerdConfig
    | undefined;
  /**
   * NodeKubeletConfig controls the defaults for new node-pools.
   *
   * Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
   */
  nodeKubeletConfig: NodeKubeletConfig | undefined;
}

/**
 * ClusterUpdate describes an update to the cluster. Exactly one update can
 * be applied to a cluster with each request, so at most one field can be
 * provided.
 */
export interface ClusterUpdate {
  /**
   * The Kubernetes version to change the nodes to (typically an
   * upgrade).
   *
   * Users may specify either explicit versions offered by
   * Kubernetes Engine or version aliases, which have the following behavior:
   *
   * - "latest": picks the highest valid Kubernetes version
   * - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
   * - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
   * - "1.X.Y-gke.N": picks an explicit Kubernetes version
   * - "-": picks the Kubernetes master version
   */
  desiredNodeVersion: string;
  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
   * service with a Kubernetes-native resource model
   * * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
   *   longer available as of GKE 1.15).
   * * `none` - No metrics will be exported from the cluster.
   *
   * If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
   */
  desiredMonitoringService: string;
  /** Configurations for the various addons available to run in the cluster. */
  desiredAddonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   */
  desiredNodePoolId: string;
  /**
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   */
  desiredImageType: string;
  /** Configuration of etcd encryption. */
  desiredDatabaseEncryption:
    | DatabaseEncryption
    | undefined;
  /** Configuration for Workload Identity. */
  desiredWorkloadIdentityConfig:
    | WorkloadIdentityConfig
    | undefined;
  /**
   * Configuration for issuance of mTLS keys and certificates to Kubernetes
   * pods.
   */
  desiredMeshCertificates:
    | MeshCertificates
    | undefined;
  /** Configuration for Shielded Nodes. */
  desiredShieldedNodes:
    | ShieldedNodes
    | undefined;
  /** The desired configuration for the fine-grained cost management feature. */
  desiredCostManagementConfig:
    | CostManagementConfig
    | undefined;
  /** DNSConfig contains clusterDNS config for this cluster. */
  desiredDnsConfig:
    | DNSConfig
    | undefined;
  /**
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   */
  desiredNodePoolAutoscaling:
    | NodePoolAutoscaling
    | undefined;
  /**
   * The desired list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster's nodes should be located.
   *
   * This list must always include the cluster's primary zone.
   *
   * Warning: changing cluster locations will update the locations of all node
   * pools and will result in nodes being added and/or removed.
   */
  desiredLocations: string[];
  /** The desired configuration options for master authorized networks feature. */
  desiredMasterAuthorizedNetworksConfig:
    | MasterAuthorizedNetworksConfig
    | undefined;
  /** Cluster-level autoscaling configuration. */
  desiredClusterAutoscaling:
    | ClusterAutoscaling
    | undefined;
  /** The desired configuration options for the Binary Authorization feature. */
  desiredBinaryAuthorization:
    | BinaryAuthorization
    | undefined;
  /**
   * The logging service the cluster should use to write logs.
   * Currently available options:
   *
   * * `logging.googleapis.com/kubernetes` - The Cloud Logging
   * service with a Kubernetes-native resource model
   * * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
   *   available as of GKE 1.15).
   * * `none` - no logs will be exported from the cluster.
   *
   * If left as an empty string,`logging.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
   */
  desiredLoggingService: string;
  /** The desired configuration for exporting resource usage. */
  desiredResourceUsageExportConfig:
    | ResourceUsageExportConfig
    | undefined;
  /** Cluster-level Vertical Pod Autoscaling configuration. */
  desiredVerticalPodAutoscaling:
    | VerticalPodAutoscaling
    | undefined;
  /**
   * The desired private cluster configuration. master_global_access_config is
   * the only field that can be changed via this field.
   * See also
   * [ClusterUpdate.desired_enable_private_endpoint][google.container.v1.ClusterUpdate.desired_enable_private_endpoint]
   * for modifying other fields within
   * [PrivateClusterConfig][google.container.v1.PrivateClusterConfig].
   */
  desiredPrivateClusterConfig:
    | PrivateClusterConfig
    | undefined;
  /** The desired config of Intra-node visibility. */
  desiredIntraNodeVisibilityConfig:
    | IntraNodeVisibilityConfig
    | undefined;
  /** The desired status of whether to disable default sNAT for this cluster. */
  desiredDefaultSnatStatus:
    | DefaultSnatStatus
    | undefined;
  /** The desired release channel configuration. */
  desiredReleaseChannel:
    | ReleaseChannel
    | undefined;
  /** The desired L4 Internal Load Balancer Subsetting configuration. */
  desiredL4ilbSubsettingConfig:
    | ILBSubsettingConfig
    | undefined;
  /** The desired datapath provider for the cluster. */
  desiredDatapathProvider: DatapathProvider;
  /** The desired state of IPv6 connectivity to Google Services. */
  desiredPrivateIpv6GoogleAccess: PrivateIPv6GoogleAccess;
  /** The desired notification configuration. */
  desiredNotificationConfig:
    | NotificationConfig
    | undefined;
  /** The desired authenticator groups config for the cluster. */
  desiredAuthenticatorGroupsConfig:
    | AuthenticatorGroupsConfig
    | undefined;
  /** The desired logging configuration. */
  desiredLoggingConfig:
    | LoggingConfig
    | undefined;
  /** The desired monitoring configuration. */
  desiredMonitoringConfig:
    | MonitoringConfig
    | undefined;
  /** The desired Identity Service component configuration. */
  desiredIdentityServiceConfig:
    | IdentityServiceConfig
    | undefined;
  /**
   * ServiceExternalIPsConfig specifies the config for the use of Services with
   * ExternalIPs field.
   */
  desiredServiceExternalIpsConfig:
    | ServiceExternalIPsConfig
    | undefined;
  /** Enable/Disable private endpoint for the cluster's master. */
  desiredEnablePrivateEndpoint?:
    | boolean
    | undefined;
  /**
   * The Kubernetes version to change the master to.
   *
   * Users may specify either explicit versions offered by
   * Kubernetes Engine or version aliases, which have the following behavior:
   *
   * - "latest": picks the highest valid Kubernetes version
   * - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
   * - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
   * - "1.X.Y-gke.N": picks an explicit Kubernetes version
   * - "-": picks the default Kubernetes version
   */
  desiredMasterVersion: string;
  /** The desired GCFS config for the cluster */
  desiredGcfsConfig:
    | GcfsConfig
    | undefined;
  /**
   * The desired network tags that apply to all auto-provisioned node pools
   * in autopilot clusters and node auto-provisioning enabled clusters.
   */
  desiredNodePoolAutoConfigNetworkTags:
    | NetworkTags
    | undefined;
  /** The desired config of Gateway API on this cluster. */
  desiredGatewayApiConfig:
    | GatewayAPIConfig
    | undefined;
  /**
   * The current etag of the cluster.
   * If an etag is provided and does not match the current etag of the cluster,
   * update will be blocked and an ABORTED error will be returned.
   */
  etag: string;
  /** The desired node pool logging configuration defaults for the cluster. */
  desiredNodePoolLoggingConfig:
    | NodePoolLoggingConfig
    | undefined;
  /** The desired fleet configuration for the cluster. */
  desiredFleet:
    | Fleet
    | undefined;
  /**
   * The desired stack type of the cluster.
   * If a stack type is provided and does not match the current stack type of
   * the cluster, update will attempt to change the stack type to the new type.
   */
  desiredStackType: StackType;
  /**
   * The additional pod ranges to be added to the cluster. These pod ranges
   * can be used by node pools to allocate pod IPs.
   */
  additionalPodRangesConfig:
    | AdditionalPodRangesConfig
    | undefined;
  /**
   * The additional pod ranges that are to be removed from the cluster.
   * The pod ranges specified here must have been specified earlier in the
   * 'additional_pod_ranges_config' argument.
   */
  removedAdditionalPodRangesConfig:
    | AdditionalPodRangesConfig
    | undefined;
  /** Kubernetes open source beta apis enabled on the cluster. Only beta apis */
  enableK8sBetaApis:
    | K8sBetaAPIConfig
    | undefined;
  /** Enable/Disable Security Posture API features for the cluster. */
  desiredSecurityPostureConfig:
    | SecurityPostureConfig
    | undefined;
  /** The desired network performance config. */
  desiredNetworkPerformanceConfig:
    | NetworkConfig_ClusterNetworkPerformanceConfig
    | undefined;
  /** Enable/Disable FQDN Network Policy for the cluster. */
  desiredEnableFqdnNetworkPolicy?:
    | boolean
    | undefined;
  /** The desired workload policy configuration for the autopilot cluster. */
  desiredAutopilotWorkloadPolicyConfig:
    | WorkloadPolicyConfig
    | undefined;
  /** Desired Beta APIs to be enabled for cluster. */
  desiredK8sBetaApis:
    | K8sBetaAPIConfig
    | undefined;
  /** The desired containerd config for the cluster. */
  desiredContainerdConfig:
    | ContainerdConfig
    | undefined;
  /** Enable/Disable Multi-Networking for the cluster */
  desiredEnableMultiNetworking?:
    | boolean
    | undefined;
  /**
   * The desired resource manager tags that apply to all auto-provisioned node
   * pools in autopilot clusters and node auto-provisioning enabled clusters.
   */
  desiredNodePoolAutoConfigResourceManagerTags:
    | ResourceManagerTags
    | undefined;
  /** Specify the details of in-transit encryption. */
  desiredInTransitEncryptionConfig?:
    | InTransitEncryptionConfig
    | undefined;
  /** Enable/Disable Cilium Clusterwide Network Policy for the cluster. */
  desiredEnableCiliumClusterwideNetworkPolicy?:
    | boolean
    | undefined;
  /** The desired node kubelet config for the cluster. */
  desiredNodeKubeletConfig:
    | NodeKubeletConfig
    | undefined;
  /**
   * The desired node kubelet config for all auto-provisioned node pools
   * in autopilot clusters and node auto-provisioning enabled clusters.
   */
  desiredNodePoolAutoConfigKubeletConfig: NodeKubeletConfig | undefined;
}

/**
 * AdditionalPodRangesConfig is the configuration for additional pod secondary
 * ranges supporting the ClusterUpdate message.
 */
export interface AdditionalPodRangesConfig {
  /** Name for pod secondary ipv4 range which has the actual range defined ahead. */
  podRangeNames: string[];
  /** Output only. Information for additional pod range. */
  podRangeInfo: RangeInfo[];
}

/** RangeInfo contains the range name and the range utilization by this cluster. */
export interface RangeInfo {
  /** Output only. Name of a range. */
  rangeName: string;
  /** Output only. The utilization of the range. */
  utilization: number;
}

/**
 * This operation resource represents operations that may have happened or are
 * happening on the cluster. All fields are output only.
 */
export interface Operation {
  /** Output only. The server-assigned ID for the operation. */
  name: string;
  /**
   * Output only. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * operation is taking place. This field is deprecated, use location instead.
   *
   * @deprecated
   */
  zone: string;
  /** Output only. The operation type. */
  operationType: Operation_Type;
  /** Output only. The current status of the operation. */
  status: Operation_Status;
  /** Output only. Detailed operation progress, if available. */
  detail: string;
  /**
   * Output only. If an error has occurred, a textual description of the error.
   * Deprecated. Use the field error instead.
   *
   * @deprecated
   */
  statusMessage: string;
  /**
   * Output only. Server-defined URI for the operation. Example:
   * `https://container.googleapis.com/v1alpha1/projects/123/locations/us-central1/operations/operation-123`.
   */
  selfLink: string;
  /**
   * Output only. Server-defined URI for the target of the operation. The format
   * of this is a URI to the resource being modified (such as a cluster, node
   * pool, or node). For node pool repairs, there may be multiple nodes being
   * repaired, but only one will be the target.
   *
   * Examples:
   *
   * -
   * ##
   * `https://container.googleapis.com/v1/projects/123/locations/us-central1/clusters/my-cluster`
   *
   * ##
   * `https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np`
   *
   * `https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np/node/my-node`
   */
  targetLink: string;
  /**
   * Output only. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
   * or
   * [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
   * in which the cluster resides.
   */
  location: string;
  /**
   * Output only. The time the operation started, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  startTime: string;
  /**
   * Output only. The time the operation completed, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  endTime: string;
  /** Output only. Progress information for an operation. */
  progress:
    | OperationProgress
    | undefined;
  /**
   * Which conditions caused the current cluster state.
   * Deprecated. Use field error instead.
   *
   * @deprecated
   */
  clusterConditions: StatusCondition[];
  /**
   * Which conditions caused the current node pool state.
   * Deprecated. Use field error instead.
   *
   * @deprecated
   */
  nodepoolConditions: StatusCondition[];
  /** The error result of the operation in case of failure. */
  error: Status | undefined;
}

/** Current status of the operation. */
export enum Operation_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PENDING - The operation has been created. */
  PENDING = 1,
  /** RUNNING - The operation is currently running. */
  RUNNING = 2,
  /** DONE - The operation is done, either cancelled or completed. */
  DONE = 3,
  /** ABORTING - The operation is aborting. */
  ABORTING = 4,
  UNRECOGNIZED = -1,
}

export function operation_StatusFromJSON(object: any): Operation_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Operation_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Operation_Status.PENDING;
    case 2:
    case "RUNNING":
      return Operation_Status.RUNNING;
    case 3:
    case "DONE":
      return Operation_Status.DONE;
    case 4:
    case "ABORTING":
      return Operation_Status.ABORTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Status.UNRECOGNIZED;
  }
}

export function operation_StatusToJSON(object: Operation_Status): string {
  switch (object) {
    case Operation_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Operation_Status.PENDING:
      return "PENDING";
    case Operation_Status.RUNNING:
      return "RUNNING";
    case Operation_Status.DONE:
      return "DONE";
    case Operation_Status.ABORTING:
      return "ABORTING";
    case Operation_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Operation type categorizes the operation. */
export enum Operation_Type {
  /** TYPE_UNSPECIFIED - Not set. */
  TYPE_UNSPECIFIED = 0,
  /**
   * CREATE_CLUSTER - The cluster is being created. The cluster should be assumed to be
   * unusable until the operation finishes.
   *
   * In the event of the operation failing, the cluster will enter the [ERROR
   * state][Cluster.Status.ERROR] and eventually be deleted.
   */
  CREATE_CLUSTER = 1,
  /**
   * DELETE_CLUSTER - The cluster is being deleted. The cluster should be assumed to be
   * unusable as soon as this operation starts.
   *
   * In the event of the operation failing, the cluster will enter the [ERROR
   * state][Cluster.Status.ERROR] and the deletion will be automatically
   * retried until completed.
   */
  DELETE_CLUSTER = 2,
  /**
   * UPGRADE_MASTER - The [cluster
   * version][google.container.v1.ClusterUpdate.desired_master_version] is
   * being updated. Note that this includes "upgrades" to the same version,
   * which are simply a recreation. This also includes
   * [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically).
   * For more details, see [documentation on cluster
   * upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades).
   */
  UPGRADE_MASTER = 3,
  /**
   * UPGRADE_NODES - A node pool is being updated. Despite calling this an "upgrade", this
   * includes most forms of updates to node pools. This also includes
   * [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades).
   *
   * This operation sets the
   * [progress][google.container.v1.Operation.progress] field and may be
   * [canceled][google.container.v1.ClusterManager.CancelOperation].
   *
   * The upgrade strategy depends on [node pool
   * configuration](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies).
   * The nodes are generally still usable during this operation.
   */
  UPGRADE_NODES = 4,
  /**
   * REPAIR_CLUSTER - A problem has been detected with the control plane and is being repaired.
   * This operation type is initiated by GKE. For more details, see
   * [documentation on
   * repairs](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
   */
  REPAIR_CLUSTER = 5,
  /**
   * UPDATE_CLUSTER - The cluster is being updated. This is a broad category of operations and
   * includes operations that only change metadata as well as those that must
   * recreate the entire cluster. If the control plane must be recreated, this
   * will cause temporary downtime for zonal clusters.
   *
   * Some features require recreating the nodes as well. Those will be
   * recreated as separate operations and the update may not be completely
   * functional until the node pools recreations finish. Node recreations will
   * generally follow [maintenance
   * policies](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions).
   *
   * Some GKE-initiated operations use this type. This includes certain types
   * of auto-upgrades and incident mitigations.
   */
  UPDATE_CLUSTER = 6,
  /**
   * CREATE_NODE_POOL - A node pool is being created. The node pool should be assumed to be
   * unusable until this operation finishes. In the event of an error, the
   * node pool may be partially created.
   *
   * If enabled, [node
   * autoprovisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
   * may have automatically initiated such operations.
   */
  CREATE_NODE_POOL = 7,
  /**
   * DELETE_NODE_POOL - The node pool is being deleted. The node pool should be assumed to be
   * unusable as soon as this operation starts.
   */
  DELETE_NODE_POOL = 8,
  /**
   * SET_NODE_POOL_MANAGEMENT - The node pool's [manamagent][google.container.v1.NodePool.management]
   * field is being updated. These operations only update metadata and may be
   * concurrent with most other operations.
   */
  SET_NODE_POOL_MANAGEMENT = 9,
  /**
   * AUTO_REPAIR_NODES - A problem has been detected with nodes and [they are being
   * repaired](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair).
   * This operation type is initiated by GKE, typically automatically. This
   * operation may be concurrent with other operations and there may be
   * multiple repairs occurring on the same node pool.
   */
  AUTO_REPAIR_NODES = 10,
  /**
   * AUTO_UPGRADE_NODES - Unused. Automatic node upgrade uses
   * [UPGRADE_NODES][google.container.v1.Operation.Type.UPGRADE_NODES].
   *
   * @deprecated
   */
  AUTO_UPGRADE_NODES = 11,
  /**
   * SET_LABELS - Unused. Updating labels uses
   * [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
   *
   * @deprecated
   */
  SET_LABELS = 12,
  /**
   * SET_MASTER_AUTH - Unused. Updating master auth uses
   * [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
   *
   * @deprecated
   */
  SET_MASTER_AUTH = 13,
  /**
   * SET_NODE_POOL_SIZE - The node pool is being resized. With the exception of resizing to or from
   * size zero, the node pool is generally usable during this operation.
   */
  SET_NODE_POOL_SIZE = 14,
  /**
   * SET_NETWORK_POLICY - Unused. Updating network policy uses
   * [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
   *
   * @deprecated
   */
  SET_NETWORK_POLICY = 15,
  /**
   * SET_MAINTENANCE_POLICY - Unused. Updating maintenance policy uses
   * [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
   *
   * @deprecated
   */
  SET_MAINTENANCE_POLICY = 16,
  /**
   * RESIZE_CLUSTER - The control plane is being resized. This operation type is initiated by
   * GKE. These operations are often performed preemptively to ensure that the
   * control plane has sufficient resources and is not typically an indication
   * of issues. For more details, see
   * [documentation on
   * resizes](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
   */
  RESIZE_CLUSTER = 18,
  /**
   * FLEET_FEATURE_UPGRADE - Fleet features of GKE Enterprise are being upgraded. The cluster should
   * be assumed to be blocked for other upgrades until the operation finishes.
   */
  FLEET_FEATURE_UPGRADE = 19,
  UNRECOGNIZED = -1,
}

export function operation_TypeFromJSON(object: any): Operation_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Operation_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CREATE_CLUSTER":
      return Operation_Type.CREATE_CLUSTER;
    case 2:
    case "DELETE_CLUSTER":
      return Operation_Type.DELETE_CLUSTER;
    case 3:
    case "UPGRADE_MASTER":
      return Operation_Type.UPGRADE_MASTER;
    case 4:
    case "UPGRADE_NODES":
      return Operation_Type.UPGRADE_NODES;
    case 5:
    case "REPAIR_CLUSTER":
      return Operation_Type.REPAIR_CLUSTER;
    case 6:
    case "UPDATE_CLUSTER":
      return Operation_Type.UPDATE_CLUSTER;
    case 7:
    case "CREATE_NODE_POOL":
      return Operation_Type.CREATE_NODE_POOL;
    case 8:
    case "DELETE_NODE_POOL":
      return Operation_Type.DELETE_NODE_POOL;
    case 9:
    case "SET_NODE_POOL_MANAGEMENT":
      return Operation_Type.SET_NODE_POOL_MANAGEMENT;
    case 10:
    case "AUTO_REPAIR_NODES":
      return Operation_Type.AUTO_REPAIR_NODES;
    case 11:
    case "AUTO_UPGRADE_NODES":
      return Operation_Type.AUTO_UPGRADE_NODES;
    case 12:
    case "SET_LABELS":
      return Operation_Type.SET_LABELS;
    case 13:
    case "SET_MASTER_AUTH":
      return Operation_Type.SET_MASTER_AUTH;
    case 14:
    case "SET_NODE_POOL_SIZE":
      return Operation_Type.SET_NODE_POOL_SIZE;
    case 15:
    case "SET_NETWORK_POLICY":
      return Operation_Type.SET_NETWORK_POLICY;
    case 16:
    case "SET_MAINTENANCE_POLICY":
      return Operation_Type.SET_MAINTENANCE_POLICY;
    case 18:
    case "RESIZE_CLUSTER":
      return Operation_Type.RESIZE_CLUSTER;
    case 19:
    case "FLEET_FEATURE_UPGRADE":
      return Operation_Type.FLEET_FEATURE_UPGRADE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Operation_Type.UNRECOGNIZED;
  }
}

export function operation_TypeToJSON(object: Operation_Type): string {
  switch (object) {
    case Operation_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Operation_Type.CREATE_CLUSTER:
      return "CREATE_CLUSTER";
    case Operation_Type.DELETE_CLUSTER:
      return "DELETE_CLUSTER";
    case Operation_Type.UPGRADE_MASTER:
      return "UPGRADE_MASTER";
    case Operation_Type.UPGRADE_NODES:
      return "UPGRADE_NODES";
    case Operation_Type.REPAIR_CLUSTER:
      return "REPAIR_CLUSTER";
    case Operation_Type.UPDATE_CLUSTER:
      return "UPDATE_CLUSTER";
    case Operation_Type.CREATE_NODE_POOL:
      return "CREATE_NODE_POOL";
    case Operation_Type.DELETE_NODE_POOL:
      return "DELETE_NODE_POOL";
    case Operation_Type.SET_NODE_POOL_MANAGEMENT:
      return "SET_NODE_POOL_MANAGEMENT";
    case Operation_Type.AUTO_REPAIR_NODES:
      return "AUTO_REPAIR_NODES";
    case Operation_Type.AUTO_UPGRADE_NODES:
      return "AUTO_UPGRADE_NODES";
    case Operation_Type.SET_LABELS:
      return "SET_LABELS";
    case Operation_Type.SET_MASTER_AUTH:
      return "SET_MASTER_AUTH";
    case Operation_Type.SET_NODE_POOL_SIZE:
      return "SET_NODE_POOL_SIZE";
    case Operation_Type.SET_NETWORK_POLICY:
      return "SET_NETWORK_POLICY";
    case Operation_Type.SET_MAINTENANCE_POLICY:
      return "SET_MAINTENANCE_POLICY";
    case Operation_Type.RESIZE_CLUSTER:
      return "RESIZE_CLUSTER";
    case Operation_Type.FLEET_FEATURE_UPGRADE:
      return "FLEET_FEATURE_UPGRADE";
    case Operation_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about operation (or operation stage) progress. */
export interface OperationProgress {
  /**
   * A non-parameterized string describing an operation stage.
   * Unset for single-stage operations.
   */
  name: string;
  /**
   * Status of an operation stage.
   * Unset for single-stage operations.
   */
  status: Operation_Status;
  /**
   * Progress metric bundle, for example:
   *   metrics: [{name: "nodes done",     int_value: 15},
   *             {name: "nodes total",    int_value: 32}]
   * or
   *   metrics: [{name: "progress",       double_value: 0.56},
   *             {name: "progress scale", double_value: 1.0}]
   */
  metrics: OperationProgress_Metric[];
  /** Substages of an operation or a stage. */
  stages: OperationProgress[];
}

/** Progress metric is (string, int|float|string) pair. */
export interface OperationProgress_Metric {
  /** Required. Metric name, e.g., "nodes total", "percent done". */
  name: string;
  /** For metrics with integer value. */
  intValue?:
    | Long
    | undefined;
  /** For metrics with floating point value. */
  doubleValue?:
    | number
    | undefined;
  /** For metrics with custom values (ratios, visual progress, etc.). */
  stringValue?: string | undefined;
}

/** CreateClusterRequest creates a cluster. */
export interface CreateClusterRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the parent
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Required. A [cluster
   * resource](https://cloud.google.com/container-engine/reference/rest/v1/projects.locations.clusters)
   */
  cluster:
    | Cluster
    | undefined;
  /**
   * The parent (project and location) where the cluster will be created.
   * Specified in the format `projects/* /locations/*`.
   */
  parent: string;
}

/** GetClusterRequest gets the settings of a cluster. */
export interface GetClusterRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to retrieve.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * The name (project, location, cluster) of the cluster to retrieve.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** UpdateClusterRequest updates the settings of a cluster. */
export interface UpdateClusterRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. A description of the update. */
  update:
    | ClusterUpdate
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** UpdateNodePoolRequests update a node pool's image and/or version. */
export interface UpdateNodePoolRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /**
   * Required. The Kubernetes version to change the nodes to (typically an
   * upgrade).
   *
   * Users may specify either explicit versions offered by Kubernetes Engine or
   * version aliases, which have the following behavior:
   *
   * - "latest": picks the highest valid Kubernetes version
   * - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
   * - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
   * - "1.X.Y-gke.N": picks an explicit Kubernetes version
   * - "-": picks the Kubernetes master version
   */
  nodeVersion: string;
  /**
   * Required. The desired image type for the node pool. Please see
   * https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
   * available image types.
   */
  imageType: string;
  /**
   * The name (project, location, cluster, node pool) of the node pool to
   * update. Specified in the format
   * `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
  /**
   * The desired list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * node pool's nodes should be located. Changing the locations for a node pool
   * will result in nodes being either created or removed from the node pool,
   * depending on whether locations are being added or removed.
   */
  locations: string[];
  /** The desired workload metadata config for the node pool. */
  workloadMetadataConfig:
    | WorkloadMetadataConfig
    | undefined;
  /** Upgrade settings control disruption and speed of the upgrade. */
  upgradeSettings:
    | NodePool_UpgradeSettings
    | undefined;
  /**
   * The desired network tags to be applied to all nodes in the node pool.
   * If this field is not present, the tags will not be changed. Otherwise,
   * the existing network tags will be *replaced* with the provided tags.
   */
  tags:
    | NetworkTags
    | undefined;
  /**
   * The desired node taints to be applied to all nodes in the node pool.
   * If this field is not present, the taints will not be changed. Otherwise,
   * the existing node taints will be *replaced* with the provided taints.
   */
  taints:
    | NodeTaints
    | undefined;
  /**
   * The desired node labels to be applied to all nodes in the node pool.
   * If this field is not present, the labels will not be changed. Otherwise,
   * the existing node labels will be *replaced* with the provided labels.
   */
  labels:
    | NodeLabels
    | undefined;
  /** Parameters that can be configured on Linux nodes. */
  linuxNodeConfig:
    | LinuxNodeConfig
    | undefined;
  /** Node kubelet configs. */
  kubeletConfig:
    | NodeKubeletConfig
    | undefined;
  /** Node network config. */
  nodeNetworkConfig:
    | NodeNetworkConfig
    | undefined;
  /** GCFS config. */
  gcfsConfig:
    | GcfsConfig
    | undefined;
  /**
   * Confidential nodes config.
   * All the nodes in the node pool will be Confidential VM once enabled.
   */
  confidentialNodes:
    | ConfidentialNodes
    | undefined;
  /** Enable or disable gvnic on the node pool. */
  gvnic:
    | VirtualNIC
    | undefined;
  /**
   * The current etag of the node pool.
   * If an etag is provided and does not match the current etag of the node
   * pool, update will be blocked and an ABORTED error will be returned.
   */
  etag: string;
  /** Enable or disable NCCL fast socket for the node pool. */
  fastSocket:
    | FastSocket
    | undefined;
  /** Logging configuration. */
  loggingConfig:
    | NodePoolLoggingConfig
    | undefined;
  /**
   * The resource labels for the node pool to use to annotate any related
   * Google Compute Engine resources.
   */
  resourceLabels:
    | ResourceLabels
    | undefined;
  /** Parameters that can be configured on Windows nodes. */
  windowsNodeConfig:
    | WindowsNodeConfig
    | undefined;
  /**
   * A list of hardware accelerators to be attached to each node.
   * See https://cloud.google.com/compute/docs/gpus for more information about
   * support for GPUs.
   */
  accelerators: AcceleratorConfig[];
  /**
   * Optional. The desired [Google Compute Engine machine
   * type](https://cloud.google.com/compute/docs/machine-types) for nodes in the
   * node pool. Initiates an upgrade operation that migrates the nodes in the
   * node pool to the specified machine type.
   */
  machineType: string;
  /**
   * Optional. The desired disk type (e.g. 'pd-standard', 'pd-ssd' or
   * 'pd-balanced') for nodes in the node pool.
   * Initiates an upgrade operation that migrates the nodes in the
   * node pool to the specified disk type.
   */
  diskType: string;
  /**
   * Optional. The desired disk size for nodes in the node pool specified in GB.
   * The smallest allowed disk size is 10GB.
   * Initiates an upgrade operation that migrates the nodes in the
   * node pool to the specified disk size.
   */
  diskSizeGb: Long;
  /**
   * Desired resource manager tag keys and values to be attached to the nodes
   * for managing Compute Engine firewalls using Network Firewall Policies.
   * Existing tags will be replaced with new values.
   */
  resourceManagerTags:
    | ResourceManagerTags
    | undefined;
  /**
   * The desired containerd config for nodes in the node pool.
   * Initiates an upgrade operation that recreates the nodes with the new
   * config.
   */
  containerdConfig:
    | ContainerdConfig
    | undefined;
  /** Specifies the configuration of queued provisioning. */
  queuedProvisioning: NodePool_QueuedProvisioning | undefined;
}

/** SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool. */
export interface SetNodePoolAutoscalingRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /** Required. Autoscaling configuration for the node pool. */
  autoscaling:
    | NodePoolAutoscaling
    | undefined;
  /**
   * The name (project, location, cluster, node pool) of the node pool to set
   * autoscaler settings. Specified in the format
   * `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/** SetLoggingServiceRequest sets the logging service of a cluster. */
export interface SetLoggingServiceRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Required. The logging service the cluster should use to write logs.
   * Currently available options:
   *
   * * `logging.googleapis.com/kubernetes` - The Cloud Logging
   * service with a Kubernetes-native resource model
   * * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
   *   available as of GKE 1.15).
   * * `none` - no logs will be exported from the cluster.
   *
   * If left as an empty string,`logging.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
   */
  loggingService: string;
  /**
   * The name (project, location, cluster) of the cluster to set logging.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** SetMonitoringServiceRequest sets the monitoring service of a cluster. */
export interface SetMonitoringServiceRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Required. The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com/kubernetes" - The Cloud Monitoring
   * service with a Kubernetes-native resource model
   * * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
   *   longer available as of GKE 1.15).
   * * `none` - No metrics will be exported from the cluster.
   *
   * If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
   * used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
   */
  monitoringService: string;
  /**
   * The name (project, location, cluster) of the cluster to set monitoring.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** SetAddonsConfigRequest sets the addons associated with the cluster. */
export interface SetAddonsConfigRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Required. The desired configurations for the various addons available to
   * run in the cluster.
   */
  addonsConfig:
    | AddonsConfig
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to set addons.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** SetLocationsRequest sets the locations of the cluster. */
export interface SetLocationsRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Required. The desired list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster's nodes should be located. Changing the locations a cluster is in
   * will result in nodes being either created or removed from the cluster,
   * depending on whether locations are being added or removed.
   *
   * This list must always include the cluster's primary zone.
   */
  locations: string[];
  /**
   * The name (project, location, cluster) of the cluster to set locations.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** UpdateMasterRequest updates the master of the cluster. */
export interface UpdateMasterRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Required. The Kubernetes version to change the master to.
   *
   * Users may specify either explicit versions offered by Kubernetes Engine or
   * version aliases, which have the following behavior:
   *
   * - "latest": picks the highest valid Kubernetes version
   * - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
   * - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
   * - "1.X.Y-gke.N": picks an explicit Kubernetes version
   * - "-": picks the default Kubernetes version
   */
  masterVersion: string;
  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** SetMasterAuthRequest updates the admin password of a cluster. */
export interface SetMasterAuthRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to upgrade.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. The exact form of action to be taken on the master auth. */
  action: SetMasterAuthRequest_Action;
  /** Required. A description of the update. */
  update:
    | MasterAuth
    | undefined;
  /**
   * The name (project, location, cluster) of the cluster to set auth.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** Operation type: what type update to perform. */
export enum SetMasterAuthRequest_Action {
  /** UNKNOWN - Operation is unknown and will error out. */
  UNKNOWN = 0,
  /** SET_PASSWORD - Set the password to a user generated value. */
  SET_PASSWORD = 1,
  /** GENERATE_PASSWORD - Generate a new password and set it to that. */
  GENERATE_PASSWORD = 2,
  /**
   * SET_USERNAME - Set the username.  If an empty username is provided, basic authentication
   * is disabled for the cluster.  If a non-empty username is provided, basic
   * authentication is enabled, with either a provided password or a generated
   * one.
   */
  SET_USERNAME = 3,
  UNRECOGNIZED = -1,
}

export function setMasterAuthRequest_ActionFromJSON(object: any): SetMasterAuthRequest_Action {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return SetMasterAuthRequest_Action.UNKNOWN;
    case 1:
    case "SET_PASSWORD":
      return SetMasterAuthRequest_Action.SET_PASSWORD;
    case 2:
    case "GENERATE_PASSWORD":
      return SetMasterAuthRequest_Action.GENERATE_PASSWORD;
    case 3:
    case "SET_USERNAME":
      return SetMasterAuthRequest_Action.SET_USERNAME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SetMasterAuthRequest_Action.UNRECOGNIZED;
  }
}

export function setMasterAuthRequest_ActionToJSON(object: SetMasterAuthRequest_Action): string {
  switch (object) {
    case SetMasterAuthRequest_Action.UNKNOWN:
      return "UNKNOWN";
    case SetMasterAuthRequest_Action.SET_PASSWORD:
      return "SET_PASSWORD";
    case SetMasterAuthRequest_Action.GENERATE_PASSWORD:
      return "GENERATE_PASSWORD";
    case SetMasterAuthRequest_Action.SET_USERNAME:
      return "SET_USERNAME";
    case SetMasterAuthRequest_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DeleteClusterRequest deletes a cluster. */
export interface DeleteClusterRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to delete.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * The name (project, location, cluster) of the cluster to delete.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** ListClustersRequest lists clusters. */
export interface ListClustersRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides, or "-" for all zones. This field has been deprecated and
   * replaced by the parent field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * The parent (project and location) where the clusters will be listed.
   * Specified in the format `projects/* /locations/*`.
   * Location "-" matches all zones and all regions.
   */
  parent: string;
}

/** ListClustersResponse is the result of ListClustersRequest. */
export interface ListClustersResponse {
  /**
   * A list of clusters in the project in the specified zone, or
   * across all ones.
   */
  clusters: Cluster[];
  /**
   * If any zones are listed here, the list of clusters returned
   * may be missing those zones.
   */
  missingZones: string[];
}

/** GetOperationRequest gets a single operation. */
export interface GetOperationRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The server-assigned `name` of the operation.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  operationId: string;
  /**
   * The name (project, location, operation id) of the operation to get.
   * Specified in the format `projects/* /locations/* /operations/*`.
   */
  name: string;
}

/** ListOperationsRequest lists operations. */
export interface ListOperationsRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) to return
   * operations for, or `-` for all zones. This field has been deprecated and
   * replaced by the parent field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * The parent (project and location) where the operations will be listed.
   * Specified in the format `projects/* /locations/*`.
   * Location "-" matches all zones and all regions.
   */
  parent: string;
}

/** CancelOperationRequest cancels a single operation. */
export interface CancelOperationRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * operation resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The server-assigned `name` of the operation.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  operationId: string;
  /**
   * The name (project, location, operation id) of the operation to cancel.
   * Specified in the format `projects/* /locations/* /operations/*`.
   */
  name: string;
}

/** ListOperationsResponse is the result of ListOperationsRequest. */
export interface ListOperationsResponse {
  /** A list of operations in the project in the specified zone. */
  operations: Operation[];
  /**
   * If any zones are listed here, the list of operations returned
   * may be missing the operations from those zones.
   */
  missingZones: string[];
}

/** Gets the current Kubernetes Engine service configuration. */
export interface GetServerConfigRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) to return
   * operations for. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * The name (project and location) of the server config to get,
   * specified in the format `projects/* /locations/*`.
   */
  name: string;
}

/** Kubernetes Engine service configuration. */
export interface ServerConfig {
  /** Version of Kubernetes the service deploys by default. */
  defaultClusterVersion: string;
  /** List of valid node upgrade target versions, in descending order. */
  validNodeVersions: string[];
  /** Default image type. */
  defaultImageType: string;
  /** List of valid image types. */
  validImageTypes: string[];
  /** List of valid master versions, in descending order. */
  validMasterVersions: string[];
  /** List of release channel configurations. */
  channels: ServerConfig_ReleaseChannelConfig[];
}

/** ReleaseChannelConfig exposes configuration for a release channel. */
export interface ServerConfig_ReleaseChannelConfig {
  /** The release channel this configuration applies to. */
  channel: ReleaseChannel_Channel;
  /** The default version for newly created clusters on the channel. */
  defaultVersion: string;
  /** List of valid versions for the channel. */
  validVersions: string[];
}

/** CreateNodePoolRequest creates a node pool for a cluster. */
export interface CreateNodePoolRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the parent
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. The node pool to create. */
  nodePool:
    | NodePool
    | undefined;
  /**
   * The parent (project, location, cluster name) where the node pool will be
   * created. Specified in the format
   * `projects/* /locations/* /clusters/*`.
   */
  parent: string;
}

/** DeleteNodePoolRequest deletes a node pool for a cluster. */
export interface DeleteNodePoolRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to delete.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to
   * delete. Specified in the format
   * `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/** ListNodePoolsRequest lists the node pool(s) for a cluster. */
export interface ListNodePoolsRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the parent
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the parent field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * The parent (project, location, cluster name) where the node pools will be
   * listed. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  parent: string;
}

/** GetNodePoolRequest retrieves a node pool for a cluster. */
export interface GetNodePoolRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to
   * get. Specified in the format
   * `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/** Settings for blue-green upgrade. */
export interface BlueGreenSettings {
  /** Standard policy for the blue-green upgrade. */
  standardRolloutPolicy?:
    | BlueGreenSettings_StandardRolloutPolicy
    | undefined;
  /**
   * Time needed after draining entire blue pool. After this period, blue pool
   * will be cleaned up.
   */
  nodePoolSoakDuration?: Duration | undefined;
}

/** Standard rollout policy is the default policy for blue-green. */
export interface BlueGreenSettings_StandardRolloutPolicy {
  /**
   * Percentage of the blue pool nodes to drain in a batch.
   * The range of this field should be (0.0, 1.0].
   */
  batchPercentage?:
    | number
    | undefined;
  /** Number of blue nodes to drain in a batch. */
  batchNodeCount?:
    | number
    | undefined;
  /** Soak time after each batch gets drained. Default to zero. */
  batchSoakDuration?: Duration | undefined;
}

/**
 * NodePool contains the name and configuration for a cluster's node pool.
 * Node pools are a set of nodes (i.e. VM's), with a common configuration and
 * specification, under the control of the cluster master. They may have a set
 * of Kubernetes labels applied to them, which may be used to reference them
 * during pod scheduling. They may also be resized up or down, to accommodate
 * the workload.
 */
export interface NodePool {
  /** The name of the node pool. */
  name: string;
  /** The node configuration of the pool. */
  config:
    | NodeConfig
    | undefined;
  /**
   * The initial node count for the pool. You must ensure that your
   * Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   */
  initialNodeCount: number;
  /**
   * The list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * NodePool's nodes should be located.
   *
   * If this value is unspecified during node pool creation, the
   * [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations)
   * value will be used, instead.
   *
   * Warning: changing node pool locations will result in nodes being added
   * and/or removed.
   */
  locations: string[];
  /**
   * Networking configuration for this NodePool. If specified, it overrides the
   * cluster-level defaults.
   */
  networkConfig:
    | NodeNetworkConfig
    | undefined;
  /** Output only. Server-defined URL for the resource. */
  selfLink: string;
  /**
   * The version of Kubernetes running on this NodePool's nodes. If unspecified,
   * it defaults as described
   * [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
   */
  version: string;
  /**
   * Output only. The resource URLs of the [managed instance
   * groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
   * associated with this node pool.
   * During the node pool blue-green upgrade operation, the URLs contain both
   * blue and green resources.
   */
  instanceGroupUrls: string[];
  /** Output only. The status of the nodes in this pool instance. */
  status: NodePool_Status;
  /**
   * Output only. Deprecated. Use conditions instead.
   * Additional information about the current status of this
   * node pool instance, if available.
   *
   * @deprecated
   */
  statusMessage: string;
  /**
   * Autoscaler configuration for this NodePool. Autoscaler is enabled
   * only if a valid configuration is present.
   */
  autoscaling:
    | NodePoolAutoscaling
    | undefined;
  /** NodeManagement configuration for this NodePool. */
  management:
    | NodeManagement
    | undefined;
  /**
   * The constraint on the maximum number of pods that can be run
   * simultaneously on a node in the node pool.
   */
  maxPodsConstraint:
    | MaxPodsConstraint
    | undefined;
  /** Which conditions caused the current node pool state. */
  conditions: StatusCondition[];
  /** Output only. The pod CIDR block size per node in this node pool. */
  podIpv4CidrSize: number;
  /** Upgrade settings control disruption and speed of the upgrade. */
  upgradeSettings:
    | NodePool_UpgradeSettings
    | undefined;
  /** Specifies the node placement policy. */
  placementPolicy:
    | NodePool_PlacementPolicy
    | undefined;
  /**
   * Output only. Update info contains relevant information during a node
   * pool update.
   */
  updateInfo:
    | NodePool_UpdateInfo
    | undefined;
  /**
   * This checksum is computed by the server based on the value of node pool
   * fields, and may be sent on update requests to ensure the client has an
   * up-to-date value before proceeding.
   */
  etag: string;
  /** Specifies the configuration of queued provisioning. */
  queuedProvisioning:
    | NodePool_QueuedProvisioning
    | undefined;
  /** Enable best effort provisioning for nodes */
  bestEffortProvisioning: BestEffortProvisioning | undefined;
}

/** The current status of the node pool instance. */
export enum NodePool_Status {
  /** STATUS_UNSPECIFIED - Not set. */
  STATUS_UNSPECIFIED = 0,
  /** PROVISIONING - The PROVISIONING state indicates the node pool is being created. */
  PROVISIONING = 1,
  /**
   * RUNNING - The RUNNING state indicates the node pool has been created
   * and is fully usable.
   */
  RUNNING = 2,
  /**
   * RUNNING_WITH_ERROR - The RUNNING_WITH_ERROR state indicates the node pool has been created
   * and is partially usable. Some error state has occurred and some
   * functionality may be impaired. Customer may need to reissue a request
   * or trigger a new update.
   */
  RUNNING_WITH_ERROR = 3,
  /**
   * RECONCILING - The RECONCILING state indicates that some work is actively being done on
   * the node pool, such as upgrading node software. Details can
   * be found in the `statusMessage` field.
   */
  RECONCILING = 4,
  /** STOPPING - The STOPPING state indicates the node pool is being deleted. */
  STOPPING = 5,
  /**
   * ERROR - The ERROR state indicates the node pool may be unusable. Details
   * can be found in the `statusMessage` field.
   */
  ERROR = 6,
  UNRECOGNIZED = -1,
}

export function nodePool_StatusFromJSON(object: any): NodePool_Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return NodePool_Status.STATUS_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return NodePool_Status.PROVISIONING;
    case 2:
    case "RUNNING":
      return NodePool_Status.RUNNING;
    case 3:
    case "RUNNING_WITH_ERROR":
      return NodePool_Status.RUNNING_WITH_ERROR;
    case 4:
    case "RECONCILING":
      return NodePool_Status.RECONCILING;
    case 5:
    case "STOPPING":
      return NodePool_Status.STOPPING;
    case 6:
    case "ERROR":
      return NodePool_Status.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePool_Status.UNRECOGNIZED;
  }
}

export function nodePool_StatusToJSON(object: NodePool_Status): string {
  switch (object) {
    case NodePool_Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case NodePool_Status.PROVISIONING:
      return "PROVISIONING";
    case NodePool_Status.RUNNING:
      return "RUNNING";
    case NodePool_Status.RUNNING_WITH_ERROR:
      return "RUNNING_WITH_ERROR";
    case NodePool_Status.RECONCILING:
      return "RECONCILING";
    case NodePool_Status.STOPPING:
      return "STOPPING";
    case NodePool_Status.ERROR:
      return "ERROR";
    case NodePool_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * These upgrade settings control the level of parallelism and the level of
 * disruption caused by an upgrade.
 *
 * maxUnavailable controls the number of nodes that can be simultaneously
 * unavailable.
 *
 * maxSurge controls the number of additional nodes that can be added to the
 * node pool temporarily for the time of the upgrade to increase the number of
 * available nodes.
 *
 * (maxUnavailable + maxSurge) determines the level of parallelism (how many
 * nodes are being upgraded at the same time).
 *
 * Note: upgrades inevitably introduce some disruption since workloads need to
 * be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0,
 * this holds true. (Disruption stays within the limits of
 * PodDisruptionBudget, if it is configured.)
 *
 * Consider a hypothetical node pool with 5 nodes having maxSurge=2,
 * maxUnavailable=1. This means the upgrade process upgrades 3 nodes
 * simultaneously. It creates 2 additional (upgraded) nodes, then it brings
 * down 3 old (not yet upgraded) nodes at the same time. This ensures that
 * there are always at least 4 nodes available.
 *
 * These upgrade settings configure the upgrade strategy for the node pool.
 * Use strategy to switch between the strategies applied to the node pool.
 *
 * If the strategy is ROLLING, use max_surge and max_unavailable to control
 * the level of parallelism and the level of disruption caused by upgrade.
 * 1. maxSurge controls the number of additional nodes that can be added to
 * the node pool temporarily for the time of the upgrade to increase the
 * number of available nodes.
 * 2. maxUnavailable controls the number of nodes that can be simultaneously
 * unavailable.
 * 3. (maxUnavailable + maxSurge) determines the level of parallelism (how
 * many nodes are being upgraded at the same time).
 *
 * If the strategy is BLUE_GREEN, use blue_green_settings to configure the
 * blue-green upgrade related settings.
 * 1. standard_rollout_policy is the default policy. The policy is used to
 * control the way blue pool gets drained. The draining is executed in the
 * batch mode. The batch size could be specified as either percentage of the
 * node pool size or the number of nodes. batch_soak_duration is the soak
 * time after each batch gets drained.
 * 2. node_pool_soak_duration is the soak time after all blue nodes are
 * drained. After this period, the blue pool nodes will be deleted.
 */
export interface NodePool_UpgradeSettings {
  /**
   * The maximum number of nodes that can be created beyond the current size
   * of the node pool during the upgrade process.
   */
  maxSurge: number;
  /**
   * The maximum number of nodes that can be simultaneously unavailable during
   * the upgrade process. A node is considered available if its status is
   * Ready.
   */
  maxUnavailable: number;
  /** Update strategy of the node pool. */
  strategy?:
    | NodePoolUpdateStrategy
    | undefined;
  /** Settings for blue-green upgrade strategy. */
  blueGreenSettings?: BlueGreenSettings | undefined;
}

/**
 * UpdateInfo contains resource (instance groups, etc), status and other
 * intermediate information relevant to a node pool upgrade.
 */
export interface NodePool_UpdateInfo {
  /** Information of a blue-green upgrade. */
  blueGreenInfo: NodePool_UpdateInfo_BlueGreenInfo | undefined;
}

/** Information relevant to blue-green upgrade. */
export interface NodePool_UpdateInfo_BlueGreenInfo {
  /** Current blue-green upgrade phase. */
  phase: NodePool_UpdateInfo_BlueGreenInfo_Phase;
  /**
   * The resource URLs of the [managed instance groups]
   * (/compute/docs/instance-groups/creating-groups-of-managed-instances)
   * associated with blue pool.
   */
  blueInstanceGroupUrls: string[];
  /**
   * The resource URLs of the [managed instance groups]
   * (/compute/docs/instance-groups/creating-groups-of-managed-instances)
   * associated with green pool.
   */
  greenInstanceGroupUrls: string[];
  /**
   * Time to start deleting blue pool to complete blue-green upgrade,
   * in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  bluePoolDeletionStartTime: string;
  /** Version of green pool. */
  greenPoolVersion: string;
}

/** Phase represents the different stages blue-green upgrade is running in. */
export enum NodePool_UpdateInfo_BlueGreenInfo_Phase {
  /** PHASE_UNSPECIFIED - Unspecified phase. */
  PHASE_UNSPECIFIED = 0,
  /** UPDATE_STARTED - blue-green upgrade has been initiated. */
  UPDATE_STARTED = 1,
  /** CREATING_GREEN_POOL - Start creating green pool nodes. */
  CREATING_GREEN_POOL = 2,
  /** CORDONING_BLUE_POOL - Start cordoning blue pool nodes. */
  CORDONING_BLUE_POOL = 3,
  /** DRAINING_BLUE_POOL - Start draining blue pool nodes. */
  DRAINING_BLUE_POOL = 4,
  /** NODE_POOL_SOAKING - Start soaking time after draining entire blue pool. */
  NODE_POOL_SOAKING = 5,
  /** DELETING_BLUE_POOL - Start deleting blue nodes. */
  DELETING_BLUE_POOL = 6,
  /** ROLLBACK_STARTED - Rollback has been initiated. */
  ROLLBACK_STARTED = 7,
  UNRECOGNIZED = -1,
}

export function nodePool_UpdateInfo_BlueGreenInfo_PhaseFromJSON(object: any): NodePool_UpdateInfo_BlueGreenInfo_Phase {
  switch (object) {
    case 0:
    case "PHASE_UNSPECIFIED":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.PHASE_UNSPECIFIED;
    case 1:
    case "UPDATE_STARTED":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.UPDATE_STARTED;
    case 2:
    case "CREATING_GREEN_POOL":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.CREATING_GREEN_POOL;
    case 3:
    case "CORDONING_BLUE_POOL":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.CORDONING_BLUE_POOL;
    case 4:
    case "DRAINING_BLUE_POOL":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.DRAINING_BLUE_POOL;
    case 5:
    case "NODE_POOL_SOAKING":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.NODE_POOL_SOAKING;
    case 6:
    case "DELETING_BLUE_POOL":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.DELETING_BLUE_POOL;
    case 7:
    case "ROLLBACK_STARTED":
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.ROLLBACK_STARTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePool_UpdateInfo_BlueGreenInfo_Phase.UNRECOGNIZED;
  }
}

export function nodePool_UpdateInfo_BlueGreenInfo_PhaseToJSON(object: NodePool_UpdateInfo_BlueGreenInfo_Phase): string {
  switch (object) {
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.PHASE_UNSPECIFIED:
      return "PHASE_UNSPECIFIED";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.UPDATE_STARTED:
      return "UPDATE_STARTED";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.CREATING_GREEN_POOL:
      return "CREATING_GREEN_POOL";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.CORDONING_BLUE_POOL:
      return "CORDONING_BLUE_POOL";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.DRAINING_BLUE_POOL:
      return "DRAINING_BLUE_POOL";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.NODE_POOL_SOAKING:
      return "NODE_POOL_SOAKING";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.DELETING_BLUE_POOL:
      return "DELETING_BLUE_POOL";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.ROLLBACK_STARTED:
      return "ROLLBACK_STARTED";
    case NodePool_UpdateInfo_BlueGreenInfo_Phase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** PlacementPolicy defines the placement policy used by the node pool. */
export interface NodePool_PlacementPolicy {
  /** The type of placement. */
  type: NodePool_PlacementPolicy_Type;
  /**
   * Optional. TPU placement topology for pod slice node pool.
   * https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies
   */
  tpuTopology: string;
  /**
   * If set, refers to the name of a custom resource policy supplied by the
   * user. The resource policy must be in the same project and region as the
   * node pool. If not found, InvalidArgument error is returned.
   */
  policyName: string;
}

/** Type defines the type of placement policy. */
export enum NodePool_PlacementPolicy_Type {
  /**
   * TYPE_UNSPECIFIED - TYPE_UNSPECIFIED specifies no requirements on nodes
   * placement.
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * COMPACT - COMPACT specifies node placement in the same availability domain to
   * ensure low communication latency.
   */
  COMPACT = 1,
  UNRECOGNIZED = -1,
}

export function nodePool_PlacementPolicy_TypeFromJSON(object: any): NodePool_PlacementPolicy_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return NodePool_PlacementPolicy_Type.TYPE_UNSPECIFIED;
    case 1:
    case "COMPACT":
      return NodePool_PlacementPolicy_Type.COMPACT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePool_PlacementPolicy_Type.UNRECOGNIZED;
  }
}

export function nodePool_PlacementPolicy_TypeToJSON(object: NodePool_PlacementPolicy_Type): string {
  switch (object) {
    case NodePool_PlacementPolicy_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case NodePool_PlacementPolicy_Type.COMPACT:
      return "COMPACT";
    case NodePool_PlacementPolicy_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** QueuedProvisioning defines the queued provisioning used by the node pool. */
export interface NodePool_QueuedProvisioning {
  /**
   * Denotes that this nodepool is QRM specific, meaning nodes can be only
   * obtained through queuing via the Cluster Autoscaler ProvisioningRequest
   * API.
   */
  enabled: boolean;
}

/**
 * NodeManagement defines the set of node management services turned on for the
 * node pool.
 */
export interface NodeManagement {
  /**
   * A flag that specifies whether node auto-upgrade is enabled for the node
   * pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
   * up to date with the latest release version of Kubernetes.
   */
  autoUpgrade: boolean;
  /**
   * A flag that specifies whether the node auto-repair is enabled for the node
   * pool. If enabled, the nodes in this node pool will be monitored and, if
   * they fail health checks too many times, an automatic repair action will be
   * triggered.
   */
  autoRepair: boolean;
  /** Specifies the Auto Upgrade knobs for the node pool. */
  upgradeOptions: AutoUpgradeOptions | undefined;
}

/** Best effort provisioning. */
export interface BestEffortProvisioning {
  /**
   * When this is enabled, cluster/node pool creations will ignore non-fatal
   * errors like stockout to best provision as many nodes as possible right now
   * and eventually bring up all target number of nodes
   */
  enabled: boolean;
  /**
   * Minimum number of nodes to be provisioned to be considered as succeeded,
   * and the rest of nodes will be provisioned gradually and eventually when
   * stockout issue has been resolved.
   */
  minProvisionNodes: number;
}

/**
 * AutoUpgradeOptions defines the set of options for the user to control how
 * the Auto Upgrades will proceed.
 */
export interface AutoUpgradeOptions {
  /**
   * Output only. This field is set when upgrades are about to commence
   * with the approximate start time for the upgrades, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  autoUpgradeStartTime: string;
  /**
   * Output only. This field is set when upgrades are about to commence
   * with the description of the upgrade.
   */
  description: string;
}

/** MaintenancePolicy defines the maintenance policy to be used for the cluster. */
export interface MaintenancePolicy {
  /** Specifies the maintenance window in which maintenance may be performed. */
  window:
    | MaintenanceWindow
    | undefined;
  /**
   * A hash identifying the version of this policy, so that updates to fields of
   * the policy won't accidentally undo intermediate changes (and so that users
   * of the API unaware of some fields won't accidentally remove other fields).
   * Make a `get()` request to the cluster to get the current
   * resource version and include it with requests to set the policy.
   */
  resourceVersion: string;
}

/** MaintenanceWindow defines the maintenance window to be used for the cluster. */
export interface MaintenanceWindow {
  /** DailyMaintenanceWindow specifies a daily maintenance operation window. */
  dailyMaintenanceWindow?:
    | DailyMaintenanceWindow
    | undefined;
  /**
   * RecurringWindow specifies some number of recurring time periods for
   * maintenance to occur. The time windows may be overlapping. If no
   * maintenance windows are set, maintenance can occur at any time.
   */
  recurringWindow?:
    | RecurringTimeWindow
    | undefined;
  /**
   * Exceptions to maintenance window. Non-emergency maintenance should not
   * occur in these windows.
   */
  maintenanceExclusions: { [key: string]: TimeWindow };
}

export interface MaintenanceWindow_MaintenanceExclusionsEntry {
  key: string;
  value: TimeWindow | undefined;
}

/** Represents an arbitrary window of time. */
export interface TimeWindow {
  /**
   * MaintenanceExclusionOptions provides maintenance exclusion related
   * options.
   */
  maintenanceExclusionOptions?:
    | MaintenanceExclusionOptions
    | undefined;
  /** The time that the window first starts. */
  startTime:
    | Date
    | undefined;
  /**
   * The time that the window ends. The end time should take place after the
   * start time.
   */
  endTime: Date | undefined;
}

/** Represents the Maintenance exclusion option. */
export interface MaintenanceExclusionOptions {
  /**
   * Scope specifies the upgrade scope which upgrades are blocked by the
   * exclusion.
   */
  scope: MaintenanceExclusionOptions_Scope;
}

/** Scope of exclusion. */
export enum MaintenanceExclusionOptions_Scope {
  /**
   * NO_UPGRADES - NO_UPGRADES excludes all upgrades, including patch upgrades and minor
   * upgrades across control planes and nodes. This is the default exclusion
   * behavior.
   */
  NO_UPGRADES = 0,
  /**
   * NO_MINOR_UPGRADES - NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only
   * patches are allowed.
   */
  NO_MINOR_UPGRADES = 1,
  /**
   * NO_MINOR_OR_NODE_UPGRADES - NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster,
   * and also exclude all node pool upgrades. Only control
   * plane patches are allowed.
   */
  NO_MINOR_OR_NODE_UPGRADES = 2,
  UNRECOGNIZED = -1,
}

export function maintenanceExclusionOptions_ScopeFromJSON(object: any): MaintenanceExclusionOptions_Scope {
  switch (object) {
    case 0:
    case "NO_UPGRADES":
      return MaintenanceExclusionOptions_Scope.NO_UPGRADES;
    case 1:
    case "NO_MINOR_UPGRADES":
      return MaintenanceExclusionOptions_Scope.NO_MINOR_UPGRADES;
    case 2:
    case "NO_MINOR_OR_NODE_UPGRADES":
      return MaintenanceExclusionOptions_Scope.NO_MINOR_OR_NODE_UPGRADES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MaintenanceExclusionOptions_Scope.UNRECOGNIZED;
  }
}

export function maintenanceExclusionOptions_ScopeToJSON(object: MaintenanceExclusionOptions_Scope): string {
  switch (object) {
    case MaintenanceExclusionOptions_Scope.NO_UPGRADES:
      return "NO_UPGRADES";
    case MaintenanceExclusionOptions_Scope.NO_MINOR_UPGRADES:
      return "NO_MINOR_UPGRADES";
    case MaintenanceExclusionOptions_Scope.NO_MINOR_OR_NODE_UPGRADES:
      return "NO_MINOR_OR_NODE_UPGRADES";
    case MaintenanceExclusionOptions_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents an arbitrary window of time that recurs. */
export interface RecurringTimeWindow {
  /** The window of the first recurrence. */
  window:
    | TimeWindow
    | undefined;
  /**
   * An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how
   * this window reccurs. They go on for the span of time between the start and
   * end time.
   *
   * For example, to have something repeat every weekday, you'd use:
   * `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR`
   *
   * To repeat some window daily (equivalent to the DailyMaintenanceWindow):
   * `FREQ=DAILY`
   *
   * For the first weekend of every month:
   * `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU`
   *
   * This specifies how frequently the window starts. Eg, if you wanted to have
   * a 9-5 UTC-4 window every weekday, you'd use something like:
   * ```
   * start time = 2019-01-01T09:00:00-0400
   * end time = 2019-01-01T17:00:00-0400
   * recurrence = FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
   * ```
   *
   * Windows can span multiple days. Eg, to make the window encompass every
   * weekend from midnight Saturday till the last minute of Sunday UTC:
   * ```
   * start time = 2019-01-05T00:00:00Z
   * end time = 2019-01-07T23:59:00Z
   * recurrence = FREQ=WEEKLY;BYDAY=SA
   * ```
   *
   * Note the start and end time's specific dates are largely arbitrary except
   * to specify duration of the window and when it first starts.
   * The FREQ values of HOURLY, MINUTELY, and SECONDLY are not supported.
   */
  recurrence: string;
}

/** Time window specified for daily maintenance operations. */
export interface DailyMaintenanceWindow {
  /**
   * Time within the maintenance window to start the maintenance operations.
   * Time format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
   * format "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
   */
  startTime: string;
  /**
   * Output only. Duration of the time window, automatically chosen to be
   * smallest possible in the given scenario.
   * Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
   * format "PTnHnMnS".
   */
  duration: string;
}

/**
 * SetNodePoolManagementRequest sets the node management properties of a node
 * pool.
 */
export interface SetNodePoolManagementRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to update.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to update.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /** Required. NodeManagement configuration for the node pool. */
  management:
    | NodeManagement
    | undefined;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * management properties. Specified in the format
   * `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/** SetNodePoolSizeRequest sets the size of a node pool. */
export interface SetNodePoolSizeRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to update.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to update.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /** Required. The desired node count for the pool. */
  nodeCount: number;
  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * size.
   * Specified in the format `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/**
 * CompleteNodePoolUpgradeRequest sets the name of target node pool to complete
 * upgrade.
 */
export interface CompleteNodePoolUpgradeRequest {
  /**
   * The name (project, location, cluster, node pool id) of the node pool to
   * complete upgrade.
   * Specified in the format `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
}

/**
 * RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
 * NodePool upgrade. This will be an no-op if the last upgrade successfully
 * completed.
 */
export interface RollbackNodePoolUpgradeRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to rollback.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * Deprecated. The name of the node pool to rollback.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  nodePoolId: string;
  /**
   * The name (project, location, cluster, node pool id) of the node poll to
   * rollback upgrade.
   * Specified in the format `projects/* /locations/* /clusters/* /nodePools/*`.
   */
  name: string;
  /**
   * Option for rollback to ignore the PodDisruptionBudget.
   * Default value is false.
   */
  respectPdb: boolean;
}

/** ListNodePoolsResponse is the result of ListNodePoolsRequest. */
export interface ListNodePoolsResponse {
  /** A list of node pools for a cluster. */
  nodePools: NodePool[];
}

/**
 * ClusterAutoscaling contains global, per-cluster information
 * required by Cluster Autoscaler to automatically adjust
 * the size of the cluster and create/delete
 * node pools based on the current needs.
 */
export interface ClusterAutoscaling {
  /** Enables automatic node pool creation and deletion. */
  enableNodeAutoprovisioning: boolean;
  /**
   * Contains global constraints regarding minimum and maximum
   * amount of resources in the cluster.
   */
  resourceLimits: ResourceLimit[];
  /** Defines autoscaling behaviour. */
  autoscalingProfile: ClusterAutoscaling_AutoscalingProfile;
  /**
   * AutoprovisioningNodePoolDefaults contains defaults for a node pool
   * created by NAP.
   */
  autoprovisioningNodePoolDefaults:
    | AutoprovisioningNodePoolDefaults
    | undefined;
  /**
   * The list of Google Compute Engine
   * [zones](https://cloud.google.com/compute/docs/zones#available) in which the
   * NodePool's nodes can be created by NAP.
   */
  autoprovisioningLocations: string[];
}

/** Defines possible options for autoscaling_profile field. */
export enum ClusterAutoscaling_AutoscalingProfile {
  /** PROFILE_UNSPECIFIED - No change to autoscaling configuration. */
  PROFILE_UNSPECIFIED = 0,
  /** OPTIMIZE_UTILIZATION - Prioritize optimizing utilization of resources. */
  OPTIMIZE_UTILIZATION = 1,
  /** BALANCED - Use default (balanced) autoscaling configuration. */
  BALANCED = 2,
  UNRECOGNIZED = -1,
}

export function clusterAutoscaling_AutoscalingProfileFromJSON(object: any): ClusterAutoscaling_AutoscalingProfile {
  switch (object) {
    case 0:
    case "PROFILE_UNSPECIFIED":
      return ClusterAutoscaling_AutoscalingProfile.PROFILE_UNSPECIFIED;
    case 1:
    case "OPTIMIZE_UTILIZATION":
      return ClusterAutoscaling_AutoscalingProfile.OPTIMIZE_UTILIZATION;
    case 2:
    case "BALANCED":
      return ClusterAutoscaling_AutoscalingProfile.BALANCED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClusterAutoscaling_AutoscalingProfile.UNRECOGNIZED;
  }
}

export function clusterAutoscaling_AutoscalingProfileToJSON(object: ClusterAutoscaling_AutoscalingProfile): string {
  switch (object) {
    case ClusterAutoscaling_AutoscalingProfile.PROFILE_UNSPECIFIED:
      return "PROFILE_UNSPECIFIED";
    case ClusterAutoscaling_AutoscalingProfile.OPTIMIZE_UTILIZATION:
      return "OPTIMIZE_UTILIZATION";
    case ClusterAutoscaling_AutoscalingProfile.BALANCED:
      return "BALANCED";
    case ClusterAutoscaling_AutoscalingProfile.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AutoprovisioningNodePoolDefaults contains defaults for a node pool created
 * by NAP.
 */
export interface AutoprovisioningNodePoolDefaults {
  /** Scopes that are used by NAP when creating node pools. */
  oauthScopes: string[];
  /** The Google Cloud Platform Service Account to be used by the node VMs. */
  serviceAccount: string;
  /** Specifies the upgrade settings for NAP created node pools */
  upgradeSettings:
    | NodePool_UpgradeSettings
    | undefined;
  /** Specifies the node management options for NAP created node-pools. */
  management:
    | NodeManagement
    | undefined;
  /**
   * Deprecated. Minimum CPU platform to be used for NAP created node pools.
   * The instance may be scheduled on the specified or newer CPU platform.
   * Applicable values are the friendly names of CPU platforms, such as
   * minCpuPlatform: Intel Haswell or
   * minCpuPlatform: Intel Sandy Bridge. For more
   * information, read [how to specify min CPU
   * platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
   * This field is deprecated, min_cpu_platform should be specified using
   * `cloud.google.com/requested-min-cpu-platform` label selector on the pod.
   * To unset the min cpu platform field pass "automatic"
   * as field value.
   *
   * @deprecated
   */
  minCpuPlatform: string;
  /**
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   *
   * If unspecified, the default disk size is 100GB.
   */
  diskSizeGb: number;
  /**
   * Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
   * 'pd-balanced')
   *
   * If unspecified, the default disk type is 'pd-standard'
   */
  diskType: string;
  /** Shielded Instance options. */
  shieldedInstanceConfig:
    | ShieldedInstanceConfig
    | undefined;
  /**
   * The Customer Managed Encryption Key used to encrypt the boot disk attached
   * to each node in the node pool. This should be of the form
   * projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
   * For more information about protecting resources with Cloud KMS Keys please
   * see:
   * https://cloud.google.com/compute/docs/disks/customer-managed-encryption
   */
  bootDiskKmsKey: string;
  /**
   * The image type to use for NAP created node. Please see
   * https://cloud.google.com/kubernetes-engine/docs/concepts/node-images for
   * available image types.
   */
  imageType: string;
  /** Enable or disable Kubelet read only port. */
  insecureKubeletReadonlyPortEnabled?: boolean | undefined;
}

/**
 * Contains information about amount of some resource in the cluster.
 * For memory, value should be in GB.
 */
export interface ResourceLimit {
  /** Resource name "cpu", "memory" or gpu-specific string. */
  resourceType: string;
  /** Minimum amount of the resource in the cluster. */
  minimum: Long;
  /** Maximum amount of the resource in the cluster. */
  maximum: Long;
}

/**
 * NodePoolAutoscaling contains information required by cluster autoscaler to
 * adjust the size of the node pool to the current cluster usage.
 */
export interface NodePoolAutoscaling {
  /** Is autoscaling enabled for this node pool. */
  enabled: boolean;
  /**
   * Minimum number of nodes for one location in the NodePool. Must be >= 1 and
   * <= max_node_count.
   */
  minNodeCount: number;
  /**
   * Maximum number of nodes for one location in the NodePool. Must be >=
   * min_node_count. There has to be enough quota to scale up the cluster.
   */
  maxNodeCount: number;
  /** Can this node pool be deleted automatically. */
  autoprovisioned: boolean;
  /** Location policy used when scaling up a nodepool. */
  locationPolicy: NodePoolAutoscaling_LocationPolicy;
  /**
   * Minimum number of nodes in the node pool. Must be greater than 1 less than
   * total_max_node_count.
   * The total_*_node_count fields are mutually exclusive with the *_node_count
   * fields.
   */
  totalMinNodeCount: number;
  /**
   * Maximum number of nodes in the node pool. Must be greater than
   * total_min_node_count. There has to be enough quota to scale up the cluster.
   * The total_*_node_count fields are mutually exclusive with the *_node_count
   * fields.
   */
  totalMaxNodeCount: number;
}

/**
 * Location policy specifies how zones are picked when scaling up the
 * nodepool.
 */
export enum NodePoolAutoscaling_LocationPolicy {
  /** LOCATION_POLICY_UNSPECIFIED - Not set. */
  LOCATION_POLICY_UNSPECIFIED = 0,
  /**
   * BALANCED - BALANCED is a best effort policy that aims to balance the sizes of
   * different zones.
   */
  BALANCED = 1,
  /** ANY - ANY policy picks zones that have the highest capacity available. */
  ANY = 2,
  UNRECOGNIZED = -1,
}

export function nodePoolAutoscaling_LocationPolicyFromJSON(object: any): NodePoolAutoscaling_LocationPolicy {
  switch (object) {
    case 0:
    case "LOCATION_POLICY_UNSPECIFIED":
      return NodePoolAutoscaling_LocationPolicy.LOCATION_POLICY_UNSPECIFIED;
    case 1:
    case "BALANCED":
      return NodePoolAutoscaling_LocationPolicy.BALANCED;
    case 2:
    case "ANY":
      return NodePoolAutoscaling_LocationPolicy.ANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodePoolAutoscaling_LocationPolicy.UNRECOGNIZED;
  }
}

export function nodePoolAutoscaling_LocationPolicyToJSON(object: NodePoolAutoscaling_LocationPolicy): string {
  switch (object) {
    case NodePoolAutoscaling_LocationPolicy.LOCATION_POLICY_UNSPECIFIED:
      return "LOCATION_POLICY_UNSPECIFIED";
    case NodePoolAutoscaling_LocationPolicy.BALANCED:
      return "BALANCED";
    case NodePoolAutoscaling_LocationPolicy.ANY:
      return "ANY";
    case NodePoolAutoscaling_LocationPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
 * Engine cluster, which will in turn set them for Google Compute Engine
 * resources used by that cluster
 */
export interface SetLabelsRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. The labels to set for that cluster. */
  resourceLabels: { [key: string]: string };
  /**
   * Required. The fingerprint of the previous set of labels for this resource,
   * used to detect conflicts. The fingerprint is initially generated by
   * Kubernetes Engine and changes after every request to modify or update
   * labels. You must always provide an up-to-date fingerprint hash when
   * updating or changing labels. Make a `get()` request to the
   * resource to get the latest fingerprint.
   */
  labelFingerprint: string;
  /**
   * The name (project, location, cluster name) of the cluster to set labels.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

export interface SetLabelsRequest_ResourceLabelsEntry {
  key: string;
  value: string;
}

/**
 * SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
 * a cluster.
 */
export interface SetLegacyAbacRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster to update.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. Whether ABAC authorization will be enabled in the cluster. */
  enabled: boolean;
  /**
   * The name (project, location, cluster name) of the cluster to set legacy
   * abac. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/**
 * StartIPRotationRequest creates a new IP for the cluster and then performs
 * a node upgrade on each node pool to point to the new IP.
 */
export interface StartIPRotationRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * The name (project, location, cluster name) of the cluster to start IP
   * rotation. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
  /** Whether to rotate credentials during IP rotation. */
  rotateCredentials: boolean;
}

/** CompleteIPRotationRequest moves the cluster master back into single-IP mode. */
export interface CompleteIPRotationRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /**
   * The name (project, location, cluster name) of the cluster to complete IP
   * rotation. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** AcceleratorConfig represents a Hardware Accelerator request. */
export interface AcceleratorConfig {
  /** The number of the accelerator cards exposed to an instance. */
  acceleratorCount: Long;
  /**
   * The accelerator type resource name. List of supported accelerators
   * [here](https://cloud.google.com/compute/docs/gpus)
   */
  acceleratorType: string;
  /**
   * Size of partitions to create on the GPU. Valid values are described in the
   * NVIDIA [mig user
   * guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
   */
  gpuPartitionSize: string;
  /** The configuration for GPU sharing options. */
  gpuSharingConfig?:
    | GPUSharingConfig
    | undefined;
  /** The configuration for auto installation of GPU driver. */
  gpuDriverInstallationConfig?: GPUDriverInstallationConfig | undefined;
}

/**
 * GPUSharingConfig represents the GPU sharing configuration for Hardware
 * Accelerators.
 */
export interface GPUSharingConfig {
  /** The max number of containers that can share a physical GPU. */
  maxSharedClientsPerGpu: Long;
  /** The type of GPU sharing strategy to enable on the GPU node. */
  gpuSharingStrategy?: GPUSharingConfig_GPUSharingStrategy | undefined;
}

/** The type of GPU sharing strategy currently provided. */
export enum GPUSharingConfig_GPUSharingStrategy {
  /** GPU_SHARING_STRATEGY_UNSPECIFIED - Default value. */
  GPU_SHARING_STRATEGY_UNSPECIFIED = 0,
  /** TIME_SHARING - GPUs are time-shared between containers. */
  TIME_SHARING = 1,
  /** MPS - GPUs are shared between containers with NVIDIA MPS. */
  MPS = 2,
  UNRECOGNIZED = -1,
}

export function gPUSharingConfig_GPUSharingStrategyFromJSON(object: any): GPUSharingConfig_GPUSharingStrategy {
  switch (object) {
    case 0:
    case "GPU_SHARING_STRATEGY_UNSPECIFIED":
      return GPUSharingConfig_GPUSharingStrategy.GPU_SHARING_STRATEGY_UNSPECIFIED;
    case 1:
    case "TIME_SHARING":
      return GPUSharingConfig_GPUSharingStrategy.TIME_SHARING;
    case 2:
    case "MPS":
      return GPUSharingConfig_GPUSharingStrategy.MPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GPUSharingConfig_GPUSharingStrategy.UNRECOGNIZED;
  }
}

export function gPUSharingConfig_GPUSharingStrategyToJSON(object: GPUSharingConfig_GPUSharingStrategy): string {
  switch (object) {
    case GPUSharingConfig_GPUSharingStrategy.GPU_SHARING_STRATEGY_UNSPECIFIED:
      return "GPU_SHARING_STRATEGY_UNSPECIFIED";
    case GPUSharingConfig_GPUSharingStrategy.TIME_SHARING:
      return "TIME_SHARING";
    case GPUSharingConfig_GPUSharingStrategy.MPS:
      return "MPS";
    case GPUSharingConfig_GPUSharingStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * GPUDriverInstallationConfig specifies the version of GPU driver to be auto
 * installed.
 */
export interface GPUDriverInstallationConfig {
  /** Mode for how the GPU driver is installed. */
  gpuDriverVersion?: GPUDriverInstallationConfig_GPUDriverVersion | undefined;
}

/** The GPU driver version to install. */
export enum GPUDriverInstallationConfig_GPUDriverVersion {
  /** GPU_DRIVER_VERSION_UNSPECIFIED - Default value is to not install any GPU driver. */
  GPU_DRIVER_VERSION_UNSPECIFIED = 0,
  /** INSTALLATION_DISABLED - Disable GPU driver auto installation and needs manual installation */
  INSTALLATION_DISABLED = 1,
  /** DEFAULT - "Default" GPU driver in COS and Ubuntu. */
  DEFAULT = 2,
  /** LATEST - "Latest" GPU driver in COS. */
  LATEST = 3,
  UNRECOGNIZED = -1,
}

export function gPUDriverInstallationConfig_GPUDriverVersionFromJSON(
  object: any,
): GPUDriverInstallationConfig_GPUDriverVersion {
  switch (object) {
    case 0:
    case "GPU_DRIVER_VERSION_UNSPECIFIED":
      return GPUDriverInstallationConfig_GPUDriverVersion.GPU_DRIVER_VERSION_UNSPECIFIED;
    case 1:
    case "INSTALLATION_DISABLED":
      return GPUDriverInstallationConfig_GPUDriverVersion.INSTALLATION_DISABLED;
    case 2:
    case "DEFAULT":
      return GPUDriverInstallationConfig_GPUDriverVersion.DEFAULT;
    case 3:
    case "LATEST":
      return GPUDriverInstallationConfig_GPUDriverVersion.LATEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GPUDriverInstallationConfig_GPUDriverVersion.UNRECOGNIZED;
  }
}

export function gPUDriverInstallationConfig_GPUDriverVersionToJSON(
  object: GPUDriverInstallationConfig_GPUDriverVersion,
): string {
  switch (object) {
    case GPUDriverInstallationConfig_GPUDriverVersion.GPU_DRIVER_VERSION_UNSPECIFIED:
      return "GPU_DRIVER_VERSION_UNSPECIFIED";
    case GPUDriverInstallationConfig_GPUDriverVersion.INSTALLATION_DISABLED:
      return "INSTALLATION_DISABLED";
    case GPUDriverInstallationConfig_GPUDriverVersion.DEFAULT:
      return "DEFAULT";
    case GPUDriverInstallationConfig_GPUDriverVersion.LATEST:
      return "LATEST";
    case GPUDriverInstallationConfig_GPUDriverVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * WorkloadMetadataConfig defines the metadata configuration to expose to
 * workloads on the node pool.
 */
export interface WorkloadMetadataConfig {
  /**
   * Mode is the configuration for how to expose metadata to workloads running
   * on the node pool.
   */
  mode: WorkloadMetadataConfig_Mode;
}

/**
 * Mode is the configuration for how to expose metadata to workloads running
 * on the node.
 */
export enum WorkloadMetadataConfig_Mode {
  /** MODE_UNSPECIFIED - Not set. */
  MODE_UNSPECIFIED = 0,
  /** GCE_METADATA - Expose all Compute Engine metadata to pods. */
  GCE_METADATA = 1,
  /**
   * GKE_METADATA - Run the GKE Metadata Server on this node. The GKE Metadata Server exposes
   * a metadata API to workloads that is compatible with the V1 Compute
   * Metadata APIs exposed by the Compute Engine and App Engine Metadata
   * Servers. This feature can only be enabled if Workload Identity is enabled
   * at the cluster level.
   */
  GKE_METADATA = 2,
  UNRECOGNIZED = -1,
}

export function workloadMetadataConfig_ModeFromJSON(object: any): WorkloadMetadataConfig_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return WorkloadMetadataConfig_Mode.MODE_UNSPECIFIED;
    case 1:
    case "GCE_METADATA":
      return WorkloadMetadataConfig_Mode.GCE_METADATA;
    case 2:
    case "GKE_METADATA":
      return WorkloadMetadataConfig_Mode.GKE_METADATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkloadMetadataConfig_Mode.UNRECOGNIZED;
  }
}

export function workloadMetadataConfig_ModeToJSON(object: WorkloadMetadataConfig_Mode): string {
  switch (object) {
    case WorkloadMetadataConfig_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case WorkloadMetadataConfig_Mode.GCE_METADATA:
      return "GCE_METADATA";
    case WorkloadMetadataConfig_Mode.GKE_METADATA:
      return "GKE_METADATA";
    case WorkloadMetadataConfig_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SetNetworkPolicyRequest enables/disables network policy for a cluster. */
export interface SetNetworkPolicyRequest {
  /**
   * Deprecated. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  projectId: string;
  /**
   * Deprecated. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides. This field has been deprecated and replaced by the name
   * field.
   *
   * @deprecated
   */
  zone: string;
  /**
   * Deprecated. The name of the cluster.
   * This field has been deprecated and replaced by the name field.
   *
   * @deprecated
   */
  clusterId: string;
  /** Required. Configuration options for the NetworkPolicy feature. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /**
   * The name (project, location, cluster name) of the cluster to set networking
   * policy. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/** SetMaintenancePolicyRequest sets the maintenance policy for a cluster. */
export interface SetMaintenancePolicyRequest {
  /**
   * Required. The Google Developers Console [project ID or project
   * number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
   */
  projectId: string;
  /**
   * Required. The name of the Google Compute Engine
   * [zone](https://cloud.google.com/compute/docs/zones#available) in which the
   * cluster resides.
   */
  zone: string;
  /** Required. The name of the cluster to update. */
  clusterId: string;
  /**
   * Required. The maintenance policy to be set for the cluster. An empty field
   * clears the existing maintenance policy.
   */
  maintenancePolicy:
    | MaintenancePolicy
    | undefined;
  /**
   * The name (project, location, cluster name) of the cluster to set
   * maintenance policy.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/**
 * StatusCondition describes why a cluster or a node pool has a certain status
 * (e.g., ERROR or DEGRADED).
 */
export interface StatusCondition {
  /**
   * Machine-friendly representation of the condition
   * Deprecated. Use canonical_code instead.
   *
   * @deprecated
   */
  code: StatusCondition_Code;
  /** Human-friendly representation of the condition */
  message: string;
  /** Canonical code of the condition. */
  canonicalCode: Code;
}

/** Code for each condition */
export enum StatusCondition_Code {
  /** UNKNOWN - UNKNOWN indicates a generic condition. */
  UNKNOWN = 0,
  /**
   * GCE_STOCKOUT - GCE_STOCKOUT indicates that Google Compute Engine resources are
   * temporarily unavailable.
   */
  GCE_STOCKOUT = 1,
  /**
   * GKE_SERVICE_ACCOUNT_DELETED - GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
   * service account.
   */
  GKE_SERVICE_ACCOUNT_DELETED = 2,
  /** GCE_QUOTA_EXCEEDED - Google Compute Engine quota was exceeded. */
  GCE_QUOTA_EXCEEDED = 3,
  /** SET_BY_OPERATOR - Cluster state was manually changed by an SRE due to a system logic error. */
  SET_BY_OPERATOR = 4,
  /**
   * CLOUD_KMS_KEY_ERROR - Unable to perform an encrypt operation against the CloudKMS key used for
   * etcd level encryption.
   */
  CLOUD_KMS_KEY_ERROR = 7,
  /** CA_EXPIRING - Cluster CA is expiring soon. */
  CA_EXPIRING = 9,
  UNRECOGNIZED = -1,
}

export function statusCondition_CodeFromJSON(object: any): StatusCondition_Code {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return StatusCondition_Code.UNKNOWN;
    case 1:
    case "GCE_STOCKOUT":
      return StatusCondition_Code.GCE_STOCKOUT;
    case 2:
    case "GKE_SERVICE_ACCOUNT_DELETED":
      return StatusCondition_Code.GKE_SERVICE_ACCOUNT_DELETED;
    case 3:
    case "GCE_QUOTA_EXCEEDED":
      return StatusCondition_Code.GCE_QUOTA_EXCEEDED;
    case 4:
    case "SET_BY_OPERATOR":
      return StatusCondition_Code.SET_BY_OPERATOR;
    case 7:
    case "CLOUD_KMS_KEY_ERROR":
      return StatusCondition_Code.CLOUD_KMS_KEY_ERROR;
    case 9:
    case "CA_EXPIRING":
      return StatusCondition_Code.CA_EXPIRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StatusCondition_Code.UNRECOGNIZED;
  }
}

export function statusCondition_CodeToJSON(object: StatusCondition_Code): string {
  switch (object) {
    case StatusCondition_Code.UNKNOWN:
      return "UNKNOWN";
    case StatusCondition_Code.GCE_STOCKOUT:
      return "GCE_STOCKOUT";
    case StatusCondition_Code.GKE_SERVICE_ACCOUNT_DELETED:
      return "GKE_SERVICE_ACCOUNT_DELETED";
    case StatusCondition_Code.GCE_QUOTA_EXCEEDED:
      return "GCE_QUOTA_EXCEEDED";
    case StatusCondition_Code.SET_BY_OPERATOR:
      return "SET_BY_OPERATOR";
    case StatusCondition_Code.CLOUD_KMS_KEY_ERROR:
      return "CLOUD_KMS_KEY_ERROR";
    case StatusCondition_Code.CA_EXPIRING:
      return "CA_EXPIRING";
    case StatusCondition_Code.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NetworkConfig reports the relative names of network & subnetwork. */
export interface NetworkConfig {
  /**
   * Output only. The relative name of the Google Compute Engine
   * [network][google.container.v1.NetworkConfig.network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
   * to which the cluster is connected. Example:
   * projects/my-project/global/networks/my-network
   */
  network: string;
  /**
   * Output only. The relative name of the Google Compute Engine
   * [subnetwork](https://cloud.google.com/compute/docs/vpc) to which the
   * cluster is connected. Example:
   * projects/my-project/regions/us-central1/subnetworks/my-subnet
   */
  subnetwork: string;
  /**
   * Whether Intra-node visibility is enabled for this cluster.
   * This makes same node pod to pod traffic visible for VPC network.
   */
  enableIntraNodeVisibility: boolean;
  /**
   * Whether the cluster disables default in-node sNAT rules. In-node sNAT rules
   * will be disabled when default_snat_status is disabled. When disabled is set
   * to false, default IP masquerade rules will be applied to the nodes to
   * prevent sNAT on cluster internal traffic.
   */
  defaultSnatStatus:
    | DefaultSnatStatus
    | undefined;
  /** Whether L4ILB Subsetting is enabled for this cluster. */
  enableL4ilbSubsetting: boolean;
  /**
   * The desired datapath provider for this cluster. By default, uses the
   * IPTables-based kube-proxy implementation.
   */
  datapathProvider: DatapathProvider;
  /**
   * The desired state of IPv6 connectivity to Google Services.
   * By default, no private IPv6 access to or from Google Services (all access
   * will be via IPv4)
   */
  privateIpv6GoogleAccess: PrivateIPv6GoogleAccess;
  /** DNSConfig contains clusterDNS config for this cluster. */
  dnsConfig:
    | DNSConfig
    | undefined;
  /**
   * ServiceExternalIPsConfig specifies if services with externalIPs field are
   * blocked or not.
   */
  serviceExternalIpsConfig:
    | ServiceExternalIPsConfig
    | undefined;
  /**
   * GatewayAPIConfig contains the desired config of Gateway API on this
   * cluster.
   */
  gatewayApiConfig:
    | GatewayAPIConfig
    | undefined;
  /** Whether multi-networking is enabled for this cluster. */
  enableMultiNetworking: boolean;
  /** Network bandwidth tier configuration. */
  networkPerformanceConfig:
    | NetworkConfig_ClusterNetworkPerformanceConfig
    | undefined;
  /** Whether FQDN Network Policy is enabled on this cluster. */
  enableFqdnNetworkPolicy?:
    | boolean
    | undefined;
  /**
   * Specify the details of in-transit encryption.
   * Now named inter-node transparent encryption.
   */
  inTransitEncryptionConfig?:
    | InTransitEncryptionConfig
    | undefined;
  /** Whether CiliumClusterwideNetworkPolicy is enabled on this cluster. */
  enableCiliumClusterwideNetworkPolicy?: boolean | undefined;
}

/** Configuration of network bandwidth tiers */
export interface NetworkConfig_ClusterNetworkPerformanceConfig {
  /** Specifies the total network bandwidth tier for NodePools in the cluster. */
  totalEgressBandwidthTier?: NetworkConfig_ClusterNetworkPerformanceConfig_Tier | undefined;
}

/** Node network tier */
export enum NetworkConfig_ClusterNetworkPerformanceConfig_Tier {
  /** TIER_UNSPECIFIED - Default value */
  TIER_UNSPECIFIED = 0,
  /** TIER_1 - Higher bandwidth, actual values based on VM size. */
  TIER_1 = 1,
  UNRECOGNIZED = -1,
}

export function networkConfig_ClusterNetworkPerformanceConfig_TierFromJSON(
  object: any,
): NetworkConfig_ClusterNetworkPerformanceConfig_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return NetworkConfig_ClusterNetworkPerformanceConfig_Tier.TIER_UNSPECIFIED;
    case 1:
    case "TIER_1":
      return NetworkConfig_ClusterNetworkPerformanceConfig_Tier.TIER_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_ClusterNetworkPerformanceConfig_Tier.UNRECOGNIZED;
  }
}

export function networkConfig_ClusterNetworkPerformanceConfig_TierToJSON(
  object: NetworkConfig_ClusterNetworkPerformanceConfig_Tier,
): string {
  switch (object) {
    case NetworkConfig_ClusterNetworkPerformanceConfig_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case NetworkConfig_ClusterNetworkPerformanceConfig_Tier.TIER_1:
      return "TIER_1";
    case NetworkConfig_ClusterNetworkPerformanceConfig_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** GatewayAPIConfig contains the desired config of Gateway API on this cluster. */
export interface GatewayAPIConfig {
  /** The Gateway API release channel to use for Gateway API. */
  channel: GatewayAPIConfig_Channel;
}

/**
 * Channel describes if/how Gateway API should be installed and implemented in
 * a cluster.
 */
export enum GatewayAPIConfig_Channel {
  /** CHANNEL_UNSPECIFIED - Default value. */
  CHANNEL_UNSPECIFIED = 0,
  /** CHANNEL_DISABLED - Gateway API support is disabled */
  CHANNEL_DISABLED = 1,
  /**
   * CHANNEL_EXPERIMENTAL - Deprecated: use CHANNEL_STANDARD instead.
   * Gateway API support is enabled, experimental CRDs are installed
   *
   * @deprecated
   */
  CHANNEL_EXPERIMENTAL = 3,
  /** CHANNEL_STANDARD - Gateway API support is enabled, standard CRDs are installed */
  CHANNEL_STANDARD = 4,
  UNRECOGNIZED = -1,
}

export function gatewayAPIConfig_ChannelFromJSON(object: any): GatewayAPIConfig_Channel {
  switch (object) {
    case 0:
    case "CHANNEL_UNSPECIFIED":
      return GatewayAPIConfig_Channel.CHANNEL_UNSPECIFIED;
    case 1:
    case "CHANNEL_DISABLED":
      return GatewayAPIConfig_Channel.CHANNEL_DISABLED;
    case 3:
    case "CHANNEL_EXPERIMENTAL":
      return GatewayAPIConfig_Channel.CHANNEL_EXPERIMENTAL;
    case 4:
    case "CHANNEL_STANDARD":
      return GatewayAPIConfig_Channel.CHANNEL_STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GatewayAPIConfig_Channel.UNRECOGNIZED;
  }
}

export function gatewayAPIConfig_ChannelToJSON(object: GatewayAPIConfig_Channel): string {
  switch (object) {
    case GatewayAPIConfig_Channel.CHANNEL_UNSPECIFIED:
      return "CHANNEL_UNSPECIFIED";
    case GatewayAPIConfig_Channel.CHANNEL_DISABLED:
      return "CHANNEL_DISABLED";
    case GatewayAPIConfig_Channel.CHANNEL_EXPERIMENTAL:
      return "CHANNEL_EXPERIMENTAL";
    case GatewayAPIConfig_Channel.CHANNEL_STANDARD:
      return "CHANNEL_STANDARD";
    case GatewayAPIConfig_Channel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Config to block services with externalIPs field. */
export interface ServiceExternalIPsConfig {
  /** Whether Services with ExternalIPs field are allowed or not. */
  enabled: boolean;
}

/**
 * GetOpenIDConfigRequest gets the OIDC discovery document for the
 * cluster. See the OpenID Connect Discovery 1.0 specification for details.
 */
export interface GetOpenIDConfigRequest {
  /**
   * The cluster (project, location, cluster name) to get the discovery document
   * for. Specified in the format `projects/* /locations/* /clusters/*`.
   */
  parent: string;
}

/**
 * GetOpenIDConfigResponse is an OIDC discovery document for the cluster.
 * See the OpenID Connect Discovery 1.0 specification for details.
 */
export interface GetOpenIDConfigResponse {
  /** OIDC Issuer. */
  issuer: string;
  /** JSON Web Key uri. */
  jwksUri: string;
  /** Supported response types. */
  responseTypesSupported: string[];
  /** Supported subject types. */
  subjectTypesSupported: string[];
  /** supported ID Token signing Algorithms. */
  idTokenSigningAlgValuesSupported: string[];
  /** Supported claims. */
  claimsSupported: string[];
  /** Supported grant types. */
  grantTypes: string[];
}

/**
 * GetJSONWebKeysRequest gets the public component of the keys used by the
 * cluster to sign token requests. This will be the jwks_uri for the discover
 * document returned by getOpenIDConfig. See the OpenID Connect
 * Discovery 1.0 specification for details.
 */
export interface GetJSONWebKeysRequest {
  /**
   * The cluster (project, location, cluster name) to get keys for. Specified in
   * the format `projects/* /locations/* /clusters/*`.
   */
  parent: string;
}

/** Jwk is a JSON Web Key as specified in RFC 7517 */
export interface Jwk {
  /** Key Type. */
  kty: string;
  /** Algorithm. */
  alg: string;
  /** Permitted uses for the public keys. */
  use: string;
  /** Key ID. */
  kid: string;
  /** Used for RSA keys. */
  n: string;
  /** Used for RSA keys. */
  e: string;
  /** Used for ECDSA keys. */
  x: string;
  /** Used for ECDSA keys. */
  y: string;
  /** Used for ECDSA keys. */
  crv: string;
}

/** GetJSONWebKeysResponse is a valid JSON Web Key Set as specififed in rfc 7517 */
export interface GetJSONWebKeysResponse {
  /**
   * The public component of the keys used by the cluster to sign token
   * requests.
   */
  keys: Jwk[];
}

/**
 * CheckAutopilotCompatibilityRequest requests getting the blockers for the
 * given operation in the cluster.
 */
export interface CheckAutopilotCompatibilityRequest {
  /**
   * The name (project, location, cluster) of the cluster to retrieve.
   * Specified in the format `projects/* /locations/* /clusters/*`.
   */
  name: string;
}

/**
 * AutopilotCompatibilityIssue contains information about a specific
 * compatibility issue with Autopilot mode.
 */
export interface AutopilotCompatibilityIssue {
  /** The last time when this issue was observed. */
  lastObservation:
    | Date
    | undefined;
  /** The constraint type of the issue. */
  constraintType: string;
  /** The incompatibility type of this issue. */
  incompatibilityType: AutopilotCompatibilityIssue_IssueType;
  /** The name of the resources which are subject to this issue. */
  subjects: string[];
  /** A URL to a public documnetation, which addresses resolving this issue. */
  documentationUrl: string;
  /** The description of the issue. */
  description: string;
}

/** The type of the reported issue. */
export enum AutopilotCompatibilityIssue_IssueType {
  /** UNSPECIFIED - Default value, should not be used. */
  UNSPECIFIED = 0,
  /**
   * INCOMPATIBILITY - Indicates that the issue is a known incompatibility between the
   * cluster and Autopilot mode.
   */
  INCOMPATIBILITY = 1,
  /**
   * ADDITIONAL_CONFIG_REQUIRED - Indicates the issue is an incompatibility if customers take no further
   * action to resolve.
   */
  ADDITIONAL_CONFIG_REQUIRED = 2,
  /**
   * PASSED_WITH_OPTIONAL_CONFIG - Indicates the issue is not an incompatibility, but depending on the
   * workloads business logic, there is a potential that they won't work on
   * Autopilot.
   */
  PASSED_WITH_OPTIONAL_CONFIG = 3,
  UNRECOGNIZED = -1,
}

export function autopilotCompatibilityIssue_IssueTypeFromJSON(object: any): AutopilotCompatibilityIssue_IssueType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return AutopilotCompatibilityIssue_IssueType.UNSPECIFIED;
    case 1:
    case "INCOMPATIBILITY":
      return AutopilotCompatibilityIssue_IssueType.INCOMPATIBILITY;
    case 2:
    case "ADDITIONAL_CONFIG_REQUIRED":
      return AutopilotCompatibilityIssue_IssueType.ADDITIONAL_CONFIG_REQUIRED;
    case 3:
    case "PASSED_WITH_OPTIONAL_CONFIG":
      return AutopilotCompatibilityIssue_IssueType.PASSED_WITH_OPTIONAL_CONFIG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutopilotCompatibilityIssue_IssueType.UNRECOGNIZED;
  }
}

export function autopilotCompatibilityIssue_IssueTypeToJSON(object: AutopilotCompatibilityIssue_IssueType): string {
  switch (object) {
    case AutopilotCompatibilityIssue_IssueType.UNSPECIFIED:
      return "UNSPECIFIED";
    case AutopilotCompatibilityIssue_IssueType.INCOMPATIBILITY:
      return "INCOMPATIBILITY";
    case AutopilotCompatibilityIssue_IssueType.ADDITIONAL_CONFIG_REQUIRED:
      return "ADDITIONAL_CONFIG_REQUIRED";
    case AutopilotCompatibilityIssue_IssueType.PASSED_WITH_OPTIONAL_CONFIG:
      return "PASSED_WITH_OPTIONAL_CONFIG";
    case AutopilotCompatibilityIssue_IssueType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** CheckAutopilotCompatibilityResponse has a list of compatibility issues. */
export interface CheckAutopilotCompatibilityResponse {
  /** The list of issues for the given operation. */
  issues: AutopilotCompatibilityIssue[];
  /** The summary of the autopilot compatibility response. */
  summary: string;
}

/**
 * ReleaseChannel indicates which release channel a cluster is
 * subscribed to. Release channels are arranged in order of risk.
 *
 * When a cluster is subscribed to a release channel, Google maintains
 * both the master version and the node version. Node auto-upgrade
 * defaults to true and cannot be disabled.
 */
export interface ReleaseChannel {
  /** channel specifies which release channel the cluster is subscribed to. */
  channel: ReleaseChannel_Channel;
}

/** Possible values for 'channel'. */
export enum ReleaseChannel_Channel {
  /** UNSPECIFIED - No channel specified. */
  UNSPECIFIED = 0,
  /**
   * RAPID - RAPID channel is offered on an early access basis for customers who want
   * to test new releases.
   *
   * WARNING: Versions available in the RAPID Channel may be subject to
   * unresolved issues with no known workaround and are not subject to any
   * SLAs.
   */
  RAPID = 1,
  /**
   * REGULAR - Clusters subscribed to REGULAR receive versions that are considered GA
   * quality. REGULAR is intended for production users who want to take
   * advantage of new features.
   */
  REGULAR = 2,
  /**
   * STABLE - Clusters subscribed to STABLE receive versions that are known to be
   * stable and reliable in production.
   */
  STABLE = 3,
  /**
   * EXTENDED - Clusters subscribed to EXTENDED receive extended support and availability
   * for versions which are known to be stable and reliable in production.
   */
  EXTENDED = 4,
  UNRECOGNIZED = -1,
}

export function releaseChannel_ChannelFromJSON(object: any): ReleaseChannel_Channel {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ReleaseChannel_Channel.UNSPECIFIED;
    case 1:
    case "RAPID":
      return ReleaseChannel_Channel.RAPID;
    case 2:
    case "REGULAR":
      return ReleaseChannel_Channel.REGULAR;
    case 3:
    case "STABLE":
      return ReleaseChannel_Channel.STABLE;
    case 4:
    case "EXTENDED":
      return ReleaseChannel_Channel.EXTENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReleaseChannel_Channel.UNRECOGNIZED;
  }
}

export function releaseChannel_ChannelToJSON(object: ReleaseChannel_Channel): string {
  switch (object) {
    case ReleaseChannel_Channel.UNSPECIFIED:
      return "UNSPECIFIED";
    case ReleaseChannel_Channel.RAPID:
      return "RAPID";
    case ReleaseChannel_Channel.REGULAR:
      return "REGULAR";
    case ReleaseChannel_Channel.STABLE:
      return "STABLE";
    case ReleaseChannel_Channel.EXTENDED:
      return "EXTENDED";
    case ReleaseChannel_Channel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for fine-grained cost management feature. */
export interface CostManagementConfig {
  /** Whether the feature is enabled or not. */
  enabled: boolean;
}

/**
 * IntraNodeVisibilityConfig contains the desired config of the intra-node
 * visibility on this cluster.
 */
export interface IntraNodeVisibilityConfig {
  /** Enables intra node visibility for this cluster. */
  enabled: boolean;
}

/**
 * ILBSubsettingConfig contains the desired config of L4 Internal LoadBalancer
 * subsetting on this cluster.
 */
export interface ILBSubsettingConfig {
  /** Enables l4 ILB subsetting for this cluster. */
  enabled: boolean;
}

/** DNSConfig contains the desired set of options for configuring clusterDNS. */
export interface DNSConfig {
  /** cluster_dns indicates which in-cluster DNS provider should be used. */
  clusterDns: DNSConfig_Provider;
  /** cluster_dns_scope indicates the scope of access to cluster DNS records. */
  clusterDnsScope: DNSConfig_DNSScope;
  /** cluster_dns_domain is the suffix used for all cluster service records. */
  clusterDnsDomain: string;
  /** Optional. The domain used in Additive VPC scope. */
  additiveVpcScopeDnsDomain: string;
}

/** Provider lists the various in-cluster DNS providers. */
export enum DNSConfig_Provider {
  /** PROVIDER_UNSPECIFIED - Default value */
  PROVIDER_UNSPECIFIED = 0,
  /** PLATFORM_DEFAULT - Use GKE default DNS provider(kube-dns) for DNS resolution. */
  PLATFORM_DEFAULT = 1,
  /** CLOUD_DNS - Use CloudDNS for DNS resolution. */
  CLOUD_DNS = 2,
  /** KUBE_DNS - Use KubeDNS for DNS resolution. */
  KUBE_DNS = 3,
  UNRECOGNIZED = -1,
}

export function dNSConfig_ProviderFromJSON(object: any): DNSConfig_Provider {
  switch (object) {
    case 0:
    case "PROVIDER_UNSPECIFIED":
      return DNSConfig_Provider.PROVIDER_UNSPECIFIED;
    case 1:
    case "PLATFORM_DEFAULT":
      return DNSConfig_Provider.PLATFORM_DEFAULT;
    case 2:
    case "CLOUD_DNS":
      return DNSConfig_Provider.CLOUD_DNS;
    case 3:
    case "KUBE_DNS":
      return DNSConfig_Provider.KUBE_DNS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DNSConfig_Provider.UNRECOGNIZED;
  }
}

export function dNSConfig_ProviderToJSON(object: DNSConfig_Provider): string {
  switch (object) {
    case DNSConfig_Provider.PROVIDER_UNSPECIFIED:
      return "PROVIDER_UNSPECIFIED";
    case DNSConfig_Provider.PLATFORM_DEFAULT:
      return "PLATFORM_DEFAULT";
    case DNSConfig_Provider.CLOUD_DNS:
      return "CLOUD_DNS";
    case DNSConfig_Provider.KUBE_DNS:
      return "KUBE_DNS";
    case DNSConfig_Provider.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DNSScope lists the various scopes of access to cluster DNS records. */
export enum DNSConfig_DNSScope {
  /** DNS_SCOPE_UNSPECIFIED - Default value, will be inferred as cluster scope. */
  DNS_SCOPE_UNSPECIFIED = 0,
  /** CLUSTER_SCOPE - DNS records are accessible from within the cluster. */
  CLUSTER_SCOPE = 1,
  /** VPC_SCOPE - DNS records are accessible from within the VPC. */
  VPC_SCOPE = 2,
  UNRECOGNIZED = -1,
}

export function dNSConfig_DNSScopeFromJSON(object: any): DNSConfig_DNSScope {
  switch (object) {
    case 0:
    case "DNS_SCOPE_UNSPECIFIED":
      return DNSConfig_DNSScope.DNS_SCOPE_UNSPECIFIED;
    case 1:
    case "CLUSTER_SCOPE":
      return DNSConfig_DNSScope.CLUSTER_SCOPE;
    case 2:
    case "VPC_SCOPE":
      return DNSConfig_DNSScope.VPC_SCOPE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DNSConfig_DNSScope.UNRECOGNIZED;
  }
}

export function dNSConfig_DNSScopeToJSON(object: DNSConfig_DNSScope): string {
  switch (object) {
    case DNSConfig_DNSScope.DNS_SCOPE_UNSPECIFIED:
      return "DNS_SCOPE_UNSPECIFIED";
    case DNSConfig_DNSScope.CLUSTER_SCOPE:
      return "CLUSTER_SCOPE";
    case DNSConfig_DNSScope.VPC_SCOPE:
      return "VPC_SCOPE";
    case DNSConfig_DNSScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Constraints applied to pods. */
export interface MaxPodsConstraint {
  /** Constraint enforced on the max num of pods per node. */
  maxPodsPerNode: Long;
}

/**
 * Configuration for the use of Kubernetes Service Accounts in GCP IAM
 * policies.
 */
export interface WorkloadIdentityConfig {
  /** The workload pool to attach all Kubernetes service accounts to. */
  workloadPool: string;
}

/**
 * IdentityServiceConfig is configuration for Identity Service which allows
 * customers to use external identity providers with the K8S API
 */
export interface IdentityServiceConfig {
  /** Whether to enable the Identity Service component */
  enabled: boolean;
}

/** Configuration for issuance of mTLS keys and certificates to Kubernetes pods. */
export interface MeshCertificates {
  /**
   * enable_certificates controls issuance of workload mTLS certificates.
   *
   * If set, the GKE Workload Identity Certificates controller and node agent
   * will be deployed in the cluster, which can then be configured by creating a
   * WorkloadCertificateConfig Custom Resource.
   *
   * Requires Workload Identity
   * ([workload_pool][google.container.v1.WorkloadIdentityConfig.workload_pool]
   * must be non-empty).
   */
  enableCertificates: boolean | undefined;
}

/** Configuration of etcd encryption. */
export interface DatabaseEncryption {
  /**
   * Name of CloudKMS key to use for the encryption of secrets in etcd.
   * Ex. projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
   */
  keyName: string;
  /** The desired state of etcd encryption. */
  state: DatabaseEncryption_State;
  /** Output only. The current state of etcd encryption. */
  currentState?:
    | DatabaseEncryption_CurrentState
    | undefined;
  /**
   * Output only. Keys in use by the cluster for decrypting
   * existing objects, in addition to the key in `key_name`.
   *
   * Each item is a CloudKMS key resource.
   */
  decryptionKeys: string[];
  /**
   * Output only. Records errors seen during DatabaseEncryption update
   * operations.
   */
  lastOperationErrors: DatabaseEncryption_OperationError[];
}

/** State of etcd encryption. */
export enum DatabaseEncryption_State {
  /** UNKNOWN - Should never be set */
  UNKNOWN = 0,
  /** ENCRYPTED - Secrets in etcd are encrypted. */
  ENCRYPTED = 1,
  /**
   * DECRYPTED - Secrets in etcd are stored in plain text (at etcd level) - this is
   * unrelated to Compute Engine level full disk encryption.
   */
  DECRYPTED = 2,
  UNRECOGNIZED = -1,
}

export function databaseEncryption_StateFromJSON(object: any): DatabaseEncryption_State {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return DatabaseEncryption_State.UNKNOWN;
    case 1:
    case "ENCRYPTED":
      return DatabaseEncryption_State.ENCRYPTED;
    case 2:
    case "DECRYPTED":
      return DatabaseEncryption_State.DECRYPTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEncryption_State.UNRECOGNIZED;
  }
}

export function databaseEncryption_StateToJSON(object: DatabaseEncryption_State): string {
  switch (object) {
    case DatabaseEncryption_State.UNKNOWN:
      return "UNKNOWN";
    case DatabaseEncryption_State.ENCRYPTED:
      return "ENCRYPTED";
    case DatabaseEncryption_State.DECRYPTED:
      return "DECRYPTED";
    case DatabaseEncryption_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Current State of etcd encryption. */
export enum DatabaseEncryption_CurrentState {
  /** CURRENT_STATE_UNSPECIFIED - Should never be set */
  CURRENT_STATE_UNSPECIFIED = 0,
  /** CURRENT_STATE_ENCRYPTED - Secrets in etcd are encrypted. */
  CURRENT_STATE_ENCRYPTED = 7,
  /**
   * CURRENT_STATE_DECRYPTED - Secrets in etcd are stored in plain text (at etcd level) - this is
   * unrelated to Compute Engine level full disk encryption.
   */
  CURRENT_STATE_DECRYPTED = 2,
  /**
   * CURRENT_STATE_ENCRYPTION_PENDING - Encryption (or re-encryption with a different CloudKMS key)
   * of Secrets is in progress.
   */
  CURRENT_STATE_ENCRYPTION_PENDING = 3,
  /**
   * CURRENT_STATE_ENCRYPTION_ERROR - Encryption (or re-encryption with a different CloudKMS key) of Secrets in
   * etcd encountered an error.
   */
  CURRENT_STATE_ENCRYPTION_ERROR = 4,
  /** CURRENT_STATE_DECRYPTION_PENDING - De-crypting Secrets to plain text in etcd is in progress. */
  CURRENT_STATE_DECRYPTION_PENDING = 5,
  /** CURRENT_STATE_DECRYPTION_ERROR - De-crypting Secrets to plain text in etcd encountered an error. */
  CURRENT_STATE_DECRYPTION_ERROR = 6,
  UNRECOGNIZED = -1,
}

export function databaseEncryption_CurrentStateFromJSON(object: any): DatabaseEncryption_CurrentState {
  switch (object) {
    case 0:
    case "CURRENT_STATE_UNSPECIFIED":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_UNSPECIFIED;
    case 7:
    case "CURRENT_STATE_ENCRYPTED":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTED;
    case 2:
    case "CURRENT_STATE_DECRYPTED":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTED;
    case 3:
    case "CURRENT_STATE_ENCRYPTION_PENDING":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTION_PENDING;
    case 4:
    case "CURRENT_STATE_ENCRYPTION_ERROR":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTION_ERROR;
    case 5:
    case "CURRENT_STATE_DECRYPTION_PENDING":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTION_PENDING;
    case 6:
    case "CURRENT_STATE_DECRYPTION_ERROR":
      return DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTION_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DatabaseEncryption_CurrentState.UNRECOGNIZED;
  }
}

export function databaseEncryption_CurrentStateToJSON(object: DatabaseEncryption_CurrentState): string {
  switch (object) {
    case DatabaseEncryption_CurrentState.CURRENT_STATE_UNSPECIFIED:
      return "CURRENT_STATE_UNSPECIFIED";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTED:
      return "CURRENT_STATE_ENCRYPTED";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTED:
      return "CURRENT_STATE_DECRYPTED";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTION_PENDING:
      return "CURRENT_STATE_ENCRYPTION_PENDING";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_ENCRYPTION_ERROR:
      return "CURRENT_STATE_ENCRYPTION_ERROR";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTION_PENDING:
      return "CURRENT_STATE_DECRYPTION_PENDING";
    case DatabaseEncryption_CurrentState.CURRENT_STATE_DECRYPTION_ERROR:
      return "CURRENT_STATE_DECRYPTION_ERROR";
    case DatabaseEncryption_CurrentState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * OperationError records errors seen from CloudKMS keys
 * encountered during updates to DatabaseEncryption configuration.
 */
export interface DatabaseEncryption_OperationError {
  /** CloudKMS key resource that had the error. */
  keyName: string;
  /** Description of the error seen during the operation. */
  errorMessage: string;
  /** Time when the CloudKMS error was seen. */
  timestamp: Date | undefined;
}

/**
 * ListUsableSubnetworksRequest requests the list of usable subnetworks
 * available to a user for creating clusters.
 */
export interface ListUsableSubnetworksRequest {
  /**
   * The parent project where subnetworks are usable.
   * Specified in the format `projects/*`.
   */
  parent: string;
  /**
   * Filtering currently only supports equality on the networkProjectId and must
   * be in the form: "networkProjectId=[PROJECTID]", where `networkProjectId`
   * is the project which owns the listed subnetworks. This defaults to the
   * parent project ID.
   */
  filter: string;
  /**
   * The max number of results per page that should be returned. If the number
   * of available results is larger than `page_size`, a `next_page_token` is
   * returned which can be used to get the next page of results in subsequent
   * requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
   */
  pageSize: number;
  /**
   * Specifies a page token to use. Set this to the nextPageToken returned by
   * previous list requests to get the next page of results.
   */
  pageToken: string;
}

/**
 * ListUsableSubnetworksResponse is the response of
 * ListUsableSubnetworksRequest.
 */
export interface ListUsableSubnetworksResponse {
  /** A list of usable subnetworks in the specified network project. */
  subnetworks: UsableSubnetwork[];
  /**
   * This token allows you to get the next page of results for list requests.
   * If the number of results is larger than `page_size`, use the
   * `next_page_token` as a value for the query parameter `page_token` in the
   * next request. The value will become empty when there are no more pages.
   */
  nextPageToken: string;
}

/** Secondary IP range of a usable subnetwork. */
export interface UsableSubnetworkSecondaryRange {
  /**
   * The name associated with this subnetwork secondary range, used when adding
   * an alias IP range to a VM instance.
   */
  rangeName: string;
  /** The range of IP addresses belonging to this subnetwork secondary range. */
  ipCidrRange: string;
  /** This field is to determine the status of the secondary range programmably. */
  status: UsableSubnetworkSecondaryRange_Status;
}

/** Status shows the current usage of a secondary IP range. */
export enum UsableSubnetworkSecondaryRange_Status {
  /** UNKNOWN - UNKNOWN is the zero value of the Status enum. It's not a valid status. */
  UNKNOWN = 0,
  /** UNUSED - UNUSED denotes that this range is unclaimed by any cluster. */
  UNUSED = 1,
  /**
   * IN_USE_SERVICE - IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
   * services. User-managed services range can be shared between clusters
   * within the same subnetwork.
   */
  IN_USE_SERVICE = 2,
  /**
   * IN_USE_SHAREABLE_POD - IN_USE_SHAREABLE_POD denotes this range was created by the network admin
   * and is currently claimed by a cluster for pods. It can only be used by
   * other clusters as a pod range.
   */
  IN_USE_SHAREABLE_POD = 3,
  /**
   * IN_USE_MANAGED_POD - IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed
   * for pods. It cannot be used for other clusters.
   */
  IN_USE_MANAGED_POD = 4,
  UNRECOGNIZED = -1,
}

export function usableSubnetworkSecondaryRange_StatusFromJSON(object: any): UsableSubnetworkSecondaryRange_Status {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return UsableSubnetworkSecondaryRange_Status.UNKNOWN;
    case 1:
    case "UNUSED":
      return UsableSubnetworkSecondaryRange_Status.UNUSED;
    case 2:
    case "IN_USE_SERVICE":
      return UsableSubnetworkSecondaryRange_Status.IN_USE_SERVICE;
    case 3:
    case "IN_USE_SHAREABLE_POD":
      return UsableSubnetworkSecondaryRange_Status.IN_USE_SHAREABLE_POD;
    case 4:
    case "IN_USE_MANAGED_POD":
      return UsableSubnetworkSecondaryRange_Status.IN_USE_MANAGED_POD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UsableSubnetworkSecondaryRange_Status.UNRECOGNIZED;
  }
}

export function usableSubnetworkSecondaryRange_StatusToJSON(object: UsableSubnetworkSecondaryRange_Status): string {
  switch (object) {
    case UsableSubnetworkSecondaryRange_Status.UNKNOWN:
      return "UNKNOWN";
    case UsableSubnetworkSecondaryRange_Status.UNUSED:
      return "UNUSED";
    case UsableSubnetworkSecondaryRange_Status.IN_USE_SERVICE:
      return "IN_USE_SERVICE";
    case UsableSubnetworkSecondaryRange_Status.IN_USE_SHAREABLE_POD:
      return "IN_USE_SHAREABLE_POD";
    case UsableSubnetworkSecondaryRange_Status.IN_USE_MANAGED_POD:
      return "IN_USE_MANAGED_POD";
    case UsableSubnetworkSecondaryRange_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * UsableSubnetwork resource returns the subnetwork name, its associated network
 * and the primary CIDR range.
 */
export interface UsableSubnetwork {
  /**
   * Subnetwork Name.
   * Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
   */
  subnetwork: string;
  /**
   * Network Name.
   * Example: projects/my-project/global/networks/my-network
   */
  network: string;
  /** The range of internal addresses that are owned by this subnetwork. */
  ipCidrRange: string;
  /** Secondary IP ranges. */
  secondaryIpRanges: UsableSubnetworkSecondaryRange[];
  /**
   * A human readable status message representing the reasons for cases where
   * the caller cannot use the secondary ranges under the subnet. For example if
   * the secondary_ip_ranges is empty due to a permission issue, an insufficient
   * permission message will be given by status_message.
   */
  statusMessage: string;
}

/** Configuration for exporting cluster resource usages. */
export interface ResourceUsageExportConfig {
  /** Configuration to use BigQuery as usage export destination. */
  bigqueryDestination:
    | ResourceUsageExportConfig_BigQueryDestination
    | undefined;
  /**
   * Whether to enable network egress metering for this cluster. If enabled, a
   * daemonset will be created in the cluster to meter network egress traffic.
   */
  enableNetworkEgressMetering: boolean;
  /** Configuration to enable resource consumption metering. */
  consumptionMeteringConfig: ResourceUsageExportConfig_ConsumptionMeteringConfig | undefined;
}

/** Parameters for using BigQuery as the destination of resource usage export. */
export interface ResourceUsageExportConfig_BigQueryDestination {
  /** The ID of a BigQuery Dataset. */
  datasetId: string;
}

/** Parameters for controlling consumption metering. */
export interface ResourceUsageExportConfig_ConsumptionMeteringConfig {
  /**
   * Whether to enable consumption metering for this cluster. If enabled, a
   * second BigQuery table will be created to hold resource consumption
   * records.
   */
  enabled: boolean;
}

/**
 * VerticalPodAutoscaling contains global, per-cluster information
 * required by Vertical Pod Autoscaler to automatically adjust
 * the resources of pods controlled by it.
 */
export interface VerticalPodAutoscaling {
  /** Enables vertical pod autoscaling. */
  enabled: boolean;
}

/**
 * DefaultSnatStatus contains the desired state of whether default sNAT should
 * be disabled on the cluster.
 */
export interface DefaultSnatStatus {
  /** Disables cluster default sNAT rules. */
  disabled: boolean;
}

/** Configuration of Shielded Nodes feature. */
export interface ShieldedNodes {
  /** Whether Shielded Nodes features are enabled on all nodes in this cluster. */
  enabled: boolean;
}

/** Configuration of gVNIC feature. */
export interface VirtualNIC {
  /** Whether gVNIC features are enabled in the node pool. */
  enabled: boolean;
}

/** Configuration of Fast Socket feature. */
export interface FastSocket {
  /** Whether Fast Socket features are enabled in the node pool. */
  enabled: boolean;
}

/** NotificationConfig is the configuration of notifications. */
export interface NotificationConfig {
  /** Notification config for Pub/Sub. */
  pubsub: NotificationConfig_PubSub | undefined;
}

/**
 * Types of notifications currently supported. Can be used to filter what
 * notifications are sent.
 */
export enum NotificationConfig_EventType {
  /** EVENT_TYPE_UNSPECIFIED - Not set, will be ignored. */
  EVENT_TYPE_UNSPECIFIED = 0,
  /** UPGRADE_AVAILABLE_EVENT - Corresponds with UpgradeAvailableEvent. */
  UPGRADE_AVAILABLE_EVENT = 1,
  /** UPGRADE_EVENT - Corresponds with UpgradeEvent. */
  UPGRADE_EVENT = 2,
  /** SECURITY_BULLETIN_EVENT - Corresponds with SecurityBulletinEvent. */
  SECURITY_BULLETIN_EVENT = 3,
  UNRECOGNIZED = -1,
}

export function notificationConfig_EventTypeFromJSON(object: any): NotificationConfig_EventType {
  switch (object) {
    case 0:
    case "EVENT_TYPE_UNSPECIFIED":
      return NotificationConfig_EventType.EVENT_TYPE_UNSPECIFIED;
    case 1:
    case "UPGRADE_AVAILABLE_EVENT":
      return NotificationConfig_EventType.UPGRADE_AVAILABLE_EVENT;
    case 2:
    case "UPGRADE_EVENT":
      return NotificationConfig_EventType.UPGRADE_EVENT;
    case 3:
    case "SECURITY_BULLETIN_EVENT":
      return NotificationConfig_EventType.SECURITY_BULLETIN_EVENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NotificationConfig_EventType.UNRECOGNIZED;
  }
}

export function notificationConfig_EventTypeToJSON(object: NotificationConfig_EventType): string {
  switch (object) {
    case NotificationConfig_EventType.EVENT_TYPE_UNSPECIFIED:
      return "EVENT_TYPE_UNSPECIFIED";
    case NotificationConfig_EventType.UPGRADE_AVAILABLE_EVENT:
      return "UPGRADE_AVAILABLE_EVENT";
    case NotificationConfig_EventType.UPGRADE_EVENT:
      return "UPGRADE_EVENT";
    case NotificationConfig_EventType.SECURITY_BULLETIN_EVENT:
      return "SECURITY_BULLETIN_EVENT";
    case NotificationConfig_EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Pub/Sub specific notification config. */
export interface NotificationConfig_PubSub {
  /** Enable notifications for Pub/Sub. */
  enabled: boolean;
  /**
   * The desired Pub/Sub topic to which notifications will be
   * sent by GKE. Format is `projects/{project}/topics/{topic}`.
   */
  topic: string;
  /**
   * Allows filtering to one or more specific event types. If no filter is
   * specified, or if a filter is specified with no event types, all event
   * types will be sent
   */
  filter: NotificationConfig_Filter | undefined;
}

/**
 * Allows filtering to one or more specific event types. If event types are
 * present, those and only those event types will be transmitted to the
 * cluster. Other types will be skipped. If no filter is specified, or no
 * event types are present, all event types will be sent
 */
export interface NotificationConfig_Filter {
  /** Event types to allowlist. */
  eventType: NotificationConfig_EventType[];
}

/**
 * ConfidentialNodes is configuration for the confidential nodes feature, which
 * makes nodes run on confidential VMs.
 */
export interface ConfidentialNodes {
  /** Whether Confidential Nodes feature is enabled. */
  enabled: boolean;
}

/**
 * UpgradeEvent is a notification sent to customers by the cluster server when
 * a resource is upgrading.
 */
export interface UpgradeEvent {
  /** The resource type that is upgrading. */
  resourceType: UpgradeResourceType;
  /** The operation associated with this upgrade. */
  operation: string;
  /** The time when the operation was started. */
  operationStartTime:
    | Date
    | undefined;
  /** The current version before the upgrade. */
  currentVersion: string;
  /** The target version for the upgrade. */
  targetVersion: string;
  /**
   * Optional relative path to the resource. For example in node pool upgrades,
   * the relative path of the node pool.
   */
  resource: string;
}

/**
 * UpgradeAvailableEvent is a notification sent to customers when a new
 * available version is released.
 */
export interface UpgradeAvailableEvent {
  /** The release version available for upgrade. */
  version: string;
  /** The resource type of the release version. */
  resourceType: UpgradeResourceType;
  /**
   * The release channel of the version. If empty, it means a non-channel
   * release.
   */
  releaseChannel:
    | ReleaseChannel
    | undefined;
  /**
   * Optional relative path to the resource. For example, the relative path of
   * the node pool.
   */
  resource: string;
}

/**
 * SecurityBulletinEvent is a notification sent to customers when a security
 * bulletin has been posted that they are vulnerable to.
 */
export interface SecurityBulletinEvent {
  /**
   * The resource type (node/control plane) that has the vulnerability. Multiple
   * notifications (1 notification per resource type) will be sent for a
   * vulnerability that affects > 1 resource type.
   */
  resourceTypeAffected: string;
  /** The ID of the bulletin corresponding to the vulnerability. */
  bulletinId: string;
  /** The CVEs associated with this bulletin. */
  cveIds: string[];
  /** The severity of this bulletin as it relates to GKE. */
  severity: string;
  /** The URI link to the bulletin on the website for more information. */
  bulletinUri: string;
  /**
   * A brief description of the bulletin. See the bulletin pointed to by the
   * bulletin_uri field for an expanded description.
   */
  briefDescription: string;
  /** The GKE minor versions affected by this vulnerability. */
  affectedSupportedMinors: string[];
  /** The GKE versions where this vulnerability is patched. */
  patchedVersions: string[];
  /**
   * This represents a version selected from the patched_versions field that
   * the cluster receiving this notification should most likely want to upgrade
   * to based on its current version. Note that if this notification is being
   * received by a given cluster, it means that this version is currently
   * available as an upgrade target in that cluster's location.
   */
  suggestedUpgradeTarget: string;
  /**
   * If this field is specified, it means there are manual steps that the user
   * must take to make their clusters safe.
   */
  manualStepsRequired: boolean;
}

/** Autopilot is the configuration for Autopilot settings on the cluster. */
export interface Autopilot {
  /** Enable Autopilot */
  enabled: boolean;
  /** Workload policy configuration for Autopilot. */
  workloadPolicyConfig: WorkloadPolicyConfig | undefined;
}

/**
 * WorkloadPolicyConfig is the configuration of workload policy for autopilot
 * clusters.
 */
export interface WorkloadPolicyConfig {
  /** If true, workloads can use NET_ADMIN capability. */
  allowNetAdmin?: boolean | undefined;
}

/** LoggingConfig is cluster logging configuration. */
export interface LoggingConfig {
  /** Logging components configuration */
  componentConfig: LoggingComponentConfig | undefined;
}

/** LoggingComponentConfig is cluster logging component configuration. */
export interface LoggingComponentConfig {
  /** Select components to collect logs. An empty set would disable all logging. */
  enableComponents: LoggingComponentConfig_Component[];
}

/** GKE components exposing logs */
export enum LoggingComponentConfig_Component {
  /** COMPONENT_UNSPECIFIED - Default value. This shouldn't be used. */
  COMPONENT_UNSPECIFIED = 0,
  /** SYSTEM_COMPONENTS - system components */
  SYSTEM_COMPONENTS = 1,
  /** WORKLOADS - workloads */
  WORKLOADS = 2,
  /** APISERVER - kube-apiserver */
  APISERVER = 3,
  /** SCHEDULER - kube-scheduler */
  SCHEDULER = 4,
  /** CONTROLLER_MANAGER - kube-controller-manager */
  CONTROLLER_MANAGER = 5,
  UNRECOGNIZED = -1,
}

export function loggingComponentConfig_ComponentFromJSON(object: any): LoggingComponentConfig_Component {
  switch (object) {
    case 0:
    case "COMPONENT_UNSPECIFIED":
      return LoggingComponentConfig_Component.COMPONENT_UNSPECIFIED;
    case 1:
    case "SYSTEM_COMPONENTS":
      return LoggingComponentConfig_Component.SYSTEM_COMPONENTS;
    case 2:
    case "WORKLOADS":
      return LoggingComponentConfig_Component.WORKLOADS;
    case 3:
    case "APISERVER":
      return LoggingComponentConfig_Component.APISERVER;
    case 4:
    case "SCHEDULER":
      return LoggingComponentConfig_Component.SCHEDULER;
    case 5:
    case "CONTROLLER_MANAGER":
      return LoggingComponentConfig_Component.CONTROLLER_MANAGER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggingComponentConfig_Component.UNRECOGNIZED;
  }
}

export function loggingComponentConfig_ComponentToJSON(object: LoggingComponentConfig_Component): string {
  switch (object) {
    case LoggingComponentConfig_Component.COMPONENT_UNSPECIFIED:
      return "COMPONENT_UNSPECIFIED";
    case LoggingComponentConfig_Component.SYSTEM_COMPONENTS:
      return "SYSTEM_COMPONENTS";
    case LoggingComponentConfig_Component.WORKLOADS:
      return "WORKLOADS";
    case LoggingComponentConfig_Component.APISERVER:
      return "APISERVER";
    case LoggingComponentConfig_Component.SCHEDULER:
      return "SCHEDULER";
    case LoggingComponentConfig_Component.CONTROLLER_MANAGER:
      return "CONTROLLER_MANAGER";
    case LoggingComponentConfig_Component.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RayClusterLoggingConfig specifies configuration of Ray logging. */
export interface RayClusterLoggingConfig {
  /** Enable log collection for Ray clusters. */
  enabled: boolean;
}

/** MonitoringConfig is cluster monitoring configuration. */
export interface MonitoringConfig {
  /** Monitoring components configuration */
  componentConfig:
    | MonitoringComponentConfig
    | undefined;
  /**
   * Enable Google Cloud Managed Service for Prometheus
   * in the cluster.
   */
  managedPrometheusConfig:
    | ManagedPrometheusConfig
    | undefined;
  /** Configuration of Advanced Datapath Observability features. */
  advancedDatapathObservabilityConfig: AdvancedDatapathObservabilityConfig | undefined;
}

/**
 * AdvancedDatapathObservabilityConfig specifies configuration of observability
 * features of advanced datapath.
 */
export interface AdvancedDatapathObservabilityConfig {
  /** Expose flow metrics on nodes */
  enableMetrics: boolean;
  /** Method used to make Relay available */
  relayMode: AdvancedDatapathObservabilityConfig_RelayMode;
  /** Enable Relay component */
  enableRelay?: boolean | undefined;
}

/** Supported Relay modes */
export enum AdvancedDatapathObservabilityConfig_RelayMode {
  /** RELAY_MODE_UNSPECIFIED - Default value. This shouldn't be used. */
  RELAY_MODE_UNSPECIFIED = 0,
  /** DISABLED - disabled */
  DISABLED = 1,
  /** INTERNAL_VPC_LB - exposed via internal load balancer */
  INTERNAL_VPC_LB = 3,
  /** EXTERNAL_LB - exposed via external load balancer */
  EXTERNAL_LB = 4,
  UNRECOGNIZED = -1,
}

export function advancedDatapathObservabilityConfig_RelayModeFromJSON(
  object: any,
): AdvancedDatapathObservabilityConfig_RelayMode {
  switch (object) {
    case 0:
    case "RELAY_MODE_UNSPECIFIED":
      return AdvancedDatapathObservabilityConfig_RelayMode.RELAY_MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return AdvancedDatapathObservabilityConfig_RelayMode.DISABLED;
    case 3:
    case "INTERNAL_VPC_LB":
      return AdvancedDatapathObservabilityConfig_RelayMode.INTERNAL_VPC_LB;
    case 4:
    case "EXTERNAL_LB":
      return AdvancedDatapathObservabilityConfig_RelayMode.EXTERNAL_LB;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AdvancedDatapathObservabilityConfig_RelayMode.UNRECOGNIZED;
  }
}

export function advancedDatapathObservabilityConfig_RelayModeToJSON(
  object: AdvancedDatapathObservabilityConfig_RelayMode,
): string {
  switch (object) {
    case AdvancedDatapathObservabilityConfig_RelayMode.RELAY_MODE_UNSPECIFIED:
      return "RELAY_MODE_UNSPECIFIED";
    case AdvancedDatapathObservabilityConfig_RelayMode.DISABLED:
      return "DISABLED";
    case AdvancedDatapathObservabilityConfig_RelayMode.INTERNAL_VPC_LB:
      return "INTERNAL_VPC_LB";
    case AdvancedDatapathObservabilityConfig_RelayMode.EXTERNAL_LB:
      return "EXTERNAL_LB";
    case AdvancedDatapathObservabilityConfig_RelayMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * RayClusterMonitoringConfig specifies monitoring configuration for Ray
 * clusters.
 */
export interface RayClusterMonitoringConfig {
  /** Enable metrics collection for Ray clusters. */
  enabled: boolean;
}

/** NodePoolLoggingConfig specifies logging configuration for nodepools. */
export interface NodePoolLoggingConfig {
  /** Logging variant configuration. */
  variantConfig: LoggingVariantConfig | undefined;
}

/** LoggingVariantConfig specifies the behaviour of the logging component. */
export interface LoggingVariantConfig {
  /** Logging variant deployed on nodes. */
  variant: LoggingVariantConfig_Variant;
}

/** Logging component variants. */
export enum LoggingVariantConfig_Variant {
  /** VARIANT_UNSPECIFIED - Default value. This shouldn't be used. */
  VARIANT_UNSPECIFIED = 0,
  /** DEFAULT - default logging variant. */
  DEFAULT = 1,
  /** MAX_THROUGHPUT - maximum logging throughput variant. */
  MAX_THROUGHPUT = 2,
  UNRECOGNIZED = -1,
}

export function loggingVariantConfig_VariantFromJSON(object: any): LoggingVariantConfig_Variant {
  switch (object) {
    case 0:
    case "VARIANT_UNSPECIFIED":
      return LoggingVariantConfig_Variant.VARIANT_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return LoggingVariantConfig_Variant.DEFAULT;
    case 2:
    case "MAX_THROUGHPUT":
      return LoggingVariantConfig_Variant.MAX_THROUGHPUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggingVariantConfig_Variant.UNRECOGNIZED;
  }
}

export function loggingVariantConfig_VariantToJSON(object: LoggingVariantConfig_Variant): string {
  switch (object) {
    case LoggingVariantConfig_Variant.VARIANT_UNSPECIFIED:
      return "VARIANT_UNSPECIFIED";
    case LoggingVariantConfig_Variant.DEFAULT:
      return "DEFAULT";
    case LoggingVariantConfig_Variant.MAX_THROUGHPUT:
      return "MAX_THROUGHPUT";
    case LoggingVariantConfig_Variant.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MonitoringComponentConfig is cluster monitoring component configuration. */
export interface MonitoringComponentConfig {
  /**
   * Select components to collect metrics. An empty set would disable all
   * monitoring.
   */
  enableComponents: MonitoringComponentConfig_Component[];
}

/** GKE components exposing metrics */
export enum MonitoringComponentConfig_Component {
  /** COMPONENT_UNSPECIFIED - Default value. This shouldn't be used. */
  COMPONENT_UNSPECIFIED = 0,
  /** SYSTEM_COMPONENTS - system components */
  SYSTEM_COMPONENTS = 1,
  /** APISERVER - kube-apiserver */
  APISERVER = 3,
  /** SCHEDULER - kube-scheduler */
  SCHEDULER = 4,
  /** CONTROLLER_MANAGER - kube-controller-manager */
  CONTROLLER_MANAGER = 5,
  /** STORAGE - Storage */
  STORAGE = 7,
  /** HPA - Horizontal Pod Autoscaling */
  HPA = 8,
  /** POD - Pod */
  POD = 9,
  /** DAEMONSET - DaemonSet */
  DAEMONSET = 10,
  /** DEPLOYMENT - Deployment */
  DEPLOYMENT = 11,
  /** STATEFULSET - Statefulset */
  STATEFULSET = 12,
  /** CADVISOR - CADVISOR */
  CADVISOR = 13,
  /** KUBELET - KUBELET */
  KUBELET = 14,
  /** DCGM - NVIDIA Data Center GPU Manager (DCGM) */
  DCGM = 15,
  UNRECOGNIZED = -1,
}

export function monitoringComponentConfig_ComponentFromJSON(object: any): MonitoringComponentConfig_Component {
  switch (object) {
    case 0:
    case "COMPONENT_UNSPECIFIED":
      return MonitoringComponentConfig_Component.COMPONENT_UNSPECIFIED;
    case 1:
    case "SYSTEM_COMPONENTS":
      return MonitoringComponentConfig_Component.SYSTEM_COMPONENTS;
    case 3:
    case "APISERVER":
      return MonitoringComponentConfig_Component.APISERVER;
    case 4:
    case "SCHEDULER":
      return MonitoringComponentConfig_Component.SCHEDULER;
    case 5:
    case "CONTROLLER_MANAGER":
      return MonitoringComponentConfig_Component.CONTROLLER_MANAGER;
    case 7:
    case "STORAGE":
      return MonitoringComponentConfig_Component.STORAGE;
    case 8:
    case "HPA":
      return MonitoringComponentConfig_Component.HPA;
    case 9:
    case "POD":
      return MonitoringComponentConfig_Component.POD;
    case 10:
    case "DAEMONSET":
      return MonitoringComponentConfig_Component.DAEMONSET;
    case 11:
    case "DEPLOYMENT":
      return MonitoringComponentConfig_Component.DEPLOYMENT;
    case 12:
    case "STATEFULSET":
      return MonitoringComponentConfig_Component.STATEFULSET;
    case 13:
    case "CADVISOR":
      return MonitoringComponentConfig_Component.CADVISOR;
    case 14:
    case "KUBELET":
      return MonitoringComponentConfig_Component.KUBELET;
    case 15:
    case "DCGM":
      return MonitoringComponentConfig_Component.DCGM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MonitoringComponentConfig_Component.UNRECOGNIZED;
  }
}

export function monitoringComponentConfig_ComponentToJSON(object: MonitoringComponentConfig_Component): string {
  switch (object) {
    case MonitoringComponentConfig_Component.COMPONENT_UNSPECIFIED:
      return "COMPONENT_UNSPECIFIED";
    case MonitoringComponentConfig_Component.SYSTEM_COMPONENTS:
      return "SYSTEM_COMPONENTS";
    case MonitoringComponentConfig_Component.APISERVER:
      return "APISERVER";
    case MonitoringComponentConfig_Component.SCHEDULER:
      return "SCHEDULER";
    case MonitoringComponentConfig_Component.CONTROLLER_MANAGER:
      return "CONTROLLER_MANAGER";
    case MonitoringComponentConfig_Component.STORAGE:
      return "STORAGE";
    case MonitoringComponentConfig_Component.HPA:
      return "HPA";
    case MonitoringComponentConfig_Component.POD:
      return "POD";
    case MonitoringComponentConfig_Component.DAEMONSET:
      return "DAEMONSET";
    case MonitoringComponentConfig_Component.DEPLOYMENT:
      return "DEPLOYMENT";
    case MonitoringComponentConfig_Component.STATEFULSET:
      return "STATEFULSET";
    case MonitoringComponentConfig_Component.CADVISOR:
      return "CADVISOR";
    case MonitoringComponentConfig_Component.KUBELET:
      return "KUBELET";
    case MonitoringComponentConfig_Component.DCGM:
      return "DCGM";
    case MonitoringComponentConfig_Component.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ManagedPrometheusConfig defines the configuration for
 * Google Cloud Managed Service for Prometheus.
 */
export interface ManagedPrometheusConfig {
  /** Enable Managed Collection. */
  enabled: boolean;
}

/** Fleet is the fleet configuration for the cluster. */
export interface Fleet {
  /**
   * The Fleet host project(project ID or project number) where this cluster
   * will be registered to. This field cannot be changed after the cluster has
   * been registered.
   */
  project: string;
  /**
   * Output only. The full resource name of the registered fleet membership of
   * the cluster, in the format
   * `//gkehub.googleapis.com/projects/* /locations/* /memberships/*`.
   */
  membership: string;
  /**
   * Output only. Whether the cluster has been registered through the fleet
   * API.
   */
  preRegistered: boolean;
}

/**
 * LocalNvmeSsdBlockConfig contains configuration for using raw-block local
 * NVMe SSDs
 */
export interface LocalNvmeSsdBlockConfig {
  /**
   * Number of local NVMe SSDs to use.  The limit for this value is dependent
   * upon the maximum number of disk available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd
   * for more information.
   *
   * A zero (or unset) value has different meanings depending on machine type
   * being used:
   * 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
   * zero (or unset) means to disable using local SSDs as ephemeral storage.
   * 2. For Gen3 machines which dictate a specific number of local ssds, zero
   * (or unset) means to use the default number of local ssds that goes with
   * that machine type. For example, for a c3-standard-8-lssd machine, 2 local
   * ssds would be provisioned. For c3-standard-8 (which doesn't support local
   * ssds), 0 will be provisioned. See
   * https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds
   * for more info.
   */
  localSsdCount: number;
}

/**
 * EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral
 * storage using Local SSDs.
 */
export interface EphemeralStorageLocalSsdConfig {
  /**
   * Number of local SSDs to use to back ephemeral storage. Uses NVMe
   * interfaces.
   *
   * A zero (or unset) value has different meanings depending on machine type
   * being used:
   * 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
   * zero (or unset) means to disable using local SSDs as ephemeral storage. The
   * limit for this value is dependent upon the maximum number of disk
   * available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd
   * for more information.
   * 2. For Gen3 machines which dictate a specific number of local ssds, zero
   * (or unset) means to use the default number of local ssds that goes with
   * that machine type. For example, for a c3-standard-8-lssd machine, 2 local
   * ssds would be provisioned. For c3-standard-8 (which doesn't support local
   * ssds), 0 will be provisioned. See
   * https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds
   * for more info.
   */
  localSsdCount: number;
}

/**
 * A map of resource manager tag keys and values to be attached to the nodes
 * for managing Compute Engine firewalls using Network Firewall Policies.
 * Tags must be according to specifications in
 * https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications.
 * A maximum of 5 tag key-value pairs can be specified.
 * Existing tags will be replaced with new values.
 */
export interface ResourceManagerTags {
  /**
   * TagKeyValue must be in one of the following formats ([KEY]=[VALUE])
   * 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}`
   * 2. `{org_id}/{tag_key_name}={tag_value_name}`
   * 3. `{project_id}/{tag_key_name}={tag_value_name}`
   */
  tags: { [key: string]: string };
}

export interface ResourceManagerTags_TagsEntry {
  key: string;
  value: string;
}

/** EnterpriseConfig is the cluster enterprise configuration. */
export interface EnterpriseConfig {
  /** Output only. cluster_tier specifies the premium tier of the cluster. */
  clusterTier: EnterpriseConfig_ClusterTier;
}

/** Premium tiers for GKE Cluster. */
export enum EnterpriseConfig_ClusterTier {
  /** CLUSTER_TIER_UNSPECIFIED - CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set. */
  CLUSTER_TIER_UNSPECIFIED = 0,
  /** STANDARD - STANDARD indicates a standard GKE cluster. */
  STANDARD = 1,
  /** ENTERPRISE - ENTERPRISE indicates a GKE Enterprise cluster. */
  ENTERPRISE = 2,
  UNRECOGNIZED = -1,
}

export function enterpriseConfig_ClusterTierFromJSON(object: any): EnterpriseConfig_ClusterTier {
  switch (object) {
    case 0:
    case "CLUSTER_TIER_UNSPECIFIED":
      return EnterpriseConfig_ClusterTier.CLUSTER_TIER_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return EnterpriseConfig_ClusterTier.STANDARD;
    case 2:
    case "ENTERPRISE":
      return EnterpriseConfig_ClusterTier.ENTERPRISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnterpriseConfig_ClusterTier.UNRECOGNIZED;
  }
}

export function enterpriseConfig_ClusterTierToJSON(object: EnterpriseConfig_ClusterTier): string {
  switch (object) {
    case EnterpriseConfig_ClusterTier.CLUSTER_TIER_UNSPECIFIED:
      return "CLUSTER_TIER_UNSPECIFIED";
    case EnterpriseConfig_ClusterTier.STANDARD:
      return "STANDARD";
    case EnterpriseConfig_ClusterTier.ENTERPRISE:
      return "ENTERPRISE";
    case EnterpriseConfig_ClusterTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * SecondaryBootDisk represents a persistent disk attached to a node
 * with special configurations based on its mode.
 */
export interface SecondaryBootDisk {
  /** Disk mode (container image cache, etc.) */
  mode: SecondaryBootDisk_Mode;
  /** Fully-qualified resource ID for an existing disk image. */
  diskImage: string;
}

/**
 * Mode specifies how the secondary boot disk will be used.
 * This triggers mode-specified logic in the control plane.
 */
export enum SecondaryBootDisk_Mode {
  /** MODE_UNSPECIFIED - MODE_UNSPECIFIED is when mode is not set. */
  MODE_UNSPECIFIED = 0,
  /**
   * CONTAINER_IMAGE_CACHE - CONTAINER_IMAGE_CACHE is for using the secondary boot disk as
   * a container image cache.
   */
  CONTAINER_IMAGE_CACHE = 1,
  UNRECOGNIZED = -1,
}

export function secondaryBootDisk_ModeFromJSON(object: any): SecondaryBootDisk_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SecondaryBootDisk_Mode.MODE_UNSPECIFIED;
    case 1:
    case "CONTAINER_IMAGE_CACHE":
      return SecondaryBootDisk_Mode.CONTAINER_IMAGE_CACHE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SecondaryBootDisk_Mode.UNRECOGNIZED;
  }
}

export function secondaryBootDisk_ModeToJSON(object: SecondaryBootDisk_Mode): string {
  switch (object) {
    case SecondaryBootDisk_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SecondaryBootDisk_Mode.CONTAINER_IMAGE_CACHE:
      return "CONTAINER_IMAGE_CACHE";
    case SecondaryBootDisk_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * SecondaryBootDiskUpdateStrategy is a placeholder which will be extended
 * in the future to define different options for updating secondary boot disks.
 */
export interface SecondaryBootDiskUpdateStrategy {
}

function createBaseLinuxNodeConfig(): LinuxNodeConfig {
  return { sysctls: {}, cgroupMode: 0, hugepages: undefined };
}

export const LinuxNodeConfig: MessageFns<LinuxNodeConfig> = {
  encode(message: LinuxNodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.sysctls).forEach(([key, value]) => {
      LinuxNodeConfig_SysctlsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.cgroupMode !== 0) {
      writer.uint32(16).int32(message.cgroupMode);
    }
    if (message.hugepages !== undefined) {
      LinuxNodeConfig_HugepagesConfig.encode(message.hugepages, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinuxNodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinuxNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = LinuxNodeConfig_SysctlsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.sysctls[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cgroupMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hugepages = LinuxNodeConfig_HugepagesConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinuxNodeConfig {
    return {
      sysctls: isObject(object.sysctls)
        ? Object.entries(object.sysctls).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      cgroupMode: isSet(object.cgroupMode) ? linuxNodeConfig_CgroupModeFromJSON(object.cgroupMode) : 0,
      hugepages: isSet(object.hugepages) ? LinuxNodeConfig_HugepagesConfig.fromJSON(object.hugepages) : undefined,
    };
  },

  toJSON(message: LinuxNodeConfig): unknown {
    const obj: any = {};
    if (message.sysctls) {
      const entries = Object.entries(message.sysctls);
      if (entries.length > 0) {
        obj.sysctls = {};
        entries.forEach(([k, v]) => {
          obj.sysctls[k] = v;
        });
      }
    }
    if (message.cgroupMode !== 0) {
      obj.cgroupMode = linuxNodeConfig_CgroupModeToJSON(message.cgroupMode);
    }
    if (message.hugepages !== undefined) {
      obj.hugepages = LinuxNodeConfig_HugepagesConfig.toJSON(message.hugepages);
    }
    return obj;
  },

  create(base?: DeepPartial<LinuxNodeConfig>): LinuxNodeConfig {
    return LinuxNodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinuxNodeConfig>): LinuxNodeConfig {
    const message = createBaseLinuxNodeConfig();
    message.sysctls = Object.entries(object.sysctls ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.cgroupMode = object.cgroupMode ?? 0;
    message.hugepages = (object.hugepages !== undefined && object.hugepages !== null)
      ? LinuxNodeConfig_HugepagesConfig.fromPartial(object.hugepages)
      : undefined;
    return message;
  },
};

function createBaseLinuxNodeConfig_HugepagesConfig(): LinuxNodeConfig_HugepagesConfig {
  return { hugepageSize2m: undefined, hugepageSize1g: undefined };
}

export const LinuxNodeConfig_HugepagesConfig: MessageFns<LinuxNodeConfig_HugepagesConfig> = {
  encode(message: LinuxNodeConfig_HugepagesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hugepageSize2m !== undefined) {
      writer.uint32(8).int32(message.hugepageSize2m);
    }
    if (message.hugepageSize1g !== undefined) {
      writer.uint32(16).int32(message.hugepageSize1g);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinuxNodeConfig_HugepagesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinuxNodeConfig_HugepagesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hugepageSize2m = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.hugepageSize1g = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinuxNodeConfig_HugepagesConfig {
    return {
      hugepageSize2m: isSet(object.hugepageSize2m) ? globalThis.Number(object.hugepageSize2m) : undefined,
      hugepageSize1g: isSet(object.hugepageSize1g) ? globalThis.Number(object.hugepageSize1g) : undefined,
    };
  },

  toJSON(message: LinuxNodeConfig_HugepagesConfig): unknown {
    const obj: any = {};
    if (message.hugepageSize2m !== undefined) {
      obj.hugepageSize2m = Math.round(message.hugepageSize2m);
    }
    if (message.hugepageSize1g !== undefined) {
      obj.hugepageSize1g = Math.round(message.hugepageSize1g);
    }
    return obj;
  },

  create(base?: DeepPartial<LinuxNodeConfig_HugepagesConfig>): LinuxNodeConfig_HugepagesConfig {
    return LinuxNodeConfig_HugepagesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinuxNodeConfig_HugepagesConfig>): LinuxNodeConfig_HugepagesConfig {
    const message = createBaseLinuxNodeConfig_HugepagesConfig();
    message.hugepageSize2m = object.hugepageSize2m ?? undefined;
    message.hugepageSize1g = object.hugepageSize1g ?? undefined;
    return message;
  },
};

function createBaseLinuxNodeConfig_SysctlsEntry(): LinuxNodeConfig_SysctlsEntry {
  return { key: "", value: "" };
}

export const LinuxNodeConfig_SysctlsEntry: MessageFns<LinuxNodeConfig_SysctlsEntry> = {
  encode(message: LinuxNodeConfig_SysctlsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinuxNodeConfig_SysctlsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinuxNodeConfig_SysctlsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinuxNodeConfig_SysctlsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LinuxNodeConfig_SysctlsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<LinuxNodeConfig_SysctlsEntry>): LinuxNodeConfig_SysctlsEntry {
    return LinuxNodeConfig_SysctlsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LinuxNodeConfig_SysctlsEntry>): LinuxNodeConfig_SysctlsEntry {
    const message = createBaseLinuxNodeConfig_SysctlsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWindowsNodeConfig(): WindowsNodeConfig {
  return { osVersion: 0 };
}

export const WindowsNodeConfig: MessageFns<WindowsNodeConfig> = {
  encode(message: WindowsNodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.osVersion !== 0) {
      writer.uint32(8).int32(message.osVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsNodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.osVersion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsNodeConfig {
    return { osVersion: isSet(object.osVersion) ? windowsNodeConfig_OSVersionFromJSON(object.osVersion) : 0 };
  },

  toJSON(message: WindowsNodeConfig): unknown {
    const obj: any = {};
    if (message.osVersion !== 0) {
      obj.osVersion = windowsNodeConfig_OSVersionToJSON(message.osVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsNodeConfig>): WindowsNodeConfig {
    return WindowsNodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsNodeConfig>): WindowsNodeConfig {
    const message = createBaseWindowsNodeConfig();
    message.osVersion = object.osVersion ?? 0;
    return message;
  },
};

function createBaseNodeKubeletConfig(): NodeKubeletConfig {
  return {
    cpuManagerPolicy: "",
    cpuCfsQuota: undefined,
    cpuCfsQuotaPeriod: "",
    podPidsLimit: Long.ZERO,
    insecureKubeletReadonlyPortEnabled: undefined,
  };
}

export const NodeKubeletConfig: MessageFns<NodeKubeletConfig> = {
  encode(message: NodeKubeletConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuManagerPolicy !== "") {
      writer.uint32(10).string(message.cpuManagerPolicy);
    }
    if (message.cpuCfsQuota !== undefined) {
      BoolValue.encode({ value: message.cpuCfsQuota! }, writer.uint32(18).fork()).join();
    }
    if (message.cpuCfsQuotaPeriod !== "") {
      writer.uint32(26).string(message.cpuCfsQuotaPeriod);
    }
    if (!message.podPidsLimit.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.podPidsLimit.toString());
    }
    if (message.insecureKubeletReadonlyPortEnabled !== undefined) {
      writer.uint32(56).bool(message.insecureKubeletReadonlyPortEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeKubeletConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeKubeletConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpuManagerPolicy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpuCfsQuota = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cpuCfsQuotaPeriod = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.podPidsLimit = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.insecureKubeletReadonlyPortEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeKubeletConfig {
    return {
      cpuManagerPolicy: isSet(object.cpuManagerPolicy) ? globalThis.String(object.cpuManagerPolicy) : "",
      cpuCfsQuota: isSet(object.cpuCfsQuota) ? Boolean(object.cpuCfsQuota) : undefined,
      cpuCfsQuotaPeriod: isSet(object.cpuCfsQuotaPeriod) ? globalThis.String(object.cpuCfsQuotaPeriod) : "",
      podPidsLimit: isSet(object.podPidsLimit) ? Long.fromValue(object.podPidsLimit) : Long.ZERO,
      insecureKubeletReadonlyPortEnabled: isSet(object.insecureKubeletReadonlyPortEnabled)
        ? globalThis.Boolean(object.insecureKubeletReadonlyPortEnabled)
        : undefined,
    };
  },

  toJSON(message: NodeKubeletConfig): unknown {
    const obj: any = {};
    if (message.cpuManagerPolicy !== "") {
      obj.cpuManagerPolicy = message.cpuManagerPolicy;
    }
    if (message.cpuCfsQuota !== undefined) {
      obj.cpuCfsQuota = message.cpuCfsQuota;
    }
    if (message.cpuCfsQuotaPeriod !== "") {
      obj.cpuCfsQuotaPeriod = message.cpuCfsQuotaPeriod;
    }
    if (!message.podPidsLimit.equals(Long.ZERO)) {
      obj.podPidsLimit = (message.podPidsLimit || Long.ZERO).toString();
    }
    if (message.insecureKubeletReadonlyPortEnabled !== undefined) {
      obj.insecureKubeletReadonlyPortEnabled = message.insecureKubeletReadonlyPortEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeKubeletConfig>): NodeKubeletConfig {
    return NodeKubeletConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeKubeletConfig>): NodeKubeletConfig {
    const message = createBaseNodeKubeletConfig();
    message.cpuManagerPolicy = object.cpuManagerPolicy ?? "";
    message.cpuCfsQuota = object.cpuCfsQuota ?? undefined;
    message.cpuCfsQuotaPeriod = object.cpuCfsQuotaPeriod ?? "";
    message.podPidsLimit = (object.podPidsLimit !== undefined && object.podPidsLimit !== null)
      ? Long.fromValue(object.podPidsLimit)
      : Long.ZERO;
    message.insecureKubeletReadonlyPortEnabled = object.insecureKubeletReadonlyPortEnabled ?? undefined;
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return {
    machineType: "",
    diskSizeGb: 0,
    oauthScopes: [],
    serviceAccount: "",
    metadata: {},
    imageType: "",
    labels: {},
    localSsdCount: 0,
    tags: [],
    preemptible: false,
    accelerators: [],
    diskType: "",
    minCpuPlatform: "",
    workloadMetadataConfig: undefined,
    taints: [],
    sandboxConfig: undefined,
    nodeGroup: "",
    reservationAffinity: undefined,
    shieldedInstanceConfig: undefined,
    linuxNodeConfig: undefined,
    kubeletConfig: undefined,
    bootDiskKmsKey: "",
    gcfsConfig: undefined,
    advancedMachineFeatures: undefined,
    gvnic: undefined,
    spot: false,
    confidentialNodes: undefined,
    fastSocket: undefined,
    resourceLabels: {},
    loggingConfig: undefined,
    windowsNodeConfig: undefined,
    localNvmeSsdBlockConfig: undefined,
    ephemeralStorageLocalSsdConfig: undefined,
    soleTenantConfig: undefined,
    containerdConfig: undefined,
    resourceManagerTags: undefined,
    enableConfidentialStorage: false,
    secondaryBootDisks: [],
    secondaryBootDiskUpdateStrategy: undefined,
  };
}

export const NodeConfig: MessageFns<NodeConfig> = {
  encode(message: NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineType !== "") {
      writer.uint32(10).string(message.machineType);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(16).int32(message.diskSizeGb);
    }
    for (const v of message.oauthScopes) {
      writer.uint32(26).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(74).string(message.serviceAccount);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      NodeConfig_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.imageType !== "") {
      writer.uint32(42).string(message.imageType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      NodeConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.localSsdCount !== 0) {
      writer.uint32(56).int32(message.localSsdCount);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.preemptible !== false) {
      writer.uint32(80).bool(message.preemptible);
    }
    for (const v of message.accelerators) {
      AcceleratorConfig.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.diskType !== "") {
      writer.uint32(98).string(message.diskType);
    }
    if (message.minCpuPlatform !== "") {
      writer.uint32(106).string(message.minCpuPlatform);
    }
    if (message.workloadMetadataConfig !== undefined) {
      WorkloadMetadataConfig.encode(message.workloadMetadataConfig, writer.uint32(114).fork()).join();
    }
    for (const v of message.taints) {
      NodeTaint.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.sandboxConfig !== undefined) {
      SandboxConfig.encode(message.sandboxConfig, writer.uint32(138).fork()).join();
    }
    if (message.nodeGroup !== "") {
      writer.uint32(146).string(message.nodeGroup);
    }
    if (message.reservationAffinity !== undefined) {
      ReservationAffinity.encode(message.reservationAffinity, writer.uint32(154).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(162).fork()).join();
    }
    if (message.linuxNodeConfig !== undefined) {
      LinuxNodeConfig.encode(message.linuxNodeConfig, writer.uint32(170).fork()).join();
    }
    if (message.kubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.kubeletConfig, writer.uint32(178).fork()).join();
    }
    if (message.bootDiskKmsKey !== "") {
      writer.uint32(186).string(message.bootDiskKmsKey);
    }
    if (message.gcfsConfig !== undefined) {
      GcfsConfig.encode(message.gcfsConfig, writer.uint32(202).fork()).join();
    }
    if (message.advancedMachineFeatures !== undefined) {
      AdvancedMachineFeatures.encode(message.advancedMachineFeatures, writer.uint32(210).fork()).join();
    }
    if (message.gvnic !== undefined) {
      VirtualNIC.encode(message.gvnic, writer.uint32(234).fork()).join();
    }
    if (message.spot !== false) {
      writer.uint32(256).bool(message.spot);
    }
    if (message.confidentialNodes !== undefined) {
      ConfidentialNodes.encode(message.confidentialNodes, writer.uint32(282).fork()).join();
    }
    if (message.fastSocket !== undefined) {
      FastSocket.encode(message.fastSocket, writer.uint32(290).fork()).join();
    }
    Object.entries(message.resourceLabels).forEach(([key, value]) => {
      NodeConfig_ResourceLabelsEntry.encode({ key: key as any, value }, writer.uint32(298).fork()).join();
    });
    if (message.loggingConfig !== undefined) {
      NodePoolLoggingConfig.encode(message.loggingConfig, writer.uint32(306).fork()).join();
    }
    if (message.windowsNodeConfig !== undefined) {
      WindowsNodeConfig.encode(message.windowsNodeConfig, writer.uint32(314).fork()).join();
    }
    if (message.localNvmeSsdBlockConfig !== undefined) {
      LocalNvmeSsdBlockConfig.encode(message.localNvmeSsdBlockConfig, writer.uint32(322).fork()).join();
    }
    if (message.ephemeralStorageLocalSsdConfig !== undefined) {
      EphemeralStorageLocalSsdConfig.encode(message.ephemeralStorageLocalSsdConfig, writer.uint32(330).fork()).join();
    }
    if (message.soleTenantConfig !== undefined) {
      SoleTenantConfig.encode(message.soleTenantConfig, writer.uint32(338).fork()).join();
    }
    if (message.containerdConfig !== undefined) {
      ContainerdConfig.encode(message.containerdConfig, writer.uint32(346).fork()).join();
    }
    if (message.resourceManagerTags !== undefined) {
      ResourceManagerTags.encode(message.resourceManagerTags, writer.uint32(362).fork()).join();
    }
    if (message.enableConfidentialStorage !== false) {
      writer.uint32(368).bool(message.enableConfidentialStorage);
    }
    for (const v of message.secondaryBootDisks) {
      SecondaryBootDisk.encode(v!, writer.uint32(386).fork()).join();
    }
    if (message.secondaryBootDiskUpdateStrategy !== undefined) {
      SecondaryBootDiskUpdateStrategy.encode(message.secondaryBootDiskUpdateStrategy, writer.uint32(402).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oauthScopes.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = NodeConfig_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.imageType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = NodeConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.localSsdCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accelerators.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.minCpuPlatform = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.workloadMetadataConfig = WorkloadMetadataConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.taints.push(NodeTaint.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.sandboxConfig = SandboxConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.nodeGroup = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.reservationAffinity = ReservationAffinity.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.shieldedInstanceConfig = ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.linuxNodeConfig = LinuxNodeConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.kubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.bootDiskKmsKey = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.gcfsConfig = GcfsConfig.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.advancedMachineFeatures = AdvancedMachineFeatures.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.gvnic = VirtualNIC.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.spot = reader.bool();
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.confidentialNodes = ConfidentialNodes.decode(reader, reader.uint32());
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.fastSocket = FastSocket.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          const entry37 = NodeConfig_ResourceLabelsEntry.decode(reader, reader.uint32());
          if (entry37.value !== undefined) {
            message.resourceLabels[entry37.key] = entry37.value;
          }
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.loggingConfig = NodePoolLoggingConfig.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.windowsNodeConfig = WindowsNodeConfig.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.localNvmeSsdBlockConfig = LocalNvmeSsdBlockConfig.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.ephemeralStorageLocalSsdConfig = EphemeralStorageLocalSsdConfig.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.soleTenantConfig = SoleTenantConfig.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.containerdConfig = ContainerdConfig.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.resourceManagerTags = ResourceManagerTags.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 368) {
            break;
          }

          message.enableConfidentialStorage = reader.bool();
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.secondaryBootDisks.push(SecondaryBootDisk.decode(reader, reader.uint32()));
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.secondaryBootDiskUpdateStrategy = SecondaryBootDiskUpdateStrategy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      oauthScopes: globalThis.Array.isArray(object?.oauthScopes)
        ? object.oauthScopes.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      imageType: isSet(object.imageType) ? globalThis.String(object.imageType) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      localSsdCount: isSet(object.localSsdCount) ? globalThis.Number(object.localSsdCount) : 0,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : false,
      accelerators: globalThis.Array.isArray(object?.accelerators)
        ? object.accelerators.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      minCpuPlatform: isSet(object.minCpuPlatform) ? globalThis.String(object.minCpuPlatform) : "",
      workloadMetadataConfig: isSet(object.workloadMetadataConfig)
        ? WorkloadMetadataConfig.fromJSON(object.workloadMetadataConfig)
        : undefined,
      taints: globalThis.Array.isArray(object?.taints)
        ? object.taints.map((e: any) => NodeTaint.fromJSON(e))
        : [],
      sandboxConfig: isSet(object.sandboxConfig) ? SandboxConfig.fromJSON(object.sandboxConfig) : undefined,
      nodeGroup: isSet(object.nodeGroup) ? globalThis.String(object.nodeGroup) : "",
      reservationAffinity: isSet(object.reservationAffinity)
        ? ReservationAffinity.fromJSON(object.reservationAffinity)
        : undefined,
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      linuxNodeConfig: isSet(object.linuxNodeConfig) ? LinuxNodeConfig.fromJSON(object.linuxNodeConfig) : undefined,
      kubeletConfig: isSet(object.kubeletConfig) ? NodeKubeletConfig.fromJSON(object.kubeletConfig) : undefined,
      bootDiskKmsKey: isSet(object.bootDiskKmsKey) ? globalThis.String(object.bootDiskKmsKey) : "",
      gcfsConfig: isSet(object.gcfsConfig) ? GcfsConfig.fromJSON(object.gcfsConfig) : undefined,
      advancedMachineFeatures: isSet(object.advancedMachineFeatures)
        ? AdvancedMachineFeatures.fromJSON(object.advancedMachineFeatures)
        : undefined,
      gvnic: isSet(object.gvnic) ? VirtualNIC.fromJSON(object.gvnic) : undefined,
      spot: isSet(object.spot) ? globalThis.Boolean(object.spot) : false,
      confidentialNodes: isSet(object.confidentialNodes)
        ? ConfidentialNodes.fromJSON(object.confidentialNodes)
        : undefined,
      fastSocket: isSet(object.fastSocket) ? FastSocket.fromJSON(object.fastSocket) : undefined,
      resourceLabels: isObject(object.resourceLabels)
        ? Object.entries(object.resourceLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      loggingConfig: isSet(object.loggingConfig) ? NodePoolLoggingConfig.fromJSON(object.loggingConfig) : undefined,
      windowsNodeConfig: isSet(object.windowsNodeConfig)
        ? WindowsNodeConfig.fromJSON(object.windowsNodeConfig)
        : undefined,
      localNvmeSsdBlockConfig: isSet(object.localNvmeSsdBlockConfig)
        ? LocalNvmeSsdBlockConfig.fromJSON(object.localNvmeSsdBlockConfig)
        : undefined,
      ephemeralStorageLocalSsdConfig: isSet(object.ephemeralStorageLocalSsdConfig)
        ? EphemeralStorageLocalSsdConfig.fromJSON(object.ephemeralStorageLocalSsdConfig)
        : undefined,
      soleTenantConfig: isSet(object.soleTenantConfig) ? SoleTenantConfig.fromJSON(object.soleTenantConfig) : undefined,
      containerdConfig: isSet(object.containerdConfig) ? ContainerdConfig.fromJSON(object.containerdConfig) : undefined,
      resourceManagerTags: isSet(object.resourceManagerTags)
        ? ResourceManagerTags.fromJSON(object.resourceManagerTags)
        : undefined,
      enableConfidentialStorage: isSet(object.enableConfidentialStorage)
        ? globalThis.Boolean(object.enableConfidentialStorage)
        : false,
      secondaryBootDisks: globalThis.Array.isArray(object?.secondaryBootDisks)
        ? object.secondaryBootDisks.map((e: any) => SecondaryBootDisk.fromJSON(e))
        : [],
      secondaryBootDiskUpdateStrategy: isSet(object.secondaryBootDiskUpdateStrategy)
        ? SecondaryBootDiskUpdateStrategy.fromJSON(object.secondaryBootDiskUpdateStrategy)
        : undefined,
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.oauthScopes?.length) {
      obj.oauthScopes = message.oauthScopes;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.imageType !== "") {
      obj.imageType = message.imageType;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.localSsdCount !== 0) {
      obj.localSsdCount = Math.round(message.localSsdCount);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.preemptible !== false) {
      obj.preemptible = message.preemptible;
    }
    if (message.accelerators?.length) {
      obj.accelerators = message.accelerators.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.minCpuPlatform !== "") {
      obj.minCpuPlatform = message.minCpuPlatform;
    }
    if (message.workloadMetadataConfig !== undefined) {
      obj.workloadMetadataConfig = WorkloadMetadataConfig.toJSON(message.workloadMetadataConfig);
    }
    if (message.taints?.length) {
      obj.taints = message.taints.map((e) => NodeTaint.toJSON(e));
    }
    if (message.sandboxConfig !== undefined) {
      obj.sandboxConfig = SandboxConfig.toJSON(message.sandboxConfig);
    }
    if (message.nodeGroup !== "") {
      obj.nodeGroup = message.nodeGroup;
    }
    if (message.reservationAffinity !== undefined) {
      obj.reservationAffinity = ReservationAffinity.toJSON(message.reservationAffinity);
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.linuxNodeConfig !== undefined) {
      obj.linuxNodeConfig = LinuxNodeConfig.toJSON(message.linuxNodeConfig);
    }
    if (message.kubeletConfig !== undefined) {
      obj.kubeletConfig = NodeKubeletConfig.toJSON(message.kubeletConfig);
    }
    if (message.bootDiskKmsKey !== "") {
      obj.bootDiskKmsKey = message.bootDiskKmsKey;
    }
    if (message.gcfsConfig !== undefined) {
      obj.gcfsConfig = GcfsConfig.toJSON(message.gcfsConfig);
    }
    if (message.advancedMachineFeatures !== undefined) {
      obj.advancedMachineFeatures = AdvancedMachineFeatures.toJSON(message.advancedMachineFeatures);
    }
    if (message.gvnic !== undefined) {
      obj.gvnic = VirtualNIC.toJSON(message.gvnic);
    }
    if (message.spot !== false) {
      obj.spot = message.spot;
    }
    if (message.confidentialNodes !== undefined) {
      obj.confidentialNodes = ConfidentialNodes.toJSON(message.confidentialNodes);
    }
    if (message.fastSocket !== undefined) {
      obj.fastSocket = FastSocket.toJSON(message.fastSocket);
    }
    if (message.resourceLabels) {
      const entries = Object.entries(message.resourceLabels);
      if (entries.length > 0) {
        obj.resourceLabels = {};
        entries.forEach(([k, v]) => {
          obj.resourceLabels[k] = v;
        });
      }
    }
    if (message.loggingConfig !== undefined) {
      obj.loggingConfig = NodePoolLoggingConfig.toJSON(message.loggingConfig);
    }
    if (message.windowsNodeConfig !== undefined) {
      obj.windowsNodeConfig = WindowsNodeConfig.toJSON(message.windowsNodeConfig);
    }
    if (message.localNvmeSsdBlockConfig !== undefined) {
      obj.localNvmeSsdBlockConfig = LocalNvmeSsdBlockConfig.toJSON(message.localNvmeSsdBlockConfig);
    }
    if (message.ephemeralStorageLocalSsdConfig !== undefined) {
      obj.ephemeralStorageLocalSsdConfig = EphemeralStorageLocalSsdConfig.toJSON(
        message.ephemeralStorageLocalSsdConfig,
      );
    }
    if (message.soleTenantConfig !== undefined) {
      obj.soleTenantConfig = SoleTenantConfig.toJSON(message.soleTenantConfig);
    }
    if (message.containerdConfig !== undefined) {
      obj.containerdConfig = ContainerdConfig.toJSON(message.containerdConfig);
    }
    if (message.resourceManagerTags !== undefined) {
      obj.resourceManagerTags = ResourceManagerTags.toJSON(message.resourceManagerTags);
    }
    if (message.enableConfidentialStorage !== false) {
      obj.enableConfidentialStorage = message.enableConfidentialStorage;
    }
    if (message.secondaryBootDisks?.length) {
      obj.secondaryBootDisks = message.secondaryBootDisks.map((e) => SecondaryBootDisk.toJSON(e));
    }
    if (message.secondaryBootDiskUpdateStrategy !== undefined) {
      obj.secondaryBootDiskUpdateStrategy = SecondaryBootDiskUpdateStrategy.toJSON(
        message.secondaryBootDiskUpdateStrategy,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig>): NodeConfig {
    return NodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig>): NodeConfig {
    const message = createBaseNodeConfig();
    message.machineType = object.machineType ?? "";
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.oauthScopes = object.oauthScopes?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.imageType = object.imageType ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.localSsdCount = object.localSsdCount ?? 0;
    message.tags = object.tags?.map((e) => e) || [];
    message.preemptible = object.preemptible ?? false;
    message.accelerators = object.accelerators?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.diskType = object.diskType ?? "";
    message.minCpuPlatform = object.minCpuPlatform ?? "";
    message.workloadMetadataConfig =
      (object.workloadMetadataConfig !== undefined && object.workloadMetadataConfig !== null)
        ? WorkloadMetadataConfig.fromPartial(object.workloadMetadataConfig)
        : undefined;
    message.taints = object.taints?.map((e) => NodeTaint.fromPartial(e)) || [];
    message.sandboxConfig = (object.sandboxConfig !== undefined && object.sandboxConfig !== null)
      ? SandboxConfig.fromPartial(object.sandboxConfig)
      : undefined;
    message.nodeGroup = object.nodeGroup ?? "";
    message.reservationAffinity = (object.reservationAffinity !== undefined && object.reservationAffinity !== null)
      ? ReservationAffinity.fromPartial(object.reservationAffinity)
      : undefined;
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.linuxNodeConfig = (object.linuxNodeConfig !== undefined && object.linuxNodeConfig !== null)
      ? LinuxNodeConfig.fromPartial(object.linuxNodeConfig)
      : undefined;
    message.kubeletConfig = (object.kubeletConfig !== undefined && object.kubeletConfig !== null)
      ? NodeKubeletConfig.fromPartial(object.kubeletConfig)
      : undefined;
    message.bootDiskKmsKey = object.bootDiskKmsKey ?? "";
    message.gcfsConfig = (object.gcfsConfig !== undefined && object.gcfsConfig !== null)
      ? GcfsConfig.fromPartial(object.gcfsConfig)
      : undefined;
    message.advancedMachineFeatures =
      (object.advancedMachineFeatures !== undefined && object.advancedMachineFeatures !== null)
        ? AdvancedMachineFeatures.fromPartial(object.advancedMachineFeatures)
        : undefined;
    message.gvnic = (object.gvnic !== undefined && object.gvnic !== null)
      ? VirtualNIC.fromPartial(object.gvnic)
      : undefined;
    message.spot = object.spot ?? false;
    message.confidentialNodes = (object.confidentialNodes !== undefined && object.confidentialNodes !== null)
      ? ConfidentialNodes.fromPartial(object.confidentialNodes)
      : undefined;
    message.fastSocket = (object.fastSocket !== undefined && object.fastSocket !== null)
      ? FastSocket.fromPartial(object.fastSocket)
      : undefined;
    message.resourceLabels = Object.entries(object.resourceLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.loggingConfig = (object.loggingConfig !== undefined && object.loggingConfig !== null)
      ? NodePoolLoggingConfig.fromPartial(object.loggingConfig)
      : undefined;
    message.windowsNodeConfig = (object.windowsNodeConfig !== undefined && object.windowsNodeConfig !== null)
      ? WindowsNodeConfig.fromPartial(object.windowsNodeConfig)
      : undefined;
    message.localNvmeSsdBlockConfig =
      (object.localNvmeSsdBlockConfig !== undefined && object.localNvmeSsdBlockConfig !== null)
        ? LocalNvmeSsdBlockConfig.fromPartial(object.localNvmeSsdBlockConfig)
        : undefined;
    message.ephemeralStorageLocalSsdConfig =
      (object.ephemeralStorageLocalSsdConfig !== undefined && object.ephemeralStorageLocalSsdConfig !== null)
        ? EphemeralStorageLocalSsdConfig.fromPartial(object.ephemeralStorageLocalSsdConfig)
        : undefined;
    message.soleTenantConfig = (object.soleTenantConfig !== undefined && object.soleTenantConfig !== null)
      ? SoleTenantConfig.fromPartial(object.soleTenantConfig)
      : undefined;
    message.containerdConfig = (object.containerdConfig !== undefined && object.containerdConfig !== null)
      ? ContainerdConfig.fromPartial(object.containerdConfig)
      : undefined;
    message.resourceManagerTags = (object.resourceManagerTags !== undefined && object.resourceManagerTags !== null)
      ? ResourceManagerTags.fromPartial(object.resourceManagerTags)
      : undefined;
    message.enableConfidentialStorage = object.enableConfidentialStorage ?? false;
    message.secondaryBootDisks = object.secondaryBootDisks?.map((e) => SecondaryBootDisk.fromPartial(e)) || [];
    message.secondaryBootDiskUpdateStrategy =
      (object.secondaryBootDiskUpdateStrategy !== undefined && object.secondaryBootDiskUpdateStrategy !== null)
        ? SecondaryBootDiskUpdateStrategy.fromPartial(object.secondaryBootDiskUpdateStrategy)
        : undefined;
    return message;
  },
};

function createBaseNodeConfig_MetadataEntry(): NodeConfig_MetadataEntry {
  return { key: "", value: "" };
}

export const NodeConfig_MetadataEntry: MessageFns<NodeConfig_MetadataEntry> = {
  encode(message: NodeConfig_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig_MetadataEntry>): NodeConfig_MetadataEntry {
    return NodeConfig_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig_MetadataEntry>): NodeConfig_MetadataEntry {
    const message = createBaseNodeConfig_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeConfig_LabelsEntry(): NodeConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const NodeConfig_LabelsEntry: MessageFns<NodeConfig_LabelsEntry> = {
  encode(message: NodeConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig_LabelsEntry>): NodeConfig_LabelsEntry {
    return NodeConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig_LabelsEntry>): NodeConfig_LabelsEntry {
    const message = createBaseNodeConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeConfig_ResourceLabelsEntry(): NodeConfig_ResourceLabelsEntry {
  return { key: "", value: "" };
}

export const NodeConfig_ResourceLabelsEntry: MessageFns<NodeConfig_ResourceLabelsEntry> = {
  encode(message: NodeConfig_ResourceLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig_ResourceLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig_ResourceLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig_ResourceLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeConfig_ResourceLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig_ResourceLabelsEntry>): NodeConfig_ResourceLabelsEntry {
    return NodeConfig_ResourceLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig_ResourceLabelsEntry>): NodeConfig_ResourceLabelsEntry {
    const message = createBaseNodeConfig_ResourceLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAdvancedMachineFeatures(): AdvancedMachineFeatures {
  return { threadsPerCore: undefined, enableNestedVirtualization: undefined };
}

export const AdvancedMachineFeatures: MessageFns<AdvancedMachineFeatures> = {
  encode(message: AdvancedMachineFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threadsPerCore !== undefined) {
      writer.uint32(8).int64(message.threadsPerCore.toString());
    }
    if (message.enableNestedVirtualization !== undefined) {
      writer.uint32(16).bool(message.enableNestedVirtualization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedMachineFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedMachineFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threadsPerCore = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableNestedVirtualization = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedMachineFeatures {
    return {
      threadsPerCore: isSet(object.threadsPerCore) ? Long.fromValue(object.threadsPerCore) : undefined,
      enableNestedVirtualization: isSet(object.enableNestedVirtualization)
        ? globalThis.Boolean(object.enableNestedVirtualization)
        : undefined,
    };
  },

  toJSON(message: AdvancedMachineFeatures): unknown {
    const obj: any = {};
    if (message.threadsPerCore !== undefined) {
      obj.threadsPerCore = (message.threadsPerCore || Long.ZERO).toString();
    }
    if (message.enableNestedVirtualization !== undefined) {
      obj.enableNestedVirtualization = message.enableNestedVirtualization;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedMachineFeatures>): AdvancedMachineFeatures {
    return AdvancedMachineFeatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedMachineFeatures>): AdvancedMachineFeatures {
    const message = createBaseAdvancedMachineFeatures();
    message.threadsPerCore = (object.threadsPerCore !== undefined && object.threadsPerCore !== null)
      ? Long.fromValue(object.threadsPerCore)
      : undefined;
    message.enableNestedVirtualization = object.enableNestedVirtualization ?? undefined;
    return message;
  },
};

function createBaseNodeNetworkConfig(): NodeNetworkConfig {
  return {
    createPodRange: false,
    podRange: "",
    podIpv4CidrBlock: "",
    enablePrivateNodes: undefined,
    networkPerformanceConfig: undefined,
    podCidrOverprovisionConfig: undefined,
    additionalNodeNetworkConfigs: [],
    additionalPodNetworkConfigs: [],
    podIpv4RangeUtilization: 0,
  };
}

export const NodeNetworkConfig: MessageFns<NodeNetworkConfig> = {
  encode(message: NodeNetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createPodRange !== false) {
      writer.uint32(32).bool(message.createPodRange);
    }
    if (message.podRange !== "") {
      writer.uint32(42).string(message.podRange);
    }
    if (message.podIpv4CidrBlock !== "") {
      writer.uint32(50).string(message.podIpv4CidrBlock);
    }
    if (message.enablePrivateNodes !== undefined) {
      writer.uint32(72).bool(message.enablePrivateNodes);
    }
    if (message.networkPerformanceConfig !== undefined) {
      NodeNetworkConfig_NetworkPerformanceConfig.encode(message.networkPerformanceConfig, writer.uint32(90).fork())
        .join();
    }
    if (message.podCidrOverprovisionConfig !== undefined) {
      PodCIDROverprovisionConfig.encode(message.podCidrOverprovisionConfig, writer.uint32(106).fork()).join();
    }
    for (const v of message.additionalNodeNetworkConfigs) {
      AdditionalNodeNetworkConfig.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.additionalPodNetworkConfigs) {
      AdditionalPodNetworkConfig.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.podIpv4RangeUtilization !== 0) {
      writer.uint32(129).double(message.podIpv4RangeUtilization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeNetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.createPodRange = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.podRange = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.podIpv4CidrBlock = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enablePrivateNodes = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.networkPerformanceConfig = NodeNetworkConfig_NetworkPerformanceConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.podCidrOverprovisionConfig = PodCIDROverprovisionConfig.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.additionalNodeNetworkConfigs.push(AdditionalNodeNetworkConfig.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.additionalPodNetworkConfigs.push(AdditionalPodNetworkConfig.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.podIpv4RangeUtilization = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeNetworkConfig {
    return {
      createPodRange: isSet(object.createPodRange) ? globalThis.Boolean(object.createPodRange) : false,
      podRange: isSet(object.podRange) ? globalThis.String(object.podRange) : "",
      podIpv4CidrBlock: isSet(object.podIpv4CidrBlock) ? globalThis.String(object.podIpv4CidrBlock) : "",
      enablePrivateNodes: isSet(object.enablePrivateNodes) ? globalThis.Boolean(object.enablePrivateNodes) : undefined,
      networkPerformanceConfig: isSet(object.networkPerformanceConfig)
        ? NodeNetworkConfig_NetworkPerformanceConfig.fromJSON(object.networkPerformanceConfig)
        : undefined,
      podCidrOverprovisionConfig: isSet(object.podCidrOverprovisionConfig)
        ? PodCIDROverprovisionConfig.fromJSON(object.podCidrOverprovisionConfig)
        : undefined,
      additionalNodeNetworkConfigs: globalThis.Array.isArray(object?.additionalNodeNetworkConfigs)
        ? object.additionalNodeNetworkConfigs.map((e: any) => AdditionalNodeNetworkConfig.fromJSON(e))
        : [],
      additionalPodNetworkConfigs: globalThis.Array.isArray(object?.additionalPodNetworkConfigs)
        ? object.additionalPodNetworkConfigs.map((e: any) => AdditionalPodNetworkConfig.fromJSON(e))
        : [],
      podIpv4RangeUtilization: isSet(object.podIpv4RangeUtilization)
        ? globalThis.Number(object.podIpv4RangeUtilization)
        : 0,
    };
  },

  toJSON(message: NodeNetworkConfig): unknown {
    const obj: any = {};
    if (message.createPodRange !== false) {
      obj.createPodRange = message.createPodRange;
    }
    if (message.podRange !== "") {
      obj.podRange = message.podRange;
    }
    if (message.podIpv4CidrBlock !== "") {
      obj.podIpv4CidrBlock = message.podIpv4CidrBlock;
    }
    if (message.enablePrivateNodes !== undefined) {
      obj.enablePrivateNodes = message.enablePrivateNodes;
    }
    if (message.networkPerformanceConfig !== undefined) {
      obj.networkPerformanceConfig = NodeNetworkConfig_NetworkPerformanceConfig.toJSON(
        message.networkPerformanceConfig,
      );
    }
    if (message.podCidrOverprovisionConfig !== undefined) {
      obj.podCidrOverprovisionConfig = PodCIDROverprovisionConfig.toJSON(message.podCidrOverprovisionConfig);
    }
    if (message.additionalNodeNetworkConfigs?.length) {
      obj.additionalNodeNetworkConfigs = message.additionalNodeNetworkConfigs.map((e) =>
        AdditionalNodeNetworkConfig.toJSON(e)
      );
    }
    if (message.additionalPodNetworkConfigs?.length) {
      obj.additionalPodNetworkConfigs = message.additionalPodNetworkConfigs.map((e) =>
        AdditionalPodNetworkConfig.toJSON(e)
      );
    }
    if (message.podIpv4RangeUtilization !== 0) {
      obj.podIpv4RangeUtilization = message.podIpv4RangeUtilization;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeNetworkConfig>): NodeNetworkConfig {
    return NodeNetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeNetworkConfig>): NodeNetworkConfig {
    const message = createBaseNodeNetworkConfig();
    message.createPodRange = object.createPodRange ?? false;
    message.podRange = object.podRange ?? "";
    message.podIpv4CidrBlock = object.podIpv4CidrBlock ?? "";
    message.enablePrivateNodes = object.enablePrivateNodes ?? undefined;
    message.networkPerformanceConfig =
      (object.networkPerformanceConfig !== undefined && object.networkPerformanceConfig !== null)
        ? NodeNetworkConfig_NetworkPerformanceConfig.fromPartial(object.networkPerformanceConfig)
        : undefined;
    message.podCidrOverprovisionConfig =
      (object.podCidrOverprovisionConfig !== undefined && object.podCidrOverprovisionConfig !== null)
        ? PodCIDROverprovisionConfig.fromPartial(object.podCidrOverprovisionConfig)
        : undefined;
    message.additionalNodeNetworkConfigs =
      object.additionalNodeNetworkConfigs?.map((e) => AdditionalNodeNetworkConfig.fromPartial(e)) || [];
    message.additionalPodNetworkConfigs =
      object.additionalPodNetworkConfigs?.map((e) => AdditionalPodNetworkConfig.fromPartial(e)) || [];
    message.podIpv4RangeUtilization = object.podIpv4RangeUtilization ?? 0;
    return message;
  },
};

function createBaseNodeNetworkConfig_NetworkPerformanceConfig(): NodeNetworkConfig_NetworkPerformanceConfig {
  return { totalEgressBandwidthTier: undefined };
}

export const NodeNetworkConfig_NetworkPerformanceConfig: MessageFns<NodeNetworkConfig_NetworkPerformanceConfig> = {
  encode(message: NodeNetworkConfig_NetworkPerformanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalEgressBandwidthTier !== undefined) {
      writer.uint32(8).int32(message.totalEgressBandwidthTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeNetworkConfig_NetworkPerformanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeNetworkConfig_NetworkPerformanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalEgressBandwidthTier = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeNetworkConfig_NetworkPerformanceConfig {
    return {
      totalEgressBandwidthTier: isSet(object.totalEgressBandwidthTier)
        ? nodeNetworkConfig_NetworkPerformanceConfig_TierFromJSON(object.totalEgressBandwidthTier)
        : undefined,
    };
  },

  toJSON(message: NodeNetworkConfig_NetworkPerformanceConfig): unknown {
    const obj: any = {};
    if (message.totalEgressBandwidthTier !== undefined) {
      obj.totalEgressBandwidthTier = nodeNetworkConfig_NetworkPerformanceConfig_TierToJSON(
        message.totalEgressBandwidthTier,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<NodeNetworkConfig_NetworkPerformanceConfig>): NodeNetworkConfig_NetworkPerformanceConfig {
    return NodeNetworkConfig_NetworkPerformanceConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<NodeNetworkConfig_NetworkPerformanceConfig>,
  ): NodeNetworkConfig_NetworkPerformanceConfig {
    const message = createBaseNodeNetworkConfig_NetworkPerformanceConfig();
    message.totalEgressBandwidthTier = object.totalEgressBandwidthTier ?? undefined;
    return message;
  },
};

function createBaseAdditionalNodeNetworkConfig(): AdditionalNodeNetworkConfig {
  return { network: "", subnetwork: "" };
}

export const AdditionalNodeNetworkConfig: MessageFns<AdditionalNodeNetworkConfig> = {
  encode(message: AdditionalNodeNetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalNodeNetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalNodeNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalNodeNetworkConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
    };
  },

  toJSON(message: AdditionalNodeNetworkConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    return obj;
  },

  create(base?: DeepPartial<AdditionalNodeNetworkConfig>): AdditionalNodeNetworkConfig {
    return AdditionalNodeNetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdditionalNodeNetworkConfig>): AdditionalNodeNetworkConfig {
    const message = createBaseAdditionalNodeNetworkConfig();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    return message;
  },
};

function createBaseAdditionalPodNetworkConfig(): AdditionalPodNetworkConfig {
  return { subnetwork: "", secondaryPodRange: "", maxPodsPerNode: undefined };
}

export const AdditionalPodNetworkConfig: MessageFns<AdditionalPodNetworkConfig> = {
  encode(message: AdditionalPodNetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subnetwork !== "") {
      writer.uint32(10).string(message.subnetwork);
    }
    if (message.secondaryPodRange !== "") {
      writer.uint32(18).string(message.secondaryPodRange);
    }
    if (message.maxPodsPerNode !== undefined) {
      MaxPodsConstraint.encode(message.maxPodsPerNode, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalPodNetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalPodNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryPodRange = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxPodsPerNode = MaxPodsConstraint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalPodNetworkConfig {
    return {
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      secondaryPodRange: isSet(object.secondaryPodRange) ? globalThis.String(object.secondaryPodRange) : "",
      maxPodsPerNode: isSet(object.maxPodsPerNode) ? MaxPodsConstraint.fromJSON(object.maxPodsPerNode) : undefined,
    };
  },

  toJSON(message: AdditionalPodNetworkConfig): unknown {
    const obj: any = {};
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.secondaryPodRange !== "") {
      obj.secondaryPodRange = message.secondaryPodRange;
    }
    if (message.maxPodsPerNode !== undefined) {
      obj.maxPodsPerNode = MaxPodsConstraint.toJSON(message.maxPodsPerNode);
    }
    return obj;
  },

  create(base?: DeepPartial<AdditionalPodNetworkConfig>): AdditionalPodNetworkConfig {
    return AdditionalPodNetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdditionalPodNetworkConfig>): AdditionalPodNetworkConfig {
    const message = createBaseAdditionalPodNetworkConfig();
    message.subnetwork = object.subnetwork ?? "";
    message.secondaryPodRange = object.secondaryPodRange ?? "";
    message.maxPodsPerNode = (object.maxPodsPerNode !== undefined && object.maxPodsPerNode !== null)
      ? MaxPodsConstraint.fromPartial(object.maxPodsPerNode)
      : undefined;
    return message;
  },
};

function createBaseShieldedInstanceConfig(): ShieldedInstanceConfig {
  return { enableSecureBoot: false, enableIntegrityMonitoring: false };
}

export const ShieldedInstanceConfig: MessageFns<ShieldedInstanceConfig> = {
  encode(message: ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    if (message.enableIntegrityMonitoring !== false) {
      writer.uint32(16).bool(message.enableIntegrityMonitoring);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableIntegrityMonitoring = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedInstanceConfig {
    return {
      enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false,
      enableIntegrityMonitoring: isSet(object.enableIntegrityMonitoring)
        ? globalThis.Boolean(object.enableIntegrityMonitoring)
        : false,
    };
  },

  toJSON(message: ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    if (message.enableIntegrityMonitoring !== false) {
      obj.enableIntegrityMonitoring = message.enableIntegrityMonitoring;
    }
    return obj;
  },

  create(base?: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    return ShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    const message = createBaseShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    message.enableIntegrityMonitoring = object.enableIntegrityMonitoring ?? false;
    return message;
  },
};

function createBaseSandboxConfig(): SandboxConfig {
  return { type: 0 };
}

export const SandboxConfig: MessageFns<SandboxConfig> = {
  encode(message: SandboxConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SandboxConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSandboxConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SandboxConfig {
    return { type: isSet(object.type) ? sandboxConfig_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: SandboxConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = sandboxConfig_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SandboxConfig>): SandboxConfig {
    return SandboxConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SandboxConfig>): SandboxConfig {
    const message = createBaseSandboxConfig();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGcfsConfig(): GcfsConfig {
  return { enabled: false };
}

export const GcfsConfig: MessageFns<GcfsConfig> = {
  encode(message: GcfsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcfsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcfsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcfsConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: GcfsConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GcfsConfig>): GcfsConfig {
    return GcfsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcfsConfig>): GcfsConfig {
    const message = createBaseGcfsConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseReservationAffinity(): ReservationAffinity {
  return { consumeReservationType: 0, key: "", values: [] };
}

export const ReservationAffinity: MessageFns<ReservationAffinity> = {
  encode(message: ReservationAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumeReservationType !== 0) {
      writer.uint32(8).int32(message.consumeReservationType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReservationAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservationAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.consumeReservationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReservationAffinity {
    return {
      consumeReservationType: isSet(object.consumeReservationType)
        ? reservationAffinity_TypeFromJSON(object.consumeReservationType)
        : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ReservationAffinity): unknown {
    const obj: any = {};
    if (message.consumeReservationType !== 0) {
      obj.consumeReservationType = reservationAffinity_TypeToJSON(message.consumeReservationType);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<ReservationAffinity>): ReservationAffinity {
    return ReservationAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReservationAffinity>): ReservationAffinity {
    const message = createBaseReservationAffinity();
    message.consumeReservationType = object.consumeReservationType ?? 0;
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseSoleTenantConfig(): SoleTenantConfig {
  return { nodeAffinities: [] };
}

export const SoleTenantConfig: MessageFns<SoleTenantConfig> = {
  encode(message: SoleTenantConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeAffinities) {
      SoleTenantConfig_NodeAffinity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoleTenantConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoleTenantConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeAffinities.push(SoleTenantConfig_NodeAffinity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoleTenantConfig {
    return {
      nodeAffinities: globalThis.Array.isArray(object?.nodeAffinities)
        ? object.nodeAffinities.map((e: any) => SoleTenantConfig_NodeAffinity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SoleTenantConfig): unknown {
    const obj: any = {};
    if (message.nodeAffinities?.length) {
      obj.nodeAffinities = message.nodeAffinities.map((e) => SoleTenantConfig_NodeAffinity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoleTenantConfig>): SoleTenantConfig {
    return SoleTenantConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoleTenantConfig>): SoleTenantConfig {
    const message = createBaseSoleTenantConfig();
    message.nodeAffinities = object.nodeAffinities?.map((e) => SoleTenantConfig_NodeAffinity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSoleTenantConfig_NodeAffinity(): SoleTenantConfig_NodeAffinity {
  return { key: "", operator: 0, values: [] };
}

export const SoleTenantConfig_NodeAffinity: MessageFns<SoleTenantConfig_NodeAffinity> = {
  encode(message: SoleTenantConfig_NodeAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoleTenantConfig_NodeAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoleTenantConfig_NodeAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoleTenantConfig_NodeAffinity {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      operator: isSet(object.operator) ? soleTenantConfig_NodeAffinity_OperatorFromJSON(object.operator) : 0,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SoleTenantConfig_NodeAffinity): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.operator !== 0) {
      obj.operator = soleTenantConfig_NodeAffinity_OperatorToJSON(message.operator);
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<SoleTenantConfig_NodeAffinity>): SoleTenantConfig_NodeAffinity {
    return SoleTenantConfig_NodeAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoleTenantConfig_NodeAffinity>): SoleTenantConfig_NodeAffinity {
    const message = createBaseSoleTenantConfig_NodeAffinity();
    message.key = object.key ?? "";
    message.operator = object.operator ?? 0;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseContainerdConfig(): ContainerdConfig {
  return { privateRegistryAccessConfig: undefined };
}

export const ContainerdConfig: MessageFns<ContainerdConfig> = {
  encode(message: ContainerdConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateRegistryAccessConfig !== undefined) {
      ContainerdConfig_PrivateRegistryAccessConfig.encode(message.privateRegistryAccessConfig, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerdConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerdConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateRegistryAccessConfig = ContainerdConfig_PrivateRegistryAccessConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerdConfig {
    return {
      privateRegistryAccessConfig: isSet(object.privateRegistryAccessConfig)
        ? ContainerdConfig_PrivateRegistryAccessConfig.fromJSON(object.privateRegistryAccessConfig)
        : undefined,
    };
  },

  toJSON(message: ContainerdConfig): unknown {
    const obj: any = {};
    if (message.privateRegistryAccessConfig !== undefined) {
      obj.privateRegistryAccessConfig = ContainerdConfig_PrivateRegistryAccessConfig.toJSON(
        message.privateRegistryAccessConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ContainerdConfig>): ContainerdConfig {
    return ContainerdConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContainerdConfig>): ContainerdConfig {
    const message = createBaseContainerdConfig();
    message.privateRegistryAccessConfig =
      (object.privateRegistryAccessConfig !== undefined && object.privateRegistryAccessConfig !== null)
        ? ContainerdConfig_PrivateRegistryAccessConfig.fromPartial(object.privateRegistryAccessConfig)
        : undefined;
    return message;
  },
};

function createBaseContainerdConfig_PrivateRegistryAccessConfig(): ContainerdConfig_PrivateRegistryAccessConfig {
  return { enabled: false, certificateAuthorityDomainConfig: [] };
}

export const ContainerdConfig_PrivateRegistryAccessConfig: MessageFns<ContainerdConfig_PrivateRegistryAccessConfig> = {
  encode(
    message: ContainerdConfig_PrivateRegistryAccessConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.certificateAuthorityDomainConfig) {
      ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.encode(v!, writer.uint32(18).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerdConfig_PrivateRegistryAccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerdConfig_PrivateRegistryAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.certificateAuthorityDomainConfig.push(
            ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerdConfig_PrivateRegistryAccessConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      certificateAuthorityDomainConfig: globalThis.Array.isArray(object?.certificateAuthorityDomainConfig)
        ? object.certificateAuthorityDomainConfig.map((e: any) =>
          ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: ContainerdConfig_PrivateRegistryAccessConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.certificateAuthorityDomainConfig?.length) {
      obj.certificateAuthorityDomainConfig = message.certificateAuthorityDomainConfig.map((e) =>
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<ContainerdConfig_PrivateRegistryAccessConfig>,
  ): ContainerdConfig_PrivateRegistryAccessConfig {
    return ContainerdConfig_PrivateRegistryAccessConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ContainerdConfig_PrivateRegistryAccessConfig>,
  ): ContainerdConfig_PrivateRegistryAccessConfig {
    const message = createBaseContainerdConfig_PrivateRegistryAccessConfig();
    message.enabled = object.enabled ?? false;
    message.certificateAuthorityDomainConfig =
      object.certificateAuthorityDomainConfig?.map((e) =>
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig(): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
  return { fqdns: [], gcpSecretManagerCertificateConfig: undefined };
}

export const ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig: MessageFns<
  ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig
> = {
  encode(
    message: ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.fqdns) {
      writer.uint32(10).string(v!);
    }
    if (message.gcpSecretManagerCertificateConfig !== undefined) {
      ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
        .encode(message.gcpSecretManagerCertificateConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fqdns.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcpSecretManagerCertificateConfig =
            ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
              .decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
    return {
      fqdns: globalThis.Array.isArray(object?.fqdns) ? object.fqdns.map((e: any) => globalThis.String(e)) : [],
      gcpSecretManagerCertificateConfig: isSet(object.gcpSecretManagerCertificateConfig)
        ? ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
          .fromJSON(object.gcpSecretManagerCertificateConfig)
        : undefined,
    };
  },

  toJSON(message: ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig): unknown {
    const obj: any = {};
    if (message.fqdns?.length) {
      obj.fqdns = message.fqdns;
    }
    if (message.gcpSecretManagerCertificateConfig !== undefined) {
      obj.gcpSecretManagerCertificateConfig =
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
          .toJSON(message.gcpSecretManagerCertificateConfig);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig>,
  ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
    return ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig>,
  ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig {
    const message = createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig();
    message.fqdns = object.fqdns?.map((e) => e) || [];
    message.gcpSecretManagerCertificateConfig =
      (object.gcpSecretManagerCertificateConfig !== undefined && object.gcpSecretManagerCertificateConfig !== null)
        ? ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
          .fromPartial(object.gcpSecretManagerCertificateConfig)
        : undefined;
    return message;
  },
};

function createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig(): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
  return { secretUri: "" };
}

export const ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig:
  MessageFns<
    ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
  > = {
    encode(
      message:
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.secretUri !== "") {
        writer.uint32(10).string(message.secretUri);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.secretUri = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(
      object: any,
    ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
      return { secretUri: isSet(object.secretUri) ? globalThis.String(object.secretUri) : "" };
    },

    toJSON(
      message:
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig,
    ): unknown {
      const obj: any = {};
      if (message.secretUri !== "") {
        obj.secretUri = message.secretUri;
      }
      return obj;
    },

    create(
      base?: DeepPartial<
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
      >,
    ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
      return ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
        .fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<
        ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig
      >,
    ): ContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig {
      const message =
        createBaseContainerdConfig_PrivateRegistryAccessConfig_CertificateAuthorityDomainConfig_GCPSecretManagerCertificateConfig();
      message.secretUri = object.secretUri ?? "";
      return message;
    },
  };

function createBaseNodeTaint(): NodeTaint {
  return { key: "", value: "", effect: 0 };
}

export const NodeTaint: MessageFns<NodeTaint> = {
  encode(message: NodeTaint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.effect !== 0) {
      writer.uint32(24).int32(message.effect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeTaint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeTaint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeTaint {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      effect: isSet(object.effect) ? nodeTaint_EffectFromJSON(object.effect) : 0,
    };
  },

  toJSON(message: NodeTaint): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.effect !== 0) {
      obj.effect = nodeTaint_EffectToJSON(message.effect);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeTaint>): NodeTaint {
    return NodeTaint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeTaint>): NodeTaint {
    const message = createBaseNodeTaint();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.effect = object.effect ?? 0;
    return message;
  },
};

function createBaseNodeTaints(): NodeTaints {
  return { taints: [] };
}

export const NodeTaints: MessageFns<NodeTaints> = {
  encode(message: NodeTaints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.taints) {
      NodeTaint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeTaints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeTaints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taints.push(NodeTaint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeTaints {
    return {
      taints: globalThis.Array.isArray(object?.taints) ? object.taints.map((e: any) => NodeTaint.fromJSON(e)) : [],
    };
  },

  toJSON(message: NodeTaints): unknown {
    const obj: any = {};
    if (message.taints?.length) {
      obj.taints = message.taints.map((e) => NodeTaint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NodeTaints>): NodeTaints {
    return NodeTaints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeTaints>): NodeTaints {
    const message = createBaseNodeTaints();
    message.taints = object.taints?.map((e) => NodeTaint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNodeLabels(): NodeLabels {
  return { labels: {} };
}

export const NodeLabels: MessageFns<NodeLabels> = {
  encode(message: NodeLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      NodeLabels_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = NodeLabels_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeLabels {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: NodeLabels): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<NodeLabels>): NodeLabels {
    return NodeLabels.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeLabels>): NodeLabels {
    const message = createBaseNodeLabels();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseNodeLabels_LabelsEntry(): NodeLabels_LabelsEntry {
  return { key: "", value: "" };
}

export const NodeLabels_LabelsEntry: MessageFns<NodeLabels_LabelsEntry> = {
  encode(message: NodeLabels_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeLabels_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeLabels_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeLabels_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: NodeLabels_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<NodeLabels_LabelsEntry>): NodeLabels_LabelsEntry {
    return NodeLabels_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeLabels_LabelsEntry>): NodeLabels_LabelsEntry {
    const message = createBaseNodeLabels_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResourceLabels(): ResourceLabels {
  return { labels: {} };
}

export const ResourceLabels: MessageFns<ResourceLabels> = {
  encode(message: ResourceLabels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      ResourceLabels_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLabels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLabels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ResourceLabels_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLabels {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ResourceLabels): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceLabels>): ResourceLabels {
    return ResourceLabels.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceLabels>): ResourceLabels {
    const message = createBaseResourceLabels();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseResourceLabels_LabelsEntry(): ResourceLabels_LabelsEntry {
  return { key: "", value: "" };
}

export const ResourceLabels_LabelsEntry: MessageFns<ResourceLabels_LabelsEntry> = {
  encode(message: ResourceLabels_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLabels_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLabels_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLabels_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceLabels_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceLabels_LabelsEntry>): ResourceLabels_LabelsEntry {
    return ResourceLabels_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceLabels_LabelsEntry>): ResourceLabels_LabelsEntry {
    const message = createBaseResourceLabels_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNetworkTags(): NetworkTags {
  return { tags: [] };
}

export const NetworkTags: MessageFns<NetworkTags> = {
  encode(message: NetworkTags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkTags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkTags {
    return { tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: NetworkTags): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkTags>): NetworkTags {
    return NetworkTags.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkTags>): NetworkTags {
    const message = createBaseNetworkTags();
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseMasterAuth(): MasterAuth {
  return {
    username: "",
    password: "",
    clientCertificateConfig: undefined,
    clusterCaCertificate: "",
    clientCertificate: "",
    clientKey: "",
  };
}

export const MasterAuth: MessageFns<MasterAuth> = {
  encode(message: MasterAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.clientCertificateConfig !== undefined) {
      ClientCertificateConfig.encode(message.clientCertificateConfig, writer.uint32(26).fork()).join();
    }
    if (message.clusterCaCertificate !== "") {
      writer.uint32(802).string(message.clusterCaCertificate);
    }
    if (message.clientCertificate !== "") {
      writer.uint32(810).string(message.clientCertificate);
    }
    if (message.clientKey !== "") {
      writer.uint32(818).string(message.clientKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clientCertificateConfig = ClientCertificateConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.clusterCaCertificate = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.clientCertificate = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.clientKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      clientCertificateConfig: isSet(object.clientCertificateConfig)
        ? ClientCertificateConfig.fromJSON(object.clientCertificateConfig)
        : undefined,
      clusterCaCertificate: isSet(object.clusterCaCertificate) ? globalThis.String(object.clusterCaCertificate) : "",
      clientCertificate: isSet(object.clientCertificate) ? globalThis.String(object.clientCertificate) : "",
      clientKey: isSet(object.clientKey) ? globalThis.String(object.clientKey) : "",
    };
  },

  toJSON(message: MasterAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.clientCertificateConfig !== undefined) {
      obj.clientCertificateConfig = ClientCertificateConfig.toJSON(message.clientCertificateConfig);
    }
    if (message.clusterCaCertificate !== "") {
      obj.clusterCaCertificate = message.clusterCaCertificate;
    }
    if (message.clientCertificate !== "") {
      obj.clientCertificate = message.clientCertificate;
    }
    if (message.clientKey !== "") {
      obj.clientKey = message.clientKey;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuth>): MasterAuth {
    return MasterAuth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuth>): MasterAuth {
    const message = createBaseMasterAuth();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.clientCertificateConfig =
      (object.clientCertificateConfig !== undefined && object.clientCertificateConfig !== null)
        ? ClientCertificateConfig.fromPartial(object.clientCertificateConfig)
        : undefined;
    message.clusterCaCertificate = object.clusterCaCertificate ?? "";
    message.clientCertificate = object.clientCertificate ?? "";
    message.clientKey = object.clientKey ?? "";
    return message;
  },
};

function createBaseClientCertificateConfig(): ClientCertificateConfig {
  return { issueClientCertificate: false };
}

export const ClientCertificateConfig: MessageFns<ClientCertificateConfig> = {
  encode(message: ClientCertificateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issueClientCertificate !== false) {
      writer.uint32(8).bool(message.issueClientCertificate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientCertificateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientCertificateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.issueClientCertificate = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientCertificateConfig {
    return {
      issueClientCertificate: isSet(object.issueClientCertificate)
        ? globalThis.Boolean(object.issueClientCertificate)
        : false,
    };
  },

  toJSON(message: ClientCertificateConfig): unknown {
    const obj: any = {};
    if (message.issueClientCertificate !== false) {
      obj.issueClientCertificate = message.issueClientCertificate;
    }
    return obj;
  },

  create(base?: DeepPartial<ClientCertificateConfig>): ClientCertificateConfig {
    return ClientCertificateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientCertificateConfig>): ClientCertificateConfig {
    const message = createBaseClientCertificateConfig();
    message.issueClientCertificate = object.issueClientCertificate ?? false;
    return message;
  },
};

function createBaseAddonsConfig(): AddonsConfig {
  return {
    httpLoadBalancing: undefined,
    horizontalPodAutoscaling: undefined,
    kubernetesDashboard: undefined,
    networkPolicyConfig: undefined,
    cloudRunConfig: undefined,
    dnsCacheConfig: undefined,
    configConnectorConfig: undefined,
    gcePersistentDiskCsiDriverConfig: undefined,
    gcpFilestoreCsiDriverConfig: undefined,
    gkeBackupAgentConfig: undefined,
    gcsFuseCsiDriverConfig: undefined,
    statefulHaConfig: undefined,
    rayOperatorConfig: undefined,
  };
}

export const AddonsConfig: MessageFns<AddonsConfig> = {
  encode(message: AddonsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpLoadBalancing !== undefined) {
      HttpLoadBalancing.encode(message.httpLoadBalancing, writer.uint32(10).fork()).join();
    }
    if (message.horizontalPodAutoscaling !== undefined) {
      HorizontalPodAutoscaling.encode(message.horizontalPodAutoscaling, writer.uint32(18).fork()).join();
    }
    if (message.kubernetesDashboard !== undefined) {
      KubernetesDashboard.encode(message.kubernetesDashboard, writer.uint32(26).fork()).join();
    }
    if (message.networkPolicyConfig !== undefined) {
      NetworkPolicyConfig.encode(message.networkPolicyConfig, writer.uint32(34).fork()).join();
    }
    if (message.cloudRunConfig !== undefined) {
      CloudRunConfig.encode(message.cloudRunConfig, writer.uint32(58).fork()).join();
    }
    if (message.dnsCacheConfig !== undefined) {
      DnsCacheConfig.encode(message.dnsCacheConfig, writer.uint32(66).fork()).join();
    }
    if (message.configConnectorConfig !== undefined) {
      ConfigConnectorConfig.encode(message.configConnectorConfig, writer.uint32(82).fork()).join();
    }
    if (message.gcePersistentDiskCsiDriverConfig !== undefined) {
      GcePersistentDiskCsiDriverConfig.encode(message.gcePersistentDiskCsiDriverConfig, writer.uint32(90).fork())
        .join();
    }
    if (message.gcpFilestoreCsiDriverConfig !== undefined) {
      GcpFilestoreCsiDriverConfig.encode(message.gcpFilestoreCsiDriverConfig, writer.uint32(114).fork()).join();
    }
    if (message.gkeBackupAgentConfig !== undefined) {
      GkeBackupAgentConfig.encode(message.gkeBackupAgentConfig, writer.uint32(130).fork()).join();
    }
    if (message.gcsFuseCsiDriverConfig !== undefined) {
      GcsFuseCsiDriverConfig.encode(message.gcsFuseCsiDriverConfig, writer.uint32(138).fork()).join();
    }
    if (message.statefulHaConfig !== undefined) {
      StatefulHAConfig.encode(message.statefulHaConfig, writer.uint32(146).fork()).join();
    }
    if (message.rayOperatorConfig !== undefined) {
      RayOperatorConfig.encode(message.rayOperatorConfig, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddonsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddonsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpLoadBalancing = HttpLoadBalancing.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.horizontalPodAutoscaling = HorizontalPodAutoscaling.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kubernetesDashboard = KubernetesDashboard.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkPolicyConfig = NetworkPolicyConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cloudRunConfig = CloudRunConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dnsCacheConfig = DnsCacheConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.configConnectorConfig = ConfigConnectorConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.gcePersistentDiskCsiDriverConfig = GcePersistentDiskCsiDriverConfig.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.gcpFilestoreCsiDriverConfig = GcpFilestoreCsiDriverConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.gkeBackupAgentConfig = GkeBackupAgentConfig.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.gcsFuseCsiDriverConfig = GcsFuseCsiDriverConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.statefulHaConfig = StatefulHAConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.rayOperatorConfig = RayOperatorConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddonsConfig {
    return {
      httpLoadBalancing: isSet(object.httpLoadBalancing)
        ? HttpLoadBalancing.fromJSON(object.httpLoadBalancing)
        : undefined,
      horizontalPodAutoscaling: isSet(object.horizontalPodAutoscaling)
        ? HorizontalPodAutoscaling.fromJSON(object.horizontalPodAutoscaling)
        : undefined,
      kubernetesDashboard: isSet(object.kubernetesDashboard)
        ? KubernetesDashboard.fromJSON(object.kubernetesDashboard)
        : undefined,
      networkPolicyConfig: isSet(object.networkPolicyConfig)
        ? NetworkPolicyConfig.fromJSON(object.networkPolicyConfig)
        : undefined,
      cloudRunConfig: isSet(object.cloudRunConfig) ? CloudRunConfig.fromJSON(object.cloudRunConfig) : undefined,
      dnsCacheConfig: isSet(object.dnsCacheConfig) ? DnsCacheConfig.fromJSON(object.dnsCacheConfig) : undefined,
      configConnectorConfig: isSet(object.configConnectorConfig)
        ? ConfigConnectorConfig.fromJSON(object.configConnectorConfig)
        : undefined,
      gcePersistentDiskCsiDriverConfig: isSet(object.gcePersistentDiskCsiDriverConfig)
        ? GcePersistentDiskCsiDriverConfig.fromJSON(object.gcePersistentDiskCsiDriverConfig)
        : undefined,
      gcpFilestoreCsiDriverConfig: isSet(object.gcpFilestoreCsiDriverConfig)
        ? GcpFilestoreCsiDriverConfig.fromJSON(object.gcpFilestoreCsiDriverConfig)
        : undefined,
      gkeBackupAgentConfig: isSet(object.gkeBackupAgentConfig)
        ? GkeBackupAgentConfig.fromJSON(object.gkeBackupAgentConfig)
        : undefined,
      gcsFuseCsiDriverConfig: isSet(object.gcsFuseCsiDriverConfig)
        ? GcsFuseCsiDriverConfig.fromJSON(object.gcsFuseCsiDriverConfig)
        : undefined,
      statefulHaConfig: isSet(object.statefulHaConfig) ? StatefulHAConfig.fromJSON(object.statefulHaConfig) : undefined,
      rayOperatorConfig: isSet(object.rayOperatorConfig)
        ? RayOperatorConfig.fromJSON(object.rayOperatorConfig)
        : undefined,
    };
  },

  toJSON(message: AddonsConfig): unknown {
    const obj: any = {};
    if (message.httpLoadBalancing !== undefined) {
      obj.httpLoadBalancing = HttpLoadBalancing.toJSON(message.httpLoadBalancing);
    }
    if (message.horizontalPodAutoscaling !== undefined) {
      obj.horizontalPodAutoscaling = HorizontalPodAutoscaling.toJSON(message.horizontalPodAutoscaling);
    }
    if (message.kubernetesDashboard !== undefined) {
      obj.kubernetesDashboard = KubernetesDashboard.toJSON(message.kubernetesDashboard);
    }
    if (message.networkPolicyConfig !== undefined) {
      obj.networkPolicyConfig = NetworkPolicyConfig.toJSON(message.networkPolicyConfig);
    }
    if (message.cloudRunConfig !== undefined) {
      obj.cloudRunConfig = CloudRunConfig.toJSON(message.cloudRunConfig);
    }
    if (message.dnsCacheConfig !== undefined) {
      obj.dnsCacheConfig = DnsCacheConfig.toJSON(message.dnsCacheConfig);
    }
    if (message.configConnectorConfig !== undefined) {
      obj.configConnectorConfig = ConfigConnectorConfig.toJSON(message.configConnectorConfig);
    }
    if (message.gcePersistentDiskCsiDriverConfig !== undefined) {
      obj.gcePersistentDiskCsiDriverConfig = GcePersistentDiskCsiDriverConfig.toJSON(
        message.gcePersistentDiskCsiDriverConfig,
      );
    }
    if (message.gcpFilestoreCsiDriverConfig !== undefined) {
      obj.gcpFilestoreCsiDriverConfig = GcpFilestoreCsiDriverConfig.toJSON(message.gcpFilestoreCsiDriverConfig);
    }
    if (message.gkeBackupAgentConfig !== undefined) {
      obj.gkeBackupAgentConfig = GkeBackupAgentConfig.toJSON(message.gkeBackupAgentConfig);
    }
    if (message.gcsFuseCsiDriverConfig !== undefined) {
      obj.gcsFuseCsiDriverConfig = GcsFuseCsiDriverConfig.toJSON(message.gcsFuseCsiDriverConfig);
    }
    if (message.statefulHaConfig !== undefined) {
      obj.statefulHaConfig = StatefulHAConfig.toJSON(message.statefulHaConfig);
    }
    if (message.rayOperatorConfig !== undefined) {
      obj.rayOperatorConfig = RayOperatorConfig.toJSON(message.rayOperatorConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AddonsConfig>): AddonsConfig {
    return AddonsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddonsConfig>): AddonsConfig {
    const message = createBaseAddonsConfig();
    message.httpLoadBalancing = (object.httpLoadBalancing !== undefined && object.httpLoadBalancing !== null)
      ? HttpLoadBalancing.fromPartial(object.httpLoadBalancing)
      : undefined;
    message.horizontalPodAutoscaling =
      (object.horizontalPodAutoscaling !== undefined && object.horizontalPodAutoscaling !== null)
        ? HorizontalPodAutoscaling.fromPartial(object.horizontalPodAutoscaling)
        : undefined;
    message.kubernetesDashboard = (object.kubernetesDashboard !== undefined && object.kubernetesDashboard !== null)
      ? KubernetesDashboard.fromPartial(object.kubernetesDashboard)
      : undefined;
    message.networkPolicyConfig = (object.networkPolicyConfig !== undefined && object.networkPolicyConfig !== null)
      ? NetworkPolicyConfig.fromPartial(object.networkPolicyConfig)
      : undefined;
    message.cloudRunConfig = (object.cloudRunConfig !== undefined && object.cloudRunConfig !== null)
      ? CloudRunConfig.fromPartial(object.cloudRunConfig)
      : undefined;
    message.dnsCacheConfig = (object.dnsCacheConfig !== undefined && object.dnsCacheConfig !== null)
      ? DnsCacheConfig.fromPartial(object.dnsCacheConfig)
      : undefined;
    message.configConnectorConfig =
      (object.configConnectorConfig !== undefined && object.configConnectorConfig !== null)
        ? ConfigConnectorConfig.fromPartial(object.configConnectorConfig)
        : undefined;
    message.gcePersistentDiskCsiDriverConfig =
      (object.gcePersistentDiskCsiDriverConfig !== undefined && object.gcePersistentDiskCsiDriverConfig !== null)
        ? GcePersistentDiskCsiDriverConfig.fromPartial(object.gcePersistentDiskCsiDriverConfig)
        : undefined;
    message.gcpFilestoreCsiDriverConfig =
      (object.gcpFilestoreCsiDriverConfig !== undefined && object.gcpFilestoreCsiDriverConfig !== null)
        ? GcpFilestoreCsiDriverConfig.fromPartial(object.gcpFilestoreCsiDriverConfig)
        : undefined;
    message.gkeBackupAgentConfig = (object.gkeBackupAgentConfig !== undefined && object.gkeBackupAgentConfig !== null)
      ? GkeBackupAgentConfig.fromPartial(object.gkeBackupAgentConfig)
      : undefined;
    message.gcsFuseCsiDriverConfig =
      (object.gcsFuseCsiDriverConfig !== undefined && object.gcsFuseCsiDriverConfig !== null)
        ? GcsFuseCsiDriverConfig.fromPartial(object.gcsFuseCsiDriverConfig)
        : undefined;
    message.statefulHaConfig = (object.statefulHaConfig !== undefined && object.statefulHaConfig !== null)
      ? StatefulHAConfig.fromPartial(object.statefulHaConfig)
      : undefined;
    message.rayOperatorConfig = (object.rayOperatorConfig !== undefined && object.rayOperatorConfig !== null)
      ? RayOperatorConfig.fromPartial(object.rayOperatorConfig)
      : undefined;
    return message;
  },
};

function createBaseHttpLoadBalancing(): HttpLoadBalancing {
  return { disabled: false };
}

export const HttpLoadBalancing: MessageFns<HttpLoadBalancing> = {
  encode(message: HttpLoadBalancing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpLoadBalancing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpLoadBalancing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpLoadBalancing {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: HttpLoadBalancing): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpLoadBalancing>): HttpLoadBalancing {
    return HttpLoadBalancing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpLoadBalancing>): HttpLoadBalancing {
    const message = createBaseHttpLoadBalancing();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseHorizontalPodAutoscaling(): HorizontalPodAutoscaling {
  return { disabled: false };
}

export const HorizontalPodAutoscaling: MessageFns<HorizontalPodAutoscaling> = {
  encode(message: HorizontalPodAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HorizontalPodAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHorizontalPodAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HorizontalPodAutoscaling {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: HorizontalPodAutoscaling): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HorizontalPodAutoscaling>): HorizontalPodAutoscaling {
    return HorizontalPodAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HorizontalPodAutoscaling>): HorizontalPodAutoscaling {
    const message = createBaseHorizontalPodAutoscaling();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseKubernetesDashboard(): KubernetesDashboard {
  return { disabled: false };
}

export const KubernetesDashboard: MessageFns<KubernetesDashboard> = {
  encode(message: KubernetesDashboard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KubernetesDashboard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKubernetesDashboard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KubernetesDashboard {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: KubernetesDashboard): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<KubernetesDashboard>): KubernetesDashboard {
    return KubernetesDashboard.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KubernetesDashboard>): KubernetesDashboard {
    const message = createBaseKubernetesDashboard();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseNetworkPolicyConfig(): NetworkPolicyConfig {
  return { disabled: false };
}

export const NetworkPolicyConfig: MessageFns<NetworkPolicyConfig> = {
  encode(message: NetworkPolicyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicyConfig {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: NetworkPolicyConfig): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicyConfig>): NetworkPolicyConfig {
    return NetworkPolicyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicyConfig>): NetworkPolicyConfig {
    const message = createBaseNetworkPolicyConfig();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseDnsCacheConfig(): DnsCacheConfig {
  return { enabled: false };
}

export const DnsCacheConfig: MessageFns<DnsCacheConfig> = {
  encode(message: DnsCacheConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsCacheConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsCacheConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsCacheConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: DnsCacheConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsCacheConfig>): DnsCacheConfig {
    return DnsCacheConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsCacheConfig>): DnsCacheConfig {
    const message = createBaseDnsCacheConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBasePrivateClusterMasterGlobalAccessConfig(): PrivateClusterMasterGlobalAccessConfig {
  return { enabled: false };
}

export const PrivateClusterMasterGlobalAccessConfig: MessageFns<PrivateClusterMasterGlobalAccessConfig> = {
  encode(message: PrivateClusterMasterGlobalAccessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateClusterMasterGlobalAccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateClusterMasterGlobalAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateClusterMasterGlobalAccessConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: PrivateClusterMasterGlobalAccessConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateClusterMasterGlobalAccessConfig>): PrivateClusterMasterGlobalAccessConfig {
    return PrivateClusterMasterGlobalAccessConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateClusterMasterGlobalAccessConfig>): PrivateClusterMasterGlobalAccessConfig {
    const message = createBasePrivateClusterMasterGlobalAccessConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBasePrivateClusterConfig(): PrivateClusterConfig {
  return {
    enablePrivateNodes: false,
    enablePrivateEndpoint: false,
    masterIpv4CidrBlock: "",
    privateEndpoint: "",
    publicEndpoint: "",
    peeringName: "",
    masterGlobalAccessConfig: undefined,
    privateEndpointSubnetwork: "",
  };
}

export const PrivateClusterConfig: MessageFns<PrivateClusterConfig> = {
  encode(message: PrivateClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enablePrivateNodes !== false) {
      writer.uint32(8).bool(message.enablePrivateNodes);
    }
    if (message.enablePrivateEndpoint !== false) {
      writer.uint32(16).bool(message.enablePrivateEndpoint);
    }
    if (message.masterIpv4CidrBlock !== "") {
      writer.uint32(26).string(message.masterIpv4CidrBlock);
    }
    if (message.privateEndpoint !== "") {
      writer.uint32(34).string(message.privateEndpoint);
    }
    if (message.publicEndpoint !== "") {
      writer.uint32(42).string(message.publicEndpoint);
    }
    if (message.peeringName !== "") {
      writer.uint32(58).string(message.peeringName);
    }
    if (message.masterGlobalAccessConfig !== undefined) {
      PrivateClusterMasterGlobalAccessConfig.encode(message.masterGlobalAccessConfig, writer.uint32(66).fork()).join();
    }
    if (message.privateEndpointSubnetwork !== "") {
      writer.uint32(82).string(message.privateEndpointSubnetwork);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enablePrivateNodes = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enablePrivateEndpoint = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.masterIpv4CidrBlock = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.privateEndpoint = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publicEndpoint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.peeringName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.masterGlobalAccessConfig = PrivateClusterMasterGlobalAccessConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.privateEndpointSubnetwork = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateClusterConfig {
    return {
      enablePrivateNodes: isSet(object.enablePrivateNodes) ? globalThis.Boolean(object.enablePrivateNodes) : false,
      enablePrivateEndpoint: isSet(object.enablePrivateEndpoint)
        ? globalThis.Boolean(object.enablePrivateEndpoint)
        : false,
      masterIpv4CidrBlock: isSet(object.masterIpv4CidrBlock) ? globalThis.String(object.masterIpv4CidrBlock) : "",
      privateEndpoint: isSet(object.privateEndpoint) ? globalThis.String(object.privateEndpoint) : "",
      publicEndpoint: isSet(object.publicEndpoint) ? globalThis.String(object.publicEndpoint) : "",
      peeringName: isSet(object.peeringName) ? globalThis.String(object.peeringName) : "",
      masterGlobalAccessConfig: isSet(object.masterGlobalAccessConfig)
        ? PrivateClusterMasterGlobalAccessConfig.fromJSON(object.masterGlobalAccessConfig)
        : undefined,
      privateEndpointSubnetwork: isSet(object.privateEndpointSubnetwork)
        ? globalThis.String(object.privateEndpointSubnetwork)
        : "",
    };
  },

  toJSON(message: PrivateClusterConfig): unknown {
    const obj: any = {};
    if (message.enablePrivateNodes !== false) {
      obj.enablePrivateNodes = message.enablePrivateNodes;
    }
    if (message.enablePrivateEndpoint !== false) {
      obj.enablePrivateEndpoint = message.enablePrivateEndpoint;
    }
    if (message.masterIpv4CidrBlock !== "") {
      obj.masterIpv4CidrBlock = message.masterIpv4CidrBlock;
    }
    if (message.privateEndpoint !== "") {
      obj.privateEndpoint = message.privateEndpoint;
    }
    if (message.publicEndpoint !== "") {
      obj.publicEndpoint = message.publicEndpoint;
    }
    if (message.peeringName !== "") {
      obj.peeringName = message.peeringName;
    }
    if (message.masterGlobalAccessConfig !== undefined) {
      obj.masterGlobalAccessConfig = PrivateClusterMasterGlobalAccessConfig.toJSON(message.masterGlobalAccessConfig);
    }
    if (message.privateEndpointSubnetwork !== "") {
      obj.privateEndpointSubnetwork = message.privateEndpointSubnetwork;
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateClusterConfig>): PrivateClusterConfig {
    return PrivateClusterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateClusterConfig>): PrivateClusterConfig {
    const message = createBasePrivateClusterConfig();
    message.enablePrivateNodes = object.enablePrivateNodes ?? false;
    message.enablePrivateEndpoint = object.enablePrivateEndpoint ?? false;
    message.masterIpv4CidrBlock = object.masterIpv4CidrBlock ?? "";
    message.privateEndpoint = object.privateEndpoint ?? "";
    message.publicEndpoint = object.publicEndpoint ?? "";
    message.peeringName = object.peeringName ?? "";
    message.masterGlobalAccessConfig =
      (object.masterGlobalAccessConfig !== undefined && object.masterGlobalAccessConfig !== null)
        ? PrivateClusterMasterGlobalAccessConfig.fromPartial(object.masterGlobalAccessConfig)
        : undefined;
    message.privateEndpointSubnetwork = object.privateEndpointSubnetwork ?? "";
    return message;
  },
};

function createBaseAuthenticatorGroupsConfig(): AuthenticatorGroupsConfig {
  return { enabled: false, securityGroup: "" };
}

export const AuthenticatorGroupsConfig: MessageFns<AuthenticatorGroupsConfig> = {
  encode(message: AuthenticatorGroupsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.securityGroup !== "") {
      writer.uint32(18).string(message.securityGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticatorGroupsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticatorGroupsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.securityGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticatorGroupsConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      securityGroup: isSet(object.securityGroup) ? globalThis.String(object.securityGroup) : "",
    };
  },

  toJSON(message: AuthenticatorGroupsConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.securityGroup !== "") {
      obj.securityGroup = message.securityGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthenticatorGroupsConfig>): AuthenticatorGroupsConfig {
    return AuthenticatorGroupsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticatorGroupsConfig>): AuthenticatorGroupsConfig {
    const message = createBaseAuthenticatorGroupsConfig();
    message.enabled = object.enabled ?? false;
    message.securityGroup = object.securityGroup ?? "";
    return message;
  },
};

function createBaseCloudRunConfig(): CloudRunConfig {
  return { disabled: false, loadBalancerType: 0 };
}

export const CloudRunConfig: MessageFns<CloudRunConfig> = {
  encode(message: CloudRunConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    if (message.loadBalancerType !== 0) {
      writer.uint32(24).int32(message.loadBalancerType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudRunConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudRunConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.loadBalancerType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudRunConfig {
    return {
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      loadBalancerType: isSet(object.loadBalancerType)
        ? cloudRunConfig_LoadBalancerTypeFromJSON(object.loadBalancerType)
        : 0,
    };
  },

  toJSON(message: CloudRunConfig): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.loadBalancerType !== 0) {
      obj.loadBalancerType = cloudRunConfig_LoadBalancerTypeToJSON(message.loadBalancerType);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudRunConfig>): CloudRunConfig {
    return CloudRunConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudRunConfig>): CloudRunConfig {
    const message = createBaseCloudRunConfig();
    message.disabled = object.disabled ?? false;
    message.loadBalancerType = object.loadBalancerType ?? 0;
    return message;
  },
};

function createBaseConfigConnectorConfig(): ConfigConnectorConfig {
  return { enabled: false };
}

export const ConfigConnectorConfig: MessageFns<ConfigConnectorConfig> = {
  encode(message: ConfigConnectorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigConnectorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigConnectorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigConnectorConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ConfigConnectorConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigConnectorConfig>): ConfigConnectorConfig {
    return ConfigConnectorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigConnectorConfig>): ConfigConnectorConfig {
    const message = createBaseConfigConnectorConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGcePersistentDiskCsiDriverConfig(): GcePersistentDiskCsiDriverConfig {
  return { enabled: false };
}

export const GcePersistentDiskCsiDriverConfig: MessageFns<GcePersistentDiskCsiDriverConfig> = {
  encode(message: GcePersistentDiskCsiDriverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcePersistentDiskCsiDriverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcePersistentDiskCsiDriverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcePersistentDiskCsiDriverConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: GcePersistentDiskCsiDriverConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GcePersistentDiskCsiDriverConfig>): GcePersistentDiskCsiDriverConfig {
    return GcePersistentDiskCsiDriverConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcePersistentDiskCsiDriverConfig>): GcePersistentDiskCsiDriverConfig {
    const message = createBaseGcePersistentDiskCsiDriverConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGcpFilestoreCsiDriverConfig(): GcpFilestoreCsiDriverConfig {
  return { enabled: false };
}

export const GcpFilestoreCsiDriverConfig: MessageFns<GcpFilestoreCsiDriverConfig> = {
  encode(message: GcpFilestoreCsiDriverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcpFilestoreCsiDriverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcpFilestoreCsiDriverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcpFilestoreCsiDriverConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: GcpFilestoreCsiDriverConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GcpFilestoreCsiDriverConfig>): GcpFilestoreCsiDriverConfig {
    return GcpFilestoreCsiDriverConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcpFilestoreCsiDriverConfig>): GcpFilestoreCsiDriverConfig {
    const message = createBaseGcpFilestoreCsiDriverConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGcsFuseCsiDriverConfig(): GcsFuseCsiDriverConfig {
  return { enabled: false };
}

export const GcsFuseCsiDriverConfig: MessageFns<GcsFuseCsiDriverConfig> = {
  encode(message: GcsFuseCsiDriverConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsFuseCsiDriverConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsFuseCsiDriverConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsFuseCsiDriverConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: GcsFuseCsiDriverConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsFuseCsiDriverConfig>): GcsFuseCsiDriverConfig {
    return GcsFuseCsiDriverConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsFuseCsiDriverConfig>): GcsFuseCsiDriverConfig {
    const message = createBaseGcsFuseCsiDriverConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseRayOperatorConfig(): RayOperatorConfig {
  return { enabled: false, rayClusterLoggingConfig: undefined, rayClusterMonitoringConfig: undefined };
}

export const RayOperatorConfig: MessageFns<RayOperatorConfig> = {
  encode(message: RayOperatorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.rayClusterLoggingConfig !== undefined) {
      RayClusterLoggingConfig.encode(message.rayClusterLoggingConfig, writer.uint32(18).fork()).join();
    }
    if (message.rayClusterMonitoringConfig !== undefined) {
      RayClusterMonitoringConfig.encode(message.rayClusterMonitoringConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RayOperatorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRayOperatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rayClusterLoggingConfig = RayClusterLoggingConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rayClusterMonitoringConfig = RayClusterMonitoringConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RayOperatorConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      rayClusterLoggingConfig: isSet(object.rayClusterLoggingConfig)
        ? RayClusterLoggingConfig.fromJSON(object.rayClusterLoggingConfig)
        : undefined,
      rayClusterMonitoringConfig: isSet(object.rayClusterMonitoringConfig)
        ? RayClusterMonitoringConfig.fromJSON(object.rayClusterMonitoringConfig)
        : undefined,
    };
  },

  toJSON(message: RayOperatorConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.rayClusterLoggingConfig !== undefined) {
      obj.rayClusterLoggingConfig = RayClusterLoggingConfig.toJSON(message.rayClusterLoggingConfig);
    }
    if (message.rayClusterMonitoringConfig !== undefined) {
      obj.rayClusterMonitoringConfig = RayClusterMonitoringConfig.toJSON(message.rayClusterMonitoringConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RayOperatorConfig>): RayOperatorConfig {
    return RayOperatorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RayOperatorConfig>): RayOperatorConfig {
    const message = createBaseRayOperatorConfig();
    message.enabled = object.enabled ?? false;
    message.rayClusterLoggingConfig =
      (object.rayClusterLoggingConfig !== undefined && object.rayClusterLoggingConfig !== null)
        ? RayClusterLoggingConfig.fromPartial(object.rayClusterLoggingConfig)
        : undefined;
    message.rayClusterMonitoringConfig =
      (object.rayClusterMonitoringConfig !== undefined && object.rayClusterMonitoringConfig !== null)
        ? RayClusterMonitoringConfig.fromPartial(object.rayClusterMonitoringConfig)
        : undefined;
    return message;
  },
};

function createBaseGkeBackupAgentConfig(): GkeBackupAgentConfig {
  return { enabled: false };
}

export const GkeBackupAgentConfig: MessageFns<GkeBackupAgentConfig> = {
  encode(message: GkeBackupAgentConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GkeBackupAgentConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGkeBackupAgentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GkeBackupAgentConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: GkeBackupAgentConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<GkeBackupAgentConfig>): GkeBackupAgentConfig {
    return GkeBackupAgentConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GkeBackupAgentConfig>): GkeBackupAgentConfig {
    const message = createBaseGkeBackupAgentConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseStatefulHAConfig(): StatefulHAConfig {
  return { enabled: false };
}

export const StatefulHAConfig: MessageFns<StatefulHAConfig> = {
  encode(message: StatefulHAConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatefulHAConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatefulHAConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatefulHAConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: StatefulHAConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<StatefulHAConfig>): StatefulHAConfig {
    return StatefulHAConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatefulHAConfig>): StatefulHAConfig {
    const message = createBaseStatefulHAConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig(): MasterAuthorizedNetworksConfig {
  return { enabled: false, cidrBlocks: [], gcpPublicCidrsAccessEnabled: undefined };
}

export const MasterAuthorizedNetworksConfig: MessageFns<MasterAuthorizedNetworksConfig> = {
  encode(message: MasterAuthorizedNetworksConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.cidrBlocks) {
      MasterAuthorizedNetworksConfig_CidrBlock.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.gcpPublicCidrsAccessEnabled !== undefined) {
      writer.uint32(24).bool(message.gcpPublicCidrsAccessEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlocks.push(MasterAuthorizedNetworksConfig_CidrBlock.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gcpPublicCidrsAccessEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      cidrBlocks: globalThis.Array.isArray(object?.cidrBlocks)
        ? object.cidrBlocks.map((e: any) => MasterAuthorizedNetworksConfig_CidrBlock.fromJSON(e))
        : [],
      gcpPublicCidrsAccessEnabled: isSet(object.gcpPublicCidrsAccessEnabled)
        ? globalThis.Boolean(object.gcpPublicCidrsAccessEnabled)
        : undefined,
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.cidrBlocks?.length) {
      obj.cidrBlocks = message.cidrBlocks.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.toJSON(e));
    }
    if (message.gcpPublicCidrsAccessEnabled !== undefined) {
      obj.gcpPublicCidrsAccessEnabled = message.gcpPublicCidrsAccessEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    return MasterAuthorizedNetworksConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    const message = createBaseMasterAuthorizedNetworksConfig();
    message.enabled = object.enabled ?? false;
    message.cidrBlocks = object.cidrBlocks?.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(e)) || [];
    message.gcpPublicCidrsAccessEnabled = object.gcpPublicCidrsAccessEnabled ?? undefined;
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig_CidrBlock(): MasterAuthorizedNetworksConfig_CidrBlock {
  return { displayName: "", cidrBlock: "" };
}

export const MasterAuthorizedNetworksConfig_CidrBlock: MessageFns<MasterAuthorizedNetworksConfig_CidrBlock> = {
  encode(message: MasterAuthorizedNetworksConfig_CidrBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.cidrBlock !== "") {
      writer.uint32(18).string(message.cidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig_CidrBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig_CidrBlock {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig_CidrBlock): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    return MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    message.displayName = object.displayName ?? "";
    message.cidrBlock = object.cidrBlock ?? "";
    return message;
  },
};

function createBaseLegacyAbac(): LegacyAbac {
  return { enabled: false };
}

export const LegacyAbac: MessageFns<LegacyAbac> = {
  encode(message: LegacyAbac, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LegacyAbac {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLegacyAbac();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LegacyAbac {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: LegacyAbac): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<LegacyAbac>): LegacyAbac {
    return LegacyAbac.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LegacyAbac>): LegacyAbac {
    const message = createBaseLegacyAbac();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseNetworkPolicy(): NetworkPolicy {
  return { provider: 0, enabled: false };
}

export const NetworkPolicy: MessageFns<NetworkPolicy> = {
  encode(message: NetworkPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== 0) {
      writer.uint32(8).int32(message.provider);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.provider = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicy {
    return {
      provider: isSet(object.provider) ? networkPolicy_ProviderFromJSON(object.provider) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: NetworkPolicy): unknown {
    const obj: any = {};
    if (message.provider !== 0) {
      obj.provider = networkPolicy_ProviderToJSON(message.provider);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicy>): NetworkPolicy {
    return NetworkPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicy>): NetworkPolicy {
    const message = createBaseNetworkPolicy();
    message.provider = object.provider ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseBinaryAuthorization(): BinaryAuthorization {
  return { enabled: false, evaluationMode: 0 };
}

export const BinaryAuthorization: MessageFns<BinaryAuthorization> = {
  encode(message: BinaryAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.evaluationMode !== 0) {
      writer.uint32(16).int32(message.evaluationMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.evaluationMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryAuthorization {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      evaluationMode: isSet(object.evaluationMode)
        ? binaryAuthorization_EvaluationModeFromJSON(object.evaluationMode)
        : 0,
    };
  },

  toJSON(message: BinaryAuthorization): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.evaluationMode !== 0) {
      obj.evaluationMode = binaryAuthorization_EvaluationModeToJSON(message.evaluationMode);
    }
    return obj;
  },

  create(base?: DeepPartial<BinaryAuthorization>): BinaryAuthorization {
    return BinaryAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinaryAuthorization>): BinaryAuthorization {
    const message = createBaseBinaryAuthorization();
    message.enabled = object.enabled ?? false;
    message.evaluationMode = object.evaluationMode ?? 0;
    return message;
  },
};

function createBasePodCIDROverprovisionConfig(): PodCIDROverprovisionConfig {
  return { disable: false };
}

export const PodCIDROverprovisionConfig: MessageFns<PodCIDROverprovisionConfig> = {
  encode(message: PodCIDROverprovisionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disable !== false) {
      writer.uint32(8).bool(message.disable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PodCIDROverprovisionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePodCIDROverprovisionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PodCIDROverprovisionConfig {
    return { disable: isSet(object.disable) ? globalThis.Boolean(object.disable) : false };
  },

  toJSON(message: PodCIDROverprovisionConfig): unknown {
    const obj: any = {};
    if (message.disable !== false) {
      obj.disable = message.disable;
    }
    return obj;
  },

  create(base?: DeepPartial<PodCIDROverprovisionConfig>): PodCIDROverprovisionConfig {
    return PodCIDROverprovisionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PodCIDROverprovisionConfig>): PodCIDROverprovisionConfig {
    const message = createBasePodCIDROverprovisionConfig();
    message.disable = object.disable ?? false;
    return message;
  },
};

function createBaseIPAllocationPolicy(): IPAllocationPolicy {
  return {
    useIpAliases: false,
    createSubnetwork: false,
    subnetworkName: "",
    clusterIpv4Cidr: "",
    nodeIpv4Cidr: "",
    servicesIpv4Cidr: "",
    clusterSecondaryRangeName: "",
    servicesSecondaryRangeName: "",
    clusterIpv4CidrBlock: "",
    nodeIpv4CidrBlock: "",
    servicesIpv4CidrBlock: "",
    tpuIpv4CidrBlock: "",
    useRoutes: false,
    stackType: 0,
    ipv6AccessType: 0,
    podCidrOverprovisionConfig: undefined,
    subnetIpv6CidrBlock: "",
    servicesIpv6CidrBlock: "",
    additionalPodRangesConfig: undefined,
    defaultPodIpv4RangeUtilization: 0,
  };
}

export const IPAllocationPolicy: MessageFns<IPAllocationPolicy> = {
  encode(message: IPAllocationPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useIpAliases !== false) {
      writer.uint32(8).bool(message.useIpAliases);
    }
    if (message.createSubnetwork !== false) {
      writer.uint32(16).bool(message.createSubnetwork);
    }
    if (message.subnetworkName !== "") {
      writer.uint32(26).string(message.subnetworkName);
    }
    if (message.clusterIpv4Cidr !== "") {
      writer.uint32(34).string(message.clusterIpv4Cidr);
    }
    if (message.nodeIpv4Cidr !== "") {
      writer.uint32(42).string(message.nodeIpv4Cidr);
    }
    if (message.servicesIpv4Cidr !== "") {
      writer.uint32(50).string(message.servicesIpv4Cidr);
    }
    if (message.clusterSecondaryRangeName !== "") {
      writer.uint32(58).string(message.clusterSecondaryRangeName);
    }
    if (message.servicesSecondaryRangeName !== "") {
      writer.uint32(66).string(message.servicesSecondaryRangeName);
    }
    if (message.clusterIpv4CidrBlock !== "") {
      writer.uint32(74).string(message.clusterIpv4CidrBlock);
    }
    if (message.nodeIpv4CidrBlock !== "") {
      writer.uint32(82).string(message.nodeIpv4CidrBlock);
    }
    if (message.servicesIpv4CidrBlock !== "") {
      writer.uint32(90).string(message.servicesIpv4CidrBlock);
    }
    if (message.tpuIpv4CidrBlock !== "") {
      writer.uint32(106).string(message.tpuIpv4CidrBlock);
    }
    if (message.useRoutes !== false) {
      writer.uint32(120).bool(message.useRoutes);
    }
    if (message.stackType !== 0) {
      writer.uint32(128).int32(message.stackType);
    }
    if (message.ipv6AccessType !== 0) {
      writer.uint32(136).int32(message.ipv6AccessType);
    }
    if (message.podCidrOverprovisionConfig !== undefined) {
      PodCIDROverprovisionConfig.encode(message.podCidrOverprovisionConfig, writer.uint32(170).fork()).join();
    }
    if (message.subnetIpv6CidrBlock !== "") {
      writer.uint32(178).string(message.subnetIpv6CidrBlock);
    }
    if (message.servicesIpv6CidrBlock !== "") {
      writer.uint32(186).string(message.servicesIpv6CidrBlock);
    }
    if (message.additionalPodRangesConfig !== undefined) {
      AdditionalPodRangesConfig.encode(message.additionalPodRangesConfig, writer.uint32(194).fork()).join();
    }
    if (message.defaultPodIpv4RangeUtilization !== 0) {
      writer.uint32(201).double(message.defaultPodIpv4RangeUtilization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IPAllocationPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIPAllocationPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useIpAliases = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.createSubnetwork = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subnetworkName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterIpv4Cidr = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeIpv4Cidr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.servicesIpv4Cidr = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clusterSecondaryRangeName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.servicesSecondaryRangeName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clusterIpv4CidrBlock = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nodeIpv4CidrBlock = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.servicesIpv4CidrBlock = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.tpuIpv4CidrBlock = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.useRoutes = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.stackType = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.ipv6AccessType = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.podCidrOverprovisionConfig = PodCIDROverprovisionConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.subnetIpv6CidrBlock = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.servicesIpv6CidrBlock = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.additionalPodRangesConfig = AdditionalPodRangesConfig.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 201) {
            break;
          }

          message.defaultPodIpv4RangeUtilization = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IPAllocationPolicy {
    return {
      useIpAliases: isSet(object.useIpAliases) ? globalThis.Boolean(object.useIpAliases) : false,
      createSubnetwork: isSet(object.createSubnetwork) ? globalThis.Boolean(object.createSubnetwork) : false,
      subnetworkName: isSet(object.subnetworkName) ? globalThis.String(object.subnetworkName) : "",
      clusterIpv4Cidr: isSet(object.clusterIpv4Cidr) ? globalThis.String(object.clusterIpv4Cidr) : "",
      nodeIpv4Cidr: isSet(object.nodeIpv4Cidr) ? globalThis.String(object.nodeIpv4Cidr) : "",
      servicesIpv4Cidr: isSet(object.servicesIpv4Cidr) ? globalThis.String(object.servicesIpv4Cidr) : "",
      clusterSecondaryRangeName: isSet(object.clusterSecondaryRangeName)
        ? globalThis.String(object.clusterSecondaryRangeName)
        : "",
      servicesSecondaryRangeName: isSet(object.servicesSecondaryRangeName)
        ? globalThis.String(object.servicesSecondaryRangeName)
        : "",
      clusterIpv4CidrBlock: isSet(object.clusterIpv4CidrBlock) ? globalThis.String(object.clusterIpv4CidrBlock) : "",
      nodeIpv4CidrBlock: isSet(object.nodeIpv4CidrBlock) ? globalThis.String(object.nodeIpv4CidrBlock) : "",
      servicesIpv4CidrBlock: isSet(object.servicesIpv4CidrBlock) ? globalThis.String(object.servicesIpv4CidrBlock) : "",
      tpuIpv4CidrBlock: isSet(object.tpuIpv4CidrBlock) ? globalThis.String(object.tpuIpv4CidrBlock) : "",
      useRoutes: isSet(object.useRoutes) ? globalThis.Boolean(object.useRoutes) : false,
      stackType: isSet(object.stackType) ? stackTypeFromJSON(object.stackType) : 0,
      ipv6AccessType: isSet(object.ipv6AccessType) ? iPv6AccessTypeFromJSON(object.ipv6AccessType) : 0,
      podCidrOverprovisionConfig: isSet(object.podCidrOverprovisionConfig)
        ? PodCIDROverprovisionConfig.fromJSON(object.podCidrOverprovisionConfig)
        : undefined,
      subnetIpv6CidrBlock: isSet(object.subnetIpv6CidrBlock) ? globalThis.String(object.subnetIpv6CidrBlock) : "",
      servicesIpv6CidrBlock: isSet(object.servicesIpv6CidrBlock) ? globalThis.String(object.servicesIpv6CidrBlock) : "",
      additionalPodRangesConfig: isSet(object.additionalPodRangesConfig)
        ? AdditionalPodRangesConfig.fromJSON(object.additionalPodRangesConfig)
        : undefined,
      defaultPodIpv4RangeUtilization: isSet(object.defaultPodIpv4RangeUtilization)
        ? globalThis.Number(object.defaultPodIpv4RangeUtilization)
        : 0,
    };
  },

  toJSON(message: IPAllocationPolicy): unknown {
    const obj: any = {};
    if (message.useIpAliases !== false) {
      obj.useIpAliases = message.useIpAliases;
    }
    if (message.createSubnetwork !== false) {
      obj.createSubnetwork = message.createSubnetwork;
    }
    if (message.subnetworkName !== "") {
      obj.subnetworkName = message.subnetworkName;
    }
    if (message.clusterIpv4Cidr !== "") {
      obj.clusterIpv4Cidr = message.clusterIpv4Cidr;
    }
    if (message.nodeIpv4Cidr !== "") {
      obj.nodeIpv4Cidr = message.nodeIpv4Cidr;
    }
    if (message.servicesIpv4Cidr !== "") {
      obj.servicesIpv4Cidr = message.servicesIpv4Cidr;
    }
    if (message.clusterSecondaryRangeName !== "") {
      obj.clusterSecondaryRangeName = message.clusterSecondaryRangeName;
    }
    if (message.servicesSecondaryRangeName !== "") {
      obj.servicesSecondaryRangeName = message.servicesSecondaryRangeName;
    }
    if (message.clusterIpv4CidrBlock !== "") {
      obj.clusterIpv4CidrBlock = message.clusterIpv4CidrBlock;
    }
    if (message.nodeIpv4CidrBlock !== "") {
      obj.nodeIpv4CidrBlock = message.nodeIpv4CidrBlock;
    }
    if (message.servicesIpv4CidrBlock !== "") {
      obj.servicesIpv4CidrBlock = message.servicesIpv4CidrBlock;
    }
    if (message.tpuIpv4CidrBlock !== "") {
      obj.tpuIpv4CidrBlock = message.tpuIpv4CidrBlock;
    }
    if (message.useRoutes !== false) {
      obj.useRoutes = message.useRoutes;
    }
    if (message.stackType !== 0) {
      obj.stackType = stackTypeToJSON(message.stackType);
    }
    if (message.ipv6AccessType !== 0) {
      obj.ipv6AccessType = iPv6AccessTypeToJSON(message.ipv6AccessType);
    }
    if (message.podCidrOverprovisionConfig !== undefined) {
      obj.podCidrOverprovisionConfig = PodCIDROverprovisionConfig.toJSON(message.podCidrOverprovisionConfig);
    }
    if (message.subnetIpv6CidrBlock !== "") {
      obj.subnetIpv6CidrBlock = message.subnetIpv6CidrBlock;
    }
    if (message.servicesIpv6CidrBlock !== "") {
      obj.servicesIpv6CidrBlock = message.servicesIpv6CidrBlock;
    }
    if (message.additionalPodRangesConfig !== undefined) {
      obj.additionalPodRangesConfig = AdditionalPodRangesConfig.toJSON(message.additionalPodRangesConfig);
    }
    if (message.defaultPodIpv4RangeUtilization !== 0) {
      obj.defaultPodIpv4RangeUtilization = message.defaultPodIpv4RangeUtilization;
    }
    return obj;
  },

  create(base?: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    return IPAllocationPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IPAllocationPolicy>): IPAllocationPolicy {
    const message = createBaseIPAllocationPolicy();
    message.useIpAliases = object.useIpAliases ?? false;
    message.createSubnetwork = object.createSubnetwork ?? false;
    message.subnetworkName = object.subnetworkName ?? "";
    message.clusterIpv4Cidr = object.clusterIpv4Cidr ?? "";
    message.nodeIpv4Cidr = object.nodeIpv4Cidr ?? "";
    message.servicesIpv4Cidr = object.servicesIpv4Cidr ?? "";
    message.clusterSecondaryRangeName = object.clusterSecondaryRangeName ?? "";
    message.servicesSecondaryRangeName = object.servicesSecondaryRangeName ?? "";
    message.clusterIpv4CidrBlock = object.clusterIpv4CidrBlock ?? "";
    message.nodeIpv4CidrBlock = object.nodeIpv4CidrBlock ?? "";
    message.servicesIpv4CidrBlock = object.servicesIpv4CidrBlock ?? "";
    message.tpuIpv4CidrBlock = object.tpuIpv4CidrBlock ?? "";
    message.useRoutes = object.useRoutes ?? false;
    message.stackType = object.stackType ?? 0;
    message.ipv6AccessType = object.ipv6AccessType ?? 0;
    message.podCidrOverprovisionConfig =
      (object.podCidrOverprovisionConfig !== undefined && object.podCidrOverprovisionConfig !== null)
        ? PodCIDROverprovisionConfig.fromPartial(object.podCidrOverprovisionConfig)
        : undefined;
    message.subnetIpv6CidrBlock = object.subnetIpv6CidrBlock ?? "";
    message.servicesIpv6CidrBlock = object.servicesIpv6CidrBlock ?? "";
    message.additionalPodRangesConfig =
      (object.additionalPodRangesConfig !== undefined && object.additionalPodRangesConfig !== null)
        ? AdditionalPodRangesConfig.fromPartial(object.additionalPodRangesConfig)
        : undefined;
    message.defaultPodIpv4RangeUtilization = object.defaultPodIpv4RangeUtilization ?? 0;
    return message;
  },
};

function createBaseCluster(): Cluster {
  return {
    name: "",
    description: "",
    initialNodeCount: 0,
    nodeConfig: undefined,
    masterAuth: undefined,
    loggingService: "",
    monitoringService: "",
    network: "",
    clusterIpv4Cidr: "",
    addonsConfig: undefined,
    subnetwork: "",
    nodePools: [],
    locations: [],
    enableKubernetesAlpha: false,
    resourceLabels: {},
    labelFingerprint: "",
    legacyAbac: undefined,
    networkPolicy: undefined,
    ipAllocationPolicy: undefined,
    masterAuthorizedNetworksConfig: undefined,
    maintenancePolicy: undefined,
    binaryAuthorization: undefined,
    autoscaling: undefined,
    networkConfig: undefined,
    defaultMaxPodsConstraint: undefined,
    resourceUsageExportConfig: undefined,
    authenticatorGroupsConfig: undefined,
    privateClusterConfig: undefined,
    databaseEncryption: undefined,
    verticalPodAutoscaling: undefined,
    shieldedNodes: undefined,
    releaseChannel: undefined,
    workloadIdentityConfig: undefined,
    meshCertificates: undefined,
    costManagementConfig: undefined,
    notificationConfig: undefined,
    confidentialNodes: undefined,
    identityServiceConfig: undefined,
    selfLink: "",
    zone: "",
    endpoint: "",
    initialClusterVersion: "",
    currentMasterVersion: "",
    currentNodeVersion: "",
    createTime: "",
    status: 0,
    statusMessage: "",
    nodeIpv4CidrSize: 0,
    servicesIpv4Cidr: "",
    instanceGroupUrls: [],
    currentNodeCount: 0,
    expireTime: "",
    location: "",
    enableTpu: false,
    tpuIpv4CidrBlock: "",
    conditions: [],
    autopilot: undefined,
    id: "",
    nodePoolDefaults: undefined,
    loggingConfig: undefined,
    monitoringConfig: undefined,
    nodePoolAutoConfig: undefined,
    etag: "",
    fleet: undefined,
    securityPostureConfig: undefined,
    enableK8sBetaApis: undefined,
    enterpriseConfig: undefined,
    satisfiesPzs: undefined,
    satisfiesPzi: undefined,
  };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.initialNodeCount !== 0) {
      writer.uint32(24).int32(message.initialNodeCount);
    }
    if (message.nodeConfig !== undefined) {
      NodeConfig.encode(message.nodeConfig, writer.uint32(34).fork()).join();
    }
    if (message.masterAuth !== undefined) {
      MasterAuth.encode(message.masterAuth, writer.uint32(42).fork()).join();
    }
    if (message.loggingService !== "") {
      writer.uint32(50).string(message.loggingService);
    }
    if (message.monitoringService !== "") {
      writer.uint32(58).string(message.monitoringService);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    if (message.clusterIpv4Cidr !== "") {
      writer.uint32(74).string(message.clusterIpv4Cidr);
    }
    if (message.addonsConfig !== undefined) {
      AddonsConfig.encode(message.addonsConfig, writer.uint32(82).fork()).join();
    }
    if (message.subnetwork !== "") {
      writer.uint32(90).string(message.subnetwork);
    }
    for (const v of message.nodePools) {
      NodePool.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.locations) {
      writer.uint32(106).string(v!);
    }
    if (message.enableKubernetesAlpha !== false) {
      writer.uint32(112).bool(message.enableKubernetesAlpha);
    }
    Object.entries(message.resourceLabels).forEach(([key, value]) => {
      Cluster_ResourceLabelsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.labelFingerprint !== "") {
      writer.uint32(130).string(message.labelFingerprint);
    }
    if (message.legacyAbac !== undefined) {
      LegacyAbac.encode(message.legacyAbac, writer.uint32(146).fork()).join();
    }
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(154).fork()).join();
    }
    if (message.ipAllocationPolicy !== undefined) {
      IPAllocationPolicy.encode(message.ipAllocationPolicy, writer.uint32(162).fork()).join();
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.masterAuthorizedNetworksConfig, writer.uint32(178).fork()).join();
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(186).fork()).join();
    }
    if (message.binaryAuthorization !== undefined) {
      BinaryAuthorization.encode(message.binaryAuthorization, writer.uint32(194).fork()).join();
    }
    if (message.autoscaling !== undefined) {
      ClusterAutoscaling.encode(message.autoscaling, writer.uint32(210).fork()).join();
    }
    if (message.networkConfig !== undefined) {
      NetworkConfig.encode(message.networkConfig, writer.uint32(218).fork()).join();
    }
    if (message.defaultMaxPodsConstraint !== undefined) {
      MaxPodsConstraint.encode(message.defaultMaxPodsConstraint, writer.uint32(242).fork()).join();
    }
    if (message.resourceUsageExportConfig !== undefined) {
      ResourceUsageExportConfig.encode(message.resourceUsageExportConfig, writer.uint32(266).fork()).join();
    }
    if (message.authenticatorGroupsConfig !== undefined) {
      AuthenticatorGroupsConfig.encode(message.authenticatorGroupsConfig, writer.uint32(274).fork()).join();
    }
    if (message.privateClusterConfig !== undefined) {
      PrivateClusterConfig.encode(message.privateClusterConfig, writer.uint32(298).fork()).join();
    }
    if (message.databaseEncryption !== undefined) {
      DatabaseEncryption.encode(message.databaseEncryption, writer.uint32(306).fork()).join();
    }
    if (message.verticalPodAutoscaling !== undefined) {
      VerticalPodAutoscaling.encode(message.verticalPodAutoscaling, writer.uint32(314).fork()).join();
    }
    if (message.shieldedNodes !== undefined) {
      ShieldedNodes.encode(message.shieldedNodes, writer.uint32(322).fork()).join();
    }
    if (message.releaseChannel !== undefined) {
      ReleaseChannel.encode(message.releaseChannel, writer.uint32(330).fork()).join();
    }
    if (message.workloadIdentityConfig !== undefined) {
      WorkloadIdentityConfig.encode(message.workloadIdentityConfig, writer.uint32(346).fork()).join();
    }
    if (message.meshCertificates !== undefined) {
      MeshCertificates.encode(message.meshCertificates, writer.uint32(538).fork()).join();
    }
    if (message.costManagementConfig !== undefined) {
      CostManagementConfig.encode(message.costManagementConfig, writer.uint32(362).fork()).join();
    }
    if (message.notificationConfig !== undefined) {
      NotificationConfig.encode(message.notificationConfig, writer.uint32(394).fork()).join();
    }
    if (message.confidentialNodes !== undefined) {
      ConfidentialNodes.encode(message.confidentialNodes, writer.uint32(402).fork()).join();
    }
    if (message.identityServiceConfig !== undefined) {
      IdentityServiceConfig.encode(message.identityServiceConfig, writer.uint32(434).fork()).join();
    }
    if (message.selfLink !== "") {
      writer.uint32(802).string(message.selfLink);
    }
    if (message.zone !== "") {
      writer.uint32(810).string(message.zone);
    }
    if (message.endpoint !== "") {
      writer.uint32(818).string(message.endpoint);
    }
    if (message.initialClusterVersion !== "") {
      writer.uint32(826).string(message.initialClusterVersion);
    }
    if (message.currentMasterVersion !== "") {
      writer.uint32(834).string(message.currentMasterVersion);
    }
    if (message.currentNodeVersion !== "") {
      writer.uint32(842).string(message.currentNodeVersion);
    }
    if (message.createTime !== "") {
      writer.uint32(850).string(message.createTime);
    }
    if (message.status !== 0) {
      writer.uint32(856).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(866).string(message.statusMessage);
    }
    if (message.nodeIpv4CidrSize !== 0) {
      writer.uint32(872).int32(message.nodeIpv4CidrSize);
    }
    if (message.servicesIpv4Cidr !== "") {
      writer.uint32(882).string(message.servicesIpv4Cidr);
    }
    for (const v of message.instanceGroupUrls) {
      writer.uint32(890).string(v!);
    }
    if (message.currentNodeCount !== 0) {
      writer.uint32(896).int32(message.currentNodeCount);
    }
    if (message.expireTime !== "") {
      writer.uint32(906).string(message.expireTime);
    }
    if (message.location !== "") {
      writer.uint32(914).string(message.location);
    }
    if (message.enableTpu !== false) {
      writer.uint32(920).bool(message.enableTpu);
    }
    if (message.tpuIpv4CidrBlock !== "") {
      writer.uint32(930).string(message.tpuIpv4CidrBlock);
    }
    for (const v of message.conditions) {
      StatusCondition.encode(v!, writer.uint32(946).fork()).join();
    }
    if (message.autopilot !== undefined) {
      Autopilot.encode(message.autopilot, writer.uint32(1026).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(1034).string(message.id);
    }
    if (message.nodePoolDefaults !== undefined) {
      NodePoolDefaults.encode(message.nodePoolDefaults, writer.uint32(1050).fork()).join();
    }
    if (message.loggingConfig !== undefined) {
      LoggingConfig.encode(message.loggingConfig, writer.uint32(1058).fork()).join();
    }
    if (message.monitoringConfig !== undefined) {
      MonitoringConfig.encode(message.monitoringConfig, writer.uint32(1066).fork()).join();
    }
    if (message.nodePoolAutoConfig !== undefined) {
      NodePoolAutoConfig.encode(message.nodePoolAutoConfig, writer.uint32(1090).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(1114).string(message.etag);
    }
    if (message.fleet !== undefined) {
      Fleet.encode(message.fleet, writer.uint32(1122).fork()).join();
    }
    if (message.securityPostureConfig !== undefined) {
      SecurityPostureConfig.encode(message.securityPostureConfig, writer.uint32(1162).fork()).join();
    }
    if (message.enableK8sBetaApis !== undefined) {
      K8sBetaAPIConfig.encode(message.enableK8sBetaApis, writer.uint32(1146).fork()).join();
    }
    if (message.enterpriseConfig !== undefined) {
      EnterpriseConfig.encode(message.enterpriseConfig, writer.uint32(1194).fork()).join();
    }
    if (message.satisfiesPzs !== undefined) {
      writer.uint32(1216).bool(message.satisfiesPzs);
    }
    if (message.satisfiesPzi !== undefined) {
      writer.uint32(1224).bool(message.satisfiesPzi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.initialNodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeConfig = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.masterAuth = MasterAuth.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.loggingService = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.monitoringService = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.clusterIpv4Cidr = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.addonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.nodePools.push(NodePool.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.enableKubernetesAlpha = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = Cluster_ResourceLabelsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.resourceLabels[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.labelFingerprint = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.legacyAbac = LegacyAbac.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.ipAllocationPolicy = IPAllocationPolicy.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.binaryAuthorization = BinaryAuthorization.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.autoscaling = ClusterAutoscaling.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.networkConfig = NetworkConfig.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.defaultMaxPodsConstraint = MaxPodsConstraint.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.resourceUsageExportConfig = ResourceUsageExportConfig.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.authenticatorGroupsConfig = AuthenticatorGroupsConfig.decode(reader, reader.uint32());
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.privateClusterConfig = PrivateClusterConfig.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.databaseEncryption = DatabaseEncryption.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.verticalPodAutoscaling = VerticalPodAutoscaling.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.shieldedNodes = ShieldedNodes.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.releaseChannel = ReleaseChannel.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.workloadIdentityConfig = WorkloadIdentityConfig.decode(reader, reader.uint32());
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }

          message.meshCertificates = MeshCertificates.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.costManagementConfig = CostManagementConfig.decode(reader, reader.uint32());
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.notificationConfig = NotificationConfig.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.confidentialNodes = ConfidentialNodes.decode(reader, reader.uint32());
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.identityServiceConfig = IdentityServiceConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.initialClusterVersion = reader.string();
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.currentMasterVersion = reader.string();
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.currentNodeVersion = reader.string();
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.createTime = reader.string();
          continue;
        case 107:
          if (tag !== 856) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 109:
          if (tag !== 872) {
            break;
          }

          message.nodeIpv4CidrSize = reader.int32();
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.servicesIpv4Cidr = reader.string();
          continue;
        case 111:
          if (tag !== 890) {
            break;
          }

          message.instanceGroupUrls.push(reader.string());
          continue;
        case 112:
          if (tag !== 896) {
            break;
          }

          message.currentNodeCount = reader.int32();
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }

          message.expireTime = reader.string();
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }

          message.location = reader.string();
          continue;
        case 115:
          if (tag !== 920) {
            break;
          }

          message.enableTpu = reader.bool();
          continue;
        case 116:
          if (tag !== 930) {
            break;
          }

          message.tpuIpv4CidrBlock = reader.string();
          continue;
        case 118:
          if (tag !== 946) {
            break;
          }

          message.conditions.push(StatusCondition.decode(reader, reader.uint32()));
          continue;
        case 128:
          if (tag !== 1026) {
            break;
          }

          message.autopilot = Autopilot.decode(reader, reader.uint32());
          continue;
        case 129:
          if (tag !== 1034) {
            break;
          }

          message.id = reader.string();
          continue;
        case 131:
          if (tag !== 1050) {
            break;
          }

          message.nodePoolDefaults = NodePoolDefaults.decode(reader, reader.uint32());
          continue;
        case 132:
          if (tag !== 1058) {
            break;
          }

          message.loggingConfig = LoggingConfig.decode(reader, reader.uint32());
          continue;
        case 133:
          if (tag !== 1066) {
            break;
          }

          message.monitoringConfig = MonitoringConfig.decode(reader, reader.uint32());
          continue;
        case 136:
          if (tag !== 1090) {
            break;
          }

          message.nodePoolAutoConfig = NodePoolAutoConfig.decode(reader, reader.uint32());
          continue;
        case 139:
          if (tag !== 1114) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 140:
          if (tag !== 1122) {
            break;
          }

          message.fleet = Fleet.decode(reader, reader.uint32());
          continue;
        case 145:
          if (tag !== 1162) {
            break;
          }

          message.securityPostureConfig = SecurityPostureConfig.decode(reader, reader.uint32());
          continue;
        case 143:
          if (tag !== 1146) {
            break;
          }

          message.enableK8sBetaApis = K8sBetaAPIConfig.decode(reader, reader.uint32());
          continue;
        case 149:
          if (tag !== 1194) {
            break;
          }

          message.enterpriseConfig = EnterpriseConfig.decode(reader, reader.uint32());
          continue;
        case 152:
          if (tag !== 1216) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 153:
          if (tag !== 1224) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      initialNodeCount: isSet(object.initialNodeCount) ? globalThis.Number(object.initialNodeCount) : 0,
      nodeConfig: isSet(object.nodeConfig) ? NodeConfig.fromJSON(object.nodeConfig) : undefined,
      masterAuth: isSet(object.masterAuth) ? MasterAuth.fromJSON(object.masterAuth) : undefined,
      loggingService: isSet(object.loggingService) ? globalThis.String(object.loggingService) : "",
      monitoringService: isSet(object.monitoringService) ? globalThis.String(object.monitoringService) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      clusterIpv4Cidr: isSet(object.clusterIpv4Cidr) ? globalThis.String(object.clusterIpv4Cidr) : "",
      addonsConfig: isSet(object.addonsConfig) ? AddonsConfig.fromJSON(object.addonsConfig) : undefined,
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      nodePools: globalThis.Array.isArray(object?.nodePools)
        ? object.nodePools.map((e: any) => NodePool.fromJSON(e))
        : [],
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      enableKubernetesAlpha: isSet(object.enableKubernetesAlpha)
        ? globalThis.Boolean(object.enableKubernetesAlpha)
        : false,
      resourceLabels: isObject(object.resourceLabels)
        ? Object.entries(object.resourceLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labelFingerprint: isSet(object.labelFingerprint) ? globalThis.String(object.labelFingerprint) : "",
      legacyAbac: isSet(object.legacyAbac) ? LegacyAbac.fromJSON(object.legacyAbac) : undefined,
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      ipAllocationPolicy: isSet(object.ipAllocationPolicy)
        ? IPAllocationPolicy.fromJSON(object.ipAllocationPolicy)
        : undefined,
      masterAuthorizedNetworksConfig: isSet(object.masterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.masterAuthorizedNetworksConfig)
        : undefined,
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      binaryAuthorization: isSet(object.binaryAuthorization)
        ? BinaryAuthorization.fromJSON(object.binaryAuthorization)
        : undefined,
      autoscaling: isSet(object.autoscaling) ? ClusterAutoscaling.fromJSON(object.autoscaling) : undefined,
      networkConfig: isSet(object.networkConfig) ? NetworkConfig.fromJSON(object.networkConfig) : undefined,
      defaultMaxPodsConstraint: isSet(object.defaultMaxPodsConstraint)
        ? MaxPodsConstraint.fromJSON(object.defaultMaxPodsConstraint)
        : undefined,
      resourceUsageExportConfig: isSet(object.resourceUsageExportConfig)
        ? ResourceUsageExportConfig.fromJSON(object.resourceUsageExportConfig)
        : undefined,
      authenticatorGroupsConfig: isSet(object.authenticatorGroupsConfig)
        ? AuthenticatorGroupsConfig.fromJSON(object.authenticatorGroupsConfig)
        : undefined,
      privateClusterConfig: isSet(object.privateClusterConfig)
        ? PrivateClusterConfig.fromJSON(object.privateClusterConfig)
        : undefined,
      databaseEncryption: isSet(object.databaseEncryption)
        ? DatabaseEncryption.fromJSON(object.databaseEncryption)
        : undefined,
      verticalPodAutoscaling: isSet(object.verticalPodAutoscaling)
        ? VerticalPodAutoscaling.fromJSON(object.verticalPodAutoscaling)
        : undefined,
      shieldedNodes: isSet(object.shieldedNodes) ? ShieldedNodes.fromJSON(object.shieldedNodes) : undefined,
      releaseChannel: isSet(object.releaseChannel) ? ReleaseChannel.fromJSON(object.releaseChannel) : undefined,
      workloadIdentityConfig: isSet(object.workloadIdentityConfig)
        ? WorkloadIdentityConfig.fromJSON(object.workloadIdentityConfig)
        : undefined,
      meshCertificates: isSet(object.meshCertificates) ? MeshCertificates.fromJSON(object.meshCertificates) : undefined,
      costManagementConfig: isSet(object.costManagementConfig)
        ? CostManagementConfig.fromJSON(object.costManagementConfig)
        : undefined,
      notificationConfig: isSet(object.notificationConfig)
        ? NotificationConfig.fromJSON(object.notificationConfig)
        : undefined,
      confidentialNodes: isSet(object.confidentialNodes)
        ? ConfidentialNodes.fromJSON(object.confidentialNodes)
        : undefined,
      identityServiceConfig: isSet(object.identityServiceConfig)
        ? IdentityServiceConfig.fromJSON(object.identityServiceConfig)
        : undefined,
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      initialClusterVersion: isSet(object.initialClusterVersion) ? globalThis.String(object.initialClusterVersion) : "",
      currentMasterVersion: isSet(object.currentMasterVersion) ? globalThis.String(object.currentMasterVersion) : "",
      currentNodeVersion: isSet(object.currentNodeVersion) ? globalThis.String(object.currentNodeVersion) : "",
      createTime: isSet(object.createTime) ? globalThis.String(object.createTime) : "",
      status: isSet(object.status) ? cluster_StatusFromJSON(object.status) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      nodeIpv4CidrSize: isSet(object.nodeIpv4CidrSize) ? globalThis.Number(object.nodeIpv4CidrSize) : 0,
      servicesIpv4Cidr: isSet(object.servicesIpv4Cidr) ? globalThis.String(object.servicesIpv4Cidr) : "",
      instanceGroupUrls: globalThis.Array.isArray(object?.instanceGroupUrls)
        ? object.instanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      currentNodeCount: isSet(object.currentNodeCount) ? globalThis.Number(object.currentNodeCount) : 0,
      expireTime: isSet(object.expireTime) ? globalThis.String(object.expireTime) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      enableTpu: isSet(object.enableTpu) ? globalThis.Boolean(object.enableTpu) : false,
      tpuIpv4CidrBlock: isSet(object.tpuIpv4CidrBlock) ? globalThis.String(object.tpuIpv4CidrBlock) : "",
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => StatusCondition.fromJSON(e))
        : [],
      autopilot: isSet(object.autopilot) ? Autopilot.fromJSON(object.autopilot) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      nodePoolDefaults: isSet(object.nodePoolDefaults) ? NodePoolDefaults.fromJSON(object.nodePoolDefaults) : undefined,
      loggingConfig: isSet(object.loggingConfig) ? LoggingConfig.fromJSON(object.loggingConfig) : undefined,
      monitoringConfig: isSet(object.monitoringConfig) ? MonitoringConfig.fromJSON(object.monitoringConfig) : undefined,
      nodePoolAutoConfig: isSet(object.nodePoolAutoConfig)
        ? NodePoolAutoConfig.fromJSON(object.nodePoolAutoConfig)
        : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      fleet: isSet(object.fleet) ? Fleet.fromJSON(object.fleet) : undefined,
      securityPostureConfig: isSet(object.securityPostureConfig)
        ? SecurityPostureConfig.fromJSON(object.securityPostureConfig)
        : undefined,
      enableK8sBetaApis: isSet(object.enableK8sBetaApis)
        ? K8sBetaAPIConfig.fromJSON(object.enableK8sBetaApis)
        : undefined,
      enterpriseConfig: isSet(object.enterpriseConfig) ? EnterpriseConfig.fromJSON(object.enterpriseConfig) : undefined,
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : undefined,
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.initialNodeCount !== 0) {
      obj.initialNodeCount = Math.round(message.initialNodeCount);
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodeConfig.toJSON(message.nodeConfig);
    }
    if (message.masterAuth !== undefined) {
      obj.masterAuth = MasterAuth.toJSON(message.masterAuth);
    }
    if (message.loggingService !== "") {
      obj.loggingService = message.loggingService;
    }
    if (message.monitoringService !== "") {
      obj.monitoringService = message.monitoringService;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.clusterIpv4Cidr !== "") {
      obj.clusterIpv4Cidr = message.clusterIpv4Cidr;
    }
    if (message.addonsConfig !== undefined) {
      obj.addonsConfig = AddonsConfig.toJSON(message.addonsConfig);
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.nodePools?.length) {
      obj.nodePools = message.nodePools.map((e) => NodePool.toJSON(e));
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.enableKubernetesAlpha !== false) {
      obj.enableKubernetesAlpha = message.enableKubernetesAlpha;
    }
    if (message.resourceLabels) {
      const entries = Object.entries(message.resourceLabels);
      if (entries.length > 0) {
        obj.resourceLabels = {};
        entries.forEach(([k, v]) => {
          obj.resourceLabels[k] = v;
        });
      }
    }
    if (message.labelFingerprint !== "") {
      obj.labelFingerprint = message.labelFingerprint;
    }
    if (message.legacyAbac !== undefined) {
      obj.legacyAbac = LegacyAbac.toJSON(message.legacyAbac);
    }
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.ipAllocationPolicy !== undefined) {
      obj.ipAllocationPolicy = IPAllocationPolicy.toJSON(message.ipAllocationPolicy);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      obj.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.masterAuthorizedNetworksConfig,
      );
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.binaryAuthorization !== undefined) {
      obj.binaryAuthorization = BinaryAuthorization.toJSON(message.binaryAuthorization);
    }
    if (message.autoscaling !== undefined) {
      obj.autoscaling = ClusterAutoscaling.toJSON(message.autoscaling);
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = NetworkConfig.toJSON(message.networkConfig);
    }
    if (message.defaultMaxPodsConstraint !== undefined) {
      obj.defaultMaxPodsConstraint = MaxPodsConstraint.toJSON(message.defaultMaxPodsConstraint);
    }
    if (message.resourceUsageExportConfig !== undefined) {
      obj.resourceUsageExportConfig = ResourceUsageExportConfig.toJSON(message.resourceUsageExportConfig);
    }
    if (message.authenticatorGroupsConfig !== undefined) {
      obj.authenticatorGroupsConfig = AuthenticatorGroupsConfig.toJSON(message.authenticatorGroupsConfig);
    }
    if (message.privateClusterConfig !== undefined) {
      obj.privateClusterConfig = PrivateClusterConfig.toJSON(message.privateClusterConfig);
    }
    if (message.databaseEncryption !== undefined) {
      obj.databaseEncryption = DatabaseEncryption.toJSON(message.databaseEncryption);
    }
    if (message.verticalPodAutoscaling !== undefined) {
      obj.verticalPodAutoscaling = VerticalPodAutoscaling.toJSON(message.verticalPodAutoscaling);
    }
    if (message.shieldedNodes !== undefined) {
      obj.shieldedNodes = ShieldedNodes.toJSON(message.shieldedNodes);
    }
    if (message.releaseChannel !== undefined) {
      obj.releaseChannel = ReleaseChannel.toJSON(message.releaseChannel);
    }
    if (message.workloadIdentityConfig !== undefined) {
      obj.workloadIdentityConfig = WorkloadIdentityConfig.toJSON(message.workloadIdentityConfig);
    }
    if (message.meshCertificates !== undefined) {
      obj.meshCertificates = MeshCertificates.toJSON(message.meshCertificates);
    }
    if (message.costManagementConfig !== undefined) {
      obj.costManagementConfig = CostManagementConfig.toJSON(message.costManagementConfig);
    }
    if (message.notificationConfig !== undefined) {
      obj.notificationConfig = NotificationConfig.toJSON(message.notificationConfig);
    }
    if (message.confidentialNodes !== undefined) {
      obj.confidentialNodes = ConfidentialNodes.toJSON(message.confidentialNodes);
    }
    if (message.identityServiceConfig !== undefined) {
      obj.identityServiceConfig = IdentityServiceConfig.toJSON(message.identityServiceConfig);
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.initialClusterVersion !== "") {
      obj.initialClusterVersion = message.initialClusterVersion;
    }
    if (message.currentMasterVersion !== "") {
      obj.currentMasterVersion = message.currentMasterVersion;
    }
    if (message.currentNodeVersion !== "") {
      obj.currentNodeVersion = message.currentNodeVersion;
    }
    if (message.createTime !== "") {
      obj.createTime = message.createTime;
    }
    if (message.status !== 0) {
      obj.status = cluster_StatusToJSON(message.status);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.nodeIpv4CidrSize !== 0) {
      obj.nodeIpv4CidrSize = Math.round(message.nodeIpv4CidrSize);
    }
    if (message.servicesIpv4Cidr !== "") {
      obj.servicesIpv4Cidr = message.servicesIpv4Cidr;
    }
    if (message.instanceGroupUrls?.length) {
      obj.instanceGroupUrls = message.instanceGroupUrls;
    }
    if (message.currentNodeCount !== 0) {
      obj.currentNodeCount = Math.round(message.currentNodeCount);
    }
    if (message.expireTime !== "") {
      obj.expireTime = message.expireTime;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.enableTpu !== false) {
      obj.enableTpu = message.enableTpu;
    }
    if (message.tpuIpv4CidrBlock !== "") {
      obj.tpuIpv4CidrBlock = message.tpuIpv4CidrBlock;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => StatusCondition.toJSON(e));
    }
    if (message.autopilot !== undefined) {
      obj.autopilot = Autopilot.toJSON(message.autopilot);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.nodePoolDefaults !== undefined) {
      obj.nodePoolDefaults = NodePoolDefaults.toJSON(message.nodePoolDefaults);
    }
    if (message.loggingConfig !== undefined) {
      obj.loggingConfig = LoggingConfig.toJSON(message.loggingConfig);
    }
    if (message.monitoringConfig !== undefined) {
      obj.monitoringConfig = MonitoringConfig.toJSON(message.monitoringConfig);
    }
    if (message.nodePoolAutoConfig !== undefined) {
      obj.nodePoolAutoConfig = NodePoolAutoConfig.toJSON(message.nodePoolAutoConfig);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.fleet !== undefined) {
      obj.fleet = Fleet.toJSON(message.fleet);
    }
    if (message.securityPostureConfig !== undefined) {
      obj.securityPostureConfig = SecurityPostureConfig.toJSON(message.securityPostureConfig);
    }
    if (message.enableK8sBetaApis !== undefined) {
      obj.enableK8sBetaApis = K8sBetaAPIConfig.toJSON(message.enableK8sBetaApis);
    }
    if (message.enterpriseConfig !== undefined) {
      obj.enterpriseConfig = EnterpriseConfig.toJSON(message.enterpriseConfig);
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== undefined) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster>): Cluster {
    return Cluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster>): Cluster {
    const message = createBaseCluster();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.initialNodeCount = object.initialNodeCount ?? 0;
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.masterAuth = (object.masterAuth !== undefined && object.masterAuth !== null)
      ? MasterAuth.fromPartial(object.masterAuth)
      : undefined;
    message.loggingService = object.loggingService ?? "";
    message.monitoringService = object.monitoringService ?? "";
    message.network = object.network ?? "";
    message.clusterIpv4Cidr = object.clusterIpv4Cidr ?? "";
    message.addonsConfig = (object.addonsConfig !== undefined && object.addonsConfig !== null)
      ? AddonsConfig.fromPartial(object.addonsConfig)
      : undefined;
    message.subnetwork = object.subnetwork ?? "";
    message.nodePools = object.nodePools?.map((e) => NodePool.fromPartial(e)) || [];
    message.locations = object.locations?.map((e) => e) || [];
    message.enableKubernetesAlpha = object.enableKubernetesAlpha ?? false;
    message.resourceLabels = Object.entries(object.resourceLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labelFingerprint = object.labelFingerprint ?? "";
    message.legacyAbac = (object.legacyAbac !== undefined && object.legacyAbac !== null)
      ? LegacyAbac.fromPartial(object.legacyAbac)
      : undefined;
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.ipAllocationPolicy = (object.ipAllocationPolicy !== undefined && object.ipAllocationPolicy !== null)
      ? IPAllocationPolicy.fromPartial(object.ipAllocationPolicy)
      : undefined;
    message.masterAuthorizedNetworksConfig =
      (object.masterAuthorizedNetworksConfig !== undefined && object.masterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.masterAuthorizedNetworksConfig)
        : undefined;
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.binaryAuthorization = (object.binaryAuthorization !== undefined && object.binaryAuthorization !== null)
      ? BinaryAuthorization.fromPartial(object.binaryAuthorization)
      : undefined;
    message.autoscaling = (object.autoscaling !== undefined && object.autoscaling !== null)
      ? ClusterAutoscaling.fromPartial(object.autoscaling)
      : undefined;
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? NetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.defaultMaxPodsConstraint =
      (object.defaultMaxPodsConstraint !== undefined && object.defaultMaxPodsConstraint !== null)
        ? MaxPodsConstraint.fromPartial(object.defaultMaxPodsConstraint)
        : undefined;
    message.resourceUsageExportConfig =
      (object.resourceUsageExportConfig !== undefined && object.resourceUsageExportConfig !== null)
        ? ResourceUsageExportConfig.fromPartial(object.resourceUsageExportConfig)
        : undefined;
    message.authenticatorGroupsConfig =
      (object.authenticatorGroupsConfig !== undefined && object.authenticatorGroupsConfig !== null)
        ? AuthenticatorGroupsConfig.fromPartial(object.authenticatorGroupsConfig)
        : undefined;
    message.privateClusterConfig = (object.privateClusterConfig !== undefined && object.privateClusterConfig !== null)
      ? PrivateClusterConfig.fromPartial(object.privateClusterConfig)
      : undefined;
    message.databaseEncryption = (object.databaseEncryption !== undefined && object.databaseEncryption !== null)
      ? DatabaseEncryption.fromPartial(object.databaseEncryption)
      : undefined;
    message.verticalPodAutoscaling =
      (object.verticalPodAutoscaling !== undefined && object.verticalPodAutoscaling !== null)
        ? VerticalPodAutoscaling.fromPartial(object.verticalPodAutoscaling)
        : undefined;
    message.shieldedNodes = (object.shieldedNodes !== undefined && object.shieldedNodes !== null)
      ? ShieldedNodes.fromPartial(object.shieldedNodes)
      : undefined;
    message.releaseChannel = (object.releaseChannel !== undefined && object.releaseChannel !== null)
      ? ReleaseChannel.fromPartial(object.releaseChannel)
      : undefined;
    message.workloadIdentityConfig =
      (object.workloadIdentityConfig !== undefined && object.workloadIdentityConfig !== null)
        ? WorkloadIdentityConfig.fromPartial(object.workloadIdentityConfig)
        : undefined;
    message.meshCertificates = (object.meshCertificates !== undefined && object.meshCertificates !== null)
      ? MeshCertificates.fromPartial(object.meshCertificates)
      : undefined;
    message.costManagementConfig = (object.costManagementConfig !== undefined && object.costManagementConfig !== null)
      ? CostManagementConfig.fromPartial(object.costManagementConfig)
      : undefined;
    message.notificationConfig = (object.notificationConfig !== undefined && object.notificationConfig !== null)
      ? NotificationConfig.fromPartial(object.notificationConfig)
      : undefined;
    message.confidentialNodes = (object.confidentialNodes !== undefined && object.confidentialNodes !== null)
      ? ConfidentialNodes.fromPartial(object.confidentialNodes)
      : undefined;
    message.identityServiceConfig =
      (object.identityServiceConfig !== undefined && object.identityServiceConfig !== null)
        ? IdentityServiceConfig.fromPartial(object.identityServiceConfig)
        : undefined;
    message.selfLink = object.selfLink ?? "";
    message.zone = object.zone ?? "";
    message.endpoint = object.endpoint ?? "";
    message.initialClusterVersion = object.initialClusterVersion ?? "";
    message.currentMasterVersion = object.currentMasterVersion ?? "";
    message.currentNodeVersion = object.currentNodeVersion ?? "";
    message.createTime = object.createTime ?? "";
    message.status = object.status ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.nodeIpv4CidrSize = object.nodeIpv4CidrSize ?? 0;
    message.servicesIpv4Cidr = object.servicesIpv4Cidr ?? "";
    message.instanceGroupUrls = object.instanceGroupUrls?.map((e) => e) || [];
    message.currentNodeCount = object.currentNodeCount ?? 0;
    message.expireTime = object.expireTime ?? "";
    message.location = object.location ?? "";
    message.enableTpu = object.enableTpu ?? false;
    message.tpuIpv4CidrBlock = object.tpuIpv4CidrBlock ?? "";
    message.conditions = object.conditions?.map((e) => StatusCondition.fromPartial(e)) || [];
    message.autopilot = (object.autopilot !== undefined && object.autopilot !== null)
      ? Autopilot.fromPartial(object.autopilot)
      : undefined;
    message.id = object.id ?? "";
    message.nodePoolDefaults = (object.nodePoolDefaults !== undefined && object.nodePoolDefaults !== null)
      ? NodePoolDefaults.fromPartial(object.nodePoolDefaults)
      : undefined;
    message.loggingConfig = (object.loggingConfig !== undefined && object.loggingConfig !== null)
      ? LoggingConfig.fromPartial(object.loggingConfig)
      : undefined;
    message.monitoringConfig = (object.monitoringConfig !== undefined && object.monitoringConfig !== null)
      ? MonitoringConfig.fromPartial(object.monitoringConfig)
      : undefined;
    message.nodePoolAutoConfig = (object.nodePoolAutoConfig !== undefined && object.nodePoolAutoConfig !== null)
      ? NodePoolAutoConfig.fromPartial(object.nodePoolAutoConfig)
      : undefined;
    message.etag = object.etag ?? "";
    message.fleet = (object.fleet !== undefined && object.fleet !== null) ? Fleet.fromPartial(object.fleet) : undefined;
    message.securityPostureConfig =
      (object.securityPostureConfig !== undefined && object.securityPostureConfig !== null)
        ? SecurityPostureConfig.fromPartial(object.securityPostureConfig)
        : undefined;
    message.enableK8sBetaApis = (object.enableK8sBetaApis !== undefined && object.enableK8sBetaApis !== null)
      ? K8sBetaAPIConfig.fromPartial(object.enableK8sBetaApis)
      : undefined;
    message.enterpriseConfig = (object.enterpriseConfig !== undefined && object.enterpriseConfig !== null)
      ? EnterpriseConfig.fromPartial(object.enterpriseConfig)
      : undefined;
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? undefined;
    return message;
  },
};

function createBaseCluster_ResourceLabelsEntry(): Cluster_ResourceLabelsEntry {
  return { key: "", value: "" };
}

export const Cluster_ResourceLabelsEntry: MessageFns<Cluster_ResourceLabelsEntry> = {
  encode(message: Cluster_ResourceLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_ResourceLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_ResourceLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_ResourceLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Cluster_ResourceLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_ResourceLabelsEntry>): Cluster_ResourceLabelsEntry {
    return Cluster_ResourceLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_ResourceLabelsEntry>): Cluster_ResourceLabelsEntry {
    const message = createBaseCluster_ResourceLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseK8sBetaAPIConfig(): K8sBetaAPIConfig {
  return { enabledApis: [] };
}

export const K8sBetaAPIConfig: MessageFns<K8sBetaAPIConfig> = {
  encode(message: K8sBetaAPIConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.enabledApis) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): K8sBetaAPIConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseK8sBetaAPIConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.enabledApis.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): K8sBetaAPIConfig {
    return {
      enabledApis: globalThis.Array.isArray(object?.enabledApis)
        ? object.enabledApis.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: K8sBetaAPIConfig): unknown {
    const obj: any = {};
    if (message.enabledApis?.length) {
      obj.enabledApis = message.enabledApis;
    }
    return obj;
  },

  create(base?: DeepPartial<K8sBetaAPIConfig>): K8sBetaAPIConfig {
    return K8sBetaAPIConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<K8sBetaAPIConfig>): K8sBetaAPIConfig {
    const message = createBaseK8sBetaAPIConfig();
    message.enabledApis = object.enabledApis?.map((e) => e) || [];
    return message;
  },
};

function createBaseSecurityPostureConfig(): SecurityPostureConfig {
  return { mode: undefined, vulnerabilityMode: undefined };
}

export const SecurityPostureConfig: MessageFns<SecurityPostureConfig> = {
  encode(message: SecurityPostureConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== undefined) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.vulnerabilityMode !== undefined) {
      writer.uint32(16).int32(message.vulnerabilityMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityPostureConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityPostureConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vulnerabilityMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityPostureConfig {
    return {
      mode: isSet(object.mode) ? securityPostureConfig_ModeFromJSON(object.mode) : undefined,
      vulnerabilityMode: isSet(object.vulnerabilityMode)
        ? securityPostureConfig_VulnerabilityModeFromJSON(object.vulnerabilityMode)
        : undefined,
    };
  },

  toJSON(message: SecurityPostureConfig): unknown {
    const obj: any = {};
    if (message.mode !== undefined) {
      obj.mode = securityPostureConfig_ModeToJSON(message.mode);
    }
    if (message.vulnerabilityMode !== undefined) {
      obj.vulnerabilityMode = securityPostureConfig_VulnerabilityModeToJSON(message.vulnerabilityMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SecurityPostureConfig>): SecurityPostureConfig {
    return SecurityPostureConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecurityPostureConfig>): SecurityPostureConfig {
    const message = createBaseSecurityPostureConfig();
    message.mode = object.mode ?? undefined;
    message.vulnerabilityMode = object.vulnerabilityMode ?? undefined;
    return message;
  },
};

function createBaseNodePoolAutoConfig(): NodePoolAutoConfig {
  return { networkTags: undefined, resourceManagerTags: undefined, nodeKubeletConfig: undefined };
}

export const NodePoolAutoConfig: MessageFns<NodePoolAutoConfig> = {
  encode(message: NodePoolAutoConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkTags !== undefined) {
      NetworkTags.encode(message.networkTags, writer.uint32(10).fork()).join();
    }
    if (message.resourceManagerTags !== undefined) {
      ResourceManagerTags.encode(message.resourceManagerTags, writer.uint32(18).fork()).join();
    }
    if (message.nodeKubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.nodeKubeletConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePoolAutoConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePoolAutoConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkTags = NetworkTags.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceManagerTags = ResourceManagerTags.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodeKubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePoolAutoConfig {
    return {
      networkTags: isSet(object.networkTags) ? NetworkTags.fromJSON(object.networkTags) : undefined,
      resourceManagerTags: isSet(object.resourceManagerTags)
        ? ResourceManagerTags.fromJSON(object.resourceManagerTags)
        : undefined,
      nodeKubeletConfig: isSet(object.nodeKubeletConfig)
        ? NodeKubeletConfig.fromJSON(object.nodeKubeletConfig)
        : undefined,
    };
  },

  toJSON(message: NodePoolAutoConfig): unknown {
    const obj: any = {};
    if (message.networkTags !== undefined) {
      obj.networkTags = NetworkTags.toJSON(message.networkTags);
    }
    if (message.resourceManagerTags !== undefined) {
      obj.resourceManagerTags = ResourceManagerTags.toJSON(message.resourceManagerTags);
    }
    if (message.nodeKubeletConfig !== undefined) {
      obj.nodeKubeletConfig = NodeKubeletConfig.toJSON(message.nodeKubeletConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePoolAutoConfig>): NodePoolAutoConfig {
    return NodePoolAutoConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePoolAutoConfig>): NodePoolAutoConfig {
    const message = createBaseNodePoolAutoConfig();
    message.networkTags = (object.networkTags !== undefined && object.networkTags !== null)
      ? NetworkTags.fromPartial(object.networkTags)
      : undefined;
    message.resourceManagerTags = (object.resourceManagerTags !== undefined && object.resourceManagerTags !== null)
      ? ResourceManagerTags.fromPartial(object.resourceManagerTags)
      : undefined;
    message.nodeKubeletConfig = (object.nodeKubeletConfig !== undefined && object.nodeKubeletConfig !== null)
      ? NodeKubeletConfig.fromPartial(object.nodeKubeletConfig)
      : undefined;
    return message;
  },
};

function createBaseNodePoolDefaults(): NodePoolDefaults {
  return { nodeConfigDefaults: undefined };
}

export const NodePoolDefaults: MessageFns<NodePoolDefaults> = {
  encode(message: NodePoolDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeConfigDefaults !== undefined) {
      NodeConfigDefaults.encode(message.nodeConfigDefaults, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePoolDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePoolDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeConfigDefaults = NodeConfigDefaults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePoolDefaults {
    return {
      nodeConfigDefaults: isSet(object.nodeConfigDefaults)
        ? NodeConfigDefaults.fromJSON(object.nodeConfigDefaults)
        : undefined,
    };
  },

  toJSON(message: NodePoolDefaults): unknown {
    const obj: any = {};
    if (message.nodeConfigDefaults !== undefined) {
      obj.nodeConfigDefaults = NodeConfigDefaults.toJSON(message.nodeConfigDefaults);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePoolDefaults>): NodePoolDefaults {
    return NodePoolDefaults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePoolDefaults>): NodePoolDefaults {
    const message = createBaseNodePoolDefaults();
    message.nodeConfigDefaults = (object.nodeConfigDefaults !== undefined && object.nodeConfigDefaults !== null)
      ? NodeConfigDefaults.fromPartial(object.nodeConfigDefaults)
      : undefined;
    return message;
  },
};

function createBaseNodeConfigDefaults(): NodeConfigDefaults {
  return { gcfsConfig: undefined, loggingConfig: undefined, containerdConfig: undefined, nodeKubeletConfig: undefined };
}

export const NodeConfigDefaults: MessageFns<NodeConfigDefaults> = {
  encode(message: NodeConfigDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcfsConfig !== undefined) {
      GcfsConfig.encode(message.gcfsConfig, writer.uint32(10).fork()).join();
    }
    if (message.loggingConfig !== undefined) {
      NodePoolLoggingConfig.encode(message.loggingConfig, writer.uint32(26).fork()).join();
    }
    if (message.containerdConfig !== undefined) {
      ContainerdConfig.encode(message.containerdConfig, writer.uint32(34).fork()).join();
    }
    if (message.nodeKubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.nodeKubeletConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfigDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfigDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcfsConfig = GcfsConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.loggingConfig = NodePoolLoggingConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.containerdConfig = ContainerdConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nodeKubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfigDefaults {
    return {
      gcfsConfig: isSet(object.gcfsConfig) ? GcfsConfig.fromJSON(object.gcfsConfig) : undefined,
      loggingConfig: isSet(object.loggingConfig) ? NodePoolLoggingConfig.fromJSON(object.loggingConfig) : undefined,
      containerdConfig: isSet(object.containerdConfig) ? ContainerdConfig.fromJSON(object.containerdConfig) : undefined,
      nodeKubeletConfig: isSet(object.nodeKubeletConfig)
        ? NodeKubeletConfig.fromJSON(object.nodeKubeletConfig)
        : undefined,
    };
  },

  toJSON(message: NodeConfigDefaults): unknown {
    const obj: any = {};
    if (message.gcfsConfig !== undefined) {
      obj.gcfsConfig = GcfsConfig.toJSON(message.gcfsConfig);
    }
    if (message.loggingConfig !== undefined) {
      obj.loggingConfig = NodePoolLoggingConfig.toJSON(message.loggingConfig);
    }
    if (message.containerdConfig !== undefined) {
      obj.containerdConfig = ContainerdConfig.toJSON(message.containerdConfig);
    }
    if (message.nodeKubeletConfig !== undefined) {
      obj.nodeKubeletConfig = NodeKubeletConfig.toJSON(message.nodeKubeletConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfigDefaults>): NodeConfigDefaults {
    return NodeConfigDefaults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfigDefaults>): NodeConfigDefaults {
    const message = createBaseNodeConfigDefaults();
    message.gcfsConfig = (object.gcfsConfig !== undefined && object.gcfsConfig !== null)
      ? GcfsConfig.fromPartial(object.gcfsConfig)
      : undefined;
    message.loggingConfig = (object.loggingConfig !== undefined && object.loggingConfig !== null)
      ? NodePoolLoggingConfig.fromPartial(object.loggingConfig)
      : undefined;
    message.containerdConfig = (object.containerdConfig !== undefined && object.containerdConfig !== null)
      ? ContainerdConfig.fromPartial(object.containerdConfig)
      : undefined;
    message.nodeKubeletConfig = (object.nodeKubeletConfig !== undefined && object.nodeKubeletConfig !== null)
      ? NodeKubeletConfig.fromPartial(object.nodeKubeletConfig)
      : undefined;
    return message;
  },
};

function createBaseClusterUpdate(): ClusterUpdate {
  return {
    desiredNodeVersion: "",
    desiredMonitoringService: "",
    desiredAddonsConfig: undefined,
    desiredNodePoolId: "",
    desiredImageType: "",
    desiredDatabaseEncryption: undefined,
    desiredWorkloadIdentityConfig: undefined,
    desiredMeshCertificates: undefined,
    desiredShieldedNodes: undefined,
    desiredCostManagementConfig: undefined,
    desiredDnsConfig: undefined,
    desiredNodePoolAutoscaling: undefined,
    desiredLocations: [],
    desiredMasterAuthorizedNetworksConfig: undefined,
    desiredClusterAutoscaling: undefined,
    desiredBinaryAuthorization: undefined,
    desiredLoggingService: "",
    desiredResourceUsageExportConfig: undefined,
    desiredVerticalPodAutoscaling: undefined,
    desiredPrivateClusterConfig: undefined,
    desiredIntraNodeVisibilityConfig: undefined,
    desiredDefaultSnatStatus: undefined,
    desiredReleaseChannel: undefined,
    desiredL4ilbSubsettingConfig: undefined,
    desiredDatapathProvider: 0,
    desiredPrivateIpv6GoogleAccess: 0,
    desiredNotificationConfig: undefined,
    desiredAuthenticatorGroupsConfig: undefined,
    desiredLoggingConfig: undefined,
    desiredMonitoringConfig: undefined,
    desiredIdentityServiceConfig: undefined,
    desiredServiceExternalIpsConfig: undefined,
    desiredEnablePrivateEndpoint: undefined,
    desiredMasterVersion: "",
    desiredGcfsConfig: undefined,
    desiredNodePoolAutoConfigNetworkTags: undefined,
    desiredGatewayApiConfig: undefined,
    etag: "",
    desiredNodePoolLoggingConfig: undefined,
    desiredFleet: undefined,
    desiredStackType: 0,
    additionalPodRangesConfig: undefined,
    removedAdditionalPodRangesConfig: undefined,
    enableK8sBetaApis: undefined,
    desiredSecurityPostureConfig: undefined,
    desiredNetworkPerformanceConfig: undefined,
    desiredEnableFqdnNetworkPolicy: undefined,
    desiredAutopilotWorkloadPolicyConfig: undefined,
    desiredK8sBetaApis: undefined,
    desiredContainerdConfig: undefined,
    desiredEnableMultiNetworking: undefined,
    desiredNodePoolAutoConfigResourceManagerTags: undefined,
    desiredInTransitEncryptionConfig: undefined,
    desiredEnableCiliumClusterwideNetworkPolicy: undefined,
    desiredNodeKubeletConfig: undefined,
    desiredNodePoolAutoConfigKubeletConfig: undefined,
  };
}

export const ClusterUpdate: MessageFns<ClusterUpdate> = {
  encode(message: ClusterUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.desiredNodeVersion !== "") {
      writer.uint32(34).string(message.desiredNodeVersion);
    }
    if (message.desiredMonitoringService !== "") {
      writer.uint32(42).string(message.desiredMonitoringService);
    }
    if (message.desiredAddonsConfig !== undefined) {
      AddonsConfig.encode(message.desiredAddonsConfig, writer.uint32(50).fork()).join();
    }
    if (message.desiredNodePoolId !== "") {
      writer.uint32(58).string(message.desiredNodePoolId);
    }
    if (message.desiredImageType !== "") {
      writer.uint32(66).string(message.desiredImageType);
    }
    if (message.desiredDatabaseEncryption !== undefined) {
      DatabaseEncryption.encode(message.desiredDatabaseEncryption, writer.uint32(370).fork()).join();
    }
    if (message.desiredWorkloadIdentityConfig !== undefined) {
      WorkloadIdentityConfig.encode(message.desiredWorkloadIdentityConfig, writer.uint32(378).fork()).join();
    }
    if (message.desiredMeshCertificates !== undefined) {
      MeshCertificates.encode(message.desiredMeshCertificates, writer.uint32(538).fork()).join();
    }
    if (message.desiredShieldedNodes !== undefined) {
      ShieldedNodes.encode(message.desiredShieldedNodes, writer.uint32(386).fork()).join();
    }
    if (message.desiredCostManagementConfig !== undefined) {
      CostManagementConfig.encode(message.desiredCostManagementConfig, writer.uint32(394).fork()).join();
    }
    if (message.desiredDnsConfig !== undefined) {
      DNSConfig.encode(message.desiredDnsConfig, writer.uint32(426).fork()).join();
    }
    if (message.desiredNodePoolAutoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.desiredNodePoolAutoscaling, writer.uint32(74).fork()).join();
    }
    for (const v of message.desiredLocations) {
      writer.uint32(82).string(v!);
    }
    if (message.desiredMasterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.desiredMasterAuthorizedNetworksConfig, writer.uint32(98).fork())
        .join();
    }
    if (message.desiredClusterAutoscaling !== undefined) {
      ClusterAutoscaling.encode(message.desiredClusterAutoscaling, writer.uint32(122).fork()).join();
    }
    if (message.desiredBinaryAuthorization !== undefined) {
      BinaryAuthorization.encode(message.desiredBinaryAuthorization, writer.uint32(130).fork()).join();
    }
    if (message.desiredLoggingService !== "") {
      writer.uint32(154).string(message.desiredLoggingService);
    }
    if (message.desiredResourceUsageExportConfig !== undefined) {
      ResourceUsageExportConfig.encode(message.desiredResourceUsageExportConfig, writer.uint32(170).fork()).join();
    }
    if (message.desiredVerticalPodAutoscaling !== undefined) {
      VerticalPodAutoscaling.encode(message.desiredVerticalPodAutoscaling, writer.uint32(178).fork()).join();
    }
    if (message.desiredPrivateClusterConfig !== undefined) {
      PrivateClusterConfig.encode(message.desiredPrivateClusterConfig, writer.uint32(202).fork()).join();
    }
    if (message.desiredIntraNodeVisibilityConfig !== undefined) {
      IntraNodeVisibilityConfig.encode(message.desiredIntraNodeVisibilityConfig, writer.uint32(210).fork()).join();
    }
    if (message.desiredDefaultSnatStatus !== undefined) {
      DefaultSnatStatus.encode(message.desiredDefaultSnatStatus, writer.uint32(226).fork()).join();
    }
    if (message.desiredReleaseChannel !== undefined) {
      ReleaseChannel.encode(message.desiredReleaseChannel, writer.uint32(250).fork()).join();
    }
    if (message.desiredL4ilbSubsettingConfig !== undefined) {
      ILBSubsettingConfig.encode(message.desiredL4ilbSubsettingConfig, writer.uint32(314).fork()).join();
    }
    if (message.desiredDatapathProvider !== 0) {
      writer.uint32(400).int32(message.desiredDatapathProvider);
    }
    if (message.desiredPrivateIpv6GoogleAccess !== 0) {
      writer.uint32(408).int32(message.desiredPrivateIpv6GoogleAccess);
    }
    if (message.desiredNotificationConfig !== undefined) {
      NotificationConfig.encode(message.desiredNotificationConfig, writer.uint32(442).fork()).join();
    }
    if (message.desiredAuthenticatorGroupsConfig !== undefined) {
      AuthenticatorGroupsConfig.encode(message.desiredAuthenticatorGroupsConfig, writer.uint32(506).fork()).join();
    }
    if (message.desiredLoggingConfig !== undefined) {
      LoggingConfig.encode(message.desiredLoggingConfig, writer.uint32(514).fork()).join();
    }
    if (message.desiredMonitoringConfig !== undefined) {
      MonitoringConfig.encode(message.desiredMonitoringConfig, writer.uint32(522).fork()).join();
    }
    if (message.desiredIdentityServiceConfig !== undefined) {
      IdentityServiceConfig.encode(message.desiredIdentityServiceConfig, writer.uint32(530).fork()).join();
    }
    if (message.desiredServiceExternalIpsConfig !== undefined) {
      ServiceExternalIPsConfig.encode(message.desiredServiceExternalIpsConfig, writer.uint32(482).fork()).join();
    }
    if (message.desiredEnablePrivateEndpoint !== undefined) {
      writer.uint32(568).bool(message.desiredEnablePrivateEndpoint);
    }
    if (message.desiredMasterVersion !== "") {
      writer.uint32(802).string(message.desiredMasterVersion);
    }
    if (message.desiredGcfsConfig !== undefined) {
      GcfsConfig.encode(message.desiredGcfsConfig, writer.uint32(874).fork()).join();
    }
    if (message.desiredNodePoolAutoConfigNetworkTags !== undefined) {
      NetworkTags.encode(message.desiredNodePoolAutoConfigNetworkTags, writer.uint32(882).fork()).join();
    }
    if (message.desiredGatewayApiConfig !== undefined) {
      GatewayAPIConfig.encode(message.desiredGatewayApiConfig, writer.uint32(914).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(922).string(message.etag);
    }
    if (message.desiredNodePoolLoggingConfig !== undefined) {
      NodePoolLoggingConfig.encode(message.desiredNodePoolLoggingConfig, writer.uint32(930).fork()).join();
    }
    if (message.desiredFleet !== undefined) {
      Fleet.encode(message.desiredFleet, writer.uint32(938).fork()).join();
    }
    if (message.desiredStackType !== 0) {
      writer.uint32(952).int32(message.desiredStackType);
    }
    if (message.additionalPodRangesConfig !== undefined) {
      AdditionalPodRangesConfig.encode(message.additionalPodRangesConfig, writer.uint32(962).fork()).join();
    }
    if (message.removedAdditionalPodRangesConfig !== undefined) {
      AdditionalPodRangesConfig.encode(message.removedAdditionalPodRangesConfig, writer.uint32(970).fork()).join();
    }
    if (message.enableK8sBetaApis !== undefined) {
      K8sBetaAPIConfig.encode(message.enableK8sBetaApis, writer.uint32(978).fork()).join();
    }
    if (message.desiredSecurityPostureConfig !== undefined) {
      SecurityPostureConfig.encode(message.desiredSecurityPostureConfig, writer.uint32(994).fork()).join();
    }
    if (message.desiredNetworkPerformanceConfig !== undefined) {
      NetworkConfig_ClusterNetworkPerformanceConfig.encode(
        message.desiredNetworkPerformanceConfig,
        writer.uint32(1002).fork(),
      ).join();
    }
    if (message.desiredEnableFqdnNetworkPolicy !== undefined) {
      writer.uint32(1008).bool(message.desiredEnableFqdnNetworkPolicy);
    }
    if (message.desiredAutopilotWorkloadPolicyConfig !== undefined) {
      WorkloadPolicyConfig.encode(message.desiredAutopilotWorkloadPolicyConfig, writer.uint32(1026).fork()).join();
    }
    if (message.desiredK8sBetaApis !== undefined) {
      K8sBetaAPIConfig.encode(message.desiredK8sBetaApis, writer.uint32(1050).fork()).join();
    }
    if (message.desiredContainerdConfig !== undefined) {
      ContainerdConfig.encode(message.desiredContainerdConfig, writer.uint32(1074).fork()).join();
    }
    if (message.desiredEnableMultiNetworking !== undefined) {
      writer.uint32(1080).bool(message.desiredEnableMultiNetworking);
    }
    if (message.desiredNodePoolAutoConfigResourceManagerTags !== undefined) {
      ResourceManagerTags.encode(message.desiredNodePoolAutoConfigResourceManagerTags, writer.uint32(1090).fork())
        .join();
    }
    if (message.desiredInTransitEncryptionConfig !== undefined) {
      writer.uint32(1096).int32(message.desiredInTransitEncryptionConfig);
    }
    if (message.desiredEnableCiliumClusterwideNetworkPolicy !== undefined) {
      writer.uint32(1104).bool(message.desiredEnableCiliumClusterwideNetworkPolicy);
    }
    if (message.desiredNodeKubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.desiredNodeKubeletConfig, writer.uint32(1130).fork()).join();
    }
    if (message.desiredNodePoolAutoConfigKubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.desiredNodePoolAutoConfigKubeletConfig, writer.uint32(1138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.desiredNodeVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.desiredMonitoringService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.desiredAddonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.desiredNodePoolId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.desiredImageType = reader.string();
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.desiredDatabaseEncryption = DatabaseEncryption.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.desiredWorkloadIdentityConfig = WorkloadIdentityConfig.decode(reader, reader.uint32());
          continue;
        case 67:
          if (tag !== 538) {
            break;
          }

          message.desiredMeshCertificates = MeshCertificates.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.desiredShieldedNodes = ShieldedNodes.decode(reader, reader.uint32());
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.desiredCostManagementConfig = CostManagementConfig.decode(reader, reader.uint32());
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.desiredDnsConfig = DNSConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.desiredNodePoolAutoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.desiredLocations.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.desiredMasterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.desiredClusterAutoscaling = ClusterAutoscaling.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.desiredBinaryAuthorization = BinaryAuthorization.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.desiredLoggingService = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.desiredResourceUsageExportConfig = ResourceUsageExportConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.desiredVerticalPodAutoscaling = VerticalPodAutoscaling.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.desiredPrivateClusterConfig = PrivateClusterConfig.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.desiredIntraNodeVisibilityConfig = IntraNodeVisibilityConfig.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.desiredDefaultSnatStatus = DefaultSnatStatus.decode(reader, reader.uint32());
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.desiredReleaseChannel = ReleaseChannel.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.desiredL4ilbSubsettingConfig = ILBSubsettingConfig.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 400) {
            break;
          }

          message.desiredDatapathProvider = reader.int32() as any;
          continue;
        case 51:
          if (tag !== 408) {
            break;
          }

          message.desiredPrivateIpv6GoogleAccess = reader.int32() as any;
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.desiredNotificationConfig = NotificationConfig.decode(reader, reader.uint32());
          continue;
        case 63:
          if (tag !== 506) {
            break;
          }

          message.desiredAuthenticatorGroupsConfig = AuthenticatorGroupsConfig.decode(reader, reader.uint32());
          continue;
        case 64:
          if (tag !== 514) {
            break;
          }

          message.desiredLoggingConfig = LoggingConfig.decode(reader, reader.uint32());
          continue;
        case 65:
          if (tag !== 522) {
            break;
          }

          message.desiredMonitoringConfig = MonitoringConfig.decode(reader, reader.uint32());
          continue;
        case 66:
          if (tag !== 530) {
            break;
          }

          message.desiredIdentityServiceConfig = IdentityServiceConfig.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.desiredServiceExternalIpsConfig = ServiceExternalIPsConfig.decode(reader, reader.uint32());
          continue;
        case 71:
          if (tag !== 568) {
            break;
          }

          message.desiredEnablePrivateEndpoint = reader.bool();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.desiredMasterVersion = reader.string();
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }

          message.desiredGcfsConfig = GcfsConfig.decode(reader, reader.uint32());
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.desiredNodePoolAutoConfigNetworkTags = NetworkTags.decode(reader, reader.uint32());
          continue;
        case 114:
          if (tag !== 914) {
            break;
          }

          message.desiredGatewayApiConfig = GatewayAPIConfig.decode(reader, reader.uint32());
          continue;
        case 115:
          if (tag !== 922) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 116:
          if (tag !== 930) {
            break;
          }

          message.desiredNodePoolLoggingConfig = NodePoolLoggingConfig.decode(reader, reader.uint32());
          continue;
        case 117:
          if (tag !== 938) {
            break;
          }

          message.desiredFleet = Fleet.decode(reader, reader.uint32());
          continue;
        case 119:
          if (tag !== 952) {
            break;
          }

          message.desiredStackType = reader.int32() as any;
          continue;
        case 120:
          if (tag !== 962) {
            break;
          }

          message.additionalPodRangesConfig = AdditionalPodRangesConfig.decode(reader, reader.uint32());
          continue;
        case 121:
          if (tag !== 970) {
            break;
          }

          message.removedAdditionalPodRangesConfig = AdditionalPodRangesConfig.decode(reader, reader.uint32());
          continue;
        case 122:
          if (tag !== 978) {
            break;
          }

          message.enableK8sBetaApis = K8sBetaAPIConfig.decode(reader, reader.uint32());
          continue;
        case 124:
          if (tag !== 994) {
            break;
          }

          message.desiredSecurityPostureConfig = SecurityPostureConfig.decode(reader, reader.uint32());
          continue;
        case 125:
          if (tag !== 1002) {
            break;
          }

          message.desiredNetworkPerformanceConfig = NetworkConfig_ClusterNetworkPerformanceConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 126:
          if (tag !== 1008) {
            break;
          }

          message.desiredEnableFqdnNetworkPolicy = reader.bool();
          continue;
        case 128:
          if (tag !== 1026) {
            break;
          }

          message.desiredAutopilotWorkloadPolicyConfig = WorkloadPolicyConfig.decode(reader, reader.uint32());
          continue;
        case 131:
          if (tag !== 1050) {
            break;
          }

          message.desiredK8sBetaApis = K8sBetaAPIConfig.decode(reader, reader.uint32());
          continue;
        case 134:
          if (tag !== 1074) {
            break;
          }

          message.desiredContainerdConfig = ContainerdConfig.decode(reader, reader.uint32());
          continue;
        case 135:
          if (tag !== 1080) {
            break;
          }

          message.desiredEnableMultiNetworking = reader.bool();
          continue;
        case 136:
          if (tag !== 1090) {
            break;
          }

          message.desiredNodePoolAutoConfigResourceManagerTags = ResourceManagerTags.decode(reader, reader.uint32());
          continue;
        case 137:
          if (tag !== 1096) {
            break;
          }

          message.desiredInTransitEncryptionConfig = reader.int32() as any;
          continue;
        case 138:
          if (tag !== 1104) {
            break;
          }

          message.desiredEnableCiliumClusterwideNetworkPolicy = reader.bool();
          continue;
        case 141:
          if (tag !== 1130) {
            break;
          }

          message.desiredNodeKubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
        case 142:
          if (tag !== 1138) {
            break;
          }

          message.desiredNodePoolAutoConfigKubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterUpdate {
    return {
      desiredNodeVersion: isSet(object.desiredNodeVersion) ? globalThis.String(object.desiredNodeVersion) : "",
      desiredMonitoringService: isSet(object.desiredMonitoringService)
        ? globalThis.String(object.desiredMonitoringService)
        : "",
      desiredAddonsConfig: isSet(object.desiredAddonsConfig)
        ? AddonsConfig.fromJSON(object.desiredAddonsConfig)
        : undefined,
      desiredNodePoolId: isSet(object.desiredNodePoolId) ? globalThis.String(object.desiredNodePoolId) : "",
      desiredImageType: isSet(object.desiredImageType) ? globalThis.String(object.desiredImageType) : "",
      desiredDatabaseEncryption: isSet(object.desiredDatabaseEncryption)
        ? DatabaseEncryption.fromJSON(object.desiredDatabaseEncryption)
        : undefined,
      desiredWorkloadIdentityConfig: isSet(object.desiredWorkloadIdentityConfig)
        ? WorkloadIdentityConfig.fromJSON(object.desiredWorkloadIdentityConfig)
        : undefined,
      desiredMeshCertificates: isSet(object.desiredMeshCertificates)
        ? MeshCertificates.fromJSON(object.desiredMeshCertificates)
        : undefined,
      desiredShieldedNodes: isSet(object.desiredShieldedNodes)
        ? ShieldedNodes.fromJSON(object.desiredShieldedNodes)
        : undefined,
      desiredCostManagementConfig: isSet(object.desiredCostManagementConfig)
        ? CostManagementConfig.fromJSON(object.desiredCostManagementConfig)
        : undefined,
      desiredDnsConfig: isSet(object.desiredDnsConfig) ? DNSConfig.fromJSON(object.desiredDnsConfig) : undefined,
      desiredNodePoolAutoscaling: isSet(object.desiredNodePoolAutoscaling)
        ? NodePoolAutoscaling.fromJSON(object.desiredNodePoolAutoscaling)
        : undefined,
      desiredLocations: globalThis.Array.isArray(object?.desiredLocations)
        ? object.desiredLocations.map((e: any) => globalThis.String(e))
        : [],
      desiredMasterAuthorizedNetworksConfig: isSet(object.desiredMasterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.desiredMasterAuthorizedNetworksConfig)
        : undefined,
      desiredClusterAutoscaling: isSet(object.desiredClusterAutoscaling)
        ? ClusterAutoscaling.fromJSON(object.desiredClusterAutoscaling)
        : undefined,
      desiredBinaryAuthorization: isSet(object.desiredBinaryAuthorization)
        ? BinaryAuthorization.fromJSON(object.desiredBinaryAuthorization)
        : undefined,
      desiredLoggingService: isSet(object.desiredLoggingService) ? globalThis.String(object.desiredLoggingService) : "",
      desiredResourceUsageExportConfig: isSet(object.desiredResourceUsageExportConfig)
        ? ResourceUsageExportConfig.fromJSON(object.desiredResourceUsageExportConfig)
        : undefined,
      desiredVerticalPodAutoscaling: isSet(object.desiredVerticalPodAutoscaling)
        ? VerticalPodAutoscaling.fromJSON(object.desiredVerticalPodAutoscaling)
        : undefined,
      desiredPrivateClusterConfig: isSet(object.desiredPrivateClusterConfig)
        ? PrivateClusterConfig.fromJSON(object.desiredPrivateClusterConfig)
        : undefined,
      desiredIntraNodeVisibilityConfig: isSet(object.desiredIntraNodeVisibilityConfig)
        ? IntraNodeVisibilityConfig.fromJSON(object.desiredIntraNodeVisibilityConfig)
        : undefined,
      desiredDefaultSnatStatus: isSet(object.desiredDefaultSnatStatus)
        ? DefaultSnatStatus.fromJSON(object.desiredDefaultSnatStatus)
        : undefined,
      desiredReleaseChannel: isSet(object.desiredReleaseChannel)
        ? ReleaseChannel.fromJSON(object.desiredReleaseChannel)
        : undefined,
      desiredL4ilbSubsettingConfig: isSet(object.desiredL4ilbSubsettingConfig)
        ? ILBSubsettingConfig.fromJSON(object.desiredL4ilbSubsettingConfig)
        : undefined,
      desiredDatapathProvider: isSet(object.desiredDatapathProvider)
        ? datapathProviderFromJSON(object.desiredDatapathProvider)
        : 0,
      desiredPrivateIpv6GoogleAccess: isSet(object.desiredPrivateIpv6GoogleAccess)
        ? privateIPv6GoogleAccessFromJSON(object.desiredPrivateIpv6GoogleAccess)
        : 0,
      desiredNotificationConfig: isSet(object.desiredNotificationConfig)
        ? NotificationConfig.fromJSON(object.desiredNotificationConfig)
        : undefined,
      desiredAuthenticatorGroupsConfig: isSet(object.desiredAuthenticatorGroupsConfig)
        ? AuthenticatorGroupsConfig.fromJSON(object.desiredAuthenticatorGroupsConfig)
        : undefined,
      desiredLoggingConfig: isSet(object.desiredLoggingConfig)
        ? LoggingConfig.fromJSON(object.desiredLoggingConfig)
        : undefined,
      desiredMonitoringConfig: isSet(object.desiredMonitoringConfig)
        ? MonitoringConfig.fromJSON(object.desiredMonitoringConfig)
        : undefined,
      desiredIdentityServiceConfig: isSet(object.desiredIdentityServiceConfig)
        ? IdentityServiceConfig.fromJSON(object.desiredIdentityServiceConfig)
        : undefined,
      desiredServiceExternalIpsConfig: isSet(object.desiredServiceExternalIpsConfig)
        ? ServiceExternalIPsConfig.fromJSON(object.desiredServiceExternalIpsConfig)
        : undefined,
      desiredEnablePrivateEndpoint: isSet(object.desiredEnablePrivateEndpoint)
        ? globalThis.Boolean(object.desiredEnablePrivateEndpoint)
        : undefined,
      desiredMasterVersion: isSet(object.desiredMasterVersion) ? globalThis.String(object.desiredMasterVersion) : "",
      desiredGcfsConfig: isSet(object.desiredGcfsConfig) ? GcfsConfig.fromJSON(object.desiredGcfsConfig) : undefined,
      desiredNodePoolAutoConfigNetworkTags: isSet(object.desiredNodePoolAutoConfigNetworkTags)
        ? NetworkTags.fromJSON(object.desiredNodePoolAutoConfigNetworkTags)
        : undefined,
      desiredGatewayApiConfig: isSet(object.desiredGatewayApiConfig)
        ? GatewayAPIConfig.fromJSON(object.desiredGatewayApiConfig)
        : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      desiredNodePoolLoggingConfig: isSet(object.desiredNodePoolLoggingConfig)
        ? NodePoolLoggingConfig.fromJSON(object.desiredNodePoolLoggingConfig)
        : undefined,
      desiredFleet: isSet(object.desiredFleet) ? Fleet.fromJSON(object.desiredFleet) : undefined,
      desiredStackType: isSet(object.desiredStackType) ? stackTypeFromJSON(object.desiredStackType) : 0,
      additionalPodRangesConfig: isSet(object.additionalPodRangesConfig)
        ? AdditionalPodRangesConfig.fromJSON(object.additionalPodRangesConfig)
        : undefined,
      removedAdditionalPodRangesConfig: isSet(object.removedAdditionalPodRangesConfig)
        ? AdditionalPodRangesConfig.fromJSON(object.removedAdditionalPodRangesConfig)
        : undefined,
      enableK8sBetaApis: isSet(object.enableK8sBetaApis)
        ? K8sBetaAPIConfig.fromJSON(object.enableK8sBetaApis)
        : undefined,
      desiredSecurityPostureConfig: isSet(object.desiredSecurityPostureConfig)
        ? SecurityPostureConfig.fromJSON(object.desiredSecurityPostureConfig)
        : undefined,
      desiredNetworkPerformanceConfig: isSet(object.desiredNetworkPerformanceConfig)
        ? NetworkConfig_ClusterNetworkPerformanceConfig.fromJSON(object.desiredNetworkPerformanceConfig)
        : undefined,
      desiredEnableFqdnNetworkPolicy: isSet(object.desiredEnableFqdnNetworkPolicy)
        ? globalThis.Boolean(object.desiredEnableFqdnNetworkPolicy)
        : undefined,
      desiredAutopilotWorkloadPolicyConfig: isSet(object.desiredAutopilotWorkloadPolicyConfig)
        ? WorkloadPolicyConfig.fromJSON(object.desiredAutopilotWorkloadPolicyConfig)
        : undefined,
      desiredK8sBetaApis: isSet(object.desiredK8sBetaApis)
        ? K8sBetaAPIConfig.fromJSON(object.desiredK8sBetaApis)
        : undefined,
      desiredContainerdConfig: isSet(object.desiredContainerdConfig)
        ? ContainerdConfig.fromJSON(object.desiredContainerdConfig)
        : undefined,
      desiredEnableMultiNetworking: isSet(object.desiredEnableMultiNetworking)
        ? globalThis.Boolean(object.desiredEnableMultiNetworking)
        : undefined,
      desiredNodePoolAutoConfigResourceManagerTags: isSet(object.desiredNodePoolAutoConfigResourceManagerTags)
        ? ResourceManagerTags.fromJSON(object.desiredNodePoolAutoConfigResourceManagerTags)
        : undefined,
      desiredInTransitEncryptionConfig: isSet(object.desiredInTransitEncryptionConfig)
        ? inTransitEncryptionConfigFromJSON(object.desiredInTransitEncryptionConfig)
        : undefined,
      desiredEnableCiliumClusterwideNetworkPolicy: isSet(object.desiredEnableCiliumClusterwideNetworkPolicy)
        ? globalThis.Boolean(object.desiredEnableCiliumClusterwideNetworkPolicy)
        : undefined,
      desiredNodeKubeletConfig: isSet(object.desiredNodeKubeletConfig)
        ? NodeKubeletConfig.fromJSON(object.desiredNodeKubeletConfig)
        : undefined,
      desiredNodePoolAutoConfigKubeletConfig: isSet(object.desiredNodePoolAutoConfigKubeletConfig)
        ? NodeKubeletConfig.fromJSON(object.desiredNodePoolAutoConfigKubeletConfig)
        : undefined,
    };
  },

  toJSON(message: ClusterUpdate): unknown {
    const obj: any = {};
    if (message.desiredNodeVersion !== "") {
      obj.desiredNodeVersion = message.desiredNodeVersion;
    }
    if (message.desiredMonitoringService !== "") {
      obj.desiredMonitoringService = message.desiredMonitoringService;
    }
    if (message.desiredAddonsConfig !== undefined) {
      obj.desiredAddonsConfig = AddonsConfig.toJSON(message.desiredAddonsConfig);
    }
    if (message.desiredNodePoolId !== "") {
      obj.desiredNodePoolId = message.desiredNodePoolId;
    }
    if (message.desiredImageType !== "") {
      obj.desiredImageType = message.desiredImageType;
    }
    if (message.desiredDatabaseEncryption !== undefined) {
      obj.desiredDatabaseEncryption = DatabaseEncryption.toJSON(message.desiredDatabaseEncryption);
    }
    if (message.desiredWorkloadIdentityConfig !== undefined) {
      obj.desiredWorkloadIdentityConfig = WorkloadIdentityConfig.toJSON(message.desiredWorkloadIdentityConfig);
    }
    if (message.desiredMeshCertificates !== undefined) {
      obj.desiredMeshCertificates = MeshCertificates.toJSON(message.desiredMeshCertificates);
    }
    if (message.desiredShieldedNodes !== undefined) {
      obj.desiredShieldedNodes = ShieldedNodes.toJSON(message.desiredShieldedNodes);
    }
    if (message.desiredCostManagementConfig !== undefined) {
      obj.desiredCostManagementConfig = CostManagementConfig.toJSON(message.desiredCostManagementConfig);
    }
    if (message.desiredDnsConfig !== undefined) {
      obj.desiredDnsConfig = DNSConfig.toJSON(message.desiredDnsConfig);
    }
    if (message.desiredNodePoolAutoscaling !== undefined) {
      obj.desiredNodePoolAutoscaling = NodePoolAutoscaling.toJSON(message.desiredNodePoolAutoscaling);
    }
    if (message.desiredLocations?.length) {
      obj.desiredLocations = message.desiredLocations;
    }
    if (message.desiredMasterAuthorizedNetworksConfig !== undefined) {
      obj.desiredMasterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.desiredMasterAuthorizedNetworksConfig,
      );
    }
    if (message.desiredClusterAutoscaling !== undefined) {
      obj.desiredClusterAutoscaling = ClusterAutoscaling.toJSON(message.desiredClusterAutoscaling);
    }
    if (message.desiredBinaryAuthorization !== undefined) {
      obj.desiredBinaryAuthorization = BinaryAuthorization.toJSON(message.desiredBinaryAuthorization);
    }
    if (message.desiredLoggingService !== "") {
      obj.desiredLoggingService = message.desiredLoggingService;
    }
    if (message.desiredResourceUsageExportConfig !== undefined) {
      obj.desiredResourceUsageExportConfig = ResourceUsageExportConfig.toJSON(message.desiredResourceUsageExportConfig);
    }
    if (message.desiredVerticalPodAutoscaling !== undefined) {
      obj.desiredVerticalPodAutoscaling = VerticalPodAutoscaling.toJSON(message.desiredVerticalPodAutoscaling);
    }
    if (message.desiredPrivateClusterConfig !== undefined) {
      obj.desiredPrivateClusterConfig = PrivateClusterConfig.toJSON(message.desiredPrivateClusterConfig);
    }
    if (message.desiredIntraNodeVisibilityConfig !== undefined) {
      obj.desiredIntraNodeVisibilityConfig = IntraNodeVisibilityConfig.toJSON(message.desiredIntraNodeVisibilityConfig);
    }
    if (message.desiredDefaultSnatStatus !== undefined) {
      obj.desiredDefaultSnatStatus = DefaultSnatStatus.toJSON(message.desiredDefaultSnatStatus);
    }
    if (message.desiredReleaseChannel !== undefined) {
      obj.desiredReleaseChannel = ReleaseChannel.toJSON(message.desiredReleaseChannel);
    }
    if (message.desiredL4ilbSubsettingConfig !== undefined) {
      obj.desiredL4ilbSubsettingConfig = ILBSubsettingConfig.toJSON(message.desiredL4ilbSubsettingConfig);
    }
    if (message.desiredDatapathProvider !== 0) {
      obj.desiredDatapathProvider = datapathProviderToJSON(message.desiredDatapathProvider);
    }
    if (message.desiredPrivateIpv6GoogleAccess !== 0) {
      obj.desiredPrivateIpv6GoogleAccess = privateIPv6GoogleAccessToJSON(message.desiredPrivateIpv6GoogleAccess);
    }
    if (message.desiredNotificationConfig !== undefined) {
      obj.desiredNotificationConfig = NotificationConfig.toJSON(message.desiredNotificationConfig);
    }
    if (message.desiredAuthenticatorGroupsConfig !== undefined) {
      obj.desiredAuthenticatorGroupsConfig = AuthenticatorGroupsConfig.toJSON(message.desiredAuthenticatorGroupsConfig);
    }
    if (message.desiredLoggingConfig !== undefined) {
      obj.desiredLoggingConfig = LoggingConfig.toJSON(message.desiredLoggingConfig);
    }
    if (message.desiredMonitoringConfig !== undefined) {
      obj.desiredMonitoringConfig = MonitoringConfig.toJSON(message.desiredMonitoringConfig);
    }
    if (message.desiredIdentityServiceConfig !== undefined) {
      obj.desiredIdentityServiceConfig = IdentityServiceConfig.toJSON(message.desiredIdentityServiceConfig);
    }
    if (message.desiredServiceExternalIpsConfig !== undefined) {
      obj.desiredServiceExternalIpsConfig = ServiceExternalIPsConfig.toJSON(message.desiredServiceExternalIpsConfig);
    }
    if (message.desiredEnablePrivateEndpoint !== undefined) {
      obj.desiredEnablePrivateEndpoint = message.desiredEnablePrivateEndpoint;
    }
    if (message.desiredMasterVersion !== "") {
      obj.desiredMasterVersion = message.desiredMasterVersion;
    }
    if (message.desiredGcfsConfig !== undefined) {
      obj.desiredGcfsConfig = GcfsConfig.toJSON(message.desiredGcfsConfig);
    }
    if (message.desiredNodePoolAutoConfigNetworkTags !== undefined) {
      obj.desiredNodePoolAutoConfigNetworkTags = NetworkTags.toJSON(message.desiredNodePoolAutoConfigNetworkTags);
    }
    if (message.desiredGatewayApiConfig !== undefined) {
      obj.desiredGatewayApiConfig = GatewayAPIConfig.toJSON(message.desiredGatewayApiConfig);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.desiredNodePoolLoggingConfig !== undefined) {
      obj.desiredNodePoolLoggingConfig = NodePoolLoggingConfig.toJSON(message.desiredNodePoolLoggingConfig);
    }
    if (message.desiredFleet !== undefined) {
      obj.desiredFleet = Fleet.toJSON(message.desiredFleet);
    }
    if (message.desiredStackType !== 0) {
      obj.desiredStackType = stackTypeToJSON(message.desiredStackType);
    }
    if (message.additionalPodRangesConfig !== undefined) {
      obj.additionalPodRangesConfig = AdditionalPodRangesConfig.toJSON(message.additionalPodRangesConfig);
    }
    if (message.removedAdditionalPodRangesConfig !== undefined) {
      obj.removedAdditionalPodRangesConfig = AdditionalPodRangesConfig.toJSON(message.removedAdditionalPodRangesConfig);
    }
    if (message.enableK8sBetaApis !== undefined) {
      obj.enableK8sBetaApis = K8sBetaAPIConfig.toJSON(message.enableK8sBetaApis);
    }
    if (message.desiredSecurityPostureConfig !== undefined) {
      obj.desiredSecurityPostureConfig = SecurityPostureConfig.toJSON(message.desiredSecurityPostureConfig);
    }
    if (message.desiredNetworkPerformanceConfig !== undefined) {
      obj.desiredNetworkPerformanceConfig = NetworkConfig_ClusterNetworkPerformanceConfig.toJSON(
        message.desiredNetworkPerformanceConfig,
      );
    }
    if (message.desiredEnableFqdnNetworkPolicy !== undefined) {
      obj.desiredEnableFqdnNetworkPolicy = message.desiredEnableFqdnNetworkPolicy;
    }
    if (message.desiredAutopilotWorkloadPolicyConfig !== undefined) {
      obj.desiredAutopilotWorkloadPolicyConfig = WorkloadPolicyConfig.toJSON(
        message.desiredAutopilotWorkloadPolicyConfig,
      );
    }
    if (message.desiredK8sBetaApis !== undefined) {
      obj.desiredK8sBetaApis = K8sBetaAPIConfig.toJSON(message.desiredK8sBetaApis);
    }
    if (message.desiredContainerdConfig !== undefined) {
      obj.desiredContainerdConfig = ContainerdConfig.toJSON(message.desiredContainerdConfig);
    }
    if (message.desiredEnableMultiNetworking !== undefined) {
      obj.desiredEnableMultiNetworking = message.desiredEnableMultiNetworking;
    }
    if (message.desiredNodePoolAutoConfigResourceManagerTags !== undefined) {
      obj.desiredNodePoolAutoConfigResourceManagerTags = ResourceManagerTags.toJSON(
        message.desiredNodePoolAutoConfigResourceManagerTags,
      );
    }
    if (message.desiredInTransitEncryptionConfig !== undefined) {
      obj.desiredInTransitEncryptionConfig = inTransitEncryptionConfigToJSON(message.desiredInTransitEncryptionConfig);
    }
    if (message.desiredEnableCiliumClusterwideNetworkPolicy !== undefined) {
      obj.desiredEnableCiliumClusterwideNetworkPolicy = message.desiredEnableCiliumClusterwideNetworkPolicy;
    }
    if (message.desiredNodeKubeletConfig !== undefined) {
      obj.desiredNodeKubeletConfig = NodeKubeletConfig.toJSON(message.desiredNodeKubeletConfig);
    }
    if (message.desiredNodePoolAutoConfigKubeletConfig !== undefined) {
      obj.desiredNodePoolAutoConfigKubeletConfig = NodeKubeletConfig.toJSON(
        message.desiredNodePoolAutoConfigKubeletConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterUpdate>): ClusterUpdate {
    return ClusterUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterUpdate>): ClusterUpdate {
    const message = createBaseClusterUpdate();
    message.desiredNodeVersion = object.desiredNodeVersion ?? "";
    message.desiredMonitoringService = object.desiredMonitoringService ?? "";
    message.desiredAddonsConfig = (object.desiredAddonsConfig !== undefined && object.desiredAddonsConfig !== null)
      ? AddonsConfig.fromPartial(object.desiredAddonsConfig)
      : undefined;
    message.desiredNodePoolId = object.desiredNodePoolId ?? "";
    message.desiredImageType = object.desiredImageType ?? "";
    message.desiredDatabaseEncryption =
      (object.desiredDatabaseEncryption !== undefined && object.desiredDatabaseEncryption !== null)
        ? DatabaseEncryption.fromPartial(object.desiredDatabaseEncryption)
        : undefined;
    message.desiredWorkloadIdentityConfig =
      (object.desiredWorkloadIdentityConfig !== undefined && object.desiredWorkloadIdentityConfig !== null)
        ? WorkloadIdentityConfig.fromPartial(object.desiredWorkloadIdentityConfig)
        : undefined;
    message.desiredMeshCertificates =
      (object.desiredMeshCertificates !== undefined && object.desiredMeshCertificates !== null)
        ? MeshCertificates.fromPartial(object.desiredMeshCertificates)
        : undefined;
    message.desiredShieldedNodes = (object.desiredShieldedNodes !== undefined && object.desiredShieldedNodes !== null)
      ? ShieldedNodes.fromPartial(object.desiredShieldedNodes)
      : undefined;
    message.desiredCostManagementConfig =
      (object.desiredCostManagementConfig !== undefined && object.desiredCostManagementConfig !== null)
        ? CostManagementConfig.fromPartial(object.desiredCostManagementConfig)
        : undefined;
    message.desiredDnsConfig = (object.desiredDnsConfig !== undefined && object.desiredDnsConfig !== null)
      ? DNSConfig.fromPartial(object.desiredDnsConfig)
      : undefined;
    message.desiredNodePoolAutoscaling =
      (object.desiredNodePoolAutoscaling !== undefined && object.desiredNodePoolAutoscaling !== null)
        ? NodePoolAutoscaling.fromPartial(object.desiredNodePoolAutoscaling)
        : undefined;
    message.desiredLocations = object.desiredLocations?.map((e) => e) || [];
    message.desiredMasterAuthorizedNetworksConfig =
      (object.desiredMasterAuthorizedNetworksConfig !== undefined &&
          object.desiredMasterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.desiredMasterAuthorizedNetworksConfig)
        : undefined;
    message.desiredClusterAutoscaling =
      (object.desiredClusterAutoscaling !== undefined && object.desiredClusterAutoscaling !== null)
        ? ClusterAutoscaling.fromPartial(object.desiredClusterAutoscaling)
        : undefined;
    message.desiredBinaryAuthorization =
      (object.desiredBinaryAuthorization !== undefined && object.desiredBinaryAuthorization !== null)
        ? BinaryAuthorization.fromPartial(object.desiredBinaryAuthorization)
        : undefined;
    message.desiredLoggingService = object.desiredLoggingService ?? "";
    message.desiredResourceUsageExportConfig =
      (object.desiredResourceUsageExportConfig !== undefined && object.desiredResourceUsageExportConfig !== null)
        ? ResourceUsageExportConfig.fromPartial(object.desiredResourceUsageExportConfig)
        : undefined;
    message.desiredVerticalPodAutoscaling =
      (object.desiredVerticalPodAutoscaling !== undefined && object.desiredVerticalPodAutoscaling !== null)
        ? VerticalPodAutoscaling.fromPartial(object.desiredVerticalPodAutoscaling)
        : undefined;
    message.desiredPrivateClusterConfig =
      (object.desiredPrivateClusterConfig !== undefined && object.desiredPrivateClusterConfig !== null)
        ? PrivateClusterConfig.fromPartial(object.desiredPrivateClusterConfig)
        : undefined;
    message.desiredIntraNodeVisibilityConfig =
      (object.desiredIntraNodeVisibilityConfig !== undefined && object.desiredIntraNodeVisibilityConfig !== null)
        ? IntraNodeVisibilityConfig.fromPartial(object.desiredIntraNodeVisibilityConfig)
        : undefined;
    message.desiredDefaultSnatStatus =
      (object.desiredDefaultSnatStatus !== undefined && object.desiredDefaultSnatStatus !== null)
        ? DefaultSnatStatus.fromPartial(object.desiredDefaultSnatStatus)
        : undefined;
    message.desiredReleaseChannel =
      (object.desiredReleaseChannel !== undefined && object.desiredReleaseChannel !== null)
        ? ReleaseChannel.fromPartial(object.desiredReleaseChannel)
        : undefined;
    message.desiredL4ilbSubsettingConfig =
      (object.desiredL4ilbSubsettingConfig !== undefined && object.desiredL4ilbSubsettingConfig !== null)
        ? ILBSubsettingConfig.fromPartial(object.desiredL4ilbSubsettingConfig)
        : undefined;
    message.desiredDatapathProvider = object.desiredDatapathProvider ?? 0;
    message.desiredPrivateIpv6GoogleAccess = object.desiredPrivateIpv6GoogleAccess ?? 0;
    message.desiredNotificationConfig =
      (object.desiredNotificationConfig !== undefined && object.desiredNotificationConfig !== null)
        ? NotificationConfig.fromPartial(object.desiredNotificationConfig)
        : undefined;
    message.desiredAuthenticatorGroupsConfig =
      (object.desiredAuthenticatorGroupsConfig !== undefined && object.desiredAuthenticatorGroupsConfig !== null)
        ? AuthenticatorGroupsConfig.fromPartial(object.desiredAuthenticatorGroupsConfig)
        : undefined;
    message.desiredLoggingConfig = (object.desiredLoggingConfig !== undefined && object.desiredLoggingConfig !== null)
      ? LoggingConfig.fromPartial(object.desiredLoggingConfig)
      : undefined;
    message.desiredMonitoringConfig =
      (object.desiredMonitoringConfig !== undefined && object.desiredMonitoringConfig !== null)
        ? MonitoringConfig.fromPartial(object.desiredMonitoringConfig)
        : undefined;
    message.desiredIdentityServiceConfig =
      (object.desiredIdentityServiceConfig !== undefined && object.desiredIdentityServiceConfig !== null)
        ? IdentityServiceConfig.fromPartial(object.desiredIdentityServiceConfig)
        : undefined;
    message.desiredServiceExternalIpsConfig =
      (object.desiredServiceExternalIpsConfig !== undefined && object.desiredServiceExternalIpsConfig !== null)
        ? ServiceExternalIPsConfig.fromPartial(object.desiredServiceExternalIpsConfig)
        : undefined;
    message.desiredEnablePrivateEndpoint = object.desiredEnablePrivateEndpoint ?? undefined;
    message.desiredMasterVersion = object.desiredMasterVersion ?? "";
    message.desiredGcfsConfig = (object.desiredGcfsConfig !== undefined && object.desiredGcfsConfig !== null)
      ? GcfsConfig.fromPartial(object.desiredGcfsConfig)
      : undefined;
    message.desiredNodePoolAutoConfigNetworkTags =
      (object.desiredNodePoolAutoConfigNetworkTags !== undefined &&
          object.desiredNodePoolAutoConfigNetworkTags !== null)
        ? NetworkTags.fromPartial(object.desiredNodePoolAutoConfigNetworkTags)
        : undefined;
    message.desiredGatewayApiConfig =
      (object.desiredGatewayApiConfig !== undefined && object.desiredGatewayApiConfig !== null)
        ? GatewayAPIConfig.fromPartial(object.desiredGatewayApiConfig)
        : undefined;
    message.etag = object.etag ?? "";
    message.desiredNodePoolLoggingConfig =
      (object.desiredNodePoolLoggingConfig !== undefined && object.desiredNodePoolLoggingConfig !== null)
        ? NodePoolLoggingConfig.fromPartial(object.desiredNodePoolLoggingConfig)
        : undefined;
    message.desiredFleet = (object.desiredFleet !== undefined && object.desiredFleet !== null)
      ? Fleet.fromPartial(object.desiredFleet)
      : undefined;
    message.desiredStackType = object.desiredStackType ?? 0;
    message.additionalPodRangesConfig =
      (object.additionalPodRangesConfig !== undefined && object.additionalPodRangesConfig !== null)
        ? AdditionalPodRangesConfig.fromPartial(object.additionalPodRangesConfig)
        : undefined;
    message.removedAdditionalPodRangesConfig =
      (object.removedAdditionalPodRangesConfig !== undefined && object.removedAdditionalPodRangesConfig !== null)
        ? AdditionalPodRangesConfig.fromPartial(object.removedAdditionalPodRangesConfig)
        : undefined;
    message.enableK8sBetaApis = (object.enableK8sBetaApis !== undefined && object.enableK8sBetaApis !== null)
      ? K8sBetaAPIConfig.fromPartial(object.enableK8sBetaApis)
      : undefined;
    message.desiredSecurityPostureConfig =
      (object.desiredSecurityPostureConfig !== undefined && object.desiredSecurityPostureConfig !== null)
        ? SecurityPostureConfig.fromPartial(object.desiredSecurityPostureConfig)
        : undefined;
    message.desiredNetworkPerformanceConfig =
      (object.desiredNetworkPerformanceConfig !== undefined && object.desiredNetworkPerformanceConfig !== null)
        ? NetworkConfig_ClusterNetworkPerformanceConfig.fromPartial(object.desiredNetworkPerformanceConfig)
        : undefined;
    message.desiredEnableFqdnNetworkPolicy = object.desiredEnableFqdnNetworkPolicy ?? undefined;
    message.desiredAutopilotWorkloadPolicyConfig =
      (object.desiredAutopilotWorkloadPolicyConfig !== undefined &&
          object.desiredAutopilotWorkloadPolicyConfig !== null)
        ? WorkloadPolicyConfig.fromPartial(object.desiredAutopilotWorkloadPolicyConfig)
        : undefined;
    message.desiredK8sBetaApis = (object.desiredK8sBetaApis !== undefined && object.desiredK8sBetaApis !== null)
      ? K8sBetaAPIConfig.fromPartial(object.desiredK8sBetaApis)
      : undefined;
    message.desiredContainerdConfig =
      (object.desiredContainerdConfig !== undefined && object.desiredContainerdConfig !== null)
        ? ContainerdConfig.fromPartial(object.desiredContainerdConfig)
        : undefined;
    message.desiredEnableMultiNetworking = object.desiredEnableMultiNetworking ?? undefined;
    message.desiredNodePoolAutoConfigResourceManagerTags =
      (object.desiredNodePoolAutoConfigResourceManagerTags !== undefined &&
          object.desiredNodePoolAutoConfigResourceManagerTags !== null)
        ? ResourceManagerTags.fromPartial(object.desiredNodePoolAutoConfigResourceManagerTags)
        : undefined;
    message.desiredInTransitEncryptionConfig = object.desiredInTransitEncryptionConfig ?? undefined;
    message.desiredEnableCiliumClusterwideNetworkPolicy = object.desiredEnableCiliumClusterwideNetworkPolicy ??
      undefined;
    message.desiredNodeKubeletConfig =
      (object.desiredNodeKubeletConfig !== undefined && object.desiredNodeKubeletConfig !== null)
        ? NodeKubeletConfig.fromPartial(object.desiredNodeKubeletConfig)
        : undefined;
    message.desiredNodePoolAutoConfigKubeletConfig =
      (object.desiredNodePoolAutoConfigKubeletConfig !== undefined &&
          object.desiredNodePoolAutoConfigKubeletConfig !== null)
        ? NodeKubeletConfig.fromPartial(object.desiredNodePoolAutoConfigKubeletConfig)
        : undefined;
    return message;
  },
};

function createBaseAdditionalPodRangesConfig(): AdditionalPodRangesConfig {
  return { podRangeNames: [], podRangeInfo: [] };
}

export const AdditionalPodRangesConfig: MessageFns<AdditionalPodRangesConfig> = {
  encode(message: AdditionalPodRangesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.podRangeNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.podRangeInfo) {
      RangeInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdditionalPodRangesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalPodRangesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.podRangeNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.podRangeInfo.push(RangeInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdditionalPodRangesConfig {
    return {
      podRangeNames: globalThis.Array.isArray(object?.podRangeNames)
        ? object.podRangeNames.map((e: any) => globalThis.String(e))
        : [],
      podRangeInfo: globalThis.Array.isArray(object?.podRangeInfo)
        ? object.podRangeInfo.map((e: any) => RangeInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AdditionalPodRangesConfig): unknown {
    const obj: any = {};
    if (message.podRangeNames?.length) {
      obj.podRangeNames = message.podRangeNames;
    }
    if (message.podRangeInfo?.length) {
      obj.podRangeInfo = message.podRangeInfo.map((e) => RangeInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AdditionalPodRangesConfig>): AdditionalPodRangesConfig {
    return AdditionalPodRangesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdditionalPodRangesConfig>): AdditionalPodRangesConfig {
    const message = createBaseAdditionalPodRangesConfig();
    message.podRangeNames = object.podRangeNames?.map((e) => e) || [];
    message.podRangeInfo = object.podRangeInfo?.map((e) => RangeInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRangeInfo(): RangeInfo {
  return { rangeName: "", utilization: 0 };
}

export const RangeInfo: MessageFns<RangeInfo> = {
  encode(message: RangeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rangeName !== "") {
      writer.uint32(10).string(message.rangeName);
    }
    if (message.utilization !== 0) {
      writer.uint32(17).double(message.utilization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RangeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRangeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rangeName = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.utilization = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RangeInfo {
    return {
      rangeName: isSet(object.rangeName) ? globalThis.String(object.rangeName) : "",
      utilization: isSet(object.utilization) ? globalThis.Number(object.utilization) : 0,
    };
  },

  toJSON(message: RangeInfo): unknown {
    const obj: any = {};
    if (message.rangeName !== "") {
      obj.rangeName = message.rangeName;
    }
    if (message.utilization !== 0) {
      obj.utilization = message.utilization;
    }
    return obj;
  },

  create(base?: DeepPartial<RangeInfo>): RangeInfo {
    return RangeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RangeInfo>): RangeInfo {
    const message = createBaseRangeInfo();
    message.rangeName = object.rangeName ?? "";
    message.utilization = object.utilization ?? 0;
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    name: "",
    zone: "",
    operationType: 0,
    status: 0,
    detail: "",
    statusMessage: "",
    selfLink: "",
    targetLink: "",
    location: "",
    startTime: "",
    endTime: "",
    progress: undefined,
    clusterConditions: [],
    nodepoolConditions: [],
    error: undefined,
  };
}

export const Operation: MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationType !== 0) {
      writer.uint32(24).int32(message.operationType);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.detail !== "") {
      writer.uint32(66).string(message.detail);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.selfLink !== "") {
      writer.uint32(50).string(message.selfLink);
    }
    if (message.targetLink !== "") {
      writer.uint32(58).string(message.targetLink);
    }
    if (message.location !== "") {
      writer.uint32(74).string(message.location);
    }
    if (message.startTime !== "") {
      writer.uint32(82).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(90).string(message.endTime);
    }
    if (message.progress !== undefined) {
      OperationProgress.encode(message.progress, writer.uint32(98).fork()).join();
    }
    for (const v of message.clusterConditions) {
      StatusCondition.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.nodepoolConditions) {
      StatusCondition.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.detail = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetLink = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.location = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.startTime = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endTime = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.progress = OperationProgress.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.clusterConditions.push(StatusCondition.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.nodepoolConditions.push(StatusCondition.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Operation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationType: isSet(object.operationType) ? operation_TypeFromJSON(object.operationType) : 0,
      status: isSet(object.status) ? operation_StatusFromJSON(object.status) : 0,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      targetLink: isSet(object.targetLink) ? globalThis.String(object.targetLink) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
      progress: isSet(object.progress) ? OperationProgress.fromJSON(object.progress) : undefined,
      clusterConditions: globalThis.Array.isArray(object?.clusterConditions)
        ? object.clusterConditions.map((e: any) => StatusCondition.fromJSON(e))
        : [],
      nodepoolConditions: globalThis.Array.isArray(object?.nodepoolConditions)
        ? object.nodepoolConditions.map((e: any) => StatusCondition.fromJSON(e))
        : [],
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Operation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationType !== 0) {
      obj.operationType = operation_TypeToJSON(message.operationType);
    }
    if (message.status !== 0) {
      obj.status = operation_StatusToJSON(message.status);
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.targetLink !== "") {
      obj.targetLink = message.targetLink;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.progress !== undefined) {
      obj.progress = OperationProgress.toJSON(message.progress);
    }
    if (message.clusterConditions?.length) {
      obj.clusterConditions = message.clusterConditions.map((e) => StatusCondition.toJSON(e));
    }
    if (message.nodepoolConditions?.length) {
      obj.nodepoolConditions = message.nodepoolConditions.map((e) => StatusCondition.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<Operation>): Operation {
    return Operation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation>): Operation {
    const message = createBaseOperation();
    message.name = object.name ?? "";
    message.zone = object.zone ?? "";
    message.operationType = object.operationType ?? 0;
    message.status = object.status ?? 0;
    message.detail = object.detail ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.selfLink = object.selfLink ?? "";
    message.targetLink = object.targetLink ?? "";
    message.location = object.location ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? OperationProgress.fromPartial(object.progress)
      : undefined;
    message.clusterConditions = object.clusterConditions?.map((e) => StatusCondition.fromPartial(e)) || [];
    message.nodepoolConditions = object.nodepoolConditions?.map((e) => StatusCondition.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseOperationProgress(): OperationProgress {
  return { name: "", status: 0, metrics: [], stages: [] };
}

export const OperationProgress: MessageFns<OperationProgress> = {
  encode(message: OperationProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.metrics) {
      OperationProgress_Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.stages) {
      OperationProgress.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(OperationProgress_Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stages.push(OperationProgress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationProgress {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? operation_StatusFromJSON(object.status) : 0,
      metrics: globalThis.Array.isArray(object?.metrics)
        ? object.metrics.map((e: any) => OperationProgress_Metric.fromJSON(e))
        : [],
      stages: globalThis.Array.isArray(object?.stages)
        ? object.stages.map((e: any) => OperationProgress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OperationProgress): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== 0) {
      obj.status = operation_StatusToJSON(message.status);
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => OperationProgress_Metric.toJSON(e));
    }
    if (message.stages?.length) {
      obj.stages = message.stages.map((e) => OperationProgress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OperationProgress>): OperationProgress {
    return OperationProgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationProgress>): OperationProgress {
    const message = createBaseOperationProgress();
    message.name = object.name ?? "";
    message.status = object.status ?? 0;
    message.metrics = object.metrics?.map((e) => OperationProgress_Metric.fromPartial(e)) || [];
    message.stages = object.stages?.map((e) => OperationProgress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationProgress_Metric(): OperationProgress_Metric {
  return { name: "", intValue: undefined, doubleValue: undefined, stringValue: undefined };
}

export const OperationProgress_Metric: MessageFns<OperationProgress_Metric> = {
  encode(message: OperationProgress_Metric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(25).double(message.doubleValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(34).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationProgress_Metric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationProgress_Metric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationProgress_Metric {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
    };
  },

  toJSON(message: OperationProgress_Metric): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationProgress_Metric>): OperationProgress_Metric {
    return OperationProgress_Metric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationProgress_Metric>): OperationProgress_Metric {
    const message = createBaseOperationProgress_Metric();
    message.name = object.name ?? "";
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    return message;
  },
};

function createBaseCreateClusterRequest(): CreateClusterRequest {
  return { projectId: "", zone: "", cluster: undefined, parent: "" };
}

export const CreateClusterRequest: MessageFns<CreateClusterRequest> = {
  encode(message: CreateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.cluster !== undefined) {
      Cluster.encode(message.cluster, writer.uint32(26).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cluster = Cluster.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      cluster: isSet(object.cluster) ? Cluster.fromJSON(object.cluster) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: CreateClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.cluster !== undefined) {
      obj.cluster = Cluster.toJSON(message.cluster);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    return CreateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    const message = createBaseCreateClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Cluster.fromPartial(object.cluster)
      : undefined;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGetClusterRequest(): GetClusterRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const GetClusterRequest: MessageFns<GetClusterRequest> = {
  encode(message: GetClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetClusterRequest>): GetClusterRequest {
    return GetClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClusterRequest>): GetClusterRequest {
    const message = createBaseGetClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateClusterRequest(): UpdateClusterRequest {
  return { projectId: "", zone: "", clusterId: "", update: undefined, name: "" };
}

export const UpdateClusterRequest: MessageFns<UpdateClusterRequest> = {
  encode(message: UpdateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.update !== undefined) {
      ClusterUpdate.encode(message.update, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.update = ClusterUpdate.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      update: isSet(object.update) ? ClusterUpdate.fromJSON(object.update) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.update !== undefined) {
      obj.update = ClusterUpdate.toJSON(message.update);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    return UpdateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    const message = createBaseUpdateClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.update = (object.update !== undefined && object.update !== null)
      ? ClusterUpdate.fromPartial(object.update)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNodePoolRequest(): UpdateNodePoolRequest {
  return {
    projectId: "",
    zone: "",
    clusterId: "",
    nodePoolId: "",
    nodeVersion: "",
    imageType: "",
    name: "",
    locations: [],
    workloadMetadataConfig: undefined,
    upgradeSettings: undefined,
    tags: undefined,
    taints: undefined,
    labels: undefined,
    linuxNodeConfig: undefined,
    kubeletConfig: undefined,
    nodeNetworkConfig: undefined,
    gcfsConfig: undefined,
    confidentialNodes: undefined,
    gvnic: undefined,
    etag: "",
    fastSocket: undefined,
    loggingConfig: undefined,
    resourceLabels: undefined,
    windowsNodeConfig: undefined,
    accelerators: [],
    machineType: "",
    diskType: "",
    diskSizeGb: Long.ZERO,
    resourceManagerTags: undefined,
    containerdConfig: undefined,
    queuedProvisioning: undefined,
  };
}

export const UpdateNodePoolRequest: MessageFns<UpdateNodePoolRequest> = {
  encode(message: UpdateNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.nodeVersion !== "") {
      writer.uint32(42).string(message.nodeVersion);
    }
    if (message.imageType !== "") {
      writer.uint32(50).string(message.imageType);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    for (const v of message.locations) {
      writer.uint32(106).string(v!);
    }
    if (message.workloadMetadataConfig !== undefined) {
      WorkloadMetadataConfig.encode(message.workloadMetadataConfig, writer.uint32(114).fork()).join();
    }
    if (message.upgradeSettings !== undefined) {
      NodePool_UpgradeSettings.encode(message.upgradeSettings, writer.uint32(122).fork()).join();
    }
    if (message.tags !== undefined) {
      NetworkTags.encode(message.tags, writer.uint32(130).fork()).join();
    }
    if (message.taints !== undefined) {
      NodeTaints.encode(message.taints, writer.uint32(138).fork()).join();
    }
    if (message.labels !== undefined) {
      NodeLabels.encode(message.labels, writer.uint32(146).fork()).join();
    }
    if (message.linuxNodeConfig !== undefined) {
      LinuxNodeConfig.encode(message.linuxNodeConfig, writer.uint32(154).fork()).join();
    }
    if (message.kubeletConfig !== undefined) {
      NodeKubeletConfig.encode(message.kubeletConfig, writer.uint32(162).fork()).join();
    }
    if (message.nodeNetworkConfig !== undefined) {
      NodeNetworkConfig.encode(message.nodeNetworkConfig, writer.uint32(170).fork()).join();
    }
    if (message.gcfsConfig !== undefined) {
      GcfsConfig.encode(message.gcfsConfig, writer.uint32(178).fork()).join();
    }
    if (message.confidentialNodes !== undefined) {
      ConfidentialNodes.encode(message.confidentialNodes, writer.uint32(186).fork()).join();
    }
    if (message.gvnic !== undefined) {
      VirtualNIC.encode(message.gvnic, writer.uint32(234).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(242).string(message.etag);
    }
    if (message.fastSocket !== undefined) {
      FastSocket.encode(message.fastSocket, writer.uint32(250).fork()).join();
    }
    if (message.loggingConfig !== undefined) {
      NodePoolLoggingConfig.encode(message.loggingConfig, writer.uint32(258).fork()).join();
    }
    if (message.resourceLabels !== undefined) {
      ResourceLabels.encode(message.resourceLabels, writer.uint32(266).fork()).join();
    }
    if (message.windowsNodeConfig !== undefined) {
      WindowsNodeConfig.encode(message.windowsNodeConfig, writer.uint32(274).fork()).join();
    }
    for (const v of message.accelerators) {
      AcceleratorConfig.encode(v!, writer.uint32(282).fork()).join();
    }
    if (message.machineType !== "") {
      writer.uint32(290).string(message.machineType);
    }
    if (message.diskType !== "") {
      writer.uint32(298).string(message.diskType);
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      writer.uint32(304).int64(message.diskSizeGb.toString());
    }
    if (message.resourceManagerTags !== undefined) {
      ResourceManagerTags.encode(message.resourceManagerTags, writer.uint32(314).fork()).join();
    }
    if (message.containerdConfig !== undefined) {
      ContainerdConfig.encode(message.containerdConfig, writer.uint32(322).fork()).join();
    }
    if (message.queuedProvisioning !== undefined) {
      NodePool_QueuedProvisioning.encode(message.queuedProvisioning, writer.uint32(338).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nodeVersion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.imageType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.workloadMetadataConfig = WorkloadMetadataConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.upgradeSettings = NodePool_UpgradeSettings.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.tags = NetworkTags.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.taints = NodeTaints.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.labels = NodeLabels.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.linuxNodeConfig = LinuxNodeConfig.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.kubeletConfig = NodeKubeletConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.nodeNetworkConfig = NodeNetworkConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.gcfsConfig = GcfsConfig.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.confidentialNodes = ConfidentialNodes.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.gvnic = VirtualNIC.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.fastSocket = FastSocket.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.loggingConfig = NodePoolLoggingConfig.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.resourceLabels = ResourceLabels.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.windowsNodeConfig = WindowsNodeConfig.decode(reader, reader.uint32());
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.accelerators.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.resourceManagerTags = ResourceManagerTags.decode(reader, reader.uint32());
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.containerdConfig = ContainerdConfig.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.queuedProvisioning = NodePool_QueuedProvisioning.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      nodeVersion: isSet(object.nodeVersion) ? globalThis.String(object.nodeVersion) : "",
      imageType: isSet(object.imageType) ? globalThis.String(object.imageType) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      workloadMetadataConfig: isSet(object.workloadMetadataConfig)
        ? WorkloadMetadataConfig.fromJSON(object.workloadMetadataConfig)
        : undefined,
      upgradeSettings: isSet(object.upgradeSettings)
        ? NodePool_UpgradeSettings.fromJSON(object.upgradeSettings)
        : undefined,
      tags: isSet(object.tags) ? NetworkTags.fromJSON(object.tags) : undefined,
      taints: isSet(object.taints) ? NodeTaints.fromJSON(object.taints) : undefined,
      labels: isSet(object.labels) ? NodeLabels.fromJSON(object.labels) : undefined,
      linuxNodeConfig: isSet(object.linuxNodeConfig) ? LinuxNodeConfig.fromJSON(object.linuxNodeConfig) : undefined,
      kubeletConfig: isSet(object.kubeletConfig) ? NodeKubeletConfig.fromJSON(object.kubeletConfig) : undefined,
      nodeNetworkConfig: isSet(object.nodeNetworkConfig)
        ? NodeNetworkConfig.fromJSON(object.nodeNetworkConfig)
        : undefined,
      gcfsConfig: isSet(object.gcfsConfig) ? GcfsConfig.fromJSON(object.gcfsConfig) : undefined,
      confidentialNodes: isSet(object.confidentialNodes)
        ? ConfidentialNodes.fromJSON(object.confidentialNodes)
        : undefined,
      gvnic: isSet(object.gvnic) ? VirtualNIC.fromJSON(object.gvnic) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      fastSocket: isSet(object.fastSocket) ? FastSocket.fromJSON(object.fastSocket) : undefined,
      loggingConfig: isSet(object.loggingConfig) ? NodePoolLoggingConfig.fromJSON(object.loggingConfig) : undefined,
      resourceLabels: isSet(object.resourceLabels) ? ResourceLabels.fromJSON(object.resourceLabels) : undefined,
      windowsNodeConfig: isSet(object.windowsNodeConfig)
        ? WindowsNodeConfig.fromJSON(object.windowsNodeConfig)
        : undefined,
      accelerators: globalThis.Array.isArray(object?.accelerators)
        ? object.accelerators.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : Long.ZERO,
      resourceManagerTags: isSet(object.resourceManagerTags)
        ? ResourceManagerTags.fromJSON(object.resourceManagerTags)
        : undefined,
      containerdConfig: isSet(object.containerdConfig) ? ContainerdConfig.fromJSON(object.containerdConfig) : undefined,
      queuedProvisioning: isSet(object.queuedProvisioning)
        ? NodePool_QueuedProvisioning.fromJSON(object.queuedProvisioning)
        : undefined,
    };
  },

  toJSON(message: UpdateNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.nodeVersion !== "") {
      obj.nodeVersion = message.nodeVersion;
    }
    if (message.imageType !== "") {
      obj.imageType = message.imageType;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.workloadMetadataConfig !== undefined) {
      obj.workloadMetadataConfig = WorkloadMetadataConfig.toJSON(message.workloadMetadataConfig);
    }
    if (message.upgradeSettings !== undefined) {
      obj.upgradeSettings = NodePool_UpgradeSettings.toJSON(message.upgradeSettings);
    }
    if (message.tags !== undefined) {
      obj.tags = NetworkTags.toJSON(message.tags);
    }
    if (message.taints !== undefined) {
      obj.taints = NodeTaints.toJSON(message.taints);
    }
    if (message.labels !== undefined) {
      obj.labels = NodeLabels.toJSON(message.labels);
    }
    if (message.linuxNodeConfig !== undefined) {
      obj.linuxNodeConfig = LinuxNodeConfig.toJSON(message.linuxNodeConfig);
    }
    if (message.kubeletConfig !== undefined) {
      obj.kubeletConfig = NodeKubeletConfig.toJSON(message.kubeletConfig);
    }
    if (message.nodeNetworkConfig !== undefined) {
      obj.nodeNetworkConfig = NodeNetworkConfig.toJSON(message.nodeNetworkConfig);
    }
    if (message.gcfsConfig !== undefined) {
      obj.gcfsConfig = GcfsConfig.toJSON(message.gcfsConfig);
    }
    if (message.confidentialNodes !== undefined) {
      obj.confidentialNodes = ConfidentialNodes.toJSON(message.confidentialNodes);
    }
    if (message.gvnic !== undefined) {
      obj.gvnic = VirtualNIC.toJSON(message.gvnic);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.fastSocket !== undefined) {
      obj.fastSocket = FastSocket.toJSON(message.fastSocket);
    }
    if (message.loggingConfig !== undefined) {
      obj.loggingConfig = NodePoolLoggingConfig.toJSON(message.loggingConfig);
    }
    if (message.resourceLabels !== undefined) {
      obj.resourceLabels = ResourceLabels.toJSON(message.resourceLabels);
    }
    if (message.windowsNodeConfig !== undefined) {
      obj.windowsNodeConfig = WindowsNodeConfig.toJSON(message.windowsNodeConfig);
    }
    if (message.accelerators?.length) {
      obj.accelerators = message.accelerators.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (!message.diskSizeGb.equals(Long.ZERO)) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.resourceManagerTags !== undefined) {
      obj.resourceManagerTags = ResourceManagerTags.toJSON(message.resourceManagerTags);
    }
    if (message.containerdConfig !== undefined) {
      obj.containerdConfig = ContainerdConfig.toJSON(message.containerdConfig);
    }
    if (message.queuedProvisioning !== undefined) {
      obj.queuedProvisioning = NodePool_QueuedProvisioning.toJSON(message.queuedProvisioning);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNodePoolRequest>): UpdateNodePoolRequest {
    return UpdateNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNodePoolRequest>): UpdateNodePoolRequest {
    const message = createBaseUpdateNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.nodeVersion = object.nodeVersion ?? "";
    message.imageType = object.imageType ?? "";
    message.name = object.name ?? "";
    message.locations = object.locations?.map((e) => e) || [];
    message.workloadMetadataConfig =
      (object.workloadMetadataConfig !== undefined && object.workloadMetadataConfig !== null)
        ? WorkloadMetadataConfig.fromPartial(object.workloadMetadataConfig)
        : undefined;
    message.upgradeSettings = (object.upgradeSettings !== undefined && object.upgradeSettings !== null)
      ? NodePool_UpgradeSettings.fromPartial(object.upgradeSettings)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null)
      ? NetworkTags.fromPartial(object.tags)
      : undefined;
    message.taints = (object.taints !== undefined && object.taints !== null)
      ? NodeTaints.fromPartial(object.taints)
      : undefined;
    message.labels = (object.labels !== undefined && object.labels !== null)
      ? NodeLabels.fromPartial(object.labels)
      : undefined;
    message.linuxNodeConfig = (object.linuxNodeConfig !== undefined && object.linuxNodeConfig !== null)
      ? LinuxNodeConfig.fromPartial(object.linuxNodeConfig)
      : undefined;
    message.kubeletConfig = (object.kubeletConfig !== undefined && object.kubeletConfig !== null)
      ? NodeKubeletConfig.fromPartial(object.kubeletConfig)
      : undefined;
    message.nodeNetworkConfig = (object.nodeNetworkConfig !== undefined && object.nodeNetworkConfig !== null)
      ? NodeNetworkConfig.fromPartial(object.nodeNetworkConfig)
      : undefined;
    message.gcfsConfig = (object.gcfsConfig !== undefined && object.gcfsConfig !== null)
      ? GcfsConfig.fromPartial(object.gcfsConfig)
      : undefined;
    message.confidentialNodes = (object.confidentialNodes !== undefined && object.confidentialNodes !== null)
      ? ConfidentialNodes.fromPartial(object.confidentialNodes)
      : undefined;
    message.gvnic = (object.gvnic !== undefined && object.gvnic !== null)
      ? VirtualNIC.fromPartial(object.gvnic)
      : undefined;
    message.etag = object.etag ?? "";
    message.fastSocket = (object.fastSocket !== undefined && object.fastSocket !== null)
      ? FastSocket.fromPartial(object.fastSocket)
      : undefined;
    message.loggingConfig = (object.loggingConfig !== undefined && object.loggingConfig !== null)
      ? NodePoolLoggingConfig.fromPartial(object.loggingConfig)
      : undefined;
    message.resourceLabels = (object.resourceLabels !== undefined && object.resourceLabels !== null)
      ? ResourceLabels.fromPartial(object.resourceLabels)
      : undefined;
    message.windowsNodeConfig = (object.windowsNodeConfig !== undefined && object.windowsNodeConfig !== null)
      ? WindowsNodeConfig.fromPartial(object.windowsNodeConfig)
      : undefined;
    message.accelerators = object.accelerators?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.machineType = object.machineType ?? "";
    message.diskType = object.diskType ?? "";
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : Long.ZERO;
    message.resourceManagerTags = (object.resourceManagerTags !== undefined && object.resourceManagerTags !== null)
      ? ResourceManagerTags.fromPartial(object.resourceManagerTags)
      : undefined;
    message.containerdConfig = (object.containerdConfig !== undefined && object.containerdConfig !== null)
      ? ContainerdConfig.fromPartial(object.containerdConfig)
      : undefined;
    message.queuedProvisioning = (object.queuedProvisioning !== undefined && object.queuedProvisioning !== null)
      ? NodePool_QueuedProvisioning.fromPartial(object.queuedProvisioning)
      : undefined;
    return message;
  },
};

function createBaseSetNodePoolAutoscalingRequest(): SetNodePoolAutoscalingRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", autoscaling: undefined, name: "" };
}

export const SetNodePoolAutoscalingRequest: MessageFns<SetNodePoolAutoscalingRequest> = {
  encode(message: SetNodePoolAutoscalingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.autoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.autoscaling, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolAutoscalingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolAutoscalingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.autoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolAutoscalingRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      autoscaling: isSet(object.autoscaling) ? NodePoolAutoscaling.fromJSON(object.autoscaling) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolAutoscalingRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.autoscaling !== undefined) {
      obj.autoscaling = NodePoolAutoscaling.toJSON(message.autoscaling);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolAutoscalingRequest>): SetNodePoolAutoscalingRequest {
    return SetNodePoolAutoscalingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolAutoscalingRequest>): SetNodePoolAutoscalingRequest {
    const message = createBaseSetNodePoolAutoscalingRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.autoscaling = (object.autoscaling !== undefined && object.autoscaling !== null)
      ? NodePoolAutoscaling.fromPartial(object.autoscaling)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLoggingServiceRequest(): SetLoggingServiceRequest {
  return { projectId: "", zone: "", clusterId: "", loggingService: "", name: "" };
}

export const SetLoggingServiceRequest: MessageFns<SetLoggingServiceRequest> = {
  encode(message: SetLoggingServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.loggingService !== "") {
      writer.uint32(34).string(message.loggingService);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLoggingServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLoggingServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.loggingService = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLoggingServiceRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      loggingService: isSet(object.loggingService) ? globalThis.String(object.loggingService) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLoggingServiceRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.loggingService !== "") {
      obj.loggingService = message.loggingService;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLoggingServiceRequest>): SetLoggingServiceRequest {
    return SetLoggingServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLoggingServiceRequest>): SetLoggingServiceRequest {
    const message = createBaseSetLoggingServiceRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.loggingService = object.loggingService ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMonitoringServiceRequest(): SetMonitoringServiceRequest {
  return { projectId: "", zone: "", clusterId: "", monitoringService: "", name: "" };
}

export const SetMonitoringServiceRequest: MessageFns<SetMonitoringServiceRequest> = {
  encode(message: SetMonitoringServiceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.monitoringService !== "") {
      writer.uint32(34).string(message.monitoringService);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMonitoringServiceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMonitoringServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.monitoringService = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMonitoringServiceRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      monitoringService: isSet(object.monitoringService) ? globalThis.String(object.monitoringService) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMonitoringServiceRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.monitoringService !== "") {
      obj.monitoringService = message.monitoringService;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMonitoringServiceRequest>): SetMonitoringServiceRequest {
    return SetMonitoringServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMonitoringServiceRequest>): SetMonitoringServiceRequest {
    const message = createBaseSetMonitoringServiceRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.monitoringService = object.monitoringService ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetAddonsConfigRequest(): SetAddonsConfigRequest {
  return { projectId: "", zone: "", clusterId: "", addonsConfig: undefined, name: "" };
}

export const SetAddonsConfigRequest: MessageFns<SetAddonsConfigRequest> = {
  encode(message: SetAddonsConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.addonsConfig !== undefined) {
      AddonsConfig.encode(message.addonsConfig, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetAddonsConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAddonsConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addonsConfig = AddonsConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAddonsConfigRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      addonsConfig: isSet(object.addonsConfig) ? AddonsConfig.fromJSON(object.addonsConfig) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetAddonsConfigRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.addonsConfig !== undefined) {
      obj.addonsConfig = AddonsConfig.toJSON(message.addonsConfig);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetAddonsConfigRequest>): SetAddonsConfigRequest {
    return SetAddonsConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetAddonsConfigRequest>): SetAddonsConfigRequest {
    const message = createBaseSetAddonsConfigRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.addonsConfig = (object.addonsConfig !== undefined && object.addonsConfig !== null)
      ? AddonsConfig.fromPartial(object.addonsConfig)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLocationsRequest(): SetLocationsRequest {
  return { projectId: "", zone: "", clusterId: "", locations: [], name: "" };
}

export const SetLocationsRequest: MessageFns<SetLocationsRequest> = {
  encode(message: SetLocationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    for (const v of message.locations) {
      writer.uint32(34).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLocationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLocationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLocationsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLocationsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLocationsRequest>): SetLocationsRequest {
    return SetLocationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLocationsRequest>): SetLocationsRequest {
    const message = createBaseSetLocationsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.locations = object.locations?.map((e) => e) || [];
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateMasterRequest(): UpdateMasterRequest {
  return { projectId: "", zone: "", clusterId: "", masterVersion: "", name: "" };
}

export const UpdateMasterRequest: MessageFns<UpdateMasterRequest> = {
  encode(message: UpdateMasterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.masterVersion !== "") {
      writer.uint32(34).string(message.masterVersion);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMasterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMasterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.masterVersion = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMasterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      masterVersion: isSet(object.masterVersion) ? globalThis.String(object.masterVersion) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateMasterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.masterVersion !== "") {
      obj.masterVersion = message.masterVersion;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateMasterRequest>): UpdateMasterRequest {
    return UpdateMasterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateMasterRequest>): UpdateMasterRequest {
    const message = createBaseUpdateMasterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.masterVersion = object.masterVersion ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMasterAuthRequest(): SetMasterAuthRequest {
  return { projectId: "", zone: "", clusterId: "", action: 0, update: undefined, name: "" };
}

export const SetMasterAuthRequest: MessageFns<SetMasterAuthRequest> = {
  encode(message: SetMasterAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.action !== 0) {
      writer.uint32(32).int32(message.action);
    }
    if (message.update !== undefined) {
      MasterAuth.encode(message.update, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMasterAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMasterAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.update = MasterAuth.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMasterAuthRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      action: isSet(object.action) ? setMasterAuthRequest_ActionFromJSON(object.action) : 0,
      update: isSet(object.update) ? MasterAuth.fromJSON(object.update) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMasterAuthRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.action !== 0) {
      obj.action = setMasterAuthRequest_ActionToJSON(message.action);
    }
    if (message.update !== undefined) {
      obj.update = MasterAuth.toJSON(message.update);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMasterAuthRequest>): SetMasterAuthRequest {
    return SetMasterAuthRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMasterAuthRequest>): SetMasterAuthRequest {
    const message = createBaseSetMasterAuthRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.action = object.action ?? 0;
    message.update = (object.update !== undefined && object.update !== null)
      ? MasterAuth.fromPartial(object.update)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteClusterRequest(): DeleteClusterRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const DeleteClusterRequest: MessageFns<DeleteClusterRequest> = {
  encode(message: DeleteClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClusterRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteClusterRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    return DeleteClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    const message = createBaseDeleteClusterRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListClustersRequest(): ListClustersRequest {
  return { projectId: "", zone: "", parent: "" };
}

export const ListClustersRequest: MessageFns<ListClustersRequest> = {
  encode(message: ListClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListClustersRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersRequest>): ListClustersRequest {
    return ListClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersRequest>): ListClustersRequest {
    const message = createBaseListClustersRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseListClustersResponse(): ListClustersResponse {
  return { clusters: [], missingZones: [] };
}

export const ListClustersResponse: MessageFns<ListClustersResponse> = {
  encode(message: ListClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clusters) {
      Cluster.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missingZones) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusters.push(Cluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingZones.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersResponse {
    return {
      clusters: globalThis.Array.isArray(object?.clusters) ? object.clusters.map((e: any) => Cluster.fromJSON(e)) : [],
      missingZones: globalThis.Array.isArray(object?.missingZones)
        ? object.missingZones.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListClustersResponse): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.missingZones?.length) {
      obj.missingZones = message.missingZones;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersResponse>): ListClustersResponse {
    return ListClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersResponse>): ListClustersResponse {
    const message = createBaseListClustersResponse();
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || [];
    message.missingZones = object.missingZones?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOperationRequest(): GetOperationRequest {
  return { projectId: "", zone: "", operationId: "", name: "" };
}

export const GetOperationRequest: MessageFns<GetOperationRequest> = {
  encode(message: GetOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationId !== "") {
      writer.uint32(26).string(message.operationId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOperationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetOperationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOperationRequest>): GetOperationRequest {
    return GetOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationRequest>): GetOperationRequest {
    const message = createBaseGetOperationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.operationId = object.operationId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOperationsRequest(): ListOperationsRequest {
  return { projectId: "", zone: "", parent: "" };
}

export const ListOperationsRequest: MessageFns<ListOperationsRequest> = {
  encode(message: ListOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.parent !== "") {
      writer.uint32(34).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListOperationsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    return ListOperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsRequest>): ListOperationsRequest {
    const message = createBaseListOperationsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseCancelOperationRequest(): CancelOperationRequest {
  return { projectId: "", zone: "", operationId: "", name: "" };
}

export const CancelOperationRequest: MessageFns<CancelOperationRequest> = {
  encode(message: CancelOperationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.operationId !== "") {
      writer.uint32(26).string(message.operationId);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOperationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOperationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelOperationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CancelOperationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.operationId !== "") {
      obj.operationId = message.operationId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelOperationRequest>): CancelOperationRequest {
    return CancelOperationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelOperationRequest>): CancelOperationRequest {
    const message = createBaseCancelOperationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.operationId = object.operationId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListOperationsResponse(): ListOperationsResponse {
  return { operations: [], missingZones: [] };
}

export const ListOperationsResponse: MessageFns<ListOperationsResponse> = {
  encode(message: ListOperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missingZones) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingZones.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOperationsResponse {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Operation.fromJSON(e))
        : [],
      missingZones: globalThis.Array.isArray(object?.missingZones)
        ? object.missingZones.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOperationsResponse): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Operation.toJSON(e));
    }
    if (message.missingZones?.length) {
      obj.missingZones = message.missingZones;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    return ListOperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOperationsResponse>): ListOperationsResponse {
    const message = createBaseListOperationsResponse();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    message.missingZones = object.missingZones?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetServerConfigRequest(): GetServerConfigRequest {
  return { projectId: "", zone: "", name: "" };
}

export const GetServerConfigRequest: MessageFns<GetServerConfigRequest> = {
  encode(message: GetServerConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServerConfigRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetServerConfigRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServerConfigRequest>): GetServerConfigRequest {
    return GetServerConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerConfigRequest>): GetServerConfigRequest {
    const message = createBaseGetServerConfigRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return {
    defaultClusterVersion: "",
    validNodeVersions: [],
    defaultImageType: "",
    validImageTypes: [],
    validMasterVersions: [],
    channels: [],
  };
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultClusterVersion !== "") {
      writer.uint32(10).string(message.defaultClusterVersion);
    }
    for (const v of message.validNodeVersions) {
      writer.uint32(26).string(v!);
    }
    if (message.defaultImageType !== "") {
      writer.uint32(34).string(message.defaultImageType);
    }
    for (const v of message.validImageTypes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.validMasterVersions) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.channels) {
      ServerConfig_ReleaseChannelConfig.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultClusterVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.validNodeVersions.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.defaultImageType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validImageTypes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.validMasterVersions.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.channels.push(ServerConfig_ReleaseChannelConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      defaultClusterVersion: isSet(object.defaultClusterVersion) ? globalThis.String(object.defaultClusterVersion) : "",
      validNodeVersions: globalThis.Array.isArray(object?.validNodeVersions)
        ? object.validNodeVersions.map((e: any) => globalThis.String(e))
        : [],
      defaultImageType: isSet(object.defaultImageType) ? globalThis.String(object.defaultImageType) : "",
      validImageTypes: globalThis.Array.isArray(object?.validImageTypes)
        ? object.validImageTypes.map((e: any) => globalThis.String(e))
        : [],
      validMasterVersions: globalThis.Array.isArray(object?.validMasterVersions)
        ? object.validMasterVersions.map((e: any) => globalThis.String(e))
        : [],
      channels: globalThis.Array.isArray(object?.channels)
        ? object.channels.map((e: any) => ServerConfig_ReleaseChannelConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.defaultClusterVersion !== "") {
      obj.defaultClusterVersion = message.defaultClusterVersion;
    }
    if (message.validNodeVersions?.length) {
      obj.validNodeVersions = message.validNodeVersions;
    }
    if (message.defaultImageType !== "") {
      obj.defaultImageType = message.defaultImageType;
    }
    if (message.validImageTypes?.length) {
      obj.validImageTypes = message.validImageTypes;
    }
    if (message.validMasterVersions?.length) {
      obj.validMasterVersions = message.validMasterVersions;
    }
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => ServerConfig_ReleaseChannelConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig>): ServerConfig {
    return ServerConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig>): ServerConfig {
    const message = createBaseServerConfig();
    message.defaultClusterVersion = object.defaultClusterVersion ?? "";
    message.validNodeVersions = object.validNodeVersions?.map((e) => e) || [];
    message.defaultImageType = object.defaultImageType ?? "";
    message.validImageTypes = object.validImageTypes?.map((e) => e) || [];
    message.validMasterVersions = object.validMasterVersions?.map((e) => e) || [];
    message.channels = object.channels?.map((e) => ServerConfig_ReleaseChannelConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServerConfig_ReleaseChannelConfig(): ServerConfig_ReleaseChannelConfig {
  return { channel: 0, defaultVersion: "", validVersions: [] };
}

export const ServerConfig_ReleaseChannelConfig: MessageFns<ServerConfig_ReleaseChannelConfig> = {
  encode(message: ServerConfig_ReleaseChannelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    if (message.defaultVersion !== "") {
      writer.uint32(18).string(message.defaultVersion);
    }
    for (const v of message.validVersions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig_ReleaseChannelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig_ReleaseChannelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.validVersions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig_ReleaseChannelConfig {
    return {
      channel: isSet(object.channel) ? releaseChannel_ChannelFromJSON(object.channel) : 0,
      defaultVersion: isSet(object.defaultVersion) ? globalThis.String(object.defaultVersion) : "",
      validVersions: globalThis.Array.isArray(object?.validVersions)
        ? object.validVersions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServerConfig_ReleaseChannelConfig): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = releaseChannel_ChannelToJSON(message.channel);
    }
    if (message.defaultVersion !== "") {
      obj.defaultVersion = message.defaultVersion;
    }
    if (message.validVersions?.length) {
      obj.validVersions = message.validVersions;
    }
    return obj;
  },

  create(base?: DeepPartial<ServerConfig_ReleaseChannelConfig>): ServerConfig_ReleaseChannelConfig {
    return ServerConfig_ReleaseChannelConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerConfig_ReleaseChannelConfig>): ServerConfig_ReleaseChannelConfig {
    const message = createBaseServerConfig_ReleaseChannelConfig();
    message.channel = object.channel ?? 0;
    message.defaultVersion = object.defaultVersion ?? "";
    message.validVersions = object.validVersions?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateNodePoolRequest(): CreateNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePool: undefined, parent: "" };
}

export const CreateNodePoolRequest: MessageFns<CreateNodePoolRequest> = {
  encode(message: CreateNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePool !== undefined) {
      NodePool.encode(message.nodePool, writer.uint32(34).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(50).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePool = NodePool.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePool: isSet(object.nodePool) ? NodePool.fromJSON(object.nodePool) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: CreateNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePool !== undefined) {
      obj.nodePool = NodePool.toJSON(message.nodePool);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNodePoolRequest>): CreateNodePoolRequest {
    return CreateNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNodePoolRequest>): CreateNodePoolRequest {
    const message = createBaseCreateNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePool = (object.nodePool !== undefined && object.nodePool !== null)
      ? NodePool.fromPartial(object.nodePool)
      : undefined;
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseDeleteNodePoolRequest(): DeleteNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "" };
}

export const DeleteNodePoolRequest: MessageFns<DeleteNodePoolRequest> = {
  encode(message: DeleteNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: DeleteNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNodePoolRequest>): DeleteNodePoolRequest {
    return DeleteNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNodePoolRequest>): DeleteNodePoolRequest {
    const message = createBaseDeleteNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNodePoolsRequest(): ListNodePoolsRequest {
  return { projectId: "", zone: "", clusterId: "", parent: "" };
}

export const ListNodePoolsRequest: MessageFns<ListNodePoolsRequest> = {
  encode(message: ListNodePoolsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodePoolsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodePoolsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodePoolsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: ListNodePoolsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodePoolsRequest>): ListNodePoolsRequest {
    return ListNodePoolsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodePoolsRequest>): ListNodePoolsRequest {
    const message = createBaseListNodePoolsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGetNodePoolRequest(): GetNodePoolRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "" };
}

export const GetNodePoolRequest: MessageFns<GetNodePoolRequest> = {
  encode(message: GetNodePoolRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodePoolRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodePoolRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodePoolRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetNodePoolRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodePoolRequest>): GetNodePoolRequest {
    return GetNodePoolRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodePoolRequest>): GetNodePoolRequest {
    const message = createBaseGetNodePoolRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBlueGreenSettings(): BlueGreenSettings {
  return { standardRolloutPolicy: undefined, nodePoolSoakDuration: undefined };
}

export const BlueGreenSettings: MessageFns<BlueGreenSettings> = {
  encode(message: BlueGreenSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.standardRolloutPolicy !== undefined) {
      BlueGreenSettings_StandardRolloutPolicy.encode(message.standardRolloutPolicy, writer.uint32(10).fork()).join();
    }
    if (message.nodePoolSoakDuration !== undefined) {
      Duration.encode(message.nodePoolSoakDuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlueGreenSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueGreenSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.standardRolloutPolicy = BlueGreenSettings_StandardRolloutPolicy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodePoolSoakDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlueGreenSettings {
    return {
      standardRolloutPolicy: isSet(object.standardRolloutPolicy)
        ? BlueGreenSettings_StandardRolloutPolicy.fromJSON(object.standardRolloutPolicy)
        : undefined,
      nodePoolSoakDuration: isSet(object.nodePoolSoakDuration)
        ? Duration.fromJSON(object.nodePoolSoakDuration)
        : undefined,
    };
  },

  toJSON(message: BlueGreenSettings): unknown {
    const obj: any = {};
    if (message.standardRolloutPolicy !== undefined) {
      obj.standardRolloutPolicy = BlueGreenSettings_StandardRolloutPolicy.toJSON(message.standardRolloutPolicy);
    }
    if (message.nodePoolSoakDuration !== undefined) {
      obj.nodePoolSoakDuration = Duration.toJSON(message.nodePoolSoakDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<BlueGreenSettings>): BlueGreenSettings {
    return BlueGreenSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlueGreenSettings>): BlueGreenSettings {
    const message = createBaseBlueGreenSettings();
    message.standardRolloutPolicy =
      (object.standardRolloutPolicy !== undefined && object.standardRolloutPolicy !== null)
        ? BlueGreenSettings_StandardRolloutPolicy.fromPartial(object.standardRolloutPolicy)
        : undefined;
    message.nodePoolSoakDuration = (object.nodePoolSoakDuration !== undefined && object.nodePoolSoakDuration !== null)
      ? Duration.fromPartial(object.nodePoolSoakDuration)
      : undefined;
    return message;
  },
};

function createBaseBlueGreenSettings_StandardRolloutPolicy(): BlueGreenSettings_StandardRolloutPolicy {
  return { batchPercentage: undefined, batchNodeCount: undefined, batchSoakDuration: undefined };
}

export const BlueGreenSettings_StandardRolloutPolicy: MessageFns<BlueGreenSettings_StandardRolloutPolicy> = {
  encode(message: BlueGreenSettings_StandardRolloutPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.batchPercentage !== undefined) {
      writer.uint32(13).float(message.batchPercentage);
    }
    if (message.batchNodeCount !== undefined) {
      writer.uint32(16).int32(message.batchNodeCount);
    }
    if (message.batchSoakDuration !== undefined) {
      Duration.encode(message.batchSoakDuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlueGreenSettings_StandardRolloutPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueGreenSettings_StandardRolloutPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.batchPercentage = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.batchNodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.batchSoakDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlueGreenSettings_StandardRolloutPolicy {
    return {
      batchPercentage: isSet(object.batchPercentage) ? globalThis.Number(object.batchPercentage) : undefined,
      batchNodeCount: isSet(object.batchNodeCount) ? globalThis.Number(object.batchNodeCount) : undefined,
      batchSoakDuration: isSet(object.batchSoakDuration) ? Duration.fromJSON(object.batchSoakDuration) : undefined,
    };
  },

  toJSON(message: BlueGreenSettings_StandardRolloutPolicy): unknown {
    const obj: any = {};
    if (message.batchPercentage !== undefined) {
      obj.batchPercentage = message.batchPercentage;
    }
    if (message.batchNodeCount !== undefined) {
      obj.batchNodeCount = Math.round(message.batchNodeCount);
    }
    if (message.batchSoakDuration !== undefined) {
      obj.batchSoakDuration = Duration.toJSON(message.batchSoakDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<BlueGreenSettings_StandardRolloutPolicy>): BlueGreenSettings_StandardRolloutPolicy {
    return BlueGreenSettings_StandardRolloutPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlueGreenSettings_StandardRolloutPolicy>): BlueGreenSettings_StandardRolloutPolicy {
    const message = createBaseBlueGreenSettings_StandardRolloutPolicy();
    message.batchPercentage = object.batchPercentage ?? undefined;
    message.batchNodeCount = object.batchNodeCount ?? undefined;
    message.batchSoakDuration = (object.batchSoakDuration !== undefined && object.batchSoakDuration !== null)
      ? Duration.fromPartial(object.batchSoakDuration)
      : undefined;
    return message;
  },
};

function createBaseNodePool(): NodePool {
  return {
    name: "",
    config: undefined,
    initialNodeCount: 0,
    locations: [],
    networkConfig: undefined,
    selfLink: "",
    version: "",
    instanceGroupUrls: [],
    status: 0,
    statusMessage: "",
    autoscaling: undefined,
    management: undefined,
    maxPodsConstraint: undefined,
    conditions: [],
    podIpv4CidrSize: 0,
    upgradeSettings: undefined,
    placementPolicy: undefined,
    updateInfo: undefined,
    etag: "",
    queuedProvisioning: undefined,
    bestEffortProvisioning: undefined,
  };
}

export const NodePool: MessageFns<NodePool> = {
  encode(message: NodePool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.config !== undefined) {
      NodeConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    if (message.initialNodeCount !== 0) {
      writer.uint32(24).int32(message.initialNodeCount);
    }
    for (const v of message.locations) {
      writer.uint32(106).string(v!);
    }
    if (message.networkConfig !== undefined) {
      NodeNetworkConfig.encode(message.networkConfig, writer.uint32(114).fork()).join();
    }
    if (message.selfLink !== "") {
      writer.uint32(802).string(message.selfLink);
    }
    if (message.version !== "") {
      writer.uint32(810).string(message.version);
    }
    for (const v of message.instanceGroupUrls) {
      writer.uint32(818).string(v!);
    }
    if (message.status !== 0) {
      writer.uint32(824).int32(message.status);
    }
    if (message.statusMessage !== "") {
      writer.uint32(834).string(message.statusMessage);
    }
    if (message.autoscaling !== undefined) {
      NodePoolAutoscaling.encode(message.autoscaling, writer.uint32(34).fork()).join();
    }
    if (message.management !== undefined) {
      NodeManagement.encode(message.management, writer.uint32(42).fork()).join();
    }
    if (message.maxPodsConstraint !== undefined) {
      MaxPodsConstraint.encode(message.maxPodsConstraint, writer.uint32(50).fork()).join();
    }
    for (const v of message.conditions) {
      StatusCondition.encode(v!, writer.uint32(842).fork()).join();
    }
    if (message.podIpv4CidrSize !== 0) {
      writer.uint32(56).int32(message.podIpv4CidrSize);
    }
    if (message.upgradeSettings !== undefined) {
      NodePool_UpgradeSettings.encode(message.upgradeSettings, writer.uint32(858).fork()).join();
    }
    if (message.placementPolicy !== undefined) {
      NodePool_PlacementPolicy.encode(message.placementPolicy, writer.uint32(866).fork()).join();
    }
    if (message.updateInfo !== undefined) {
      NodePool_UpdateInfo.encode(message.updateInfo, writer.uint32(874).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(882).string(message.etag);
    }
    if (message.queuedProvisioning !== undefined) {
      NodePool_QueuedProvisioning.encode(message.queuedProvisioning, writer.uint32(898).fork()).join();
    }
    if (message.bestEffortProvisioning !== undefined) {
      BestEffortProvisioning.encode(message.bestEffortProvisioning, writer.uint32(906).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.initialNodeCount = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.networkConfig = NodeNetworkConfig.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.version = reader.string();
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.instanceGroupUrls.push(reader.string());
          continue;
        case 103:
          if (tag !== 824) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.autoscaling = NodePoolAutoscaling.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.management = NodeManagement.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxPodsConstraint = MaxPodsConstraint.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.conditions.push(StatusCondition.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.podIpv4CidrSize = reader.int32();
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }

          message.upgradeSettings = NodePool_UpgradeSettings.decode(reader, reader.uint32());
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.placementPolicy = NodePool_PlacementPolicy.decode(reader, reader.uint32());
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }

          message.updateInfo = NodePool_UpdateInfo.decode(reader, reader.uint32());
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }

          message.queuedProvisioning = NodePool_QueuedProvisioning.decode(reader, reader.uint32());
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }

          message.bestEffortProvisioning = BestEffortProvisioning.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      config: isSet(object.config) ? NodeConfig.fromJSON(object.config) : undefined,
      initialNodeCount: isSet(object.initialNodeCount) ? globalThis.Number(object.initialNodeCount) : 0,
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      networkConfig: isSet(object.networkConfig) ? NodeNetworkConfig.fromJSON(object.networkConfig) : undefined,
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instanceGroupUrls: globalThis.Array.isArray(object?.instanceGroupUrls)
        ? object.instanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? nodePool_StatusFromJSON(object.status) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      autoscaling: isSet(object.autoscaling) ? NodePoolAutoscaling.fromJSON(object.autoscaling) : undefined,
      management: isSet(object.management) ? NodeManagement.fromJSON(object.management) : undefined,
      maxPodsConstraint: isSet(object.maxPodsConstraint)
        ? MaxPodsConstraint.fromJSON(object.maxPodsConstraint)
        : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => StatusCondition.fromJSON(e))
        : [],
      podIpv4CidrSize: isSet(object.podIpv4CidrSize) ? globalThis.Number(object.podIpv4CidrSize) : 0,
      upgradeSettings: isSet(object.upgradeSettings)
        ? NodePool_UpgradeSettings.fromJSON(object.upgradeSettings)
        : undefined,
      placementPolicy: isSet(object.placementPolicy)
        ? NodePool_PlacementPolicy.fromJSON(object.placementPolicy)
        : undefined,
      updateInfo: isSet(object.updateInfo) ? NodePool_UpdateInfo.fromJSON(object.updateInfo) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      queuedProvisioning: isSet(object.queuedProvisioning)
        ? NodePool_QueuedProvisioning.fromJSON(object.queuedProvisioning)
        : undefined,
      bestEffortProvisioning: isSet(object.bestEffortProvisioning)
        ? BestEffortProvisioning.fromJSON(object.bestEffortProvisioning)
        : undefined,
    };
  },

  toJSON(message: NodePool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.config !== undefined) {
      obj.config = NodeConfig.toJSON(message.config);
    }
    if (message.initialNodeCount !== 0) {
      obj.initialNodeCount = Math.round(message.initialNodeCount);
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = NodeNetworkConfig.toJSON(message.networkConfig);
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instanceGroupUrls?.length) {
      obj.instanceGroupUrls = message.instanceGroupUrls;
    }
    if (message.status !== 0) {
      obj.status = nodePool_StatusToJSON(message.status);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.autoscaling !== undefined) {
      obj.autoscaling = NodePoolAutoscaling.toJSON(message.autoscaling);
    }
    if (message.management !== undefined) {
      obj.management = NodeManagement.toJSON(message.management);
    }
    if (message.maxPodsConstraint !== undefined) {
      obj.maxPodsConstraint = MaxPodsConstraint.toJSON(message.maxPodsConstraint);
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => StatusCondition.toJSON(e));
    }
    if (message.podIpv4CidrSize !== 0) {
      obj.podIpv4CidrSize = Math.round(message.podIpv4CidrSize);
    }
    if (message.upgradeSettings !== undefined) {
      obj.upgradeSettings = NodePool_UpgradeSettings.toJSON(message.upgradeSettings);
    }
    if (message.placementPolicy !== undefined) {
      obj.placementPolicy = NodePool_PlacementPolicy.toJSON(message.placementPolicy);
    }
    if (message.updateInfo !== undefined) {
      obj.updateInfo = NodePool_UpdateInfo.toJSON(message.updateInfo);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.queuedProvisioning !== undefined) {
      obj.queuedProvisioning = NodePool_QueuedProvisioning.toJSON(message.queuedProvisioning);
    }
    if (message.bestEffortProvisioning !== undefined) {
      obj.bestEffortProvisioning = BestEffortProvisioning.toJSON(message.bestEffortProvisioning);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool>): NodePool {
    return NodePool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool>): NodePool {
    const message = createBaseNodePool();
    message.name = object.name ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? NodeConfig.fromPartial(object.config)
      : undefined;
    message.initialNodeCount = object.initialNodeCount ?? 0;
    message.locations = object.locations?.map((e) => e) || [];
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? NodeNetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.selfLink = object.selfLink ?? "";
    message.version = object.version ?? "";
    message.instanceGroupUrls = object.instanceGroupUrls?.map((e) => e) || [];
    message.status = object.status ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.autoscaling = (object.autoscaling !== undefined && object.autoscaling !== null)
      ? NodePoolAutoscaling.fromPartial(object.autoscaling)
      : undefined;
    message.management = (object.management !== undefined && object.management !== null)
      ? NodeManagement.fromPartial(object.management)
      : undefined;
    message.maxPodsConstraint = (object.maxPodsConstraint !== undefined && object.maxPodsConstraint !== null)
      ? MaxPodsConstraint.fromPartial(object.maxPodsConstraint)
      : undefined;
    message.conditions = object.conditions?.map((e) => StatusCondition.fromPartial(e)) || [];
    message.podIpv4CidrSize = object.podIpv4CidrSize ?? 0;
    message.upgradeSettings = (object.upgradeSettings !== undefined && object.upgradeSettings !== null)
      ? NodePool_UpgradeSettings.fromPartial(object.upgradeSettings)
      : undefined;
    message.placementPolicy = (object.placementPolicy !== undefined && object.placementPolicy !== null)
      ? NodePool_PlacementPolicy.fromPartial(object.placementPolicy)
      : undefined;
    message.updateInfo = (object.updateInfo !== undefined && object.updateInfo !== null)
      ? NodePool_UpdateInfo.fromPartial(object.updateInfo)
      : undefined;
    message.etag = object.etag ?? "";
    message.queuedProvisioning = (object.queuedProvisioning !== undefined && object.queuedProvisioning !== null)
      ? NodePool_QueuedProvisioning.fromPartial(object.queuedProvisioning)
      : undefined;
    message.bestEffortProvisioning =
      (object.bestEffortProvisioning !== undefined && object.bestEffortProvisioning !== null)
        ? BestEffortProvisioning.fromPartial(object.bestEffortProvisioning)
        : undefined;
    return message;
  },
};

function createBaseNodePool_UpgradeSettings(): NodePool_UpgradeSettings {
  return { maxSurge: 0, maxUnavailable: 0, strategy: undefined, blueGreenSettings: undefined };
}

export const NodePool_UpgradeSettings: MessageFns<NodePool_UpgradeSettings> = {
  encode(message: NodePool_UpgradeSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxSurge !== 0) {
      writer.uint32(8).int32(message.maxSurge);
    }
    if (message.maxUnavailable !== 0) {
      writer.uint32(16).int32(message.maxUnavailable);
    }
    if (message.strategy !== undefined) {
      writer.uint32(24).int32(message.strategy);
    }
    if (message.blueGreenSettings !== undefined) {
      BlueGreenSettings.encode(message.blueGreenSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_UpgradeSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_UpgradeSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxSurge = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxUnavailable = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.strategy = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blueGreenSettings = BlueGreenSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_UpgradeSettings {
    return {
      maxSurge: isSet(object.maxSurge) ? globalThis.Number(object.maxSurge) : 0,
      maxUnavailable: isSet(object.maxUnavailable) ? globalThis.Number(object.maxUnavailable) : 0,
      strategy: isSet(object.strategy) ? nodePoolUpdateStrategyFromJSON(object.strategy) : undefined,
      blueGreenSettings: isSet(object.blueGreenSettings)
        ? BlueGreenSettings.fromJSON(object.blueGreenSettings)
        : undefined,
    };
  },

  toJSON(message: NodePool_UpgradeSettings): unknown {
    const obj: any = {};
    if (message.maxSurge !== 0) {
      obj.maxSurge = Math.round(message.maxSurge);
    }
    if (message.maxUnavailable !== 0) {
      obj.maxUnavailable = Math.round(message.maxUnavailable);
    }
    if (message.strategy !== undefined) {
      obj.strategy = nodePoolUpdateStrategyToJSON(message.strategy);
    }
    if (message.blueGreenSettings !== undefined) {
      obj.blueGreenSettings = BlueGreenSettings.toJSON(message.blueGreenSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_UpgradeSettings>): NodePool_UpgradeSettings {
    return NodePool_UpgradeSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_UpgradeSettings>): NodePool_UpgradeSettings {
    const message = createBaseNodePool_UpgradeSettings();
    message.maxSurge = object.maxSurge ?? 0;
    message.maxUnavailable = object.maxUnavailable ?? 0;
    message.strategy = object.strategy ?? undefined;
    message.blueGreenSettings = (object.blueGreenSettings !== undefined && object.blueGreenSettings !== null)
      ? BlueGreenSettings.fromPartial(object.blueGreenSettings)
      : undefined;
    return message;
  },
};

function createBaseNodePool_UpdateInfo(): NodePool_UpdateInfo {
  return { blueGreenInfo: undefined };
}

export const NodePool_UpdateInfo: MessageFns<NodePool_UpdateInfo> = {
  encode(message: NodePool_UpdateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueGreenInfo !== undefined) {
      NodePool_UpdateInfo_BlueGreenInfo.encode(message.blueGreenInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_UpdateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_UpdateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blueGreenInfo = NodePool_UpdateInfo_BlueGreenInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_UpdateInfo {
    return {
      blueGreenInfo: isSet(object.blueGreenInfo)
        ? NodePool_UpdateInfo_BlueGreenInfo.fromJSON(object.blueGreenInfo)
        : undefined,
    };
  },

  toJSON(message: NodePool_UpdateInfo): unknown {
    const obj: any = {};
    if (message.blueGreenInfo !== undefined) {
      obj.blueGreenInfo = NodePool_UpdateInfo_BlueGreenInfo.toJSON(message.blueGreenInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_UpdateInfo>): NodePool_UpdateInfo {
    return NodePool_UpdateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_UpdateInfo>): NodePool_UpdateInfo {
    const message = createBaseNodePool_UpdateInfo();
    message.blueGreenInfo = (object.blueGreenInfo !== undefined && object.blueGreenInfo !== null)
      ? NodePool_UpdateInfo_BlueGreenInfo.fromPartial(object.blueGreenInfo)
      : undefined;
    return message;
  },
};

function createBaseNodePool_UpdateInfo_BlueGreenInfo(): NodePool_UpdateInfo_BlueGreenInfo {
  return {
    phase: 0,
    blueInstanceGroupUrls: [],
    greenInstanceGroupUrls: [],
    bluePoolDeletionStartTime: "",
    greenPoolVersion: "",
  };
}

export const NodePool_UpdateInfo_BlueGreenInfo: MessageFns<NodePool_UpdateInfo_BlueGreenInfo> = {
  encode(message: NodePool_UpdateInfo_BlueGreenInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phase !== 0) {
      writer.uint32(8).int32(message.phase);
    }
    for (const v of message.blueInstanceGroupUrls) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.greenInstanceGroupUrls) {
      writer.uint32(26).string(v!);
    }
    if (message.bluePoolDeletionStartTime !== "") {
      writer.uint32(34).string(message.bluePoolDeletionStartTime);
    }
    if (message.greenPoolVersion !== "") {
      writer.uint32(42).string(message.greenPoolVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_UpdateInfo_BlueGreenInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_UpdateInfo_BlueGreenInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blueInstanceGroupUrls.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.greenInstanceGroupUrls.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bluePoolDeletionStartTime = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.greenPoolVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_UpdateInfo_BlueGreenInfo {
    return {
      phase: isSet(object.phase) ? nodePool_UpdateInfo_BlueGreenInfo_PhaseFromJSON(object.phase) : 0,
      blueInstanceGroupUrls: globalThis.Array.isArray(object?.blueInstanceGroupUrls)
        ? object.blueInstanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      greenInstanceGroupUrls: globalThis.Array.isArray(object?.greenInstanceGroupUrls)
        ? object.greenInstanceGroupUrls.map((e: any) => globalThis.String(e))
        : [],
      bluePoolDeletionStartTime: isSet(object.bluePoolDeletionStartTime)
        ? globalThis.String(object.bluePoolDeletionStartTime)
        : "",
      greenPoolVersion: isSet(object.greenPoolVersion) ? globalThis.String(object.greenPoolVersion) : "",
    };
  },

  toJSON(message: NodePool_UpdateInfo_BlueGreenInfo): unknown {
    const obj: any = {};
    if (message.phase !== 0) {
      obj.phase = nodePool_UpdateInfo_BlueGreenInfo_PhaseToJSON(message.phase);
    }
    if (message.blueInstanceGroupUrls?.length) {
      obj.blueInstanceGroupUrls = message.blueInstanceGroupUrls;
    }
    if (message.greenInstanceGroupUrls?.length) {
      obj.greenInstanceGroupUrls = message.greenInstanceGroupUrls;
    }
    if (message.bluePoolDeletionStartTime !== "") {
      obj.bluePoolDeletionStartTime = message.bluePoolDeletionStartTime;
    }
    if (message.greenPoolVersion !== "") {
      obj.greenPoolVersion = message.greenPoolVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_UpdateInfo_BlueGreenInfo>): NodePool_UpdateInfo_BlueGreenInfo {
    return NodePool_UpdateInfo_BlueGreenInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_UpdateInfo_BlueGreenInfo>): NodePool_UpdateInfo_BlueGreenInfo {
    const message = createBaseNodePool_UpdateInfo_BlueGreenInfo();
    message.phase = object.phase ?? 0;
    message.blueInstanceGroupUrls = object.blueInstanceGroupUrls?.map((e) => e) || [];
    message.greenInstanceGroupUrls = object.greenInstanceGroupUrls?.map((e) => e) || [];
    message.bluePoolDeletionStartTime = object.bluePoolDeletionStartTime ?? "";
    message.greenPoolVersion = object.greenPoolVersion ?? "";
    return message;
  },
};

function createBaseNodePool_PlacementPolicy(): NodePool_PlacementPolicy {
  return { type: 0, tpuTopology: "", policyName: "" };
}

export const NodePool_PlacementPolicy: MessageFns<NodePool_PlacementPolicy> = {
  encode(message: NodePool_PlacementPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.tpuTopology !== "") {
      writer.uint32(18).string(message.tpuTopology);
    }
    if (message.policyName !== "") {
      writer.uint32(26).string(message.policyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_PlacementPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_PlacementPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tpuTopology = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_PlacementPolicy {
    return {
      type: isSet(object.type) ? nodePool_PlacementPolicy_TypeFromJSON(object.type) : 0,
      tpuTopology: isSet(object.tpuTopology) ? globalThis.String(object.tpuTopology) : "",
      policyName: isSet(object.policyName) ? globalThis.String(object.policyName) : "",
    };
  },

  toJSON(message: NodePool_PlacementPolicy): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = nodePool_PlacementPolicy_TypeToJSON(message.type);
    }
    if (message.tpuTopology !== "") {
      obj.tpuTopology = message.tpuTopology;
    }
    if (message.policyName !== "") {
      obj.policyName = message.policyName;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_PlacementPolicy>): NodePool_PlacementPolicy {
    return NodePool_PlacementPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_PlacementPolicy>): NodePool_PlacementPolicy {
    const message = createBaseNodePool_PlacementPolicy();
    message.type = object.type ?? 0;
    message.tpuTopology = object.tpuTopology ?? "";
    message.policyName = object.policyName ?? "";
    return message;
  },
};

function createBaseNodePool_QueuedProvisioning(): NodePool_QueuedProvisioning {
  return { enabled: false };
}

export const NodePool_QueuedProvisioning: MessageFns<NodePool_QueuedProvisioning> = {
  encode(message: NodePool_QueuedProvisioning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePool_QueuedProvisioning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePool_QueuedProvisioning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePool_QueuedProvisioning {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: NodePool_QueuedProvisioning): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NodePool_QueuedProvisioning>): NodePool_QueuedProvisioning {
    return NodePool_QueuedProvisioning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePool_QueuedProvisioning>): NodePool_QueuedProvisioning {
    const message = createBaseNodePool_QueuedProvisioning();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseNodeManagement(): NodeManagement {
  return { autoUpgrade: false, autoRepair: false, upgradeOptions: undefined };
}

export const NodeManagement: MessageFns<NodeManagement> = {
  encode(message: NodeManagement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoUpgrade !== false) {
      writer.uint32(8).bool(message.autoUpgrade);
    }
    if (message.autoRepair !== false) {
      writer.uint32(16).bool(message.autoRepair);
    }
    if (message.upgradeOptions !== undefined) {
      AutoUpgradeOptions.encode(message.upgradeOptions, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeManagement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeManagement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.autoUpgrade = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.autoRepair = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.upgradeOptions = AutoUpgradeOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeManagement {
    return {
      autoUpgrade: isSet(object.autoUpgrade) ? globalThis.Boolean(object.autoUpgrade) : false,
      autoRepair: isSet(object.autoRepair) ? globalThis.Boolean(object.autoRepair) : false,
      upgradeOptions: isSet(object.upgradeOptions) ? AutoUpgradeOptions.fromJSON(object.upgradeOptions) : undefined,
    };
  },

  toJSON(message: NodeManagement): unknown {
    const obj: any = {};
    if (message.autoUpgrade !== false) {
      obj.autoUpgrade = message.autoUpgrade;
    }
    if (message.autoRepair !== false) {
      obj.autoRepair = message.autoRepair;
    }
    if (message.upgradeOptions !== undefined) {
      obj.upgradeOptions = AutoUpgradeOptions.toJSON(message.upgradeOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeManagement>): NodeManagement {
    return NodeManagement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeManagement>): NodeManagement {
    const message = createBaseNodeManagement();
    message.autoUpgrade = object.autoUpgrade ?? false;
    message.autoRepair = object.autoRepair ?? false;
    message.upgradeOptions = (object.upgradeOptions !== undefined && object.upgradeOptions !== null)
      ? AutoUpgradeOptions.fromPartial(object.upgradeOptions)
      : undefined;
    return message;
  },
};

function createBaseBestEffortProvisioning(): BestEffortProvisioning {
  return { enabled: false, minProvisionNodes: 0 };
}

export const BestEffortProvisioning: MessageFns<BestEffortProvisioning> = {
  encode(message: BestEffortProvisioning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.minProvisionNodes !== 0) {
      writer.uint32(16).int32(message.minProvisionNodes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BestEffortProvisioning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBestEffortProvisioning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minProvisionNodes = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BestEffortProvisioning {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      minProvisionNodes: isSet(object.minProvisionNodes) ? globalThis.Number(object.minProvisionNodes) : 0,
    };
  },

  toJSON(message: BestEffortProvisioning): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.minProvisionNodes !== 0) {
      obj.minProvisionNodes = Math.round(message.minProvisionNodes);
    }
    return obj;
  },

  create(base?: DeepPartial<BestEffortProvisioning>): BestEffortProvisioning {
    return BestEffortProvisioning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BestEffortProvisioning>): BestEffortProvisioning {
    const message = createBaseBestEffortProvisioning();
    message.enabled = object.enabled ?? false;
    message.minProvisionNodes = object.minProvisionNodes ?? 0;
    return message;
  },
};

function createBaseAutoUpgradeOptions(): AutoUpgradeOptions {
  return { autoUpgradeStartTime: "", description: "" };
}

export const AutoUpgradeOptions: MessageFns<AutoUpgradeOptions> = {
  encode(message: AutoUpgradeOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.autoUpgradeStartTime !== "") {
      writer.uint32(10).string(message.autoUpgradeStartTime);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoUpgradeOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoUpgradeOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.autoUpgradeStartTime = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoUpgradeOptions {
    return {
      autoUpgradeStartTime: isSet(object.autoUpgradeStartTime) ? globalThis.String(object.autoUpgradeStartTime) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: AutoUpgradeOptions): unknown {
    const obj: any = {};
    if (message.autoUpgradeStartTime !== "") {
      obj.autoUpgradeStartTime = message.autoUpgradeStartTime;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoUpgradeOptions>): AutoUpgradeOptions {
    return AutoUpgradeOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoUpgradeOptions>): AutoUpgradeOptions {
    const message = createBaseAutoUpgradeOptions();
    message.autoUpgradeStartTime = object.autoUpgradeStartTime ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseMaintenancePolicy(): MaintenancePolicy {
  return { window: undefined, resourceVersion: "" };
}

export const MaintenancePolicy: MessageFns<MaintenancePolicy> = {
  encode(message: MaintenancePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      MaintenanceWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    if (message.resourceVersion !== "") {
      writer.uint32(26).string(message.resourceVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenancePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenancePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = MaintenanceWindow.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenancePolicy {
    return {
      window: isSet(object.window) ? MaintenanceWindow.fromJSON(object.window) : undefined,
      resourceVersion: isSet(object.resourceVersion) ? globalThis.String(object.resourceVersion) : "",
    };
  },

  toJSON(message: MaintenancePolicy): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = MaintenanceWindow.toJSON(message.window);
    }
    if (message.resourceVersion !== "") {
      obj.resourceVersion = message.resourceVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    return MaintenancePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenancePolicy>): MaintenancePolicy {
    const message = createBaseMaintenancePolicy();
    message.window = (object.window !== undefined && object.window !== null)
      ? MaintenanceWindow.fromPartial(object.window)
      : undefined;
    message.resourceVersion = object.resourceVersion ?? "";
    return message;
  },
};

function createBaseMaintenanceWindow(): MaintenanceWindow {
  return { dailyMaintenanceWindow: undefined, recurringWindow: undefined, maintenanceExclusions: {} };
}

export const MaintenanceWindow: MessageFns<MaintenanceWindow> = {
  encode(message: MaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dailyMaintenanceWindow !== undefined) {
      DailyMaintenanceWindow.encode(message.dailyMaintenanceWindow, writer.uint32(18).fork()).join();
    }
    if (message.recurringWindow !== undefined) {
      RecurringTimeWindow.encode(message.recurringWindow, writer.uint32(26).fork()).join();
    }
    Object.entries(message.maintenanceExclusions).forEach(([key, value]) => {
      MaintenanceWindow_MaintenanceExclusionsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dailyMaintenanceWindow = DailyMaintenanceWindow.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.recurringWindow = RecurringTimeWindow.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = MaintenanceWindow_MaintenanceExclusionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.maintenanceExclusions[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceWindow {
    return {
      dailyMaintenanceWindow: isSet(object.dailyMaintenanceWindow)
        ? DailyMaintenanceWindow.fromJSON(object.dailyMaintenanceWindow)
        : undefined,
      recurringWindow: isSet(object.recurringWindow) ? RecurringTimeWindow.fromJSON(object.recurringWindow) : undefined,
      maintenanceExclusions: isObject(object.maintenanceExclusions)
        ? Object.entries(object.maintenanceExclusions).reduce<{ [key: string]: TimeWindow }>((acc, [key, value]) => {
          acc[key] = TimeWindow.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MaintenanceWindow): unknown {
    const obj: any = {};
    if (message.dailyMaintenanceWindow !== undefined) {
      obj.dailyMaintenanceWindow = DailyMaintenanceWindow.toJSON(message.dailyMaintenanceWindow);
    }
    if (message.recurringWindow !== undefined) {
      obj.recurringWindow = RecurringTimeWindow.toJSON(message.recurringWindow);
    }
    if (message.maintenanceExclusions) {
      const entries = Object.entries(message.maintenanceExclusions);
      if (entries.length > 0) {
        obj.maintenanceExclusions = {};
        entries.forEach(([k, v]) => {
          obj.maintenanceExclusions[k] = TimeWindow.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    return MaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenanceWindow>): MaintenanceWindow {
    const message = createBaseMaintenanceWindow();
    message.dailyMaintenanceWindow =
      (object.dailyMaintenanceWindow !== undefined && object.dailyMaintenanceWindow !== null)
        ? DailyMaintenanceWindow.fromPartial(object.dailyMaintenanceWindow)
        : undefined;
    message.recurringWindow = (object.recurringWindow !== undefined && object.recurringWindow !== null)
      ? RecurringTimeWindow.fromPartial(object.recurringWindow)
      : undefined;
    message.maintenanceExclusions = Object.entries(object.maintenanceExclusions ?? {}).reduce<
      { [key: string]: TimeWindow }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = TimeWindow.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMaintenanceWindow_MaintenanceExclusionsEntry(): MaintenanceWindow_MaintenanceExclusionsEntry {
  return { key: "", value: undefined };
}

export const MaintenanceWindow_MaintenanceExclusionsEntry: MessageFns<MaintenanceWindow_MaintenanceExclusionsEntry> = {
  encode(
    message: MaintenanceWindow_MaintenanceExclusionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TimeWindow.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceWindow_MaintenanceExclusionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceWindow_MaintenanceExclusionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = TimeWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceWindow_MaintenanceExclusionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TimeWindow.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: MaintenanceWindow_MaintenanceExclusionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TimeWindow.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<MaintenanceWindow_MaintenanceExclusionsEntry>,
  ): MaintenanceWindow_MaintenanceExclusionsEntry {
    return MaintenanceWindow_MaintenanceExclusionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<MaintenanceWindow_MaintenanceExclusionsEntry>,
  ): MaintenanceWindow_MaintenanceExclusionsEntry {
    const message = createBaseMaintenanceWindow_MaintenanceExclusionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TimeWindow.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return { maintenanceExclusionOptions: undefined, startTime: undefined, endTime: undefined };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maintenanceExclusionOptions !== undefined) {
      MaintenanceExclusionOptions.encode(message.maintenanceExclusionOptions, writer.uint32(26).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maintenanceExclusionOptions = MaintenanceExclusionOptions.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      maintenanceExclusionOptions: isSet(object.maintenanceExclusionOptions)
        ? MaintenanceExclusionOptions.fromJSON(object.maintenanceExclusionOptions)
        : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.maintenanceExclusionOptions !== undefined) {
      obj.maintenanceExclusionOptions = MaintenanceExclusionOptions.toJSON(message.maintenanceExclusionOptions);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.maintenanceExclusionOptions =
      (object.maintenanceExclusionOptions !== undefined && object.maintenanceExclusionOptions !== null)
        ? MaintenanceExclusionOptions.fromPartial(object.maintenanceExclusionOptions)
        : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseMaintenanceExclusionOptions(): MaintenanceExclusionOptions {
  return { scope: 0 };
}

export const MaintenanceExclusionOptions: MessageFns<MaintenanceExclusionOptions> = {
  encode(message: MaintenanceExclusionOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== 0) {
      writer.uint32(8).int32(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaintenanceExclusionOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaintenanceExclusionOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaintenanceExclusionOptions {
    return { scope: isSet(object.scope) ? maintenanceExclusionOptions_ScopeFromJSON(object.scope) : 0 };
  },

  toJSON(message: MaintenanceExclusionOptions): unknown {
    const obj: any = {};
    if (message.scope !== 0) {
      obj.scope = maintenanceExclusionOptions_ScopeToJSON(message.scope);
    }
    return obj;
  },

  create(base?: DeepPartial<MaintenanceExclusionOptions>): MaintenanceExclusionOptions {
    return MaintenanceExclusionOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaintenanceExclusionOptions>): MaintenanceExclusionOptions {
    const message = createBaseMaintenanceExclusionOptions();
    message.scope = object.scope ?? 0;
    return message;
  },
};

function createBaseRecurringTimeWindow(): RecurringTimeWindow {
  return { window: undefined, recurrence: "" };
}

export const RecurringTimeWindow: MessageFns<RecurringTimeWindow> = {
  encode(message: RecurringTimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      TimeWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    if (message.recurrence !== "") {
      writer.uint32(18).string(message.recurrence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurringTimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurringTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = TimeWindow.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recurrence = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecurringTimeWindow {
    return {
      window: isSet(object.window) ? TimeWindow.fromJSON(object.window) : undefined,
      recurrence: isSet(object.recurrence) ? globalThis.String(object.recurrence) : "",
    };
  },

  toJSON(message: RecurringTimeWindow): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = TimeWindow.toJSON(message.window);
    }
    if (message.recurrence !== "") {
      obj.recurrence = message.recurrence;
    }
    return obj;
  },

  create(base?: DeepPartial<RecurringTimeWindow>): RecurringTimeWindow {
    return RecurringTimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecurringTimeWindow>): RecurringTimeWindow {
    const message = createBaseRecurringTimeWindow();
    message.window = (object.window !== undefined && object.window !== null)
      ? TimeWindow.fromPartial(object.window)
      : undefined;
    message.recurrence = object.recurrence ?? "";
    return message;
  },
};

function createBaseDailyMaintenanceWindow(): DailyMaintenanceWindow {
  return { startTime: "", duration: "" };
}

export const DailyMaintenanceWindow: MessageFns<DailyMaintenanceWindow> = {
  encode(message: DailyMaintenanceWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== "") {
      writer.uint32(18).string(message.startTime);
    }
    if (message.duration !== "") {
      writer.uint32(26).string(message.duration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyMaintenanceWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyMaintenanceWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DailyMaintenanceWindow {
    return {
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      duration: isSet(object.duration) ? globalThis.String(object.duration) : "",
    };
  },

  toJSON(message: DailyMaintenanceWindow): unknown {
    const obj: any = {};
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.duration !== "") {
      obj.duration = message.duration;
    }
    return obj;
  },

  create(base?: DeepPartial<DailyMaintenanceWindow>): DailyMaintenanceWindow {
    return DailyMaintenanceWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DailyMaintenanceWindow>): DailyMaintenanceWindow {
    const message = createBaseDailyMaintenanceWindow();
    message.startTime = object.startTime ?? "";
    message.duration = object.duration ?? "";
    return message;
  },
};

function createBaseSetNodePoolManagementRequest(): SetNodePoolManagementRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", management: undefined, name: "" };
}

export const SetNodePoolManagementRequest: MessageFns<SetNodePoolManagementRequest> = {
  encode(message: SetNodePoolManagementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.management !== undefined) {
      NodeManagement.encode(message.management, writer.uint32(42).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolManagementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolManagementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.management = NodeManagement.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolManagementRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      management: isSet(object.management) ? NodeManagement.fromJSON(object.management) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolManagementRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.management !== undefined) {
      obj.management = NodeManagement.toJSON(message.management);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolManagementRequest>): SetNodePoolManagementRequest {
    return SetNodePoolManagementRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolManagementRequest>): SetNodePoolManagementRequest {
    const message = createBaseSetNodePoolManagementRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.management = (object.management !== undefined && object.management !== null)
      ? NodeManagement.fromPartial(object.management)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetNodePoolSizeRequest(): SetNodePoolSizeRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", nodeCount: 0, name: "" };
}

export const SetNodePoolSizeRequest: MessageFns<SetNodePoolSizeRequest> = {
  encode(message: SetNodePoolSizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(40).int32(message.nodeCount);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNodePoolSizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNodePoolSizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNodePoolSizeRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNodePoolSizeRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNodePoolSizeRequest>): SetNodePoolSizeRequest {
    return SetNodePoolSizeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNodePoolSizeRequest>): SetNodePoolSizeRequest {
    const message = createBaseSetNodePoolSizeRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.nodeCount = object.nodeCount ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCompleteNodePoolUpgradeRequest(): CompleteNodePoolUpgradeRequest {
  return { name: "" };
}

export const CompleteNodePoolUpgradeRequest: MessageFns<CompleteNodePoolUpgradeRequest> = {
  encode(message: CompleteNodePoolUpgradeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteNodePoolUpgradeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteNodePoolUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteNodePoolUpgradeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CompleteNodePoolUpgradeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteNodePoolUpgradeRequest>): CompleteNodePoolUpgradeRequest {
    return CompleteNodePoolUpgradeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteNodePoolUpgradeRequest>): CompleteNodePoolUpgradeRequest {
    const message = createBaseCompleteNodePoolUpgradeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRollbackNodePoolUpgradeRequest(): RollbackNodePoolUpgradeRequest {
  return { projectId: "", zone: "", clusterId: "", nodePoolId: "", name: "", respectPdb: false };
}

export const RollbackNodePoolUpgradeRequest: MessageFns<RollbackNodePoolUpgradeRequest> = {
  encode(message: RollbackNodePoolUpgradeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.nodePoolId !== "") {
      writer.uint32(34).string(message.nodePoolId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.respectPdb !== false) {
      writer.uint32(56).bool(message.respectPdb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackNodePoolUpgradeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackNodePoolUpgradeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodePoolId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.respectPdb = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackNodePoolUpgradeRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodePoolId: isSet(object.nodePoolId) ? globalThis.String(object.nodePoolId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      respectPdb: isSet(object.respectPdb) ? globalThis.Boolean(object.respectPdb) : false,
    };
  },

  toJSON(message: RollbackNodePoolUpgradeRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodePoolId !== "") {
      obj.nodePoolId = message.nodePoolId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.respectPdb !== false) {
      obj.respectPdb = message.respectPdb;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackNodePoolUpgradeRequest>): RollbackNodePoolUpgradeRequest {
    return RollbackNodePoolUpgradeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackNodePoolUpgradeRequest>): RollbackNodePoolUpgradeRequest {
    const message = createBaseRollbackNodePoolUpgradeRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.nodePoolId = object.nodePoolId ?? "";
    message.name = object.name ?? "";
    message.respectPdb = object.respectPdb ?? false;
    return message;
  },
};

function createBaseListNodePoolsResponse(): ListNodePoolsResponse {
  return { nodePools: [] };
}

export const ListNodePoolsResponse: MessageFns<ListNodePoolsResponse> = {
  encode(message: ListNodePoolsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodePools) {
      NodePool.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodePoolsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodePoolsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodePools.push(NodePool.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodePoolsResponse {
    return {
      nodePools: globalThis.Array.isArray(object?.nodePools)
        ? object.nodePools.map((e: any) => NodePool.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListNodePoolsResponse): unknown {
    const obj: any = {};
    if (message.nodePools?.length) {
      obj.nodePools = message.nodePools.map((e) => NodePool.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodePoolsResponse>): ListNodePoolsResponse {
    return ListNodePoolsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodePoolsResponse>): ListNodePoolsResponse {
    const message = createBaseListNodePoolsResponse();
    message.nodePools = object.nodePools?.map((e) => NodePool.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClusterAutoscaling(): ClusterAutoscaling {
  return {
    enableNodeAutoprovisioning: false,
    resourceLimits: [],
    autoscalingProfile: 0,
    autoprovisioningNodePoolDefaults: undefined,
    autoprovisioningLocations: [],
  };
}

export const ClusterAutoscaling: MessageFns<ClusterAutoscaling> = {
  encode(message: ClusterAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableNodeAutoprovisioning !== false) {
      writer.uint32(8).bool(message.enableNodeAutoprovisioning);
    }
    for (const v of message.resourceLimits) {
      ResourceLimit.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.autoscalingProfile !== 0) {
      writer.uint32(24).int32(message.autoscalingProfile);
    }
    if (message.autoprovisioningNodePoolDefaults !== undefined) {
      AutoprovisioningNodePoolDefaults.encode(message.autoprovisioningNodePoolDefaults, writer.uint32(34).fork())
        .join();
    }
    for (const v of message.autoprovisioningLocations) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableNodeAutoprovisioning = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceLimits.push(ResourceLimit.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.autoscalingProfile = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.autoprovisioningNodePoolDefaults = AutoprovisioningNodePoolDefaults.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.autoprovisioningLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterAutoscaling {
    return {
      enableNodeAutoprovisioning: isSet(object.enableNodeAutoprovisioning)
        ? globalThis.Boolean(object.enableNodeAutoprovisioning)
        : false,
      resourceLimits: globalThis.Array.isArray(object?.resourceLimits)
        ? object.resourceLimits.map((e: any) => ResourceLimit.fromJSON(e))
        : [],
      autoscalingProfile: isSet(object.autoscalingProfile)
        ? clusterAutoscaling_AutoscalingProfileFromJSON(object.autoscalingProfile)
        : 0,
      autoprovisioningNodePoolDefaults: isSet(object.autoprovisioningNodePoolDefaults)
        ? AutoprovisioningNodePoolDefaults.fromJSON(object.autoprovisioningNodePoolDefaults)
        : undefined,
      autoprovisioningLocations: globalThis.Array.isArray(object?.autoprovisioningLocations)
        ? object.autoprovisioningLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ClusterAutoscaling): unknown {
    const obj: any = {};
    if (message.enableNodeAutoprovisioning !== false) {
      obj.enableNodeAutoprovisioning = message.enableNodeAutoprovisioning;
    }
    if (message.resourceLimits?.length) {
      obj.resourceLimits = message.resourceLimits.map((e) => ResourceLimit.toJSON(e));
    }
    if (message.autoscalingProfile !== 0) {
      obj.autoscalingProfile = clusterAutoscaling_AutoscalingProfileToJSON(message.autoscalingProfile);
    }
    if (message.autoprovisioningNodePoolDefaults !== undefined) {
      obj.autoprovisioningNodePoolDefaults = AutoprovisioningNodePoolDefaults.toJSON(
        message.autoprovisioningNodePoolDefaults,
      );
    }
    if (message.autoprovisioningLocations?.length) {
      obj.autoprovisioningLocations = message.autoprovisioningLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ClusterAutoscaling>): ClusterAutoscaling {
    return ClusterAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClusterAutoscaling>): ClusterAutoscaling {
    const message = createBaseClusterAutoscaling();
    message.enableNodeAutoprovisioning = object.enableNodeAutoprovisioning ?? false;
    message.resourceLimits = object.resourceLimits?.map((e) => ResourceLimit.fromPartial(e)) || [];
    message.autoscalingProfile = object.autoscalingProfile ?? 0;
    message.autoprovisioningNodePoolDefaults =
      (object.autoprovisioningNodePoolDefaults !== undefined && object.autoprovisioningNodePoolDefaults !== null)
        ? AutoprovisioningNodePoolDefaults.fromPartial(object.autoprovisioningNodePoolDefaults)
        : undefined;
    message.autoprovisioningLocations = object.autoprovisioningLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseAutoprovisioningNodePoolDefaults(): AutoprovisioningNodePoolDefaults {
  return {
    oauthScopes: [],
    serviceAccount: "",
    upgradeSettings: undefined,
    management: undefined,
    minCpuPlatform: "",
    diskSizeGb: 0,
    diskType: "",
    shieldedInstanceConfig: undefined,
    bootDiskKmsKey: "",
    imageType: "",
    insecureKubeletReadonlyPortEnabled: undefined,
  };
}

export const AutoprovisioningNodePoolDefaults: MessageFns<AutoprovisioningNodePoolDefaults> = {
  encode(message: AutoprovisioningNodePoolDefaults, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.oauthScopes) {
      writer.uint32(10).string(v!);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(18).string(message.serviceAccount);
    }
    if (message.upgradeSettings !== undefined) {
      NodePool_UpgradeSettings.encode(message.upgradeSettings, writer.uint32(26).fork()).join();
    }
    if (message.management !== undefined) {
      NodeManagement.encode(message.management, writer.uint32(34).fork()).join();
    }
    if (message.minCpuPlatform !== "") {
      writer.uint32(42).string(message.minCpuPlatform);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(48).int32(message.diskSizeGb);
    }
    if (message.diskType !== "") {
      writer.uint32(58).string(message.diskType);
    }
    if (message.shieldedInstanceConfig !== undefined) {
      ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(66).fork()).join();
    }
    if (message.bootDiskKmsKey !== "") {
      writer.uint32(74).string(message.bootDiskKmsKey);
    }
    if (message.imageType !== "") {
      writer.uint32(82).string(message.imageType);
    }
    if (message.insecureKubeletReadonlyPortEnabled !== undefined) {
      writer.uint32(104).bool(message.insecureKubeletReadonlyPortEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoprovisioningNodePoolDefaults {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoprovisioningNodePoolDefaults();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.oauthScopes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.upgradeSettings = NodePool_UpgradeSettings.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.management = NodeManagement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.minCpuPlatform = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.shieldedInstanceConfig = ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.bootDiskKmsKey = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.imageType = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.insecureKubeletReadonlyPortEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoprovisioningNodePoolDefaults {
    return {
      oauthScopes: globalThis.Array.isArray(object?.oauthScopes)
        ? object.oauthScopes.map((e: any) => globalThis.String(e))
        : [],
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      upgradeSettings: isSet(object.upgradeSettings)
        ? NodePool_UpgradeSettings.fromJSON(object.upgradeSettings)
        : undefined,
      management: isSet(object.management) ? NodeManagement.fromJSON(object.management) : undefined,
      minCpuPlatform: isSet(object.minCpuPlatform) ? globalThis.String(object.minCpuPlatform) : "",
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      bootDiskKmsKey: isSet(object.bootDiskKmsKey) ? globalThis.String(object.bootDiskKmsKey) : "",
      imageType: isSet(object.imageType) ? globalThis.String(object.imageType) : "",
      insecureKubeletReadonlyPortEnabled: isSet(object.insecureKubeletReadonlyPortEnabled)
        ? globalThis.Boolean(object.insecureKubeletReadonlyPortEnabled)
        : undefined,
    };
  },

  toJSON(message: AutoprovisioningNodePoolDefaults): unknown {
    const obj: any = {};
    if (message.oauthScopes?.length) {
      obj.oauthScopes = message.oauthScopes;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.upgradeSettings !== undefined) {
      obj.upgradeSettings = NodePool_UpgradeSettings.toJSON(message.upgradeSettings);
    }
    if (message.management !== undefined) {
      obj.management = NodeManagement.toJSON(message.management);
    }
    if (message.minCpuPlatform !== "") {
      obj.minCpuPlatform = message.minCpuPlatform;
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.bootDiskKmsKey !== "") {
      obj.bootDiskKmsKey = message.bootDiskKmsKey;
    }
    if (message.imageType !== "") {
      obj.imageType = message.imageType;
    }
    if (message.insecureKubeletReadonlyPortEnabled !== undefined) {
      obj.insecureKubeletReadonlyPortEnabled = message.insecureKubeletReadonlyPortEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoprovisioningNodePoolDefaults>): AutoprovisioningNodePoolDefaults {
    return AutoprovisioningNodePoolDefaults.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoprovisioningNodePoolDefaults>): AutoprovisioningNodePoolDefaults {
    const message = createBaseAutoprovisioningNodePoolDefaults();
    message.oauthScopes = object.oauthScopes?.map((e) => e) || [];
    message.serviceAccount = object.serviceAccount ?? "";
    message.upgradeSettings = (object.upgradeSettings !== undefined && object.upgradeSettings !== null)
      ? NodePool_UpgradeSettings.fromPartial(object.upgradeSettings)
      : undefined;
    message.management = (object.management !== undefined && object.management !== null)
      ? NodeManagement.fromPartial(object.management)
      : undefined;
    message.minCpuPlatform = object.minCpuPlatform ?? "";
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.diskType = object.diskType ?? "";
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.bootDiskKmsKey = object.bootDiskKmsKey ?? "";
    message.imageType = object.imageType ?? "";
    message.insecureKubeletReadonlyPortEnabled = object.insecureKubeletReadonlyPortEnabled ?? undefined;
    return message;
  },
};

function createBaseResourceLimit(): ResourceLimit {
  return { resourceType: "", minimum: Long.ZERO, maximum: Long.ZERO };
}

export const ResourceLimit: MessageFns<ResourceLimit> = {
  encode(message: ResourceLimit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceType !== "") {
      writer.uint32(10).string(message.resourceType);
    }
    if (!message.minimum.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.minimum.toString());
    }
    if (!message.maximum.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.maximum.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLimit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minimum = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maximum = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLimit {
    return {
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      minimum: isSet(object.minimum) ? Long.fromValue(object.minimum) : Long.ZERO,
      maximum: isSet(object.maximum) ? Long.fromValue(object.maximum) : Long.ZERO,
    };
  },

  toJSON(message: ResourceLimit): unknown {
    const obj: any = {};
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (!message.minimum.equals(Long.ZERO)) {
      obj.minimum = (message.minimum || Long.ZERO).toString();
    }
    if (!message.maximum.equals(Long.ZERO)) {
      obj.maximum = (message.maximum || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceLimit>): ResourceLimit {
    return ResourceLimit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceLimit>): ResourceLimit {
    const message = createBaseResourceLimit();
    message.resourceType = object.resourceType ?? "";
    message.minimum = (object.minimum !== undefined && object.minimum !== null)
      ? Long.fromValue(object.minimum)
      : Long.ZERO;
    message.maximum = (object.maximum !== undefined && object.maximum !== null)
      ? Long.fromValue(object.maximum)
      : Long.ZERO;
    return message;
  },
};

function createBaseNodePoolAutoscaling(): NodePoolAutoscaling {
  return {
    enabled: false,
    minNodeCount: 0,
    maxNodeCount: 0,
    autoprovisioned: false,
    locationPolicy: 0,
    totalMinNodeCount: 0,
    totalMaxNodeCount: 0,
  };
}

export const NodePoolAutoscaling: MessageFns<NodePoolAutoscaling> = {
  encode(message: NodePoolAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.minNodeCount !== 0) {
      writer.uint32(16).int32(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      writer.uint32(24).int32(message.maxNodeCount);
    }
    if (message.autoprovisioned !== false) {
      writer.uint32(32).bool(message.autoprovisioned);
    }
    if (message.locationPolicy !== 0) {
      writer.uint32(40).int32(message.locationPolicy);
    }
    if (message.totalMinNodeCount !== 0) {
      writer.uint32(48).int32(message.totalMinNodeCount);
    }
    if (message.totalMaxNodeCount !== 0) {
      writer.uint32(56).int32(message.totalMaxNodeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePoolAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePoolAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minNodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.autoprovisioned = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.locationPolicy = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalMinNodeCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.totalMaxNodeCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePoolAutoscaling {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      minNodeCount: isSet(object.minNodeCount) ? globalThis.Number(object.minNodeCount) : 0,
      maxNodeCount: isSet(object.maxNodeCount) ? globalThis.Number(object.maxNodeCount) : 0,
      autoprovisioned: isSet(object.autoprovisioned) ? globalThis.Boolean(object.autoprovisioned) : false,
      locationPolicy: isSet(object.locationPolicy)
        ? nodePoolAutoscaling_LocationPolicyFromJSON(object.locationPolicy)
        : 0,
      totalMinNodeCount: isSet(object.totalMinNodeCount) ? globalThis.Number(object.totalMinNodeCount) : 0,
      totalMaxNodeCount: isSet(object.totalMaxNodeCount) ? globalThis.Number(object.totalMaxNodeCount) : 0,
    };
  },

  toJSON(message: NodePoolAutoscaling): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.minNodeCount !== 0) {
      obj.minNodeCount = Math.round(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      obj.maxNodeCount = Math.round(message.maxNodeCount);
    }
    if (message.autoprovisioned !== false) {
      obj.autoprovisioned = message.autoprovisioned;
    }
    if (message.locationPolicy !== 0) {
      obj.locationPolicy = nodePoolAutoscaling_LocationPolicyToJSON(message.locationPolicy);
    }
    if (message.totalMinNodeCount !== 0) {
      obj.totalMinNodeCount = Math.round(message.totalMinNodeCount);
    }
    if (message.totalMaxNodeCount !== 0) {
      obj.totalMaxNodeCount = Math.round(message.totalMaxNodeCount);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePoolAutoscaling>): NodePoolAutoscaling {
    return NodePoolAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePoolAutoscaling>): NodePoolAutoscaling {
    const message = createBaseNodePoolAutoscaling();
    message.enabled = object.enabled ?? false;
    message.minNodeCount = object.minNodeCount ?? 0;
    message.maxNodeCount = object.maxNodeCount ?? 0;
    message.autoprovisioned = object.autoprovisioned ?? false;
    message.locationPolicy = object.locationPolicy ?? 0;
    message.totalMinNodeCount = object.totalMinNodeCount ?? 0;
    message.totalMaxNodeCount = object.totalMaxNodeCount ?? 0;
    return message;
  },
};

function createBaseSetLabelsRequest(): SetLabelsRequest {
  return { projectId: "", zone: "", clusterId: "", resourceLabels: {}, labelFingerprint: "", name: "" };
}

export const SetLabelsRequest: MessageFns<SetLabelsRequest> = {
  encode(message: SetLabelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    Object.entries(message.resourceLabels).forEach(([key, value]) => {
      SetLabelsRequest_ResourceLabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.labelFingerprint !== "") {
      writer.uint32(42).string(message.labelFingerprint);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLabelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLabelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SetLabelsRequest_ResourceLabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.resourceLabels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.labelFingerprint = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLabelsRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      resourceLabels: isObject(object.resourceLabels)
        ? Object.entries(object.resourceLabels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      labelFingerprint: isSet(object.labelFingerprint) ? globalThis.String(object.labelFingerprint) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLabelsRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.resourceLabels) {
      const entries = Object.entries(message.resourceLabels);
      if (entries.length > 0) {
        obj.resourceLabels = {};
        entries.forEach(([k, v]) => {
          obj.resourceLabels[k] = v;
        });
      }
    }
    if (message.labelFingerprint !== "") {
      obj.labelFingerprint = message.labelFingerprint;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLabelsRequest>): SetLabelsRequest {
    return SetLabelsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLabelsRequest>): SetLabelsRequest {
    const message = createBaseSetLabelsRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.resourceLabels = Object.entries(object.resourceLabels ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.labelFingerprint = object.labelFingerprint ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetLabelsRequest_ResourceLabelsEntry(): SetLabelsRequest_ResourceLabelsEntry {
  return { key: "", value: "" };
}

export const SetLabelsRequest_ResourceLabelsEntry: MessageFns<SetLabelsRequest_ResourceLabelsEntry> = {
  encode(message: SetLabelsRequest_ResourceLabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLabelsRequest_ResourceLabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLabelsRequest_ResourceLabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLabelsRequest_ResourceLabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetLabelsRequest_ResourceLabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLabelsRequest_ResourceLabelsEntry>): SetLabelsRequest_ResourceLabelsEntry {
    return SetLabelsRequest_ResourceLabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLabelsRequest_ResourceLabelsEntry>): SetLabelsRequest_ResourceLabelsEntry {
    const message = createBaseSetLabelsRequest_ResourceLabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetLegacyAbacRequest(): SetLegacyAbacRequest {
  return { projectId: "", zone: "", clusterId: "", enabled: false, name: "" };
}

export const SetLegacyAbacRequest: MessageFns<SetLegacyAbacRequest> = {
  encode(message: SetLegacyAbacRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.enabled !== false) {
      writer.uint32(32).bool(message.enabled);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetLegacyAbacRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetLegacyAbacRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetLegacyAbacRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetLegacyAbacRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetLegacyAbacRequest>): SetLegacyAbacRequest {
    return SetLegacyAbacRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetLegacyAbacRequest>): SetLegacyAbacRequest {
    const message = createBaseSetLegacyAbacRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.enabled = object.enabled ?? false;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartIPRotationRequest(): StartIPRotationRequest {
  return { projectId: "", zone: "", clusterId: "", name: "", rotateCredentials: false };
}

export const StartIPRotationRequest: MessageFns<StartIPRotationRequest> = {
  encode(message: StartIPRotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.rotateCredentials !== false) {
      writer.uint32(56).bool(message.rotateCredentials);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartIPRotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartIPRotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.rotateCredentials = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartIPRotationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rotateCredentials: isSet(object.rotateCredentials) ? globalThis.Boolean(object.rotateCredentials) : false,
    };
  },

  toJSON(message: StartIPRotationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rotateCredentials !== false) {
      obj.rotateCredentials = message.rotateCredentials;
    }
    return obj;
  },

  create(base?: DeepPartial<StartIPRotationRequest>): StartIPRotationRequest {
    return StartIPRotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartIPRotationRequest>): StartIPRotationRequest {
    const message = createBaseStartIPRotationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    message.rotateCredentials = object.rotateCredentials ?? false;
    return message;
  },
};

function createBaseCompleteIPRotationRequest(): CompleteIPRotationRequest {
  return { projectId: "", zone: "", clusterId: "", name: "" };
}

export const CompleteIPRotationRequest: MessageFns<CompleteIPRotationRequest> = {
  encode(message: CompleteIPRotationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteIPRotationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteIPRotationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteIPRotationRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CompleteIPRotationRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteIPRotationRequest>): CompleteIPRotationRequest {
    return CompleteIPRotationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteIPRotationRequest>): CompleteIPRotationRequest {
    const message = createBaseCompleteIPRotationRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return {
    acceleratorCount: Long.ZERO,
    acceleratorType: "",
    gpuPartitionSize: "",
    gpuSharingConfig: undefined,
    gpuDriverInstallationConfig: undefined,
  };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.acceleratorCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.acceleratorCount.toString());
    }
    if (message.acceleratorType !== "") {
      writer.uint32(18).string(message.acceleratorType);
    }
    if (message.gpuPartitionSize !== "") {
      writer.uint32(26).string(message.gpuPartitionSize);
    }
    if (message.gpuSharingConfig !== undefined) {
      GPUSharingConfig.encode(message.gpuSharingConfig, writer.uint32(42).fork()).join();
    }
    if (message.gpuDriverInstallationConfig !== undefined) {
      GPUDriverInstallationConfig.encode(message.gpuDriverInstallationConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acceleratorCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gpuPartitionSize = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gpuSharingConfig = GPUSharingConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gpuDriverInstallationConfig = GPUDriverInstallationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      acceleratorCount: isSet(object.acceleratorCount) ? Long.fromValue(object.acceleratorCount) : Long.ZERO,
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : "",
      gpuPartitionSize: isSet(object.gpuPartitionSize) ? globalThis.String(object.gpuPartitionSize) : "",
      gpuSharingConfig: isSet(object.gpuSharingConfig) ? GPUSharingConfig.fromJSON(object.gpuSharingConfig) : undefined,
      gpuDriverInstallationConfig: isSet(object.gpuDriverInstallationConfig)
        ? GPUDriverInstallationConfig.fromJSON(object.gpuDriverInstallationConfig)
        : undefined,
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (!message.acceleratorCount.equals(Long.ZERO)) {
      obj.acceleratorCount = (message.acceleratorCount || Long.ZERO).toString();
    }
    if (message.acceleratorType !== "") {
      obj.acceleratorType = message.acceleratorType;
    }
    if (message.gpuPartitionSize !== "") {
      obj.gpuPartitionSize = message.gpuPartitionSize;
    }
    if (message.gpuSharingConfig !== undefined) {
      obj.gpuSharingConfig = GPUSharingConfig.toJSON(message.gpuSharingConfig);
    }
    if (message.gpuDriverInstallationConfig !== undefined) {
      obj.gpuDriverInstallationConfig = GPUDriverInstallationConfig.toJSON(message.gpuDriverInstallationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.acceleratorCount = (object.acceleratorCount !== undefined && object.acceleratorCount !== null)
      ? Long.fromValue(object.acceleratorCount)
      : Long.ZERO;
    message.acceleratorType = object.acceleratorType ?? "";
    message.gpuPartitionSize = object.gpuPartitionSize ?? "";
    message.gpuSharingConfig = (object.gpuSharingConfig !== undefined && object.gpuSharingConfig !== null)
      ? GPUSharingConfig.fromPartial(object.gpuSharingConfig)
      : undefined;
    message.gpuDriverInstallationConfig =
      (object.gpuDriverInstallationConfig !== undefined && object.gpuDriverInstallationConfig !== null)
        ? GPUDriverInstallationConfig.fromPartial(object.gpuDriverInstallationConfig)
        : undefined;
    return message;
  },
};

function createBaseGPUSharingConfig(): GPUSharingConfig {
  return { maxSharedClientsPerGpu: Long.ZERO, gpuSharingStrategy: undefined };
}

export const GPUSharingConfig: MessageFns<GPUSharingConfig> = {
  encode(message: GPUSharingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxSharedClientsPerGpu.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.maxSharedClientsPerGpu.toString());
    }
    if (message.gpuSharingStrategy !== undefined) {
      writer.uint32(16).int32(message.gpuSharingStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPUSharingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPUSharingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxSharedClientsPerGpu = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.gpuSharingStrategy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPUSharingConfig {
    return {
      maxSharedClientsPerGpu: isSet(object.maxSharedClientsPerGpu)
        ? Long.fromValue(object.maxSharedClientsPerGpu)
        : Long.ZERO,
      gpuSharingStrategy: isSet(object.gpuSharingStrategy)
        ? gPUSharingConfig_GPUSharingStrategyFromJSON(object.gpuSharingStrategy)
        : undefined,
    };
  },

  toJSON(message: GPUSharingConfig): unknown {
    const obj: any = {};
    if (!message.maxSharedClientsPerGpu.equals(Long.ZERO)) {
      obj.maxSharedClientsPerGpu = (message.maxSharedClientsPerGpu || Long.ZERO).toString();
    }
    if (message.gpuSharingStrategy !== undefined) {
      obj.gpuSharingStrategy = gPUSharingConfig_GPUSharingStrategyToJSON(message.gpuSharingStrategy);
    }
    return obj;
  },

  create(base?: DeepPartial<GPUSharingConfig>): GPUSharingConfig {
    return GPUSharingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GPUSharingConfig>): GPUSharingConfig {
    const message = createBaseGPUSharingConfig();
    message.maxSharedClientsPerGpu =
      (object.maxSharedClientsPerGpu !== undefined && object.maxSharedClientsPerGpu !== null)
        ? Long.fromValue(object.maxSharedClientsPerGpu)
        : Long.ZERO;
    message.gpuSharingStrategy = object.gpuSharingStrategy ?? undefined;
    return message;
  },
};

function createBaseGPUDriverInstallationConfig(): GPUDriverInstallationConfig {
  return { gpuDriverVersion: undefined };
}

export const GPUDriverInstallationConfig: MessageFns<GPUDriverInstallationConfig> = {
  encode(message: GPUDriverInstallationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gpuDriverVersion !== undefined) {
      writer.uint32(8).int32(message.gpuDriverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GPUDriverInstallationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGPUDriverInstallationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.gpuDriverVersion = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GPUDriverInstallationConfig {
    return {
      gpuDriverVersion: isSet(object.gpuDriverVersion)
        ? gPUDriverInstallationConfig_GPUDriverVersionFromJSON(object.gpuDriverVersion)
        : undefined,
    };
  },

  toJSON(message: GPUDriverInstallationConfig): unknown {
    const obj: any = {};
    if (message.gpuDriverVersion !== undefined) {
      obj.gpuDriverVersion = gPUDriverInstallationConfig_GPUDriverVersionToJSON(message.gpuDriverVersion);
    }
    return obj;
  },

  create(base?: DeepPartial<GPUDriverInstallationConfig>): GPUDriverInstallationConfig {
    return GPUDriverInstallationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GPUDriverInstallationConfig>): GPUDriverInstallationConfig {
    const message = createBaseGPUDriverInstallationConfig();
    message.gpuDriverVersion = object.gpuDriverVersion ?? undefined;
    return message;
  },
};

function createBaseWorkloadMetadataConfig(): WorkloadMetadataConfig {
  return { mode: 0 };
}

export const WorkloadMetadataConfig: MessageFns<WorkloadMetadataConfig> = {
  encode(message: WorkloadMetadataConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(16).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadMetadataConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadMetadataConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadMetadataConfig {
    return { mode: isSet(object.mode) ? workloadMetadataConfig_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: WorkloadMetadataConfig): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = workloadMetadataConfig_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadMetadataConfig>): WorkloadMetadataConfig {
    return WorkloadMetadataConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadMetadataConfig>): WorkloadMetadataConfig {
    const message = createBaseWorkloadMetadataConfig();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSetNetworkPolicyRequest(): SetNetworkPolicyRequest {
  return { projectId: "", zone: "", clusterId: "", networkPolicy: undefined, name: "" };
}

export const SetNetworkPolicyRequest: MessageFns<SetNetworkPolicyRequest> = {
  encode(message: SetNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetNetworkPolicyRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetNetworkPolicyRequest>): SetNetworkPolicyRequest {
    return SetNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetNetworkPolicyRequest>): SetNetworkPolicyRequest {
    const message = createBaseSetNetworkPolicyRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSetMaintenancePolicyRequest(): SetMaintenancePolicyRequest {
  return { projectId: "", zone: "", clusterId: "", maintenancePolicy: undefined, name: "" };
}

export const SetMaintenancePolicyRequest: MessageFns<SetMaintenancePolicyRequest> = {
  encode(message: SetMaintenancePolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.maintenancePolicy !== undefined) {
      MaintenancePolicy.encode(message.maintenancePolicy, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetMaintenancePolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMaintenancePolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maintenancePolicy = MaintenancePolicy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMaintenancePolicyRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      maintenancePolicy: isSet(object.maintenancePolicy)
        ? MaintenancePolicy.fromJSON(object.maintenancePolicy)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: SetMaintenancePolicyRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.maintenancePolicy !== undefined) {
      obj.maintenancePolicy = MaintenancePolicy.toJSON(message.maintenancePolicy);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMaintenancePolicyRequest>): SetMaintenancePolicyRequest {
    return SetMaintenancePolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMaintenancePolicyRequest>): SetMaintenancePolicyRequest {
    const message = createBaseSetMaintenancePolicyRequest();
    message.projectId = object.projectId ?? "";
    message.zone = object.zone ?? "";
    message.clusterId = object.clusterId ?? "";
    message.maintenancePolicy = (object.maintenancePolicy !== undefined && object.maintenancePolicy !== null)
      ? MaintenancePolicy.fromPartial(object.maintenancePolicy)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStatusCondition(): StatusCondition {
  return { code: 0, message: "", canonicalCode: 0 };
}

export const StatusCondition: MessageFns<StatusCondition> = {
  encode(message: StatusCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.canonicalCode !== 0) {
      writer.uint32(24).int32(message.canonicalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canonicalCode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusCondition {
    return {
      code: isSet(object.code) ? statusCondition_CodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      canonicalCode: isSet(object.canonicalCode) ? codeFromJSON(object.canonicalCode) : 0,
    };
  },

  toJSON(message: StatusCondition): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = statusCondition_CodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.canonicalCode !== 0) {
      obj.canonicalCode = codeToJSON(message.canonicalCode);
    }
    return obj;
  },

  create(base?: DeepPartial<StatusCondition>): StatusCondition {
    return StatusCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StatusCondition>): StatusCondition {
    const message = createBaseStatusCondition();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.canonicalCode = object.canonicalCode ?? 0;
    return message;
  },
};

function createBaseNetworkConfig(): NetworkConfig {
  return {
    network: "",
    subnetwork: "",
    enableIntraNodeVisibility: false,
    defaultSnatStatus: undefined,
    enableL4ilbSubsetting: false,
    datapathProvider: 0,
    privateIpv6GoogleAccess: 0,
    dnsConfig: undefined,
    serviceExternalIpsConfig: undefined,
    gatewayApiConfig: undefined,
    enableMultiNetworking: false,
    networkPerformanceConfig: undefined,
    enableFqdnNetworkPolicy: undefined,
    inTransitEncryptionConfig: undefined,
    enableCiliumClusterwideNetworkPolicy: undefined,
  };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    if (message.enableIntraNodeVisibility !== false) {
      writer.uint32(40).bool(message.enableIntraNodeVisibility);
    }
    if (message.defaultSnatStatus !== undefined) {
      DefaultSnatStatus.encode(message.defaultSnatStatus, writer.uint32(58).fork()).join();
    }
    if (message.enableL4ilbSubsetting !== false) {
      writer.uint32(80).bool(message.enableL4ilbSubsetting);
    }
    if (message.datapathProvider !== 0) {
      writer.uint32(88).int32(message.datapathProvider);
    }
    if (message.privateIpv6GoogleAccess !== 0) {
      writer.uint32(96).int32(message.privateIpv6GoogleAccess);
    }
    if (message.dnsConfig !== undefined) {
      DNSConfig.encode(message.dnsConfig, writer.uint32(106).fork()).join();
    }
    if (message.serviceExternalIpsConfig !== undefined) {
      ServiceExternalIPsConfig.encode(message.serviceExternalIpsConfig, writer.uint32(122).fork()).join();
    }
    if (message.gatewayApiConfig !== undefined) {
      GatewayAPIConfig.encode(message.gatewayApiConfig, writer.uint32(130).fork()).join();
    }
    if (message.enableMultiNetworking !== false) {
      writer.uint32(136).bool(message.enableMultiNetworking);
    }
    if (message.networkPerformanceConfig !== undefined) {
      NetworkConfig_ClusterNetworkPerformanceConfig.encode(message.networkPerformanceConfig, writer.uint32(146).fork())
        .join();
    }
    if (message.enableFqdnNetworkPolicy !== undefined) {
      writer.uint32(152).bool(message.enableFqdnNetworkPolicy);
    }
    if (message.inTransitEncryptionConfig !== undefined) {
      writer.uint32(160).int32(message.inTransitEncryptionConfig);
    }
    if (message.enableCiliumClusterwideNetworkPolicy !== undefined) {
      writer.uint32(168).bool(message.enableCiliumClusterwideNetworkPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableIntraNodeVisibility = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultSnatStatus = DefaultSnatStatus.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.enableL4ilbSubsetting = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.datapathProvider = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.privateIpv6GoogleAccess = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.dnsConfig = DNSConfig.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.serviceExternalIpsConfig = ServiceExternalIPsConfig.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.gatewayApiConfig = GatewayAPIConfig.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.enableMultiNetworking = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.networkPerformanceConfig = NetworkConfig_ClusterNetworkPerformanceConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.enableFqdnNetworkPolicy = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.inTransitEncryptionConfig = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.enableCiliumClusterwideNetworkPolicy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      enableIntraNodeVisibility: isSet(object.enableIntraNodeVisibility)
        ? globalThis.Boolean(object.enableIntraNodeVisibility)
        : false,
      defaultSnatStatus: isSet(object.defaultSnatStatus)
        ? DefaultSnatStatus.fromJSON(object.defaultSnatStatus)
        : undefined,
      enableL4ilbSubsetting: isSet(object.enableL4ilbSubsetting)
        ? globalThis.Boolean(object.enableL4ilbSubsetting)
        : false,
      datapathProvider: isSet(object.datapathProvider) ? datapathProviderFromJSON(object.datapathProvider) : 0,
      privateIpv6GoogleAccess: isSet(object.privateIpv6GoogleAccess)
        ? privateIPv6GoogleAccessFromJSON(object.privateIpv6GoogleAccess)
        : 0,
      dnsConfig: isSet(object.dnsConfig) ? DNSConfig.fromJSON(object.dnsConfig) : undefined,
      serviceExternalIpsConfig: isSet(object.serviceExternalIpsConfig)
        ? ServiceExternalIPsConfig.fromJSON(object.serviceExternalIpsConfig)
        : undefined,
      gatewayApiConfig: isSet(object.gatewayApiConfig) ? GatewayAPIConfig.fromJSON(object.gatewayApiConfig) : undefined,
      enableMultiNetworking: isSet(object.enableMultiNetworking)
        ? globalThis.Boolean(object.enableMultiNetworking)
        : false,
      networkPerformanceConfig: isSet(object.networkPerformanceConfig)
        ? NetworkConfig_ClusterNetworkPerformanceConfig.fromJSON(object.networkPerformanceConfig)
        : undefined,
      enableFqdnNetworkPolicy: isSet(object.enableFqdnNetworkPolicy)
        ? globalThis.Boolean(object.enableFqdnNetworkPolicy)
        : undefined,
      inTransitEncryptionConfig: isSet(object.inTransitEncryptionConfig)
        ? inTransitEncryptionConfigFromJSON(object.inTransitEncryptionConfig)
        : undefined,
      enableCiliumClusterwideNetworkPolicy: isSet(object.enableCiliumClusterwideNetworkPolicy)
        ? globalThis.Boolean(object.enableCiliumClusterwideNetworkPolicy)
        : undefined,
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.enableIntraNodeVisibility !== false) {
      obj.enableIntraNodeVisibility = message.enableIntraNodeVisibility;
    }
    if (message.defaultSnatStatus !== undefined) {
      obj.defaultSnatStatus = DefaultSnatStatus.toJSON(message.defaultSnatStatus);
    }
    if (message.enableL4ilbSubsetting !== false) {
      obj.enableL4ilbSubsetting = message.enableL4ilbSubsetting;
    }
    if (message.datapathProvider !== 0) {
      obj.datapathProvider = datapathProviderToJSON(message.datapathProvider);
    }
    if (message.privateIpv6GoogleAccess !== 0) {
      obj.privateIpv6GoogleAccess = privateIPv6GoogleAccessToJSON(message.privateIpv6GoogleAccess);
    }
    if (message.dnsConfig !== undefined) {
      obj.dnsConfig = DNSConfig.toJSON(message.dnsConfig);
    }
    if (message.serviceExternalIpsConfig !== undefined) {
      obj.serviceExternalIpsConfig = ServiceExternalIPsConfig.toJSON(message.serviceExternalIpsConfig);
    }
    if (message.gatewayApiConfig !== undefined) {
      obj.gatewayApiConfig = GatewayAPIConfig.toJSON(message.gatewayApiConfig);
    }
    if (message.enableMultiNetworking !== false) {
      obj.enableMultiNetworking = message.enableMultiNetworking;
    }
    if (message.networkPerformanceConfig !== undefined) {
      obj.networkPerformanceConfig = NetworkConfig_ClusterNetworkPerformanceConfig.toJSON(
        message.networkPerformanceConfig,
      );
    }
    if (message.enableFqdnNetworkPolicy !== undefined) {
      obj.enableFqdnNetworkPolicy = message.enableFqdnNetworkPolicy;
    }
    if (message.inTransitEncryptionConfig !== undefined) {
      obj.inTransitEncryptionConfig = inTransitEncryptionConfigToJSON(message.inTransitEncryptionConfig);
    }
    if (message.enableCiliumClusterwideNetworkPolicy !== undefined) {
      obj.enableCiliumClusterwideNetworkPolicy = message.enableCiliumClusterwideNetworkPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.enableIntraNodeVisibility = object.enableIntraNodeVisibility ?? false;
    message.defaultSnatStatus = (object.defaultSnatStatus !== undefined && object.defaultSnatStatus !== null)
      ? DefaultSnatStatus.fromPartial(object.defaultSnatStatus)
      : undefined;
    message.enableL4ilbSubsetting = object.enableL4ilbSubsetting ?? false;
    message.datapathProvider = object.datapathProvider ?? 0;
    message.privateIpv6GoogleAccess = object.privateIpv6GoogleAccess ?? 0;
    message.dnsConfig = (object.dnsConfig !== undefined && object.dnsConfig !== null)
      ? DNSConfig.fromPartial(object.dnsConfig)
      : undefined;
    message.serviceExternalIpsConfig =
      (object.serviceExternalIpsConfig !== undefined && object.serviceExternalIpsConfig !== null)
        ? ServiceExternalIPsConfig.fromPartial(object.serviceExternalIpsConfig)
        : undefined;
    message.gatewayApiConfig = (object.gatewayApiConfig !== undefined && object.gatewayApiConfig !== null)
      ? GatewayAPIConfig.fromPartial(object.gatewayApiConfig)
      : undefined;
    message.enableMultiNetworking = object.enableMultiNetworking ?? false;
    message.networkPerformanceConfig =
      (object.networkPerformanceConfig !== undefined && object.networkPerformanceConfig !== null)
        ? NetworkConfig_ClusterNetworkPerformanceConfig.fromPartial(object.networkPerformanceConfig)
        : undefined;
    message.enableFqdnNetworkPolicy = object.enableFqdnNetworkPolicy ?? undefined;
    message.inTransitEncryptionConfig = object.inTransitEncryptionConfig ?? undefined;
    message.enableCiliumClusterwideNetworkPolicy = object.enableCiliumClusterwideNetworkPolicy ?? undefined;
    return message;
  },
};

function createBaseNetworkConfig_ClusterNetworkPerformanceConfig(): NetworkConfig_ClusterNetworkPerformanceConfig {
  return { totalEgressBandwidthTier: undefined };
}

export const NetworkConfig_ClusterNetworkPerformanceConfig: MessageFns<NetworkConfig_ClusterNetworkPerformanceConfig> =
  {
    encode(
      message: NetworkConfig_ClusterNetworkPerformanceConfig,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.totalEgressBandwidthTier !== undefined) {
        writer.uint32(8).int32(message.totalEgressBandwidthTier);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig_ClusterNetworkPerformanceConfig {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseNetworkConfig_ClusterNetworkPerformanceConfig();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.totalEgressBandwidthTier = reader.int32() as any;
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): NetworkConfig_ClusterNetworkPerformanceConfig {
      return {
        totalEgressBandwidthTier: isSet(object.totalEgressBandwidthTier)
          ? networkConfig_ClusterNetworkPerformanceConfig_TierFromJSON(object.totalEgressBandwidthTier)
          : undefined,
      };
    },

    toJSON(message: NetworkConfig_ClusterNetworkPerformanceConfig): unknown {
      const obj: any = {};
      if (message.totalEgressBandwidthTier !== undefined) {
        obj.totalEgressBandwidthTier = networkConfig_ClusterNetworkPerformanceConfig_TierToJSON(
          message.totalEgressBandwidthTier,
        );
      }
      return obj;
    },

    create(
      base?: DeepPartial<NetworkConfig_ClusterNetworkPerformanceConfig>,
    ): NetworkConfig_ClusterNetworkPerformanceConfig {
      return NetworkConfig_ClusterNetworkPerformanceConfig.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<NetworkConfig_ClusterNetworkPerformanceConfig>,
    ): NetworkConfig_ClusterNetworkPerformanceConfig {
      const message = createBaseNetworkConfig_ClusterNetworkPerformanceConfig();
      message.totalEgressBandwidthTier = object.totalEgressBandwidthTier ?? undefined;
      return message;
    },
  };

function createBaseGatewayAPIConfig(): GatewayAPIConfig {
  return { channel: 0 };
}

export const GatewayAPIConfig: MessageFns<GatewayAPIConfig> = {
  encode(message: GatewayAPIConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GatewayAPIConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayAPIConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayAPIConfig {
    return { channel: isSet(object.channel) ? gatewayAPIConfig_ChannelFromJSON(object.channel) : 0 };
  },

  toJSON(message: GatewayAPIConfig): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = gatewayAPIConfig_ChannelToJSON(message.channel);
    }
    return obj;
  },

  create(base?: DeepPartial<GatewayAPIConfig>): GatewayAPIConfig {
    return GatewayAPIConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GatewayAPIConfig>): GatewayAPIConfig {
    const message = createBaseGatewayAPIConfig();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseServiceExternalIPsConfig(): ServiceExternalIPsConfig {
  return { enabled: false };
}

export const ServiceExternalIPsConfig: MessageFns<ServiceExternalIPsConfig> = {
  encode(message: ServiceExternalIPsConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceExternalIPsConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceExternalIPsConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceExternalIPsConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ServiceExternalIPsConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceExternalIPsConfig>): ServiceExternalIPsConfig {
    return ServiceExternalIPsConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceExternalIPsConfig>): ServiceExternalIPsConfig {
    const message = createBaseServiceExternalIPsConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGetOpenIDConfigRequest(): GetOpenIDConfigRequest {
  return { parent: "" };
}

export const GetOpenIDConfigRequest: MessageFns<GetOpenIDConfigRequest> = {
  encode(message: GetOpenIDConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOpenIDConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOpenIDConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOpenIDConfigRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GetOpenIDConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOpenIDConfigRequest>): GetOpenIDConfigRequest {
    return GetOpenIDConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOpenIDConfigRequest>): GetOpenIDConfigRequest {
    const message = createBaseGetOpenIDConfigRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGetOpenIDConfigResponse(): GetOpenIDConfigResponse {
  return {
    issuer: "",
    jwksUri: "",
    responseTypesSupported: [],
    subjectTypesSupported: [],
    idTokenSigningAlgValuesSupported: [],
    claimsSupported: [],
    grantTypes: [],
  };
}

export const GetOpenIDConfigResponse: MessageFns<GetOpenIDConfigResponse> = {
  encode(message: GetOpenIDConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.jwksUri !== "") {
      writer.uint32(18).string(message.jwksUri);
    }
    for (const v of message.responseTypesSupported) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.subjectTypesSupported) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.idTokenSigningAlgValuesSupported) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.claimsSupported) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.grantTypes) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOpenIDConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOpenIDConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jwksUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseTypesSupported.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjectTypesSupported.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.idTokenSigningAlgValuesSupported.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.claimsSupported.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.grantTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOpenIDConfigResponse {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      jwksUri: isSet(object.jwksUri) ? globalThis.String(object.jwksUri) : "",
      responseTypesSupported: globalThis.Array.isArray(object?.responseTypesSupported)
        ? object.responseTypesSupported.map((e: any) => globalThis.String(e))
        : [],
      subjectTypesSupported: globalThis.Array.isArray(object?.subjectTypesSupported)
        ? object.subjectTypesSupported.map((e: any) => globalThis.String(e))
        : [],
      idTokenSigningAlgValuesSupported: globalThis.Array.isArray(object?.idTokenSigningAlgValuesSupported)
        ? object.idTokenSigningAlgValuesSupported.map((e: any) => globalThis.String(e))
        : [],
      claimsSupported: globalThis.Array.isArray(object?.claimsSupported)
        ? object.claimsSupported.map((e: any) => globalThis.String(e))
        : [],
      grantTypes: globalThis.Array.isArray(object?.grantTypes)
        ? object.grantTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetOpenIDConfigResponse): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.jwksUri !== "") {
      obj.jwksUri = message.jwksUri;
    }
    if (message.responseTypesSupported?.length) {
      obj.responseTypesSupported = message.responseTypesSupported;
    }
    if (message.subjectTypesSupported?.length) {
      obj.subjectTypesSupported = message.subjectTypesSupported;
    }
    if (message.idTokenSigningAlgValuesSupported?.length) {
      obj.idTokenSigningAlgValuesSupported = message.idTokenSigningAlgValuesSupported;
    }
    if (message.claimsSupported?.length) {
      obj.claimsSupported = message.claimsSupported;
    }
    if (message.grantTypes?.length) {
      obj.grantTypes = message.grantTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOpenIDConfigResponse>): GetOpenIDConfigResponse {
    return GetOpenIDConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOpenIDConfigResponse>): GetOpenIDConfigResponse {
    const message = createBaseGetOpenIDConfigResponse();
    message.issuer = object.issuer ?? "";
    message.jwksUri = object.jwksUri ?? "";
    message.responseTypesSupported = object.responseTypesSupported?.map((e) => e) || [];
    message.subjectTypesSupported = object.subjectTypesSupported?.map((e) => e) || [];
    message.idTokenSigningAlgValuesSupported = object.idTokenSigningAlgValuesSupported?.map((e) => e) || [];
    message.claimsSupported = object.claimsSupported?.map((e) => e) || [];
    message.grantTypes = object.grantTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetJSONWebKeysRequest(): GetJSONWebKeysRequest {
  return { parent: "" };
}

export const GetJSONWebKeysRequest: MessageFns<GetJSONWebKeysRequest> = {
  encode(message: GetJSONWebKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJSONWebKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJSONWebKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJSONWebKeysRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GetJSONWebKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GetJSONWebKeysRequest>): GetJSONWebKeysRequest {
    return GetJSONWebKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJSONWebKeysRequest>): GetJSONWebKeysRequest {
    const message = createBaseGetJSONWebKeysRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseJwk(): Jwk {
  return { kty: "", alg: "", use: "", kid: "", n: "", e: "", x: "", y: "", crv: "" };
}

export const Jwk: MessageFns<Jwk> = {
  encode(message: Jwk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kty !== "") {
      writer.uint32(10).string(message.kty);
    }
    if (message.alg !== "") {
      writer.uint32(18).string(message.alg);
    }
    if (message.use !== "") {
      writer.uint32(26).string(message.use);
    }
    if (message.kid !== "") {
      writer.uint32(34).string(message.kid);
    }
    if (message.n !== "") {
      writer.uint32(42).string(message.n);
    }
    if (message.e !== "") {
      writer.uint32(50).string(message.e);
    }
    if (message.x !== "") {
      writer.uint32(58).string(message.x);
    }
    if (message.y !== "") {
      writer.uint32(66).string(message.y);
    }
    if (message.crv !== "") {
      writer.uint32(74).string(message.crv);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Jwk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kty = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alg = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.use = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kid = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.n = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.e = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.x = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.y = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.crv = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Jwk {
    return {
      kty: isSet(object.kty) ? globalThis.String(object.kty) : "",
      alg: isSet(object.alg) ? globalThis.String(object.alg) : "",
      use: isSet(object.use) ? globalThis.String(object.use) : "",
      kid: isSet(object.kid) ? globalThis.String(object.kid) : "",
      n: isSet(object.n) ? globalThis.String(object.n) : "",
      e: isSet(object.e) ? globalThis.String(object.e) : "",
      x: isSet(object.x) ? globalThis.String(object.x) : "",
      y: isSet(object.y) ? globalThis.String(object.y) : "",
      crv: isSet(object.crv) ? globalThis.String(object.crv) : "",
    };
  },

  toJSON(message: Jwk): unknown {
    const obj: any = {};
    if (message.kty !== "") {
      obj.kty = message.kty;
    }
    if (message.alg !== "") {
      obj.alg = message.alg;
    }
    if (message.use !== "") {
      obj.use = message.use;
    }
    if (message.kid !== "") {
      obj.kid = message.kid;
    }
    if (message.n !== "") {
      obj.n = message.n;
    }
    if (message.e !== "") {
      obj.e = message.e;
    }
    if (message.x !== "") {
      obj.x = message.x;
    }
    if (message.y !== "") {
      obj.y = message.y;
    }
    if (message.crv !== "") {
      obj.crv = message.crv;
    }
    return obj;
  },

  create(base?: DeepPartial<Jwk>): Jwk {
    return Jwk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Jwk>): Jwk {
    const message = createBaseJwk();
    message.kty = object.kty ?? "";
    message.alg = object.alg ?? "";
    message.use = object.use ?? "";
    message.kid = object.kid ?? "";
    message.n = object.n ?? "";
    message.e = object.e ?? "";
    message.x = object.x ?? "";
    message.y = object.y ?? "";
    message.crv = object.crv ?? "";
    return message;
  },
};

function createBaseGetJSONWebKeysResponse(): GetJSONWebKeysResponse {
  return { keys: [] };
}

export const GetJSONWebKeysResponse: MessageFns<GetJSONWebKeysResponse> = {
  encode(message: GetJSONWebKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      Jwk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJSONWebKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJSONWebKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keys.push(Jwk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJSONWebKeysResponse {
    return { keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => Jwk.fromJSON(e)) : [] };
  },

  toJSON(message: GetJSONWebKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => Jwk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetJSONWebKeysResponse>): GetJSONWebKeysResponse {
    return GetJSONWebKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetJSONWebKeysResponse>): GetJSONWebKeysResponse {
    const message = createBaseGetJSONWebKeysResponse();
    message.keys = object.keys?.map((e) => Jwk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCheckAutopilotCompatibilityRequest(): CheckAutopilotCompatibilityRequest {
  return { name: "" };
}

export const CheckAutopilotCompatibilityRequest: MessageFns<CheckAutopilotCompatibilityRequest> = {
  encode(message: CheckAutopilotCompatibilityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAutopilotCompatibilityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAutopilotCompatibilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAutopilotCompatibilityRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CheckAutopilotCompatibilityRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckAutopilotCompatibilityRequest>): CheckAutopilotCompatibilityRequest {
    return CheckAutopilotCompatibilityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckAutopilotCompatibilityRequest>): CheckAutopilotCompatibilityRequest {
    const message = createBaseCheckAutopilotCompatibilityRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAutopilotCompatibilityIssue(): AutopilotCompatibilityIssue {
  return {
    lastObservation: undefined,
    constraintType: "",
    incompatibilityType: 0,
    subjects: [],
    documentationUrl: "",
    description: "",
  };
}

export const AutopilotCompatibilityIssue: MessageFns<AutopilotCompatibilityIssue> = {
  encode(message: AutopilotCompatibilityIssue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastObservation !== undefined) {
      Timestamp.encode(toTimestamp(message.lastObservation), writer.uint32(10).fork()).join();
    }
    if (message.constraintType !== "") {
      writer.uint32(18).string(message.constraintType);
    }
    if (message.incompatibilityType !== 0) {
      writer.uint32(24).int32(message.incompatibilityType);
    }
    for (const v of message.subjects) {
      writer.uint32(34).string(v!);
    }
    if (message.documentationUrl !== "") {
      writer.uint32(42).string(message.documentationUrl);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutopilotCompatibilityIssue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutopilotCompatibilityIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lastObservation = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constraintType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.incompatibilityType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjects.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.documentationUrl = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutopilotCompatibilityIssue {
    return {
      lastObservation: isSet(object.lastObservation) ? fromJsonTimestamp(object.lastObservation) : undefined,
      constraintType: isSet(object.constraintType) ? globalThis.String(object.constraintType) : "",
      incompatibilityType: isSet(object.incompatibilityType)
        ? autopilotCompatibilityIssue_IssueTypeFromJSON(object.incompatibilityType)
        : 0,
      subjects: globalThis.Array.isArray(object?.subjects) ? object.subjects.map((e: any) => globalThis.String(e)) : [],
      documentationUrl: isSet(object.documentationUrl) ? globalThis.String(object.documentationUrl) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: AutopilotCompatibilityIssue): unknown {
    const obj: any = {};
    if (message.lastObservation !== undefined) {
      obj.lastObservation = message.lastObservation.toISOString();
    }
    if (message.constraintType !== "") {
      obj.constraintType = message.constraintType;
    }
    if (message.incompatibilityType !== 0) {
      obj.incompatibilityType = autopilotCompatibilityIssue_IssueTypeToJSON(message.incompatibilityType);
    }
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    if (message.documentationUrl !== "") {
      obj.documentationUrl = message.documentationUrl;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<AutopilotCompatibilityIssue>): AutopilotCompatibilityIssue {
    return AutopilotCompatibilityIssue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutopilotCompatibilityIssue>): AutopilotCompatibilityIssue {
    const message = createBaseAutopilotCompatibilityIssue();
    message.lastObservation = object.lastObservation ?? undefined;
    message.constraintType = object.constraintType ?? "";
    message.incompatibilityType = object.incompatibilityType ?? 0;
    message.subjects = object.subjects?.map((e) => e) || [];
    message.documentationUrl = object.documentationUrl ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseCheckAutopilotCompatibilityResponse(): CheckAutopilotCompatibilityResponse {
  return { issues: [], summary: "" };
}

export const CheckAutopilotCompatibilityResponse: MessageFns<CheckAutopilotCompatibilityResponse> = {
  encode(message: CheckAutopilotCompatibilityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.issues) {
      AutopilotCompatibilityIssue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckAutopilotCompatibilityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckAutopilotCompatibilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issues.push(AutopilotCompatibilityIssue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckAutopilotCompatibilityResponse {
    return {
      issues: globalThis.Array.isArray(object?.issues)
        ? object.issues.map((e: any) => AutopilotCompatibilityIssue.fromJSON(e))
        : [],
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
    };
  },

  toJSON(message: CheckAutopilotCompatibilityResponse): unknown {
    const obj: any = {};
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => AutopilotCompatibilityIssue.toJSON(e));
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    return obj;
  },

  create(base?: DeepPartial<CheckAutopilotCompatibilityResponse>): CheckAutopilotCompatibilityResponse {
    return CheckAutopilotCompatibilityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CheckAutopilotCompatibilityResponse>): CheckAutopilotCompatibilityResponse {
    const message = createBaseCheckAutopilotCompatibilityResponse();
    message.issues = object.issues?.map((e) => AutopilotCompatibilityIssue.fromPartial(e)) || [];
    message.summary = object.summary ?? "";
    return message;
  },
};

function createBaseReleaseChannel(): ReleaseChannel {
  return { channel: 0 };
}

export const ReleaseChannel: MessageFns<ReleaseChannel> = {
  encode(message: ReleaseChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channel !== 0) {
      writer.uint32(8).int32(message.channel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseChannel {
    return { channel: isSet(object.channel) ? releaseChannel_ChannelFromJSON(object.channel) : 0 };
  },

  toJSON(message: ReleaseChannel): unknown {
    const obj: any = {};
    if (message.channel !== 0) {
      obj.channel = releaseChannel_ChannelToJSON(message.channel);
    }
    return obj;
  },

  create(base?: DeepPartial<ReleaseChannel>): ReleaseChannel {
    return ReleaseChannel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReleaseChannel>): ReleaseChannel {
    const message = createBaseReleaseChannel();
    message.channel = object.channel ?? 0;
    return message;
  },
};

function createBaseCostManagementConfig(): CostManagementConfig {
  return { enabled: false };
}

export const CostManagementConfig: MessageFns<CostManagementConfig> = {
  encode(message: CostManagementConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CostManagementConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCostManagementConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CostManagementConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: CostManagementConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<CostManagementConfig>): CostManagementConfig {
    return CostManagementConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CostManagementConfig>): CostManagementConfig {
    const message = createBaseCostManagementConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseIntraNodeVisibilityConfig(): IntraNodeVisibilityConfig {
  return { enabled: false };
}

export const IntraNodeVisibilityConfig: MessageFns<IntraNodeVisibilityConfig> = {
  encode(message: IntraNodeVisibilityConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntraNodeVisibilityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntraNodeVisibilityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntraNodeVisibilityConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: IntraNodeVisibilityConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<IntraNodeVisibilityConfig>): IntraNodeVisibilityConfig {
    return IntraNodeVisibilityConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntraNodeVisibilityConfig>): IntraNodeVisibilityConfig {
    const message = createBaseIntraNodeVisibilityConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseILBSubsettingConfig(): ILBSubsettingConfig {
  return { enabled: false };
}

export const ILBSubsettingConfig: MessageFns<ILBSubsettingConfig> = {
  encode(message: ILBSubsettingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ILBSubsettingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseILBSubsettingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ILBSubsettingConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ILBSubsettingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ILBSubsettingConfig>): ILBSubsettingConfig {
    return ILBSubsettingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ILBSubsettingConfig>): ILBSubsettingConfig {
    const message = createBaseILBSubsettingConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseDNSConfig(): DNSConfig {
  return { clusterDns: 0, clusterDnsScope: 0, clusterDnsDomain: "", additiveVpcScopeDnsDomain: "" };
}

export const DNSConfig: MessageFns<DNSConfig> = {
  encode(message: DNSConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterDns !== 0) {
      writer.uint32(8).int32(message.clusterDns);
    }
    if (message.clusterDnsScope !== 0) {
      writer.uint32(16).int32(message.clusterDnsScope);
    }
    if (message.clusterDnsDomain !== "") {
      writer.uint32(26).string(message.clusterDnsDomain);
    }
    if (message.additiveVpcScopeDnsDomain !== "") {
      writer.uint32(42).string(message.additiveVpcScopeDnsDomain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DNSConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDNSConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clusterDns = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clusterDnsScope = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clusterDnsDomain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additiveVpcScopeDnsDomain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DNSConfig {
    return {
      clusterDns: isSet(object.clusterDns) ? dNSConfig_ProviderFromJSON(object.clusterDns) : 0,
      clusterDnsScope: isSet(object.clusterDnsScope) ? dNSConfig_DNSScopeFromJSON(object.clusterDnsScope) : 0,
      clusterDnsDomain: isSet(object.clusterDnsDomain) ? globalThis.String(object.clusterDnsDomain) : "",
      additiveVpcScopeDnsDomain: isSet(object.additiveVpcScopeDnsDomain)
        ? globalThis.String(object.additiveVpcScopeDnsDomain)
        : "",
    };
  },

  toJSON(message: DNSConfig): unknown {
    const obj: any = {};
    if (message.clusterDns !== 0) {
      obj.clusterDns = dNSConfig_ProviderToJSON(message.clusterDns);
    }
    if (message.clusterDnsScope !== 0) {
      obj.clusterDnsScope = dNSConfig_DNSScopeToJSON(message.clusterDnsScope);
    }
    if (message.clusterDnsDomain !== "") {
      obj.clusterDnsDomain = message.clusterDnsDomain;
    }
    if (message.additiveVpcScopeDnsDomain !== "") {
      obj.additiveVpcScopeDnsDomain = message.additiveVpcScopeDnsDomain;
    }
    return obj;
  },

  create(base?: DeepPartial<DNSConfig>): DNSConfig {
    return DNSConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DNSConfig>): DNSConfig {
    const message = createBaseDNSConfig();
    message.clusterDns = object.clusterDns ?? 0;
    message.clusterDnsScope = object.clusterDnsScope ?? 0;
    message.clusterDnsDomain = object.clusterDnsDomain ?? "";
    message.additiveVpcScopeDnsDomain = object.additiveVpcScopeDnsDomain ?? "";
    return message;
  },
};

function createBaseMaxPodsConstraint(): MaxPodsConstraint {
  return { maxPodsPerNode: Long.ZERO };
}

export const MaxPodsConstraint: MessageFns<MaxPodsConstraint> = {
  encode(message: MaxPodsConstraint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxPodsPerNode.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.maxPodsPerNode.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaxPodsConstraint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaxPodsConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.maxPodsPerNode = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaxPodsConstraint {
    return { maxPodsPerNode: isSet(object.maxPodsPerNode) ? Long.fromValue(object.maxPodsPerNode) : Long.ZERO };
  },

  toJSON(message: MaxPodsConstraint): unknown {
    const obj: any = {};
    if (!message.maxPodsPerNode.equals(Long.ZERO)) {
      obj.maxPodsPerNode = (message.maxPodsPerNode || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<MaxPodsConstraint>): MaxPodsConstraint {
    return MaxPodsConstraint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaxPodsConstraint>): MaxPodsConstraint {
    const message = createBaseMaxPodsConstraint();
    message.maxPodsPerNode = (object.maxPodsPerNode !== undefined && object.maxPodsPerNode !== null)
      ? Long.fromValue(object.maxPodsPerNode)
      : Long.ZERO;
    return message;
  },
};

function createBaseWorkloadIdentityConfig(): WorkloadIdentityConfig {
  return { workloadPool: "" };
}

export const WorkloadIdentityConfig: MessageFns<WorkloadIdentityConfig> = {
  encode(message: WorkloadIdentityConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workloadPool !== "") {
      writer.uint32(18).string(message.workloadPool);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadIdentityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadIdentityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workloadPool = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadIdentityConfig {
    return { workloadPool: isSet(object.workloadPool) ? globalThis.String(object.workloadPool) : "" };
  },

  toJSON(message: WorkloadIdentityConfig): unknown {
    const obj: any = {};
    if (message.workloadPool !== "") {
      obj.workloadPool = message.workloadPool;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadIdentityConfig>): WorkloadIdentityConfig {
    return WorkloadIdentityConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadIdentityConfig>): WorkloadIdentityConfig {
    const message = createBaseWorkloadIdentityConfig();
    message.workloadPool = object.workloadPool ?? "";
    return message;
  },
};

function createBaseIdentityServiceConfig(): IdentityServiceConfig {
  return { enabled: false };
}

export const IdentityServiceConfig: MessageFns<IdentityServiceConfig> = {
  encode(message: IdentityServiceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityServiceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityServiceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityServiceConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: IdentityServiceConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<IdentityServiceConfig>): IdentityServiceConfig {
    return IdentityServiceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IdentityServiceConfig>): IdentityServiceConfig {
    const message = createBaseIdentityServiceConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseMeshCertificates(): MeshCertificates {
  return { enableCertificates: undefined };
}

export const MeshCertificates: MessageFns<MeshCertificates> = {
  encode(message: MeshCertificates, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableCertificates !== undefined) {
      BoolValue.encode({ value: message.enableCertificates! }, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeshCertificates {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeshCertificates();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.enableCertificates = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeshCertificates {
    return { enableCertificates: isSet(object.enableCertificates) ? Boolean(object.enableCertificates) : undefined };
  },

  toJSON(message: MeshCertificates): unknown {
    const obj: any = {};
    if (message.enableCertificates !== undefined) {
      obj.enableCertificates = message.enableCertificates;
    }
    return obj;
  },

  create(base?: DeepPartial<MeshCertificates>): MeshCertificates {
    return MeshCertificates.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MeshCertificates>): MeshCertificates {
    const message = createBaseMeshCertificates();
    message.enableCertificates = object.enableCertificates ?? undefined;
    return message;
  },
};

function createBaseDatabaseEncryption(): DatabaseEncryption {
  return { keyName: "", state: 0, currentState: undefined, decryptionKeys: [], lastOperationErrors: [] };
}

export const DatabaseEncryption: MessageFns<DatabaseEncryption> = {
  encode(message: DatabaseEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyName !== "") {
      writer.uint32(10).string(message.keyName);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.currentState !== undefined) {
      writer.uint32(24).int32(message.currentState);
    }
    for (const v of message.decryptionKeys) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.lastOperationErrors) {
      DatabaseEncryption_OperationError.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.currentState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.decryptionKeys.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastOperationErrors.push(DatabaseEncryption_OperationError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseEncryption {
    return {
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      state: isSet(object.state) ? databaseEncryption_StateFromJSON(object.state) : 0,
      currentState: isSet(object.currentState)
        ? databaseEncryption_CurrentStateFromJSON(object.currentState)
        : undefined,
      decryptionKeys: globalThis.Array.isArray(object?.decryptionKeys)
        ? object.decryptionKeys.map((e: any) => globalThis.String(e))
        : [],
      lastOperationErrors: globalThis.Array.isArray(object?.lastOperationErrors)
        ? object.lastOperationErrors.map((e: any) => DatabaseEncryption_OperationError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DatabaseEncryption): unknown {
    const obj: any = {};
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.state !== 0) {
      obj.state = databaseEncryption_StateToJSON(message.state);
    }
    if (message.currentState !== undefined) {
      obj.currentState = databaseEncryption_CurrentStateToJSON(message.currentState);
    }
    if (message.decryptionKeys?.length) {
      obj.decryptionKeys = message.decryptionKeys;
    }
    if (message.lastOperationErrors?.length) {
      obj.lastOperationErrors = message.lastOperationErrors.map((e) => DatabaseEncryption_OperationError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseEncryption>): DatabaseEncryption {
    return DatabaseEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseEncryption>): DatabaseEncryption {
    const message = createBaseDatabaseEncryption();
    message.keyName = object.keyName ?? "";
    message.state = object.state ?? 0;
    message.currentState = object.currentState ?? undefined;
    message.decryptionKeys = object.decryptionKeys?.map((e) => e) || [];
    message.lastOperationErrors =
      object.lastOperationErrors?.map((e) => DatabaseEncryption_OperationError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDatabaseEncryption_OperationError(): DatabaseEncryption_OperationError {
  return { keyName: "", errorMessage: "", timestamp: undefined };
}

export const DatabaseEncryption_OperationError: MessageFns<DatabaseEncryption_OperationError> = {
  encode(message: DatabaseEncryption_OperationError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyName !== "") {
      writer.uint32(10).string(message.keyName);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseEncryption_OperationError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseEncryption_OperationError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DatabaseEncryption_OperationError {
    return {
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: DatabaseEncryption_OperationError): unknown {
    const obj: any = {};
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DatabaseEncryption_OperationError>): DatabaseEncryption_OperationError {
    return DatabaseEncryption_OperationError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseEncryption_OperationError>): DatabaseEncryption_OperationError {
    const message = createBaseDatabaseEncryption_OperationError();
    message.keyName = object.keyName ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseListUsableSubnetworksRequest(): ListUsableSubnetworksRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListUsableSubnetworksRequest: MessageFns<ListUsableSubnetworksRequest> = {
  encode(message: ListUsableSubnetworksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableSubnetworksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableSubnetworksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableSubnetworksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListUsableSubnetworksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableSubnetworksRequest>): ListUsableSubnetworksRequest {
    return ListUsableSubnetworksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableSubnetworksRequest>): ListUsableSubnetworksRequest {
    const message = createBaseListUsableSubnetworksRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListUsableSubnetworksResponse(): ListUsableSubnetworksResponse {
  return { subnetworks: [], nextPageToken: "" };
}

export const ListUsableSubnetworksResponse: MessageFns<ListUsableSubnetworksResponse> = {
  encode(message: ListUsableSubnetworksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subnetworks) {
      UsableSubnetwork.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsableSubnetworksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsableSubnetworksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnetworks.push(UsableSubnetwork.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsableSubnetworksResponse {
    return {
      subnetworks: globalThis.Array.isArray(object?.subnetworks)
        ? object.subnetworks.map((e: any) => UsableSubnetwork.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListUsableSubnetworksResponse): unknown {
    const obj: any = {};
    if (message.subnetworks?.length) {
      obj.subnetworks = message.subnetworks.map((e) => UsableSubnetwork.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListUsableSubnetworksResponse>): ListUsableSubnetworksResponse {
    return ListUsableSubnetworksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListUsableSubnetworksResponse>): ListUsableSubnetworksResponse {
    const message = createBaseListUsableSubnetworksResponse();
    message.subnetworks = object.subnetworks?.map((e) => UsableSubnetwork.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUsableSubnetworkSecondaryRange(): UsableSubnetworkSecondaryRange {
  return { rangeName: "", ipCidrRange: "", status: 0 };
}

export const UsableSubnetworkSecondaryRange: MessageFns<UsableSubnetworkSecondaryRange> = {
  encode(message: UsableSubnetworkSecondaryRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rangeName !== "") {
      writer.uint32(10).string(message.rangeName);
    }
    if (message.ipCidrRange !== "") {
      writer.uint32(18).string(message.ipCidrRange);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsableSubnetworkSecondaryRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsableSubnetworkSecondaryRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rangeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipCidrRange = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsableSubnetworkSecondaryRange {
    return {
      rangeName: isSet(object.rangeName) ? globalThis.String(object.rangeName) : "",
      ipCidrRange: isSet(object.ipCidrRange) ? globalThis.String(object.ipCidrRange) : "",
      status: isSet(object.status) ? usableSubnetworkSecondaryRange_StatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: UsableSubnetworkSecondaryRange): unknown {
    const obj: any = {};
    if (message.rangeName !== "") {
      obj.rangeName = message.rangeName;
    }
    if (message.ipCidrRange !== "") {
      obj.ipCidrRange = message.ipCidrRange;
    }
    if (message.status !== 0) {
      obj.status = usableSubnetworkSecondaryRange_StatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<UsableSubnetworkSecondaryRange>): UsableSubnetworkSecondaryRange {
    return UsableSubnetworkSecondaryRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UsableSubnetworkSecondaryRange>): UsableSubnetworkSecondaryRange {
    const message = createBaseUsableSubnetworkSecondaryRange();
    message.rangeName = object.rangeName ?? "";
    message.ipCidrRange = object.ipCidrRange ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseUsableSubnetwork(): UsableSubnetwork {
  return { subnetwork: "", network: "", ipCidrRange: "", secondaryIpRanges: [], statusMessage: "" };
}

export const UsableSubnetwork: MessageFns<UsableSubnetwork> = {
  encode(message: UsableSubnetwork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subnetwork !== "") {
      writer.uint32(10).string(message.subnetwork);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.ipCidrRange !== "") {
      writer.uint32(26).string(message.ipCidrRange);
    }
    for (const v of message.secondaryIpRanges) {
      UsableSubnetworkSecondaryRange.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsableSubnetwork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsableSubnetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipCidrRange = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.secondaryIpRanges.push(UsableSubnetworkSecondaryRange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsableSubnetwork {
    return {
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ipCidrRange: isSet(object.ipCidrRange) ? globalThis.String(object.ipCidrRange) : "",
      secondaryIpRanges: globalThis.Array.isArray(object?.secondaryIpRanges)
        ? object.secondaryIpRanges.map((e: any) => UsableSubnetworkSecondaryRange.fromJSON(e))
        : [],
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
    };
  },

  toJSON(message: UsableSubnetwork): unknown {
    const obj: any = {};
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ipCidrRange !== "") {
      obj.ipCidrRange = message.ipCidrRange;
    }
    if (message.secondaryIpRanges?.length) {
      obj.secondaryIpRanges = message.secondaryIpRanges.map((e) => UsableSubnetworkSecondaryRange.toJSON(e));
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<UsableSubnetwork>): UsableSubnetwork {
    return UsableSubnetwork.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UsableSubnetwork>): UsableSubnetwork {
    const message = createBaseUsableSubnetwork();
    message.subnetwork = object.subnetwork ?? "";
    message.network = object.network ?? "";
    message.ipCidrRange = object.ipCidrRange ?? "";
    message.secondaryIpRanges = object.secondaryIpRanges?.map((e) => UsableSubnetworkSecondaryRange.fromPartial(e)) ||
      [];
    message.statusMessage = object.statusMessage ?? "";
    return message;
  },
};

function createBaseResourceUsageExportConfig(): ResourceUsageExportConfig {
  return { bigqueryDestination: undefined, enableNetworkEgressMetering: false, consumptionMeteringConfig: undefined };
}

export const ResourceUsageExportConfig: MessageFns<ResourceUsageExportConfig> = {
  encode(message: ResourceUsageExportConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bigqueryDestination !== undefined) {
      ResourceUsageExportConfig_BigQueryDestination.encode(message.bigqueryDestination, writer.uint32(10).fork())
        .join();
    }
    if (message.enableNetworkEgressMetering !== false) {
      writer.uint32(16).bool(message.enableNetworkEgressMetering);
    }
    if (message.consumptionMeteringConfig !== undefined) {
      ResourceUsageExportConfig_ConsumptionMeteringConfig.encode(
        message.consumptionMeteringConfig,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceUsageExportConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceUsageExportConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bigqueryDestination = ResourceUsageExportConfig_BigQueryDestination.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableNetworkEgressMetering = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.consumptionMeteringConfig = ResourceUsageExportConfig_ConsumptionMeteringConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceUsageExportConfig {
    return {
      bigqueryDestination: isSet(object.bigqueryDestination)
        ? ResourceUsageExportConfig_BigQueryDestination.fromJSON(object.bigqueryDestination)
        : undefined,
      enableNetworkEgressMetering: isSet(object.enableNetworkEgressMetering)
        ? globalThis.Boolean(object.enableNetworkEgressMetering)
        : false,
      consumptionMeteringConfig: isSet(object.consumptionMeteringConfig)
        ? ResourceUsageExportConfig_ConsumptionMeteringConfig.fromJSON(object.consumptionMeteringConfig)
        : undefined,
    };
  },

  toJSON(message: ResourceUsageExportConfig): unknown {
    const obj: any = {};
    if (message.bigqueryDestination !== undefined) {
      obj.bigqueryDestination = ResourceUsageExportConfig_BigQueryDestination.toJSON(message.bigqueryDestination);
    }
    if (message.enableNetworkEgressMetering !== false) {
      obj.enableNetworkEgressMetering = message.enableNetworkEgressMetering;
    }
    if (message.consumptionMeteringConfig !== undefined) {
      obj.consumptionMeteringConfig = ResourceUsageExportConfig_ConsumptionMeteringConfig.toJSON(
        message.consumptionMeteringConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceUsageExportConfig>): ResourceUsageExportConfig {
    return ResourceUsageExportConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceUsageExportConfig>): ResourceUsageExportConfig {
    const message = createBaseResourceUsageExportConfig();
    message.bigqueryDestination = (object.bigqueryDestination !== undefined && object.bigqueryDestination !== null)
      ? ResourceUsageExportConfig_BigQueryDestination.fromPartial(object.bigqueryDestination)
      : undefined;
    message.enableNetworkEgressMetering = object.enableNetworkEgressMetering ?? false;
    message.consumptionMeteringConfig =
      (object.consumptionMeteringConfig !== undefined && object.consumptionMeteringConfig !== null)
        ? ResourceUsageExportConfig_ConsumptionMeteringConfig.fromPartial(object.consumptionMeteringConfig)
        : undefined;
    return message;
  },
};

function createBaseResourceUsageExportConfig_BigQueryDestination(): ResourceUsageExportConfig_BigQueryDestination {
  return { datasetId: "" };
}

export const ResourceUsageExportConfig_BigQueryDestination: MessageFns<ResourceUsageExportConfig_BigQueryDestination> =
  {
    encode(
      message: ResourceUsageExportConfig_BigQueryDestination,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.datasetId !== "") {
        writer.uint32(10).string(message.datasetId);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ResourceUsageExportConfig_BigQueryDestination {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseResourceUsageExportConfig_BigQueryDestination();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.datasetId = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ResourceUsageExportConfig_BigQueryDestination {
      return { datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "" };
    },

    toJSON(message: ResourceUsageExportConfig_BigQueryDestination): unknown {
      const obj: any = {};
      if (message.datasetId !== "") {
        obj.datasetId = message.datasetId;
      }
      return obj;
    },

    create(
      base?: DeepPartial<ResourceUsageExportConfig_BigQueryDestination>,
    ): ResourceUsageExportConfig_BigQueryDestination {
      return ResourceUsageExportConfig_BigQueryDestination.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<ResourceUsageExportConfig_BigQueryDestination>,
    ): ResourceUsageExportConfig_BigQueryDestination {
      const message = createBaseResourceUsageExportConfig_BigQueryDestination();
      message.datasetId = object.datasetId ?? "";
      return message;
    },
  };

function createBaseResourceUsageExportConfig_ConsumptionMeteringConfig(): ResourceUsageExportConfig_ConsumptionMeteringConfig {
  return { enabled: false };
}

export const ResourceUsageExportConfig_ConsumptionMeteringConfig: MessageFns<
  ResourceUsageExportConfig_ConsumptionMeteringConfig
> = {
  encode(
    message: ResourceUsageExportConfig_ConsumptionMeteringConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceUsageExportConfig_ConsumptionMeteringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceUsageExportConfig_ConsumptionMeteringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceUsageExportConfig_ConsumptionMeteringConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ResourceUsageExportConfig_ConsumptionMeteringConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ResourceUsageExportConfig_ConsumptionMeteringConfig>,
  ): ResourceUsageExportConfig_ConsumptionMeteringConfig {
    return ResourceUsageExportConfig_ConsumptionMeteringConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ResourceUsageExportConfig_ConsumptionMeteringConfig>,
  ): ResourceUsageExportConfig_ConsumptionMeteringConfig {
    const message = createBaseResourceUsageExportConfig_ConsumptionMeteringConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseVerticalPodAutoscaling(): VerticalPodAutoscaling {
  return { enabled: false };
}

export const VerticalPodAutoscaling: MessageFns<VerticalPodAutoscaling> = {
  encode(message: VerticalPodAutoscaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerticalPodAutoscaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerticalPodAutoscaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerticalPodAutoscaling {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: VerticalPodAutoscaling): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<VerticalPodAutoscaling>): VerticalPodAutoscaling {
    return VerticalPodAutoscaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VerticalPodAutoscaling>): VerticalPodAutoscaling {
    const message = createBaseVerticalPodAutoscaling();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseDefaultSnatStatus(): DefaultSnatStatus {
  return { disabled: false };
}

export const DefaultSnatStatus: MessageFns<DefaultSnatStatus> = {
  encode(message: DefaultSnatStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disabled !== false) {
      writer.uint32(8).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultSnatStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultSnatStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultSnatStatus {
    return { disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false };
  },

  toJSON(message: DefaultSnatStatus): unknown {
    const obj: any = {};
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<DefaultSnatStatus>): DefaultSnatStatus {
    return DefaultSnatStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DefaultSnatStatus>): DefaultSnatStatus {
    const message = createBaseDefaultSnatStatus();
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseShieldedNodes(): ShieldedNodes {
  return { enabled: false };
}

export const ShieldedNodes: MessageFns<ShieldedNodes> = {
  encode(message: ShieldedNodes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShieldedNodes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedNodes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedNodes {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ShieldedNodes): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ShieldedNodes>): ShieldedNodes {
    return ShieldedNodes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShieldedNodes>): ShieldedNodes {
    const message = createBaseShieldedNodes();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseVirtualNIC(): VirtualNIC {
  return { enabled: false };
}

export const VirtualNIC: MessageFns<VirtualNIC> = {
  encode(message: VirtualNIC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualNIC {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualNIC();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtualNIC {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: VirtualNIC): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<VirtualNIC>): VirtualNIC {
    return VirtualNIC.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VirtualNIC>): VirtualNIC {
    const message = createBaseVirtualNIC();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseFastSocket(): FastSocket {
  return { enabled: false };
}

export const FastSocket: MessageFns<FastSocket> = {
  encode(message: FastSocket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FastSocket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFastSocket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FastSocket {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: FastSocket): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<FastSocket>): FastSocket {
    return FastSocket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FastSocket>): FastSocket {
    const message = createBaseFastSocket();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseNotificationConfig(): NotificationConfig {
  return { pubsub: undefined };
}

export const NotificationConfig: MessageFns<NotificationConfig> = {
  encode(message: NotificationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pubsub !== undefined) {
      NotificationConfig_PubSub.encode(message.pubsub, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsub = NotificationConfig_PubSub.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationConfig {
    return { pubsub: isSet(object.pubsub) ? NotificationConfig_PubSub.fromJSON(object.pubsub) : undefined };
  },

  toJSON(message: NotificationConfig): unknown {
    const obj: any = {};
    if (message.pubsub !== undefined) {
      obj.pubsub = NotificationConfig_PubSub.toJSON(message.pubsub);
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationConfig>): NotificationConfig {
    return NotificationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationConfig>): NotificationConfig {
    const message = createBaseNotificationConfig();
    message.pubsub = (object.pubsub !== undefined && object.pubsub !== null)
      ? NotificationConfig_PubSub.fromPartial(object.pubsub)
      : undefined;
    return message;
  },
};

function createBaseNotificationConfig_PubSub(): NotificationConfig_PubSub {
  return { enabled: false, topic: "", filter: undefined };
}

export const NotificationConfig_PubSub: MessageFns<NotificationConfig_PubSub> = {
  encode(message: NotificationConfig_PubSub, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    if (message.filter !== undefined) {
      NotificationConfig_Filter.encode(message.filter, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationConfig_PubSub {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationConfig_PubSub();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = NotificationConfig_Filter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationConfig_PubSub {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      filter: isSet(object.filter) ? NotificationConfig_Filter.fromJSON(object.filter) : undefined,
    };
  },

  toJSON(message: NotificationConfig_PubSub): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.filter !== undefined) {
      obj.filter = NotificationConfig_Filter.toJSON(message.filter);
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationConfig_PubSub>): NotificationConfig_PubSub {
    return NotificationConfig_PubSub.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationConfig_PubSub>): NotificationConfig_PubSub {
    const message = createBaseNotificationConfig_PubSub();
    message.enabled = object.enabled ?? false;
    message.topic = object.topic ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? NotificationConfig_Filter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseNotificationConfig_Filter(): NotificationConfig_Filter {
  return { eventType: [] };
}

export const NotificationConfig_Filter: MessageFns<NotificationConfig_Filter> = {
  encode(message: NotificationConfig_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.eventType) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationConfig_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationConfig_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.eventType.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.eventType.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationConfig_Filter {
    return {
      eventType: globalThis.Array.isArray(object?.eventType)
        ? object.eventType.map((e: any) => notificationConfig_EventTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: NotificationConfig_Filter): unknown {
    const obj: any = {};
    if (message.eventType?.length) {
      obj.eventType = message.eventType.map((e) => notificationConfig_EventTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NotificationConfig_Filter>): NotificationConfig_Filter {
    return NotificationConfig_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NotificationConfig_Filter>): NotificationConfig_Filter {
    const message = createBaseNotificationConfig_Filter();
    message.eventType = object.eventType?.map((e) => e) || [];
    return message;
  },
};

function createBaseConfidentialNodes(): ConfidentialNodes {
  return { enabled: false };
}

export const ConfidentialNodes: MessageFns<ConfidentialNodes> = {
  encode(message: ConfidentialNodes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfidentialNodes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfidentialNodes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfidentialNodes {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ConfidentialNodes): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfidentialNodes>): ConfidentialNodes {
    return ConfidentialNodes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfidentialNodes>): ConfidentialNodes {
    const message = createBaseConfidentialNodes();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseUpgradeEvent(): UpgradeEvent {
  return {
    resourceType: 0,
    operation: "",
    operationStartTime: undefined,
    currentVersion: "",
    targetVersion: "",
    resource: "",
  };
}

export const UpgradeEvent: MessageFns<UpgradeEvent> = {
  encode(message: UpgradeEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceType !== 0) {
      writer.uint32(8).int32(message.resourceType);
    }
    if (message.operation !== "") {
      writer.uint32(18).string(message.operation);
    }
    if (message.operationStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.operationStartTime), writer.uint32(26).fork()).join();
    }
    if (message.currentVersion !== "") {
      writer.uint32(34).string(message.currentVersion);
    }
    if (message.targetVersion !== "") {
      writer.uint32(42).string(message.targetVersion);
    }
    if (message.resource !== "") {
      writer.uint32(50).string(message.resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetVersion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeEvent {
    return {
      resourceType: isSet(object.resourceType) ? upgradeResourceTypeFromJSON(object.resourceType) : 0,
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      operationStartTime: isSet(object.operationStartTime) ? fromJsonTimestamp(object.operationStartTime) : undefined,
      currentVersion: isSet(object.currentVersion) ? globalThis.String(object.currentVersion) : "",
      targetVersion: isSet(object.targetVersion) ? globalThis.String(object.targetVersion) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
    };
  },

  toJSON(message: UpgradeEvent): unknown {
    const obj: any = {};
    if (message.resourceType !== 0) {
      obj.resourceType = upgradeResourceTypeToJSON(message.resourceType);
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.operationStartTime !== undefined) {
      obj.operationStartTime = message.operationStartTime.toISOString();
    }
    if (message.currentVersion !== "") {
      obj.currentVersion = message.currentVersion;
    }
    if (message.targetVersion !== "") {
      obj.targetVersion = message.targetVersion;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeEvent>): UpgradeEvent {
    return UpgradeEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeEvent>): UpgradeEvent {
    const message = createBaseUpgradeEvent();
    message.resourceType = object.resourceType ?? 0;
    message.operation = object.operation ?? "";
    message.operationStartTime = object.operationStartTime ?? undefined;
    message.currentVersion = object.currentVersion ?? "";
    message.targetVersion = object.targetVersion ?? "";
    message.resource = object.resource ?? "";
    return message;
  },
};

function createBaseUpgradeAvailableEvent(): UpgradeAvailableEvent {
  return { version: "", resourceType: 0, releaseChannel: undefined, resource: "" };
}

export const UpgradeAvailableEvent: MessageFns<UpgradeAvailableEvent> = {
  encode(message: UpgradeAvailableEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    if (message.releaseChannel !== undefined) {
      ReleaseChannel.encode(message.releaseChannel, writer.uint32(26).fork()).join();
    }
    if (message.resource !== "") {
      writer.uint32(34).string(message.resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeAvailableEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeAvailableEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.releaseChannel = ReleaseChannel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeAvailableEvent {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      resourceType: isSet(object.resourceType) ? upgradeResourceTypeFromJSON(object.resourceType) : 0,
      releaseChannel: isSet(object.releaseChannel) ? ReleaseChannel.fromJSON(object.releaseChannel) : undefined,
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
    };
  },

  toJSON(message: UpgradeAvailableEvent): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = upgradeResourceTypeToJSON(message.resourceType);
    }
    if (message.releaseChannel !== undefined) {
      obj.releaseChannel = ReleaseChannel.toJSON(message.releaseChannel);
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    return obj;
  },

  create(base?: DeepPartial<UpgradeAvailableEvent>): UpgradeAvailableEvent {
    return UpgradeAvailableEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpgradeAvailableEvent>): UpgradeAvailableEvent {
    const message = createBaseUpgradeAvailableEvent();
    message.version = object.version ?? "";
    message.resourceType = object.resourceType ?? 0;
    message.releaseChannel = (object.releaseChannel !== undefined && object.releaseChannel !== null)
      ? ReleaseChannel.fromPartial(object.releaseChannel)
      : undefined;
    message.resource = object.resource ?? "";
    return message;
  },
};

function createBaseSecurityBulletinEvent(): SecurityBulletinEvent {
  return {
    resourceTypeAffected: "",
    bulletinId: "",
    cveIds: [],
    severity: "",
    bulletinUri: "",
    briefDescription: "",
    affectedSupportedMinors: [],
    patchedVersions: [],
    suggestedUpgradeTarget: "",
    manualStepsRequired: false,
  };
}

export const SecurityBulletinEvent: MessageFns<SecurityBulletinEvent> = {
  encode(message: SecurityBulletinEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceTypeAffected !== "") {
      writer.uint32(10).string(message.resourceTypeAffected);
    }
    if (message.bulletinId !== "") {
      writer.uint32(18).string(message.bulletinId);
    }
    for (const v of message.cveIds) {
      writer.uint32(26).string(v!);
    }
    if (message.severity !== "") {
      writer.uint32(34).string(message.severity);
    }
    if (message.bulletinUri !== "") {
      writer.uint32(42).string(message.bulletinUri);
    }
    if (message.briefDescription !== "") {
      writer.uint32(50).string(message.briefDescription);
    }
    for (const v of message.affectedSupportedMinors) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.patchedVersions) {
      writer.uint32(66).string(v!);
    }
    if (message.suggestedUpgradeTarget !== "") {
      writer.uint32(74).string(message.suggestedUpgradeTarget);
    }
    if (message.manualStepsRequired !== false) {
      writer.uint32(80).bool(message.manualStepsRequired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityBulletinEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityBulletinEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceTypeAffected = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bulletinId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cveIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.severity = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bulletinUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.briefDescription = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.affectedSupportedMinors.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.patchedVersions.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.suggestedUpgradeTarget = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.manualStepsRequired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityBulletinEvent {
    return {
      resourceTypeAffected: isSet(object.resourceTypeAffected) ? globalThis.String(object.resourceTypeAffected) : "",
      bulletinId: isSet(object.bulletinId) ? globalThis.String(object.bulletinId) : "",
      cveIds: globalThis.Array.isArray(object?.cveIds) ? object.cveIds.map((e: any) => globalThis.String(e)) : [],
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      bulletinUri: isSet(object.bulletinUri) ? globalThis.String(object.bulletinUri) : "",
      briefDescription: isSet(object.briefDescription) ? globalThis.String(object.briefDescription) : "",
      affectedSupportedMinors: globalThis.Array.isArray(object?.affectedSupportedMinors)
        ? object.affectedSupportedMinors.map((e: any) => globalThis.String(e))
        : [],
      patchedVersions: globalThis.Array.isArray(object?.patchedVersions)
        ? object.patchedVersions.map((e: any) => globalThis.String(e))
        : [],
      suggestedUpgradeTarget: isSet(object.suggestedUpgradeTarget)
        ? globalThis.String(object.suggestedUpgradeTarget)
        : "",
      manualStepsRequired: isSet(object.manualStepsRequired) ? globalThis.Boolean(object.manualStepsRequired) : false,
    };
  },

  toJSON(message: SecurityBulletinEvent): unknown {
    const obj: any = {};
    if (message.resourceTypeAffected !== "") {
      obj.resourceTypeAffected = message.resourceTypeAffected;
    }
    if (message.bulletinId !== "") {
      obj.bulletinId = message.bulletinId;
    }
    if (message.cveIds?.length) {
      obj.cveIds = message.cveIds;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.bulletinUri !== "") {
      obj.bulletinUri = message.bulletinUri;
    }
    if (message.briefDescription !== "") {
      obj.briefDescription = message.briefDescription;
    }
    if (message.affectedSupportedMinors?.length) {
      obj.affectedSupportedMinors = message.affectedSupportedMinors;
    }
    if (message.patchedVersions?.length) {
      obj.patchedVersions = message.patchedVersions;
    }
    if (message.suggestedUpgradeTarget !== "") {
      obj.suggestedUpgradeTarget = message.suggestedUpgradeTarget;
    }
    if (message.manualStepsRequired !== false) {
      obj.manualStepsRequired = message.manualStepsRequired;
    }
    return obj;
  },

  create(base?: DeepPartial<SecurityBulletinEvent>): SecurityBulletinEvent {
    return SecurityBulletinEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecurityBulletinEvent>): SecurityBulletinEvent {
    const message = createBaseSecurityBulletinEvent();
    message.resourceTypeAffected = object.resourceTypeAffected ?? "";
    message.bulletinId = object.bulletinId ?? "";
    message.cveIds = object.cveIds?.map((e) => e) || [];
    message.severity = object.severity ?? "";
    message.bulletinUri = object.bulletinUri ?? "";
    message.briefDescription = object.briefDescription ?? "";
    message.affectedSupportedMinors = object.affectedSupportedMinors?.map((e) => e) || [];
    message.patchedVersions = object.patchedVersions?.map((e) => e) || [];
    message.suggestedUpgradeTarget = object.suggestedUpgradeTarget ?? "";
    message.manualStepsRequired = object.manualStepsRequired ?? false;
    return message;
  },
};

function createBaseAutopilot(): Autopilot {
  return { enabled: false, workloadPolicyConfig: undefined };
}

export const Autopilot: MessageFns<Autopilot> = {
  encode(message: Autopilot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.workloadPolicyConfig !== undefined) {
      WorkloadPolicyConfig.encode(message.workloadPolicyConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Autopilot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutopilot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workloadPolicyConfig = WorkloadPolicyConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Autopilot {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      workloadPolicyConfig: isSet(object.workloadPolicyConfig)
        ? WorkloadPolicyConfig.fromJSON(object.workloadPolicyConfig)
        : undefined,
    };
  },

  toJSON(message: Autopilot): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.workloadPolicyConfig !== undefined) {
      obj.workloadPolicyConfig = WorkloadPolicyConfig.toJSON(message.workloadPolicyConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Autopilot>): Autopilot {
    return Autopilot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Autopilot>): Autopilot {
    const message = createBaseAutopilot();
    message.enabled = object.enabled ?? false;
    message.workloadPolicyConfig = (object.workloadPolicyConfig !== undefined && object.workloadPolicyConfig !== null)
      ? WorkloadPolicyConfig.fromPartial(object.workloadPolicyConfig)
      : undefined;
    return message;
  },
};

function createBaseWorkloadPolicyConfig(): WorkloadPolicyConfig {
  return { allowNetAdmin: undefined };
}

export const WorkloadPolicyConfig: MessageFns<WorkloadPolicyConfig> = {
  encode(message: WorkloadPolicyConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowNetAdmin !== undefined) {
      writer.uint32(8).bool(message.allowNetAdmin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadPolicyConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadPolicyConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowNetAdmin = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadPolicyConfig {
    return { allowNetAdmin: isSet(object.allowNetAdmin) ? globalThis.Boolean(object.allowNetAdmin) : undefined };
  },

  toJSON(message: WorkloadPolicyConfig): unknown {
    const obj: any = {};
    if (message.allowNetAdmin !== undefined) {
      obj.allowNetAdmin = message.allowNetAdmin;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadPolicyConfig>): WorkloadPolicyConfig {
    return WorkloadPolicyConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadPolicyConfig>): WorkloadPolicyConfig {
    const message = createBaseWorkloadPolicyConfig();
    message.allowNetAdmin = object.allowNetAdmin ?? undefined;
    return message;
  },
};

function createBaseLoggingConfig(): LoggingConfig {
  return { componentConfig: undefined };
}

export const LoggingConfig: MessageFns<LoggingConfig> = {
  encode(message: LoggingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentConfig !== undefined) {
      LoggingComponentConfig.encode(message.componentConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentConfig = LoggingComponentConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggingConfig {
    return {
      componentConfig: isSet(object.componentConfig)
        ? LoggingComponentConfig.fromJSON(object.componentConfig)
        : undefined,
    };
  },

  toJSON(message: LoggingConfig): unknown {
    const obj: any = {};
    if (message.componentConfig !== undefined) {
      obj.componentConfig = LoggingComponentConfig.toJSON(message.componentConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<LoggingConfig>): LoggingConfig {
    return LoggingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggingConfig>): LoggingConfig {
    const message = createBaseLoggingConfig();
    message.componentConfig = (object.componentConfig !== undefined && object.componentConfig !== null)
      ? LoggingComponentConfig.fromPartial(object.componentConfig)
      : undefined;
    return message;
  },
};

function createBaseLoggingComponentConfig(): LoggingComponentConfig {
  return { enableComponents: [] };
}

export const LoggingComponentConfig: MessageFns<LoggingComponentConfig> = {
  encode(message: LoggingComponentConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.enableComponents) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggingComponentConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggingComponentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.enableComponents.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enableComponents.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggingComponentConfig {
    return {
      enableComponents: globalThis.Array.isArray(object?.enableComponents)
        ? object.enableComponents.map((e: any) => loggingComponentConfig_ComponentFromJSON(e))
        : [],
    };
  },

  toJSON(message: LoggingComponentConfig): unknown {
    const obj: any = {};
    if (message.enableComponents?.length) {
      obj.enableComponents = message.enableComponents.map((e) => loggingComponentConfig_ComponentToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LoggingComponentConfig>): LoggingComponentConfig {
    return LoggingComponentConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggingComponentConfig>): LoggingComponentConfig {
    const message = createBaseLoggingComponentConfig();
    message.enableComponents = object.enableComponents?.map((e) => e) || [];
    return message;
  },
};

function createBaseRayClusterLoggingConfig(): RayClusterLoggingConfig {
  return { enabled: false };
}

export const RayClusterLoggingConfig: MessageFns<RayClusterLoggingConfig> = {
  encode(message: RayClusterLoggingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RayClusterLoggingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRayClusterLoggingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RayClusterLoggingConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: RayClusterLoggingConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<RayClusterLoggingConfig>): RayClusterLoggingConfig {
    return RayClusterLoggingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RayClusterLoggingConfig>): RayClusterLoggingConfig {
    const message = createBaseRayClusterLoggingConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseMonitoringConfig(): MonitoringConfig {
  return {
    componentConfig: undefined,
    managedPrometheusConfig: undefined,
    advancedDatapathObservabilityConfig: undefined,
  };
}

export const MonitoringConfig: MessageFns<MonitoringConfig> = {
  encode(message: MonitoringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentConfig !== undefined) {
      MonitoringComponentConfig.encode(message.componentConfig, writer.uint32(10).fork()).join();
    }
    if (message.managedPrometheusConfig !== undefined) {
      ManagedPrometheusConfig.encode(message.managedPrometheusConfig, writer.uint32(18).fork()).join();
    }
    if (message.advancedDatapathObservabilityConfig !== undefined) {
      AdvancedDatapathObservabilityConfig.encode(message.advancedDatapathObservabilityConfig, writer.uint32(26).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentConfig = MonitoringComponentConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.managedPrometheusConfig = ManagedPrometheusConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.advancedDatapathObservabilityConfig = AdvancedDatapathObservabilityConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoringConfig {
    return {
      componentConfig: isSet(object.componentConfig)
        ? MonitoringComponentConfig.fromJSON(object.componentConfig)
        : undefined,
      managedPrometheusConfig: isSet(object.managedPrometheusConfig)
        ? ManagedPrometheusConfig.fromJSON(object.managedPrometheusConfig)
        : undefined,
      advancedDatapathObservabilityConfig: isSet(object.advancedDatapathObservabilityConfig)
        ? AdvancedDatapathObservabilityConfig.fromJSON(object.advancedDatapathObservabilityConfig)
        : undefined,
    };
  },

  toJSON(message: MonitoringConfig): unknown {
    const obj: any = {};
    if (message.componentConfig !== undefined) {
      obj.componentConfig = MonitoringComponentConfig.toJSON(message.componentConfig);
    }
    if (message.managedPrometheusConfig !== undefined) {
      obj.managedPrometheusConfig = ManagedPrometheusConfig.toJSON(message.managedPrometheusConfig);
    }
    if (message.advancedDatapathObservabilityConfig !== undefined) {
      obj.advancedDatapathObservabilityConfig = AdvancedDatapathObservabilityConfig.toJSON(
        message.advancedDatapathObservabilityConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoringConfig>): MonitoringConfig {
    return MonitoringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoringConfig>): MonitoringConfig {
    const message = createBaseMonitoringConfig();
    message.componentConfig = (object.componentConfig !== undefined && object.componentConfig !== null)
      ? MonitoringComponentConfig.fromPartial(object.componentConfig)
      : undefined;
    message.managedPrometheusConfig =
      (object.managedPrometheusConfig !== undefined && object.managedPrometheusConfig !== null)
        ? ManagedPrometheusConfig.fromPartial(object.managedPrometheusConfig)
        : undefined;
    message.advancedDatapathObservabilityConfig =
      (object.advancedDatapathObservabilityConfig !== undefined && object.advancedDatapathObservabilityConfig !== null)
        ? AdvancedDatapathObservabilityConfig.fromPartial(object.advancedDatapathObservabilityConfig)
        : undefined;
    return message;
  },
};

function createBaseAdvancedDatapathObservabilityConfig(): AdvancedDatapathObservabilityConfig {
  return { enableMetrics: false, relayMode: 0, enableRelay: undefined };
}

export const AdvancedDatapathObservabilityConfig: MessageFns<AdvancedDatapathObservabilityConfig> = {
  encode(message: AdvancedDatapathObservabilityConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableMetrics !== false) {
      writer.uint32(8).bool(message.enableMetrics);
    }
    if (message.relayMode !== 0) {
      writer.uint32(16).int32(message.relayMode);
    }
    if (message.enableRelay !== undefined) {
      writer.uint32(24).bool(message.enableRelay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedDatapathObservabilityConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedDatapathObservabilityConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableMetrics = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.relayMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableRelay = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedDatapathObservabilityConfig {
    return {
      enableMetrics: isSet(object.enableMetrics) ? globalThis.Boolean(object.enableMetrics) : false,
      relayMode: isSet(object.relayMode) ? advancedDatapathObservabilityConfig_RelayModeFromJSON(object.relayMode) : 0,
      enableRelay: isSet(object.enableRelay) ? globalThis.Boolean(object.enableRelay) : undefined,
    };
  },

  toJSON(message: AdvancedDatapathObservabilityConfig): unknown {
    const obj: any = {};
    if (message.enableMetrics !== false) {
      obj.enableMetrics = message.enableMetrics;
    }
    if (message.relayMode !== 0) {
      obj.relayMode = advancedDatapathObservabilityConfig_RelayModeToJSON(message.relayMode);
    }
    if (message.enableRelay !== undefined) {
      obj.enableRelay = message.enableRelay;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedDatapathObservabilityConfig>): AdvancedDatapathObservabilityConfig {
    return AdvancedDatapathObservabilityConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedDatapathObservabilityConfig>): AdvancedDatapathObservabilityConfig {
    const message = createBaseAdvancedDatapathObservabilityConfig();
    message.enableMetrics = object.enableMetrics ?? false;
    message.relayMode = object.relayMode ?? 0;
    message.enableRelay = object.enableRelay ?? undefined;
    return message;
  },
};

function createBaseRayClusterMonitoringConfig(): RayClusterMonitoringConfig {
  return { enabled: false };
}

export const RayClusterMonitoringConfig: MessageFns<RayClusterMonitoringConfig> = {
  encode(message: RayClusterMonitoringConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RayClusterMonitoringConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRayClusterMonitoringConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RayClusterMonitoringConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: RayClusterMonitoringConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<RayClusterMonitoringConfig>): RayClusterMonitoringConfig {
    return RayClusterMonitoringConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RayClusterMonitoringConfig>): RayClusterMonitoringConfig {
    const message = createBaseRayClusterMonitoringConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseNodePoolLoggingConfig(): NodePoolLoggingConfig {
  return { variantConfig: undefined };
}

export const NodePoolLoggingConfig: MessageFns<NodePoolLoggingConfig> = {
  encode(message: NodePoolLoggingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantConfig !== undefined) {
      LoggingVariantConfig.encode(message.variantConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodePoolLoggingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodePoolLoggingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.variantConfig = LoggingVariantConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodePoolLoggingConfig {
    return {
      variantConfig: isSet(object.variantConfig) ? LoggingVariantConfig.fromJSON(object.variantConfig) : undefined,
    };
  },

  toJSON(message: NodePoolLoggingConfig): unknown {
    const obj: any = {};
    if (message.variantConfig !== undefined) {
      obj.variantConfig = LoggingVariantConfig.toJSON(message.variantConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NodePoolLoggingConfig>): NodePoolLoggingConfig {
    return NodePoolLoggingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodePoolLoggingConfig>): NodePoolLoggingConfig {
    const message = createBaseNodePoolLoggingConfig();
    message.variantConfig = (object.variantConfig !== undefined && object.variantConfig !== null)
      ? LoggingVariantConfig.fromPartial(object.variantConfig)
      : undefined;
    return message;
  },
};

function createBaseLoggingVariantConfig(): LoggingVariantConfig {
  return { variant: 0 };
}

export const LoggingVariantConfig: MessageFns<LoggingVariantConfig> = {
  encode(message: LoggingVariantConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== 0) {
      writer.uint32(8).int32(message.variant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggingVariantConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggingVariantConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.variant = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggingVariantConfig {
    return { variant: isSet(object.variant) ? loggingVariantConfig_VariantFromJSON(object.variant) : 0 };
  },

  toJSON(message: LoggingVariantConfig): unknown {
    const obj: any = {};
    if (message.variant !== 0) {
      obj.variant = loggingVariantConfig_VariantToJSON(message.variant);
    }
    return obj;
  },

  create(base?: DeepPartial<LoggingVariantConfig>): LoggingVariantConfig {
    return LoggingVariantConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggingVariantConfig>): LoggingVariantConfig {
    const message = createBaseLoggingVariantConfig();
    message.variant = object.variant ?? 0;
    return message;
  },
};

function createBaseMonitoringComponentConfig(): MonitoringComponentConfig {
  return { enableComponents: [] };
}

export const MonitoringComponentConfig: MessageFns<MonitoringComponentConfig> = {
  encode(message: MonitoringComponentConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.enableComponents) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonitoringComponentConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringComponentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.enableComponents.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enableComponents.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoringComponentConfig {
    return {
      enableComponents: globalThis.Array.isArray(object?.enableComponents)
        ? object.enableComponents.map((e: any) => monitoringComponentConfig_ComponentFromJSON(e))
        : [],
    };
  },

  toJSON(message: MonitoringComponentConfig): unknown {
    const obj: any = {};
    if (message.enableComponents?.length) {
      obj.enableComponents = message.enableComponents.map((e) => monitoringComponentConfig_ComponentToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoringComponentConfig>): MonitoringComponentConfig {
    return MonitoringComponentConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoringComponentConfig>): MonitoringComponentConfig {
    const message = createBaseMonitoringComponentConfig();
    message.enableComponents = object.enableComponents?.map((e) => e) || [];
    return message;
  },
};

function createBaseManagedPrometheusConfig(): ManagedPrometheusConfig {
  return { enabled: false };
}

export const ManagedPrometheusConfig: MessageFns<ManagedPrometheusConfig> = {
  encode(message: ManagedPrometheusConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManagedPrometheusConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagedPrometheusConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManagedPrometheusConfig {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: ManagedPrometheusConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<ManagedPrometheusConfig>): ManagedPrometheusConfig {
    return ManagedPrometheusConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManagedPrometheusConfig>): ManagedPrometheusConfig {
    const message = createBaseManagedPrometheusConfig();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseFleet(): Fleet {
  return { project: "", membership: "", preRegistered: false };
}

export const Fleet: MessageFns<Fleet> = {
  encode(message: Fleet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.membership !== "") {
      writer.uint32(18).string(message.membership);
    }
    if (message.preRegistered !== false) {
      writer.uint32(24).bool(message.preRegistered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fleet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFleet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.membership = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.preRegistered = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fleet {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      membership: isSet(object.membership) ? globalThis.String(object.membership) : "",
      preRegistered: isSet(object.preRegistered) ? globalThis.Boolean(object.preRegistered) : false,
    };
  },

  toJSON(message: Fleet): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.membership !== "") {
      obj.membership = message.membership;
    }
    if (message.preRegistered !== false) {
      obj.preRegistered = message.preRegistered;
    }
    return obj;
  },

  create(base?: DeepPartial<Fleet>): Fleet {
    return Fleet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fleet>): Fleet {
    const message = createBaseFleet();
    message.project = object.project ?? "";
    message.membership = object.membership ?? "";
    message.preRegistered = object.preRegistered ?? false;
    return message;
  },
};

function createBaseLocalNvmeSsdBlockConfig(): LocalNvmeSsdBlockConfig {
  return { localSsdCount: 0 };
}

export const LocalNvmeSsdBlockConfig: MessageFns<LocalNvmeSsdBlockConfig> = {
  encode(message: LocalNvmeSsdBlockConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localSsdCount !== 0) {
      writer.uint32(8).int32(message.localSsdCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocalNvmeSsdBlockConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocalNvmeSsdBlockConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.localSsdCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocalNvmeSsdBlockConfig {
    return { localSsdCount: isSet(object.localSsdCount) ? globalThis.Number(object.localSsdCount) : 0 };
  },

  toJSON(message: LocalNvmeSsdBlockConfig): unknown {
    const obj: any = {};
    if (message.localSsdCount !== 0) {
      obj.localSsdCount = Math.round(message.localSsdCount);
    }
    return obj;
  },

  create(base?: DeepPartial<LocalNvmeSsdBlockConfig>): LocalNvmeSsdBlockConfig {
    return LocalNvmeSsdBlockConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocalNvmeSsdBlockConfig>): LocalNvmeSsdBlockConfig {
    const message = createBaseLocalNvmeSsdBlockConfig();
    message.localSsdCount = object.localSsdCount ?? 0;
    return message;
  },
};

function createBaseEphemeralStorageLocalSsdConfig(): EphemeralStorageLocalSsdConfig {
  return { localSsdCount: 0 };
}

export const EphemeralStorageLocalSsdConfig: MessageFns<EphemeralStorageLocalSsdConfig> = {
  encode(message: EphemeralStorageLocalSsdConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localSsdCount !== 0) {
      writer.uint32(8).int32(message.localSsdCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EphemeralStorageLocalSsdConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEphemeralStorageLocalSsdConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.localSsdCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EphemeralStorageLocalSsdConfig {
    return { localSsdCount: isSet(object.localSsdCount) ? globalThis.Number(object.localSsdCount) : 0 };
  },

  toJSON(message: EphemeralStorageLocalSsdConfig): unknown {
    const obj: any = {};
    if (message.localSsdCount !== 0) {
      obj.localSsdCount = Math.round(message.localSsdCount);
    }
    return obj;
  },

  create(base?: DeepPartial<EphemeralStorageLocalSsdConfig>): EphemeralStorageLocalSsdConfig {
    return EphemeralStorageLocalSsdConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EphemeralStorageLocalSsdConfig>): EphemeralStorageLocalSsdConfig {
    const message = createBaseEphemeralStorageLocalSsdConfig();
    message.localSsdCount = object.localSsdCount ?? 0;
    return message;
  },
};

function createBaseResourceManagerTags(): ResourceManagerTags {
  return { tags: {} };
}

export const ResourceManagerTags: MessageFns<ResourceManagerTags> = {
  encode(message: ResourceManagerTags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.tags).forEach(([key, value]) => {
      ResourceManagerTags_TagsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceManagerTags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceManagerTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ResourceManagerTags_TagsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.tags[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceManagerTags {
    return {
      tags: isObject(object.tags)
        ? Object.entries(object.tags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ResourceManagerTags): unknown {
    const obj: any = {};
    if (message.tags) {
      const entries = Object.entries(message.tags);
      if (entries.length > 0) {
        obj.tags = {};
        entries.forEach(([k, v]) => {
          obj.tags[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceManagerTags>): ResourceManagerTags {
    return ResourceManagerTags.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceManagerTags>): ResourceManagerTags {
    const message = createBaseResourceManagerTags();
    message.tags = Object.entries(object.tags ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseResourceManagerTags_TagsEntry(): ResourceManagerTags_TagsEntry {
  return { key: "", value: "" };
}

export const ResourceManagerTags_TagsEntry: MessageFns<ResourceManagerTags_TagsEntry> = {
  encode(message: ResourceManagerTags_TagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceManagerTags_TagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceManagerTags_TagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceManagerTags_TagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceManagerTags_TagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceManagerTags_TagsEntry>): ResourceManagerTags_TagsEntry {
    return ResourceManagerTags_TagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceManagerTags_TagsEntry>): ResourceManagerTags_TagsEntry {
    const message = createBaseResourceManagerTags_TagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnterpriseConfig(): EnterpriseConfig {
  return { clusterTier: 0 };
}

export const EnterpriseConfig: MessageFns<EnterpriseConfig> = {
  encode(message: EnterpriseConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterTier !== 0) {
      writer.uint32(8).int32(message.clusterTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnterpriseConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnterpriseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clusterTier = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnterpriseConfig {
    return { clusterTier: isSet(object.clusterTier) ? enterpriseConfig_ClusterTierFromJSON(object.clusterTier) : 0 };
  },

  toJSON(message: EnterpriseConfig): unknown {
    const obj: any = {};
    if (message.clusterTier !== 0) {
      obj.clusterTier = enterpriseConfig_ClusterTierToJSON(message.clusterTier);
    }
    return obj;
  },

  create(base?: DeepPartial<EnterpriseConfig>): EnterpriseConfig {
    return EnterpriseConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnterpriseConfig>): EnterpriseConfig {
    const message = createBaseEnterpriseConfig();
    message.clusterTier = object.clusterTier ?? 0;
    return message;
  },
};

function createBaseSecondaryBootDisk(): SecondaryBootDisk {
  return { mode: 0, diskImage: "" };
}

export const SecondaryBootDisk: MessageFns<SecondaryBootDisk> = {
  encode(message: SecondaryBootDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.diskImage !== "") {
      writer.uint32(18).string(message.diskImage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecondaryBootDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecondaryBootDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.diskImage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecondaryBootDisk {
    return {
      mode: isSet(object.mode) ? secondaryBootDisk_ModeFromJSON(object.mode) : 0,
      diskImage: isSet(object.diskImage) ? globalThis.String(object.diskImage) : "",
    };
  },

  toJSON(message: SecondaryBootDisk): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = secondaryBootDisk_ModeToJSON(message.mode);
    }
    if (message.diskImage !== "") {
      obj.diskImage = message.diskImage;
    }
    return obj;
  },

  create(base?: DeepPartial<SecondaryBootDisk>): SecondaryBootDisk {
    return SecondaryBootDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecondaryBootDisk>): SecondaryBootDisk {
    const message = createBaseSecondaryBootDisk();
    message.mode = object.mode ?? 0;
    message.diskImage = object.diskImage ?? "";
    return message;
  },
};

function createBaseSecondaryBootDiskUpdateStrategy(): SecondaryBootDiskUpdateStrategy {
  return {};
}

export const SecondaryBootDiskUpdateStrategy: MessageFns<SecondaryBootDiskUpdateStrategy> = {
  encode(_: SecondaryBootDiskUpdateStrategy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecondaryBootDiskUpdateStrategy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecondaryBootDiskUpdateStrategy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SecondaryBootDiskUpdateStrategy {
    return {};
  },

  toJSON(_: SecondaryBootDiskUpdateStrategy): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SecondaryBootDiskUpdateStrategy>): SecondaryBootDiskUpdateStrategy {
    return SecondaryBootDiskUpdateStrategy.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SecondaryBootDiskUpdateStrategy>): SecondaryBootDiskUpdateStrategy {
    const message = createBaseSecondaryBootDiskUpdateStrategy();
    return message;
  },
};

/** Google Kubernetes Engine Cluster Manager v1 */
export type ClusterManagerDefinition = typeof ClusterManagerDefinition;
export const ClusterManagerDefinition = {
  name: "ClusterManager",
  fullName: "google.container.v1.ClusterManager",
  methods: {
    /**
     * Lists all clusters owned by a project in either the specified zone or all
     * zones.
     */
    listClusters: {
      name: "ListClusters",
      requestType: ListClustersRequest,
      requestStream: false,
      responseType: ListClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([15, 112, 114, 111, 106, 101, 99, 116, 95, 105, 100, 44, 122, 111, 110, 101]),
            Buffer.from([6, 112, 97, 114, 101, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              97,
              90,
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a specific cluster. */
    getCluster: {
      name: "GetCluster",
      requestType: GetClusterRequest,
      requestStream: false,
      responseType: Cluster,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              110,
              90,
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a cluster, consisting of the specified number and type of Google
     * Compute Engine instances.
     *
     * By default, the cluster is created in the project's
     * [default
     * network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
     *
     * One firewall is added for the cluster. After cluster creation,
     * the Kubelet creates routes for each node to allow the containers
     * on that node to communicate with all other instances in the
     * cluster.
     *
     * Finally, an entry is added to the project's global metadata indicating
     * which CIDR range the cluster is using.
     */
    createCluster: {
      name: "CreateCluster",
      requestType: CreateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
            ]),
            Buffer.from([14, 112, 97, 114, 101, 110, 116, 44, 99, 108, 117, 115, 116, 101, 114]),
          ],
          578365826: [
            Buffer.from([
              103,
              58,
              1,
              42,
              90,
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the settings of a specific cluster. */
    updateCluster: {
      name: "UpdateCluster",
      requestType: UpdateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
            ]),
            Buffer.from([11, 110, 97, 109, 101, 44, 117, 112, 100, 97, 116, 101]),
          ],
          578365826: [
            Buffer.from([
              116,
              58,
              1,
              42,
              90,
              65,
              58,
              1,
              42,
              26,
              60,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              26,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the version and/or image type for the specified node pool. */
    updateNodePool: {
      name: "UpdateNodePool",
      requestType: UpdateNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              160,
              1,
              58,
              1,
              42,
              90,
              97,
              58,
              1,
              42,
              34,
              92,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              47,
              117,
              112,
              100,
              97,
              116,
              101,
              26,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Sets the autoscaling settings for the specified node pool. */
    setNodePoolAutoscaling: {
      name: "SetNodePoolAutoscaling",
      requestType: SetNodePoolAutoscalingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              180,
              1,
              58,
              1,
              42,
              90,
              102,
              58,
              1,
              42,
              34,
              97,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              47,
              97,
              117,
              116,
              111,
              115,
              99,
              97,
              108,
              105,
              110,
              103,
              34,
              71,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              65,
              117,
              116,
              111,
              115,
              99,
              97,
              108,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the logging service for a specific cluster. */
    setLoggingService: {
      name: "SetLoggingService",
      requestType: SetLoggingServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              42,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
            Buffer.from([
              20,
              110,
              97,
              109,
              101,
              44,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              135,
              1,
              58,
              1,
              42,
              90,
              73,
              58,
              1,
              42,
              34,
              68,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              111,
              103,
              103,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the monitoring service for a specific cluster. */
    setMonitoringService: {
      name: "SetMonitoringService",
      requestType: SetMonitoringServiceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              45,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              109,
              111,
              110,
              105,
              116,
              111,
              114,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
            Buffer.from([
              23,
              110,
              97,
              109,
              101,
              44,
              109,
              111,
              110,
              105,
              116,
              111,
              114,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              141,
              1,
              58,
              1,
              42,
              90,
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              109,
              111,
              110,
              105,
              116,
              111,
              114,
              105,
              110,
              103,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              111,
              110,
              105,
              116,
              111,
              114,
              105,
              110,
              103,
            ]),
          ],
        },
      },
    },
    /** Sets the addons for a specific cluster. */
    setAddonsConfig: {
      name: "SetAddonsConfig",
      requestType: SetAddonsConfigRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              40,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              97,
              100,
              100,
              111,
              110,
              115,
              95,
              99,
              111,
              110,
              102,
              105,
              103,
            ]),
            Buffer.from([18, 110, 97, 109, 101, 44, 97, 100, 100, 111, 110, 115, 95, 99, 111, 110, 102, 105, 103]),
          ],
          578365826: [
            Buffer.from([
              133,
              1,
              58,
              1,
              42,
              90,
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              97,
              100,
              100,
              111,
              110,
              115,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              65,
              100,
              100,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the locations for a specific cluster.
     * Deprecated. Use
     * [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/update)
     * instead.
     *
     * @deprecated
     */
    setLocations: {
      name: "SetLocations",
      requestType: SetLocationsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              36,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
            Buffer.from([14, 110, 97, 109, 101, 44, 108, 111, 99, 97, 116, 105, 111, 110, 115]),
          ],
          578365826: [
            Buffer.from([
              139,
              1,
              58,
              1,
              42,
              90,
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the master for a specific cluster. */
    updateMaster: {
      name: "UpdateMaster",
      requestType: UpdateMasterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              41,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              109,
              97,
              115,
              116,
              101,
              114,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
            Buffer.from([
              19,
              110,
              97,
              109,
              101,
              44,
              109,
              97,
              115,
              116,
              101,
              114,
              95,
              118,
              101,
              114,
              115,
              105,
              111,
              110,
            ]),
          ],
          578365826: [
            Buffer.from([
              136,
              1,
              58,
              1,
              42,
              90,
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              109,
              97,
              115,
              116,
              101,
              114,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              77,
              97,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Sets master auth materials. Currently supports changing the admin password
     * or a specific cluster, either via password generation or explicitly setting
     * the password.
     */
    setMasterAuth: {
      name: "SetMasterAuth",
      requestType: SetMasterAuthRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              144,
              1,
              58,
              1,
              42,
              90,
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              115,
              116,
              101,
              114,
              65,
              117,
              116,
              104,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              115,
              116,
              101,
              114,
              65,
              117,
              116,
              104,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the cluster, including the Kubernetes endpoint and all worker
     * nodes.
     *
     * Firewalls and routes that were configured during cluster creation
     * are also deleted.
     *
     * Other Google Compute Engine resources that might be in use by the cluster,
     * such as load balancer resources, are not deleted if they weren't present
     * when the cluster was initially created.
     */
    deleteCluster: {
      name: "DeleteCluster",
      requestType: DeleteClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              110,
              90,
              62,
              42,
              60,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all operations in a project in a specific zone or all zones. */
    listOperations: {
      name: "ListOperations",
      requestType: ListOperationsRequest,
      requestStream: false,
      responseType: ListOperationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([15, 112, 114, 111, 106, 101, 99, 116, 95, 105, 100, 44, 122, 111, 110, 101]),
            Buffer.from([6, 112, 97, 114, 101, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              101,
              90,
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the specified operation. */
    getOperation: {
      name: "GetOperation",
      requestType: GetOperationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              28,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              116,
              90,
              66,
              18,
              64,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              125,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Cancels the specified operation. */
    cancelOperation: {
      name: "CancelOperation",
      requestType: CancelOperationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              28,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              136,
              1,
              58,
              1,
              42,
              90,
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              123,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              97,
              110,
              99,
              101,
              108,
            ]),
          ],
        },
      },
    },
    /** Returns configuration info about the Google Kubernetes Engine service. */
    getServerConfig: {
      name: "GetServerConfig",
      requestType: GetServerConfigRequest,
      requestStream: false,
      responseType: ServerConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([15, 112, 114, 111, 106, 101, 99, 116, 95, 105, 100, 44, 122, 111, 110, 101]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              103,
              90,
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              115,
              101,
              114,
              118,
              101,
              114,
              99,
              111,
              110,
              102,
              105,
              103,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              115,
              101,
              114,
              118,
              101,
              114,
              67,
              111,
              110,
              102,
              105,
              103,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the public component of the cluster signing keys in
     * JSON Web Key format.
     */
    getJSONWebKeys: {
      name: "GetJSONWebKeys",
      requestType: GetJSONWebKeysRequest,
      requestStream: false,
      responseType: GetJSONWebKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              106,
              119,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists the node pools for a cluster. */
    listNodePools: {
      name: "ListNodePools",
      requestType: ListNodePoolsRequest,
      requestStream: false,
      responseType: ListNodePoolsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
            Buffer.from([6, 112, 97, 114, 101, 110, 116]),
          ],
          578365826: [
            Buffer.from([
              132,
              1,
              90,
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              18,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves the requested node pool. */
    getNodePool: {
      name: "GetNodePool",
      requestType: GetNodePoolRequest,
      requestStream: false,
      responseType: NodePool,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              147,
              1,
              90,
              87,
              18,
              85,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              18,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a node pool for a cluster. */
    createNodePool: {
      name: "CreateNodePool",
      requestType: CreateNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              36,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
            ]),
            Buffer.from([16, 112, 97, 114, 101, 110, 116, 44, 110, 111, 100, 101, 95, 112, 111, 111, 108]),
          ],
          578365826: [
            Buffer.from([
              138,
              1,
              58,
              1,
              42,
              90,
              75,
              58,
              1,
              42,
              34,
              70,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a node pool from a cluster. */
    deleteNodePool: {
      name: "DeleteNodePool",
      requestType: DeleteNodePoolRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              147,
              1,
              90,
              87,
              42,
              85,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              42,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * CompleteNodePoolUpgrade will signal an on-going node pool upgrade to
     * complete.
     */
    completeNodePoolUpgrade: {
      name: "CompleteNodePoolUpgrade",
      requestType: CompleteNodePoolUpgradeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
              85,
              112,
              103,
              114,
              97,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Rolls back a previously Aborted or Failed NodePool upgrade.
     * This makes no changes if the last upgrade successfully completed.
     */
    rollbackNodePoolUpgrade: {
      name: "RollbackNodePoolUpgrade",
      requestType: RollbackNodePoolUpgradeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              171,
              1,
              58,
              1,
              42,
              90,
              99,
              58,
              1,
              42,
              34,
              94,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /** Sets the NodeManagement options for a node pool. */
    setNodePoolManagement: {
      name: "SetNodePoolManagement",
      requestType: SetNodePoolManagementRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              181,
              1,
              58,
              1,
              42,
              90,
              104,
              58,
              1,
              42,
              34,
              99,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              47,
              115,
              101,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /** Sets labels on a cluster. */
    setLabels: {
      name: "SetLabels",
      requestType: SetLabelsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              149,
              1,
              58,
              1,
              42,
              90,
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              76,
              97,
              98,
              101,
              108,
              115,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              76,
              97,
              98,
              101,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Enables or disables the ABAC authorization mechanism on a cluster. */
    setLegacyAbac: {
      name: "SetLegacyAbac",
      requestType: SetLegacyAbacRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              34,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              101,
              110,
              97,
              98,
              108,
              101,
              100,
            ]),
            Buffer.from([12, 110, 97, 109, 101, 44, 101, 110, 97, 98, 108, 101, 100]),
          ],
          578365826: [
            Buffer.from([
              141,
              1,
              58,
              1,
              42,
              90,
              76,
              58,
              1,
              42,
              34,
              71,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              108,
              101,
              103,
              97,
              99,
              121,
              65,
              98,
              97,
              99,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              76,
              101,
              103,
              97,
              99,
              121,
              65,
              98,
              97,
              99,
            ]),
          ],
        },
      },
    },
    /** Starts master IP rotation. */
    startIPRotation: {
      name: "StartIPRotation",
      requestType: StartIPRotationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              148,
              1,
              58,
              1,
              42,
              90,
              81,
              58,
              1,
              42,
              34,
              76,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /** Completes master IP rotation. */
    completeIPRotation: {
      name: "CompleteIPRotation",
      requestType: CompleteIPRotationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
            Buffer.from([4, 110, 97, 109, 101]),
          ],
          578365826: [
            Buffer.from([
              154,
              1,
              58,
              1,
              42,
              90,
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
              34,
              63,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              108,
              101,
              116,
              101,
              73,
              112,
              82,
              111,
              116,
              97,
              116,
              105,
              111,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Sets the size for a specific node pool. The new size will be used for all
     * replicas, including future replicas created by modifying
     * [NodePool.locations][google.container.v1.NodePool.locations].
     */
    setNodePoolSize: {
      name: "SetNodePoolSize",
      requestType: SetNodePoolSizeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              169,
              1,
              58,
              1,
              42,
              90,
              98,
              58,
              1,
              42,
              34,
              93,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              123,
              110,
              111,
              100,
              101,
              95,
              112,
              111,
              111,
              108,
              95,
              105,
              100,
              125,
              47,
              115,
              101,
              116,
              83,
              105,
              122,
              101,
              34,
              64,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              80,
              111,
              111,
              108,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              83,
              105,
              122,
              101,
            ]),
          ],
        },
      },
    },
    /** Enables or disables Network Policy for a cluster. */
    setNetworkPolicy: {
      name: "SetNetworkPolicy",
      requestType: SetNetworkPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              41,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
            ]),
            Buffer.from([
              19,
              110,
              97,
              109,
              101,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              150,
              1,
              58,
              1,
              42,
              90,
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              58,
              115,
              101,
              116,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              121,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Sets the maintenance policy for a cluster. */
    setMaintenancePolicy: {
      name: "SetMaintenancePolicy",
      requestType: SetMaintenancePolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              45,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              44,
              122,
              111,
              110,
              101,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              44,
              109,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
            ]),
            Buffer.from([
              23,
              110,
              97,
              109,
              101,
              44,
              109,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
          578365826: [
            Buffer.from([
              158,
              1,
              58,
              1,
              42,
              90,
              86,
              58,
              1,
              42,
              34,
              81,
              47,
              118,
              49,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              125,
              47,
              122,
              111,
              110,
              101,
              115,
              47,
              123,
              122,
              111,
              110,
              101,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              80,
              111,
              108,
              105,
              99,
              121,
              34,
              65,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              116,
              77,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              80,
              111,
              108,
              105,
              99,
              121,
            ]),
          ],
        },
      },
    },
    /** Lists subnetworks that are usable for creating clusters in a project. */
    listUsableSubnetworks: {
      name: "ListUsableSubnetworks",
      requestType: ListUsableSubnetworksRequest,
      requestStream: false,
      responseType: ListUsableSubnetworksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              103,
              103,
              114,
              101,
              103,
              97,
              116,
              101,
              100,
              47,
              117,
              115,
              97,
              98,
              108,
              101,
              83,
              117,
              98,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Checks the cluster compatibility with Autopilot mode, and returns a list of
     * compatibility issues.
     */
    checkAutopilotCompatibility: {
      name: "CheckAutopilotCompatibility",
      requestType: CheckAutopilotCompatibilityRequest,
      requestStream: false,
      responseType: CheckAutopilotCompatibilityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              74,
              18,
              72,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              99,
              104,
              101,
              99,
              107,
              65,
              117,
              116,
              111,
              112,
              105,
              108,
              111,
              116,
              67,
              111,
              109,
              112,
              97,
              116,
              105,
              98,
              105,
              108,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ClusterManagerServiceImplementation<CallContextExt = {}> {
  /**
   * Lists all clusters owned by a project in either the specified zone or all
   * zones.
   */
  listClusters(
    request: ListClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListClustersResponse>>;
  /** Gets the details of a specific cluster. */
  getCluster(request: GetClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Cluster>>;
  /**
   * Creates a cluster, consisting of the specified number and type of Google
   * Compute Engine instances.
   *
   * By default, the cluster is created in the project's
   * [default
   * network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
   *
   * One firewall is added for the cluster. After cluster creation,
   * the Kubelet creates routes for each node to allow the containers
   * on that node to communicate with all other instances in the
   * cluster.
   *
   * Finally, an entry is added to the project's global metadata indicating
   * which CIDR range the cluster is using.
   */
  createCluster(request: CreateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the settings of a specific cluster. */
  updateCluster(request: UpdateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the version and/or image type for the specified node pool. */
  updateNodePool(
    request: UpdateNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the autoscaling settings for the specified node pool. */
  setNodePoolAutoscaling(
    request: SetNodePoolAutoscalingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the logging service for a specific cluster. */
  setLoggingService(
    request: SetLoggingServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the monitoring service for a specific cluster. */
  setMonitoringService(
    request: SetMonitoringServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the addons for a specific cluster. */
  setAddonsConfig(
    request: SetAddonsConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Sets the locations for a specific cluster.
   * Deprecated. Use
   * [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/update)
   * instead.
   *
   * @deprecated
   */
  setLocations(request: SetLocationsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the master for a specific cluster. */
  updateMaster(request: UpdateMasterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Sets master auth materials. Currently supports changing the admin password
   * or a specific cluster, either via password generation or explicitly setting
   * the password.
   */
  setMasterAuth(request: SetMasterAuthRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes the cluster, including the Kubernetes endpoint and all worker
   * nodes.
   *
   * Firewalls and routes that were configured during cluster creation
   * are also deleted.
   *
   * Other Google Compute Engine resources that might be in use by the cluster,
   * such as load balancer resources, are not deleted if they weren't present
   * when the cluster was initially created.
   */
  deleteCluster(request: DeleteClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists all operations in a project in a specific zone or all zones. */
  listOperations(
    request: ListOperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOperationsResponse>>;
  /** Gets the specified operation. */
  getOperation(request: GetOperationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Cancels the specified operation. */
  cancelOperation(request: CancelOperationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Returns configuration info about the Google Kubernetes Engine service. */
  getServerConfig(
    request: GetServerConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ServerConfig>>;
  /**
   * Gets the public component of the cluster signing keys in
   * JSON Web Key format.
   */
  getJSONWebKeys(
    request: GetJSONWebKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetJSONWebKeysResponse>>;
  /** Lists the node pools for a cluster. */
  listNodePools(
    request: ListNodePoolsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNodePoolsResponse>>;
  /** Retrieves the requested node pool. */
  getNodePool(request: GetNodePoolRequest, context: CallContext & CallContextExt): Promise<DeepPartial<NodePool>>;
  /** Creates a node pool for a cluster. */
  createNodePool(
    request: CreateNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a node pool from a cluster. */
  deleteNodePool(
    request: DeleteNodePoolRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * CompleteNodePoolUpgrade will signal an on-going node pool upgrade to
   * complete.
   */
  completeNodePoolUpgrade(
    request: CompleteNodePoolUpgradeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Rolls back a previously Aborted or Failed NodePool upgrade.
   * This makes no changes if the last upgrade successfully completed.
   */
  rollbackNodePoolUpgrade(
    request: RollbackNodePoolUpgradeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the NodeManagement options for a node pool. */
  setNodePoolManagement(
    request: SetNodePoolManagementRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets labels on a cluster. */
  setLabels(request: SetLabelsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Enables or disables the ABAC authorization mechanism on a cluster. */
  setLegacyAbac(request: SetLegacyAbacRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Starts master IP rotation. */
  startIPRotation(
    request: StartIPRotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Completes master IP rotation. */
  completeIPRotation(
    request: CompleteIPRotationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Sets the size for a specific node pool. The new size will be used for all
   * replicas, including future replicas created by modifying
   * [NodePool.locations][google.container.v1.NodePool.locations].
   */
  setNodePoolSize(
    request: SetNodePoolSizeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Enables or disables Network Policy for a cluster. */
  setNetworkPolicy(
    request: SetNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Sets the maintenance policy for a cluster. */
  setMaintenancePolicy(
    request: SetMaintenancePolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists subnetworks that are usable for creating clusters in a project. */
  listUsableSubnetworks(
    request: ListUsableSubnetworksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListUsableSubnetworksResponse>>;
  /**
   * Checks the cluster compatibility with Autopilot mode, and returns a list of
   * compatibility issues.
   */
  checkAutopilotCompatibility(
    request: CheckAutopilotCompatibilityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CheckAutopilotCompatibilityResponse>>;
}

export interface ClusterManagerClient<CallOptionsExt = {}> {
  /**
   * Lists all clusters owned by a project in either the specified zone or all
   * zones.
   */
  listClusters(
    request: DeepPartial<ListClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListClustersResponse>;
  /** Gets the details of a specific cluster. */
  getCluster(request: DeepPartial<GetClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Cluster>;
  /**
   * Creates a cluster, consisting of the specified number and type of Google
   * Compute Engine instances.
   *
   * By default, the cluster is created in the project's
   * [default
   * network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
   *
   * One firewall is added for the cluster. After cluster creation,
   * the Kubelet creates routes for each node to allow the containers
   * on that node to communicate with all other instances in the
   * cluster.
   *
   * Finally, an entry is added to the project's global metadata indicating
   * which CIDR range the cluster is using.
   */
  createCluster(request: DeepPartial<CreateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the settings of a specific cluster. */
  updateCluster(request: DeepPartial<UpdateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the version and/or image type for the specified node pool. */
  updateNodePool(
    request: DeepPartial<UpdateNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the autoscaling settings for the specified node pool. */
  setNodePoolAutoscaling(
    request: DeepPartial<SetNodePoolAutoscalingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the logging service for a specific cluster. */
  setLoggingService(
    request: DeepPartial<SetLoggingServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the monitoring service for a specific cluster. */
  setMonitoringService(
    request: DeepPartial<SetMonitoringServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the addons for a specific cluster. */
  setAddonsConfig(
    request: DeepPartial<SetAddonsConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Sets the locations for a specific cluster.
   * Deprecated. Use
   * [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters/update)
   * instead.
   *
   * @deprecated
   */
  setLocations(request: DeepPartial<SetLocationsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the master for a specific cluster. */
  updateMaster(request: DeepPartial<UpdateMasterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Sets master auth materials. Currently supports changing the admin password
   * or a specific cluster, either via password generation or explicitly setting
   * the password.
   */
  setMasterAuth(request: DeepPartial<SetMasterAuthRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes the cluster, including the Kubernetes endpoint and all worker
   * nodes.
   *
   * Firewalls and routes that were configured during cluster creation
   * are also deleted.
   *
   * Other Google Compute Engine resources that might be in use by the cluster,
   * such as load balancer resources, are not deleted if they weren't present
   * when the cluster was initially created.
   */
  deleteCluster(request: DeepPartial<DeleteClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists all operations in a project in a specific zone or all zones. */
  listOperations(
    request: DeepPartial<ListOperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOperationsResponse>;
  /** Gets the specified operation. */
  getOperation(request: DeepPartial<GetOperationRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Cancels the specified operation. */
  cancelOperation(request: DeepPartial<CancelOperationRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Returns configuration info about the Google Kubernetes Engine service. */
  getServerConfig(
    request: DeepPartial<GetServerConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ServerConfig>;
  /**
   * Gets the public component of the cluster signing keys in
   * JSON Web Key format.
   */
  getJSONWebKeys(
    request: DeepPartial<GetJSONWebKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetJSONWebKeysResponse>;
  /** Lists the node pools for a cluster. */
  listNodePools(
    request: DeepPartial<ListNodePoolsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNodePoolsResponse>;
  /** Retrieves the requested node pool. */
  getNodePool(request: DeepPartial<GetNodePoolRequest>, options?: CallOptions & CallOptionsExt): Promise<NodePool>;
  /** Creates a node pool for a cluster. */
  createNodePool(
    request: DeepPartial<CreateNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a node pool from a cluster. */
  deleteNodePool(
    request: DeepPartial<DeleteNodePoolRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * CompleteNodePoolUpgrade will signal an on-going node pool upgrade to
   * complete.
   */
  completeNodePoolUpgrade(
    request: DeepPartial<CompleteNodePoolUpgradeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Rolls back a previously Aborted or Failed NodePool upgrade.
   * This makes no changes if the last upgrade successfully completed.
   */
  rollbackNodePoolUpgrade(
    request: DeepPartial<RollbackNodePoolUpgradeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the NodeManagement options for a node pool. */
  setNodePoolManagement(
    request: DeepPartial<SetNodePoolManagementRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets labels on a cluster. */
  setLabels(request: DeepPartial<SetLabelsRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Enables or disables the ABAC authorization mechanism on a cluster. */
  setLegacyAbac(request: DeepPartial<SetLegacyAbacRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Starts master IP rotation. */
  startIPRotation(
    request: DeepPartial<StartIPRotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Completes master IP rotation. */
  completeIPRotation(
    request: DeepPartial<CompleteIPRotationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Sets the size for a specific node pool. The new size will be used for all
   * replicas, including future replicas created by modifying
   * [NodePool.locations][google.container.v1.NodePool.locations].
   */
  setNodePoolSize(
    request: DeepPartial<SetNodePoolSizeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Enables or disables Network Policy for a cluster. */
  setNetworkPolicy(
    request: DeepPartial<SetNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Sets the maintenance policy for a cluster. */
  setMaintenancePolicy(
    request: DeepPartial<SetMaintenancePolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists subnetworks that are usable for creating clusters in a project. */
  listUsableSubnetworks(
    request: DeepPartial<ListUsableSubnetworksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListUsableSubnetworksResponse>;
  /**
   * Checks the cluster compatibility with Autopilot mode, and returns a list of
   * compatibility issues.
   */
  checkAutopilotCompatibility(
    request: DeepPartial<CheckAutopilotCompatibilityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CheckAutopilotCompatibilityResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
