// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/dataflow/v1beta3/environment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Any } from "../../protobuf/any.js";
import { Struct } from "../../protobuf/struct.js";

export const protobufPackage = "google.dataflow.v1beta3";

/**
 * Specifies the processing model used by a
 * [google.dataflow.v1beta3.Job], which determines the way the Job is
 * managed by the Cloud Dataflow service (how workers are scheduled, how
 * inputs are sharded, etc).
 */
export enum JobType {
  /** JOB_TYPE_UNKNOWN - The type of the job is unspecified, or unknown. */
  JOB_TYPE_UNKNOWN = 0,
  /**
   * JOB_TYPE_BATCH - A batch job with a well-defined end point: data is read, data is
   * processed, data is written, and the job is done.
   */
  JOB_TYPE_BATCH = 1,
  /**
   * JOB_TYPE_STREAMING - A continuously streaming job with no end: data is read,
   * processed, and written continuously.
   */
  JOB_TYPE_STREAMING = 2,
  UNRECOGNIZED = -1,
}

export function jobTypeFromJSON(object: any): JobType {
  switch (object) {
    case 0:
    case "JOB_TYPE_UNKNOWN":
      return JobType.JOB_TYPE_UNKNOWN;
    case 1:
    case "JOB_TYPE_BATCH":
      return JobType.JOB_TYPE_BATCH;
    case 2:
    case "JOB_TYPE_STREAMING":
      return JobType.JOB_TYPE_STREAMING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobType.UNRECOGNIZED;
  }
}

export function jobTypeToJSON(object: JobType): string {
  switch (object) {
    case JobType.JOB_TYPE_UNKNOWN:
      return "JOB_TYPE_UNKNOWN";
    case JobType.JOB_TYPE_BATCH:
      return "JOB_TYPE_BATCH";
    case JobType.JOB_TYPE_STREAMING:
      return "JOB_TYPE_STREAMING";
    case JobType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the resource to optimize for in Flexible Resource Scheduling. */
export enum FlexResourceSchedulingGoal {
  /** FLEXRS_UNSPECIFIED - Run in the default mode. */
  FLEXRS_UNSPECIFIED = 0,
  /** FLEXRS_SPEED_OPTIMIZED - Optimize for lower execution time. */
  FLEXRS_SPEED_OPTIMIZED = 1,
  /** FLEXRS_COST_OPTIMIZED - Optimize for lower cost. */
  FLEXRS_COST_OPTIMIZED = 2,
  UNRECOGNIZED = -1,
}

export function flexResourceSchedulingGoalFromJSON(object: any): FlexResourceSchedulingGoal {
  switch (object) {
    case 0:
    case "FLEXRS_UNSPECIFIED":
      return FlexResourceSchedulingGoal.FLEXRS_UNSPECIFIED;
    case 1:
    case "FLEXRS_SPEED_OPTIMIZED":
      return FlexResourceSchedulingGoal.FLEXRS_SPEED_OPTIMIZED;
    case 2:
    case "FLEXRS_COST_OPTIMIZED":
      return FlexResourceSchedulingGoal.FLEXRS_COST_OPTIMIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FlexResourceSchedulingGoal.UNRECOGNIZED;
  }
}

export function flexResourceSchedulingGoalToJSON(object: FlexResourceSchedulingGoal): string {
  switch (object) {
    case FlexResourceSchedulingGoal.FLEXRS_UNSPECIFIED:
      return "FLEXRS_UNSPECIFIED";
    case FlexResourceSchedulingGoal.FLEXRS_SPEED_OPTIMIZED:
      return "FLEXRS_SPEED_OPTIMIZED";
    case FlexResourceSchedulingGoal.FLEXRS_COST_OPTIMIZED:
      return "FLEXRS_COST_OPTIMIZED";
    case FlexResourceSchedulingGoal.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies what happens to a resource when a Cloud Dataflow
 * [google.dataflow.v1beta3.Job][google.dataflow.v1beta3.Job] has completed.
 */
export enum TeardownPolicy {
  /** TEARDOWN_POLICY_UNKNOWN - The teardown policy isn't specified, or is unknown. */
  TEARDOWN_POLICY_UNKNOWN = 0,
  /** TEARDOWN_ALWAYS - Always teardown the resource. */
  TEARDOWN_ALWAYS = 1,
  /**
   * TEARDOWN_ON_SUCCESS - Teardown the resource on success. This is useful for debugging
   * failures.
   */
  TEARDOWN_ON_SUCCESS = 2,
  /**
   * TEARDOWN_NEVER - Never teardown the resource. This is useful for debugging and
   * development.
   */
  TEARDOWN_NEVER = 3,
  UNRECOGNIZED = -1,
}

export function teardownPolicyFromJSON(object: any): TeardownPolicy {
  switch (object) {
    case 0:
    case "TEARDOWN_POLICY_UNKNOWN":
      return TeardownPolicy.TEARDOWN_POLICY_UNKNOWN;
    case 1:
    case "TEARDOWN_ALWAYS":
      return TeardownPolicy.TEARDOWN_ALWAYS;
    case 2:
    case "TEARDOWN_ON_SUCCESS":
      return TeardownPolicy.TEARDOWN_ON_SUCCESS;
    case 3:
    case "TEARDOWN_NEVER":
      return TeardownPolicy.TEARDOWN_NEVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TeardownPolicy.UNRECOGNIZED;
  }
}

export function teardownPolicyToJSON(object: TeardownPolicy): string {
  switch (object) {
    case TeardownPolicy.TEARDOWN_POLICY_UNKNOWN:
      return "TEARDOWN_POLICY_UNKNOWN";
    case TeardownPolicy.TEARDOWN_ALWAYS:
      return "TEARDOWN_ALWAYS";
    case TeardownPolicy.TEARDOWN_ON_SUCCESS:
      return "TEARDOWN_ON_SUCCESS";
    case TeardownPolicy.TEARDOWN_NEVER:
      return "TEARDOWN_NEVER";
    case TeardownPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The default set of packages to be staged on a pool of workers. */
export enum DefaultPackageSet {
  /** DEFAULT_PACKAGE_SET_UNKNOWN - The default set of packages to stage is unknown, or unspecified. */
  DEFAULT_PACKAGE_SET_UNKNOWN = 0,
  /**
   * DEFAULT_PACKAGE_SET_NONE - Indicates that no packages should be staged at the worker unless
   * explicitly specified by the job.
   */
  DEFAULT_PACKAGE_SET_NONE = 1,
  /** DEFAULT_PACKAGE_SET_JAVA - Stage packages typically useful to workers written in Java. */
  DEFAULT_PACKAGE_SET_JAVA = 2,
  /** DEFAULT_PACKAGE_SET_PYTHON - Stage packages typically useful to workers written in Python. */
  DEFAULT_PACKAGE_SET_PYTHON = 3,
  UNRECOGNIZED = -1,
}

export function defaultPackageSetFromJSON(object: any): DefaultPackageSet {
  switch (object) {
    case 0:
    case "DEFAULT_PACKAGE_SET_UNKNOWN":
      return DefaultPackageSet.DEFAULT_PACKAGE_SET_UNKNOWN;
    case 1:
    case "DEFAULT_PACKAGE_SET_NONE":
      return DefaultPackageSet.DEFAULT_PACKAGE_SET_NONE;
    case 2:
    case "DEFAULT_PACKAGE_SET_JAVA":
      return DefaultPackageSet.DEFAULT_PACKAGE_SET_JAVA;
    case 3:
    case "DEFAULT_PACKAGE_SET_PYTHON":
      return DefaultPackageSet.DEFAULT_PACKAGE_SET_PYTHON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DefaultPackageSet.UNRECOGNIZED;
  }
}

export function defaultPackageSetToJSON(object: DefaultPackageSet): string {
  switch (object) {
    case DefaultPackageSet.DEFAULT_PACKAGE_SET_UNKNOWN:
      return "DEFAULT_PACKAGE_SET_UNKNOWN";
    case DefaultPackageSet.DEFAULT_PACKAGE_SET_NONE:
      return "DEFAULT_PACKAGE_SET_NONE";
    case DefaultPackageSet.DEFAULT_PACKAGE_SET_JAVA:
      return "DEFAULT_PACKAGE_SET_JAVA";
    case DefaultPackageSet.DEFAULT_PACKAGE_SET_PYTHON:
      return "DEFAULT_PACKAGE_SET_PYTHON";
    case DefaultPackageSet.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the algorithm used to determine the number of worker
 * processes to run at any given point in time, based on the amount of
 * data left to process, the number of workers, and how quickly
 * existing workers are processing data.
 */
export enum AutoscalingAlgorithm {
  /** AUTOSCALING_ALGORITHM_UNKNOWN - The algorithm is unknown, or unspecified. */
  AUTOSCALING_ALGORITHM_UNKNOWN = 0,
  /** AUTOSCALING_ALGORITHM_NONE - Disable autoscaling. */
  AUTOSCALING_ALGORITHM_NONE = 1,
  /** AUTOSCALING_ALGORITHM_BASIC - Increase worker count over time to reduce job execution time. */
  AUTOSCALING_ALGORITHM_BASIC = 2,
  UNRECOGNIZED = -1,
}

export function autoscalingAlgorithmFromJSON(object: any): AutoscalingAlgorithm {
  switch (object) {
    case 0:
    case "AUTOSCALING_ALGORITHM_UNKNOWN":
      return AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_UNKNOWN;
    case 1:
    case "AUTOSCALING_ALGORITHM_NONE":
      return AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_NONE;
    case 2:
    case "AUTOSCALING_ALGORITHM_BASIC":
      return AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_BASIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutoscalingAlgorithm.UNRECOGNIZED;
  }
}

export function autoscalingAlgorithmToJSON(object: AutoscalingAlgorithm): string {
  switch (object) {
    case AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_UNKNOWN:
      return "AUTOSCALING_ALGORITHM_UNKNOWN";
    case AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_NONE:
      return "AUTOSCALING_ALGORITHM_NONE";
    case AutoscalingAlgorithm.AUTOSCALING_ALGORITHM_BASIC:
      return "AUTOSCALING_ALGORITHM_BASIC";
    case AutoscalingAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies how IP addresses should be allocated to the worker machines. */
export enum WorkerIPAddressConfiguration {
  /** WORKER_IP_UNSPECIFIED - The configuration is unknown, or unspecified. */
  WORKER_IP_UNSPECIFIED = 0,
  /** WORKER_IP_PUBLIC - Workers should have public IP addresses. */
  WORKER_IP_PUBLIC = 1,
  /** WORKER_IP_PRIVATE - Workers should have private IP addresses. */
  WORKER_IP_PRIVATE = 2,
  UNRECOGNIZED = -1,
}

export function workerIPAddressConfigurationFromJSON(object: any): WorkerIPAddressConfiguration {
  switch (object) {
    case 0:
    case "WORKER_IP_UNSPECIFIED":
      return WorkerIPAddressConfiguration.WORKER_IP_UNSPECIFIED;
    case 1:
    case "WORKER_IP_PUBLIC":
      return WorkerIPAddressConfiguration.WORKER_IP_PUBLIC;
    case 2:
    case "WORKER_IP_PRIVATE":
      return WorkerIPAddressConfiguration.WORKER_IP_PRIVATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkerIPAddressConfiguration.UNRECOGNIZED;
  }
}

export function workerIPAddressConfigurationToJSON(object: WorkerIPAddressConfiguration): string {
  switch (object) {
    case WorkerIPAddressConfiguration.WORKER_IP_UNSPECIFIED:
      return "WORKER_IP_UNSPECIFIED";
    case WorkerIPAddressConfiguration.WORKER_IP_PUBLIC:
      return "WORKER_IP_PUBLIC";
    case WorkerIPAddressConfiguration.WORKER_IP_PRIVATE:
      return "WORKER_IP_PRIVATE";
    case WorkerIPAddressConfiguration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the shuffle mode used by a
 * [google.dataflow.v1beta3.Job], which determines the approach data is shuffled
 * during processing. More details in:
 * https://cloud.google.com/dataflow/docs/guides/deploying-a-pipeline#dataflow-shuffle
 */
export enum ShuffleMode {
  /** SHUFFLE_MODE_UNSPECIFIED - Shuffle mode information is not available. */
  SHUFFLE_MODE_UNSPECIFIED = 0,
  /** VM_BASED - Shuffle is done on the worker VMs. */
  VM_BASED = 1,
  /** SERVICE_BASED - Shuffle is done on the service side. */
  SERVICE_BASED = 2,
  UNRECOGNIZED = -1,
}

export function shuffleModeFromJSON(object: any): ShuffleMode {
  switch (object) {
    case 0:
    case "SHUFFLE_MODE_UNSPECIFIED":
      return ShuffleMode.SHUFFLE_MODE_UNSPECIFIED;
    case 1:
    case "VM_BASED":
      return ShuffleMode.VM_BASED;
    case 2:
    case "SERVICE_BASED":
      return ShuffleMode.SERVICE_BASED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ShuffleMode.UNRECOGNIZED;
  }
}

export function shuffleModeToJSON(object: ShuffleMode): string {
  switch (object) {
    case ShuffleMode.SHUFFLE_MODE_UNSPECIFIED:
      return "SHUFFLE_MODE_UNSPECIFIED";
    case ShuffleMode.VM_BASED:
      return "VM_BASED";
    case ShuffleMode.SERVICE_BASED:
      return "SERVICE_BASED";
    case ShuffleMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes the environment in which a Dataflow Job runs. */
export interface Environment {
  /**
   * The prefix of the resources the system should use for temporary
   * storage.  The system will append the suffix "/temp-{JOBNAME} to
   * this resource prefix, where {JOBNAME} is the value of the
   * job_name field.  The resulting bucket and object prefix is used
   * as the prefix of the resources used to store temporary data
   * needed during the job execution.  NOTE: This will override the
   * value in taskrunner_settings.
   * The supported resource type is:
   *
   * Google Cloud Storage:
   *
   *   storage.googleapis.com/{bucket}/{object}
   *   bucket.storage.googleapis.com/{object}
   */
  tempStoragePrefix: string;
  /**
   * The type of cluster manager API to use.  If unknown or
   * unspecified, the service will attempt to choose a reasonable
   * default.  This should be in the form of the API service name,
   * e.g. "compute.googleapis.com".
   */
  clusterManagerApiService: string;
  /**
   * The list of experiments to enable. This field should be used for SDK
   * related experiments and not for service related experiments. The proper
   * field for service related experiments is service_options.
   */
  experiments: string[];
  /**
   * The list of service options to enable. This field should be used for
   * service related experiments only. These experiments, when graduating to GA,
   * should be replaced by dedicated fields or become default (i.e. always on).
   */
  serviceOptions: string[];
  /**
   * If set, contains the Cloud KMS key identifier used to encrypt data
   * at rest, AKA a Customer Managed Encryption Key (CMEK).
   *
   * Format:
   *   projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY
   */
  serviceKmsKeyName: string;
  /**
   * The worker pools. At least one "harness" worker pool must be
   * specified in order for the job to have workers.
   */
  workerPools: WorkerPool[];
  /** A description of the process that generated the request. */
  userAgent:
    | { [key: string]: any }
    | undefined;
  /**
   * A structure describing which components and their versions of the service
   * are required in order to run the job.
   */
  version:
    | { [key: string]: any }
    | undefined;
  /**
   * The dataset for the current project where various workflow
   * related tables are stored.
   *
   * The supported resource type is:
   *
   * Google BigQuery:
   *   bigquery.googleapis.com/{dataset}
   */
  dataset: string;
  /**
   * The Cloud Dataflow SDK pipeline options specified by the user. These
   * options are passed through the service and are used to recreate the
   * SDK pipeline options on the worker in a language agnostic and platform
   * independent way.
   */
  sdkPipelineOptions:
    | { [key: string]: any }
    | undefined;
  /** Experimental settings. */
  internalExperiments:
    | Any
    | undefined;
  /** Identity to run virtual machines as. Defaults to the default account. */
  serviceAccountEmail: string;
  /** Which Flexible Resource Scheduling mode to run in. */
  flexResourceSchedulingGoal: FlexResourceSchedulingGoal;
  /**
   * The Compute Engine region
   * (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in
   * which worker processing should occur, e.g. "us-west1". Mutually exclusive
   * with worker_zone. If neither worker_region nor worker_zone is specified,
   * default to the control plane's region.
   */
  workerRegion: string;
  /**
   * The Compute Engine zone
   * (https://cloud.google.com/compute/docs/regions-zones/regions-zones) in
   * which worker processing should occur, e.g. "us-west1-a". Mutually exclusive
   * with worker_region. If neither worker_region nor worker_zone is specified,
   * a zone in the control plane's region is chosen based on available capacity.
   */
  workerZone: string;
  /** Output only. The shuffle mode used for the job. */
  shuffleMode: ShuffleMode;
  /** Any debugging options to be supplied to the job. */
  debugOptions: DebugOptions | undefined;
}

/**
 * The packages that must be installed in order for a worker to run the
 * steps of the Cloud Dataflow job that will be assigned to its worker
 * pool.
 *
 * This is the mechanism by which the Cloud Dataflow SDK causes code to
 * be loaded onto the workers. For example, the Cloud Dataflow Java SDK
 * might use this to install jars containing the user's code and all of the
 * various dependencies (libraries, data files, etc.) required in order
 * for that code to run.
 */
export interface Package {
  /** The name of the package. */
  name: string;
  /**
   * The resource to read the package from. The supported resource type is:
   *
   * Google Cloud Storage:
   *
   *   storage.googleapis.com/{bucket}
   *   bucket.storage.googleapis.com/
   */
  location: string;
}

/** Describes the data disk used by a workflow job. */
export interface Disk {
  /**
   * Size of disk in GB.  If zero or unspecified, the service will
   * attempt to choose a reasonable default.
   */
  sizeGb: number;
  /**
   * Disk storage type, as defined by Google Compute Engine.  This
   * must be a disk type appropriate to the project and zone in which
   * the workers will run.  If unknown or unspecified, the service
   * will attempt to choose a reasonable default.
   *
   * For example, the standard persistent disk type is a resource name
   * typically ending in "pd-standard".  If SSD persistent disks are
   * available, the resource name typically ends with "pd-ssd".  The
   * actual valid values are defined the Google Compute Engine API,
   * not by the Cloud Dataflow API; consult the Google Compute Engine
   * documentation for more information about determining the set of
   * available disk types for a particular project and zone.
   *
   * Google Compute Engine Disk types are local to a particular
   * project in a particular zone, and so the resource name will
   * typically look something like this:
   *
   * compute.googleapis.com/projects/project-id/zones/zone/diskTypes/pd-standard
   */
  diskType: string;
  /** Directory in a VM where disk is mounted. */
  mountPoint: string;
}

/** Provides data to pass through to the worker harness. */
export interface WorkerSettings {
  /**
   * The base URL for accessing Google Cloud APIs.
   *
   * When workers access Google Cloud APIs, they logically do so via
   * relative URLs.  If this field is specified, it supplies the base
   * URL to use for resolving these relative URLs.  The normative
   * algorithm used is defined by RFC 1808, "Relative Uniform Resource
   * Locators".
   *
   * If not specified, the default value is "http://www.googleapis.com/"
   */
  baseUrl: string;
  /** Whether to send work progress updates to the service. */
  reportingEnabled: boolean;
  /**
   * The Cloud Dataflow service path relative to the root URL, for example,
   * "dataflow/v1b3/projects".
   */
  servicePath: string;
  /**
   * The Shuffle service path relative to the root URL, for example,
   * "shuffle/v1beta1".
   */
  shuffleServicePath: string;
  /** The ID of the worker running this pipeline. */
  workerId: string;
  /**
   * The prefix of the resources the system should use for temporary
   * storage.
   *
   * The supported resource type is:
   *
   * Google Cloud Storage:
   *
   *   storage.googleapis.com/{bucket}/{object}
   *   bucket.storage.googleapis.com/{object}
   */
  tempStoragePrefix: string;
}

/** Taskrunner configuration settings. */
export interface TaskRunnerSettings {
  /**
   * The UNIX user ID on the worker VM to use for tasks launched by
   * taskrunner; e.g. "root".
   */
  taskUser: string;
  /**
   * The UNIX group ID on the worker VM to use for tasks launched by
   * taskrunner; e.g. "wheel".
   */
  taskGroup: string;
  /**
   * The OAuth2 scopes to be requested by the taskrunner in order to
   * access the Cloud Dataflow API.
   */
  oauthScopes: string[];
  /**
   * The base URL for the taskrunner to use when accessing Google Cloud APIs.
   *
   * When workers access Google Cloud APIs, they logically do so via
   * relative URLs.  If this field is specified, it supplies the base
   * URL to use for resolving these relative URLs.  The normative
   * algorithm used is defined by RFC 1808, "Relative Uniform Resource
   * Locators".
   *
   * If not specified, the default value is "http://www.googleapis.com/"
   */
  baseUrl: string;
  /** The API version of endpoint, e.g. "v1b3" */
  dataflowApiVersion: string;
  /** The settings to pass to the parallel worker harness. */
  parallelWorkerSettings:
    | WorkerSettings
    | undefined;
  /** The location on the worker for task-specific subdirectories. */
  baseTaskDir: string;
  /** Whether to continue taskrunner if an exception is hit. */
  continueOnException: boolean;
  /**
   * Whether to send taskrunner log info to Google Compute Engine VM serial
   * console.
   */
  logToSerialconsole: boolean;
  /** Whether to also send taskrunner log info to stderr. */
  alsologtostderr: boolean;
  /**
   * Indicates where to put logs.  If this is not specified, the logs
   * will not be uploaded.
   *
   * The supported resource type is:
   *
   * Google Cloud Storage:
   *   storage.googleapis.com/{bucket}/{object}
   *   bucket.storage.googleapis.com/{object}
   */
  logUploadLocation: string;
  /** The directory on the VM to store logs. */
  logDir: string;
  /**
   * The prefix of the resources the taskrunner should use for
   * temporary storage.
   *
   * The supported resource type is:
   *
   * Google Cloud Storage:
   *   storage.googleapis.com/{bucket}/{object}
   *   bucket.storage.googleapis.com/{object}
   */
  tempStoragePrefix: string;
  /** The command to launch the worker harness. */
  harnessCommand: string;
  /** The file to store the workflow in. */
  workflowFileName: string;
  /** The file to store preprocessing commands in. */
  commandlinesFileName: string;
  /** The ID string of the VM. */
  vmId: string;
  /** The suggested backend language. */
  languageHint: string;
  /** The streaming worker main class name. */
  streamingWorkerMainClass: string;
}

/** Settings for WorkerPool autoscaling. */
export interface AutoscalingSettings {
  /** The algorithm to use for autoscaling. */
  algorithm: AutoscalingAlgorithm;
  /** The maximum number of workers to cap scaling at. */
  maxNumWorkers: number;
}

/** Defines a SDK harness container for executing Dataflow pipelines. */
export interface SdkHarnessContainerImage {
  /** A docker container image that resides in Google Container Registry. */
  containerImage: string;
  /**
   * If true, recommends the Dataflow service to use only one core per SDK
   * container instance with this image. If false (or unset) recommends using
   * more than one core per SDK container instance with this image for
   * efficiency. Note that Dataflow service may choose to override this property
   * if needed.
   */
  useSingleCorePerContainer: boolean;
  /**
   * Environment ID for the Beam runner API proto Environment that corresponds
   * to the current SDK Harness.
   */
  environmentId: string;
  /**
   * The set of capabilities enumerated in the above Environment proto. See also
   * https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/beam_runner_api.proto
   */
  capabilities: string[];
}

/**
 * Describes one particular pool of Cloud Dataflow workers to be
 * instantiated by the Cloud Dataflow service in order to perform the
 * computations required by a job.  Note that a workflow job may use
 * multiple pools, in order to match the various computational
 * requirements of the various stages of the job.
 */
export interface WorkerPool {
  /**
   * The kind of the worker pool; currently only `harness` and `shuffle`
   * are supported.
   */
  kind: string;
  /**
   * Number of Google Compute Engine workers in this pool needed to
   * execute the job.  If zero or unspecified, the service will
   * attempt to choose a reasonable default.
   */
  numWorkers: number;
  /** Packages to be installed on workers. */
  packages: Package[];
  /**
   * The default package set to install.  This allows the service to
   * select a default set of packages which are useful to worker
   * harnesses written in a particular language.
   */
  defaultPackageSet: DefaultPackageSet;
  /**
   * Machine type (e.g. "n1-standard-1").  If empty or unspecified, the
   * service will attempt to choose a reasonable default.
   */
  machineType: string;
  /**
   * Sets the policy for determining when to turndown worker pool.
   * Allowed values are: `TEARDOWN_ALWAYS`, `TEARDOWN_ON_SUCCESS`, and
   * `TEARDOWN_NEVER`.
   * `TEARDOWN_ALWAYS` means workers are always torn down regardless of whether
   * the job succeeds. `TEARDOWN_ON_SUCCESS` means workers are torn down
   * if the job succeeds. `TEARDOWN_NEVER` means the workers are never torn
   * down.
   *
   * If the workers are not torn down by the service, they will
   * continue to run and use Google Compute Engine VM resources in the
   * user's project until they are explicitly terminated by the user.
   * Because of this, Google recommends using the `TEARDOWN_ALWAYS`
   * policy except for small, manually supervised test jobs.
   *
   * If unknown or unspecified, the service will attempt to choose a reasonable
   * default.
   */
  teardownPolicy: TeardownPolicy;
  /**
   * Size of root disk for VMs, in GB.  If zero or unspecified, the service will
   * attempt to choose a reasonable default.
   */
  diskSizeGb: number;
  /**
   * Type of root disk for VMs.  If empty or unspecified, the service will
   * attempt to choose a reasonable default.
   */
  diskType: string;
  /** Fully qualified source image for disks. */
  diskSourceImage: string;
  /**
   * Zone to run the worker pools in.  If empty or unspecified, the service
   * will attempt to choose a reasonable default.
   */
  zone: string;
  /**
   * Settings passed through to Google Compute Engine workers when
   * using the standard Dataflow task runner.  Users should ignore
   * this field.
   */
  taskrunnerSettings:
    | TaskRunnerSettings
    | undefined;
  /**
   * The action to take on host maintenance, as defined by the Google
   * Compute Engine API.
   */
  onHostMaintenance: string;
  /** Data disks that are used by a VM in this workflow. */
  dataDisks: Disk[];
  /** Metadata to set on the Google Compute Engine VMs. */
  metadata: { [key: string]: string };
  /** Settings for autoscaling of this WorkerPool. */
  autoscalingSettings:
    | AutoscalingSettings
    | undefined;
  /** Extra arguments for this worker pool. */
  poolArgs:
    | Any
    | undefined;
  /**
   * Network to which VMs will be assigned.  If empty or unspecified,
   * the service will use the network "default".
   */
  network: string;
  /**
   * Subnetwork to which VMs will be assigned, if desired.  Expected to be of
   * the form "regions/REGION/subnetworks/SUBNETWORK".
   */
  subnetwork: string;
  /**
   * Required. Docker container image that executes the Cloud Dataflow worker
   * harness, residing in Google Container Registry.
   *
   * Deprecated for the Fn API path. Use sdk_harness_container_images instead.
   */
  workerHarnessContainerImage: string;
  /**
   * The number of threads per worker harness. If empty or unspecified, the
   * service will choose a number of threads (according to the number of cores
   * on the selected machine type for batch, or 1 by convention for streaming).
   */
  numThreadsPerWorker: number;
  /** Configuration for VM IPs. */
  ipConfiguration: WorkerIPAddressConfiguration;
  /**
   * Set of SDK harness containers needed to execute this pipeline. This will
   * only be set in the Fn API path. For non-cross-language pipelines this
   * should have only one entry. Cross-language pipelines will have two or more
   * entries.
   */
  sdkHarnessContainerImages: SdkHarnessContainerImage[];
}

export interface WorkerPool_MetadataEntry {
  key: string;
  value: string;
}

/** Describes any options that have an effect on the debugging of pipelines. */
export interface DebugOptions {
  /**
   * When true, enables the logging of the literal hot key to the user's Cloud
   * Logging.
   */
  enableHotKeyLogging: boolean;
}

function createBaseEnvironment(): Environment {
  return {
    tempStoragePrefix: "",
    clusterManagerApiService: "",
    experiments: [],
    serviceOptions: [],
    serviceKmsKeyName: "",
    workerPools: [],
    userAgent: undefined,
    version: undefined,
    dataset: "",
    sdkPipelineOptions: undefined,
    internalExperiments: undefined,
    serviceAccountEmail: "",
    flexResourceSchedulingGoal: 0,
    workerRegion: "",
    workerZone: "",
    shuffleMode: 0,
    debugOptions: undefined,
  };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tempStoragePrefix !== "") {
      writer.uint32(10).string(message.tempStoragePrefix);
    }
    if (message.clusterManagerApiService !== "") {
      writer.uint32(18).string(message.clusterManagerApiService);
    }
    for (const v of message.experiments) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.serviceOptions) {
      writer.uint32(130).string(v!);
    }
    if (message.serviceKmsKeyName !== "") {
      writer.uint32(98).string(message.serviceKmsKeyName);
    }
    for (const v of message.workerPools) {
      WorkerPool.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.userAgent !== undefined) {
      Struct.encode(Struct.wrap(message.userAgent), writer.uint32(42).fork()).join();
    }
    if (message.version !== undefined) {
      Struct.encode(Struct.wrap(message.version), writer.uint32(50).fork()).join();
    }
    if (message.dataset !== "") {
      writer.uint32(58).string(message.dataset);
    }
    if (message.sdkPipelineOptions !== undefined) {
      Struct.encode(Struct.wrap(message.sdkPipelineOptions), writer.uint32(66).fork()).join();
    }
    if (message.internalExperiments !== undefined) {
      Any.encode(message.internalExperiments, writer.uint32(74).fork()).join();
    }
    if (message.serviceAccountEmail !== "") {
      writer.uint32(82).string(message.serviceAccountEmail);
    }
    if (message.flexResourceSchedulingGoal !== 0) {
      writer.uint32(88).int32(message.flexResourceSchedulingGoal);
    }
    if (message.workerRegion !== "") {
      writer.uint32(106).string(message.workerRegion);
    }
    if (message.workerZone !== "") {
      writer.uint32(114).string(message.workerZone);
    }
    if (message.shuffleMode !== 0) {
      writer.uint32(120).int32(message.shuffleMode);
    }
    if (message.debugOptions !== undefined) {
      DebugOptions.encode(message.debugOptions, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tempStoragePrefix = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterManagerApiService = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.experiments.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.serviceOptions.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.serviceKmsKeyName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerPools.push(WorkerPool.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userAgent = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.version = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataset = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sdkPipelineOptions = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.internalExperiments = Any.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.flexResourceSchedulingGoal = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.workerRegion = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.workerZone = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.shuffleMode = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.debugOptions = DebugOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      tempStoragePrefix: isSet(object.tempStoragePrefix) ? globalThis.String(object.tempStoragePrefix) : "",
      clusterManagerApiService: isSet(object.clusterManagerApiService)
        ? globalThis.String(object.clusterManagerApiService)
        : "",
      experiments: globalThis.Array.isArray(object?.experiments)
        ? object.experiments.map((e: any) => globalThis.String(e))
        : [],
      serviceOptions: globalThis.Array.isArray(object?.serviceOptions)
        ? object.serviceOptions.map((e: any) => globalThis.String(e))
        : [],
      serviceKmsKeyName: isSet(object.serviceKmsKeyName) ? globalThis.String(object.serviceKmsKeyName) : "",
      workerPools: globalThis.Array.isArray(object?.workerPools)
        ? object.workerPools.map((e: any) => WorkerPool.fromJSON(e))
        : [],
      userAgent: isObject(object.userAgent) ? object.userAgent : undefined,
      version: isObject(object.version) ? object.version : undefined,
      dataset: isSet(object.dataset) ? globalThis.String(object.dataset) : "",
      sdkPipelineOptions: isObject(object.sdkPipelineOptions) ? object.sdkPipelineOptions : undefined,
      internalExperiments: isSet(object.internalExperiments) ? Any.fromJSON(object.internalExperiments) : undefined,
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      flexResourceSchedulingGoal: isSet(object.flexResourceSchedulingGoal)
        ? flexResourceSchedulingGoalFromJSON(object.flexResourceSchedulingGoal)
        : 0,
      workerRegion: isSet(object.workerRegion) ? globalThis.String(object.workerRegion) : "",
      workerZone: isSet(object.workerZone) ? globalThis.String(object.workerZone) : "",
      shuffleMode: isSet(object.shuffleMode) ? shuffleModeFromJSON(object.shuffleMode) : 0,
      debugOptions: isSet(object.debugOptions) ? DebugOptions.fromJSON(object.debugOptions) : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.tempStoragePrefix !== "") {
      obj.tempStoragePrefix = message.tempStoragePrefix;
    }
    if (message.clusterManagerApiService !== "") {
      obj.clusterManagerApiService = message.clusterManagerApiService;
    }
    if (message.experiments?.length) {
      obj.experiments = message.experiments;
    }
    if (message.serviceOptions?.length) {
      obj.serviceOptions = message.serviceOptions;
    }
    if (message.serviceKmsKeyName !== "") {
      obj.serviceKmsKeyName = message.serviceKmsKeyName;
    }
    if (message.workerPools?.length) {
      obj.workerPools = message.workerPools.map((e) => WorkerPool.toJSON(e));
    }
    if (message.userAgent !== undefined) {
      obj.userAgent = message.userAgent;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.dataset !== "") {
      obj.dataset = message.dataset;
    }
    if (message.sdkPipelineOptions !== undefined) {
      obj.sdkPipelineOptions = message.sdkPipelineOptions;
    }
    if (message.internalExperiments !== undefined) {
      obj.internalExperiments = Any.toJSON(message.internalExperiments);
    }
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.flexResourceSchedulingGoal !== 0) {
      obj.flexResourceSchedulingGoal = flexResourceSchedulingGoalToJSON(message.flexResourceSchedulingGoal);
    }
    if (message.workerRegion !== "") {
      obj.workerRegion = message.workerRegion;
    }
    if (message.workerZone !== "") {
      obj.workerZone = message.workerZone;
    }
    if (message.shuffleMode !== 0) {
      obj.shuffleMode = shuffleModeToJSON(message.shuffleMode);
    }
    if (message.debugOptions !== undefined) {
      obj.debugOptions = DebugOptions.toJSON(message.debugOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.tempStoragePrefix = object.tempStoragePrefix ?? "";
    message.clusterManagerApiService = object.clusterManagerApiService ?? "";
    message.experiments = object.experiments?.map((e) => e) || [];
    message.serviceOptions = object.serviceOptions?.map((e) => e) || [];
    message.serviceKmsKeyName = object.serviceKmsKeyName ?? "";
    message.workerPools = object.workerPools?.map((e) => WorkerPool.fromPartial(e)) || [];
    message.userAgent = object.userAgent ?? undefined;
    message.version = object.version ?? undefined;
    message.dataset = object.dataset ?? "";
    message.sdkPipelineOptions = object.sdkPipelineOptions ?? undefined;
    message.internalExperiments = (object.internalExperiments !== undefined && object.internalExperiments !== null)
      ? Any.fromPartial(object.internalExperiments)
      : undefined;
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.flexResourceSchedulingGoal = object.flexResourceSchedulingGoal ?? 0;
    message.workerRegion = object.workerRegion ?? "";
    message.workerZone = object.workerZone ?? "";
    message.shuffleMode = object.shuffleMode ?? 0;
    message.debugOptions = (object.debugOptions !== undefined && object.debugOptions !== null)
      ? DebugOptions.fromPartial(object.debugOptions)
      : undefined;
    return message;
  },
};

function createBasePackage(): Package {
  return { name: "", location: "" };
}

export const Package: MessageFns<Package> = {
  encode(message: Package, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Package {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Package {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: Package): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<Package>): Package {
    return Package.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Package>): Package {
    const message = createBasePackage();
    message.name = object.name ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseDisk(): Disk {
  return { sizeGb: 0, diskType: "", mountPoint: "" };
}

export const Disk: MessageFns<Disk> = {
  encode(message: Disk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeGb !== 0) {
      writer.uint32(8).int32(message.sizeGb);
    }
    if (message.diskType !== "") {
      writer.uint32(18).string(message.diskType);
    }
    if (message.mountPoint !== "") {
      writer.uint32(26).string(message.mountPoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sizeGb = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mountPoint = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Disk {
    return {
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      mountPoint: isSet(object.mountPoint) ? globalThis.String(object.mountPoint) : "",
    };
  },

  toJSON(message: Disk): unknown {
    const obj: any = {};
    if (message.sizeGb !== 0) {
      obj.sizeGb = Math.round(message.sizeGb);
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.mountPoint !== "") {
      obj.mountPoint = message.mountPoint;
    }
    return obj;
  },

  create(base?: DeepPartial<Disk>): Disk {
    return Disk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Disk>): Disk {
    const message = createBaseDisk();
    message.sizeGb = object.sizeGb ?? 0;
    message.diskType = object.diskType ?? "";
    message.mountPoint = object.mountPoint ?? "";
    return message;
  },
};

function createBaseWorkerSettings(): WorkerSettings {
  return {
    baseUrl: "",
    reportingEnabled: false,
    servicePath: "",
    shuffleServicePath: "",
    workerId: "",
    tempStoragePrefix: "",
  };
}

export const WorkerSettings: MessageFns<WorkerSettings> = {
  encode(message: WorkerSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseUrl !== "") {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.reportingEnabled !== false) {
      writer.uint32(16).bool(message.reportingEnabled);
    }
    if (message.servicePath !== "") {
      writer.uint32(26).string(message.servicePath);
    }
    if (message.shuffleServicePath !== "") {
      writer.uint32(34).string(message.shuffleServicePath);
    }
    if (message.workerId !== "") {
      writer.uint32(42).string(message.workerId);
    }
    if (message.tempStoragePrefix !== "") {
      writer.uint32(50).string(message.tempStoragePrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reportingEnabled = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.servicePath = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.shuffleServicePath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tempStoragePrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerSettings {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      reportingEnabled: isSet(object.reportingEnabled) ? globalThis.Boolean(object.reportingEnabled) : false,
      servicePath: isSet(object.servicePath) ? globalThis.String(object.servicePath) : "",
      shuffleServicePath: isSet(object.shuffleServicePath) ? globalThis.String(object.shuffleServicePath) : "",
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      tempStoragePrefix: isSet(object.tempStoragePrefix) ? globalThis.String(object.tempStoragePrefix) : "",
    };
  },

  toJSON(message: WorkerSettings): unknown {
    const obj: any = {};
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.reportingEnabled !== false) {
      obj.reportingEnabled = message.reportingEnabled;
    }
    if (message.servicePath !== "") {
      obj.servicePath = message.servicePath;
    }
    if (message.shuffleServicePath !== "") {
      obj.shuffleServicePath = message.shuffleServicePath;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.tempStoragePrefix !== "") {
      obj.tempStoragePrefix = message.tempStoragePrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerSettings>): WorkerSettings {
    return WorkerSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerSettings>): WorkerSettings {
    const message = createBaseWorkerSettings();
    message.baseUrl = object.baseUrl ?? "";
    message.reportingEnabled = object.reportingEnabled ?? false;
    message.servicePath = object.servicePath ?? "";
    message.shuffleServicePath = object.shuffleServicePath ?? "";
    message.workerId = object.workerId ?? "";
    message.tempStoragePrefix = object.tempStoragePrefix ?? "";
    return message;
  },
};

function createBaseTaskRunnerSettings(): TaskRunnerSettings {
  return {
    taskUser: "",
    taskGroup: "",
    oauthScopes: [],
    baseUrl: "",
    dataflowApiVersion: "",
    parallelWorkerSettings: undefined,
    baseTaskDir: "",
    continueOnException: false,
    logToSerialconsole: false,
    alsologtostderr: false,
    logUploadLocation: "",
    logDir: "",
    tempStoragePrefix: "",
    harnessCommand: "",
    workflowFileName: "",
    commandlinesFileName: "",
    vmId: "",
    languageHint: "",
    streamingWorkerMainClass: "",
  };
}

export const TaskRunnerSettings: MessageFns<TaskRunnerSettings> = {
  encode(message: TaskRunnerSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskUser !== "") {
      writer.uint32(10).string(message.taskUser);
    }
    if (message.taskGroup !== "") {
      writer.uint32(18).string(message.taskGroup);
    }
    for (const v of message.oauthScopes) {
      writer.uint32(26).string(v!);
    }
    if (message.baseUrl !== "") {
      writer.uint32(34).string(message.baseUrl);
    }
    if (message.dataflowApiVersion !== "") {
      writer.uint32(42).string(message.dataflowApiVersion);
    }
    if (message.parallelWorkerSettings !== undefined) {
      WorkerSettings.encode(message.parallelWorkerSettings, writer.uint32(50).fork()).join();
    }
    if (message.baseTaskDir !== "") {
      writer.uint32(58).string(message.baseTaskDir);
    }
    if (message.continueOnException !== false) {
      writer.uint32(64).bool(message.continueOnException);
    }
    if (message.logToSerialconsole !== false) {
      writer.uint32(72).bool(message.logToSerialconsole);
    }
    if (message.alsologtostderr !== false) {
      writer.uint32(80).bool(message.alsologtostderr);
    }
    if (message.logUploadLocation !== "") {
      writer.uint32(90).string(message.logUploadLocation);
    }
    if (message.logDir !== "") {
      writer.uint32(98).string(message.logDir);
    }
    if (message.tempStoragePrefix !== "") {
      writer.uint32(106).string(message.tempStoragePrefix);
    }
    if (message.harnessCommand !== "") {
      writer.uint32(114).string(message.harnessCommand);
    }
    if (message.workflowFileName !== "") {
      writer.uint32(122).string(message.workflowFileName);
    }
    if (message.commandlinesFileName !== "") {
      writer.uint32(130).string(message.commandlinesFileName);
    }
    if (message.vmId !== "") {
      writer.uint32(138).string(message.vmId);
    }
    if (message.languageHint !== "") {
      writer.uint32(146).string(message.languageHint);
    }
    if (message.streamingWorkerMainClass !== "") {
      writer.uint32(154).string(message.streamingWorkerMainClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskRunnerSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskRunnerSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskUser = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskGroup = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oauthScopes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataflowApiVersion = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parallelWorkerSettings = WorkerSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.baseTaskDir = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.continueOnException = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.logToSerialconsole = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.alsologtostderr = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.logUploadLocation = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.logDir = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.tempStoragePrefix = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.harnessCommand = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.workflowFileName = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.commandlinesFileName = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.vmId = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.languageHint = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.streamingWorkerMainClass = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskRunnerSettings {
    return {
      taskUser: isSet(object.taskUser) ? globalThis.String(object.taskUser) : "",
      taskGroup: isSet(object.taskGroup) ? globalThis.String(object.taskGroup) : "",
      oauthScopes: globalThis.Array.isArray(object?.oauthScopes)
        ? object.oauthScopes.map((e: any) => globalThis.String(e))
        : [],
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      dataflowApiVersion: isSet(object.dataflowApiVersion) ? globalThis.String(object.dataflowApiVersion) : "",
      parallelWorkerSettings: isSet(object.parallelWorkerSettings)
        ? WorkerSettings.fromJSON(object.parallelWorkerSettings)
        : undefined,
      baseTaskDir: isSet(object.baseTaskDir) ? globalThis.String(object.baseTaskDir) : "",
      continueOnException: isSet(object.continueOnException) ? globalThis.Boolean(object.continueOnException) : false,
      logToSerialconsole: isSet(object.logToSerialconsole) ? globalThis.Boolean(object.logToSerialconsole) : false,
      alsologtostderr: isSet(object.alsologtostderr) ? globalThis.Boolean(object.alsologtostderr) : false,
      logUploadLocation: isSet(object.logUploadLocation) ? globalThis.String(object.logUploadLocation) : "",
      logDir: isSet(object.logDir) ? globalThis.String(object.logDir) : "",
      tempStoragePrefix: isSet(object.tempStoragePrefix) ? globalThis.String(object.tempStoragePrefix) : "",
      harnessCommand: isSet(object.harnessCommand) ? globalThis.String(object.harnessCommand) : "",
      workflowFileName: isSet(object.workflowFileName) ? globalThis.String(object.workflowFileName) : "",
      commandlinesFileName: isSet(object.commandlinesFileName) ? globalThis.String(object.commandlinesFileName) : "",
      vmId: isSet(object.vmId) ? globalThis.String(object.vmId) : "",
      languageHint: isSet(object.languageHint) ? globalThis.String(object.languageHint) : "",
      streamingWorkerMainClass: isSet(object.streamingWorkerMainClass)
        ? globalThis.String(object.streamingWorkerMainClass)
        : "",
    };
  },

  toJSON(message: TaskRunnerSettings): unknown {
    const obj: any = {};
    if (message.taskUser !== "") {
      obj.taskUser = message.taskUser;
    }
    if (message.taskGroup !== "") {
      obj.taskGroup = message.taskGroup;
    }
    if (message.oauthScopes?.length) {
      obj.oauthScopes = message.oauthScopes;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.dataflowApiVersion !== "") {
      obj.dataflowApiVersion = message.dataflowApiVersion;
    }
    if (message.parallelWorkerSettings !== undefined) {
      obj.parallelWorkerSettings = WorkerSettings.toJSON(message.parallelWorkerSettings);
    }
    if (message.baseTaskDir !== "") {
      obj.baseTaskDir = message.baseTaskDir;
    }
    if (message.continueOnException !== false) {
      obj.continueOnException = message.continueOnException;
    }
    if (message.logToSerialconsole !== false) {
      obj.logToSerialconsole = message.logToSerialconsole;
    }
    if (message.alsologtostderr !== false) {
      obj.alsologtostderr = message.alsologtostderr;
    }
    if (message.logUploadLocation !== "") {
      obj.logUploadLocation = message.logUploadLocation;
    }
    if (message.logDir !== "") {
      obj.logDir = message.logDir;
    }
    if (message.tempStoragePrefix !== "") {
      obj.tempStoragePrefix = message.tempStoragePrefix;
    }
    if (message.harnessCommand !== "") {
      obj.harnessCommand = message.harnessCommand;
    }
    if (message.workflowFileName !== "") {
      obj.workflowFileName = message.workflowFileName;
    }
    if (message.commandlinesFileName !== "") {
      obj.commandlinesFileName = message.commandlinesFileName;
    }
    if (message.vmId !== "") {
      obj.vmId = message.vmId;
    }
    if (message.languageHint !== "") {
      obj.languageHint = message.languageHint;
    }
    if (message.streamingWorkerMainClass !== "") {
      obj.streamingWorkerMainClass = message.streamingWorkerMainClass;
    }
    return obj;
  },

  create(base?: DeepPartial<TaskRunnerSettings>): TaskRunnerSettings {
    return TaskRunnerSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskRunnerSettings>): TaskRunnerSettings {
    const message = createBaseTaskRunnerSettings();
    message.taskUser = object.taskUser ?? "";
    message.taskGroup = object.taskGroup ?? "";
    message.oauthScopes = object.oauthScopes?.map((e) => e) || [];
    message.baseUrl = object.baseUrl ?? "";
    message.dataflowApiVersion = object.dataflowApiVersion ?? "";
    message.parallelWorkerSettings =
      (object.parallelWorkerSettings !== undefined && object.parallelWorkerSettings !== null)
        ? WorkerSettings.fromPartial(object.parallelWorkerSettings)
        : undefined;
    message.baseTaskDir = object.baseTaskDir ?? "";
    message.continueOnException = object.continueOnException ?? false;
    message.logToSerialconsole = object.logToSerialconsole ?? false;
    message.alsologtostderr = object.alsologtostderr ?? false;
    message.logUploadLocation = object.logUploadLocation ?? "";
    message.logDir = object.logDir ?? "";
    message.tempStoragePrefix = object.tempStoragePrefix ?? "";
    message.harnessCommand = object.harnessCommand ?? "";
    message.workflowFileName = object.workflowFileName ?? "";
    message.commandlinesFileName = object.commandlinesFileName ?? "";
    message.vmId = object.vmId ?? "";
    message.languageHint = object.languageHint ?? "";
    message.streamingWorkerMainClass = object.streamingWorkerMainClass ?? "";
    return message;
  },
};

function createBaseAutoscalingSettings(): AutoscalingSettings {
  return { algorithm: 0, maxNumWorkers: 0 };
}

export const AutoscalingSettings: MessageFns<AutoscalingSettings> = {
  encode(message: AutoscalingSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== 0) {
      writer.uint32(8).int32(message.algorithm);
    }
    if (message.maxNumWorkers !== 0) {
      writer.uint32(16).int32(message.maxNumWorkers);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxNumWorkers = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingSettings {
    return {
      algorithm: isSet(object.algorithm) ? autoscalingAlgorithmFromJSON(object.algorithm) : 0,
      maxNumWorkers: isSet(object.maxNumWorkers) ? globalThis.Number(object.maxNumWorkers) : 0,
    };
  },

  toJSON(message: AutoscalingSettings): unknown {
    const obj: any = {};
    if (message.algorithm !== 0) {
      obj.algorithm = autoscalingAlgorithmToJSON(message.algorithm);
    }
    if (message.maxNumWorkers !== 0) {
      obj.maxNumWorkers = Math.round(message.maxNumWorkers);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingSettings>): AutoscalingSettings {
    return AutoscalingSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingSettings>): AutoscalingSettings {
    const message = createBaseAutoscalingSettings();
    message.algorithm = object.algorithm ?? 0;
    message.maxNumWorkers = object.maxNumWorkers ?? 0;
    return message;
  },
};

function createBaseSdkHarnessContainerImage(): SdkHarnessContainerImage {
  return { containerImage: "", useSingleCorePerContainer: false, environmentId: "", capabilities: [] };
}

export const SdkHarnessContainerImage: MessageFns<SdkHarnessContainerImage> = {
  encode(message: SdkHarnessContainerImage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerImage !== "") {
      writer.uint32(10).string(message.containerImage);
    }
    if (message.useSingleCorePerContainer !== false) {
      writer.uint32(16).bool(message.useSingleCorePerContainer);
    }
    if (message.environmentId !== "") {
      writer.uint32(26).string(message.environmentId);
    }
    for (const v of message.capabilities) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SdkHarnessContainerImage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSdkHarnessContainerImage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.useSingleCorePerContainer = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.environmentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SdkHarnessContainerImage {
    return {
      containerImage: isSet(object.containerImage) ? globalThis.String(object.containerImage) : "",
      useSingleCorePerContainer: isSet(object.useSingleCorePerContainer)
        ? globalThis.Boolean(object.useSingleCorePerContainer)
        : false,
      environmentId: isSet(object.environmentId) ? globalThis.String(object.environmentId) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SdkHarnessContainerImage): unknown {
    const obj: any = {};
    if (message.containerImage !== "") {
      obj.containerImage = message.containerImage;
    }
    if (message.useSingleCorePerContainer !== false) {
      obj.useSingleCorePerContainer = message.useSingleCorePerContainer;
    }
    if (message.environmentId !== "") {
      obj.environmentId = message.environmentId;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    return obj;
  },

  create(base?: DeepPartial<SdkHarnessContainerImage>): SdkHarnessContainerImage {
    return SdkHarnessContainerImage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SdkHarnessContainerImage>): SdkHarnessContainerImage {
    const message = createBaseSdkHarnessContainerImage();
    message.containerImage = object.containerImage ?? "";
    message.useSingleCorePerContainer = object.useSingleCorePerContainer ?? false;
    message.environmentId = object.environmentId ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkerPool(): WorkerPool {
  return {
    kind: "",
    numWorkers: 0,
    packages: [],
    defaultPackageSet: 0,
    machineType: "",
    teardownPolicy: 0,
    diskSizeGb: 0,
    diskType: "",
    diskSourceImage: "",
    zone: "",
    taskrunnerSettings: undefined,
    onHostMaintenance: "",
    dataDisks: [],
    metadata: {},
    autoscalingSettings: undefined,
    poolArgs: undefined,
    network: "",
    subnetwork: "",
    workerHarnessContainerImage: "",
    numThreadsPerWorker: 0,
    ipConfiguration: 0,
    sdkHarnessContainerImages: [],
  };
}

export const WorkerPool: MessageFns<WorkerPool> = {
  encode(message: WorkerPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.numWorkers !== 0) {
      writer.uint32(16).int32(message.numWorkers);
    }
    for (const v of message.packages) {
      Package.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.defaultPackageSet !== 0) {
      writer.uint32(32).int32(message.defaultPackageSet);
    }
    if (message.machineType !== "") {
      writer.uint32(42).string(message.machineType);
    }
    if (message.teardownPolicy !== 0) {
      writer.uint32(48).int32(message.teardownPolicy);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(56).int32(message.diskSizeGb);
    }
    if (message.diskType !== "") {
      writer.uint32(130).string(message.diskType);
    }
    if (message.diskSourceImage !== "") {
      writer.uint32(66).string(message.diskSourceImage);
    }
    if (message.zone !== "") {
      writer.uint32(74).string(message.zone);
    }
    if (message.taskrunnerSettings !== undefined) {
      TaskRunnerSettings.encode(message.taskrunnerSettings, writer.uint32(82).fork()).join();
    }
    if (message.onHostMaintenance !== "") {
      writer.uint32(90).string(message.onHostMaintenance);
    }
    for (const v of message.dataDisks) {
      Disk.encode(v!, writer.uint32(98).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      WorkerPool_MetadataEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.autoscalingSettings !== undefined) {
      AutoscalingSettings.encode(message.autoscalingSettings, writer.uint32(114).fork()).join();
    }
    if (message.poolArgs !== undefined) {
      Any.encode(message.poolArgs, writer.uint32(122).fork()).join();
    }
    if (message.network !== "") {
      writer.uint32(138).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(154).string(message.subnetwork);
    }
    if (message.workerHarnessContainerImage !== "") {
      writer.uint32(146).string(message.workerHarnessContainerImage);
    }
    if (message.numThreadsPerWorker !== 0) {
      writer.uint32(160).int32(message.numThreadsPerWorker);
    }
    if (message.ipConfiguration !== 0) {
      writer.uint32(168).int32(message.ipConfiguration);
    }
    for (const v of message.sdkHarnessContainerImages) {
      SdkHarnessContainerImage.encode(v!, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numWorkers = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.packages.push(Package.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.defaultPackageSet = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.teardownPolicy = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.diskSourceImage = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.taskrunnerSettings = TaskRunnerSettings.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.onHostMaintenance = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.dataDisks.push(Disk.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = WorkerPool_MetadataEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.metadata[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.autoscalingSettings = AutoscalingSettings.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.poolArgs = Any.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.network = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.workerHarnessContainerImage = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.numThreadsPerWorker = reader.int32();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.ipConfiguration = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.sdkHarnessContainerImages.push(SdkHarnessContainerImage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerPool {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      numWorkers: isSet(object.numWorkers) ? globalThis.Number(object.numWorkers) : 0,
      packages: globalThis.Array.isArray(object?.packages) ? object.packages.map((e: any) => Package.fromJSON(e)) : [],
      defaultPackageSet: isSet(object.defaultPackageSet) ? defaultPackageSetFromJSON(object.defaultPackageSet) : 0,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      teardownPolicy: isSet(object.teardownPolicy) ? teardownPolicyFromJSON(object.teardownPolicy) : 0,
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : "",
      diskSourceImage: isSet(object.diskSourceImage) ? globalThis.String(object.diskSourceImage) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      taskrunnerSettings: isSet(object.taskrunnerSettings)
        ? TaskRunnerSettings.fromJSON(object.taskrunnerSettings)
        : undefined,
      onHostMaintenance: isSet(object.onHostMaintenance) ? globalThis.String(object.onHostMaintenance) : "",
      dataDisks: globalThis.Array.isArray(object?.dataDisks) ? object.dataDisks.map((e: any) => Disk.fromJSON(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      autoscalingSettings: isSet(object.autoscalingSettings)
        ? AutoscalingSettings.fromJSON(object.autoscalingSettings)
        : undefined,
      poolArgs: isSet(object.poolArgs) ? Any.fromJSON(object.poolArgs) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      workerHarnessContainerImage: isSet(object.workerHarnessContainerImage)
        ? globalThis.String(object.workerHarnessContainerImage)
        : "",
      numThreadsPerWorker: isSet(object.numThreadsPerWorker) ? globalThis.Number(object.numThreadsPerWorker) : 0,
      ipConfiguration: isSet(object.ipConfiguration) ? workerIPAddressConfigurationFromJSON(object.ipConfiguration) : 0,
      sdkHarnessContainerImages: globalThis.Array.isArray(object?.sdkHarnessContainerImages)
        ? object.sdkHarnessContainerImages.map((e: any) => SdkHarnessContainerImage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WorkerPool): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.numWorkers !== 0) {
      obj.numWorkers = Math.round(message.numWorkers);
    }
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => Package.toJSON(e));
    }
    if (message.defaultPackageSet !== 0) {
      obj.defaultPackageSet = defaultPackageSetToJSON(message.defaultPackageSet);
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.teardownPolicy !== 0) {
      obj.teardownPolicy = teardownPolicyToJSON(message.teardownPolicy);
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.diskType !== "") {
      obj.diskType = message.diskType;
    }
    if (message.diskSourceImage !== "") {
      obj.diskSourceImage = message.diskSourceImage;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.taskrunnerSettings !== undefined) {
      obj.taskrunnerSettings = TaskRunnerSettings.toJSON(message.taskrunnerSettings);
    }
    if (message.onHostMaintenance !== "") {
      obj.onHostMaintenance = message.onHostMaintenance;
    }
    if (message.dataDisks?.length) {
      obj.dataDisks = message.dataDisks.map((e) => Disk.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.autoscalingSettings !== undefined) {
      obj.autoscalingSettings = AutoscalingSettings.toJSON(message.autoscalingSettings);
    }
    if (message.poolArgs !== undefined) {
      obj.poolArgs = Any.toJSON(message.poolArgs);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.workerHarnessContainerImage !== "") {
      obj.workerHarnessContainerImage = message.workerHarnessContainerImage;
    }
    if (message.numThreadsPerWorker !== 0) {
      obj.numThreadsPerWorker = Math.round(message.numThreadsPerWorker);
    }
    if (message.ipConfiguration !== 0) {
      obj.ipConfiguration = workerIPAddressConfigurationToJSON(message.ipConfiguration);
    }
    if (message.sdkHarnessContainerImages?.length) {
      obj.sdkHarnessContainerImages = message.sdkHarnessContainerImages.map((e) => SdkHarnessContainerImage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerPool>): WorkerPool {
    return WorkerPool.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerPool>): WorkerPool {
    const message = createBaseWorkerPool();
    message.kind = object.kind ?? "";
    message.numWorkers = object.numWorkers ?? 0;
    message.packages = object.packages?.map((e) => Package.fromPartial(e)) || [];
    message.defaultPackageSet = object.defaultPackageSet ?? 0;
    message.machineType = object.machineType ?? "";
    message.teardownPolicy = object.teardownPolicy ?? 0;
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.diskType = object.diskType ?? "";
    message.diskSourceImage = object.diskSourceImage ?? "";
    message.zone = object.zone ?? "";
    message.taskrunnerSettings = (object.taskrunnerSettings !== undefined && object.taskrunnerSettings !== null)
      ? TaskRunnerSettings.fromPartial(object.taskrunnerSettings)
      : undefined;
    message.onHostMaintenance = object.onHostMaintenance ?? "";
    message.dataDisks = object.dataDisks?.map((e) => Disk.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.autoscalingSettings = (object.autoscalingSettings !== undefined && object.autoscalingSettings !== null)
      ? AutoscalingSettings.fromPartial(object.autoscalingSettings)
      : undefined;
    message.poolArgs = (object.poolArgs !== undefined && object.poolArgs !== null)
      ? Any.fromPartial(object.poolArgs)
      : undefined;
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.workerHarnessContainerImage = object.workerHarnessContainerImage ?? "";
    message.numThreadsPerWorker = object.numThreadsPerWorker ?? 0;
    message.ipConfiguration = object.ipConfiguration ?? 0;
    message.sdkHarnessContainerImages =
      object.sdkHarnessContainerImages?.map((e) => SdkHarnessContainerImage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkerPool_MetadataEntry(): WorkerPool_MetadataEntry {
  return { key: "", value: "" };
}

export const WorkerPool_MetadataEntry: MessageFns<WorkerPool_MetadataEntry> = {
  encode(message: WorkerPool_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerPool_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerPool_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerPool_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkerPool_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerPool_MetadataEntry>): WorkerPool_MetadataEntry {
    return WorkerPool_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerPool_MetadataEntry>): WorkerPool_MetadataEntry {
    const message = createBaseWorkerPool_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDebugOptions(): DebugOptions {
  return { enableHotKeyLogging: false };
}

export const DebugOptions: MessageFns<DebugOptions> = {
  encode(message: DebugOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableHotKeyLogging !== false) {
      writer.uint32(8).bool(message.enableHotKeyLogging);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableHotKeyLogging = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugOptions {
    return {
      enableHotKeyLogging: isSet(object.enableHotKeyLogging) ? globalThis.Boolean(object.enableHotKeyLogging) : false,
    };
  },

  toJSON(message: DebugOptions): unknown {
    const obj: any = {};
    if (message.enableHotKeyLogging !== false) {
      obj.enableHotKeyLogging = message.enableHotKeyLogging;
    }
    return obj;
  },

  create(base?: DeepPartial<DebugOptions>): DebugOptions {
    return DebugOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DebugOptions>): DebugOptions {
    const message = createBaseDebugOptions();
    message.enableHotKeyLogging = object.enableHotKeyLogging ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
