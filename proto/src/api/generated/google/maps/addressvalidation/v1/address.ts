// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/addressvalidation/v1/address.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PostalAddress } from "../../../type/postal_address.js";

export const protobufPackage = "google.maps.addressvalidation.v1";

/**
 * Details of the post-processed address. Post-processing includes
 * correcting misspelled parts of the address, replacing incorrect parts, and
 * inferring missing parts.
 */
export interface Address {
  /**
   * The post-processed address, formatted as a single-line address following
   * the address formatting rules of the region where the address is located.
   */
  formattedAddress: string;
  /** The post-processed address represented as a postal address. */
  postalAddress:
    | PostalAddress
    | undefined;
  /**
   * Unordered list. The individual address components of the formatted and
   * corrected address, along with validation information. This provides
   * information on the validation status of the individual components.
   *
   * Address components are not ordered in a particular way. Do not make any
   * assumptions on the ordering of the address components in the list.
   */
  addressComponents: AddressComponent[];
  /**
   * The types of components that were expected to be present in a correctly
   * formatted mailing address but were not found in the input AND could
   * not be inferred. Components of this type are not present in
   * `formatted_address`, `postal_address`, or `address_components`. An
   * example might be `['street_number', 'route']` for an input like
   * "Boulder, Colorado, 80301, USA". The list of possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   */
  missingComponentTypes: string[];
  /**
   * The types of the components that are present in the `address_components`
   * but could not be confirmed to be correct. This field is provided for the
   * sake of convenience: its contents are equivalent to iterating through the
   * `address_components` to find the types of all the components where the
   * [confirmation_level][google.maps.addressvalidation.v1.AddressComponent.confirmation_level]
   * is not
   * [CONFIRMED][google.maps.addressvalidation.v1.AddressComponent.ConfirmationLevel.CONFIRMED]
   * or the
   * [inferred][google.maps.addressvalidation.v1.AddressComponent.inferred]
   * flag is not set to `true`. The list of possible types can be found
   * [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
   */
  unconfirmedComponentTypes: string[];
  /**
   * Any tokens in the input that could not be resolved. This might be an
   * input that was not recognized as a valid part of an address (for example
   * in an input like "123235253253 Main St, San Francisco, CA, 94105", the
   * unresolved tokens may look like `["123235253253"]` since that does not
   * look like a valid street number.
   */
  unresolvedTokens: string[];
}

/** Represents an address component, such as a street, city, or state. */
export interface AddressComponent {
  /** The name for this component. */
  componentName:
    | ComponentName
    | undefined;
  /**
   * The type of the address component. See
   * [Table 2: Additional types returned by the Places
   * service](https://developers.google.com/places/web-service/supported_types#table2)
   * for a list of possible types.
   */
  componentType: string;
  /**
   * Indicates the level of certainty that we have that the component
   * is correct.
   */
  confirmationLevel: AddressComponent_ConfirmationLevel;
  /**
   * Indicates that the component was not part of the input, but we
   * inferred it for the address location and believe it should be provided
   * for a complete address.
   */
  inferred: boolean;
  /**
   * Indicates a correction to a misspelling in the component name.  The API
   * does not always flag changes from one spelling variant to another, such as
   * when changing "centre" to "center". It also does not always flag common
   * misspellings, such as when changing "Amphitheater Pkwy" to "Amphitheatre
   * Pkwy".
   */
  spellCorrected: boolean;
  /**
   * Indicates the name of the component was replaced with a completely
   * different one, for example a wrong postal code being replaced with one that
   * is correct for the address. This is not a cosmetic change, the input
   * component has been changed to a different one.
   */
  replaced: boolean;
  /**
   * Indicates an address component that is not expected to be present in a
   * postal address for the given region. We have retained it only because it
   * was part of the input.
   */
  unexpected: boolean;
}

/** The different possible values for confirmation levels. */
export enum AddressComponent_ConfirmationLevel {
  /** CONFIRMATION_LEVEL_UNSPECIFIED - Default value. This value is unused. */
  CONFIRMATION_LEVEL_UNSPECIFIED = 0,
  /**
   * CONFIRMED - We were able to verify that this component exists and makes sense in the
   * context of the rest of the address.
   */
  CONFIRMED = 1,
  /**
   * UNCONFIRMED_BUT_PLAUSIBLE - This component could not be confirmed, but it is plausible that it
   * exists. For example, a street number within a known valid range of
   * numbers on a street where specific house numbers are not known.
   */
  UNCONFIRMED_BUT_PLAUSIBLE = 2,
  /**
   * UNCONFIRMED_AND_SUSPICIOUS - This component was not confirmed and is likely to be wrong. For
   * example, a neighborhood that does not fit the rest of the address.
   */
  UNCONFIRMED_AND_SUSPICIOUS = 3,
  UNRECOGNIZED = -1,
}

export function addressComponent_ConfirmationLevelFromJSON(object: any): AddressComponent_ConfirmationLevel {
  switch (object) {
    case 0:
    case "CONFIRMATION_LEVEL_UNSPECIFIED":
      return AddressComponent_ConfirmationLevel.CONFIRMATION_LEVEL_UNSPECIFIED;
    case 1:
    case "CONFIRMED":
      return AddressComponent_ConfirmationLevel.CONFIRMED;
    case 2:
    case "UNCONFIRMED_BUT_PLAUSIBLE":
      return AddressComponent_ConfirmationLevel.UNCONFIRMED_BUT_PLAUSIBLE;
    case 3:
    case "UNCONFIRMED_AND_SUSPICIOUS":
      return AddressComponent_ConfirmationLevel.UNCONFIRMED_AND_SUSPICIOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AddressComponent_ConfirmationLevel.UNRECOGNIZED;
  }
}

export function addressComponent_ConfirmationLevelToJSON(object: AddressComponent_ConfirmationLevel): string {
  switch (object) {
    case AddressComponent_ConfirmationLevel.CONFIRMATION_LEVEL_UNSPECIFIED:
      return "CONFIRMATION_LEVEL_UNSPECIFIED";
    case AddressComponent_ConfirmationLevel.CONFIRMED:
      return "CONFIRMED";
    case AddressComponent_ConfirmationLevel.UNCONFIRMED_BUT_PLAUSIBLE:
      return "UNCONFIRMED_BUT_PLAUSIBLE";
    case AddressComponent_ConfirmationLevel.UNCONFIRMED_AND_SUSPICIOUS:
      return "UNCONFIRMED_AND_SUSPICIOUS";
    case AddressComponent_ConfirmationLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A wrapper for the name of the component. */
export interface ComponentName {
  /**
   * The name text. For example, "5th Avenue" for a street name or "1253" for a
   * street number.
   */
  text: string;
  /**
   * The BCP-47 language code. This will not be present if the component name is
   * not associated with a language, such as a street number.
   */
  languageCode: string;
}

function createBaseAddress(): Address {
  return {
    formattedAddress: "",
    postalAddress: undefined,
    addressComponents: [],
    missingComponentTypes: [],
    unconfirmedComponentTypes: [],
    unresolvedTokens: [],
  };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.formattedAddress !== "") {
      writer.uint32(18).string(message.formattedAddress);
    }
    if (message.postalAddress !== undefined) {
      PostalAddress.encode(message.postalAddress, writer.uint32(26).fork()).join();
    }
    for (const v of message.addressComponents) {
      AddressComponent.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.missingComponentTypes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.unconfirmedComponentTypes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.unresolvedTokens) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.formattedAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.postalAddress = PostalAddress.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addressComponents.push(AddressComponent.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.missingComponentTypes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unconfirmedComponentTypes.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.unresolvedTokens.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      formattedAddress: isSet(object.formattedAddress) ? globalThis.String(object.formattedAddress) : "",
      postalAddress: isSet(object.postalAddress) ? PostalAddress.fromJSON(object.postalAddress) : undefined,
      addressComponents: globalThis.Array.isArray(object?.addressComponents)
        ? object.addressComponents.map((e: any) => AddressComponent.fromJSON(e))
        : [],
      missingComponentTypes: globalThis.Array.isArray(object?.missingComponentTypes)
        ? object.missingComponentTypes.map((e: any) => globalThis.String(e))
        : [],
      unconfirmedComponentTypes: globalThis.Array.isArray(object?.unconfirmedComponentTypes)
        ? object.unconfirmedComponentTypes.map((e: any) => globalThis.String(e))
        : [],
      unresolvedTokens: globalThis.Array.isArray(object?.unresolvedTokens)
        ? object.unresolvedTokens.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.formattedAddress !== "") {
      obj.formattedAddress = message.formattedAddress;
    }
    if (message.postalAddress !== undefined) {
      obj.postalAddress = PostalAddress.toJSON(message.postalAddress);
    }
    if (message.addressComponents?.length) {
      obj.addressComponents = message.addressComponents.map((e) => AddressComponent.toJSON(e));
    }
    if (message.missingComponentTypes?.length) {
      obj.missingComponentTypes = message.missingComponentTypes;
    }
    if (message.unconfirmedComponentTypes?.length) {
      obj.unconfirmedComponentTypes = message.unconfirmedComponentTypes;
    }
    if (message.unresolvedTokens?.length) {
      obj.unresolvedTokens = message.unresolvedTokens;
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.formattedAddress = object.formattedAddress ?? "";
    message.postalAddress = (object.postalAddress !== undefined && object.postalAddress !== null)
      ? PostalAddress.fromPartial(object.postalAddress)
      : undefined;
    message.addressComponents = object.addressComponents?.map((e) => AddressComponent.fromPartial(e)) || [];
    message.missingComponentTypes = object.missingComponentTypes?.map((e) => e) || [];
    message.unconfirmedComponentTypes = object.unconfirmedComponentTypes?.map((e) => e) || [];
    message.unresolvedTokens = object.unresolvedTokens?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddressComponent(): AddressComponent {
  return {
    componentName: undefined,
    componentType: "",
    confirmationLevel: 0,
    inferred: false,
    spellCorrected: false,
    replaced: false,
    unexpected: false,
  };
}

export const AddressComponent: MessageFns<AddressComponent> = {
  encode(message: AddressComponent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.componentName !== undefined) {
      ComponentName.encode(message.componentName, writer.uint32(10).fork()).join();
    }
    if (message.componentType !== "") {
      writer.uint32(18).string(message.componentType);
    }
    if (message.confirmationLevel !== 0) {
      writer.uint32(24).int32(message.confirmationLevel);
    }
    if (message.inferred !== false) {
      writer.uint32(32).bool(message.inferred);
    }
    if (message.spellCorrected !== false) {
      writer.uint32(40).bool(message.spellCorrected);
    }
    if (message.replaced !== false) {
      writer.uint32(48).bool(message.replaced);
    }
    if (message.unexpected !== false) {
      writer.uint32(56).bool(message.unexpected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressComponent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = ComponentName.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.componentType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.confirmationLevel = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.inferred = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.spellCorrected = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.replaced = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.unexpected = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressComponent {
    return {
      componentName: isSet(object.componentName) ? ComponentName.fromJSON(object.componentName) : undefined,
      componentType: isSet(object.componentType) ? globalThis.String(object.componentType) : "",
      confirmationLevel: isSet(object.confirmationLevel)
        ? addressComponent_ConfirmationLevelFromJSON(object.confirmationLevel)
        : 0,
      inferred: isSet(object.inferred) ? globalThis.Boolean(object.inferred) : false,
      spellCorrected: isSet(object.spellCorrected) ? globalThis.Boolean(object.spellCorrected) : false,
      replaced: isSet(object.replaced) ? globalThis.Boolean(object.replaced) : false,
      unexpected: isSet(object.unexpected) ? globalThis.Boolean(object.unexpected) : false,
    };
  },

  toJSON(message: AddressComponent): unknown {
    const obj: any = {};
    if (message.componentName !== undefined) {
      obj.componentName = ComponentName.toJSON(message.componentName);
    }
    if (message.componentType !== "") {
      obj.componentType = message.componentType;
    }
    if (message.confirmationLevel !== 0) {
      obj.confirmationLevel = addressComponent_ConfirmationLevelToJSON(message.confirmationLevel);
    }
    if (message.inferred !== false) {
      obj.inferred = message.inferred;
    }
    if (message.spellCorrected !== false) {
      obj.spellCorrected = message.spellCorrected;
    }
    if (message.replaced !== false) {
      obj.replaced = message.replaced;
    }
    if (message.unexpected !== false) {
      obj.unexpected = message.unexpected;
    }
    return obj;
  },

  create(base?: DeepPartial<AddressComponent>): AddressComponent {
    return AddressComponent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressComponent>): AddressComponent {
    const message = createBaseAddressComponent();
    message.componentName = (object.componentName !== undefined && object.componentName !== null)
      ? ComponentName.fromPartial(object.componentName)
      : undefined;
    message.componentType = object.componentType ?? "";
    message.confirmationLevel = object.confirmationLevel ?? 0;
    message.inferred = object.inferred ?? false;
    message.spellCorrected = object.spellCorrected ?? false;
    message.replaced = object.replaced ?? false;
    message.unexpected = object.unexpected ?? false;
    return message;
  },
};

function createBaseComponentName(): ComponentName {
  return { text: "", languageCode: "" };
}

export const ComponentName: MessageFns<ComponentName> = {
  encode(message: ComponentName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.languageCode !== "") {
      writer.uint32(18).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComponentName {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ComponentName): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ComponentName>): ComponentName {
    return ComponentName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComponentName>): ComponentName {
    const message = createBaseComponentName();
    message.text = object.text ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
