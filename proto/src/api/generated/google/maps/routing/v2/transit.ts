// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/routing/v2/transit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { LocalizedText } from "../../../type/localized_text.js";
import { Location } from "./location.js";

export const protobufPackage = "google.maps.routing.v2";

/** A transit agency that operates a transit line. */
export interface TransitAgency {
  /** The name of this transit agency. */
  name: string;
  /** The transit agency's locale-specific formatted phone number. */
  phoneNumber: string;
  /** The transit agency's URI. */
  uri: string;
}

/** Contains information about the transit line used in this step. */
export interface TransitLine {
  /** The transit agency (or agencies) that operates this transit line. */
  agencies: TransitAgency[];
  /** The full name of this transit line, For example, "8 Avenue Local". */
  name: string;
  /** the URI for this transit line as provided by the transit agency. */
  uri: string;
  /**
   * The color commonly used in signage for this line. Represented in
   * hexadecimal.
   */
  color: string;
  /** The URI for the icon associated with this line. */
  iconUri: string;
  /**
   * The short name of this transit line. This name will normally be a line
   * number, such as "M7" or "355".
   */
  nameShort: string;
  /**
   * The color commonly used in text on signage for this line. Represented in
   * hexadecimal.
   */
  textColor: string;
  /** The type of vehicle that operates on this transit line. */
  vehicle: TransitVehicle | undefined;
}

/** Information about a transit stop. */
export interface TransitStop {
  /** The name of the transit stop. */
  name: string;
  /** The location of the stop expressed in latitude/longitude coordinates. */
  location: Location | undefined;
}

/** Information about a vehicle used in transit routes. */
export interface TransitVehicle {
  /** The name of this vehicle, capitalized. */
  name:
    | LocalizedText
    | undefined;
  /** The type of vehicle used. */
  type: TransitVehicle_TransitVehicleType;
  /** The URI for an icon associated with this vehicle type. */
  iconUri: string;
  /**
   * The URI for the icon associated with this vehicle type, based on the local
   * transport signage.
   */
  localIconUri: string;
}

/** The type of vehicles for transit routes. */
export enum TransitVehicle_TransitVehicleType {
  /** TRANSIT_VEHICLE_TYPE_UNSPECIFIED - Unused. */
  TRANSIT_VEHICLE_TYPE_UNSPECIFIED = 0,
  /** BUS - Bus. */
  BUS = 1,
  /**
   * CABLE_CAR - A vehicle that operates on a cable, usually on the ground. Aerial cable
   * cars may be of the type `GONDOLA_LIFT`.
   */
  CABLE_CAR = 2,
  /** COMMUTER_TRAIN - Commuter rail. */
  COMMUTER_TRAIN = 3,
  /** FERRY - Ferry. */
  FERRY = 4,
  /**
   * FUNICULAR - A vehicle that is pulled up a steep incline by a cable. A Funicular
   * typically consists of two cars, with each car acting as a counterweight
   * for the other.
   */
  FUNICULAR = 5,
  /** GONDOLA_LIFT - An aerial cable car. */
  GONDOLA_LIFT = 6,
  /** HEAVY_RAIL - Heavy rail. */
  HEAVY_RAIL = 7,
  /** HIGH_SPEED_TRAIN - High speed train. */
  HIGH_SPEED_TRAIN = 8,
  /** INTERCITY_BUS - Intercity bus. */
  INTERCITY_BUS = 9,
  /** LONG_DISTANCE_TRAIN - Long distance train. */
  LONG_DISTANCE_TRAIN = 10,
  /** METRO_RAIL - Light rail transit. */
  METRO_RAIL = 11,
  /** MONORAIL - Monorail. */
  MONORAIL = 12,
  /** OTHER - All other vehicles. */
  OTHER = 13,
  /** RAIL - Rail. */
  RAIL = 14,
  /**
   * SHARE_TAXI - Share taxi is a kind of bus with the ability to drop off and pick up
   * passengers anywhere on its route.
   */
  SHARE_TAXI = 15,
  /** SUBWAY - Underground light rail. */
  SUBWAY = 16,
  /** TRAM - Above ground light rail. */
  TRAM = 17,
  /** TROLLEYBUS - Trolleybus. */
  TROLLEYBUS = 18,
  UNRECOGNIZED = -1,
}

export function transitVehicle_TransitVehicleTypeFromJSON(object: any): TransitVehicle_TransitVehicleType {
  switch (object) {
    case 0:
    case "TRANSIT_VEHICLE_TYPE_UNSPECIFIED":
      return TransitVehicle_TransitVehicleType.TRANSIT_VEHICLE_TYPE_UNSPECIFIED;
    case 1:
    case "BUS":
      return TransitVehicle_TransitVehicleType.BUS;
    case 2:
    case "CABLE_CAR":
      return TransitVehicle_TransitVehicleType.CABLE_CAR;
    case 3:
    case "COMMUTER_TRAIN":
      return TransitVehicle_TransitVehicleType.COMMUTER_TRAIN;
    case 4:
    case "FERRY":
      return TransitVehicle_TransitVehicleType.FERRY;
    case 5:
    case "FUNICULAR":
      return TransitVehicle_TransitVehicleType.FUNICULAR;
    case 6:
    case "GONDOLA_LIFT":
      return TransitVehicle_TransitVehicleType.GONDOLA_LIFT;
    case 7:
    case "HEAVY_RAIL":
      return TransitVehicle_TransitVehicleType.HEAVY_RAIL;
    case 8:
    case "HIGH_SPEED_TRAIN":
      return TransitVehicle_TransitVehicleType.HIGH_SPEED_TRAIN;
    case 9:
    case "INTERCITY_BUS":
      return TransitVehicle_TransitVehicleType.INTERCITY_BUS;
    case 10:
    case "LONG_DISTANCE_TRAIN":
      return TransitVehicle_TransitVehicleType.LONG_DISTANCE_TRAIN;
    case 11:
    case "METRO_RAIL":
      return TransitVehicle_TransitVehicleType.METRO_RAIL;
    case 12:
    case "MONORAIL":
      return TransitVehicle_TransitVehicleType.MONORAIL;
    case 13:
    case "OTHER":
      return TransitVehicle_TransitVehicleType.OTHER;
    case 14:
    case "RAIL":
      return TransitVehicle_TransitVehicleType.RAIL;
    case 15:
    case "SHARE_TAXI":
      return TransitVehicle_TransitVehicleType.SHARE_TAXI;
    case 16:
    case "SUBWAY":
      return TransitVehicle_TransitVehicleType.SUBWAY;
    case 17:
    case "TRAM":
      return TransitVehicle_TransitVehicleType.TRAM;
    case 18:
    case "TROLLEYBUS":
      return TransitVehicle_TransitVehicleType.TROLLEYBUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransitVehicle_TransitVehicleType.UNRECOGNIZED;
  }
}

export function transitVehicle_TransitVehicleTypeToJSON(object: TransitVehicle_TransitVehicleType): string {
  switch (object) {
    case TransitVehicle_TransitVehicleType.TRANSIT_VEHICLE_TYPE_UNSPECIFIED:
      return "TRANSIT_VEHICLE_TYPE_UNSPECIFIED";
    case TransitVehicle_TransitVehicleType.BUS:
      return "BUS";
    case TransitVehicle_TransitVehicleType.CABLE_CAR:
      return "CABLE_CAR";
    case TransitVehicle_TransitVehicleType.COMMUTER_TRAIN:
      return "COMMUTER_TRAIN";
    case TransitVehicle_TransitVehicleType.FERRY:
      return "FERRY";
    case TransitVehicle_TransitVehicleType.FUNICULAR:
      return "FUNICULAR";
    case TransitVehicle_TransitVehicleType.GONDOLA_LIFT:
      return "GONDOLA_LIFT";
    case TransitVehicle_TransitVehicleType.HEAVY_RAIL:
      return "HEAVY_RAIL";
    case TransitVehicle_TransitVehicleType.HIGH_SPEED_TRAIN:
      return "HIGH_SPEED_TRAIN";
    case TransitVehicle_TransitVehicleType.INTERCITY_BUS:
      return "INTERCITY_BUS";
    case TransitVehicle_TransitVehicleType.LONG_DISTANCE_TRAIN:
      return "LONG_DISTANCE_TRAIN";
    case TransitVehicle_TransitVehicleType.METRO_RAIL:
      return "METRO_RAIL";
    case TransitVehicle_TransitVehicleType.MONORAIL:
      return "MONORAIL";
    case TransitVehicle_TransitVehicleType.OTHER:
      return "OTHER";
    case TransitVehicle_TransitVehicleType.RAIL:
      return "RAIL";
    case TransitVehicle_TransitVehicleType.SHARE_TAXI:
      return "SHARE_TAXI";
    case TransitVehicle_TransitVehicleType.SUBWAY:
      return "SUBWAY";
    case TransitVehicle_TransitVehicleType.TRAM:
      return "TRAM";
    case TransitVehicle_TransitVehicleType.TROLLEYBUS:
      return "TROLLEYBUS";
    case TransitVehicle_TransitVehicleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseTransitAgency(): TransitAgency {
  return { name: "", phoneNumber: "", uri: "" };
}

export const TransitAgency: MessageFns<TransitAgency> = {
  encode(message: TransitAgency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(18).string(message.phoneNumber);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitAgency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitAgency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitAgency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
    };
  },

  toJSON(message: TransitAgency): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitAgency>): TransitAgency {
    return TransitAgency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitAgency>): TransitAgency {
    const message = createBaseTransitAgency();
    message.name = object.name ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseTransitLine(): TransitLine {
  return { agencies: [], name: "", uri: "", color: "", iconUri: "", nameShort: "", textColor: "", vehicle: undefined };
}

export const TransitLine: MessageFns<TransitLine> = {
  encode(message: TransitLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.agencies) {
      TransitAgency.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.color !== "") {
      writer.uint32(34).string(message.color);
    }
    if (message.iconUri !== "") {
      writer.uint32(42).string(message.iconUri);
    }
    if (message.nameShort !== "") {
      writer.uint32(50).string(message.nameShort);
    }
    if (message.textColor !== "") {
      writer.uint32(58).string(message.textColor);
    }
    if (message.vehicle !== undefined) {
      TransitVehicle.encode(message.vehicle, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agencies.push(TransitAgency.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.color = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nameShort = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.textColor = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vehicle = TransitVehicle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitLine {
    return {
      agencies: globalThis.Array.isArray(object?.agencies)
        ? object.agencies.map((e: any) => TransitAgency.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
      nameShort: isSet(object.nameShort) ? globalThis.String(object.nameShort) : "",
      textColor: isSet(object.textColor) ? globalThis.String(object.textColor) : "",
      vehicle: isSet(object.vehicle) ? TransitVehicle.fromJSON(object.vehicle) : undefined,
    };
  },

  toJSON(message: TransitLine): unknown {
    const obj: any = {};
    if (message.agencies?.length) {
      obj.agencies = message.agencies.map((e) => TransitAgency.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    if (message.nameShort !== "") {
      obj.nameShort = message.nameShort;
    }
    if (message.textColor !== "") {
      obj.textColor = message.textColor;
    }
    if (message.vehicle !== undefined) {
      obj.vehicle = TransitVehicle.toJSON(message.vehicle);
    }
    return obj;
  },

  create(base?: DeepPartial<TransitLine>): TransitLine {
    return TransitLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitLine>): TransitLine {
    const message = createBaseTransitLine();
    message.agencies = object.agencies?.map((e) => TransitAgency.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.uri = object.uri ?? "";
    message.color = object.color ?? "";
    message.iconUri = object.iconUri ?? "";
    message.nameShort = object.nameShort ?? "";
    message.textColor = object.textColor ?? "";
    message.vehicle = (object.vehicle !== undefined && object.vehicle !== null)
      ? TransitVehicle.fromPartial(object.vehicle)
      : undefined;
    return message;
  },
};

function createBaseTransitStop(): TransitStop {
  return { name: "", location: undefined };
}

export const TransitStop: MessageFns<TransitStop> = {
  encode(message: TransitStop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.location !== undefined) {
      Location.encode(message.location, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitStop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitStop {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      location: isSet(object.location) ? Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: TransitStop): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.location !== undefined) {
      obj.location = Location.toJSON(message.location);
    }
    return obj;
  },

  create(base?: DeepPartial<TransitStop>): TransitStop {
    return TransitStop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitStop>): TransitStop {
    const message = createBaseTransitStop();
    message.name = object.name ?? "";
    message.location = (object.location !== undefined && object.location !== null)
      ? Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBaseTransitVehicle(): TransitVehicle {
  return { name: undefined, type: 0, iconUri: "", localIconUri: "" };
}

export const TransitVehicle: MessageFns<TransitVehicle> = {
  encode(message: TransitVehicle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      LocalizedText.encode(message.name, writer.uint32(10).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.iconUri !== "") {
      writer.uint32(26).string(message.iconUri);
    }
    if (message.localIconUri !== "") {
      writer.uint32(34).string(message.localIconUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransitVehicle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransitVehicle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.localIconUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransitVehicle {
    return {
      name: isSet(object.name) ? LocalizedText.fromJSON(object.name) : undefined,
      type: isSet(object.type) ? transitVehicle_TransitVehicleTypeFromJSON(object.type) : 0,
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
      localIconUri: isSet(object.localIconUri) ? globalThis.String(object.localIconUri) : "",
    };
  },

  toJSON(message: TransitVehicle): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = LocalizedText.toJSON(message.name);
    }
    if (message.type !== 0) {
      obj.type = transitVehicle_TransitVehicleTypeToJSON(message.type);
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    if (message.localIconUri !== "") {
      obj.localIconUri = message.localIconUri;
    }
    return obj;
  },

  create(base?: DeepPartial<TransitVehicle>): TransitVehicle {
    return TransitVehicle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransitVehicle>): TransitVehicle {
    const message = createBaseTransitVehicle();
    message.name = (object.name !== undefined && object.name !== null)
      ? LocalizedText.fromPartial(object.name)
      : undefined;
    message.type = object.type ?? 0;
    message.iconUri = object.iconUri ?? "";
    message.localIconUri = object.localIconUri ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
