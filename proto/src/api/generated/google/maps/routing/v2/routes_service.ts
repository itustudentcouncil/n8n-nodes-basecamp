// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/routing/v2/routes_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { LocalizedText } from "../../../type/localized_text.js";
import { FallbackInfo } from "./fallback_info.js";
import { GeocodingResults } from "./geocoding_results.js";
import {
  PolylineEncoding,
  polylineEncodingFromJSON,
  polylineEncodingToJSON,
  PolylineQuality,
  polylineQualityFromJSON,
  polylineQualityToJSON,
} from "./polyline.js";
import { Route, RouteTravelAdvisory } from "./route.js";
import { RouteModifiers } from "./route_modifiers.js";
import { RouteTravelMode, routeTravelModeFromJSON, routeTravelModeToJSON } from "./route_travel_mode.js";
import { RoutingPreference, routingPreferenceFromJSON, routingPreferenceToJSON } from "./routing_preference.js";
import { TrafficModel, trafficModelFromJSON, trafficModelToJSON } from "./traffic_model.js";
import { TransitPreferences } from "./transit_preferences.js";
import { Units, unitsFromJSON, unitsToJSON } from "./units.js";
import { Waypoint } from "./waypoint.js";

export const protobufPackage = "google.maps.routing.v2";

/** The condition of the route being returned. */
export enum RouteMatrixElementCondition {
  /** ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED - Only used when the `status` of the element is not OK. */
  ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED = 0,
  /**
   * ROUTE_EXISTS - A route was found, and the corresponding information was filled out for the
   * element.
   */
  ROUTE_EXISTS = 1,
  /**
   * ROUTE_NOT_FOUND - No route could be found. Fields containing route information, such as
   * `distance_meters` or `duration`, will not be filled out in the element.
   */
  ROUTE_NOT_FOUND = 2,
  UNRECOGNIZED = -1,
}

export function routeMatrixElementConditionFromJSON(object: any): RouteMatrixElementCondition {
  switch (object) {
    case 0:
    case "ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED":
      return RouteMatrixElementCondition.ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED;
    case 1:
    case "ROUTE_EXISTS":
      return RouteMatrixElementCondition.ROUTE_EXISTS;
    case 2:
    case "ROUTE_NOT_FOUND":
      return RouteMatrixElementCondition.ROUTE_NOT_FOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RouteMatrixElementCondition.UNRECOGNIZED;
  }
}

export function routeMatrixElementConditionToJSON(object: RouteMatrixElementCondition): string {
  switch (object) {
    case RouteMatrixElementCondition.ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED:
      return "ROUTE_MATRIX_ELEMENT_CONDITION_UNSPECIFIED";
    case RouteMatrixElementCondition.ROUTE_EXISTS:
      return "ROUTE_EXISTS";
    case RouteMatrixElementCondition.ROUTE_NOT_FOUND:
      return "ROUTE_NOT_FOUND";
    case RouteMatrixElementCondition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ComputeRoutes request message. */
export interface ComputeRoutesRequest {
  /** Required. Origin waypoint. */
  origin:
    | Waypoint
    | undefined;
  /** Required. Destination waypoint. */
  destination:
    | Waypoint
    | undefined;
  /**
   * Optional. A set of waypoints along the route (excluding terminal points),
   * for either stopping at or passing by. Up to 25 intermediate waypoints are
   * supported.
   */
  intermediates: Waypoint[];
  /** Optional. Specifies the mode of transportation. */
  travelMode: RouteTravelMode;
  /**
   * Optional. Specifies how to compute the route. The server
   * attempts to use the selected routing preference to compute the route. If
   *  the routing preference results in an error or an extra long latency, then
   * an error is returned. You can specify this option only when the
   * `travel_mode` is `DRIVE` or `TWO_WHEELER`, otherwise the request fails.
   */
  routingPreference: RoutingPreference;
  /** Optional. Specifies your preference for the quality of the polyline. */
  polylineQuality: PolylineQuality;
  /** Optional. Specifies the preferred encoding for the polyline. */
  polylineEncoding: PolylineEncoding;
  /**
   * Optional. The departure time. If you don't set this value, then this value
   * defaults to the time that you made the request.
   * NOTE: You can only specify a `departure_time` in the past when
   * [`RouteTravelMode`][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`. Transit trips are available for up to 7 days in the past or 100
   * days in the future.
   */
  departureTime:
    | Date
    | undefined;
  /**
   * Optional. The arrival time.
   * NOTE: Can only be set when
   * [RouteTravelMode][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`. You can specify either `departure_time` or `arrival_time`, but
   * not both. Transit trips are available for up to 7 days in the past or 100
   * days in the future.
   */
  arrivalTime:
    | Date
    | undefined;
  /**
   * Optional. Specifies whether to calculate alternate routes in addition to
   * the route. No alternative routes are returned for requests that have
   * intermediate waypoints.
   */
  computeAlternativeRoutes: boolean;
  /**
   * Optional. A set of conditions to satisfy that affect the way routes are
   * calculated.
   */
  routeModifiers:
    | RouteModifiers
    | undefined;
  /**
   * Optional. The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see [Unicode Locale
   * Identifier](http://www.unicode.org/reports/tr35/#Unicode_locale_identifier).
   * See [Language
   * Support](https://developers.google.com/maps/faq#languagesupport)
   * for the list of supported languages. When you don't provide this value, the
   * display language is inferred from the location of the route request.
   */
  languageCode: string;
  /**
   * Optional. The region code, specified as a ccTLD ("top-level domain")
   * two-character value. For more information see [Country code top-level
   * domains](https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains#Country_code_top-level_domains).
   */
  regionCode: string;
  /**
   * Optional. Specifies the units of measure for the display fields. These
   * fields include the `instruction` field in
   * [`NavigationInstruction`][google.maps.routing.v2.NavigationInstruction].
   * The units of measure used for the route, leg, step distance, and duration
   * are not affected by this value. If you don't provide this value, then the
   * display units are inferred from the location of the first origin.
   */
  units: Units;
  /**
   * Optional. If set to true, the service attempts to minimize the overall cost
   * of the route by re-ordering the specified intermediate waypoints. The
   * request fails if any of the intermediate waypoints is a `via` waypoint. Use
   * `ComputeRoutesResponse.Routes.optimized_intermediate_waypoint_index` to
   * find the new ordering.
   * If `ComputeRoutesResponseroutes.optimized_intermediate_waypoint_index` is
   * not requested in the `X-Goog-FieldMask` header, the request fails.
   * If `optimize_waypoint_order` is set to false,
   * `ComputeRoutesResponse.optimized_intermediate_waypoint_index` will be
   * empty.
   */
  optimizeWaypointOrder: boolean;
  /**
   * Optional. Specifies what reference routes to calculate as part of the
   * request in addition to the default route. A reference route is a route with
   * a different route calculation objective than the default route. For example
   * a `FUEL_EFFICIENT` reference route calculation takes into account various
   * parameters that would generate an optimal fuel efficient route.
   */
  requestedReferenceRoutes: ComputeRoutesRequest_ReferenceRoute[];
  /**
   * Optional. A list of extra computations which may be used to complete the
   * request. Note: These extra computations may return extra fields on the
   * response. These extra fields must also be specified in the field mask to be
   * returned in the response.
   */
  extraComputations: ComputeRoutesRequest_ExtraComputation[];
  /**
   * Optional. Specifies the assumptions to use when calculating time in
   * traffic. This setting affects the value returned in the duration field in
   * the
   * [`Route`][google.maps.routing.v2.Route] and
   * [`RouteLeg`][google.maps.routing.v2.RouteLeg] which contains the predicted
   * time in traffic based on historical averages.
   * `TrafficModel` is only available for requests that have set
   * [`RoutingPreference`][google.maps.routing.v2.RoutingPreference] to
   * `TRAFFIC_AWARE_OPTIMAL` and
   * [`RouteTravelMode`][google.maps.routing.v2.RouteTravelMode] to `DRIVE`.
   * Defaults to `BEST_GUESS` if traffic is requested and `TrafficModel` is not
   * specified.
   */
  trafficModel: TrafficModel;
  /**
   * Optional. Specifies preferences that influence the route returned for
   * `TRANSIT` routes. NOTE: You can only specify a `transit_preferences` when
   * [`RouteTravelMode`][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`.
   */
  transitPreferences: TransitPreferences | undefined;
}

/** A supported reference route on the ComputeRoutesRequest. */
export enum ComputeRoutesRequest_ReferenceRoute {
  /** REFERENCE_ROUTE_UNSPECIFIED - Not used. Requests containing this value fail. */
  REFERENCE_ROUTE_UNSPECIFIED = 0,
  /**
   * FUEL_EFFICIENT - Fuel efficient route. Routes labeled with this value are determined to be
   * optimized for parameters such as fuel consumption.
   */
  FUEL_EFFICIENT = 1,
  UNRECOGNIZED = -1,
}

export function computeRoutesRequest_ReferenceRouteFromJSON(object: any): ComputeRoutesRequest_ReferenceRoute {
  switch (object) {
    case 0:
    case "REFERENCE_ROUTE_UNSPECIFIED":
      return ComputeRoutesRequest_ReferenceRoute.REFERENCE_ROUTE_UNSPECIFIED;
    case 1:
    case "FUEL_EFFICIENT":
      return ComputeRoutesRequest_ReferenceRoute.FUEL_EFFICIENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeRoutesRequest_ReferenceRoute.UNRECOGNIZED;
  }
}

export function computeRoutesRequest_ReferenceRouteToJSON(object: ComputeRoutesRequest_ReferenceRoute): string {
  switch (object) {
    case ComputeRoutesRequest_ReferenceRoute.REFERENCE_ROUTE_UNSPECIFIED:
      return "REFERENCE_ROUTE_UNSPECIFIED";
    case ComputeRoutesRequest_ReferenceRoute.FUEL_EFFICIENT:
      return "FUEL_EFFICIENT";
    case ComputeRoutesRequest_ReferenceRoute.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Extra computations to perform while completing the request. */
export enum ComputeRoutesRequest_ExtraComputation {
  /** EXTRA_COMPUTATION_UNSPECIFIED - Not used. Requests containing this value will fail. */
  EXTRA_COMPUTATION_UNSPECIFIED = 0,
  /** TOLLS - Toll information for the route(s). */
  TOLLS = 1,
  /** FUEL_CONSUMPTION - Estimated fuel consumption for the route(s). */
  FUEL_CONSUMPTION = 2,
  /** TRAFFIC_ON_POLYLINE - Traffic aware polylines for the route(s). */
  TRAFFIC_ON_POLYLINE = 3,
  /**
   * HTML_FORMATTED_NAVIGATION_INSTRUCTIONS - [`NavigationInstructions`](google.maps.routing.v2.NavigationInstructions.instructions)
   * presented as a formatted HTML text string. This content
   * is meant to be read as-is. This content is for display only.
   * Do not programmatically parse it.
   */
  HTML_FORMATTED_NAVIGATION_INSTRUCTIONS = 4,
  UNRECOGNIZED = -1,
}

export function computeRoutesRequest_ExtraComputationFromJSON(object: any): ComputeRoutesRequest_ExtraComputation {
  switch (object) {
    case 0:
    case "EXTRA_COMPUTATION_UNSPECIFIED":
      return ComputeRoutesRequest_ExtraComputation.EXTRA_COMPUTATION_UNSPECIFIED;
    case 1:
    case "TOLLS":
      return ComputeRoutesRequest_ExtraComputation.TOLLS;
    case 2:
    case "FUEL_CONSUMPTION":
      return ComputeRoutesRequest_ExtraComputation.FUEL_CONSUMPTION;
    case 3:
    case "TRAFFIC_ON_POLYLINE":
      return ComputeRoutesRequest_ExtraComputation.TRAFFIC_ON_POLYLINE;
    case 4:
    case "HTML_FORMATTED_NAVIGATION_INSTRUCTIONS":
      return ComputeRoutesRequest_ExtraComputation.HTML_FORMATTED_NAVIGATION_INSTRUCTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeRoutesRequest_ExtraComputation.UNRECOGNIZED;
  }
}

export function computeRoutesRequest_ExtraComputationToJSON(object: ComputeRoutesRequest_ExtraComputation): string {
  switch (object) {
    case ComputeRoutesRequest_ExtraComputation.EXTRA_COMPUTATION_UNSPECIFIED:
      return "EXTRA_COMPUTATION_UNSPECIFIED";
    case ComputeRoutesRequest_ExtraComputation.TOLLS:
      return "TOLLS";
    case ComputeRoutesRequest_ExtraComputation.FUEL_CONSUMPTION:
      return "FUEL_CONSUMPTION";
    case ComputeRoutesRequest_ExtraComputation.TRAFFIC_ON_POLYLINE:
      return "TRAFFIC_ON_POLYLINE";
    case ComputeRoutesRequest_ExtraComputation.HTML_FORMATTED_NAVIGATION_INSTRUCTIONS:
      return "HTML_FORMATTED_NAVIGATION_INSTRUCTIONS";
    case ComputeRoutesRequest_ExtraComputation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ComputeRoutes the response message. */
export interface ComputeRoutesResponse {
  /**
   * Contains an array of computed routes (up to three) when you specify
   * `compute_alternatives_routes`, and contains just one route when you don't.
   * When this array contains multiple entries, the first one is the most
   * recommended route. If the array is empty, then it means no route could be
   * found.
   */
  routes: Route[];
  /**
   * In some cases when the server is not able to compute the route results with
   * all of the input preferences, it may fallback to using a different way of
   * computation. When fallback mode is used, this field contains detailed info
   * about the fallback response. Otherwise this field is unset.
   */
  fallbackInfo:
    | FallbackInfo
    | undefined;
  /** Contains geocoding response info for waypoints specified as addresses. */
  geocodingResults: GeocodingResults | undefined;
}

/** ComputeRouteMatrix request message */
export interface ComputeRouteMatrixRequest {
  /**
   * Required. Array of origins, which determines the rows of the response
   * matrix. Several size restrictions apply to the cardinality of origins and
   * destinations:
   *
   * * The sum of the number of origins + the number of destinations specified
   * as either `place_id` or `address` must be no greater than 50.
   * * The product of number of origins × number of destinations must be no
   * greater than 625 in any case.
   * * The product of the number of origins × number of destinations must be no
   * greater than 100 if routing_preference is set to `TRAFFIC_AWARE_OPTIMAL`.
   * * The product of the number of origins × number of destinations must be no
   * greater than 100 if travel_mode is set to `TRANSIT`.
   */
  origins: RouteMatrixOrigin[];
  /**
   * Required. Array of destinations, which determines the columns of the
   * response matrix.
   */
  destinations: RouteMatrixDestination[];
  /** Optional. Specifies the mode of transportation. */
  travelMode: RouteTravelMode;
  /**
   * Optional. Specifies how to compute the route. The server attempts to use
   * the selected routing preference to compute the route. If the routing
   * preference results in an error or an extra long latency, an error is
   * returned. You can specify this option only when the `travel_mode` is
   * `DRIVE` or `TWO_WHEELER`, otherwise the request fails.
   */
  routingPreference: RoutingPreference;
  /**
   * Optional. The departure time. If you don't set this value, then this value
   * defaults to the time that you made the request.
   * NOTE: You can only specify a `departure_time` in the past when
   * [`RouteTravelMode`][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`.
   */
  departureTime:
    | Date
    | undefined;
  /**
   * Optional. The arrival time.
   * NOTE: Can only be set when
   * [`RouteTravelMode`][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`. You can specify either `departure_time` or `arrival_time`, but
   * not both.
   */
  arrivalTime:
    | Date
    | undefined;
  /**
   * Optional. The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see [Unicode Locale
   * Identifier](http://www.unicode.org/reports/tr35/#Unicode_locale_identifier).
   * See [Language
   * Support](https://developers.google.com/maps/faq#languagesupport)
   * for the list of supported languages. When you don't provide this value, the
   * display language is inferred from the location of the first origin.
   */
  languageCode: string;
  /**
   * Optional. The region code, specified as a ccTLD ("top-level domain")
   * two-character value. For more information see [Country code top-level
   * domains](https://en.wikipedia.org/wiki/List_of_Internet_top-level_domains#Country_code_top-level_domains).
   */
  regionCode: string;
  /** Optional. Specifies the units of measure for the display fields. */
  units: Units;
  /**
   * Optional. A list of extra computations which may be used to complete the
   * request. Note: These extra computations may return extra fields on the
   * response. These extra fields must also be specified in the field mask to be
   * returned in the response.
   */
  extraComputations: ComputeRouteMatrixRequest_ExtraComputation[];
  /**
   * Optional. Specifies the assumptions to use when calculating time in
   * traffic. This setting affects the value returned in the duration field in
   * the [RouteMatrixElement][google.maps.routing.v2.RouteMatrixElement] which
   * contains the predicted time in traffic based on historical averages.
   * [RoutingPreference][google.maps.routing.v2.RoutingPreference] to
   * `TRAFFIC_AWARE_OPTIMAL` and
   * [RouteTravelMode][google.maps.routing.v2.RouteTravelMode] to `DRIVE`.
   * Defaults to `BEST_GUESS` if traffic is requested and `TrafficModel` is not
   * specified.
   */
  trafficModel: TrafficModel;
  /**
   * Optional. Specifies preferences that influence the route returned for
   * `TRANSIT` routes. NOTE: You can only specify a `transit_preferences` when
   * [RouteTravelMode][google.maps.routing.v2.RouteTravelMode] is set to
   * `TRANSIT`.
   */
  transitPreferences: TransitPreferences | undefined;
}

/** Extra computations to perform while completing the request. */
export enum ComputeRouteMatrixRequest_ExtraComputation {
  /** EXTRA_COMPUTATION_UNSPECIFIED - Not used. Requests containing this value will fail. */
  EXTRA_COMPUTATION_UNSPECIFIED = 0,
  /** TOLLS - Toll information for the matrix element(s). */
  TOLLS = 1,
  UNRECOGNIZED = -1,
}

export function computeRouteMatrixRequest_ExtraComputationFromJSON(
  object: any,
): ComputeRouteMatrixRequest_ExtraComputation {
  switch (object) {
    case 0:
    case "EXTRA_COMPUTATION_UNSPECIFIED":
      return ComputeRouteMatrixRequest_ExtraComputation.EXTRA_COMPUTATION_UNSPECIFIED;
    case 1:
    case "TOLLS":
      return ComputeRouteMatrixRequest_ExtraComputation.TOLLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeRouteMatrixRequest_ExtraComputation.UNRECOGNIZED;
  }
}

export function computeRouteMatrixRequest_ExtraComputationToJSON(
  object: ComputeRouteMatrixRequest_ExtraComputation,
): string {
  switch (object) {
    case ComputeRouteMatrixRequest_ExtraComputation.EXTRA_COMPUTATION_UNSPECIFIED:
      return "EXTRA_COMPUTATION_UNSPECIFIED";
    case ComputeRouteMatrixRequest_ExtraComputation.TOLLS:
      return "TOLLS";
    case ComputeRouteMatrixRequest_ExtraComputation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A single origin for ComputeRouteMatrixRequest */
export interface RouteMatrixOrigin {
  /** Required. Origin waypoint */
  waypoint:
    | Waypoint
    | undefined;
  /** Optional. Modifiers for every route that takes this as the origin */
  routeModifiers: RouteModifiers | undefined;
}

/** A single destination for ComputeRouteMatrixRequest */
export interface RouteMatrixDestination {
  /** Required. Destination waypoint */
  waypoint: Waypoint | undefined;
}

/**
 * Contains route information computed for an origin/destination pair in the
 * ComputeRouteMatrix API. This proto can be streamed to the client.
 */
export interface RouteMatrixElement {
  /** Zero-based index of the origin in the request. */
  originIndex?:
    | number
    | undefined;
  /** Zero-based index of the destination in the request. */
  destinationIndex?:
    | number
    | undefined;
  /** Error status code for this element. */
  status:
    | Status
    | undefined;
  /** Indicates whether the route was found or not. Independent of status. */
  condition: RouteMatrixElementCondition;
  /** The travel distance of the route, in meters. */
  distanceMeters: number;
  /**
   * The length of time needed to navigate the route. If you set the
   * [routing_preference][google.maps.routing.v2.ComputeRouteMatrixRequest.routing_preference]
   * to `TRAFFIC_UNAWARE`, then this value is the same as `static_duration`. If
   * you set the `routing_preference` to either `TRAFFIC_AWARE` or
   * `TRAFFIC_AWARE_OPTIMAL`, then this value is calculated taking traffic
   * conditions into account.
   */
  duration:
    | Duration
    | undefined;
  /**
   * The duration of traveling through the route without taking traffic
   * conditions into consideration.
   */
  staticDuration:
    | Duration
    | undefined;
  /**
   * Additional information about the route. For example: restriction
   * information and toll information
   */
  travelAdvisory:
    | RouteTravelAdvisory
    | undefined;
  /**
   * In some cases when the server is not able to compute the route with the
   * given preferences for this particular origin/destination pair, it may
   * fall back to using a different mode of computation. When fallback mode is
   * used, this field contains detailed information about the fallback response.
   * Otherwise this field is unset.
   */
  fallbackInfo:
    | FallbackInfo
    | undefined;
  /** Text representations of properties of the `RouteMatrixElement`. */
  localizedValues: RouteMatrixElement_LocalizedValues | undefined;
}

/** Text representations of certain properties. */
export interface RouteMatrixElement_LocalizedValues {
  /** Travel distance represented in text form. */
  distance:
    | LocalizedText
    | undefined;
  /**
   * Duration represented in text form taking traffic conditions into
   * consideration. Note: If traffic information was not requested, this value
   * is the same value as static_duration.
   */
  duration:
    | LocalizedText
    | undefined;
  /**
   * Duration represented in text form without taking traffic conditions into
   * consideration.
   */
  staticDuration:
    | LocalizedText
    | undefined;
  /** Transit fare represented in text form. */
  transitFare: LocalizedText | undefined;
}

function createBaseComputeRoutesRequest(): ComputeRoutesRequest {
  return {
    origin: undefined,
    destination: undefined,
    intermediates: [],
    travelMode: 0,
    routingPreference: 0,
    polylineQuality: 0,
    polylineEncoding: 0,
    departureTime: undefined,
    arrivalTime: undefined,
    computeAlternativeRoutes: false,
    routeModifiers: undefined,
    languageCode: "",
    regionCode: "",
    units: 0,
    optimizeWaypointOrder: false,
    requestedReferenceRoutes: [],
    extraComputations: [],
    trafficModel: 0,
    transitPreferences: undefined,
  };
}

export const ComputeRoutesRequest: MessageFns<ComputeRoutesRequest> = {
  encode(message: ComputeRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.origin !== undefined) {
      Waypoint.encode(message.origin, writer.uint32(10).fork()).join();
    }
    if (message.destination !== undefined) {
      Waypoint.encode(message.destination, writer.uint32(18).fork()).join();
    }
    for (const v of message.intermediates) {
      Waypoint.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.travelMode !== 0) {
      writer.uint32(32).int32(message.travelMode);
    }
    if (message.routingPreference !== 0) {
      writer.uint32(40).int32(message.routingPreference);
    }
    if (message.polylineQuality !== 0) {
      writer.uint32(48).int32(message.polylineQuality);
    }
    if (message.polylineEncoding !== 0) {
      writer.uint32(96).int32(message.polylineEncoding);
    }
    if (message.departureTime !== undefined) {
      Timestamp.encode(toTimestamp(message.departureTime), writer.uint32(58).fork()).join();
    }
    if (message.arrivalTime !== undefined) {
      Timestamp.encode(toTimestamp(message.arrivalTime), writer.uint32(154).fork()).join();
    }
    if (message.computeAlternativeRoutes !== false) {
      writer.uint32(64).bool(message.computeAlternativeRoutes);
    }
    if (message.routeModifiers !== undefined) {
      RouteModifiers.encode(message.routeModifiers, writer.uint32(74).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(82).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(130).string(message.regionCode);
    }
    if (message.units !== 0) {
      writer.uint32(88).int32(message.units);
    }
    if (message.optimizeWaypointOrder !== false) {
      writer.uint32(104).bool(message.optimizeWaypointOrder);
    }
    writer.uint32(114).fork();
    for (const v of message.requestedReferenceRoutes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(122).fork();
    for (const v of message.extraComputations) {
      writer.int32(v);
    }
    writer.join();
    if (message.trafficModel !== 0) {
      writer.uint32(144).int32(message.trafficModel);
    }
    if (message.transitPreferences !== undefined) {
      TransitPreferences.encode(message.transitPreferences, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin = Waypoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = Waypoint.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intermediates.push(Waypoint.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.routingPreference = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.polylineQuality = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.polylineEncoding = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.departureTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.arrivalTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.computeAlternativeRoutes = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.routeModifiers = RouteModifiers.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.units = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.optimizeWaypointOrder = reader.bool();
          continue;
        case 14:
          if (tag === 112) {
            message.requestedReferenceRoutes.push(reader.int32() as any);

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestedReferenceRoutes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 15:
          if (tag === 120) {
            message.extraComputations.push(reader.int32() as any);

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.extraComputations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.trafficModel = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.transitPreferences = TransitPreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeRoutesRequest {
    return {
      origin: isSet(object.origin) ? Waypoint.fromJSON(object.origin) : undefined,
      destination: isSet(object.destination) ? Waypoint.fromJSON(object.destination) : undefined,
      intermediates: globalThis.Array.isArray(object?.intermediates)
        ? object.intermediates.map((e: any) => Waypoint.fromJSON(e))
        : [],
      travelMode: isSet(object.travelMode) ? routeTravelModeFromJSON(object.travelMode) : 0,
      routingPreference: isSet(object.routingPreference) ? routingPreferenceFromJSON(object.routingPreference) : 0,
      polylineQuality: isSet(object.polylineQuality) ? polylineQualityFromJSON(object.polylineQuality) : 0,
      polylineEncoding: isSet(object.polylineEncoding) ? polylineEncodingFromJSON(object.polylineEncoding) : 0,
      departureTime: isSet(object.departureTime) ? fromJsonTimestamp(object.departureTime) : undefined,
      arrivalTime: isSet(object.arrivalTime) ? fromJsonTimestamp(object.arrivalTime) : undefined,
      computeAlternativeRoutes: isSet(object.computeAlternativeRoutes)
        ? globalThis.Boolean(object.computeAlternativeRoutes)
        : false,
      routeModifiers: isSet(object.routeModifiers) ? RouteModifiers.fromJSON(object.routeModifiers) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      units: isSet(object.units) ? unitsFromJSON(object.units) : 0,
      optimizeWaypointOrder: isSet(object.optimizeWaypointOrder)
        ? globalThis.Boolean(object.optimizeWaypointOrder)
        : false,
      requestedReferenceRoutes: globalThis.Array.isArray(object?.requestedReferenceRoutes)
        ? object.requestedReferenceRoutes.map((e: any) => computeRoutesRequest_ReferenceRouteFromJSON(e))
        : [],
      extraComputations: globalThis.Array.isArray(object?.extraComputations)
        ? object.extraComputations.map((e: any) => computeRoutesRequest_ExtraComputationFromJSON(e))
        : [],
      trafficModel: isSet(object.trafficModel) ? trafficModelFromJSON(object.trafficModel) : 0,
      transitPreferences: isSet(object.transitPreferences)
        ? TransitPreferences.fromJSON(object.transitPreferences)
        : undefined,
    };
  },

  toJSON(message: ComputeRoutesRequest): unknown {
    const obj: any = {};
    if (message.origin !== undefined) {
      obj.origin = Waypoint.toJSON(message.origin);
    }
    if (message.destination !== undefined) {
      obj.destination = Waypoint.toJSON(message.destination);
    }
    if (message.intermediates?.length) {
      obj.intermediates = message.intermediates.map((e) => Waypoint.toJSON(e));
    }
    if (message.travelMode !== 0) {
      obj.travelMode = routeTravelModeToJSON(message.travelMode);
    }
    if (message.routingPreference !== 0) {
      obj.routingPreference = routingPreferenceToJSON(message.routingPreference);
    }
    if (message.polylineQuality !== 0) {
      obj.polylineQuality = polylineQualityToJSON(message.polylineQuality);
    }
    if (message.polylineEncoding !== 0) {
      obj.polylineEncoding = polylineEncodingToJSON(message.polylineEncoding);
    }
    if (message.departureTime !== undefined) {
      obj.departureTime = message.departureTime.toISOString();
    }
    if (message.arrivalTime !== undefined) {
      obj.arrivalTime = message.arrivalTime.toISOString();
    }
    if (message.computeAlternativeRoutes !== false) {
      obj.computeAlternativeRoutes = message.computeAlternativeRoutes;
    }
    if (message.routeModifiers !== undefined) {
      obj.routeModifiers = RouteModifiers.toJSON(message.routeModifiers);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.units !== 0) {
      obj.units = unitsToJSON(message.units);
    }
    if (message.optimizeWaypointOrder !== false) {
      obj.optimizeWaypointOrder = message.optimizeWaypointOrder;
    }
    if (message.requestedReferenceRoutes?.length) {
      obj.requestedReferenceRoutes = message.requestedReferenceRoutes.map((e) =>
        computeRoutesRequest_ReferenceRouteToJSON(e)
      );
    }
    if (message.extraComputations?.length) {
      obj.extraComputations = message.extraComputations.map((e) => computeRoutesRequest_ExtraComputationToJSON(e));
    }
    if (message.trafficModel !== 0) {
      obj.trafficModel = trafficModelToJSON(message.trafficModel);
    }
    if (message.transitPreferences !== undefined) {
      obj.transitPreferences = TransitPreferences.toJSON(message.transitPreferences);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeRoutesRequest>): ComputeRoutesRequest {
    return ComputeRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeRoutesRequest>): ComputeRoutesRequest {
    const message = createBaseComputeRoutesRequest();
    message.origin = (object.origin !== undefined && object.origin !== null)
      ? Waypoint.fromPartial(object.origin)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? Waypoint.fromPartial(object.destination)
      : undefined;
    message.intermediates = object.intermediates?.map((e) => Waypoint.fromPartial(e)) || [];
    message.travelMode = object.travelMode ?? 0;
    message.routingPreference = object.routingPreference ?? 0;
    message.polylineQuality = object.polylineQuality ?? 0;
    message.polylineEncoding = object.polylineEncoding ?? 0;
    message.departureTime = object.departureTime ?? undefined;
    message.arrivalTime = object.arrivalTime ?? undefined;
    message.computeAlternativeRoutes = object.computeAlternativeRoutes ?? false;
    message.routeModifiers = (object.routeModifiers !== undefined && object.routeModifiers !== null)
      ? RouteModifiers.fromPartial(object.routeModifiers)
      : undefined;
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.units = object.units ?? 0;
    message.optimizeWaypointOrder = object.optimizeWaypointOrder ?? false;
    message.requestedReferenceRoutes = object.requestedReferenceRoutes?.map((e) => e) || [];
    message.extraComputations = object.extraComputations?.map((e) => e) || [];
    message.trafficModel = object.trafficModel ?? 0;
    message.transitPreferences = (object.transitPreferences !== undefined && object.transitPreferences !== null)
      ? TransitPreferences.fromPartial(object.transitPreferences)
      : undefined;
    return message;
  },
};

function createBaseComputeRoutesResponse(): ComputeRoutesResponse {
  return { routes: [], fallbackInfo: undefined, geocodingResults: undefined };
}

export const ComputeRoutesResponse: MessageFns<ComputeRoutesResponse> = {
  encode(message: ComputeRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      Route.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.fallbackInfo !== undefined) {
      FallbackInfo.encode(message.fallbackInfo, writer.uint32(18).fork()).join();
    }
    if (message.geocodingResults !== undefined) {
      GeocodingResults.encode(message.geocodingResults, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routes.push(Route.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fallbackInfo = FallbackInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.geocodingResults = GeocodingResults.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeRoutesResponse {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : [],
      fallbackInfo: isSet(object.fallbackInfo) ? FallbackInfo.fromJSON(object.fallbackInfo) : undefined,
      geocodingResults: isSet(object.geocodingResults) ? GeocodingResults.fromJSON(object.geocodingResults) : undefined,
    };
  },

  toJSON(message: ComputeRoutesResponse): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    if (message.fallbackInfo !== undefined) {
      obj.fallbackInfo = FallbackInfo.toJSON(message.fallbackInfo);
    }
    if (message.geocodingResults !== undefined) {
      obj.geocodingResults = GeocodingResults.toJSON(message.geocodingResults);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeRoutesResponse>): ComputeRoutesResponse {
    return ComputeRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeRoutesResponse>): ComputeRoutesResponse {
    const message = createBaseComputeRoutesResponse();
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || [];
    message.fallbackInfo = (object.fallbackInfo !== undefined && object.fallbackInfo !== null)
      ? FallbackInfo.fromPartial(object.fallbackInfo)
      : undefined;
    message.geocodingResults = (object.geocodingResults !== undefined && object.geocodingResults !== null)
      ? GeocodingResults.fromPartial(object.geocodingResults)
      : undefined;
    return message;
  },
};

function createBaseComputeRouteMatrixRequest(): ComputeRouteMatrixRequest {
  return {
    origins: [],
    destinations: [],
    travelMode: 0,
    routingPreference: 0,
    departureTime: undefined,
    arrivalTime: undefined,
    languageCode: "",
    regionCode: "",
    units: 0,
    extraComputations: [],
    trafficModel: 0,
    transitPreferences: undefined,
  };
}

export const ComputeRouteMatrixRequest: MessageFns<ComputeRouteMatrixRequest> = {
  encode(message: ComputeRouteMatrixRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.origins) {
      RouteMatrixOrigin.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.destinations) {
      RouteMatrixDestination.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.travelMode !== 0) {
      writer.uint32(24).int32(message.travelMode);
    }
    if (message.routingPreference !== 0) {
      writer.uint32(32).int32(message.routingPreference);
    }
    if (message.departureTime !== undefined) {
      Timestamp.encode(toTimestamp(message.departureTime), writer.uint32(42).fork()).join();
    }
    if (message.arrivalTime !== undefined) {
      Timestamp.encode(toTimestamp(message.arrivalTime), writer.uint32(90).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(50).string(message.languageCode);
    }
    if (message.regionCode !== "") {
      writer.uint32(74).string(message.regionCode);
    }
    if (message.units !== 0) {
      writer.uint32(56).int32(message.units);
    }
    writer.uint32(66).fork();
    for (const v of message.extraComputations) {
      writer.int32(v);
    }
    writer.join();
    if (message.trafficModel !== 0) {
      writer.uint32(80).int32(message.trafficModel);
    }
    if (message.transitPreferences !== undefined) {
      TransitPreferences.encode(message.transitPreferences, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeRouteMatrixRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeRouteMatrixRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origins.push(RouteMatrixOrigin.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinations.push(RouteMatrixDestination.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.routingPreference = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.departureTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.arrivalTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.units = reader.int32() as any;
          continue;
        case 8:
          if (tag === 64) {
            message.extraComputations.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.extraComputations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.trafficModel = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transitPreferences = TransitPreferences.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeRouteMatrixRequest {
    return {
      origins: globalThis.Array.isArray(object?.origins)
        ? object.origins.map((e: any) => RouteMatrixOrigin.fromJSON(e))
        : [],
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => RouteMatrixDestination.fromJSON(e))
        : [],
      travelMode: isSet(object.travelMode) ? routeTravelModeFromJSON(object.travelMode) : 0,
      routingPreference: isSet(object.routingPreference) ? routingPreferenceFromJSON(object.routingPreference) : 0,
      departureTime: isSet(object.departureTime) ? fromJsonTimestamp(object.departureTime) : undefined,
      arrivalTime: isSet(object.arrivalTime) ? fromJsonTimestamp(object.arrivalTime) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      units: isSet(object.units) ? unitsFromJSON(object.units) : 0,
      extraComputations: globalThis.Array.isArray(object?.extraComputations)
        ? object.extraComputations.map((e: any) => computeRouteMatrixRequest_ExtraComputationFromJSON(e))
        : [],
      trafficModel: isSet(object.trafficModel) ? trafficModelFromJSON(object.trafficModel) : 0,
      transitPreferences: isSet(object.transitPreferences)
        ? TransitPreferences.fromJSON(object.transitPreferences)
        : undefined,
    };
  },

  toJSON(message: ComputeRouteMatrixRequest): unknown {
    const obj: any = {};
    if (message.origins?.length) {
      obj.origins = message.origins.map((e) => RouteMatrixOrigin.toJSON(e));
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => RouteMatrixDestination.toJSON(e));
    }
    if (message.travelMode !== 0) {
      obj.travelMode = routeTravelModeToJSON(message.travelMode);
    }
    if (message.routingPreference !== 0) {
      obj.routingPreference = routingPreferenceToJSON(message.routingPreference);
    }
    if (message.departureTime !== undefined) {
      obj.departureTime = message.departureTime.toISOString();
    }
    if (message.arrivalTime !== undefined) {
      obj.arrivalTime = message.arrivalTime.toISOString();
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.units !== 0) {
      obj.units = unitsToJSON(message.units);
    }
    if (message.extraComputations?.length) {
      obj.extraComputations = message.extraComputations.map((e) => computeRouteMatrixRequest_ExtraComputationToJSON(e));
    }
    if (message.trafficModel !== 0) {
      obj.trafficModel = trafficModelToJSON(message.trafficModel);
    }
    if (message.transitPreferences !== undefined) {
      obj.transitPreferences = TransitPreferences.toJSON(message.transitPreferences);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeRouteMatrixRequest>): ComputeRouteMatrixRequest {
    return ComputeRouteMatrixRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeRouteMatrixRequest>): ComputeRouteMatrixRequest {
    const message = createBaseComputeRouteMatrixRequest();
    message.origins = object.origins?.map((e) => RouteMatrixOrigin.fromPartial(e)) || [];
    message.destinations = object.destinations?.map((e) => RouteMatrixDestination.fromPartial(e)) || [];
    message.travelMode = object.travelMode ?? 0;
    message.routingPreference = object.routingPreference ?? 0;
    message.departureTime = object.departureTime ?? undefined;
    message.arrivalTime = object.arrivalTime ?? undefined;
    message.languageCode = object.languageCode ?? "";
    message.regionCode = object.regionCode ?? "";
    message.units = object.units ?? 0;
    message.extraComputations = object.extraComputations?.map((e) => e) || [];
    message.trafficModel = object.trafficModel ?? 0;
    message.transitPreferences = (object.transitPreferences !== undefined && object.transitPreferences !== null)
      ? TransitPreferences.fromPartial(object.transitPreferences)
      : undefined;
    return message;
  },
};

function createBaseRouteMatrixOrigin(): RouteMatrixOrigin {
  return { waypoint: undefined, routeModifiers: undefined };
}

export const RouteMatrixOrigin: MessageFns<RouteMatrixOrigin> = {
  encode(message: RouteMatrixOrigin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.waypoint !== undefined) {
      Waypoint.encode(message.waypoint, writer.uint32(10).fork()).join();
    }
    if (message.routeModifiers !== undefined) {
      RouteModifiers.encode(message.routeModifiers, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatrixOrigin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatrixOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.waypoint = Waypoint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.routeModifiers = RouteModifiers.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatrixOrigin {
    return {
      waypoint: isSet(object.waypoint) ? Waypoint.fromJSON(object.waypoint) : undefined,
      routeModifiers: isSet(object.routeModifiers) ? RouteModifiers.fromJSON(object.routeModifiers) : undefined,
    };
  },

  toJSON(message: RouteMatrixOrigin): unknown {
    const obj: any = {};
    if (message.waypoint !== undefined) {
      obj.waypoint = Waypoint.toJSON(message.waypoint);
    }
    if (message.routeModifiers !== undefined) {
      obj.routeModifiers = RouteModifiers.toJSON(message.routeModifiers);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteMatrixOrigin>): RouteMatrixOrigin {
    return RouteMatrixOrigin.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteMatrixOrigin>): RouteMatrixOrigin {
    const message = createBaseRouteMatrixOrigin();
    message.waypoint = (object.waypoint !== undefined && object.waypoint !== null)
      ? Waypoint.fromPartial(object.waypoint)
      : undefined;
    message.routeModifiers = (object.routeModifiers !== undefined && object.routeModifiers !== null)
      ? RouteModifiers.fromPartial(object.routeModifiers)
      : undefined;
    return message;
  },
};

function createBaseRouteMatrixDestination(): RouteMatrixDestination {
  return { waypoint: undefined };
}

export const RouteMatrixDestination: MessageFns<RouteMatrixDestination> = {
  encode(message: RouteMatrixDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.waypoint !== undefined) {
      Waypoint.encode(message.waypoint, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatrixDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatrixDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.waypoint = Waypoint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatrixDestination {
    return { waypoint: isSet(object.waypoint) ? Waypoint.fromJSON(object.waypoint) : undefined };
  },

  toJSON(message: RouteMatrixDestination): unknown {
    const obj: any = {};
    if (message.waypoint !== undefined) {
      obj.waypoint = Waypoint.toJSON(message.waypoint);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteMatrixDestination>): RouteMatrixDestination {
    return RouteMatrixDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteMatrixDestination>): RouteMatrixDestination {
    const message = createBaseRouteMatrixDestination();
    message.waypoint = (object.waypoint !== undefined && object.waypoint !== null)
      ? Waypoint.fromPartial(object.waypoint)
      : undefined;
    return message;
  },
};

function createBaseRouteMatrixElement(): RouteMatrixElement {
  return {
    originIndex: undefined,
    destinationIndex: undefined,
    status: undefined,
    condition: 0,
    distanceMeters: 0,
    duration: undefined,
    staticDuration: undefined,
    travelAdvisory: undefined,
    fallbackInfo: undefined,
    localizedValues: undefined,
  };
}

export const RouteMatrixElement: MessageFns<RouteMatrixElement> = {
  encode(message: RouteMatrixElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originIndex !== undefined) {
      writer.uint32(8).int32(message.originIndex);
    }
    if (message.destinationIndex !== undefined) {
      writer.uint32(16).int32(message.destinationIndex);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(26).fork()).join();
    }
    if (message.condition !== 0) {
      writer.uint32(72).int32(message.condition);
    }
    if (message.distanceMeters !== 0) {
      writer.uint32(32).int32(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(42).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      Duration.encode(message.staticDuration, writer.uint32(50).fork()).join();
    }
    if (message.travelAdvisory !== undefined) {
      RouteTravelAdvisory.encode(message.travelAdvisory, writer.uint32(58).fork()).join();
    }
    if (message.fallbackInfo !== undefined) {
      FallbackInfo.encode(message.fallbackInfo, writer.uint32(66).fork()).join();
    }
    if (message.localizedValues !== undefined) {
      RouteMatrixElement_LocalizedValues.encode(message.localizedValues, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatrixElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatrixElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.originIndex = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.destinationIndex = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.distanceMeters = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.staticDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.travelAdvisory = RouteTravelAdvisory.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fallbackInfo = FallbackInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.localizedValues = RouteMatrixElement_LocalizedValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatrixElement {
    return {
      originIndex: isSet(object.originIndex) ? globalThis.Number(object.originIndex) : undefined,
      destinationIndex: isSet(object.destinationIndex) ? globalThis.Number(object.destinationIndex) : undefined,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      condition: isSet(object.condition) ? routeMatrixElementConditionFromJSON(object.condition) : 0,
      distanceMeters: isSet(object.distanceMeters) ? globalThis.Number(object.distanceMeters) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? Duration.fromJSON(object.staticDuration) : undefined,
      travelAdvisory: isSet(object.travelAdvisory) ? RouteTravelAdvisory.fromJSON(object.travelAdvisory) : undefined,
      fallbackInfo: isSet(object.fallbackInfo) ? FallbackInfo.fromJSON(object.fallbackInfo) : undefined,
      localizedValues: isSet(object.localizedValues)
        ? RouteMatrixElement_LocalizedValues.fromJSON(object.localizedValues)
        : undefined,
    };
  },

  toJSON(message: RouteMatrixElement): unknown {
    const obj: any = {};
    if (message.originIndex !== undefined) {
      obj.originIndex = Math.round(message.originIndex);
    }
    if (message.destinationIndex !== undefined) {
      obj.destinationIndex = Math.round(message.destinationIndex);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.condition !== 0) {
      obj.condition = routeMatrixElementConditionToJSON(message.condition);
    }
    if (message.distanceMeters !== 0) {
      obj.distanceMeters = Math.round(message.distanceMeters);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = Duration.toJSON(message.staticDuration);
    }
    if (message.travelAdvisory !== undefined) {
      obj.travelAdvisory = RouteTravelAdvisory.toJSON(message.travelAdvisory);
    }
    if (message.fallbackInfo !== undefined) {
      obj.fallbackInfo = FallbackInfo.toJSON(message.fallbackInfo);
    }
    if (message.localizedValues !== undefined) {
      obj.localizedValues = RouteMatrixElement_LocalizedValues.toJSON(message.localizedValues);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteMatrixElement>): RouteMatrixElement {
    return RouteMatrixElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteMatrixElement>): RouteMatrixElement {
    const message = createBaseRouteMatrixElement();
    message.originIndex = object.originIndex ?? undefined;
    message.destinationIndex = object.destinationIndex ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.condition = object.condition ?? 0;
    message.distanceMeters = object.distanceMeters ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? Duration.fromPartial(object.staticDuration)
      : undefined;
    message.travelAdvisory = (object.travelAdvisory !== undefined && object.travelAdvisory !== null)
      ? RouteTravelAdvisory.fromPartial(object.travelAdvisory)
      : undefined;
    message.fallbackInfo = (object.fallbackInfo !== undefined && object.fallbackInfo !== null)
      ? FallbackInfo.fromPartial(object.fallbackInfo)
      : undefined;
    message.localizedValues = (object.localizedValues !== undefined && object.localizedValues !== null)
      ? RouteMatrixElement_LocalizedValues.fromPartial(object.localizedValues)
      : undefined;
    return message;
  },
};

function createBaseRouteMatrixElement_LocalizedValues(): RouteMatrixElement_LocalizedValues {
  return { distance: undefined, duration: undefined, staticDuration: undefined, transitFare: undefined };
}

export const RouteMatrixElement_LocalizedValues: MessageFns<RouteMatrixElement_LocalizedValues> = {
  encode(message: RouteMatrixElement_LocalizedValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distance !== undefined) {
      LocalizedText.encode(message.distance, writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      LocalizedText.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.staticDuration !== undefined) {
      LocalizedText.encode(message.staticDuration, writer.uint32(26).fork()).join();
    }
    if (message.transitFare !== undefined) {
      LocalizedText.encode(message.transitFare, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RouteMatrixElement_LocalizedValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRouteMatrixElement_LocalizedValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.distance = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.staticDuration = LocalizedText.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transitFare = LocalizedText.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RouteMatrixElement_LocalizedValues {
    return {
      distance: isSet(object.distance) ? LocalizedText.fromJSON(object.distance) : undefined,
      duration: isSet(object.duration) ? LocalizedText.fromJSON(object.duration) : undefined,
      staticDuration: isSet(object.staticDuration) ? LocalizedText.fromJSON(object.staticDuration) : undefined,
      transitFare: isSet(object.transitFare) ? LocalizedText.fromJSON(object.transitFare) : undefined,
    };
  },

  toJSON(message: RouteMatrixElement_LocalizedValues): unknown {
    const obj: any = {};
    if (message.distance !== undefined) {
      obj.distance = LocalizedText.toJSON(message.distance);
    }
    if (message.duration !== undefined) {
      obj.duration = LocalizedText.toJSON(message.duration);
    }
    if (message.staticDuration !== undefined) {
      obj.staticDuration = LocalizedText.toJSON(message.staticDuration);
    }
    if (message.transitFare !== undefined) {
      obj.transitFare = LocalizedText.toJSON(message.transitFare);
    }
    return obj;
  },

  create(base?: DeepPartial<RouteMatrixElement_LocalizedValues>): RouteMatrixElement_LocalizedValues {
    return RouteMatrixElement_LocalizedValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RouteMatrixElement_LocalizedValues>): RouteMatrixElement_LocalizedValues {
    const message = createBaseRouteMatrixElement_LocalizedValues();
    message.distance = (object.distance !== undefined && object.distance !== null)
      ? LocalizedText.fromPartial(object.distance)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? LocalizedText.fromPartial(object.duration)
      : undefined;
    message.staticDuration = (object.staticDuration !== undefined && object.staticDuration !== null)
      ? LocalizedText.fromPartial(object.staticDuration)
      : undefined;
    message.transitFare = (object.transitFare !== undefined && object.transitFare !== null)
      ? LocalizedText.fromPartial(object.transitFare)
      : undefined;
    return message;
  },
};

/** The Routes API. */
export type RoutesDefinition = typeof RoutesDefinition;
export const RoutesDefinition = {
  name: "Routes",
  fullName: "google.maps.routing.v2.Routes",
  methods: {
    /**
     * Returns the primary route along with optional alternate routes, given a set
     * of terminal and intermediate waypoints.
     *
     * **NOTE:** This method requires that you specify a response field mask in
     * the input. You can provide the response field mask by using URL parameter
     * `$fields` or `fields`, or by using an HTTP/gRPC header `X-Goog-FieldMask`
     * (see the [available URL parameters and
     * headers](https://cloud.google.com/apis/docs/system-parameters)). The value
     * is a comma separated list of field paths. See detailed documentation about
     * [how to construct the field
     * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
     *
     * For example, in this method:
     *
     * * Field mask of all available fields (for manual inspection):
     *   `X-Goog-FieldMask: *`
     * * Field mask of Route-level duration, distance, and polyline (an example
     * production setup):
     *   `X-Goog-FieldMask:
     *   routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline`
     *
     * Google discourage the use of the wildcard (`*`) response field mask, or
     * specifying the field mask at the top level (`routes`), because:
     *
     * * Selecting only the fields that you need helps our server save computation
     * cycles, allowing us to return the result to you with a lower latency.
     * * Selecting only the fields that you need
     * in your production job ensures stable latency performance. We might add
     * more response fields in the future, and those new fields might require
     * extra computation time. If you select all fields, or if you select all
     * fields at the top level, then you might experience performance degradation
     * because any new field we add will be automatically included in the
     * response.
     * * Selecting only the fields that you need results in a smaller response
     * size, and thus higher network throughput.
     */
    computeRoutes: {
      name: "ComputeRoutes",
      requestType: ComputeRoutesRequest,
      requestStream: false,
      responseType: ComputeRoutesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              33,
              58,
              1,
              42,
              34,
              28,
              47,
              100,
              105,
              114,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              118,
              50,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              82,
              111,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Takes in a list of origins and destinations and returns a stream containing
     * route information for each combination of origin and destination.
     *
     * **NOTE:** This method requires that you specify a response field mask in
     * the input. You can provide the response field mask by using the URL
     * parameter `$fields` or `fields`, or by using the HTTP/gRPC header
     * `X-Goog-FieldMask` (see the [available URL parameters and
     * headers](https://cloud.google.com/apis/docs/system-parameters)).
     * The value is a comma separated list of field paths. See this detailed
     * documentation about [how to construct the field
     * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
     *
     * For example, in this method:
     *
     * * Field mask of all available fields (for manual inspection):
     *   `X-Goog-FieldMask: *`
     * * Field mask of route durations, distances, element status, condition, and
     *   element indices (an example production setup):
     *   `X-Goog-FieldMask:
     *   originIndex,destinationIndex,status,condition,distanceMeters,duration`
     *
     * It is critical that you include `status` in your field mask as otherwise
     * all messages will appear to be OK. Google discourages the use of the
     * wildcard (`*`) response field mask, because:
     *
     * * Selecting only the fields that you need helps our server save computation
     * cycles, allowing us to return the result to you with a lower latency.
     * * Selecting only the fields that you need in your production job ensures
     * stable latency performance. We might add more response fields in the
     * future, and those new fields might require extra computation time. If you
     * select all fields, or if you select all fields at the top level, then you
     * might experience performance degradation because any new field we add will
     * be automatically included in the response.
     * * Selecting only the fields that you need results in a smaller response
     * size, and thus higher network throughput.
     */
    computeRouteMatrix: {
      name: "ComputeRouteMatrix",
      requestType: ComputeRouteMatrixRequest,
      requestStream: false,
      responseType: RouteMatrixElement,
      responseStream: true,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              100,
              105,
              115,
              116,
              97,
              110,
              99,
              101,
              77,
              97,
              116,
              114,
              105,
              120,
              47,
              118,
              50,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              82,
              111,
              117,
              116,
              101,
              77,
              97,
              116,
              114,
              105,
              120,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface RoutesServiceImplementation<CallContextExt = {}> {
  /**
   * Returns the primary route along with optional alternate routes, given a set
   * of terminal and intermediate waypoints.
   *
   * **NOTE:** This method requires that you specify a response field mask in
   * the input. You can provide the response field mask by using URL parameter
   * `$fields` or `fields`, or by using an HTTP/gRPC header `X-Goog-FieldMask`
   * (see the [available URL parameters and
   * headers](https://cloud.google.com/apis/docs/system-parameters)). The value
   * is a comma separated list of field paths. See detailed documentation about
   * [how to construct the field
   * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
   *
   * For example, in this method:
   *
   * * Field mask of all available fields (for manual inspection):
   *   `X-Goog-FieldMask: *`
   * * Field mask of Route-level duration, distance, and polyline (an example
   * production setup):
   *   `X-Goog-FieldMask:
   *   routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline`
   *
   * Google discourage the use of the wildcard (`*`) response field mask, or
   * specifying the field mask at the top level (`routes`), because:
   *
   * * Selecting only the fields that you need helps our server save computation
   * cycles, allowing us to return the result to you with a lower latency.
   * * Selecting only the fields that you need
   * in your production job ensures stable latency performance. We might add
   * more response fields in the future, and those new fields might require
   * extra computation time. If you select all fields, or if you select all
   * fields at the top level, then you might experience performance degradation
   * because any new field we add will be automatically included in the
   * response.
   * * Selecting only the fields that you need results in a smaller response
   * size, and thus higher network throughput.
   */
  computeRoutes(
    request: ComputeRoutesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeRoutesResponse>>;
  /**
   * Takes in a list of origins and destinations and returns a stream containing
   * route information for each combination of origin and destination.
   *
   * **NOTE:** This method requires that you specify a response field mask in
   * the input. You can provide the response field mask by using the URL
   * parameter `$fields` or `fields`, or by using the HTTP/gRPC header
   * `X-Goog-FieldMask` (see the [available URL parameters and
   * headers](https://cloud.google.com/apis/docs/system-parameters)).
   * The value is a comma separated list of field paths. See this detailed
   * documentation about [how to construct the field
   * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
   *
   * For example, in this method:
   *
   * * Field mask of all available fields (for manual inspection):
   *   `X-Goog-FieldMask: *`
   * * Field mask of route durations, distances, element status, condition, and
   *   element indices (an example production setup):
   *   `X-Goog-FieldMask:
   *   originIndex,destinationIndex,status,condition,distanceMeters,duration`
   *
   * It is critical that you include `status` in your field mask as otherwise
   * all messages will appear to be OK. Google discourages the use of the
   * wildcard (`*`) response field mask, because:
   *
   * * Selecting only the fields that you need helps our server save computation
   * cycles, allowing us to return the result to you with a lower latency.
   * * Selecting only the fields that you need in your production job ensures
   * stable latency performance. We might add more response fields in the
   * future, and those new fields might require extra computation time. If you
   * select all fields, or if you select all fields at the top level, then you
   * might experience performance degradation because any new field we add will
   * be automatically included in the response.
   * * Selecting only the fields that you need results in a smaller response
   * size, and thus higher network throughput.
   */
  computeRouteMatrix(
    request: ComputeRouteMatrixRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<RouteMatrixElement>>;
}

export interface RoutesClient<CallOptionsExt = {}> {
  /**
   * Returns the primary route along with optional alternate routes, given a set
   * of terminal and intermediate waypoints.
   *
   * **NOTE:** This method requires that you specify a response field mask in
   * the input. You can provide the response field mask by using URL parameter
   * `$fields` or `fields`, or by using an HTTP/gRPC header `X-Goog-FieldMask`
   * (see the [available URL parameters and
   * headers](https://cloud.google.com/apis/docs/system-parameters)). The value
   * is a comma separated list of field paths. See detailed documentation about
   * [how to construct the field
   * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
   *
   * For example, in this method:
   *
   * * Field mask of all available fields (for manual inspection):
   *   `X-Goog-FieldMask: *`
   * * Field mask of Route-level duration, distance, and polyline (an example
   * production setup):
   *   `X-Goog-FieldMask:
   *   routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline`
   *
   * Google discourage the use of the wildcard (`*`) response field mask, or
   * specifying the field mask at the top level (`routes`), because:
   *
   * * Selecting only the fields that you need helps our server save computation
   * cycles, allowing us to return the result to you with a lower latency.
   * * Selecting only the fields that you need
   * in your production job ensures stable latency performance. We might add
   * more response fields in the future, and those new fields might require
   * extra computation time. If you select all fields, or if you select all
   * fields at the top level, then you might experience performance degradation
   * because any new field we add will be automatically included in the
   * response.
   * * Selecting only the fields that you need results in a smaller response
   * size, and thus higher network throughput.
   */
  computeRoutes(
    request: DeepPartial<ComputeRoutesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeRoutesResponse>;
  /**
   * Takes in a list of origins and destinations and returns a stream containing
   * route information for each combination of origin and destination.
   *
   * **NOTE:** This method requires that you specify a response field mask in
   * the input. You can provide the response field mask by using the URL
   * parameter `$fields` or `fields`, or by using the HTTP/gRPC header
   * `X-Goog-FieldMask` (see the [available URL parameters and
   * headers](https://cloud.google.com/apis/docs/system-parameters)).
   * The value is a comma separated list of field paths. See this detailed
   * documentation about [how to construct the field
   * paths](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto).
   *
   * For example, in this method:
   *
   * * Field mask of all available fields (for manual inspection):
   *   `X-Goog-FieldMask: *`
   * * Field mask of route durations, distances, element status, condition, and
   *   element indices (an example production setup):
   *   `X-Goog-FieldMask:
   *   originIndex,destinationIndex,status,condition,distanceMeters,duration`
   *
   * It is critical that you include `status` in your field mask as otherwise
   * all messages will appear to be OK. Google discourages the use of the
   * wildcard (`*`) response field mask, because:
   *
   * * Selecting only the fields that you need helps our server save computation
   * cycles, allowing us to return the result to you with a lower latency.
   * * Selecting only the fields that you need in your production job ensures
   * stable latency performance. We might add more response fields in the
   * future, and those new fields might require extra computation time. If you
   * select all fields, or if you select all fields at the top level, then you
   * might experience performance degradation because any new field we add will
   * be automatically included in the response.
   * * Selecting only the fields that you need results in a smaller response
   * size, and thus higher network throughput.
   */
  computeRouteMatrix(
    request: DeepPartial<ComputeRouteMatrixRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<RouteMatrixElement>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
