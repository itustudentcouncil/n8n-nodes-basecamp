// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/delivery/v1/delivery_vehicles.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Int32Value } from "../../../../protobuf/wrappers.js";
import { LatLng } from "../../../../type/latlng.js";
import {
  DeliveryVehicleAttribute,
  DeliveryVehicleLocation,
  DeliveryVehicleNavigationStatus,
  deliveryVehicleNavigationStatusFromJSON,
  deliveryVehicleNavigationStatusToJSON,
  TimeWindow,
} from "./common.js";

export const protobufPackage = "maps.fleetengine.delivery.v1";

/**
 * The `DeliveryVehicle` message. A delivery vehicle transports shipments from a
 * depot to a delivery location, and from a pickup location to the depot. In
 * some cases, delivery vehicles also transport shipments directly from the
 * pickup location to the delivery location.
 *
 * Note: gRPC and REST APIs use different field naming conventions. For example,
 * the `DeliveryVehicle.current_route_segment` field in the gRPC API and the
 * `DeliveryVehicle.currentRouteSegment` field in the REST API refer to the same
 * field.
 */
export interface DeliveryVehicle {
  /**
   * The unique name of this Delivery Vehicle.
   * The format is `providers/{provider}/deliveryVehicles/{vehicle}`.
   */
  name: string;
  /** The last reported location of the Delivery Vehicle. */
  lastLocation:
    | DeliveryVehicleLocation
    | undefined;
  /** The Delivery Vehicle's navigation status. */
  navigationStatus: DeliveryVehicleNavigationStatus;
  /**
   * The encoded polyline specifying the route that the navigation recommends
   * taking to the next waypoint. Your driver app updates this when a
   * stop is reached or passed, and when the navigation reroutes. These
   * `LatLng`s are returned in
   * `Task.journey_sharing_info.remaining_vehicle_journey_segments[0].path`
   * (gRPC) or `Task.journeySharingInfo.remainingVehicleJourneySegments[0].path`
   * (REST) for all active Tasks assigned to the Vehicle.
   *
   * There are a few cases where this field might not be used to populate
   * `Task.journey_sharing_info.remaining_vehicle_journey_segments[0].path`
   * (gRPC) or `Task.journeySharingInfo.remainingVehicleJourneySegments[0].path`
   * (REST):
   *
   * * The endpoint of the `current_route_segment` does not match
   * `DeliveryVehicle.remaining_vehicle_journey_segments[0].stop` (gRPC) or
   * `DeliveryVehicle.remainingVehicleJourneySegments[0].stop` (REST).
   *
   * * The driver app has not updated its location recently, so the last
   * updated value for this field might be stale.
   *
   * * The driver app has recently updated its location, but the
   * `current_route_segment` is stale, and points to a previous vehicle stop.
   *
   * In these cases, Fleet Engine populates this field with a route from the
   * most recently passed VehicleStop to the upcoming VehicleStop to ensure that
   * the consumer of this field has the best available information on the
   * current path of the Delivery Vehicle.
   */
  currentRouteSegment: Buffer;
  /**
   * The location where the `current_route_segment` ends. This is not currently
   * populated by the driver app, but you can supply it on
   * `UpdateDeliveryVehicle` calls. It is either the `LatLng` from the upcoming
   * vehicle stop, or the last `LatLng` of the `current_route_segment`. Fleet
   * Engine will then do its best to interpolate to an actual `VehicleStop`.
   *
   * This field is ignored in `UpdateDeliveryVehicle` calls if the
   * `current_route_segment` field is empty.
   */
  currentRouteSegmentEndPoint:
    | LatLng
    | undefined;
  /**
   * The remaining driving distance for the `current_route_segment`.
   * The Driver app typically provides this field, but there are some
   * circumstances in which Fleet Engine will override the value sent by the
   * app. For more information, see
   * [DeliveryVehicle.current_route_segment][maps.fleetengine.delivery.v1.DeliveryVehicle.current_route_segment].
   * This field is returned in
   * `Task.remaining_vehicle_journey_segments[0].driving_distance_meters` (gRPC)
   * or `Task.remainingVehicleJourneySegments[0].drivingDistanceMeters` (REST)
   * for all active `Task`s assigned to the Delivery Vehicle.
   *
   * Fleet Engine ignores this field in `UpdateDeliveryVehicleRequest` if the
   * `current_route_segment` field is empty.
   */
  remainingDistanceMeters:
    | number
    | undefined;
  /**
   * The remaining driving time for the `current_route_segment`.
   * The Driver app typically provides this field, but there are some
   * circumstances in which Fleet Engine will override the value sent by the
   * app.  For more information, see
   * [DeliveryVehicle.current_route_segment][maps.fleetengine.delivery.v1.DeliveryVehicle.current_route_segment].
   * This field is returned in
   * `Task.remaining_vehicle_journey_segments[0].driving_duration` (gRPC) or
   * `Task.remainingVehicleJourneySegments[0].drivingDuration` (REST) for all
   * active tasks assigned to the Delivery Vehicle.
   *
   * Fleet Engine ignores this field in `UpdateDeliveryVehicleRequest` if the
   * `current_route_segment` field is empty.
   */
  remainingDuration:
    | Duration
    | undefined;
  /**
   * The journey segments assigned to this Delivery Vehicle, starting from the
   * Vehicle's most recently reported location. This field won't be populated
   * in the response of `ListDeliveryVehicles`.
   */
  remainingVehicleJourneySegments: VehicleJourneySegment[];
  /**
   * A list of custom Delivery Vehicle attributes. A Delivery Vehicle can have
   * at most 100 attributes, and each attribute must have a unique key.
   */
  attributes: DeliveryVehicleAttribute[];
  /** The type of this delivery vehicle. If unset, this will default to `AUTO`. */
  type: DeliveryVehicle_DeliveryVehicleType;
}

/** The type of delivery vehicle. */
export enum DeliveryVehicle_DeliveryVehicleType {
  /** DELIVERY_VEHICLE_TYPE_UNSPECIFIED - The value is unused. */
  DELIVERY_VEHICLE_TYPE_UNSPECIFIED = 0,
  /** AUTO - An automobile. */
  AUTO = 1,
  /** TWO_WHEELER - A motorcycle, moped, or other two-wheeled vehicle */
  TWO_WHEELER = 2,
  /** BICYCLE - Human-powered transport. */
  BICYCLE = 3,
  /**
   * PEDESTRIAN - A human transporter, typically walking or running, traveling along
   * pedestrian pathways.
   */
  PEDESTRIAN = 4,
  UNRECOGNIZED = -1,
}

export function deliveryVehicle_DeliveryVehicleTypeFromJSON(object: any): DeliveryVehicle_DeliveryVehicleType {
  switch (object) {
    case 0:
    case "DELIVERY_VEHICLE_TYPE_UNSPECIFIED":
      return DeliveryVehicle_DeliveryVehicleType.DELIVERY_VEHICLE_TYPE_UNSPECIFIED;
    case 1:
    case "AUTO":
      return DeliveryVehicle_DeliveryVehicleType.AUTO;
    case 2:
    case "TWO_WHEELER":
      return DeliveryVehicle_DeliveryVehicleType.TWO_WHEELER;
    case 3:
    case "BICYCLE":
      return DeliveryVehicle_DeliveryVehicleType.BICYCLE;
    case 4:
    case "PEDESTRIAN":
      return DeliveryVehicle_DeliveryVehicleType.PEDESTRIAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeliveryVehicle_DeliveryVehicleType.UNRECOGNIZED;
  }
}

export function deliveryVehicle_DeliveryVehicleTypeToJSON(object: DeliveryVehicle_DeliveryVehicleType): string {
  switch (object) {
    case DeliveryVehicle_DeliveryVehicleType.DELIVERY_VEHICLE_TYPE_UNSPECIFIED:
      return "DELIVERY_VEHICLE_TYPE_UNSPECIFIED";
    case DeliveryVehicle_DeliveryVehicleType.AUTO:
      return "AUTO";
    case DeliveryVehicle_DeliveryVehicleType.TWO_WHEELER:
      return "TWO_WHEELER";
    case DeliveryVehicle_DeliveryVehicleType.BICYCLE:
      return "BICYCLE";
    case DeliveryVehicle_DeliveryVehicleType.PEDESTRIAN:
      return "PEDESTRIAN";
    case DeliveryVehicle_DeliveryVehicleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A location with any additional identifiers. */
export interface LocationInfo {
  /** The location's coordinates. */
  point: LatLng | undefined;
}

/**
 * Represents a Vehicle’s travel segment - from its previous stop to the
 * current stop. If it is the first active stop, then it is from the
 * Vehicle’s current location to this stop.
 */
export interface VehicleJourneySegment {
  /**
   * Specifies the stop location, along with the `Task`s associated with
   * the stop. Some fields of the VehicleStop might not be present if this
   * journey segment is part of `JourneySharingInfo`.
   */
  stop:
    | VehicleStop
    | undefined;
  /**
   * Output only. The travel distance from the previous stop to this stop.
   * If the current stop is the first stop in the list of journey
   * segments, then the starting point is the vehicle's location recorded
   * at the time that this stop was added to the list. This field might not be
   * present if this journey segment is part of `JourneySharingInfo`.
   */
  drivingDistanceMeters:
    | number
    | undefined;
  /**
   * Output only. The travel time from the previous stop to this stop.
   * If the current stop is the first stop in the list of journey
   * segments, then the starting point is the Vehicle's location recorded
   * at the time that this stop was added to the list.
   *
   * If this field is defined in the path
   * `Task.remaining_vehicle_journey_segments[0].driving_duration` (gRPC) or
   * `Task.remainingVehicleJourneySegments[0].drivingDuration` (REST),
   * then it may be populated with the value from
   * `DeliveryVehicle.remaining_duration` (gRPC) or
   * `DeliveryVehicle.remainingDuration` (REST).
   * This provides the remaining driving duration from the driver app's latest
   * known location rather than the driving time from the previous stop.
   */
  drivingDuration:
    | Duration
    | undefined;
  /**
   * Output only. The path from the previous stop to this stop. If the current
   * stop is the first stop in the list of journey segments, then this is the
   * path from the vehicle's current location to this stop at the time that the
   * stop was added to the list. This field might not be present if this journey
   * segment is part of `JourneySharingInfo`.
   *
   * If this field is defined in the path
   * `Task.journey_sharing_info.remaining_vehicle_journey_segments[0].path`
   * (gRPC) or `Task.journeySharingInfo.remainingVehicleJourneySegments[0].path`
   * (REST), then it may be populated with the `LatLng`s decoded from
   * `DeliveryVehicle.current_route_segment` (gRPC) or
   * `DeliveryVehicle.currentRouteSegment` (REST). This provides the driving
   * path from the driver app's latest known location rather than the path from
   * the previous stop.
   */
  path: LatLng[];
}

/** Describes a point where a Vehicle stops to perform one or more `Task`s. */
export interface VehicleStop {
  /**
   * Required. The location of the stop. Note that the locations in the `Task`s
   * might not exactly match this location, but will be within a short distance
   * of it. This field won't be populated in the response of a `GetTask` call.
   */
  plannedLocation:
    | LocationInfo
    | undefined;
  /**
   * The list of `Task`s to be performed at this stop. This field won't be
   * populated in the response of a `GetTask` call.
   */
  tasks: VehicleStop_TaskInfo[];
  /**
   * The state of the `VehicleStop`. This field won't be populated in the
   * response of a `GetTask` call.
   */
  state: VehicleStop_State;
}

/** The current state of a `VehicleStop`. */
export enum VehicleStop_State {
  /** STATE_UNSPECIFIED - Unknown. */
  STATE_UNSPECIFIED = 0,
  /** NEW - Created, but not actively routing. */
  NEW = 1,
  /** ENROUTE - Assigned and actively routing. */
  ENROUTE = 2,
  /**
   * ARRIVED - Arrived at stop. Assumes that when the Vehicle is routing to the next
   * stop, that all previous stops have been completed.
   */
  ARRIVED = 3,
  UNRECOGNIZED = -1,
}

export function vehicleStop_StateFromJSON(object: any): VehicleStop_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return VehicleStop_State.STATE_UNSPECIFIED;
    case 1:
    case "NEW":
      return VehicleStop_State.NEW;
    case 2:
    case "ENROUTE":
      return VehicleStop_State.ENROUTE;
    case 3:
    case "ARRIVED":
      return VehicleStop_State.ARRIVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VehicleStop_State.UNRECOGNIZED;
  }
}

export function vehicleStop_StateToJSON(object: VehicleStop_State): string {
  switch (object) {
    case VehicleStop_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case VehicleStop_State.NEW:
      return "NEW";
    case VehicleStop_State.ENROUTE:
      return "ENROUTE";
    case VehicleStop_State.ARRIVED:
      return "ARRIVED";
    case VehicleStop_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Additional information about the Task performed at this stop. */
export interface VehicleStop_TaskInfo {
  /**
   * The Task ID. This field won't be populated in the response of a `GetTask`
   * call. Task IDs are subject to the following restrictions:
   *
   * * Must be a valid Unicode string.
   * * Limited to a maximum length of 64 characters.
   * * Normalized according to [Unicode Normalization Form C]
   * (http://www.unicode.org/reports/tr15/).
   * * May not contain any of the following ASCII characters: '/', ':', '?',
   * ',', or '#'.
   */
  taskId: string;
  /** Output only. The time required to perform the Task. */
  taskDuration:
    | Duration
    | undefined;
  /**
   * Output only. The time window during which the task should be completed.
   * This is only set in the response to `GetDeliveryVehicle`.
   */
  targetTimeWindow: TimeWindow | undefined;
}

function createBaseDeliveryVehicle(): DeliveryVehicle {
  return {
    name: "",
    lastLocation: undefined,
    navigationStatus: 0,
    currentRouteSegment: Buffer.alloc(0),
    currentRouteSegmentEndPoint: undefined,
    remainingDistanceMeters: undefined,
    remainingDuration: undefined,
    remainingVehicleJourneySegments: [],
    attributes: [],
    type: 0,
  };
}

export const DeliveryVehicle: MessageFns<DeliveryVehicle> = {
  encode(message: DeliveryVehicle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lastLocation !== undefined) {
      DeliveryVehicleLocation.encode(message.lastLocation, writer.uint32(18).fork()).join();
    }
    if (message.navigationStatus !== 0) {
      writer.uint32(24).int32(message.navigationStatus);
    }
    if (message.currentRouteSegment.length !== 0) {
      writer.uint32(34).bytes(message.currentRouteSegment);
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      LatLng.encode(message.currentRouteSegmentEndPoint, writer.uint32(42).fork()).join();
    }
    if (message.remainingDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.remainingDistanceMeters! }, writer.uint32(50).fork()).join();
    }
    if (message.remainingDuration !== undefined) {
      Duration.encode(message.remainingDuration, writer.uint32(58).fork()).join();
    }
    for (const v of message.remainingVehicleJourneySegments) {
      VehicleJourneySegment.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.attributes) {
      DeliveryVehicleAttribute.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeliveryVehicle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeliveryVehicle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastLocation = DeliveryVehicleLocation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.navigationStatus = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentRouteSegment = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currentRouteSegmentEndPoint = LatLng.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.remainingDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.remainingDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.remainingVehicleJourneySegments.push(VehicleJourneySegment.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.attributes.push(DeliveryVehicleAttribute.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeliveryVehicle {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lastLocation: isSet(object.lastLocation) ? DeliveryVehicleLocation.fromJSON(object.lastLocation) : undefined,
      navigationStatus: isSet(object.navigationStatus)
        ? deliveryVehicleNavigationStatusFromJSON(object.navigationStatus)
        : 0,
      currentRouteSegment: isSet(object.currentRouteSegment)
        ? Buffer.from(bytesFromBase64(object.currentRouteSegment))
        : Buffer.alloc(0),
      currentRouteSegmentEndPoint: isSet(object.currentRouteSegmentEndPoint)
        ? LatLng.fromJSON(object.currentRouteSegmentEndPoint)
        : undefined,
      remainingDistanceMeters: isSet(object.remainingDistanceMeters)
        ? Number(object.remainingDistanceMeters)
        : undefined,
      remainingDuration: isSet(object.remainingDuration) ? Duration.fromJSON(object.remainingDuration) : undefined,
      remainingVehicleJourneySegments: globalThis.Array.isArray(object?.remainingVehicleJourneySegments)
        ? object.remainingVehicleJourneySegments.map((e: any) => VehicleJourneySegment.fromJSON(e))
        : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => DeliveryVehicleAttribute.fromJSON(e))
        : [],
      type: isSet(object.type) ? deliveryVehicle_DeliveryVehicleTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: DeliveryVehicle): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lastLocation !== undefined) {
      obj.lastLocation = DeliveryVehicleLocation.toJSON(message.lastLocation);
    }
    if (message.navigationStatus !== 0) {
      obj.navigationStatus = deliveryVehicleNavigationStatusToJSON(message.navigationStatus);
    }
    if (message.currentRouteSegment.length !== 0) {
      obj.currentRouteSegment = base64FromBytes(message.currentRouteSegment);
    }
    if (message.currentRouteSegmentEndPoint !== undefined) {
      obj.currentRouteSegmentEndPoint = LatLng.toJSON(message.currentRouteSegmentEndPoint);
    }
    if (message.remainingDistanceMeters !== undefined) {
      obj.remainingDistanceMeters = message.remainingDistanceMeters;
    }
    if (message.remainingDuration !== undefined) {
      obj.remainingDuration = Duration.toJSON(message.remainingDuration);
    }
    if (message.remainingVehicleJourneySegments?.length) {
      obj.remainingVehicleJourneySegments = message.remainingVehicleJourneySegments.map((e) =>
        VehicleJourneySegment.toJSON(e)
      );
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => DeliveryVehicleAttribute.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = deliveryVehicle_DeliveryVehicleTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<DeliveryVehicle>): DeliveryVehicle {
    return DeliveryVehicle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeliveryVehicle>): DeliveryVehicle {
    const message = createBaseDeliveryVehicle();
    message.name = object.name ?? "";
    message.lastLocation = (object.lastLocation !== undefined && object.lastLocation !== null)
      ? DeliveryVehicleLocation.fromPartial(object.lastLocation)
      : undefined;
    message.navigationStatus = object.navigationStatus ?? 0;
    message.currentRouteSegment = object.currentRouteSegment ?? Buffer.alloc(0);
    message.currentRouteSegmentEndPoint =
      (object.currentRouteSegmentEndPoint !== undefined && object.currentRouteSegmentEndPoint !== null)
        ? LatLng.fromPartial(object.currentRouteSegmentEndPoint)
        : undefined;
    message.remainingDistanceMeters = object.remainingDistanceMeters ?? undefined;
    message.remainingDuration = (object.remainingDuration !== undefined && object.remainingDuration !== null)
      ? Duration.fromPartial(object.remainingDuration)
      : undefined;
    message.remainingVehicleJourneySegments =
      object.remainingVehicleJourneySegments?.map((e) => VehicleJourneySegment.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => DeliveryVehicleAttribute.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseLocationInfo(): LocationInfo {
  return { point: undefined };
}

export const LocationInfo: MessageFns<LocationInfo> = {
  encode(message: LocationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.point !== undefined) {
      LatLng.encode(message.point, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.point = LatLng.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationInfo {
    return { point: isSet(object.point) ? LatLng.fromJSON(object.point) : undefined };
  },

  toJSON(message: LocationInfo): unknown {
    const obj: any = {};
    if (message.point !== undefined) {
      obj.point = LatLng.toJSON(message.point);
    }
    return obj;
  },

  create(base?: DeepPartial<LocationInfo>): LocationInfo {
    return LocationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationInfo>): LocationInfo {
    const message = createBaseLocationInfo();
    message.point = (object.point !== undefined && object.point !== null)
      ? LatLng.fromPartial(object.point)
      : undefined;
    return message;
  },
};

function createBaseVehicleJourneySegment(): VehicleJourneySegment {
  return { stop: undefined, drivingDistanceMeters: undefined, drivingDuration: undefined, path: [] };
}

export const VehicleJourneySegment: MessageFns<VehicleJourneySegment> = {
  encode(message: VehicleJourneySegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stop !== undefined) {
      VehicleStop.encode(message.stop, writer.uint32(10).fork()).join();
    }
    if (message.drivingDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.drivingDistanceMeters! }, writer.uint32(18).fork()).join();
    }
    if (message.drivingDuration !== undefined) {
      Duration.encode(message.drivingDuration, writer.uint32(26).fork()).join();
    }
    for (const v of message.path) {
      LatLng.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleJourneySegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleJourneySegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stop = VehicleStop.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.drivingDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.drivingDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.path.push(LatLng.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleJourneySegment {
    return {
      stop: isSet(object.stop) ? VehicleStop.fromJSON(object.stop) : undefined,
      drivingDistanceMeters: isSet(object.drivingDistanceMeters) ? Number(object.drivingDistanceMeters) : undefined,
      drivingDuration: isSet(object.drivingDuration) ? Duration.fromJSON(object.drivingDuration) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => LatLng.fromJSON(e)) : [],
    };
  },

  toJSON(message: VehicleJourneySegment): unknown {
    const obj: any = {};
    if (message.stop !== undefined) {
      obj.stop = VehicleStop.toJSON(message.stop);
    }
    if (message.drivingDistanceMeters !== undefined) {
      obj.drivingDistanceMeters = message.drivingDistanceMeters;
    }
    if (message.drivingDuration !== undefined) {
      obj.drivingDuration = Duration.toJSON(message.drivingDuration);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => LatLng.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleJourneySegment>): VehicleJourneySegment {
    return VehicleJourneySegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleJourneySegment>): VehicleJourneySegment {
    const message = createBaseVehicleJourneySegment();
    message.stop = (object.stop !== undefined && object.stop !== null)
      ? VehicleStop.fromPartial(object.stop)
      : undefined;
    message.drivingDistanceMeters = object.drivingDistanceMeters ?? undefined;
    message.drivingDuration = (object.drivingDuration !== undefined && object.drivingDuration !== null)
      ? Duration.fromPartial(object.drivingDuration)
      : undefined;
    message.path = object.path?.map((e) => LatLng.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVehicleStop(): VehicleStop {
  return { plannedLocation: undefined, tasks: [], state: 0 };
}

export const VehicleStop: MessageFns<VehicleStop> = {
  encode(message: VehicleStop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plannedLocation !== undefined) {
      LocationInfo.encode(message.plannedLocation, writer.uint32(10).fork()).join();
    }
    for (const v of message.tasks) {
      VehicleStop_TaskInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleStop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plannedLocation = LocationInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tasks.push(VehicleStop_TaskInfo.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleStop {
    return {
      plannedLocation: isSet(object.plannedLocation) ? LocationInfo.fromJSON(object.plannedLocation) : undefined,
      tasks: globalThis.Array.isArray(object?.tasks)
        ? object.tasks.map((e: any) => VehicleStop_TaskInfo.fromJSON(e))
        : [],
      state: isSet(object.state) ? vehicleStop_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: VehicleStop): unknown {
    const obj: any = {};
    if (message.plannedLocation !== undefined) {
      obj.plannedLocation = LocationInfo.toJSON(message.plannedLocation);
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => VehicleStop_TaskInfo.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = vehicleStop_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleStop>): VehicleStop {
    return VehicleStop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleStop>): VehicleStop {
    const message = createBaseVehicleStop();
    message.plannedLocation = (object.plannedLocation !== undefined && object.plannedLocation !== null)
      ? LocationInfo.fromPartial(object.plannedLocation)
      : undefined;
    message.tasks = object.tasks?.map((e) => VehicleStop_TaskInfo.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseVehicleStop_TaskInfo(): VehicleStop_TaskInfo {
  return { taskId: "", taskDuration: undefined, targetTimeWindow: undefined };
}

export const VehicleStop_TaskInfo: MessageFns<VehicleStop_TaskInfo> = {
  encode(message: VehicleStop_TaskInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.taskDuration !== undefined) {
      Duration.encode(message.taskDuration, writer.uint32(18).fork()).join();
    }
    if (message.targetTimeWindow !== undefined) {
      TimeWindow.encode(message.targetTimeWindow, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleStop_TaskInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleStop_TaskInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetTimeWindow = TimeWindow.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleStop_TaskInfo {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      taskDuration: isSet(object.taskDuration) ? Duration.fromJSON(object.taskDuration) : undefined,
      targetTimeWindow: isSet(object.targetTimeWindow) ? TimeWindow.fromJSON(object.targetTimeWindow) : undefined,
    };
  },

  toJSON(message: VehicleStop_TaskInfo): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.taskDuration !== undefined) {
      obj.taskDuration = Duration.toJSON(message.taskDuration);
    }
    if (message.targetTimeWindow !== undefined) {
      obj.targetTimeWindow = TimeWindow.toJSON(message.targetTimeWindow);
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleStop_TaskInfo>): VehicleStop_TaskInfo {
    return VehicleStop_TaskInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleStop_TaskInfo>): VehicleStop_TaskInfo {
    const message = createBaseVehicleStop_TaskInfo();
    message.taskId = object.taskId ?? "";
    message.taskDuration = (object.taskDuration !== undefined && object.taskDuration !== null)
      ? Duration.fromPartial(object.taskDuration)
      : undefined;
    message.targetTimeWindow = (object.targetTimeWindow !== undefined && object.targetTimeWindow !== null)
      ? TimeWindow.fromPartial(object.targetTimeWindow)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
