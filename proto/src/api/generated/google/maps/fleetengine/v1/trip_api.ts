// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/v1/trip_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { PolylineFormatType, polylineFormatTypeFromJSON, polylineFormatTypeToJSON } from "./fleetengine.js";
import { RequestHeader } from "./header.js";
import {
  BillingPlatformIdentifier,
  billingPlatformIdentifierFromJSON,
  billingPlatformIdentifierToJSON,
  Trip,
  TripView,
  tripViewFromJSON,
  tripViewToJSON,
} from "./trips.js";

export const protobufPackage = "maps.fleetengine.v1";

/** CreateTrip request message. */
export interface CreateTripRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  parent: string;
  /**
   * Required. Unique Trip ID.
   * Subject to the following restrictions:
   *
   * * Must be a valid Unicode string.
   * * Limited to a maximum length of 64 characters.
   * * Normalized according to [Unicode Normalization Form C]
   * (http://www.unicode.org/reports/tr15/).
   * * May not contain any of the following ASCII characters: '/', ':', '?',
   * ',', or '#'.
   */
  tripId: string;
  /**
   * Required. Trip entity to create.
   *
   * When creating a Trip, the following fields are required:
   *
   * * `trip_type`
   * * `pickup_point`
   *
   * The following fields are used if you provide them:
   *
   * * `number_of_passengers`
   * * `vehicle_id`
   * * `dropoff_point`
   * * `intermediate_destinations`
   * * `vehicle_waypoints`
   *
   * All other Trip fields are ignored. For example, all trips start with a
   * `trip_status` of `NEW` even if you pass in a `trip_status` of `CANCELED` in
   * the creation request.
   *
   * Only `EXCLUSIVE` trips support `intermediate_destinations`.
   *
   * When `vehicle_id` is set for a shared trip, you must supply
   * the list of `Trip.vehicle_waypoints` to specify the order of the remaining
   * waypoints for the vehicle, otherwise the waypoint order will be
   * undetermined.
   *
   * When you specify `Trip.vehicle_waypoints`, the list must contain all
   * the remaining waypoints of the vehicle's trips, with no extra waypoints.
   * You must order these waypoints such that for a given trip, the pickup
   * point is before intermediate destinations, and all intermediate
   * destinations come before the drop-off point. An `EXCLUSIVE` trip's
   * waypoints must not interleave with any other trips.
   *
   * The `trip_id`, `waypoint_type` and `location` fields are used, and all
   * other TripWaypoint fields in `vehicle_waypoints` are ignored.
   */
  trip: Trip | undefined;
}

/** GetTrip request message. */
export interface GetTripRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}/trips/{trip}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  name: string;
  /** The subset of Trip fields that should be returned and their interpretation. */
  view: TripView;
  /**
   * Indicates the minimum timestamp (exclusive) for which `Trip.route` or
   * `Trip.current_route_segment` data are retrieved. If route data are
   * unchanged since this timestamp, the route field is not set in the response.
   * If a minimum is unspecified, the route data are always retrieved.
   */
  currentRouteSegmentVersion:
    | Date
    | undefined;
  /**
   * Indicates the minimum timestamp (exclusive) for which
   * `Trip.remaining_waypoints` are retrieved. If they are unchanged since this
   * timestamp, the `remaining_waypoints` are not set in the response. If this
   * field is unspecified, `remaining_waypoints` is always retrieved.
   */
  remainingWaypointsVersion:
    | Date
    | undefined;
  /**
   * The returned current route format, `LAT_LNG_LIST_TYPE` (in `Trip.route`),
   * or `ENCODED_POLYLINE_TYPE` (in `Trip.current_route_segment`). The default
   * is `LAT_LNG_LIST_TYPE`.
   */
  routeFormatType: PolylineFormatType;
  /**
   * Indicates the minimum timestamp (exclusive) for which
   * `Trip.current_route_segment_traffic` is retrieved. If traffic data are
   * unchanged since this timestamp, the `current_route_segment_traffic` field
   * is not set in the response. If a minimum is unspecified, the traffic data
   * are always retrieved. Note that traffic is only available for On-Demand
   * Rides and Deliveries Solution customers.
   */
  currentRouteSegmentTrafficVersion:
    | Date
    | undefined;
  /**
   * Indicates the minimum timestamp (exclusive) for which
   * `Trip.remaining_waypoints.traffic_to_waypoint` and
   * `Trip.remaining_waypoints.path_to_waypoint` data are retrieved. If data are
   * unchanged since this timestamp, the fields above are
   * not set in the response. If `remaining_waypoints_route_version` is
   * unspecified, traffic and path are always retrieved.
   */
  remainingWaypointsRouteVersion: Date | undefined;
}

/** ReportBillableTrip request message. */
export interface ReportBillableTripRequest {
  /**
   * Required. Must be in the format
   * `providers/{provider}/billableTrips/{billable_trip}`. The
   * provider must be the Project ID (for example, `sample-cloud-project`) of
   * the Google Cloud Project of which the service account making this call is a
   * member.
   */
  name: string;
  /**
   * Required. Two letter country code of the country where the trip takes
   * place. Price is defined according to country code.
   */
  countryCode: string;
  /** The platform upon which the request was issued. */
  platform: BillingPlatformIdentifier;
  /**
   * The identifiers that are directly related to the trip being reported. These
   * are usually IDs (for example, session IDs) of pre-booking operations done
   * before the trip ID is available. The number of `related_ids` is
   * limited to 50.
   */
  relatedIds: string[];
  /**
   * The type of GMP product solution (for example,
   * `ON_DEMAND_RIDESHARING_AND_DELIVERIES`) used for the reported trip.
   */
  solutionType: ReportBillableTripRequest_SolutionType;
}

/** Selector for different solution types of a reported trip. */
export enum ReportBillableTripRequest_SolutionType {
  /**
   * SOLUTION_TYPE_UNSPECIFIED - The default value. For backwards-compatibility, the API will use
   * `ON_DEMAND_RIDESHARING_AND_DELIVERIES` by default which is the first
   * supported solution type.
   */
  SOLUTION_TYPE_UNSPECIFIED = 0,
  /** ON_DEMAND_RIDESHARING_AND_DELIVERIES - The solution is an on-demand ridesharing and deliveries trip. */
  ON_DEMAND_RIDESHARING_AND_DELIVERIES = 1,
  UNRECOGNIZED = -1,
}

export function reportBillableTripRequest_SolutionTypeFromJSON(object: any): ReportBillableTripRequest_SolutionType {
  switch (object) {
    case 0:
    case "SOLUTION_TYPE_UNSPECIFIED":
      return ReportBillableTripRequest_SolutionType.SOLUTION_TYPE_UNSPECIFIED;
    case 1:
    case "ON_DEMAND_RIDESHARING_AND_DELIVERIES":
      return ReportBillableTripRequest_SolutionType.ON_DEMAND_RIDESHARING_AND_DELIVERIES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportBillableTripRequest_SolutionType.UNRECOGNIZED;
  }
}

export function reportBillableTripRequest_SolutionTypeToJSON(object: ReportBillableTripRequest_SolutionType): string {
  switch (object) {
    case ReportBillableTripRequest_SolutionType.SOLUTION_TYPE_UNSPECIFIED:
      return "SOLUTION_TYPE_UNSPECIFIED";
    case ReportBillableTripRequest_SolutionType.ON_DEMAND_RIDESHARING_AND_DELIVERIES:
      return "ON_DEMAND_RIDESHARING_AND_DELIVERIES";
    case ReportBillableTripRequest_SolutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** UpdateTrip request message. */
export interface UpdateTripRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format
   * `providers/{provider}/trips/{trip}`. The provider must
   * be the Project ID (for example, `sample-consumer-project`) of the Google
   * Cloud Project of which the service account making this call is a member.
   */
  name: string;
  /**
   * Required. The Trip associated with the update.
   *
   * The following fields are maintained by the Fleet Engine. Do not update
   * them using Trip.update.
   *
   * * `current_route_segment`
   * * `current_route_segment_end_point`
   * * `current_route_segment_traffic`
   * * `current_route_segment_traffic_version`
   * * `current_route_segment_version`
   * * `dropoff_time`
   * * `eta_to_next_waypoint`
   * * `intermediate_destinations_version`
   * * `last_location`
   * * `name`
   * * `number_of_passengers`
   * * `pickup_time`
   * * `remaining_distance_meters`
   * * `remaining_time_to_first_waypoint`
   * * `remaining_waypoints`
   * * `remaining_waypoints_version`
   * * `route`
   *
   * When you update the `Trip.vehicle_id` for a shared trip, you must supply
   * the list of `Trip.vehicle_waypoints` to specify the order of the remaining
   * waypoints, otherwise the order will be undetermined.
   *
   * When you specify `Trip.vehicle_waypoints`, the list must contain all
   * the remaining waypoints of the vehicle's trips, with no extra waypoints.
   * You must order these waypoints such that for a given trip, the pickup
   * point is before intermediate destinations, and all intermediate
   * destinations come before the drop-off point. An `EXCLUSIVE` trip's
   * waypoints must not interleave with any other trips.
   * The `trip_id`, `waypoint_type` and `location` fields are used, and all
   * other TripWaypoint fields in `vehicle_waypoints` are ignored.
   *
   * To avoid a race condition for trips with multiple destinations, you
   * should provide `Trip.intermediate_destinations_version` when updating
   * the trip status to `ENROUTE_TO_INTERMEDIATE_DESTINATION`. The
   * `Trip.intermediate_destinations_version` passed must be consistent with
   * Fleet Engine's version. If it isn't, the request fails.
   */
  trip:
    | Trip
    | undefined;
  /**
   * Required. The field mask indicating which fields in Trip to update.
   * The `update_mask` must contain at least one field.
   */
  updateMask: string[] | undefined;
}

/** SearchTrips request message. */
export interface SearchTripsRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  parent: string;
  /**
   * The vehicle associated with the trips in the request. If unspecified, the
   * returned trips do not contain:
   *
   * * `current_route_segment`
   * * `remaining_waypoints`
   * * `remaining_distance_meters`
   * * `eta_to_first_waypoint`
   */
  vehicleId: string;
  /**
   * If set to true, the response includes Trips that influence a driver's
   * route.
   */
  activeTripsOnly: boolean;
  /** If not set, the server decides the number of results to return. */
  pageSize: number;
  /**
   * Set this to a value previously returned in the `SearchTripsResponse` to
   * continue from previous results.
   */
  pageToken: string;
  /**
   * If specified, returns the trips that have not been updated after the time
   * `(current - minimum_staleness)`.
   */
  minimumStaleness: Duration | undefined;
}

/** SearchTrips response message. */
export interface SearchTripsResponse {
  /** The list of trips for the requested vehicle. */
  trips: Trip[];
  /**
   * Pass this token in the SearchTripsRequest to page through list results. The
   * API returns a trip list on each call, and when no more results remain the
   * trip list is empty.
   */
  nextPageToken: string;
}

function createBaseCreateTripRequest(): CreateTripRequest {
  return { header: undefined, parent: "", tripId: "", trip: undefined };
}

export const CreateTripRequest: MessageFns<CreateTripRequest> = {
  encode(message: CreateTripRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.tripId !== "") {
      writer.uint32(42).string(message.tripId);
    }
    if (message.trip !== undefined) {
      Trip.encode(message.trip, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTripRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTripRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tripId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trip = Trip.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTripRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : "",
      trip: isSet(object.trip) ? Trip.fromJSON(object.trip) : undefined,
    };
  },

  toJSON(message: CreateTripRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.tripId !== "") {
      obj.tripId = message.tripId;
    }
    if (message.trip !== undefined) {
      obj.trip = Trip.toJSON(message.trip);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTripRequest>): CreateTripRequest {
    return CreateTripRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTripRequest>): CreateTripRequest {
    const message = createBaseCreateTripRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.parent = object.parent ?? "";
    message.tripId = object.tripId ?? "";
    message.trip = (object.trip !== undefined && object.trip !== null) ? Trip.fromPartial(object.trip) : undefined;
    return message;
  },
};

function createBaseGetTripRequest(): GetTripRequest {
  return {
    header: undefined,
    name: "",
    view: 0,
    currentRouteSegmentVersion: undefined,
    remainingWaypointsVersion: undefined,
    routeFormatType: 0,
    currentRouteSegmentTrafficVersion: undefined,
    remainingWaypointsRouteVersion: undefined,
  };
}

export const GetTripRequest: MessageFns<GetTripRequest> = {
  encode(message: GetTripRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(88).int32(message.view);
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentVersion), writer.uint32(50).fork()).join();
    }
    if (message.remainingWaypointsVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.remainingWaypointsVersion), writer.uint32(58).fork()).join();
    }
    if (message.routeFormatType !== 0) {
      writer.uint32(64).int32(message.routeFormatType);
    }
    if (message.currentRouteSegmentTrafficVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentTrafficVersion), writer.uint32(74).fork()).join();
    }
    if (message.remainingWaypointsRouteVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.remainingWaypointsRouteVersion), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTripRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTripRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currentRouteSegmentVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.remainingWaypointsVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.routeFormatType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.currentRouteSegmentTrafficVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.remainingWaypointsRouteVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTripRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? tripViewFromJSON(object.view) : 0,
      currentRouteSegmentVersion: isSet(object.currentRouteSegmentVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentVersion)
        : undefined,
      remainingWaypointsVersion: isSet(object.remainingWaypointsVersion)
        ? fromJsonTimestamp(object.remainingWaypointsVersion)
        : undefined,
      routeFormatType: isSet(object.routeFormatType) ? polylineFormatTypeFromJSON(object.routeFormatType) : 0,
      currentRouteSegmentTrafficVersion: isSet(object.currentRouteSegmentTrafficVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentTrafficVersion)
        : undefined,
      remainingWaypointsRouteVersion: isSet(object.remainingWaypointsRouteVersion)
        ? fromJsonTimestamp(object.remainingWaypointsRouteVersion)
        : undefined,
    };
  },

  toJSON(message: GetTripRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = tripViewToJSON(message.view);
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      obj.currentRouteSegmentVersion = message.currentRouteSegmentVersion.toISOString();
    }
    if (message.remainingWaypointsVersion !== undefined) {
      obj.remainingWaypointsVersion = message.remainingWaypointsVersion.toISOString();
    }
    if (message.routeFormatType !== 0) {
      obj.routeFormatType = polylineFormatTypeToJSON(message.routeFormatType);
    }
    if (message.currentRouteSegmentTrafficVersion !== undefined) {
      obj.currentRouteSegmentTrafficVersion = message.currentRouteSegmentTrafficVersion.toISOString();
    }
    if (message.remainingWaypointsRouteVersion !== undefined) {
      obj.remainingWaypointsRouteVersion = message.remainingWaypointsRouteVersion.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetTripRequest>): GetTripRequest {
    return GetTripRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTripRequest>): GetTripRequest {
    const message = createBaseGetTripRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    message.currentRouteSegmentVersion = object.currentRouteSegmentVersion ?? undefined;
    message.remainingWaypointsVersion = object.remainingWaypointsVersion ?? undefined;
    message.routeFormatType = object.routeFormatType ?? 0;
    message.currentRouteSegmentTrafficVersion = object.currentRouteSegmentTrafficVersion ?? undefined;
    message.remainingWaypointsRouteVersion = object.remainingWaypointsRouteVersion ?? undefined;
    return message;
  },
};

function createBaseReportBillableTripRequest(): ReportBillableTripRequest {
  return { name: "", countryCode: "", platform: 0, relatedIds: [], solutionType: 0 };
}

export const ReportBillableTripRequest: MessageFns<ReportBillableTripRequest> = {
  encode(message: ReportBillableTripRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.countryCode !== "") {
      writer.uint32(26).string(message.countryCode);
    }
    if (message.platform !== 0) {
      writer.uint32(40).int32(message.platform);
    }
    for (const v of message.relatedIds) {
      writer.uint32(50).string(v!);
    }
    if (message.solutionType !== 0) {
      writer.uint32(56).int32(message.solutionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportBillableTripRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportBillableTripRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.platform = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.relatedIds.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.solutionType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportBillableTripRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      platform: isSet(object.platform) ? billingPlatformIdentifierFromJSON(object.platform) : 0,
      relatedIds: globalThis.Array.isArray(object?.relatedIds)
        ? object.relatedIds.map((e: any) => globalThis.String(e))
        : [],
      solutionType: isSet(object.solutionType)
        ? reportBillableTripRequest_SolutionTypeFromJSON(object.solutionType)
        : 0,
    };
  },

  toJSON(message: ReportBillableTripRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.platform !== 0) {
      obj.platform = billingPlatformIdentifierToJSON(message.platform);
    }
    if (message.relatedIds?.length) {
      obj.relatedIds = message.relatedIds;
    }
    if (message.solutionType !== 0) {
      obj.solutionType = reportBillableTripRequest_SolutionTypeToJSON(message.solutionType);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportBillableTripRequest>): ReportBillableTripRequest {
    return ReportBillableTripRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportBillableTripRequest>): ReportBillableTripRequest {
    const message = createBaseReportBillableTripRequest();
    message.name = object.name ?? "";
    message.countryCode = object.countryCode ?? "";
    message.platform = object.platform ?? 0;
    message.relatedIds = object.relatedIds?.map((e) => e) || [];
    message.solutionType = object.solutionType ?? 0;
    return message;
  },
};

function createBaseUpdateTripRequest(): UpdateTripRequest {
  return { header: undefined, name: "", trip: undefined, updateMask: undefined };
}

export const UpdateTripRequest: MessageFns<UpdateTripRequest> = {
  encode(message: UpdateTripRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.trip !== undefined) {
      Trip.encode(message.trip, writer.uint32(34).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTripRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTripRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trip = Trip.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTripRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      trip: isSet(object.trip) ? Trip.fromJSON(object.trip) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateTripRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.trip !== undefined) {
      obj.trip = Trip.toJSON(message.trip);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTripRequest>): UpdateTripRequest {
    return UpdateTripRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTripRequest>): UpdateTripRequest {
    const message = createBaseUpdateTripRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.name = object.name ?? "";
    message.trip = (object.trip !== undefined && object.trip !== null) ? Trip.fromPartial(object.trip) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseSearchTripsRequest(): SearchTripsRequest {
  return {
    header: undefined,
    parent: "",
    vehicleId: "",
    activeTripsOnly: false,
    pageSize: 0,
    pageToken: "",
    minimumStaleness: undefined,
  };
}

export const SearchTripsRequest: MessageFns<SearchTripsRequest> = {
  encode(message: SearchTripsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.vehicleId !== "") {
      writer.uint32(34).string(message.vehicleId);
    }
    if (message.activeTripsOnly !== false) {
      writer.uint32(40).bool(message.activeTripsOnly);
    }
    if (message.pageSize !== 0) {
      writer.uint32(48).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(58).string(message.pageToken);
    }
    if (message.minimumStaleness !== undefined) {
      Duration.encode(message.minimumStaleness, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTripsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTripsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vehicleId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeTripsOnly = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.minimumStaleness = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTripsRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      vehicleId: isSet(object.vehicleId) ? globalThis.String(object.vehicleId) : "",
      activeTripsOnly: isSet(object.activeTripsOnly) ? globalThis.Boolean(object.activeTripsOnly) : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      minimumStaleness: isSet(object.minimumStaleness) ? Duration.fromJSON(object.minimumStaleness) : undefined,
    };
  },

  toJSON(message: SearchTripsRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.vehicleId !== "") {
      obj.vehicleId = message.vehicleId;
    }
    if (message.activeTripsOnly !== false) {
      obj.activeTripsOnly = message.activeTripsOnly;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.minimumStaleness !== undefined) {
      obj.minimumStaleness = Duration.toJSON(message.minimumStaleness);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTripsRequest>): SearchTripsRequest {
    return SearchTripsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTripsRequest>): SearchTripsRequest {
    const message = createBaseSearchTripsRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.parent = object.parent ?? "";
    message.vehicleId = object.vehicleId ?? "";
    message.activeTripsOnly = object.activeTripsOnly ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.minimumStaleness = (object.minimumStaleness !== undefined && object.minimumStaleness !== null)
      ? Duration.fromPartial(object.minimumStaleness)
      : undefined;
    return message;
  },
};

function createBaseSearchTripsResponse(): SearchTripsResponse {
  return { trips: [], nextPageToken: "" };
}

export const SearchTripsResponse: MessageFns<SearchTripsResponse> = {
  encode(message: SearchTripsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trips) {
      Trip.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchTripsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchTripsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.trips.push(Trip.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchTripsResponse {
    return {
      trips: globalThis.Array.isArray(object?.trips) ? object.trips.map((e: any) => Trip.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchTripsResponse): unknown {
    const obj: any = {};
    if (message.trips?.length) {
      obj.trips = message.trips.map((e) => Trip.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchTripsResponse>): SearchTripsResponse {
    return SearchTripsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchTripsResponse>): SearchTripsResponse {
    const message = createBaseSearchTripsResponse();
    message.trips = object.trips?.map((e) => Trip.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** Trip management service. */
export type TripServiceDefinition = typeof TripServiceDefinition;
export const TripServiceDefinition = {
  name: "TripService",
  fullName: "maps.fleetengine.v1.TripService",
  methods: {
    /** Creates a trip in the Fleet Engine and returns the new trip. */
    createTrip: {
      name: "CreateTrip",
      requestType: CreateTripRequest,
      requestStream: false,
      responseType: Trip,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              58,
              4,
              116,
              114,
              105,
              112,
              34,
              30,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              105,
              112,
              115,
            ]),
          ],
          578365834: [
            Buffer.from([
              37,
              18,
              35,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get information about a single trip. */
    getTrip: {
      name: "GetTrip",
      requestType: GetTripRequest,
      requestStream: false,
      responseType: Trip,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              32,
              18,
              30,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              116,
              114,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Report billable trip usage. */
    reportBillableTrip: {
      name: "ReportBillableTrip",
      requestType: ReportBillableTripRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              50,
              58,
              1,
              42,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              105,
              108,
              108,
              97,
              98,
              108,
              101,
              84,
              114,
              105,
              112,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Get all the trips for a specific vehicle. */
    searchTrips: {
      name: "SearchTrips",
      requestType: SearchTripsRequest,
      requestStream: false,
      responseType: SearchTripsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              42,
              58,
              1,
              42,
              34,
              37,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              105,
              112,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
          578365834: [
            Buffer.from([
              37,
              18,
              35,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates trip data. */
    updateTrip: {
      name: "UpdateTrip",
      requestType: UpdateTripRequest,
      requestStream: false,
      responseType: Trip,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              38,
              58,
              4,
              116,
              114,
              105,
              112,
              26,
              30,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              116,
              114,
              105,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TripServiceImplementation<CallContextExt = {}> {
  /** Creates a trip in the Fleet Engine and returns the new trip. */
  createTrip(request: CreateTripRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Trip>>;
  /** Get information about a single trip. */
  getTrip(request: GetTripRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Trip>>;
  /** Report billable trip usage. */
  reportBillableTrip(
    request: ReportBillableTripRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Get all the trips for a specific vehicle. */
  searchTrips(
    request: SearchTripsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchTripsResponse>>;
  /** Updates trip data. */
  updateTrip(request: UpdateTripRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Trip>>;
}

export interface TripServiceClient<CallOptionsExt = {}> {
  /** Creates a trip in the Fleet Engine and returns the new trip. */
  createTrip(request: DeepPartial<CreateTripRequest>, options?: CallOptions & CallOptionsExt): Promise<Trip>;
  /** Get information about a single trip. */
  getTrip(request: DeepPartial<GetTripRequest>, options?: CallOptions & CallOptionsExt): Promise<Trip>;
  /** Report billable trip usage. */
  reportBillableTrip(
    request: DeepPartial<ReportBillableTripRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Get all the trips for a specific vehicle. */
  searchTrips(
    request: DeepPartial<SearchTripsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchTripsResponse>;
  /** Updates trip data. */
  updateTrip(request: DeepPartial<UpdateTripRequest>, options?: CallOptions & CallOptionsExt): Promise<Trip>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
